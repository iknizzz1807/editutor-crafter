{"html":"<h1 id=\"rpc-framework-design-document\">RPC Framework: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This system implements a simple Remote Procedure Call (RPC) framework that allows clients to invoke functions on remote servers as if they were local method calls. The key architectural challenge is transparently handling network communication, serialization, and error propagation while maintaining the illusion of local function invocation.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for Milestones 1, 2, and 3 - understanding the core RPC challenge</p>\n</blockquote>\n<h3 id=\"mental-model-the-postal-service-analogy\">Mental Model: The Postal Service Analogy</h3>\n<p>Understanding Remote Procedure Calls becomes intuitive when we think about how the postal service operates. Imagine you need to ask your grandmother for her famous cookie recipe, but she lives in another city. You can&#39;t simply walk into her kitchen and ask - there&#39;s a physical distance barrier that requires a communication protocol.</p>\n<p>In the traditional postal approach, you write a letter with your request, put it in an envelope with her address, mail it, and wait for her response letter with the recipe. This exchange involves several key elements that directly mirror RPC concepts: you need a <strong>standardized message format</strong> (letter writing conventions), a <strong>delivery mechanism</strong> (postal service), <strong>addressing</strong> (her mailing address), <strong>request identification</strong> (so she knows which letter she&#39;s responding to), and <strong>error handling</strong> (what happens if the letter gets lost?).</p>\n<p>The <strong>sender</strong> (you) doesn&#39;t need to understand the complex logistics of mail sorting, truck routes, or delivery scheduling - you just write the letter and trust the postal service to handle delivery. Similarly, the <strong>recipient</strong> (your grandmother) doesn&#39;t need to know how the letter traveled - she just reads your request and writes a response. This <strong>transparency</strong> is the fundamental goal of RPC: making remote function calls feel as natural as local function calls.</p>\n<p>However, unlike face-to-face conversation, postal communication introduces several challenges. Letters can get <strong>lost in transit</strong> (network failures), arrive <strong>out of order</strong> (if you send multiple requests), take <strong>unpredictable amounts of time</strong> (latency), or contain <strong>illegible handwriting</strong> (serialization errors). Your grandmother might be <strong>unavailable</strong> (server down), <strong>not understand your request</strong> (method not found), or <strong>unable to fulfill it</strong> (execution error). The postal service requires both parties to agree on message formatting, addressing schemes, and error handling procedures.</p>\n<p>In our RPC framework, the <strong>client</strong> acts like you writing letters with function call requests. The <strong>network transport</strong> serves as the postal service, routing messages between locations. The <strong>server</strong> functions like your grandmother, receiving requests and sending back responses. The <strong>message protocol</strong> defines the standardized format for requests and responses, just like letter-writing conventions ensure clear communication.</p>\n<p><img src=\"/api/project/rpc-basic/architecture-doc/asset?path=diagrams%2Fsystem-overview.svg\" alt=\"RPC Framework System Overview\"></p>\n<p>This analogy helps us understand why RPC frameworks need several sophisticated components that don&#39;t exist in local function calls. We need <strong>message serialization</strong> to convert function parameters into a format suitable for network transmission (like writing legibly). We need <strong>connection management</strong> to establish and maintain communication channels (like ensuring the postal service has correct addresses). We need <strong>error handling</strong> for all the ways remote communication can fail (like dealing with lost or delayed mail). Most importantly, we need <strong>transparency mechanisms</strong> that hide these complexities from the application developer, making remote calls look identical to local calls.</p>\n<h3 id=\"existing-rpc-approaches\">Existing RPC Approaches</h3>\n<p>The software industry has developed numerous approaches for enabling remote procedure calls, each with different trade-offs between simplicity, performance, and feature richness. Understanding these existing solutions helps us appreciate the design decisions in our educational RPC framework and provides context for why certain patterns have emerged as standards.</p>\n<p><strong>REST APIs with HTTP/JSON</strong> represent the most ubiquitous approach to remote communication in modern web applications. REST treats remote operations as HTTP requests to resource-oriented URLs, using standard HTTP verbs (GET, POST, PUT, DELETE) to indicate operation types. Parameters are typically passed as URL query parameters, request bodies, or path segments, with JSON serving as the serialization format for complex data structures.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>REST APIs</th>\n<th>Our Assessment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Learning Curve</strong></td>\n<td>Shallow - builds on familiar HTTP concepts</td>\n<td>Excellent for beginners</td>\n</tr>\n<tr>\n<td><strong>Tooling Support</strong></td>\n<td>Extensive - every language has HTTP libraries</td>\n<td>Universal availability</td>\n</tr>\n<tr>\n<td><strong>Performance</strong></td>\n<td>Moderate - HTTP overhead, JSON parsing costs</td>\n<td>Acceptable for most use cases</td>\n</tr>\n<tr>\n<td><strong>Type Safety</strong></td>\n<td>Weak - JSON is dynamically typed</td>\n<td>Requires careful validation</td>\n</tr>\n<tr>\n<td><strong>Transport</strong></td>\n<td>HTTP-only - bound to request/response model</td>\n<td>Limited flexibility</td>\n</tr>\n<tr>\n<td><strong>Discovery</strong></td>\n<td>Manual - developers must know endpoints</td>\n<td>No built-in service discovery</td>\n</tr>\n</tbody></table>\n<p>REST&#39;s primary strength lies in its <strong>conceptual simplicity</strong> and <strong>universal tooling support</strong>. Every programming language provides HTTP client libraries, making REST APIs immediately accessible. The <strong>stateless, cacheable</strong> nature of HTTP aligns well with web architecture patterns, and <strong>human-readable</strong> URLs and JSON payloads simplify debugging and testing. However, REST&#39;s resource-oriented model can feel <strong>unnatural for procedure-oriented operations</strong>, and the <strong>lack of formal contracts</strong> means API changes can break clients in subtle ways.</p>\n<p><strong>gRPC with Protocol Buffers</strong> represents Google&#39;s high-performance, strongly-typed approach to RPC. gRPC uses HTTP/2 as its transport layer, providing features like <strong>multiplexing, flow control, and header compression</strong>. Protocol Buffers serve as both the <strong>interface definition language</strong> (defining service contracts in <code>.proto</code> files) and the <strong>binary serialization format</strong>, offering <strong>strong typing, forward/backward compatibility, and compact wire encoding</strong>.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>gRPC</th>\n<th>Our Assessment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Performance</strong></td>\n<td>High - binary encoding, HTTP/2 multiplexing</td>\n<td>Excellent for high-throughput systems</td>\n</tr>\n<tr>\n<td><strong>Type Safety</strong></td>\n<td>Strong - generated client/server code</td>\n<td>Prevents many integration bugs</td>\n</tr>\n<tr>\n<td><strong>Tooling</strong></td>\n<td>Excellent - code generation, reflection, debugging</td>\n<td>Rich ecosystem</td>\n</tr>\n<tr>\n<td><strong>Learning Curve</strong></td>\n<td>Steep - requires Protocol Buffer knowledge</td>\n<td>Challenging for beginners</td>\n</tr>\n<tr>\n<td><strong>Transport</strong></td>\n<td>HTTP/2 required - complex proxy configuration</td>\n<td>Infrastructure complexity</td>\n</tr>\n<tr>\n<td><strong>Human Readability</strong></td>\n<td>Poor - binary format difficult to debug</td>\n<td>Harder to troubleshoot</td>\n</tr>\n</tbody></table>\n<p>gRPC excels in <strong>microservice architectures</strong> where <strong>performance and type safety</strong> are critical. The <strong>automatic code generation</strong> from <code>.proto</code> files ensures client and server implementations stay synchronized. <strong>Streaming support</strong> enables real-time communication patterns like chat systems or live data feeds. However, gRPC&#39;s <strong>binary format complicates debugging</strong>, and <strong>HTTP/2 requirements</strong> can create deployment challenges in environments with legacy proxy servers or firewalls.</p>\n<p><strong>JSON-RPC</strong> provides a lightweight, specification-based approach that directly mirrors traditional function call semantics. Unlike REST&#39;s resource orientation, JSON-RPC explicitly models <strong>method invocation with parameters and return values</strong>. The protocol defines standardized message formats for <strong>requests, responses, and errors</strong>, making implementations more consistent across languages and frameworks.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>JSON-RPC</th>\n<th>Our Assessment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Conceptual Model</strong></td>\n<td>Natural - direct function call mapping</td>\n<td>Intuitive for developers</td>\n</tr>\n<tr>\n<td><strong>Specification</strong></td>\n<td>Formal - well-defined message formats</td>\n<td>Promotes interoperability</td>\n</tr>\n<tr>\n<td><strong>Implementation</strong></td>\n<td>Simple - just JSON over HTTP/TCP/WebSocket</td>\n<td>Easy to implement correctly</td>\n</tr>\n<tr>\n<td><strong>Flexibility</strong></td>\n<td>High - transport-agnostic protocol</td>\n<td>Adaptable to different needs</td>\n</tr>\n<tr>\n<td><strong>Tooling</strong></td>\n<td>Limited - fewer frameworks than REST/gRPC</td>\n<td>Requires more manual work</td>\n</tr>\n<tr>\n<td><strong>Performance</strong></td>\n<td>Moderate - JSON overhead, no streaming</td>\n<td>Adequate for most applications</td>\n</tr>\n</tbody></table>\n<p>JSON-RPC strikes a <strong>balance between simplicity and formality</strong> that makes it an excellent educational choice. The <strong>specification provides clear guidance</strong> for message formats and error handling, while the <strong>transport independence</strong> allows implementations over TCP sockets, HTTP, WebSockets, or message queues. <strong>Batching support</strong> enables multiple method calls in a single request, reducing network round-trips for bulk operations.</p>\n<p><strong>Message Queue Systems</strong> like RabbitMQ, Apache Kafka, or Redis Pub/Sub take a fundamentally different approach, treating remote communication as <strong>asynchronous message passing</strong> rather than synchronous function calls. Clients publish <strong>request messages</strong> to queues, servers consume and process these messages, then publish <strong>response messages</strong> back to reply queues or topics.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Message Queues</th>\n<th>Our Assessment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Decoupling</strong></td>\n<td>Excellent - clients and servers independent</td>\n<td>Great for scalable architectures</td>\n</tr>\n<tr>\n<td><strong>Reliability</strong></td>\n<td>High - message persistence, delivery guarantees</td>\n<td>Handles failures gracefully</td>\n</tr>\n<tr>\n<td><strong>Scalability</strong></td>\n<td>Excellent - natural load balancing, fan-out</td>\n<td>Scales to high message volumes</td>\n</tr>\n<tr>\n<td><strong>Complexity</strong></td>\n<td>High - requires message broker infrastructure</td>\n<td>Significant operational overhead</td>\n</tr>\n<tr>\n<td><strong>Latency</strong></td>\n<td>Higher - broker adds network hops</td>\n<td>Not suitable for low-latency calls</td>\n</tr>\n<tr>\n<td><strong>Programming Model</strong></td>\n<td>Asynchronous - requires careful state management</td>\n<td>More complex application logic</td>\n</tr>\n</tbody></table>\n<p>Message queues excel in <strong>distributed systems</strong> where <strong>fault tolerance and scalability</strong> outweigh latency concerns. The <strong>broker-mediated communication</strong> provides <strong>natural load balancing</strong> and <strong>failure isolation</strong> - if one server instance crashes, others can continue processing queued messages. However, the <strong>asynchronous programming model</strong> requires applications to carefully manage <strong>request correlation and state</strong>, making simple function call patterns more complex to implement.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: Our educational RPC framework adopts JSON-RPC&#39;s message format because it provides <strong>formal specification guidance</strong> while remaining <strong>simple enough for beginners</strong> to implement without extensive tooling. We&#39;ll use <strong>TCP sockets for transport</strong> to focus on core RPC concepts rather than HTTP complexities, and <strong>synchronous request-response patterns</strong> to maintain familiar function call semantics.</p>\n</blockquote>\n<p>The choice of <strong>JSON-RPC over TCP</strong> for our educational framework reflects several pedagogical priorities. <strong>JSON serialization</strong> allows students to <strong>inspect wire format messages</strong> during debugging, unlike binary protocols that require specialized tools. <strong>TCP sockets</strong> expose <strong>fundamental networking concepts</strong> like connection management and byte stream handling, providing deeper systems understanding than HTTP abstraction layers. <strong>Synchronous patterns</strong> maintain the <strong>mental model of function calls</strong> that students already understand, avoiding the complexity of asynchronous programming and callback management.</p>\n<p><strong>Architecture Decision Records</strong></p>\n<blockquote>\n<p><strong>Decision: JSON-RPC Message Format</strong></p>\n<ul>\n<li><strong>Context</strong>: Need a message protocol that balances formal specification with educational clarity</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Custom binary protocol (maximum control, high complexity)</li>\n<li>HTTP REST with JSON (familiar, but resource-oriented doesn&#39;t match RPC semantics)</li>\n<li>JSON-RPC 2.0 specification (formal, function-call oriented)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: JSON-RPC 2.0 specification with minor adaptations</li>\n<li><strong>Rationale</strong>: Provides formal specification for message formats while maintaining human-readable JSON encoding that aids debugging and learning</li>\n<li><strong>Consequences</strong>: Students learn standard protocol patterns and can easily inspect/debug message exchanges, but JSON parsing adds some performance overhead</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Custom Binary</strong></td>\n<td>Maximum performance and control</td>\n<td>High complexity, no existing tooling, difficult to debug</td>\n</tr>\n<tr>\n<td><strong>HTTP REST</strong></td>\n<td>Universal tooling, familiar to web developers</td>\n<td>Resource-oriented model doesn&#39;t match function call semantics</td>\n</tr>\n<tr>\n<td><strong>JSON-RPC</strong></td>\n<td>Formal spec, function-call oriented, human-readable</td>\n<td>Less tooling than HTTP, moderate performance overhead</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: TCP Socket Transport</strong></p>\n<ul>\n<li><strong>Context</strong>: Need transport layer that exposes fundamental networking concepts for educational value</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>HTTP with standard libraries (simple, abstracted)</li>\n<li>Raw TCP sockets (educational, full control)</li>\n<li>WebSockets (real-time capable, browser-friendly)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Raw TCP sockets with JSON message framing</li>\n<li><strong>Rationale</strong>: Forces students to understand connection management, byte streams, and message framing - core networking concepts hidden by HTTP abstractions</li>\n<li><strong>Consequences</strong>: Students gain deeper networking understanding but must implement connection pooling and error handling manually</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>HTTP</strong></td>\n<td>Familiar, extensive tooling, handles framing automatically</td>\n<td>Hides networking concepts, adds protocol overhead</td>\n</tr>\n<tr>\n<td><strong>TCP Sockets</strong></td>\n<td>Educational value, full control, minimal overhead</td>\n<td>Requires manual connection and framing management</td>\n</tr>\n<tr>\n<td><strong>WebSockets</strong></td>\n<td>Real-time capable, familiar to web developers</td>\n<td>More complex than needed for basic RPC</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Synchronous Request-Response Pattern</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to choose between synchronous and asynchronous client API design</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Synchronous blocking calls (simple, familiar function semantics)</li>\n<li>Asynchronous with callbacks (scalable, complex error handling)</li>\n<li>Asynchronous with futures/promises (modern, requires concurrency understanding)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Synchronous blocking calls with configurable timeouts</li>\n<li><strong>Rationale</strong>: Maintains familiar function call semantics while teaching core RPC concepts without concurrent programming complexity</li>\n<li><strong>Consequences</strong>: Simple to understand and use, but limits scalability for high-concurrency applications</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Synchronous</strong></td>\n<td>Familiar function semantics, simple error handling</td>\n<td>Blocks calling thread, limits concurrency</td>\n</tr>\n<tr>\n<td><strong>Callbacks</strong></td>\n<td>Non-blocking, scalable</td>\n<td>Complex error handling, callback hell</td>\n</tr>\n<tr>\n<td><strong>Futures/Promises</strong></td>\n<td>Modern async patterns, composable</td>\n<td>Requires understanding of concurrent programming</td>\n</tr>\n</tbody></table>\n<p>These architectural decisions collectively create an RPC framework that <strong>prioritizes learning value over production features</strong>. Students will understand <strong>message serialization, network programming, and distributed error handling</strong> without being overwhelmed by <strong>performance optimizations, concurrent programming, or complex tooling requirements</strong>. The resulting system provides a solid foundation for understanding more sophisticated frameworks like gRPC or enterprise message queuing systems.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>JSON Handling</strong></td>\n<td><code>json</code> module (built-in)</td>\n<td><code>ujson</code> or <code>orjson</code> for performance</td>\n</tr>\n<tr>\n<td><strong>Socket Management</strong></td>\n<td><code>socket</code> module (built-in)</td>\n<td><code>asyncio</code> for async patterns</td>\n</tr>\n<tr>\n<td><strong>Logging</strong></td>\n<td><code>logging</code> module (built-in)</td>\n<td><code>structlog</code> for structured logs</td>\n</tr>\n<tr>\n<td><strong>Testing</strong></td>\n<td><code>unittest</code> (built-in)</td>\n<td><code>pytest</code> with fixtures</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended Project Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>rpc-framework/\n├── rpc/\n│   ├── __init__.py\n│   ├── protocol.py          ← Message formats and serialization (Milestone 1)\n│   ├── server.py           ← RPC server implementation (Milestone 2)  \n│   ├── client.py           ← RPC client implementation (Milestone 3)\n│   └── exceptions.py       ← Custom exception classes\n├── examples/\n│   ├── calculator_server.py ← Example server with math functions\n│   ├── calculator_client.py ← Example client usage\n│   └── echo_server.py      ← Simple echo service for testing\n├── tests/\n│   ├── test_protocol.py    ← Message format tests\n│   ├── test_server.py      ← Server functionality tests\n│   ├── test_client.py      ← Client functionality tests\n│   └── test_integration.py ← End-to-end RPC call tests\n└── README.md</code></pre></div>\n\n<p><strong>Core Exception Hierarchy:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc/exceptions.py - Complete exception infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all RPC-related errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCProtocolError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Errors related to message format or protocol violations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCTransportError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Errors related to network communication.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCTimeoutError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCTransportError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Request timeout exceeded.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCMethodError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Errors related to method execution.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, code, message, data</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> code</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"RPC Error </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Standard JSON-RPC error codes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorCode</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PARSE_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32700</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVALID_REQUEST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32600</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    METHOD_NOT_FOUND</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32601</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVALID_PARAMS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32602</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INTERNAL_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32603</span></span></code></pre></div>\n\n<p><strong>JSON Message Utilities:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc/protocol.py - Complete message handling infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict, Optional, Union</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> generate_request_id</span><span style=\"color:#E1E4E8\">() -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Generate unique request ID for RPC calls.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(uuid.uuid4())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_request_message</span><span style=\"color:#E1E4E8\">(method: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, params: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a JSON-RPC 2.0 request message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create message dict with jsonrpc version \"2.0\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add method name and request_id (generate if None)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add params only if not None (supports both list and dict params)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return complete request message dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_response_message</span><span style=\"color:#E1E4E8\">(request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, result: Any) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a JSON-RPC 2.0 success response message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create message dict with jsonrpc version \"2.0\" </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add matching request_id and result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return complete response message dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_error_message</span><span style=\"color:#E1E4E8\">(request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, code: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, data: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a JSON-RPC 2.0 error response message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create message dict with jsonrpc version \"2.0\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add matching request_id </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create error object with code and message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add data to error object if provided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return complete error response message dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> serialize_message</span><span style=\"color:#E1E4E8\">(message: Dict) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Serialize message to JSON bytes with length prefix.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Convert message dict to JSON string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Encode JSON string to UTF-8 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create length prefix (4-byte big-endian integer)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return length prefix + message bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use struct.pack('>I', length) for big-endian 32-bit int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> deserialize_message</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Deserialize JSON bytes to message dict.\"\"\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Decode UTF-8 bytes to JSON string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Parse JSON string to dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate required fields (jsonrpc, id)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return message dict or raise RPCProtocolError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>Socket Helper Utilities:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc/transport.py - Complete network transport utilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> struct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SocketHelper</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Utility class for socket operations with proper error handling.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> send_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Send all bytes, handling partial sends.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Set socket timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Track bytes sent with offset</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Loop until all bytes sent, handle EAGAIN/EWOULDBLOCK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Raise RPCTransportError on socket errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recv_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Receive exact number of bytes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Set socket timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Track bytes received with buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Loop until exact size received</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle connection closed (recv returns empty bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Raise RPCTransportError on socket errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recv_message</span><span style=\"color:#E1E4E8\">(sock: socket.socket, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Receive length-prefixed message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Receive 4-byte length prefix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Unpack big-endian integer from prefix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Receive message bytes of specified length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return message bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use struct.unpack('>I', prefix)[0] for big-endian 32-bit int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Language-Specific Implementation Hints:</strong></p>\n<ul>\n<li><strong>JSON Handling</strong>: Use <code>json.loads()</code> and <code>json.dumps()</code> for message serialization. Handle <code>json.JSONDecodeError</code> for malformed messages.</li>\n<li><strong>Socket Programming</strong>: Use <code>socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code> for TCP sockets. Always call <code>close()</code> in finally blocks.</li>\n<li><strong>Error Propagation</strong>: Wrap socket exceptions in custom <code>RPCTransportError</code> to provide consistent error handling across the framework.</li>\n<li><strong>Thread Safety</strong>: Use <code>threading.Lock()</code> if implementing concurrent request handling in the server.</li>\n<li><strong>Timeout Handling</strong>: Use <code>socket.settimeout()</code> for network operations and catch <code>socket.timeout</code> exceptions.</li>\n</ul>\n<p><strong>Development Workflow:</strong></p>\n<ol>\n<li><strong>Start with Protocol</strong>: Implement message creation and serialization functions first - these are the foundation for client and server.</li>\n<li><strong>Build Server Next</strong>: Create the method registry and request dispatcher - easier to test than client since you control both ends.</li>\n<li><strong>Add Client Last</strong>: Implement the proxy object and connection management - can test against your working server.</li>\n<li><strong>Test Integration</strong>: Write end-to-end tests that exercise client → server → client round trips with various scenarios.</li>\n</ol>\n<p><strong>Common Setup Mistakes to Avoid:</strong></p>\n<p>⚠️ <strong>Pitfall: Forgetting Message Framing</strong>\nTCP is a byte stream, not a message stream. Without length prefixes, you can&#39;t tell where one JSON message ends and the next begins. Always use length-prefixed framing.</p>\n<p>⚠️ <strong>Pitfall: Not Handling Partial Socket Operations</strong><br><code>socket.send()</code> and <code>socket.recv()</code> may not send/receive all requested bytes in a single call. Always loop until complete.</p>\n<p>⚠️ <strong>Pitfall: Mixing Bytes and Strings</strong>\nJSON serialization produces strings, but sockets require bytes. Always encode/decode at the socket boundary using UTF-8.</p>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all milestones - defines the scope and boundaries of our RPC framework implementation</p>\n</blockquote>\n<h3 id=\"mental-model-the-swiss-army-knife-vs-the-hammer\">Mental Model: The Swiss Army Knife vs. The Hammer</h3>\n<p>Think of our RPC framework like choosing between a Swiss Army knife and a hammer. A Swiss Army knife has dozens of tools - screwdrivers, scissors, can opener, magnifying glass - and can handle almost any situation you encounter. However, each tool is small and somewhat awkward to use. In contrast, a hammer does exactly one thing: drive nails. It&#39;s simple, reliable, and excellent at its specific job, but useless for cutting wire or opening bottles.</p>\n<p>Production RPC frameworks like gRPC are Swiss Army knives. They handle authentication, load balancing, circuit breakers, multiple serialization formats, streaming, compression, service discovery, and dozens of other concerns. They&#39;re incredibly powerful but also complex to understand and implement.</p>\n<p>Our educational RPC framework is the hammer. It does one thing well: allow a client to call a function on a remote server as if it were local. By focusing solely on this core mechanism, we can understand the fundamental principles without getting lost in production concerns. Once you master the hammer, you&#39;ll appreciate why the Swiss Army knife needs all those extra tools.</p>\n<h3 id=\"functional-goals\">Functional Goals</h3>\n<p>Our RPC framework must demonstrate the core concepts that make remote procedure calls possible. These goals define the minimum viable system that teaches the essential patterns and challenges of distributed function invocation.</p>\n<p><strong>Core RPC Semantics</strong></p>\n<p>The framework must provide the illusion of local function calls despite network boundaries. When a client calls <code>calculator.add(5, 3)</code>, it should feel identical to calling a local method, even though the actual computation happens on a remote server. This transparency is the defining characteristic of RPC systems.</p>\n<p>The system must support <strong>method registration</strong> on the server side, allowing developers to expose specific functions for remote invocation. A server should be able to register functions like <code>add</code>, <code>subtract</code>, <code>get_user</code>, or <code>process_payment</code> and make them available to remote clients through a simple registry mechanism.</p>\n<p><strong>JSON-RPC Protocol Implementation</strong></p>\n<p>We will implement a subset of the JSON-RPC 2.0 specification, which provides a lightweight, human-readable protocol for remote procedure calls. Our implementation must handle the three core message types defined by this specification.</p>\n<table>\n<thead>\n<tr>\n<th>Message Type</th>\n<th>Required Fields</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Request</td>\n<td><code>method</code>, <code>params</code>, <code>id</code></td>\n<td>Invoke remote function with parameters</td>\n</tr>\n<tr>\n<td>Response</td>\n<td><code>result</code>, <code>id</code></td>\n<td>Return successful function result</td>\n</tr>\n<tr>\n<td>Error</td>\n<td><code>error</code>, <code>id</code></td>\n<td>Report function execution or protocol errors</td>\n</tr>\n</tbody></table>\n<p>The protocol must support <strong>request-response correlation</strong> using unique request IDs. When a client sends a request with ID &quot;abc123&quot;, it must receive a response with the matching ID &quot;abc123&quot;. This correlation allows clients to handle multiple concurrent requests and match responses to their originating calls.</p>\n<p><strong>Network Transport and Serialization</strong></p>\n<p>The framework must implement <strong>TCP socket communication</strong> for reliable message delivery between clients and servers. TCP provides the ordered, reliable byte stream we need for RPC communication, handling packet loss, reordering, and corruption at the network level.</p>\n<p>All messages must use <strong>JSON serialization</strong> for cross-language compatibility and human readability during development. The system must handle serialization of common Python types including strings, numbers, lists, dictionaries, and <code>None</code> values.</p>\n<p>The implementation must solve the <strong>message framing problem</strong> - determining where one message ends and the next begins in a continuous byte stream. We&#39;ll use a simple length-prefix framing protocol where each message is preceded by a 4-byte header indicating the message size.</p>\n<p><strong>Error Handling and Propagation</strong></p>\n<p>The framework must provide comprehensive error handling that distinguishes between different failure modes and propagates appropriate error information back to clients.</p>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Example Causes</th>\n<th>Client Experience</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Protocol Errors</td>\n<td>Invalid JSON, missing fields</td>\n<td><code>RPCProtocolError</code> exception</td>\n</tr>\n<tr>\n<td>Transport Errors</td>\n<td>Connection dropped, network unreachable</td>\n<td><code>RPCTransportError</code> exception</td>\n</tr>\n<tr>\n<td>Method Errors</td>\n<td>Function not found, execution failed</td>\n<td><code>RPCMethodError</code> exception with details</td>\n</tr>\n<tr>\n<td>Timeout Errors</td>\n<td>Server too slow, network congestion</td>\n<td><code>RPCTimeoutError</code> exception</td>\n</tr>\n</tbody></table>\n<p>Each error type must include sufficient information for debugging while maintaining security boundaries. Method execution errors should include the error message and type information, but not sensitive server-side details like file paths or stack traces.</p>\n<p><strong>Client Proxy Interface</strong></p>\n<p>The client must provide a <strong>proxy object</strong> that converts method calls into RPC requests transparently. Instead of manually constructing JSON messages, developers should write natural Python code:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># This natural syntax...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> client.calculator.add(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ...should automatically generate and send this RPC request:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># {\"method\": \"add\", \"params\": [5, 3], \"id\": \"req_001\"}</span></span></code></pre></div>\n\n<p>The proxy must handle <strong>timeout management</strong>, raising <code>RPCTimeoutError</code> when remote calls exceed the configured deadline. This prevents clients from waiting indefinitely for servers that have crashed or become unresponsive.</p>\n<p><strong>Server Method Registry and Dispatch</strong></p>\n<p>The server must implement a <strong>method registry</strong> that maps string method names to callable Python functions. The registry should support simple registration syntax:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">server.register_method(</span><span style=\"color:#9ECBFF\">\"add\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">lambda</span><span style=\"color:#E1E4E8\"> a, b: a </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> b)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">server.register_method(</span><span style=\"color:#9ECBFF\">\"get_user\"</span><span style=\"color:#E1E4E8\">, user_service.get_user_by_id)</span></span></code></pre></div>\n\n<p>The server must implement <strong>request dispatch logic</strong> that parses incoming messages, looks up the requested method in the registry, invokes the method with the provided parameters, and serializes the result back to the client. This dispatch process must handle parameter validation, method execution, and error response generation.</p>\n<h3 id=\"non-goals\">Non-Goals</h3>\n<p>Understanding what we will NOT implement is equally important for maintaining focus and managing scope. These exclusions allow us to concentrate on core RPC concepts without getting distracted by production concerns.</p>\n<p><strong>Production Reliability Features</strong></p>\n<p>We will not implement <strong>authentication or authorization</strong> mechanisms. Our framework assumes a trusted network environment where all clients are permitted to invoke all registered methods. Production systems require sophisticated access control, API keys, OAuth tokens, or certificate-based authentication, but these concerns are orthogonal to understanding RPC fundamentals.</p>\n<p>The framework will not include <strong>encryption or transport security</strong>. All communication happens in plaintext over TCP sockets. Production RPC systems use TLS encryption to protect sensitive data in transit, but implementing cryptography would obscure the core message exchange patterns we&#39;re trying to learn.</p>\n<p>We will not implement <strong>connection pooling or persistent connections</strong>. Each RPC call will establish a new TCP connection, send the request, receive the response, and close the connection. This approach is inefficient but simpler to understand and debug. Production systems maintain connection pools to amortize connection establishment costs across multiple calls.</p>\n<p><strong>Performance and Scalability Features</strong></p>\n<p>The system will not support <strong>asynchronous or streaming calls</strong>. Every RPC call follows a simple synchronous request-response pattern where the client blocks until the server returns a result. Asynchronous RPC systems use callbacks, futures, or async/await patterns to handle multiple concurrent calls without blocking threads.</p>\n<p>We will not implement <strong>load balancing or service discovery</strong>. Clients must know the exact IP address and port of the server they want to contact. Production systems use service registries, DNS-based discovery, or load balancers to distribute requests across multiple server instances.</p>\n<p>The framework will not include <strong>circuit breakers or retry mechanisms</strong>. If a server is unreachable or returns an error, the client will immediately report the failure to the application. Production systems implement sophisticated retry policies with exponential backoff, circuit breakers that stop calling failing services, and graceful degradation strategies.</p>\n<p><strong>Advanced Protocol Features</strong></p>\n<p>We will not support <strong>binary serialization formats</strong> like Protocol Buffers, MessagePack, or Apache Avro. JSON serialization is less efficient but much easier to debug and understand. Binary formats require schema definitions, code generation, and specialized tooling that would complicate our learning objectives.</p>\n<p>The system will not implement <strong>batch requests or pipelining</strong>. Each RPC call requires a separate network round-trip. Some RPC protocols allow clients to send multiple requests in a single message or send requests without waiting for responses, but these optimizations add protocol complexity.</p>\n<p>We will not support <strong>bidirectional communication or server push</strong>. Communication flows strictly from client to server and back. Modern RPC frameworks support streaming responses, server-initiated callbacks, and full-duplex communication channels, but these patterns require more sophisticated connection management.</p>\n<p><strong>Error Recovery and Reliability</strong></p>\n<p>The framework will not implement <strong>automatic retry logic</strong>. If a network error occurs or a server becomes unavailable, the client will immediately raise an exception. Production systems implement retry policies that distinguish between transient errors (network congestion, temporary server overload) and permanent errors (method not found, invalid parameters).</p>\n<p>We will not include <strong>distributed tracing or monitoring</strong> capabilities. Each RPC call happens in isolation without correlation IDs, performance metrics, or observability hooks. Production systems instrument every remote call with tracing data to help debug performance issues and understand system behavior.</p>\n<p>The system will not support <strong>graceful shutdown or connection draining</strong>. Servers will terminate immediately when stopped, potentially interrupting in-flight requests. Production servers implement graceful shutdown sequences that stop accepting new requests while allowing existing requests to complete.</p>\n<p><strong>Multi-Language and Compatibility Features</strong></p>\n<p>While our protocol uses JSON and could theoretically support multiple languages, we will not provide <strong>client libraries for other languages</strong>. The implementation will be Python-only, with Python-specific error types, proxy mechanisms, and API patterns.</p>\n<p>We will not implement <strong>schema validation or interface definition languages</strong>. Methods can be called with any parameters, and type checking happens at runtime during method execution. Production RPC systems often use schema languages like Protocol Buffer definitions or OpenAPI specifications to define and validate interfaces.</p>\n<blockquote>\n<p><strong>Design Principle: Educational Focus Over Production Readiness</strong></p>\n<p>Every non-goal represents a deliberate choice to prioritize learning over completeness. Production RPC frameworks are complex because distributed systems are complex. By temporarily ignoring these concerns, we can focus on the core insight: how to make a function call traverse a network boundary while maintaining the illusion of local execution.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This framework serves as a foundation for understanding distributed systems concepts. The implementation should be straightforward enough for junior developers to complete in a few days while demonstrating the essential patterns used in production RPC systems.</p>\n<p><strong>A. Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Serialization</td>\n<td>JSON with <code>json</code> module</td>\n<td>MessagePack or Protocol Buffers</td>\n<td>JSON ✓</td>\n</tr>\n<tr>\n<td>Transport</td>\n<td>Raw TCP sockets with <code>socket</code> module</td>\n<td>HTTP with <code>requests</code> library</td>\n<td>TCP ✓</td>\n</tr>\n<tr>\n<td>Threading</td>\n<td>Single-threaded blocking server</td>\n<td><code>threading</code> or <code>asyncio</code> for concurrency</td>\n<td>Single-threaded ✓</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Exception hierarchy with custom types</td>\n<td>Result types or error codes</td>\n<td>Exceptions ✓</td>\n</tr>\n<tr>\n<td>Message Framing</td>\n<td>Length-prefix (4 bytes + payload)</td>\n<td>Delimiter-based or HTTP chunking</td>\n<td>Length-prefix ✓</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File Structure</strong></p>\n<p>The codebase should be organized into focused modules that separate concerns and make testing easier:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>rpc_framework/\n├── __init__.py                 # Main package exports\n├── protocol.py                 # Message formats and serialization\n├── errors.py                   # Exception hierarchy\n├── server.py                   # RPC server implementation\n├── client.py                   # RPC client and proxy\n├── utils.py                    # Socket helpers and utilities\n└── examples/\n    ├── calculator_server.py    # Example server with math functions\n    ├── calculator_client.py    # Example client usage\n    └── test_integration.py     # End-to-end integration tests</code></pre></div>\n\n<p>This structure separates the protocol definition from the client and server implementations, making it easier to understand each component independently.</p>\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p><strong>Socket Helper Utilities (<code>utils.py</code>)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> struct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SocketHelper</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Utility functions for reliable socket communication with timeouts.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> send_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, timeout: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Send all bytes, handling partial sends and timeouts.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            sock: Connected socket</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            data: Bytes to send</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            timeout: Maximum time to wait (None for blocking)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            RPCTransportError: If send fails or times out</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> timeout </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sock.settimeout(timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_sent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> total_sent </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(data):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                sent </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sock.send(data[total_sent:])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> sent </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#9ECBFF\">\"Socket connection broken\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                total_sent </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> sent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> socket.timeout:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTimeoutError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Send timeout after </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">timeout</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">s\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> socket.error </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Send failed: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recv_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, timeout: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Receive exactly size bytes, handling partial receives.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            sock: Connected socket</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            size: Number of bytes to receive</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            timeout: Maximum time to wait</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Exact number of bytes requested</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            RPCTransportError: If receive fails or connection closes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            RPCTimeoutError: If receive times out</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> timeout </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sock.settimeout(timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        chunks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bytes_received </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> bytes_received </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> size:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sock.recv(size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> bytes_received)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> chunk:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#9ECBFF\">\"Connection closed by peer\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                chunks.append(chunk)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                bytes_received </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(chunk)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> socket.timeout:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTimeoutError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Receive timeout after </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">timeout</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">s\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> socket.error </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Receive failed: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">.join(chunks)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recv_message</span><span style=\"color:#E1E4E8\">(sock: socket.socket, timeout: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Receive a length-prefixed message.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Protocol: 4-byte length (network byte order) + message payload</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            sock: Connected socket</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            timeout: Maximum time to wait</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Message payload bytes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # First receive the 4-byte length header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SocketHelper.recv_all(sock, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> struct.unpack(</span><span style=\"color:#9ECBFF\">'!I'</span><span style=\"color:#E1E4E8\">, length_data)[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Validate message length to prevent memory attacks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> message_length </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># 1MB limit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> RPCProtocolError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Message too large: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">message_length</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Then receive the actual message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> SocketHelper.recv_all(sock, message_length, timeout)</span></span></code></pre></div>\n\n<p><strong>Error Hierarchy (<code>errors.py</code>)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all RPC-related errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCProtocolError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Errors in message format or protocol violations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCTransportError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Network communication errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCTimeoutError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Request timeout errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCMethodError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Method execution errors with JSON-RPC error details.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, code: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, data</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"RPC Method Error [</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">]: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> code</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorCode</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Standard JSON-RPC error codes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PARSE_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32700</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVALID_REQUEST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32600</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    METHOD_NOT_FOUND</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32601</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVALID_PARAMS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32602</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INTERNAL_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32603</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p><strong>Protocol Message Handling (<code>protocol.py</code>)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> struct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> generate_request_id</span><span style=\"color:#E1E4E8\">() -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Generate a unique request ID for correlating requests and responses.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Unique string identifier</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate a unique ID using uuid4() and return as string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use uuid.uuid4().hex for a simple string representation</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_request_message</span><span style=\"color:#E1E4E8\">(method: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, params: Any, request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a JSON-RPC request message.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        method: Remote method name to invoke</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        params: Parameters to pass to method (list or dict)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        request_id: Unique identifier for this request</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Dictionary representing JSON-RPC request</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create dictionary with required JSON-RPC fields:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - \"jsonrpc\": \"2.0\" (protocol version)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - \"method\": method name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - \"params\": parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - \"id\": request_id</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_response_message</span><span style=\"color:#E1E4E8\">(request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, result: Any) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a JSON-RPC response message for successful calls.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        request_id: ID from the original request</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        result: Return value from method execution</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Dictionary representing JSON-RPC response</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create dictionary with required JSON-RPC response fields:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - \"jsonrpc\": \"2.0\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - \"result\": the return value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - \"id\": request_id</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_error_message</span><span style=\"color:#E1E4E8\">(request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, code: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, data: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a JSON-RPC error message.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        request_id: ID from the original request</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        code: Standard error code (see ErrorCode class)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        message: Human-readable error description</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        data: Optional additional error information</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Dictionary representing JSON-RPC error</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create dictionary with JSON-RPC error structure:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - \"jsonrpc\": \"2.0\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - \"error\": {\"code\": code, \"message\": message, \"data\": data}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - \"id\": request_id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Note: Only include \"data\" field if data is not None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> serialize_message</span><span style=\"color:#E1E4E8\">(message: Dict) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert message dictionary to length-prefixed bytes for network transmission.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Protocol: 4-byte length header (network byte order) + JSON payload</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        message: Dictionary to serialize</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Length-prefixed message bytes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        RPCProtocolError: If JSON serialization fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Convert message dict to JSON string using json.dumps()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Encode JSON string to UTF-8 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate message length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Pack length as 4-byte network byte order integer using struct.pack('!I', length)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Concatenate length header + message bytes and return</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> deserialize_message</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parse bytes to message dictionary.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        data: Raw message bytes (no length prefix)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Parsed message dictionary</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        RPCProtocolError: If JSON parsing fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Decode bytes to UTF-8 string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Parse JSON string to dictionary using json.loads()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate that result is a dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the parsed dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Wrap json.loads() in try/except and raise RPCProtocolError for invalid JSON</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<p><strong>Socket Programming in Python:</strong></p>\n<ul>\n<li>Use <code>socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code> for TCP sockets</li>\n<li>Call <code>sock.bind((&#39;localhost&#39;, port))</code> and <code>sock.listen(1)</code> to create a server</li>\n<li>Use <code>sock.accept()</code> to wait for client connections (returns new socket + address)</li>\n<li>Call <code>sock.connect((host, port))</code> from client to establish connection</li>\n<li>Always call <code>sock.close()</code> in a <code>finally</code> block or use <code>with</code> statement</li>\n</ul>\n<p><strong>JSON Serialization:</strong></p>\n<ul>\n<li><code>json.dumps(obj)</code> converts Python object to JSON string</li>\n<li><code>json.loads(string)</code> parses JSON string to Python object</li>\n<li>JSON supports: strings, numbers, booleans, None (becomes null), lists, dictionaries</li>\n<li>JSON cannot serialize: functions, classes, bytes, datetime objects</li>\n</ul>\n<p><strong>Struct for Binary Data:</strong></p>\n<ul>\n<li><code>struct.pack(&#39;!I&#39;, value)</code> packs integer as 4-byte network byte order</li>\n<li><code>struct.unpack(&#39;!I&#39;, bytes)[0]</code> unpacks 4-byte network byte order to integer</li>\n<li>The <code>!</code> means network byte order (big-endian)</li>\n<li>The <code>I</code> means unsigned 32-bit integer</li>\n</ul>\n<p><strong>F. Milestone Checkpoints</strong></p>\n<p><strong>After Milestone 1 (Message Protocol):</strong></p>\n<ul>\n<li>Run: <code>python -c &quot;from protocol import *; print(create_request_message(&#39;add&#39;, [1,2], &#39;test&#39;))&quot;</code></li>\n<li>Expected: <code>{&#39;jsonrpc&#39;: &#39;2.0&#39;, &#39;method&#39;: &#39;add&#39;, &#39;params&#39;: [1, 2], &#39;id&#39;: &#39;test&#39;}</code></li>\n<li>Test serialization round-trip: message → serialize → deserialize → should equal original</li>\n<li>Verify length-prefix format: serialized message should start with 4-byte length</li>\n</ul>\n<p><strong>After Milestone 2 (Server Implementation):</strong></p>\n<ul>\n<li>Run: <code>python calculator_server.py</code> (should start server on localhost:8000)</li>\n<li>Test with telnet: <code>telnet localhost 8000</code></li>\n<li>Send raw JSON-RPC request and verify you get a JSON-RPC response</li>\n<li>Server should handle multiple sequential connections (connect, call, disconnect, repeat)</li>\n</ul>\n<p><strong>After Milestone 3 (Client Implementation):</strong></p>\n<ul>\n<li>Run server in one terminal: <code>python calculator_server.py</code></li>\n<li>Run client in another: <code>python calculator_client.py</code></li>\n<li>Expected: Client should print results like &quot;5 + 3 = 8&quot;</li>\n<li>Test timeout: Stop server, client should raise <code>RPCTimeoutError</code></li>\n<li>Test invalid method: Call non-existent method, should raise <code>RPCMethodError</code></li>\n</ul>\n<p><strong>G. Debugging Tips</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Connection refused&quot;</td>\n<td>Server not running</td>\n<td>Check if server process is active</td>\n<td>Start server first</td>\n</tr>\n<tr>\n<td>&quot;JSON decode error&quot;</td>\n<td>Malformed message</td>\n<td>Print raw bytes before deserializing</td>\n<td>Fix message construction</td>\n</tr>\n<tr>\n<td>Client hangs forever</td>\n<td>Wrong message length</td>\n<td>Verify 4-byte length header matches payload</td>\n<td>Use <code>struct.pack(&#39;!I&#39;, len(data))</code></td>\n</tr>\n<tr>\n<td>&quot;Method not found&quot;</td>\n<td>Method not registered</td>\n<td>Check server method registry</td>\n<td>Call <code>server.register_method()</code></td>\n</tr>\n<tr>\n<td>Partial message received</td>\n<td>Not using <code>recv_all</code></td>\n<td>Use provided <code>SocketHelper.recv_all()</code></td>\n<td>Always receive exact byte count</td>\n</tr>\n<tr>\n<td>&quot;Broken pipe&quot; error</td>\n<td>Client disconnected early</td>\n<td>Check client timeout settings</td>\n<td>Increase timeout or fix server speed</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Learning Checkpoint</strong>: By the end of this implementation, you should understand how network boundaries affect function calls, why serialization is necessary, how to correlate requests with responses, and what kinds of errors can occur in distributed systems. These concepts form the foundation for understanding more sophisticated distributed systems patterns.</p>\n</blockquote>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for Milestones 1, 2, and 3 - establishes the overall system structure and component responsibilities</p>\n</blockquote>\n<p>The RPC Framework consists of three primary components that work together to enable transparent remote method invocation. Understanding how these components interact and their individual responsibilities is crucial for successful implementation. This architecture follows a clear separation of concerns, where each component has a well-defined role in the overall RPC communication process.</p>\n<h3 id=\"component-overview\">Component Overview</h3>\n<p>Think of our RPC framework as a <strong>telephone system connecting different offices</strong>. The message protocol acts like the standardized language and format everyone uses when making calls. The server is like a corporate switchboard operator who receives calls, understands what department the caller needs, and routes them to the right person. The client is like an executive assistant who knows how to dial the switchboard, speak the standard language, and handle the responses on behalf of their boss.</p>\n<p>This mental model helps illustrate the key principle: <strong>each component has a single, focused responsibility</strong> that contributes to the illusion of local method calls across a network boundary.</p>\n<h4 id=\"message-protocol-component\">Message Protocol Component</h4>\n<p>The <strong>message protocol component</strong> serves as the foundation layer that defines how RPC communication is structured and serialized. This component establishes the wire format and message structure that both client and server must understand. It acts as the common language that enables interoperability between different RPC endpoints.</p>\n<p>The protocol component&#39;s primary responsibilities include defining the JSON-RPC message formats, handling message serialization and deserialization, implementing message framing for TCP streams, and providing error code definitions. This component ensures that all communication follows a consistent, predictable structure that can be reliably parsed and understood by both ends of the connection.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Key Functions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Message Structure</td>\n<td>Defines request, response, and error message formats</td>\n<td><code>create_request_message</code>, <code>create_response_message</code>, <code>create_error_message</code></td>\n</tr>\n<tr>\n<td>Serialization</td>\n<td>Converts messages to/from wire format</td>\n<td><code>serialize_message</code>, <code>deserialize_message</code></td>\n</tr>\n<tr>\n<td>Message Framing</td>\n<td>Handles length-prefixed message boundaries</td>\n<td>Built into serialize/deserialize functions</td>\n</tr>\n<tr>\n<td>Request ID Management</td>\n<td>Generates unique identifiers for request correlation</td>\n<td><code>generate_request_id</code></td>\n</tr>\n<tr>\n<td>Error Classification</td>\n<td>Defines standard error codes and formats</td>\n<td><code>ErrorCode</code> constants</td>\n</tr>\n</tbody></table>\n<p>The protocol component must handle several critical aspects of RPC communication. <strong>Message framing</strong> solves the fundamental problem of determining where one message ends and another begins in a TCP byte stream. Since TCP provides a stream of bytes without message boundaries, we use a length prefix approach where each message is preceded by a 4-byte header indicating the message size.</p>\n<p><strong>Request ID correlation</strong> ensures that responses can be matched to their corresponding requests, especially important when multiple requests are in flight simultaneously. Each request receives a unique identifier that must be echoed back in the response, allowing the client to properly route responses to waiting callers.</p>\n<h4 id=\"server-component\">Server Component</h4>\n<p>The <strong>server component</strong> acts as the RPC service provider, accepting incoming connections and executing remote method calls. Think of it as a <strong>receptionist and call routing system</strong> - it listens for incoming requests, understands what the client wants to do, finds the right function to handle that request, and sends back the appropriate response.</p>\n<p>The server&#39;s architecture centers around the concept of a <strong>method registry</strong> - a mapping from string names to callable Python functions. When a client requests a method call, the server looks up the method name in its registry, validates the parameters, executes the function, and returns the result or error.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Implementation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection Management</td>\n<td>Accept and handle TCP connections</td>\n<td>Single-threaded with connection reuse</td>\n</tr>\n<tr>\n<td>Method Registry</td>\n<td>Map method names to callable functions</td>\n<td>Dictionary-based lookup</td>\n</tr>\n<tr>\n<td>Request Processing</td>\n<td>Parse messages and dispatch to handlers</td>\n<td>Sequential message processing</td>\n</tr>\n<tr>\n<td>Parameter Validation</td>\n<td>Ensure method calls have correct parameters</td>\n<td>Runtime type checking</td>\n</tr>\n<tr>\n<td>Response Generation</td>\n<td>Create and send response messages</td>\n<td>Automatic serialization and framing</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Convert exceptions to RPC error responses</td>\n<td>Structured error code mapping</td>\n</tr>\n</tbody></table>\n<p>The server follows a <strong>synchronous, single-threaded model</strong> for simplicity. Each incoming connection is handled sequentially, processing one request at a time before moving to the next. This design choice eliminates concurrency complexity while still providing a functional RPC service suitable for learning purposes.</p>\n<p><strong>Method registration</strong> happens at server startup, where application code registers functions by providing a string name and a callable object. The server stores these mappings and uses them to dispatch incoming requests to the appropriate handlers.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: The single-threaded server design prioritizes simplicity over performance. Real-world RPC servers would use threading or async I/O, but for educational purposes, the sequential model makes debugging easier and eliminates race conditions.</p>\n</blockquote>\n<h4 id=\"client-component\">Client Component</h4>\n<p>The <strong>client component</strong> provides the caller-side interface for making RPC calls. Its primary goal is to make remote method invocation feel as natural as calling a local function. Think of the client as a <strong>personal secretary</strong> who handles all the complex details of making phone calls - they know the right numbers to dial, speak the proper protocol language, wait for responses, and handle any problems that arise.</p>\n<p>The client&#39;s most important feature is <strong>method proxying</strong> - the ability to intercept method calls on a proxy object and convert them into RPC requests. When application code calls <code>proxy.calculate(5, 3)</code>, the client automatically creates an RPC request message, sends it to the server, waits for the response, and returns the result as if the method had been executed locally.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Key Mechanisms</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection Management</td>\n<td>Establish and maintain TCP connections</td>\n<td>Socket lifecycle management</td>\n</tr>\n<tr>\n<td>Method Proxying</td>\n<td>Convert method calls to RPC requests</td>\n<td>Python <code>__getattr__</code> magic method</td>\n</tr>\n<tr>\n<td>Request Correlation</td>\n<td>Track pending requests by ID</td>\n<td>Dictionary mapping request IDs to futures</td>\n</tr>\n<tr>\n<td>Timeout Handling</td>\n<td>Abort requests that take too long</td>\n<td>Socket timeout configuration</td>\n</tr>\n<tr>\n<td>Response Processing</td>\n<td>Convert RPC responses back to return values</td>\n<td>Automatic deserialization</td>\n</tr>\n<tr>\n<td>Error Translation</td>\n<td>Convert RPC errors to Python exceptions</td>\n<td>Custom exception hierarchy</td>\n</tr>\n</tbody></table>\n<p><strong>Connection management</strong> in the client involves establishing TCP connections to the server and handling connection lifecycle. For simplicity, our client creates a new connection for each RPC call, though production systems would typically use connection pooling for better performance.</p>\n<p><strong>Timeout handling</strong> is critical for preventing client applications from hanging indefinitely when servers become unresponsive. The client sets socket timeouts and raises <code>RPCTimeoutError</code> exceptions when requests exceed their deadline.</p>\n<blockquote>\n<p><strong>Architecture Decision: Synchronous vs Asynchronous Client API</strong></p>\n<ul>\n<li><strong>Context</strong>: Clients can provide either blocking method calls or async/callback-based APIs</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Synchronous blocking calls that wait for responses</li>\n<li>Asynchronous calls with callbacks or futures</li>\n<li>Both options with a configuration flag</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Synchronous blocking calls only</li>\n<li><strong>Rationale</strong>: Blocking calls are much simpler to implement and use, matching the mental model of &quot;remote calls that work like local calls.&quot; Async support adds significant complexity in error handling, timeout management, and API design.</li>\n<li><strong>Consequences</strong>: Enables simple, intuitive client code but limits performance in scenarios requiring many concurrent calls</li>\n</ul>\n</blockquote>\n<h3 id=\"component-interaction-patterns\">Component Interaction Patterns</h3>\n<p>The three components interact through well-defined interfaces and protocols. Understanding these interaction patterns is crucial for implementing each component correctly and debugging issues that span component boundaries.</p>\n<p><strong>Request Flow</strong> follows a predictable sequence: the client proxy converts method calls to protocol messages, sends them over the network to the server, which deserializes the messages, executes the requested methods, and sends back protocol-formatted responses. Each step in this flow has specific responsibilities and error handling requirements.</p>\n<p><strong>Error Propagation</strong> must work correctly across component boundaries. Server-side exceptions become RPC error messages, which the client converts back to Python exceptions. This requires consistent error classification and proper serialization of error details.</p>\n<p><strong>State Management</strong> is distributed across components. The protocol component is stateless, handling individual messages independently. The server maintains method registry state and connection state. The client maintains connection state and tracks pending requests by ID.</p>\n<p><img src=\"/api/project/rpc-basic/architecture-doc/asset?path=diagrams%2Fsystem-overview.svg\" alt=\"RPC Framework System Overview\"></p>\n<h3 id=\"recommended-file-structure\">Recommended File Structure</h3>\n<p>Organizing the RPC framework code into logical modules makes the implementation more maintainable and helps separate concerns clearly. The recommended structure follows Python packaging conventions while grouping related functionality together.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>rpc_framework/\n├── __init__.py                 # Package initialization and public API\n├── protocol.py                 # Message protocol implementation\n├── server.py                   # RPC server implementation  \n├── client.py                   # RPC client implementation\n├── exceptions.py               # Exception hierarchy and error codes\n├── utils.py                    # Socket utilities and helpers\n└── examples/\n    ├── __init__.py\n    ├── calculator_server.py    # Example server with math functions\n    ├── calculator_client.py    # Example client usage\n    └── test_integration.py     # End-to-end integration tests</code></pre></div>\n\n<p>This file organization supports the natural development progression through the three milestones. Each major component lives in its own module, making it easy to focus on one piece at a time while maintaining clear interfaces between components.</p>\n<h4 id=\"core-module-responsibilities\">Core Module Responsibilities</h4>\n<p><strong>The <code>protocol.py</code> module</strong> (Milestone 1) contains all message format definitions, serialization functions, and protocol constants. This module should be completely independent of networking code, focusing purely on message structure and wire format encoding. It exports the message creation functions, serialization utilities, and error code constants that other modules depend on.</p>\n<p><strong>The <code>server.py</code> module</strong> (Milestone 2) implements the RPC server class, method registry, and request dispatch logic. This module imports the protocol module for message handling but is independent of client-side code. It exports the main server class and any server-specific configuration options.</p>\n<p><strong>The <code>client.py</code> module</strong> (Milestone 3) implements the RPC client class, proxy object, and connection management. This module imports the protocol module for message handling but is independent of server-side code. It exports the main client class and proxy object that application code interacts with.</p>\n<p><strong>The <code>exceptions.py</code> module</strong> defines the complete exception hierarchy used throughout the framework. This includes both protocol-level errors (like <code>RPCProtocolError</code>) and application-level errors (like <code>RPCMethodError</code>). Having all exceptions in one module makes error handling consistent across components.</p>\n<p><strong>The <code>utils.py</code> module</strong> contains networking utilities and helper functions shared by both client and server. This includes the <code>SocketHelper</code> class with functions like <code>send_all</code>, <code>recv_all</code>, and <code>recv_message</code> that handle the low-level details of TCP communication with proper error handling.</p>\n<table>\n<thead>\n<tr>\n<th>Module</th>\n<th>Primary Classes</th>\n<th>Key Functions</th>\n<th>Dependencies</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>protocol.py</code></td>\n<td><code>ErrorCode</code></td>\n<td><code>create_request_message</code>, <code>serialize_message</code>, <code>generate_request_id</code></td>\n<td>None (pure protocol)</td>\n</tr>\n<tr>\n<td><code>server.py</code></td>\n<td><code>RPCServer</code></td>\n<td><code>register_method</code>, <code>start_server</code>, <code>handle_request</code></td>\n<td>protocol, utils, exceptions</td>\n</tr>\n<tr>\n<td><code>client.py</code></td>\n<td><code>RPCClient</code>, <code>RPCProxy</code></td>\n<td><code>call_method</code>, <code>connect</code>, <code>__getattr__</code></td>\n<td>protocol, utils, exceptions</td>\n</tr>\n<tr>\n<td><code>exceptions.py</code></td>\n<td><code>RPCError</code>, <code>RPCTimeoutError</code>, etc.</td>\n<td>Exception constructors</td>\n<td>None</td>\n</tr>\n<tr>\n<td><code>utils.py</code></td>\n<td><code>SocketHelper</code></td>\n<td><code>send_all</code>, <code>recv_all</code>, <code>recv_message</code></td>\n<td>socket, struct</td>\n</tr>\n</tbody></table>\n<h4 id=\"development-workflow\">Development Workflow</h4>\n<p>The recommended file structure supports a natural development progression where each milestone builds on the previous one. <strong>Milestone 1</strong> focuses entirely on <code>protocol.py</code> and <code>exceptions.py</code>, allowing you to perfect message handling before dealing with networking complexity. <strong>Milestone 2</strong> adds <code>server.py</code> and the networking parts of <code>utils.py</code>, building the service side of the RPC system. <strong>Milestone 3</strong> completes the framework by implementing <code>client.py</code> and the proxy mechanism.</p>\n<p>This structure also supports good testing practices. Each module can be unit tested independently, and the <code>examples/</code> directory provides integration tests that exercise the complete system. The examples serve both as test cases and as documentation showing how to use the framework.</p>\n<blockquote>\n<p><strong>Implementation Insight</strong>: Start each milestone by defining the public interface in <code>__init__.py</code>. This forces you to think about what other modules need from each component and helps maintain clean separation of concerns.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The high-level architecture provides the foundation for implementing a working RPC framework. This guidance covers technology choices, starter code structure, and practical implementation approaches for each component.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Approach</th>\n<th>Advanced Alternative</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Message Protocol</td>\n<td>JSON with length-prefix framing</td>\n<td>MessagePack or Protocol Buffers</td>\n</tr>\n<tr>\n<td>Server Transport</td>\n<td>Raw TCP sockets with blocking I/O</td>\n<td>Async I/O with asyncio</td>\n</tr>\n<tr>\n<td>Client Transport</td>\n<td>Raw TCP sockets with timeouts</td>\n<td>HTTP/2 or connection pooling</td>\n</tr>\n<tr>\n<td>Serialization</td>\n<td>Python json module</td>\n<td>Custom binary protocol</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Exception-based with structured errors</td>\n<td>Result types or error codes</td>\n</tr>\n<tr>\n<td>Method Registry</td>\n<td>Simple dict mapping names to functions</td>\n<td>Decorator-based registration</td>\n</tr>\n</tbody></table>\n<p>For this educational implementation, we recommend the simple approaches. JSON is human-readable and easy to debug, raw TCP sockets expose the fundamental networking concepts, and exception-based error handling matches Python idioms.</p>\n<h4 id=\"project-structure-setup\">Project Structure Setup</h4>\n<p>Create the initial project structure with proper Python packaging:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc_framework/__init__.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Simple RPC Framework for educational purposes.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">__version__</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"1.0.0\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Public API - expose main classes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .server </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> RPCServer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .client </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> RPCClient</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RPCError, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RPCProtocolError, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RPCTransportError, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RPCTimeoutError,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RPCMethodError</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">__all__</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'RPCServer'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'RPCClient'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'RPCError'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'RPCProtocolError'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'RPCTransportError'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'RPCTimeoutError'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'RPCMethodError'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">]</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc_framework/exceptions.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Exception hierarchy for RPC framework.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all RPC-related errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCProtocolError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when message format is invalid or cannot be parsed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCTransportError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when network communication fails.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCTimeoutError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when request times out waiting for response.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCMethodError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when remote method execution fails.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, code, message, data</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> code</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"RPC Method Error </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorCode</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Standard JSON-RPC error codes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PARSE_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32700</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVALID_REQUEST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32600</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    METHOD_NOT_FOUND</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32601</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVALID_PARAMS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32602</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INTERNAL_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32603</span></span></code></pre></div>\n\n<h4 id=\"socket-utilities-infrastructure\">Socket Utilities Infrastructure</h4>\n<p>Provide complete socket helper functions that both client and server can use:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc_framework/utils.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Networking utilities for RPC framework.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> struct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> RPCTransportError, RPCTimeoutError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SocketHelper</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Utility class for reliable socket operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> send_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, timeout: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Send all bytes, handling partial sends and timeouts.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> timeout:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sock.settimeout(timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_sent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> total_sent </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(data):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                sent </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sock.send(data[total_sent:])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> sent </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#9ECBFF\">\"Socket connection broken during send\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                total_sent </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> sent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> socket.timeout:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTimeoutError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Send timeout after </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">timeout</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> seconds\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> socket.error </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Socket send error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recv_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, timeout: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Receive exactly size bytes, handling partial receives and timeouts.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> timeout:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sock.settimeout(timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        chunks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bytes_received </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> bytes_received </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> size:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sock.recv(</span><span style=\"color:#79B8FF\">min</span><span style=\"color:#E1E4E8\">(size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> bytes_received, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> chunk:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#9ECBFF\">\"Socket connection closed during receive\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                chunks.append(chunk)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                bytes_received </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(chunk)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> socket.timeout:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTimeoutError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Receive timeout after </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">timeout</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> seconds\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> socket.error </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Socket receive error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">.join(chunks)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recv_message</span><span style=\"color:#E1E4E8\">(sock: socket.socket, timeout: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Receive a length-prefixed message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # First receive the 4-byte length header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SocketHelper.recv_all(sock, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> struct.unpack(</span><span style=\"color:#9ECBFF\">'!I'</span><span style=\"color:#E1E4E8\">, length_data)[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Then receive the message body</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> SocketHelper.recv_all(sock, message_length, timeout)</span></span></code></pre></div>\n\n<h4 id=\"component-implementation-skeletons\">Component Implementation Skeletons</h4>\n<p>Provide skeletal implementations that define the interfaces and main methods without implementing the core logic:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc_framework/protocol.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Message protocol implementation for RPC framework.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> struct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> RPCProtocolError, ErrorCode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> generate_request_id</span><span style=\"color:#E1E4E8\">() -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Generate a unique request identifier.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return a unique string ID for correlating requests and responses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: uuid.uuid4().hex provides a good unique identifier</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_request_message</span><span style=\"color:#E1E4E8\">(method: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, params: Any, request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a JSON-RPC request message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create dict with required fields: jsonrpc, method, params, id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that method is a string and request_id is provided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return properly formatted request message dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_response_message</span><span style=\"color:#E1E4E8\">(request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, result: Any) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a JSON-RPC response message for successful calls.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create dict with required fields: jsonrpc, result, id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure request_id matches the original request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return properly formatted response message dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_error_message</span><span style=\"color:#E1E4E8\">(request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, code: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, data: Optional[Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a JSON-RPC error response message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create dict with required fields: jsonrpc, error, id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Error field should contain: code, message, and optional data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Use standard error codes from ErrorCode class</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return properly formatted error message dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> serialize_message</span><span style=\"color:#E1E4E8\">(message: Dict) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert message dict to length-prefixed bytes for network transmission.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Convert message dict to JSON string using json.dumps</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Encode JSON string to UTF-8 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create 4-byte length prefix using struct.pack('!I', length)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Concatenate length prefix + message bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle JSON serialization errors and raise RPCProtocolError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use '!I' format for network byte order unsigned int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> deserialize_message</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parse length-prefixed bytes back to message dict.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract 4-byte length prefix using struct.unpack('!I', data[:4])</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract message bytes using the length: data[4:4+length]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Decode message bytes from UTF-8 to string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Parse JSON string to dict using json.loads</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle parsing errors and raise RPCProtocolError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Validate message has required JSON-RPC fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc_framework/server.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"RPC Server implementation.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Callable, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .protocol </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> deserialize_message, serialize_message, create_response_message, create_error_message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .utils </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SocketHelper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> RPCError, RPCProtocolError, RPCTransportError, ErrorCode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCServer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"RPC Server that handles method registration and request processing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, host: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'localhost'</span><span style=\"color:#E1E4E8\">, port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 8000</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.host </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> host</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> port</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.methods: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Callable] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.running </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_method</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, method: Callable) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register a method that can be called remotely.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add method to self.methods dict with name as key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that method is callable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Consider logging the registration for debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> start_server</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Start the RPC server and listen for connections.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create TCP socket using socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Set SO_REUSEADDR socket option to avoid \"Address already in use\" errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Bind socket to (self.host, self.port)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Start listening with sock.listen()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Set self.running = True</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Enter main server loop accepting connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: For each connection, call self.handle_connection(client_sock)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Handle KeyboardInterrupt to allow clean shutdown</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_connection</span><span style=\"color:#E1E4E8\">(self, client_sock: socket.socket) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle a single client connection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Use SocketHelper.recv_message to receive request bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Deserialize bytes to message dict using deserialize_message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Call self.process_request(message) to get response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Serialize response using serialize_message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Send response using SocketHelper.send_all</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Close client socket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Handle all exceptions and convert to error responses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_request</span><span style=\"color:#E1E4E8\">(self, request: Dict) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process an RPC request and return response or error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate request has required fields (jsonrpc, method, id)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract method name from request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Look up method in self.methods registry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If method not found, return METHOD_NOT_FOUND error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Extract params from request (handle missing params)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Call method with params (handle *args and **kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return success response with result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Catch exceptions and convert to INTERNAL_ERROR responses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing each component, verify it works with these checkpoints:</p>\n<p><strong>Milestone 1 Checkpoint (Protocol):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test basic protocol functionality</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> rpc_framework.protocol </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> generate_request_id, create_request_message, serialize_message, deserialize_message</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Generate unique IDs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">id1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> generate_request_id()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">id2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> generate_request_id()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> id1 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> id2, </span><span style=\"color:#9ECBFF\">\"Request IDs should be unique\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create and serialize a request</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">request </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_request_message(</span><span style=\"color:#9ECBFF\">\"add\"</span><span style=\"color:#E1E4E8\">, [</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">], id1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">serialized </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> serialize_message(request)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">deserialized </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> deserialize_message(serialized)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> deserialized </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> request, </span><span style=\"color:#9ECBFF\">\"Round-trip serialization should preserve message\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✅ Protocol component working correctly\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Checkpoint (Server):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test server with simple method</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> rpc_framework </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> RPCServer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> add</span><span style=\"color:#E1E4E8\">(a, b):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> b</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">server </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> RPCServer(</span><span style=\"color:#FFAB70\">host</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'localhost'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">port</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">8001</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">server.register_method(</span><span style=\"color:#9ECBFF\">'add'</span><span style=\"color:#E1E4E8\">, add)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Start server in background thread</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">server_thread </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> threading.Thread(</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">server.start_server)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">server_thread.daemon </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">server_thread.start()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">time.sleep(</span><span style=\"color:#79B8FF\">0.1</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Let server start</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Send a raw JSON-RPC request using socket and verify response</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✅ Server component working correctly\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Milestone 3 Checkpoint (Client):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test complete RPC call</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> rpc_framework </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> RPCServer, RPCClient</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Set up server (same as above)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create client and make call</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">client </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> RPCClient(</span><span style=\"color:#FFAB70\">host</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'localhost'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">port</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">8001</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> client.call(</span><span style=\"color:#9ECBFF\">'add'</span><span style=\"color:#E1E4E8\">, [</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Expected 8, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">result</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✅ Complete RPC framework working correctly\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"python-specific-implementation-hints\">Python-Specific Implementation Hints</h4>\n<ul>\n<li><p><strong>Use <code>json.dumps()</code> and <code>json.loads()</code></strong> for message serialization. Handle <code>JSONDecodeError</code> exceptions and convert them to <code>RPCProtocolError</code>.</p>\n</li>\n<li><p><strong>Use <code>struct.pack(&#39;!I&#39;, length)</code> and <code>struct.unpack(&#39;!I&#39;, data)</code></strong> for the 4-byte length prefix. The <code>!</code> ensures network byte order (big-endian).</p>\n</li>\n<li><p><strong>Use <code>socket.settimeout()</code></strong> for implementing client timeouts. Catch <code>socket.timeout</code> exceptions and convert to <code>RPCTimeoutError</code>.</p>\n</li>\n<li><p><strong>Use <code>uuid.uuid4().hex</code></strong> for generating unique request IDs. This provides sufficiently unique identifiers without collision concerns.</p>\n</li>\n<li><p><strong>Use <code>**kwargs</code> unpacking</strong> when calling registered methods to handle both positional and keyword arguments from RPC calls.</p>\n</li>\n<li><p><strong>Use context managers</strong> (<code>with</code> statements) for socket management to ensure proper cleanup even when exceptions occur.</p>\n</li>\n</ul>\n<h2 id=\"message-protocol-design\">Message Protocol Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (Message Protocol) - defines request/response message format, serialization, and error handling</p>\n</blockquote>\n<p>The message protocol serves as the common language between RPC clients and servers, defining how method calls are encoded, transmitted, and decoded across network boundaries. This protocol must handle the fundamental challenge of converting programming language function calls into structured messages that can travel over TCP connections and be reconstructed on the remote end.</p>\n<h3 id=\"mental-model-the-international-mail-system\">Mental Model: The International Mail System</h3>\n<p>Think of the RPC message protocol like the international postal system. When you send a letter to another country, you can&#39;t just write the address in your local format and hope it arrives. Instead, there&#39;s a standardized format that postal workers worldwide understand: recipient name, street address, city, postal code, and country, arranged in a specific order with clear delimiters.</p>\n<p>Similarly, when a client wants to call a remote method, it can&#39;t just send &quot;call getUserById with parameter 123&quot; as plain text. The message must follow a structured format that both client and server understand: which method to call, what parameters to pass, how to identify this specific request, and how to handle the response or any errors that occur.</p>\n<p>Just as international mail includes return address information so replies can find their way back, RPC messages include request identifiers that allow responses to be matched with their original requests. And just as postal systems have standard procedures for handling undeliverable mail, RPC protocols define standard error codes and formats for when things go wrong.</p>\n<h3 id=\"message-formats\">Message Formats</h3>\n<p>The message protocol defines three fundamental message types that enable complete request-response communication cycles with comprehensive error handling.</p>\n<p><img src=\"/api/project/rpc-basic/architecture-doc/asset?path=diagrams%2Fmessage-formats.svg\" alt=\"Message Protocol Structure\"></p>\n<h4 id=\"request-message-structure\">Request Message Structure</h4>\n<p>Request messages carry method invocation information from client to server, including all necessary context for the server to locate and execute the requested function. Each request follows a standardized structure that ensures reliable method dispatch and response correlation.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>jsonrpc</code></td>\n<td>String</td>\n<td>Protocol version identifier, always &quot;2.0&quot; for JSON-RPC compliance</td>\n</tr>\n<tr>\n<td><code>method</code></td>\n<td>String</td>\n<td>Name of the remote method to invoke, must match server registry</td>\n</tr>\n<tr>\n<td><code>params</code></td>\n<td>Array or Object</td>\n<td>Method parameters, either positional array or named object</td>\n</tr>\n<tr>\n<td><code>id</code></td>\n<td>String or Number</td>\n<td>Unique request identifier for correlating responses</td>\n</tr>\n</tbody></table>\n<p>The <code>method</code> field specifies which registered server function to execute. Method names should follow clear naming conventions and must exactly match the names used when registering functions in the server&#39;s method registry. The server uses this string to perform method lookup and dispatch.</p>\n<p>The <code>params</code> field carries the arguments to pass to the remote method. Parameters can be structured as either a JSON array for positional arguments or a JSON object for named arguments. The array format <code>[arg1, arg2, arg3]</code> passes arguments in order to the method signature, while the object format <code>{&quot;name&quot;: &quot;value&quot;, &quot;count&quot;: 42}</code> allows parameter names to be specified explicitly.</p>\n<p>The <code>id</code> field enables request-response correlation in concurrent environments where multiple requests may be in flight simultaneously. Each client-generated request must include a unique identifier that the server echoes back in the corresponding response message. This allows clients to match responses with their originating requests even when network delays cause responses to arrive out of order.</p>\n<h4 id=\"response-message-structure\">Response Message Structure</h4>\n<p>Response messages carry successful method execution results back to the requesting client. The response structure mirrors the request format while providing the method&#39;s return value and maintaining request correlation.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>jsonrpc</code></td>\n<td>String</td>\n<td>Protocol version identifier, always &quot;2.0&quot;</td>\n</tr>\n<tr>\n<td><code>result</code></td>\n<td>Any</td>\n<td>Method return value, can be any JSON-serializable type</td>\n</tr>\n<tr>\n<td><code>id</code></td>\n<td>String or Number</td>\n<td>Request identifier copied from the corresponding request</td>\n</tr>\n</tbody></table>\n<p>The <code>result</code> field contains the actual return value from the executed method. This can be any JSON-serializable data type including strings, numbers, booleans, arrays, objects, or null. Complex return values like custom objects must be serializable to JSON, which may require custom serialization logic for certain data types.</p>\n<p>Response messages must not contain both <code>result</code> and <code>error</code> fields. A successful method execution produces a response with a <code>result</code> field, while method failures produce error messages with an <code>error</code> field instead.</p>\n<h4 id=\"error-message-structure\">Error Message Structure</h4>\n<p>Error messages communicate method execution failures, protocol violations, and system errors back to clients. The error structure provides detailed information about what went wrong and how clients might handle or recover from the failure.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>jsonrpc</code></td>\n<td>String</td>\n<td>Protocol version identifier, always &quot;2.0&quot;</td>\n</tr>\n<tr>\n<td><code>error</code></td>\n<td>Object</td>\n<td>Error details containing code, message, and optional data</td>\n</tr>\n<tr>\n<td><code>id</code></td>\n<td>String or Number or null</td>\n<td>Request identifier, or null if request parsing failed</td>\n</tr>\n</tbody></table>\n<p>The <code>error</code> field itself is an object containing structured error information that allows programmatic error handling and user-friendly error reporting.</p>\n<table>\n<thead>\n<tr>\n<th>Error Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>code</code></td>\n<td>Integer</td>\n<td>Numeric error code following JSON-RPC standard codes</td>\n</tr>\n<tr>\n<td><code>message</code></td>\n<td>String</td>\n<td>Human-readable error description</td>\n</tr>\n<tr>\n<td><code>data</code></td>\n<td>Any (optional)</td>\n<td>Additional error context like stack traces or validation details</td>\n</tr>\n</tbody></table>\n<p>Standard error codes follow the JSON-RPC specification to ensure consistent error handling across different RPC implementations. Pre-defined error codes cover common failure scenarios while custom application codes can address domain-specific errors.</p>\n<table>\n<thead>\n<tr>\n<th>Error Code</th>\n<th>Constant Name</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-32700</td>\n<td><code>PARSE_ERROR</code></td>\n<td>Invalid JSON received, cannot parse message</td>\n</tr>\n<tr>\n<td>-32600</td>\n<td><code>INVALID_REQUEST</code></td>\n<td>JSON is valid but doesn&#39;t conform to RPC format</td>\n</tr>\n<tr>\n<td>-32601</td>\n<td><code>METHOD_NOT_FOUND</code></td>\n<td>Requested method not registered on server</td>\n</tr>\n<tr>\n<td>-32602</td>\n<td><code>INVALID_PARAMS</code></td>\n<td>Method parameters are invalid or missing</td>\n</tr>\n<tr>\n<td>-32603</td>\n<td><code>INTERNAL_ERROR</code></td>\n<td>Server internal error during method execution</td>\n</tr>\n</tbody></table>\n<h3 id=\"serialization-strategy\">Serialization Strategy</h3>\n<p>The serialization strategy defines how structured message objects transform into byte streams for network transmission and how received byte streams reconstruct into message objects. This process must handle the challenges of network protocols that deliver unstructured byte streams rather than discrete messages.</p>\n<h4 id=\"json-encoding-decisions\">JSON Encoding Decisions</h4>\n<p>JSON serves as the wire format for message serialization due to its widespread language support, human readability, and reasonable performance characteristics. While binary formats like MessagePack or Protocol Buffers offer better performance, JSON provides the best balance of simplicity and interoperability for an educational RPC framework.</p>\n<blockquote>\n<p><strong>Decision: JSON Wire Format</strong></p>\n<ul>\n<li><strong>Context</strong>: Need a serialization format that balances simplicity, readability, and cross-language support for an educational RPC framework</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>JSON: Human-readable, widely supported, simple parsing</li>\n<li>MessagePack: More compact, faster parsing, binary format</li>\n<li>Protocol Buffers: Excellent performance, requires schema definition</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Use JSON as the primary serialization format</li>\n<li><strong>Rationale</strong>: JSON maximizes learning value by being human-readable during debugging, has universal language support, and requires minimal setup complexity. Performance is not critical for educational use cases.</li>\n<li><strong>Consequences</strong>: Slightly larger message sizes and slower parsing compared to binary formats, but greatly improved debugging experience and implementation simplicity.</li>\n</ul>\n</blockquote>\n<h4 id=\"message-framing-protocol\">Message Framing Protocol</h4>\n<p>TCP connections provide a continuous byte stream rather than discrete message boundaries, creating the fundamental challenge of determining where one message ends and the next begins. The message framing protocol solves this by prefixing each JSON message with a length header that specifies the exact number of bytes in the following message.</p>\n<p>The length prefix consists of a 4-byte big-endian unsigned integer that specifies the length of the JSON message in bytes. This approach provides several advantages over alternative framing strategies:</p>\n<ol>\n<li><strong>Fixed-size header</strong>: The receiver always knows to read exactly 4 bytes for the length field</li>\n<li><strong>Binary length encoding</strong>: More efficient than text-based length prefixes</li>\n<li><strong>Maximum message size</strong>: 4 bytes allows messages up to 4GB, far exceeding practical needs</li>\n<li><strong>Simple parsing</strong>: No need to scan for delimiters or escape sequences</li>\n</ol>\n<p>The complete wire format structure follows this pattern:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[4-byte length][JSON message bytes]</code></pre></div>\n\n<p>For example, a 45-byte JSON message would be transmitted as a 4-byte big-endian integer containing the value 45, followed immediately by the 45 bytes of JSON data.</p>\n<h4 id=\"parameter-type-handling\">Parameter Type Handling</h4>\n<p>JSON&#39;s limited type system requires careful handling of programming language types that don&#39;t map directly to JSON primitives. The protocol defines standard mappings between common language types and JSON representations.</p>\n<table>\n<thead>\n<tr>\n<th>Language Type</th>\n<th>JSON Representation</th>\n<th>Handling Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String</td>\n<td>JSON string</td>\n<td>Direct mapping, UTF-8 encoding</td>\n</tr>\n<tr>\n<td>Integer</td>\n<td>JSON number</td>\n<td>Direct mapping, 64-bit precision</td>\n</tr>\n<tr>\n<td>Float</td>\n<td>JSON number</td>\n<td>Direct mapping, may lose precision</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>JSON boolean</td>\n<td>Direct mapping</td>\n</tr>\n<tr>\n<td>Null/None</td>\n<td>JSON null</td>\n<td>Direct mapping</td>\n</tr>\n<tr>\n<td>Array/List</td>\n<td>JSON array</td>\n<td>Recursive serialization of elements</td>\n</tr>\n<tr>\n<td>Object/Dict</td>\n<td>JSON object</td>\n<td>String keys required, recursive values</td>\n</tr>\n<tr>\n<td>Date/Time</td>\n<td>ISO 8601 string</td>\n<td>Custom serialization required</td>\n</tr>\n<tr>\n<td>Binary Data</td>\n<td>Base64 string</td>\n<td>Custom encoding required</td>\n</tr>\n</tbody></table>\n<p>Custom types that don&#39;t map directly to JSON require application-specific serialization logic. The protocol supports this through the <code>data</code> field in error messages, which can contain arbitrary structured information about serialization failures or type conversion errors.</p>\n<blockquote>\n<p><strong>Decision: Strict JSON Type Mapping</strong></p>\n<ul>\n<li><strong>Context</strong>: Programming languages have richer type systems than JSON supports natively</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Strict JSON mapping with custom type serialization</li>\n<li>Extended JSON with type annotations</li>\n<li>Binary serialization for complex types</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Use strict JSON mapping with explicit custom serialization for unsupported types</li>\n<li><strong>Rationale</strong>: Maintains protocol simplicity and JSON compatibility while making type conversion explicit and controllable by the application</li>\n<li><strong>Consequences</strong>: Applications must handle custom type serialization explicitly, but the protocol remains simple and debuggable</li>\n</ul>\n</blockquote>\n<h4 id=\"serialization-error-handling\">Serialization Error Handling</h4>\n<p>Serialization failures can occur at multiple points in the message lifecycle: when creating request messages, when serializing responses, or when deserializing received data. The protocol defines specific error handling strategies for each scenario.</p>\n<p>Request serialization errors occur on the client side when method parameters cannot be converted to JSON. These errors should be raised as <code>RPCProtocolError</code> exceptions immediately, without sending any message to the server.</p>\n<p>Response serialization errors occur on the server side when method return values cannot be converted to JSON. The server should catch these errors and send an <code>INTERNAL_ERROR</code> response instead of the failed serialization.</p>\n<p>Deserialization errors occur when parsing received JSON data that is malformed or doesn&#39;t conform to the expected message structure. These should generate <code>PARSE_ERROR</code> or <code>INVALID_REQUEST</code> responses depending on whether the JSON itself is malformed or just doesn&#39;t match the RPC message format.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The message protocol implementation provides the foundation for all client-server communication, focusing on robust serialization, proper message framing, and comprehensive error handling.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JSON Library</td>\n<td><code>json</code> (built-in)</td>\n<td><code>ujson</code> for performance</td>\n</tr>\n<tr>\n<td>Message Framing</td>\n<td>Manual length prefix</td>\n<td>Custom protocol library</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Exception hierarchy</td>\n<td>Result/Maybe types</td>\n</tr>\n<tr>\n<td>ID Generation</td>\n<td><code>uuid.uuid4()</code></td>\n<td>Timestamp + counter</td>\n</tr>\n</tbody></table>\n<h4 id=\"core-protocol-implementation\">Core Protocol Implementation</h4>\n<p>The message protocol implementation centers around message creation, serialization, and deserialization functions that handle the complete message lifecycle.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> struct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Union, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorCode</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Standard JSON-RPC error codes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PARSE_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32700</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVALID_REQUEST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32600</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    METHOD_NOT_FOUND</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32601</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVALID_PARAMS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32602</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INTERNAL_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32603</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all RPC errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCProtocolError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when message format is invalid.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCTransportError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when network communication fails.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCTimeoutError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when request times out.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCMethodError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when method execution fails.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, code: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, data: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> code</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"RPC Error </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> generate_request_id</span><span style=\"color:#E1E4E8\">() -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Generate unique request ID for correlation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return string representation of UUID4</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use str(uuid.uuid4()) for simplicity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_request_message</span><span style=\"color:#E1E4E8\">(method: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, params: Union[</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">], request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create JSON-RPC request message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create message dict with jsonrpc=\"2.0\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add method name from parameter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add params (can be list or dict)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add request_id for response correlation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return complete message dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_response_message</span><span style=\"color:#E1E4E8\">(request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, result: Any) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create JSON-RPC response message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create message dict with jsonrpc=\"2.0\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add result field with method return value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add id field copied from request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return complete message dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Note: Response must not have both result and error fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_error_message</span><span style=\"color:#E1E4E8\">(request_id: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], code: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, data: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create JSON-RPC error message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create message dict with jsonrpc=\"2.0\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create error object with code and message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add data to error object if provided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add error object to message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Add id field (can be None if request parsing failed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return complete error message dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> serialize_message</span><span style=\"color:#E1E4E8\">(message: Dict) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert message dict to length-prefixed bytes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Convert message dict to JSON string using json.dumps()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Encode JSON string to UTF-8 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Get byte length of JSON data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create 4-byte big-endian length prefix using struct.pack('>I', length)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return length prefix + JSON bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Handle: json.JSONEncodeError should raise RPCProtocolError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> deserialize_message</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parse length-prefixed bytes to message dict.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check that data has at least 4 bytes for length prefix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Unpack length from first 4 bytes using struct.unpack('>I', data[:4])</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Extract JSON bytes using the length (data[4:4+length])</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Decode JSON bytes to UTF-8 string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Parse JSON string to dict using json.loads()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Validate message has required fields (jsonrpc, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return message dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Handle: struct.error, UnicodeDecodeError, json.JSONDecodeError should raise RPCProtocolError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"message-validation-logic\">Message Validation Logic</h4>\n<p>Robust message validation ensures that all received messages conform to the JSON-RPC specification before processing.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_request_message</span><span style=\"color:#E1E4E8\">(message: Dict) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validate request message format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check jsonrpc field is present and equals \"2.0\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check method field is present and is a string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check id field is present (string, number, or None)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check params field if present is list or dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Raise RPCProtocolError with descriptive message for any validation failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use isinstance() to check types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_response_message</span><span style=\"color:#E1E4E8\">(message: Dict) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validate response message format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check jsonrpc field is present and equals \"2.0\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check id field is present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check exactly one of 'result' or 'error' field is present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If error field present, validate error object structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Raise RPCProtocolError for validation failures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_error_object</span><span style=\"color:#E1E4E8\">(error: Dict) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validate error object structure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check error is a dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check 'code' field is present and is an integer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check 'message' field is present and is a string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check 'data' field if present is JSON-serializable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Raise RPCProtocolError for validation failures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"socket-helper-utilities\">Socket Helper Utilities</h4>\n<p>Network communication requires careful handling of partial sends and receives that can occur with TCP sockets.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SocketHelper</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Utility class for reliable socket operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> send_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, timeout: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Send all bytes handling partial sends.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Set socket timeout if specified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Track total bytes sent and remaining data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Loop while data remains to send</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Call sock.send() with remaining data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Update sent counter and slice remaining data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle socket.error exceptions as RPCTransportError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Note: send() may not send all bytes at once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recv_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, timeout: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Receive exactly size bytes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Set socket timeout if specified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Initialize empty buffer for received data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Loop until exactly size bytes received</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Call sock.recv() for remaining bytes needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Check for connection closed (empty recv result)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Append received data to buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return complete buffer when size bytes received</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Handle: socket.error, socket.timeout as RPCTransportError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recv_message</span><span style=\"color:#E1E4E8\">(sock: socket.socket, timeout: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Receive length-prefixed message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Receive 4-byte length prefix using recv_all()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Unpack length from prefix using struct.unpack('>I', prefix)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Receive message bytes using recv_all() with unpacked length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return complete message bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle struct.error as RPCProtocolError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"parameter-type-serialization\">Parameter Type Serialization</h4>\n<p>Custom serialization helpers handle types that don&#39;t map directly to JSON.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> serialize_custom_types</span><span style=\"color:#E1E4E8\">(obj: Any) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert custom types to JSON-serializable equivalents.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Handle datetime objects by converting to ISO format string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle Decimal objects by converting to float or string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle bytes objects by converting to base64 string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle set objects by converting to list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return obj unchanged if no custom serialization needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Recursively handle lists and dicts containing custom types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> deserialize_custom_types</span><span style=\"color:#E1E4E8\">(obj: Any, type_hints: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">type</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert JSON values back to custom types using type hints.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if type_hints provided for this field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Convert ISO format strings back to datetime if hinted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Convert base64 strings back to bytes if hinted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Convert lists back to sets if hinted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Recursively handle nested structures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return obj unchanged if no conversion needed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing the message protocol, verify the following behavior:</p>\n<p><strong>Request Message Creation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test that messages are created correctly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">request </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_request_message(</span><span style=\"color:#9ECBFF\">\"getUserById\"</span><span style=\"color:#E1E4E8\">, [</span><span style=\"color:#79B8FF\">123</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"req-1\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> request[</span><span style=\"color:#9ECBFF\">\"jsonrpc\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"2.0\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> request[</span><span style=\"color:#9ECBFF\">\"method\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"getUserById\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> request[</span><span style=\"color:#9ECBFF\">\"params\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">123</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> request[</span><span style=\"color:#9ECBFF\">\"id\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"req-1\"</span></span></code></pre></div>\n\n<p><strong>Serialization Roundtrip:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test that messages serialize and deserialize correctly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">original </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_request_message(</span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">, {</span><span style=\"color:#9ECBFF\">\"arg\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"value\"</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#9ECBFF\">\"test-id\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">serialized </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> serialize_message(original)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">deserialized </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> deserialize_message(serialized)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> deserialized </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> original</span></span></code></pre></div>\n\n<p><strong>Error Message Handling:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test that error messages are created correctly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">error_msg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_error_message(</span><span style=\"color:#9ECBFF\">\"req-1\"</span><span style=\"color:#E1E4E8\">, ErrorCode.</span><span style=\"color:#79B8FF\">METHOD_NOT_FOUND</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Method not found\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> error_msg[</span><span style=\"color:#9ECBFF\">\"error\"</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#9ECBFF\">\"code\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32601</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#9ECBFF\"> \"Method not found\"</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> error_msg[</span><span style=\"color:#9ECBFF\">\"error\"</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#9ECBFF\">\"message\"</span><span style=\"color:#E1E4E8\">]</span></span></code></pre></div>\n\n<h4 id=\"common-pitfalls-and-debugging\">Common Pitfalls and Debugging</h4>\n<p>⚠️ <strong>Pitfall: Incorrect Length Prefix Byte Order</strong>\nWhen implementing message framing, using little-endian instead of big-endian byte order causes length values to be misinterpreted, leading to connection hangs or protocol errors. Always use <code>&#39;&gt;I&#39;</code> format in <code>struct.pack()</code> and <code>struct.unpack()</code> to ensure big-endian (network byte order) encoding.</p>\n<p>⚠️ <strong>Pitfall: Partial JSON Message Parsing</strong>\nAttempting to parse JSON before receiving the complete message (as indicated by the length prefix) results in JSON decode errors. Always receive exactly the number of bytes specified in the length prefix before calling <code>json.loads()</code>.</p>\n<p>⚠️ <strong>Pitfall: Missing Request ID Validation</strong>\nFailing to validate that request IDs are present and properly formatted breaks request-response correlation in concurrent scenarios. Always validate ID fields during message parsing and ensure they&#39;re echoed correctly in responses.</p>\n<p>⚠️ <strong>Pitfall: JSON Serialization of Custom Types</strong>\nPython objects that aren&#39;t JSON-serializable (like datetime, Decimal, or custom classes) cause <code>json.dumps()</code> to raise <code>TypeError</code>. Implement custom serialization logic or use the <code>default</code> parameter in <code>json.dumps()</code> to handle these types explicitly.</p>\n<p>⚠️ <strong>Pitfall: Unicode Encoding Issues</strong>\nForgetting to specify UTF-8 encoding when converting between strings and bytes can cause encoding errors with non-ASCII characters. Always use <code>.encode(&#39;utf-8&#39;)</code> and <code>.decode(&#39;utf-8&#39;)</code> explicitly when handling JSON message bytes.</p>\n<h2 id=\"server-component-design\">Server Component Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (Server Implementation) - builds the RPC server that registers methods, accepts connections, and dispatches requests to registered functions</p>\n</blockquote>\n<p>The server component is the heart of our RPC framework, acting as the central dispatch point that receives remote method calls from clients and routes them to the appropriate local functions. The server must handle multiple concurrent connections, maintain a registry of callable methods, and gracefully manage errors while providing transparent remote access to local functionality.</p>\n<p><img src=\"/api/project/rpc-basic/architecture-doc/asset?path=diagrams%2Frequest-dispatch-flow.svg\" alt=\"Server Request Dispatch Flowchart\"></p>\n<h3 id=\"mental-model-the-receptionist-pattern\">Mental Model: The Receptionist Pattern</h3>\n<p>Think of the RPC server as a <strong>corporate receptionist</strong> working at the front desk of a large office building. Just as a receptionist receives phone calls from external visitors and routes them to the correct department or employee, the RPC server receives network requests from remote clients and routes them to the appropriate registered functions.</p>\n<p>The receptionist analogy illuminates several key aspects of server design:</p>\n<p><strong>Call Routing</strong>: When someone calls the main office number asking to speak with &quot;Dr. Smith in Cardiology,&quot; the receptionist doesn&#39;t need to know anything about cardiology procedures. They simply look up &quot;Dr. Smith&quot; in their directory and transfer the call. Similarly, when a client requests the method &quot;calculate_tax&quot; with parameters, the server looks up &quot;calculate_tax&quot; in its method registry and forwards the call to the registered function.</p>\n<p><strong>Multiple Simultaneous Calls</strong>: A busy receptionist handles multiple phone lines simultaneously, placing some callers on hold while connecting others. The RPC server must handle multiple client connections concurrently, processing requests as they arrive without blocking other clients.</p>\n<p><strong>Error Handling</strong>: When someone asks to speak with &quot;Dr. Johnson&quot; but no such person works at the hospital, the receptionist politely responds &quot;I&#39;m sorry, we don&#39;t have a Dr. Johnson here.&quot; Similarly, when a client requests a non-existent method, the server responds with a structured error message rather than crashing.</p>\n<p><strong>Message Translation</strong>: The receptionist might receive a call saying &quot;I need to speak to someone about my heart problem&quot; and translate this to &quot;connecting you to Cardiology.&quot; The server receives JSON-encoded method calls and translates them into actual Python function invocations with the correct parameters.</p>\n<p><strong>Directory Management</strong>: The receptionist maintains an up-to-date directory of employees and departments. The server maintains a method registry mapping function names to callable Python objects.</p>\n<p>This mental model helps us understand that the server&#39;s primary responsibility is <strong>intelligent message routing</strong> rather than performing the actual business logic. The registered methods contain the domain expertise; the server simply ensures that remote requests reach the right local functions with the correct parameters.</p>\n<h3 id=\"method-registry\">Method Registry</h3>\n<p>The <strong>method registry</strong> is the server&#39;s phone directory - a mapping from string method names to callable Python functions. This registry enables <strong>dynamic method dispatch</strong>, where the server can invoke different functions based on the method name received in client requests.</p>\n<p>The registry design centers around a simple but powerful concept: <strong>name-based function lookup</strong>. Instead of hardcoding specific method calls, the server maintains a dictionary where keys are method names (strings) and values are callable objects. This approach provides flexibility and extensibility - new methods can be registered at runtime without modifying the server&#39;s core dispatch logic.</p>\n<table>\n<thead>\n<tr>\n<th>Registry Component</th>\n<th>Type</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Method Name</td>\n<td><code>str</code></td>\n<td>Unique identifier for the remote method</td>\n<td><code>&quot;calculate_tax&quot;</code></td>\n</tr>\n<tr>\n<td>Handler Function</td>\n<td><code>Callable</code></td>\n<td>Python function that implements the method</td>\n<td><code>lambda rate, amount: amount * rate</code></td>\n</tr>\n<tr>\n<td>Parameter Count</td>\n<td><code>int</code></td>\n<td>Expected number of parameters (optional validation)</td>\n<td><code>2</code></td>\n</tr>\n<tr>\n<td>Documentation</td>\n<td><code>str</code></td>\n<td>Human-readable description (optional)</td>\n<td><code>&quot;Calculates tax given rate and amount&quot;</code></td>\n</tr>\n</tbody></table>\n<p>The registry supports several registration patterns to accommodate different use cases:</p>\n<p><strong>Direct Function Registration</strong>: The simplest approach involves registering standalone functions by name. For example, registering a tax calculation function allows clients to call <code>calculate_tax(0.08, 100.0)</code> remotely.</p>\n<p><strong>Class Method Registration</strong>: Object-oriented applications can register instance methods, enabling remote access to stateful operations. For instance, registering <code>user_service.create_user</code> allows clients to invoke methods on server-side service objects.</p>\n<p><strong>Lambda Registration</strong>: Simple computations can be registered as lambda functions for lightweight remote operations. This pattern works well for mathematical calculations or data transformations.</p>\n<p><strong>Decorator-Based Registration</strong>: A more elegant approach uses Python decorators to automatically register functions when they&#39;re defined. This reduces boilerplate and ensures that method registration happens alongside function definition.</p>\n<blockquote>\n<p><strong>Key Design Insight</strong>: The registry acts as a <strong>capability list</strong> - it explicitly defines which local functions are accessible to remote clients. This provides both security (unlisted functions cannot be called) and clarity (the registry serves as an API contract).</p>\n</blockquote>\n<p>Method lookup follows a straightforward algorithm:</p>\n<ol>\n<li>Extract the method name from the incoming request message</li>\n<li>Check if the method name exists in the registry dictionary</li>\n<li>If found, retrieve the associated callable object</li>\n<li>If not found, prepare a METHOD_NOT_FOUND error response</li>\n<li>Return either the callable function or an error indicator</li>\n</ol>\n<p>The registry implementation must consider <strong>thread safety</strong> since multiple client connections may perform method lookups simultaneously. Python&#39;s built-in dictionary provides thread-safe read operations, but method registration during server operation requires appropriate locking.</p>\n<table>\n<thead>\n<tr>\n<th>Registry Operation</th>\n<th>Thread Safety</th>\n<th>Performance</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Method Lookup</td>\n<td>Thread-safe (read-only)</td>\n<td>O(1) average</td>\n<td>Request dispatch</td>\n</tr>\n<tr>\n<td>Method Registration</td>\n<td>Requires locking</td>\n<td>O(1) average</td>\n<td>Server startup</td>\n</tr>\n<tr>\n<td>Method Unregistration</td>\n<td>Requires locking</td>\n<td>O(1) average</td>\n<td>Dynamic updates</td>\n</tr>\n<tr>\n<td>Registry Enumeration</td>\n<td>Requires snapshot</td>\n<td>O(n)</td>\n<td>Introspection</td>\n</tr>\n</tbody></table>\n<h3 id=\"request-dispatch-algorithm\">Request Dispatch Algorithm</h3>\n<p>The <strong>request dispatch algorithm</strong> transforms incoming client messages into local function calls and converts the results back into response messages. This process involves message parsing, method lookup, parameter validation, function execution, and response serialization.</p>\n<p><img src=\"/api/project/rpc-basic/architecture-doc/asset?path=diagrams%2Frpc-call-sequence.svg\" alt=\"RPC Call Sequence\"></p>\n<p>The dispatch algorithm operates as a <strong>message transformation pipeline</strong>, where each stage performs a specific transformation on the request data:</p>\n<ol>\n<li><p><strong>Message Reception</strong>: The server receives length-prefixed JSON bytes from the client socket connection. The message framing ensures complete message boundaries in the TCP stream.</p>\n</li>\n<li><p><strong>Deserialization</strong>: The raw bytes are parsed as JSON and converted into a Python dictionary representing the request message. This stage can fail if the client sends malformed JSON.</p>\n</li>\n<li><p><strong>Request Validation</strong>: The server verifies that the message contains all required fields (<code>method</code>, <code>params</code>, <code>id</code>) and that field types match the JSON-RPC specification.</p>\n</li>\n<li><p><strong>Method Lookup</strong>: The server searches the method registry for a function matching the requested method name. This lookup determines whether the request can be fulfilled.</p>\n</li>\n<li><p><strong>Parameter Preparation</strong>: The parameter list from the request is unpacked for passing to the target function. This may involve type coercion or validation depending on the method&#39;s requirements.</p>\n</li>\n<li><p><strong>Function Execution</strong>: The server invokes the registered function with the provided parameters. This is where the actual business logic executes.</p>\n</li>\n<li><p><strong>Result Handling</strong>: The function&#39;s return value is captured and prepared for serialization. Exceptions during execution must be caught and converted to error responses.</p>\n</li>\n<li><p><strong>Response Serialization</strong>: The result or error is packaged into a JSON-RPC response message and serialized to bytes for transmission.</p>\n</li>\n<li><p><strong>Message Transmission</strong>: The response bytes are sent back to the client through the same socket connection that delivered the request.</p>\n</li>\n</ol>\n<p>Each stage includes <strong>error handling</strong> that can terminate the pipeline early and generate an appropriate error response:</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Detection Stage</th>\n<th>Error Code</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Malformed JSON</td>\n<td>Deserialization</td>\n<td><code>PARSE_ERROR</code></td>\n<td>Send error response if possible</td>\n</tr>\n<tr>\n<td>Missing Fields</td>\n<td>Request Validation</td>\n<td><code>INVALID_REQUEST</code></td>\n<td>Send error response with details</td>\n</tr>\n<tr>\n<td>Unknown Method</td>\n<td>Method Lookup</td>\n<td><code>METHOD_NOT_FOUND</code></td>\n<td>Send error response with method name</td>\n</tr>\n<tr>\n<td>Wrong Parameters</td>\n<td>Parameter Preparation</td>\n<td><code>INVALID_PARAMS</code></td>\n<td>Send error response with expected signature</td>\n</tr>\n<tr>\n<td>Function Exception</td>\n<td>Function Execution</td>\n<td><code>INTERNAL_ERROR</code></td>\n<td>Send error response with exception details</td>\n</tr>\n<tr>\n<td>Serialization Failure</td>\n<td>Response Serialization</td>\n<td><code>INTERNAL_ERROR</code></td>\n<td>Log error and close connection</td>\n</tr>\n</tbody></table>\n<p>The algorithm maintains <strong>request context</strong> throughout the pipeline to ensure proper error attribution and response correlation. Each request carries its unique ID from initial reception through final response transmission.</p>\n<blockquote>\n<p><strong>Critical Design Decision</strong>: The dispatch algorithm operates <strong>synchronously</strong> within each client connection. While the server handles multiple connections concurrently, individual requests execute sequentially within their connection context. This simplifies error handling and state management.</p>\n</blockquote>\n<p>The dispatch process handles <strong>parameter passing</strong> by unpacking the JSON array into individual function arguments. For a request with <code>&quot;params&quot;: [0.08, 100.0]</code>, the server calls <code>registered_function(0.08, 100.0)</code>. This approach supports positional parameters naturally while requiring careful parameter count validation.</p>\n<p><strong>Exception propagation</strong> follows a convert-and-contain strategy. Python exceptions raised during method execution are caught, converted to JSON-RPC error responses, and sent to the client. The server continues operating normally after handling exceptions, ensuring that one client&#39;s error doesn&#39;t affect other connections.</p>\n<h3 id=\"architecture-decision-records\">Architecture Decision Records</h3>\n<blockquote>\n<p><strong>Decision: Synchronous Request Processing</strong></p>\n<ul>\n<li><strong>Context</strong>: Each client connection must decide whether to process requests synchronously (one at a time) or asynchronously (multiple concurrent requests per connection)</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Synchronous processing with one request at a time per connection</li>\n<li>Asynchronous processing with multiple concurrent requests per connection</li>\n<li>Thread pool for request execution within each connection</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Synchronous request processing within each connection</li>\n<li><strong>Rationale</strong>: Simplifies implementation for a beginner-level framework while still supporting multiple concurrent clients through separate connections. Eliminates race conditions and complex state management within connections.</li>\n<li><strong>Consequences</strong>: Enables easier debugging and testing while limiting throughput for clients that could benefit from request pipelining. Acceptable trade-off for educational implementation.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Synchronous</td>\n<td>Simple state management, easy debugging, predictable behavior</td>\n<td>Lower throughput per connection, head-of-line blocking</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Asynchronous</td>\n<td>Higher throughput, request pipelining support</td>\n<td>Complex error handling, race conditions, harder debugging</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Thread Pool</td>\n<td>Balanced throughput and complexity</td>\n<td>Thread overhead, synchronization issues</td>\n<td>Medium</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Thread-Per-Connection Model</strong></p>\n<ul>\n<li><strong>Context</strong>: The server must handle multiple simultaneous client connections while maintaining isolation between clients</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Single-threaded event loop with select/poll</li>\n<li>Thread-per-connection model</li>\n<li>Thread pool with connection queuing</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Thread-per-connection model using Python threading</li>\n<li><strong>Rationale</strong>: Provides natural isolation between clients and simplifies connection state management. Python&#39;s GIL limits true parallelism but still allows I/O concurrency for network operations.</li>\n<li><strong>Consequences</strong>: Each connection gets dedicated thread context with simple blocking I/O. Memory overhead scales with connection count but remains manageable for typical RPC usage.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Scalability</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Event Loop</td>\n<td>Memory efficient, high scalability</td>\n<td>Complex state machines, callback hell</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Thread-per-Connection</td>\n<td>Simple programming model, natural isolation</td>\n<td>Memory overhead, GIL limitations</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Thread Pool</td>\n<td>Bounded resource usage, good for bursts</td>\n<td>Complex work queuing, shared state issues</td>\n<td>Medium</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Exception-to-Error Response Conversion</strong></p>\n<ul>\n<li><strong>Context</strong>: When registered methods throw exceptions, the server must decide how to communicate failures to clients</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Convert all exceptions to INTERNAL_ERROR responses</li>\n<li>Allow methods to raise specific RPC error exceptions</li>\n<li>Crash the server on any unhandled exception</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Convert Python exceptions to INTERNAL_ERROR responses with exception details in the data field</li>\n<li><strong>Rationale</strong>: Provides robust error handling that doesn&#39;t crash the server while giving clients useful debugging information. Maintains service availability despite individual method failures.</li>\n<li><strong>Consequences</strong>: Enables graceful degradation and easier debugging while potentially exposing internal implementation details to clients.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Security</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Generic Conversion</td>\n<td>Simple, robust, maintains availability</td>\n<td>Less specific error information</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Specific RPC Exceptions</td>\n<td>Precise error communication, client-friendly</td>\n<td>Requires method author cooperation</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Server Crash</td>\n<td>Fails fast, obvious problems</td>\n<td>Poor availability, affects all clients</td>\n<td>Low</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: JSON-Only Parameter Serialization</strong></p>\n<ul>\n<li><strong>Context</strong>: Client parameters must be converted from JSON to Python objects for function calls</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>JSON-only with basic type mapping (str, int, float, bool, list, dict)</li>\n<li>Custom serialization with type hints and object reconstruction</li>\n<li>Binary serialization using pickle or msgpack</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: JSON-only serialization with standard Python type mapping</li>\n<li><strong>Rationale</strong>: Provides language-agnostic interoperability and simple implementation while supporting most common use cases. JSON types map naturally to Python built-ins.</li>\n<li><strong>Consequences</strong>: Enables cross-language clients and simple debugging while limiting parameter types to JSON-compatible values.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Interoperability</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JSON-Only</td>\n<td>Language agnostic, simple, debuggable</td>\n<td>Limited types, no custom objects</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Custom Serialization</td>\n<td>Rich type support, Python-native</td>\n<td>Complex, Python-specific clients</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Binary</td>\n<td>Efficient, type-preserving</td>\n<td>Opaque, debugging difficulty</td>\n<td>Medium</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Blocking Server with Long-Running Methods</strong>\nWhen registered methods perform time-consuming operations like database queries or external API calls, they block the entire connection thread. Since our architecture uses one thread per connection, a slow method prevents that client from making additional requests until the current request completes.</p>\n<p><strong>Why it&#39;s wrong</strong>: Clients expect responsiveness from RPC services. A method that takes 30 seconds to complete makes the connection unusable during that time, creating poor user experience and potential timeouts.</p>\n<p><strong>How to fix</strong>: Implement request timeouts on both client and server sides. Consider moving long-running operations to background tasks and returning a job ID that clients can use to poll for results. For educational purposes, document this limitation and suggest that registered methods complete quickly.</p>\n<p>⚠️ <strong>Pitfall: Registry Race Conditions During Dynamic Registration</strong>\nIf the server allows method registration while handling client requests, concurrent access to the registry dictionary can cause race conditions. Python dictionaries aren&#39;t thread-safe for concurrent modifications, leading to corrupted state or KeyError exceptions.</p>\n<p><strong>Why it&#39;s wrong</strong>: Race conditions create intermittent failures that are difficult to reproduce and debug. The server might crash or return inconsistent results depending on timing.</p>\n<p><strong>How to fix</strong>: Use a threading lock (RLock) around registry modifications, or restrict method registration to server startup only. For read-heavy workloads, consider using a copy-on-write pattern where registry updates create new dictionary instances.</p>\n<p>⚠️ <strong>Pitfall: Exposing Internal Functions Accidentally</strong>\nDevelopers might register utility functions or internal helper methods that weren&#39;t intended for remote access. This creates security vulnerabilities and API confusion.</p>\n<p><strong>Why it&#39;s wrong</strong>: Internal functions often assume trusted input or have side effects that shouldn&#39;t be accessible to remote clients. Exposing them violates the principle of least privilege and can lead to unintended system modifications.</p>\n<p><strong>How to fix</strong>: Use explicit registration rather than automatic discovery. Consider implementing a decorator that marks functions as RPC-eligible, ensuring only intentionally exposed methods enter the registry. Review the registry contents during development.</p>\n<p>⚠️ <strong>Pitfall: Poor Error Message Serialization</strong>\nWhen converting Python exceptions to JSON error responses, including the full exception object or stack trace can cause serialization failures if the exception contains non-JSON-serializable data.</p>\n<p><strong>Why it&#39;s wrong</strong>: Serialization failures during error handling can crash the connection or send malformed responses to clients. This creates cascading failures where error recovery itself fails.</p>\n<p><strong>How to fix</strong>: Extract only the exception message string and type name for error responses. Use <code>str(exception)</code> and <code>type(exception).__name__</code> rather than trying to serialize the exception object directly. Test error paths with various exception types.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Parameter Count Validation</strong>\nCalling Python functions with the wrong number of parameters causes TypeError exceptions, but these might not provide clear error messages for remote clients trying to understand the correct method signature.</p>\n<p><strong>Why it&#39;s wrong</strong>: Generic &quot;TypeError: function() takes 2 positional arguments but 3 were given&quot; messages don&#39;t help remote clients understand the expected parameter format, leading to trial-and-error debugging.</p>\n<p><strong>How to fix</strong>: Validate parameter count before function invocation and return INVALID_PARAMS errors with clear descriptions of the expected signature. Consider storing parameter metadata in the registry for better error messages.</p>\n<p>⚠️ <strong>Pitfall: Connection Resource Leaks</strong>\nFailing to properly close client sockets when connections end can exhaust the server&#39;s file descriptor limit, especially during testing with many short-lived connections.</p>\n<p><strong>Why it&#39;s wrong</strong>: Resource leaks accumulate over time and can crash the server or prevent new connections. The operating system has limits on open file descriptors per process.</p>\n<p><strong>How to fix</strong>: Use try-finally blocks or context managers to ensure socket cleanup. Implement proper connection termination handling that closes resources even when exceptions occur during request processing.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Threading</td>\n<td><code>threading.Thread</code> per connection</td>\n<td><code>concurrent.futures.ThreadPoolExecutor</code></td>\n</tr>\n<tr>\n<td>Socket Handling</td>\n<td>Raw <code>socket.socket</code> with manual framing</td>\n<td><code>socketserver.ThreadingTCPServer</code></td>\n</tr>\n<tr>\n<td>Method Registry</td>\n<td>Simple <code>dict</code> mapping</td>\n<td>Class-based registry with validation</td>\n</tr>\n<tr>\n<td>Error Logging</td>\n<td>Built-in <code>logging</code> module</td>\n<td>Structured logging with JSON output</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>rpc_framework/\n  server/\n    __init__.py              ← exports RPCServer\n    registry.py              ← method registration logic  \n    server.py                ← main server implementation\n    connection.py            ← connection handling logic\n  protocol/\n    messages.py              ← from previous milestone\n    serialization.py         ← from previous milestone\n  common/\n    errors.py                ← RPC exception classes\n    socket_helper.py         ← socket utilities</code></pre></div>\n\n<p><strong>Socket Helper Infrastructure (Complete):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> struct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SocketHelper</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Utility class for socket operations with message framing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> send_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Send all bytes, handling partial sends and timeouts.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sock.settimeout(timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_sent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> total_sent </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(data):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                sent </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sock.send(data[total_sent:])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> sent </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    raise</span><span style=\"color:#79B8FF\"> ConnectionError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Socket connection broken\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                total_sent </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> sent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> socket.timeout:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTimeoutError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Send timeout after </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">timeout</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">s\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recv_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Receive exact number of bytes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sock.settimeout(timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        chunks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bytes_received </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> bytes_received </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> size:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sock.recv(size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> bytes_received)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> chunk:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    raise</span><span style=\"color:#79B8FF\"> ConnectionError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Socket connection broken\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                chunks.append(chunk)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                bytes_received </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(chunk)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> socket.timeout:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTimeoutError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Receive timeout after </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">timeout</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">s\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">.join(chunks)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recv_message</span><span style=\"color:#E1E4E8\">(sock: socket.socket, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Receive a length-prefixed message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # First receive 4-byte length prefix</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SocketHelper.recv_all(sock, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> struct.unpack(</span><span style=\"color:#9ECBFF\">'>I'</span><span style=\"color:#E1E4E8\">, length_bytes)[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Then receive the actual message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> SocketHelper.recv_all(sock, message_length, timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> send_message</span><span style=\"color:#E1E4E8\">(sock: socket.socket, message_bytes: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Send a length-prefixed message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length_prefix </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> struct.pack(</span><span style=\"color:#9ECBFF\">'>I'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(message_bytes))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SocketHelper.send_all(sock, length_prefix </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> message_bytes, timeout)</span></span></code></pre></div>\n\n<p><strong>Method Registry Core (Complete):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Callable, Any, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MethodRegistry</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Thread-safe registry for RPC methods.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._methods: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Callable] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> threading.RLock()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._descriptions: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_method</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, method: Callable, description: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register a callable method by name.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._methods[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> method</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> description:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">._descriptions[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> description</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> lookup_method</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[Callable]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Look up a method by name. Thread-safe read operation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._methods.get(name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> list_methods</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return a copy of all registered methods with descriptions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> {name: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._descriptions.get(name, </span><span style=\"color:#9ECBFF\">\"No description\"</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   for</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._methods}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> method_exists</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if a method is registered.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._methods</span></span></code></pre></div>\n\n<p><strong>Server Core Logic Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCServer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Simple RPC Server with method registry and connection handling.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, host: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'localhost'</span><span style=\"color:#E1E4E8\">, port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 8000</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.host </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> host</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> port</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.registry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> MethodRegistry()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.server_socket </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.running </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_method</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, method: Callable) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register a method in the server's registry.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Use the registry to register the method by name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Log the registration for debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> start_server</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Start the RPC server and listen for connections.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create server socket and bind to host:port</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Start listening for connections (backlog=5)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Set self.running = True</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Enter main accept loop, creating thread for each connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle KeyboardInterrupt for graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use threading.Thread(target=self.handle_connection, args=(client_sock,))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_connection</span><span style=\"color:#E1E4E8\">(self, client_sock: socket.socket) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle a single client connection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Log the new connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Loop receiving messages until connection closes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For each message, call process_request and send response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle SocketHelper exceptions and close connection gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Use SocketHelper.recv_message() and SocketHelper.send_message()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        finally</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Always close the client socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_request</span><span style=\"color:#E1E4E8\">(self, request_bytes: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process a single RPC request and return response bytes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Deserialize the request bytes to a dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate request has required fields (method, params, id)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Look up the method in the registry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If method not found, create METHOD_NOT_FOUND error response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If found, call the method with params and create success response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle any exceptions during method execution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Serialize response dictionary to bytes and return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Use deserialize_message() and serialize_message() from protocol</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Use create_response_message() and create_error_message()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> json.JSONDecodeError:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Handle JSON parsing errors with PARSE_ERROR response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Handle unexpected errors with INTERNAL_ERROR response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> stop_server</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Stop the server gracefully.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Set self.running = False</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Close server socket if open</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing the server component, verify the following behavior:</p>\n<ol>\n<li><p><strong>Method Registration Test</strong>: Create a simple function like <code>def add(a, b): return a + b</code>, register it with the server, and verify it appears in the registry.</p>\n</li>\n<li><p><strong>Connection Handling Test</strong>: Start the server and use telnet or a simple socket client to connect. The server should accept the connection without crashing.</p>\n</li>\n<li><p><strong>Request Processing Test</strong>: Send a properly formatted JSON-RPC request and verify you receive a JSON-RPC response. Use this test message:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   {</span><span style=\"color:#79B8FF\">\"method\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"add\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\"params\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">\"id\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"test-1\"</span><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><p><strong>Error Handling Test</strong>: Send an invalid request (malformed JSON or unknown method) and verify you receive an appropriate error response.</p>\n</li>\n<li><p><strong>Concurrent Connection Test</strong>: Open multiple connections simultaneously and verify the server handles them independently.</p>\n</li>\n</ol>\n<p><strong>Language-Specific Hints:</strong></p>\n<ul>\n<li>Use <code>socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code> for TCP sockets</li>\n<li>Set <code>socket.SO_REUSEADDR</code> to avoid &quot;Address already in use&quot; errors during testing</li>\n<li>Use <code>threading.Thread(target=handler, args=(sock,), daemon=True)</code> for connection threads</li>\n<li>Python&#39;s GIL limits true parallelism but allows I/O concurrency for socket operations</li>\n<li>Use <code>logging.basicConfig(level=logging.INFO)</code> to see connection and request logs</li>\n<li>Handle <code>ConnectionResetError</code> and <code>BrokenPipeError</code> for client disconnections</li>\n</ul>\n<h2 id=\"client-component-design\">Client Component Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (Client Implementation) - builds the RPC client that provides method proxying, manages network communication, and handles timeouts</p>\n</blockquote>\n<p>The client component serves as the user-facing interface to the RPC framework, transforming local method calls into remote procedure calls and managing all the underlying network complexity. The client must provide a seamless experience where calling a remote function feels identical to calling a local function, while handling the inherent challenges of network communication, serialization, and error propagation.</p>\n<h3 id=\"mental-model-the-secretary-pattern\">Mental Model: The Secretary Pattern</h3>\n<p>Think of the RPC client as your personal secretary who handles all your external communications. When you need to contact someone in another department, you don&#39;t dial the phone yourself, manage the conversation, or worry about busy signals. Instead, you simply tell your secretary &quot;I need to call the accounting department and ask them to calculate the tax for invoice #1234.&quot; Your secretary handles everything: looking up the phone number, making the call, translating your request into the proper format, waiting for the response, handling any errors (&quot;sorry, their line is busy, should I try again?&quot;), and finally delivering the result back to you in a format you can immediately use.</p>\n<p>The RPC client works similarly. When your application code wants to call <code>remote.calculate_tax(invoice_id=&quot;1234&quot;)</code>, the client proxy intercepts this call, translates it into a properly formatted RPC request message, manages the TCP connection to the server, sends the request, waits for the response, handles any network errors or timeouts, and finally returns the result as if it were a local function call. Just like a good secretary, the client handles all the complexity behind the scenes so you can focus on your actual work.</p>\n<p>This mental model helps us understand the client&#39;s core responsibilities: <strong>transparent proxying</strong> (making remote calls look local), <strong>connection management</strong> (maintaining reliable communication channels), <strong>request tracking</strong> (ensuring responses match requests), and <strong>error translation</strong> (converting network failures into meaningful exceptions).</p>\n<h3 id=\"method-proxying\">Method Proxying</h3>\n<p>Method proxying is the mechanism that creates the illusion of local function calls for remote procedures. The proxy object intercepts method calls using language-specific metaprogramming features and converts them into RPC requests. This requires careful handling of method names, parameter serialization, and response deserialization.</p>\n<p>The proxy object acts as a stand-in for the remote service, implementing the same interface but routing calls over the network instead of executing them locally. When a method is called on the proxy, it captures the method name and arguments, creates an RPC request message using the protocol defined in Milestone 1, sends it to the server, waits for the response, and returns the result or raises an appropriate exception.</p>\n<p>The key challenge in method proxying is maintaining the natural feel of local method calls while handling the additional complexity of network communication. This includes preserving parameter types through serialization, maintaining call semantics (synchronous by default), and translating remote errors into local exceptions.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: The proxy pattern is crucial for RPC adoption because it eliminates the mental overhead of thinking about network details. Developers can write <code>result = calculator.add(5, 3)</code> instead of <code>result = rpc_client.call(&quot;add&quot;, [5, 3])</code>, making remote calls feel natural and reducing cognitive load.</p>\n</blockquote>\n<p><strong>Proxy Object Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>client</code></td>\n<td><code>RPCClient</code></td>\n<td>Reference to the underlying RPC client that manages connections</td>\n</tr>\n<tr>\n<td><code>timeout</code></td>\n<td><code>float</code></td>\n<td>Default timeout for method calls in seconds</td>\n</tr>\n<tr>\n<td><code>_method_cache</code></td>\n<td><code>Dict[str, Callable]</code></td>\n<td>Cache of dynamically created method proxies for performance</td>\n</tr>\n</tbody></table>\n<p><strong>Method Proxy Interface:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>__getattr__</code></td>\n<td><code>name: str</code></td>\n<td><code>Callable</code></td>\n<td>Dynamically creates proxy methods for any attribute access</td>\n</tr>\n<tr>\n<td><code>__call__</code></td>\n<td><code>*args, **kwargs</code></td>\n<td><code>Any</code></td>\n<td>Executes the actual RPC call when proxy method is invoked</td>\n</tr>\n<tr>\n<td><code>_create_method_proxy</code></td>\n<td><code>method_name: str</code></td>\n<td><code>Callable</code></td>\n<td>Creates a callable that captures method name and forwards to RPC client</td>\n</tr>\n<tr>\n<td><code>_validate_parameters</code></td>\n<td><code>args: Tuple, kwargs: Dict</code></td>\n<td><code>None</code></td>\n<td>Ensures parameters are JSON-serializable before sending</td>\n</tr>\n</tbody></table>\n<p>The method proxying implementation uses Python&#39;s <code>__getattr__</code> magic method to intercept attribute access and return callable objects that perform RPC calls. When code calls <code>proxy.method_name(arg1, arg2)</code>, Python first calls <code>proxy.__getattr__(&quot;method_name&quot;)</code> which returns a callable, then immediately calls that callable with the provided arguments.</p>\n<p><strong>Method Proxying Algorithm:</strong></p>\n<ol>\n<li>Application code calls a method on the proxy object (e.g., <code>proxy.calculate_tax(invoice_id=&quot;1234&quot;)</code>)</li>\n<li>Python&#39;s attribute resolution triggers <code>__getattr__(&quot;calculate_tax&quot;)</code></li>\n<li>The proxy checks its method cache for an existing proxy function for this method name</li>\n<li>If not cached, it creates a new proxy function that captures the method name and stores it in the cache</li>\n<li>The proxy function is returned to Python, which immediately calls it with the provided arguments</li>\n<li>Inside the proxy function, parameters are validated for JSON serializability</li>\n<li>A unique request ID is generated using <code>generate_request_id()</code></li>\n<li>The request message is created using <code>create_request_message(method_name, args, request_id)</code></li>\n<li>The request is sent to the server via the underlying <code>RPCClient</code></li>\n<li>The proxy function blocks waiting for the response with the matching request ID</li>\n<li>When the response arrives, it&#39;s either returned as the method result or converted to an exception</li>\n<li>The final result is returned to the application code as if it were a local function call</li>\n</ol>\n<blockquote>\n<p><strong>Critical Design Decision</strong>: We choose to make method calls synchronous (blocking) by default because this matches the semantics of local function calls and is easier for beginners to understand. Asynchronous support can be added later as an advanced feature.</p>\n</blockquote>\n<h3 id=\"connection-management\">Connection Management</h3>\n<p>Connection management handles the TCP socket lifecycle, including establishing connections, reusing connections for multiple requests, handling connection failures, and properly closing connections when done. Effective connection management is crucial for both performance and reliability.</p>\n<p>The client must decide whether to create a new connection for each RPC call or reuse connections across multiple calls. Connection reuse improves performance by avoiding the overhead of TCP handshakes, but introduces complexity around connection state management, error recovery, and concurrent access.</p>\n<p>For this educational framework, we choose a simple connection-per-client model where each <code>RPCClient</code> instance maintains a single TCP connection that is established on first use and reused for all subsequent calls from that client instance. This strikes a balance between simplicity and performance while avoiding the complexity of connection pooling.</p>\n<blockquote>\n<p><strong>Decision: Connection Reuse Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Each RPC call could create a new TCP connection or reuse an existing connection, with trade-offs between simplicity and performance</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>New connection per call (simple but slow)</li>\n<li>Single persistent connection per client (balanced)</li>\n<li>Connection pool with multiple connections (complex but scalable)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Single persistent connection per client instance</li>\n<li><strong>Rationale</strong>: Provides good performance for typical usage patterns while keeping implementation simple. Most applications create one client instance and make many calls, so connection reuse provides significant benefits without the complexity of pool management.</li>\n<li><strong>Consequences</strong>: Better performance than connection-per-call, simpler than connection pooling, but limits concurrency to one outstanding request per client instance.</li>\n</ul>\n</blockquote>\n<p><strong>Connection Management States:</strong></p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th>Description</th>\n<th>Valid Transitions</th>\n<th>Trigger Events</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Disconnected</code></td>\n<td>No active connection, client is ready to connect</td>\n<td><code>Connecting</code></td>\n<td>First RPC call made</td>\n</tr>\n<tr>\n<td><code>Connecting</code></td>\n<td>TCP connection establishment in progress</td>\n<td><code>Connected</code>, <code>Failed</code></td>\n<td>Socket connect completes or times out</td>\n</tr>\n<tr>\n<td><code>Connected</code></td>\n<td>Active connection ready for requests</td>\n<td><code>Sending</code>, <code>Disconnected</code></td>\n<td>RPC call made or connection error detected</td>\n</tr>\n<tr>\n<td><code>Sending</code></td>\n<td>Request being sent over connection</td>\n<td><code>Waiting</code>, <code>Failed</code></td>\n<td>Send completes or socket error occurs</td>\n</tr>\n<tr>\n<td><code>Waiting</code></td>\n<td>Waiting for response from server</td>\n<td><code>Receiving</code>, <code>Timeout</code>, <code>Failed</code></td>\n<td>Response arrives, timeout expires, or connection error</td>\n</tr>\n<tr>\n<td><code>Receiving</code></td>\n<td>Reading response from server</td>\n<td><code>Connected</code>, <code>Failed</code></td>\n<td>Response fully received or read error</td>\n</tr>\n<tr>\n<td><code>Failed</code></td>\n<td>Connection failed and needs to be reset</td>\n<td><code>Disconnected</code></td>\n<td>Error handled and connection cleaned up</td>\n</tr>\n<tr>\n<td><code>Timeout</code></td>\n<td>Request timed out waiting for response</td>\n<td><code>Disconnected</code></td>\n<td>Timeout handled and connection closed</td>\n</tr>\n</tbody></table>\n<p><strong>Connection Management Interface:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>_ensure_connected</code></td>\n<td><code>timeout: float</code></td>\n<td><code>None</code></td>\n<td>Establishes connection if not already connected, raises <code>RPCTransportError</code> on failure</td>\n</tr>\n<tr>\n<td><code>_disconnect</code></td>\n<td><code>None</code></td>\n<td><code>None</code></td>\n<td>Closes the connection and resets state to disconnected</td>\n</tr>\n<tr>\n<td><code>_is_connected</code></td>\n<td><code>None</code></td>\n<td><code>bool</code></td>\n<td>Checks if the connection is active and healthy</td>\n</tr>\n<tr>\n<td><code>_handle_connection_error</code></td>\n<td><code>error: Exception</code></td>\n<td><code>None</code></td>\n<td>Handles connection failures by cleaning up and transitioning to failed state</td>\n</tr>\n<tr>\n<td><code>_reset_connection</code></td>\n<td><code>None</code></td>\n<td><code>None</code></td>\n<td>Forces connection reset for recovery from errors</td>\n</tr>\n</tbody></table>\n<p><strong>Connection Establishment Algorithm:</strong></p>\n<ol>\n<li>Client receives an RPC call and checks if connection exists and is healthy</li>\n<li>If no connection exists, create a new TCP socket using the configured host and port</li>\n<li>Set socket options for timeout and TCP keepalive to detect dead connections</li>\n<li>Attempt to connect to the server with the specified connection timeout</li>\n<li>If connection fails, raise <code>RPCTransportError</code> with details about the failure</li>\n<li>If connection succeeds, store the socket and transition to connected state</li>\n<li>For subsequent calls, reuse the existing connection if it&#39;s still healthy</li>\n<li>If the connection becomes unhealthy (detected during send/receive), close it and establish a new one</li>\n</ol>\n<p>The connection health check is performed before each RPC call by attempting to send/receive with a very short timeout. If this fails, the connection is considered dead and must be re-established. This handles cases where the server has closed the connection or network connectivity has been lost.</p>\n<blockquote>\n<p><strong>Implementation Note</strong>: Connection establishment should use a configurable timeout (default 5 seconds) to avoid hanging indefinitely when the server is unreachable. The timeout should be shorter than typical RPC call timeouts to provide fast feedback.</p>\n</blockquote>\n<h3 id=\"timeout-and-id-tracking\">Timeout and ID Tracking</h3>\n<p>Timeout and ID tracking ensures that RPC calls don&#39;t hang indefinitely and that responses are correctly matched to their originating requests. This is particularly important in network programming where messages can be delayed, reordered, or lost entirely.</p>\n<p>Each RPC request is assigned a unique request ID that allows the client to correlate responses with their originating requests. The client maintains a mapping of outstanding request IDs to their associated metadata (start time, timeout deadline, response callback) and actively monitors for timeouts.</p>\n<p>The timeout mechanism prevents clients from blocking forever when servers are unresponsive or when network connectivity is lost. When a timeout occurs, the client should clean up the pending request, close the connection (since the server may still send a late response), and raise a <code>RPCTimeoutError</code> to the calling code.</p>\n<blockquote>\n<p><strong>Design Challenge</strong>: The biggest challenge in timeout handling is deciding what to do with late responses. If a request times out but the server eventually sends a response, should we ignore it, log it, or handle it somehow? For simplicity, we close the connection on timeout to avoid out-of-order message handling.</p>\n</blockquote>\n<p><strong>Request Tracking Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>request_id</code></td>\n<td><code>str</code></td>\n<td>Unique identifier for this request, generated by <code>generate_request_id()</code></td>\n</tr>\n<tr>\n<td><code>method_name</code></td>\n<td><code>str</code></td>\n<td>Name of the remote method being called</td>\n</tr>\n<tr>\n<td><code>start_time</code></td>\n<td><code>float</code></td>\n<td>Timestamp when request was sent (from <code>time.time()</code>)</td>\n</tr>\n<tr>\n<td><code>timeout_deadline</code></td>\n<td><code>float</code></td>\n<td>Absolute time when request should timeout (<code>start_time + timeout</code>)</td>\n</tr>\n<tr>\n<td><code>response_received</code></td>\n<td><code>bool</code></td>\n<td>Flag indicating whether response has been received</td>\n</tr>\n<tr>\n<td><code>result</code></td>\n<td><code>Any</code></td>\n<td>Response result or error, set when response arrives</td>\n</tr>\n<tr>\n<td><code>condition</code></td>\n<td><code>threading.Condition</code></td>\n<td>Synchronization primitive for blocking until response or timeout</td>\n</tr>\n</tbody></table>\n<p><strong>Timeout Management Interface:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>_track_request</code></td>\n<td><code>request_id: str, timeout: float</code></td>\n<td><code>None</code></td>\n<td>Registers new request for timeout monitoring</td>\n</tr>\n<tr>\n<td><code>_wait_for_response</code></td>\n<td><code>request_id: str</code></td>\n<td><code>Dict</code></td>\n<td>Blocks until response received or timeout occurs</td>\n</tr>\n<tr>\n<td><code>_handle_response</code></td>\n<td><code>response: Dict</code></td>\n<td><code>None</code></td>\n<td>Processes incoming response and notifies waiting threads</td>\n</tr>\n<tr>\n<td><code>_cleanup_request</code></td>\n<td><code>request_id: str</code></td>\n<td><code>None</code></td>\n<td>Removes request from tracking and releases resources</td>\n</tr>\n<tr>\n<td><code>_check_timeout</code></td>\n<td><code>request_id: str</code></td>\n<td><code>bool</code></td>\n<td>Checks if request has exceeded its timeout deadline</td>\n</tr>\n</tbody></table>\n<p><strong>Request ID Generation Strategy:</strong></p>\n<p>Request IDs must be unique within the lifetime of a client instance to avoid response mismatching. A simple approach is to combine a timestamp with a counter, or use a UUID. The ID should be short enough to minimize message overhead but unique enough to avoid collisions.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Request ID Format: f&quot;{int(time.time() * 1000000)}-{counter}&quot;\nExample: &quot;1640995200123456-1&quot;, &quot;1640995200123457-2&quot;</code></pre></div>\n\n<p>This format provides microsecond timestamp precision combined with a sequential counter, making IDs unique and sortable while remaining human-readable for debugging.</p>\n<p><strong>Timeout Handling Algorithm:</strong></p>\n<ol>\n<li>When an RPC call begins, generate a unique request ID and calculate the timeout deadline</li>\n<li>Register the request in the tracking dictionary with its metadata and synchronization objects</li>\n<li>Send the request message to the server over the TCP connection</li>\n<li>Start blocking wait on the condition variable with the calculated timeout duration</li>\n<li>If a response arrives before timeout, <code>_handle_response</code> notifies the condition variable and the wait returns</li>\n<li>If the timeout expires first, clean up the request, close the connection, and raise <code>RPCTimeoutError</code></li>\n<li>Background response handling checks incoming message IDs against tracked requests</li>\n<li>When a matching response is found, store the result and notify the waiting thread</li>\n<li>If an unmatched response arrives (expired request), log it and discard it</li>\n</ol>\n<p>The timeout calculation should account for both network latency and server processing time. A reasonable default is 30 seconds for most applications, with the ability to customize per-call or per-client.</p>\n<blockquote>\n<p><strong>Concurrency Consideration</strong>: If we later add support for concurrent requests from a single client, the request tracking system is already designed to handle this with per-request condition variables and thread-safe dictionaries.</p>\n</blockquote>\n<h3 id=\"architecture-decision-records\">Architecture Decision Records</h3>\n<blockquote>\n<p><strong>Decision: Synchronous vs Asynchronous Client API</strong></p>\n<ul>\n<li><strong>Context</strong>: RPC calls could be synchronous (blocking until response) or asynchronous (return immediately with future/callback), affecting both API design and implementation complexity</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Synchronous only (simple, matches local call semantics)</li>\n<li>Asynchronous only (complex, requires event loop or callback handling)</li>\n<li>Both synchronous and asynchronous APIs (flexible but doubles implementation complexity)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Synchronous only for this educational framework</li>\n<li><strong>Rationale</strong>: Synchronous calls match the semantics of local function calls, making the RPC abstraction more natural. Implementation is significantly simpler without callback management or event loops. Most RPC use cases can tolerate blocking calls, and async can be added later.</li>\n<li><strong>Consequences</strong>: Simple implementation and natural API, but limits throughput for I/O-bound applications that could benefit from async concurrency.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Synchronous Only</td>\n<td>Simple implementation, natural API, matches local calls</td>\n<td>Blocks threads, limited concurrency</td>\n</tr>\n<tr>\n<td>Asynchronous Only</td>\n<td>High concurrency, non-blocking</td>\n<td>Complex implementation, unnatural API for beginners</td>\n</tr>\n<tr>\n<td>Both APIs</td>\n<td>Flexible, covers all use cases</td>\n<td>Double implementation complexity, API confusion</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Connection Pooling vs Single Connection</strong></p>\n<ul>\n<li><strong>Context</strong>: Clients could use a pool of connections for higher concurrency or a single connection per client for simplicity</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Single persistent connection per client (simple, adequate for most use cases)</li>\n<li>Connection pool with multiple connections (complex, supports high concurrency)</li>\n<li>New connection per request (very simple but poor performance)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Single persistent connection per client instance</li>\n<li><strong>Rationale</strong>: Most applications create one client instance and use it throughout the program lifetime. A single connection provides good performance through reuse while avoiding the complexity of pool management, sizing, and cleanup.</li>\n<li><strong>Consequences</strong>: Good performance for typical usage, simple implementation, but limits each client instance to one outstanding request at a time.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single Connection</td>\n<td>Simple, good performance, easy connection management</td>\n<td>No concurrency within one client</td>\n</tr>\n<tr>\n<td>Connection Pool</td>\n<td>High concurrency, optimal resource usage</td>\n<td>Complex implementation, pool sizing decisions</td>\n</tr>\n<tr>\n<td>Per-Request Connection</td>\n<td>Very simple, no state management</td>\n<td>Poor performance, high overhead</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Error Handling Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Network and RPC errors need to be presented to application code in a way that&#39;s both informative and actionable</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Generic exceptions with error codes (simple but less type-safe)</li>\n<li>Specific exception types for each error category (more complex but better handling)</li>\n<li>Error return values instead of exceptions (doesn&#39;t match Python conventions)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Specific exception hierarchy with <code>RPCError</code> base class</li>\n<li><strong>Rationale</strong>: Python developers expect exceptions for error conditions. Specific exception types allow application code to handle different error categories appropriately (retry network errors, don&#39;t retry method not found errors).</li>\n<li><strong>Consequences</strong>: More exception classes to implement and document, but better error handling capabilities and more Pythonic API design.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Specific Exception Types</td>\n<td>Type-safe, targeted handling, clear semantics</td>\n<td>More classes to implement</td>\n</tr>\n<tr>\n<td>Generic Exceptions</td>\n<td>Simple implementation, fewer classes</td>\n<td>Less precise error handling</td>\n</tr>\n<tr>\n<td>Error Return Values</td>\n<td>Explicit error checking</td>\n<td>Un-Pythonic, easy to ignore errors</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Request ID Format</strong></p>\n<ul>\n<li><strong>Context</strong>: Request IDs must be unique within client lifetime and should be efficient to generate and compare</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Sequential integers (simple but not globally unique)</li>\n<li>UUIDs (globally unique but longer and less human-readable)</li>\n<li>Timestamp + counter combination (unique, sortable, readable)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Timestamp + counter combination format</li>\n<li><strong>Rationale</strong>: Provides uniqueness within client lifetime (sufficient for our use case), remains human-readable for debugging, and creates sortable IDs that can help with troubleshooting message ordering issues.</li>\n<li><strong>Consequences</strong>: Slightly more complex ID generation than simple counters, but much more debuggable than UUIDs and adequate uniqueness for single-client scenarios.</li>\n</ul>\n</blockquote>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Forgetting to Handle Connection Failures During RPC Calls</strong></p>\n<p>Many beginners assume that once a connection is established, it will remain healthy for the duration of the program. However, network connections can fail at any time due to server restarts, network partitions, or idle timeouts. If the client doesn&#39;t detect and handle connection failures, RPC calls will hang or fail with cryptic socket errors.</p>\n<p><strong>Why this is wrong</strong>: Socket operations (send/receive) can fail even after successful connection establishment. The server might close the connection, the network might drop packets, or intermediate firewalls might reset connections. Without proper error detection, clients become unusable after the first connection failure.</p>\n<p><strong>How to fix</strong>: Always wrap socket operations in try/catch blocks and handle connection errors by closing the socket, transitioning to disconnected state, and optionally retrying the connection. Implement connection health checks before each RPC call to detect dead connections early.</p>\n<p>⚠️ <strong>Pitfall: Not Cleaning Up Timed-Out Requests</strong></p>\n<p>When a request times out, beginners often simply raise a timeout exception but leave the request tracking data structures intact. This causes memory leaks as the request dictionary grows, and can lead to confusion if late responses eventually arrive.</p>\n<p><strong>Why this is wrong</strong>: Timed-out requests consume memory indefinitely, and late responses might be delivered to the wrong caller if request IDs are reused. Additionally, the connection state becomes uncertain since the server might still send a response.</p>\n<p><strong>How to fix</strong>: Always clean up request tracking data when a timeout occurs, and close the connection to prevent out-of-order responses. Use <code>_cleanup_request()</code> to remove the request from tracking dictionaries and release condition variables.</p>\n<p>⚠️ <strong>Pitfall: Making Method Proxies That Don&#39;t Preserve Call Semantics</strong></p>\n<p>When implementing method proxying with <code>__getattr__</code>, beginners sometimes return the actual RPC result from <code>__getattr__</code> instead of returning a callable. This breaks the natural method call syntax and makes the API confusing.</p>\n<p><strong>Why this is wrong</strong>: <code>proxy.method_name</code> should return a callable that can be invoked with arguments, not execute the RPC call immediately. The call <code>proxy.method_name(args)</code> requires two steps: first get the callable, then invoke it with arguments.</p>\n<p><strong>How to fix</strong>: <code>__getattr__</code> should return a callable (lambda or bound method) that captures the method name and performs the RPC call when invoked. Don&#39;t execute the RPC call from within <code>__getattr__</code>.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Parameter Serialization Validation</strong></p>\n<p>JSON serialization has limitations on supported data types. Beginners often pass objects that can&#39;t be serialized (like file handles, custom classes, or functions) and get confusing errors during the RPC call rather than at parameter validation time.</p>\n<p><strong>Why this is wrong</strong>: Serialization errors happen deep in the call stack and provide poor error messages. It&#39;s better to validate parameters early and provide clear feedback about what types are supported.</p>\n<p><strong>How to fix</strong>: Implement <code>_validate_parameters()</code> that checks all arguments and keyword arguments for JSON serializability before creating the RPC request. Provide clear error messages explaining what types are supported.</p>\n<p>⚠️ <strong>Pitfall: Race Conditions in Response Handling</strong></p>\n<p>When implementing request tracking with threading, beginners sometimes access the tracking dictionary without proper synchronization, leading to race conditions where responses are lost or delivered to the wrong caller.</p>\n<p><strong>Why this is wrong</strong>: Multiple threads accessing shared data structures without synchronization can cause data corruption, lost responses, or responses delivered to the wrong waiting thread.</p>\n<p><strong>How to fix</strong>: Use threading primitives (locks, condition variables) consistently around all access to shared data structures. Each request should have its own condition variable for waiting, and the tracking dictionary should be protected with a lock.</p>\n<p>⚠️ <strong>Pitfall: Not Handling Partial Socket Reads/Writes</strong></p>\n<p>TCP sockets don&#39;t guarantee that <code>send()</code> will send all bytes or that <code>recv()</code> will receive the complete message in one call. Beginners often assume that one <code>recv()</code> call will return the complete response message, leading to protocol errors when messages are split across multiple TCP packets.</p>\n<p><strong>Why this is wrong</strong>: TCP is a stream protocol, not a message protocol. Large messages will be split across multiple packets, and small messages might be combined into one packet. Without proper message framing and complete read/write handling, messages become corrupted.</p>\n<p><strong>How to fix</strong>: Use the length-prefixed message framing from the protocol design, and implement <code>send_all()</code> and <code>recv_all()</code> utility functions that loop until all bytes are sent/received. Always read the length prefix first, then read exactly that many bytes for the message body.</p>\n<p><img src=\"/api/project/rpc-basic/architecture-doc/asset?path=diagrams%2Fclient-state-machine.svg\" alt=\"Client Request State Machine\"></p>\n<p><img src=\"/api/project/rpc-basic/architecture-doc/asset?path=diagrams%2Frpc-call-sequence.svg\" alt=\"RPC Call Sequence\"></p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides concrete implementation guidance for building the RPC client component in Python. The client is responsible for method proxying, connection management, and request/response handling.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network Transport</td>\n<td>Raw TCP sockets with JSON</td>\n<td>HTTP with requests library</td>\n</tr>\n<tr>\n<td>Serialization</td>\n<td>Built-in <code>json</code> module</td>\n<td><code>msgpack</code> for binary efficiency</td>\n</tr>\n<tr>\n<td>Concurrency</td>\n<td>Threading with condition variables</td>\n<td><code>asyncio</code> for async support</td>\n</tr>\n<tr>\n<td>Connection Management</td>\n<td>Single persistent connection</td>\n<td>Connection pooling with queue</td>\n</tr>\n<tr>\n<td>Timeout Handling</td>\n<td>Socket timeouts with threading</td>\n<td><code>select()</code> or <code>epoll()</code> for non-blocking</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc_framework/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   client/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#     __init__.py          ← exports RPCClient and proxy classes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#     client.py            ← main RPCClient implementation  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#     proxy.py             ← method proxy implementation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#     connection.py        ← connection management utilities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#     exceptions.py        ← client-specific exceptions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#   common/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#     protocol.py          ← shared protocol utilities (from Milestone 1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#     socket_helper.py     ← socket utilities (from server implementation)</span></span></code></pre></div>\n\n<p><strong>Infrastructure Starter Code (Complete Socket Helper):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc_framework/common/socket_helper.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> struct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SocketHelper</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Utility class for reliable socket operations with timeout support.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> send_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Send all bytes, handling partial sends and timeouts.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sock.settimeout(timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_sent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> total_sent </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(data):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                sent </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sock.send(data[total_sent:])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> sent </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#9ECBFF\">\"Socket connection broken during send\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                total_sent </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> sent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> socket.timeout:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTimeoutError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Send timeout after </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">timeout</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> seconds\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> socket.error </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Socket send error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recv_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Receive exactly size bytes, handling partial receives and timeouts.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sock.settimeout(timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        chunks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bytes_received </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> bytes_received </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> size:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sock.recv(</span><span style=\"color:#79B8FF\">min</span><span style=\"color:#E1E4E8\">(size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> bytes_received, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> chunk:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#9ECBFF\">\"Socket connection closed during receive\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                chunks.append(chunk)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                bytes_received </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(chunk)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> socket.timeout:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTimeoutError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Receive timeout after </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">timeout</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> seconds\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> socket.error </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Socket receive error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">.join(chunks)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recv_message</span><span style=\"color:#E1E4E8\">(sock: socket.socket, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Receive length-prefixed message using protocol framing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # First, receive 4-byte length prefix</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SocketHelper.recv_all(sock, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> struct.unpack(</span><span style=\"color:#9ECBFF\">'!I'</span><span style=\"color:#E1E4E8\">, length_bytes)[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Then receive the message body</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> message_length </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># 1MB limit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> RPCProtocolError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Message too large: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">message_length</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> SocketHelper.recv_all(sock, message_length, timeout)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> send_message</span><span style=\"color:#E1E4E8\">(sock: socket.socket, message_bytes: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Send length-prefixed message using protocol framing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(message_bytes) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># 1MB limit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> RPCProtocolError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Message too large: </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(message_bytes)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Send 4-byte length prefix followed by message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length_prefix </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> struct.pack(</span><span style=\"color:#9ECBFF\">'!I'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(message_bytes))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SocketHelper.send_all(sock, length_prefix </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> message_bytes, timeout)</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton (Client Implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc_framework/client/client.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..common.protocol </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> generate_request_id, create_request_message, deserialize_message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..common.socket_helper </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SocketHelper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> RPCError, RPCTransportError, RPCTimeoutError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCClient</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"RPC client with connection management and request tracking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, host: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'localhost'</span><span style=\"color:#E1E4E8\">, port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 8000</span><span style=\"color:#E1E4E8\">, default_timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.host </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> host</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> port</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.default_timeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> default_timeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Connection management</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._socket: Optional[socket.socket] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._connected </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._connection_lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> threading.Lock()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Request tracking</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._pending_requests: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Dict] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._request_lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> threading.Lock()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Response handling</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._response_thread: Optional[threading.Thread] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._shutdown_event </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> threading.Event()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> call</span><span style=\"color:#E1E4E8\">(self, method_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, timeout: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Make an RPC call and return the result.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> timeout </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            timeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.default_timeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate unique request ID using generate_request_id()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate that all parameters are JSON-serializable </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create request message using create_request_message()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Ensure connection is established using _ensure_connected()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Register request for tracking using _track_request()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Send request message using SocketHelper.send_message()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Wait for response using _wait_for_response()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Clean up request tracking using _cleanup_request()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Return result or raise appropriate exception based on response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Wrap steps 4-6 in try/catch to handle connection errors</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _ensure_connected</span><span style=\"color:#E1E4E8\">(self, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Establish connection if not already connected.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._connection_lock:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._connected </span><span style=\"color:#F97583\">and</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._socket:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if existing connection is still healthy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If healthy, return early without reconnecting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create new TCP socket with appropriate options</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Set socket timeout for connection attempt  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Connect to (self.host, self.port) with error handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Start response handling thread using _start_response_thread()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Set self._connected = True and store socket reference</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Use socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _track_request</span><span style=\"color:#E1E4E8\">(self, request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register request for response tracking and timeout monitoring.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        request_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'start_time'</span><span style=\"color:#E1E4E8\">: time.time(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'timeout_deadline'</span><span style=\"color:#E1E4E8\">: time.time() </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> timeout,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'response_received'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'result'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'condition'</span><span style=\"color:#E1E4E8\">: threading.Condition()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._request_lock:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Add request_info to self._pending_requests[request_id]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate that request_id is not already in use</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _wait_for_response</span><span style=\"color:#E1E4E8\">(self, request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Block until response received or timeout occurs.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._request_lock:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> request_id </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._pending_requests:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Request </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">request_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> not found in tracking\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            request_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._pending_requests[request_id]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            condition </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request_info[</span><span style=\"color:#9ECBFF\">'condition'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#E1E4E8\"> condition:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate remaining timeout based on deadline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Wait on condition variable with timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check if response was received or timeout occurred</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the response or raise RPCTimeoutError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Use condition.wait(timeout) and check return value</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _start_response_thread</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Start background thread to handle incoming responses.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._response_thread </span><span style=\"color:#F97583\">and</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._response_thread.is_alive():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._shutdown_event.clear()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._response_thread </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> threading.Thread(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            target</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._response_handler,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            daemon</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"RPC-ResponseHandler\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._response_thread.start()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _response_handler</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Background thread that receives and dispatches responses.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._shutdown_event.is_set():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Receive message using SocketHelper.recv_message()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Deserialize message using deserialize_message()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Extract request_id from response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Find matching pending request using request_id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Store response in request_info and notify waiting thread</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle case where no matching request found (log and discard)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Hint: Use short timeout on recv_message to allow shutdown checking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> socket.timeout:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Continue loop to check shutdown event</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Handle connection errors by breaking loop and disconnecting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _cleanup_request</span><span style=\"color:#E1E4E8\">(self, request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Remove request from tracking and release resources.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._request_lock:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Remove request_id from self._pending_requests if present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle case where request_id not found (already cleaned up)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _disconnect</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Close connection and clean up resources.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._connection_lock:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Set shutdown event to stop response thread</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Close socket if it exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Wait for response thread to finish</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Reset connection state variables</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Clean up any pending requests with connection errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __enter__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Context manager entry.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __exit__</span><span style=\"color:#E1E4E8\">(self, exc_type, exc_val, exc_tb):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Context manager exit - clean up connection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._disconnect()</span></span></code></pre></div>\n\n<p><strong>Method Proxy Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc_framework/client/proxy.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Callable</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCProxy</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Proxy object that converts method calls to RPC requests.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, client, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Use object.__setattr__ to avoid infinite recursion with __getattr__</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        object</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__setattr__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'_client'</span><span style=\"color:#E1E4E8\">, client)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        object</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__setattr__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'_timeout'</span><span style=\"color:#E1E4E8\">, timeout)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        object</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__setattr__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'_method_cache'</span><span style=\"color:#E1E4E8\">, {})</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __getattr__</span><span style=\"color:#E1E4E8\">(self, method_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Callable:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create proxy method for any attribute access.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check method cache for existing proxy function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If not cached, create new proxy function using _create_method_proxy()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Store in cache and return the callable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Cache improves performance for repeated calls to same method</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _create_method_proxy</span><span style=\"color:#E1E4E8\">(self, method_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Callable:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create a callable that performs RPC call for the given method.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#B392F0\"> proxy_method</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Call self._client.call() with method_name and arguments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Use self._timeout if specified, otherwise client default</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return result from RPC call</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Set helpful attributes for debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proxy_method.</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> method_name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proxy_method.</span><span style=\"color:#79B8FF\">__doc__</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"RPC proxy for remote method '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">method_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> proxy_method</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_json_serializable</span><span style=\"color:#E1E4E8\">(self, obj: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate that object can be JSON serialized.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Attempt to JSON serialize the object  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Raise clear error message if serialization fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Include information about supported types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            json.dumps(obj)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">TypeError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">ValueError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> RPCError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Parameter not JSON serializable: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">. \"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         f</span><span style=\"color:#9ECBFF\">\"Supported types: str, int, float, bool, list, dict, None\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Language-Specific Implementation Hints:</strong></p>\n<ol>\n<li><p><strong>Socket Management</strong>: Use <code>socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code> for TCP connections. Always set timeouts with <code>sock.settimeout()</code> to avoid infinite blocking.</p>\n</li>\n<li><p><strong>Threading Synchronization</strong>: Use <code>threading.Condition</code> for request/response coordination and <code>threading.Lock</code> for protecting shared data structures. Condition variables are perfect for the &quot;wait for specific response&quot; pattern.</p>\n</li>\n<li><p><strong>JSON Validation</strong>: Use <code>json.dumps()</code> in a try/catch block to validate serializability. The <code>json</code> module raises <code>TypeError</code> for unserializable objects.</p>\n</li>\n<li><p><strong>Context Managers</strong>: Implement <code>__enter__</code> and <code>__exit__</code> methods so clients can be used with <code>with</code> statements for automatic cleanup.</p>\n</li>\n<li><p><strong>Magic Methods</strong>: Use <code>object.__setattr__()</code> in <code>RPCProxy.__init__()</code> to avoid triggering <code>__getattr__</code> during initialization.</p>\n</li>\n</ol>\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing the client component, verify functionality with this test:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># test_client.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_basic_client</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Assuming server is running with a 'add' method</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    with</span><span style=\"color:#E1E4E8\"> RPCClient(</span><span style=\"color:#9ECBFF\">'localhost'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8000</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> client:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proxy </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> RPCProxy(client)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Test basic method call</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proxy.add(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        assert</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Test timeout behavior</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            proxy.slow_method(</span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            assert</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Should have timed out\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> RPCTimeoutError:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span><span style=\"color:#6A737D\">  # Expected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ Client implementation working correctly\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> __name__</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#9ECBFF\"> \"__main__\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    test_basic_client()</span></span></code></pre></div>\n\n<p>Expected behavior:</p>\n<ul>\n<li>Client connects to server automatically on first call</li>\n<li>Method calls return results as if they were local functions  </li>\n<li>Timeouts raise <code>RPCTimeoutError</code> after specified duration</li>\n<li>Connection is reused for multiple calls</li>\n<li>Resources are cleaned up when client exits context manager</li>\n</ul>\n<p><strong>Common Implementation Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Connection refused&quot;</td>\n<td>Server not running or wrong port</td>\n<td>Check server status and port configuration</td>\n</tr>\n<tr>\n<td>Calls hang forever</td>\n<td>No timeout set on socket operations</td>\n<td>Always use <code>sock.settimeout()</code> before socket operations</td>\n</tr>\n<tr>\n<td>&quot;Broken pipe&quot; errors</td>\n<td>Server closed connection unexpectedly</td>\n<td>Implement connection health checks and retry logic</td>\n</tr>\n<tr>\n<td>Responses to wrong calls</td>\n<td>Race condition in request tracking</td>\n<td>Use proper locking around <code>_pending_requests</code> dictionary</td>\n</tr>\n<tr>\n<td>Memory leaks</td>\n<td>Requests not cleaned up after timeout</td>\n<td>Always call <code>_cleanup_request()</code> in finally blocks</td>\n</tr>\n</tbody></table>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Integration of Milestones 1, 2, and 3 - demonstrates how message protocol, server, and client work together to execute remote procedure calls</p>\n</blockquote>\n<h3 id=\"mental-model-the-phone-call-choreography\">Mental Model: The Phone Call Choreography</h3>\n<p>Think of an RPC call like a carefully choreographed business phone call. The client (caller) dials the server (receiver), speaks a structured message in a shared language (protocol), waits for a response, and hangs up. Just like a phone call has predictable stages - dialing, waiting for pickup, speaking, listening, confirming understanding, hanging up - an RPC call follows a precise sequence that both sides understand.</p>\n<p>The magic happens because both parties follow the same &quot;business phone etiquette&quot; - they know when to speak, what format to use, how to handle misunderstandings, and how to gracefully end the conversation. When something goes wrong (busy signal, wrong number, bad connection), there are standard ways to handle each situation.</p>\n<p>This choreography is crucial because unlike a local function call that happens in nanoseconds within the same process, an RPC call crosses network boundaries, involves serialization, and can fail in dozens of ways. The protocol and error handling ensure that despite this complexity, the client can still pretend it&#39;s just calling a local function.</p>\n<h2 id=\"rpc-call-sequence\">RPC Call Sequence</h2>\n<p>The successful RPC call sequence represents the &quot;happy path&quot; where everything works as designed. This sequence involves precise coordination between the client proxy, network transport layer, and server dispatcher to maintain the illusion that the remote function call is local.</p>\n<p><img src=\"/api/project/rpc-basic/architecture-doc/asset?path=diagrams%2Frpc-call-sequence.svg\" alt=\"RPC Call Sequence\"></p>\n<h3 id=\"step-by-step-call-flow\">Step-by-Step Call Flow</h3>\n<p>The complete RPC call sequence involves eleven distinct steps that transform a local method invocation into a remote procedure execution and back again:</p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Component</th>\n<th>Action</th>\n<th>Data Transformed</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Client Code</td>\n<td>Invokes method on proxy object</td>\n<td><code>calc.add(5, 3)</code></td>\n<td>Triggers RPC call</td>\n</tr>\n<tr>\n<td>2</td>\n<td>RPCProxy</td>\n<td>Intercepts call via <code>__getattr__</code></td>\n<td>Method name + args → internal call</td>\n<td>Transparent proxying</td>\n</tr>\n<tr>\n<td>3</td>\n<td>RPCClient</td>\n<td>Generates request ID and creates message</td>\n<td>Args → JSON-RPC request dict</td>\n<td>Message preparation</td>\n</tr>\n<tr>\n<td>4</td>\n<td>RPCClient</td>\n<td>Serializes and sends message</td>\n<td>Request dict → length-prefixed bytes</td>\n<td>Network transmission</td>\n</tr>\n<tr>\n<td>5</td>\n<td>RPCServer</td>\n<td>Receives and deserializes message</td>\n<td>Bytes → request dict</td>\n<td>Message reception</td>\n</tr>\n<tr>\n<td>6</td>\n<td>RPCServer</td>\n<td>Looks up method in registry</td>\n<td>Method name → callable function</td>\n<td>Method resolution</td>\n</tr>\n<tr>\n<td>7</td>\n<td>RPCServer</td>\n<td>Executes registered function</td>\n<td>Parameters → result value</td>\n<td>Actual computation</td>\n</tr>\n<tr>\n<td>8</td>\n<td>RPCServer</td>\n<td>Creates and serializes response</td>\n<td>Result → JSON-RPC response bytes</td>\n<td>Response preparation</td>\n</tr>\n<tr>\n<td>9</td>\n<td>RPCClient</td>\n<td>Receives and deserializes response</td>\n<td>Bytes → response dict</td>\n<td>Response reception</td>\n</tr>\n<tr>\n<td>10</td>\n<td>RPCClient</td>\n<td>Matches response to pending request</td>\n<td>Request ID → waiting thread</td>\n<td>Response correlation</td>\n</tr>\n<tr>\n<td>11</td>\n<td>Client Code</td>\n<td>Receives result as return value</td>\n<td>Response dict → Python object</td>\n<td>Transparent result</td>\n</tr>\n</tbody></table>\n<h4 id=\"detailed-sequence-narrative\">Detailed Sequence Narrative</h4>\n<p><strong>Phase 1: Client-Side Request Preparation</strong></p>\n<p>The sequence begins when application code invokes what appears to be a method on a local object. For example, when the code calls <code>calc.add(5, 3)</code>, the <code>calc</code> object is actually an <code>RPCProxy</code> instance that intercepts this call through Python&#39;s <code>__getattr__</code> mechanism. The proxy recognizes that <code>add</code> is not a local method and triggers the RPC machinery.</p>\n<p>The <code>RPCProxy</code> delegates to its underlying <code>RPCClient</code>, which performs several critical preparation steps. First, it generates a unique request ID using <code>generate_request_id()</code> to ensure this request can be correlated with its eventual response. The client maintains a dictionary of pending requests keyed by these IDs, which is essential for handling concurrent calls on the same connection.</p>\n<p>Next, the client constructs a JSON-RPC request message using <code>create_request_message()</code>. This transforms the method name &quot;add&quot;, parameters <code>[5, 3]</code>, and generated request ID into a standardized dictionary format that the server can parse. The message includes version information and follows the JSON-RPC 2.0 specification exactly.</p>\n<p><strong>Phase 2: Network Transmission</strong></p>\n<p>The client serializes the request message using <code>serialize_message()</code>, which converts the Python dictionary to JSON bytes and prepends a 4-byte length prefix for message framing. This length prefix is crucial because TCP provides a byte stream without message boundaries - the server needs to know exactly how many bytes constitute one complete message.</p>\n<p>Before sending, the client calls <code>_ensure_connected()</code> to establish a TCP connection if one doesn&#39;t exist or verify that the existing connection is still healthy. Connection reuse is important for performance since establishing new TCP connections for every RPC call would add significant latency.</p>\n<p>The client then transmits the serialized message using <code>send_all()</code>, which handles the complexity of partial sends. TCP doesn&#39;t guarantee that all bytes are sent in a single <code>send()</code> call, so this helper function loops until all bytes are transmitted successfully.</p>\n<p><strong>Phase 3: Server-Side Request Processing</strong></p>\n<p>The server receives the incoming bytes through its <code>handle_connection()</code> method running in a dedicated thread for this client connection. The server first reads the 4-byte length prefix to determine how many additional bytes constitute the complete message, then reads exactly that many bytes using <code>recv_all()</code>.</p>\n<p>Once the complete message is received, the server deserializes it back into a Python dictionary using <code>deserialize_message()</code>. The server validates that this is a well-formed JSON-RPC request with all required fields (method, params, id, jsonrpc version).</p>\n<p>The server&#39;s <code>process_request()</code> method handles the core dispatch logic. It extracts the method name from the request and looks it up in the <code>MethodRegistry</code>. If the method exists, the server unpacks the parameters and invokes the registered function directly. The beauty of this approach is that any Python function can be registered - the server doesn&#39;t need special knowledge about what &quot;add&quot; does, it just calls the registered function with the provided parameters.</p>\n<p><strong>Phase 4: Server-Side Response Generation</strong></p>\n<p>After the registered function executes successfully and returns a result, the server packages this result into a JSON-RPC response message using <code>create_response_message()</code>. The response includes the original request ID (crucial for correlation), the result value, and the JSON-RPC version identifier.</p>\n<p>The server serializes this response message the same way as requests - JSON encoding with a length prefix - and transmits it back to the client using the same TCP connection. The bidirectional nature of the connection allows responses to flow back through the same socket.</p>\n<p><strong>Phase 5: Client-Side Response Handling</strong></p>\n<p>Meanwhile, the client has been blocking in <code>_wait_for_response()</code>, continuously reading from the socket for incoming messages. When the response arrives, the client deserializes it and extracts the request ID to determine which pending request this response satisfies.</p>\n<p>The client&#39;s request tracking mechanism uses the ID to find the correct thread or callback waiting for this response. For blocking calls, this typically means unblocking the thread that made the original RPC call and returning the result value.</p>\n<p>Finally, the client cleans up the request from its pending requests dictionary and returns the result to the application code. From the application&#39;s perspective, the call to <code>calc.add(5, 3)</code> simply returned <code>8</code> - all the network complexity was hidden by the RPC framework.</p>\n<h3 id=\"timing-and-concurrency-considerations\">Timing and Concurrency Considerations</h3>\n<p>The RPC call sequence must handle several timing and concurrency challenges that don&#39;t exist in local function calls:</p>\n<p><strong>Request ID Management</strong>: Since multiple threads might make concurrent RPC calls on the same client connection, the request ID mechanism prevents responses from being delivered to the wrong caller. Each request gets a unique ID, and responses are routed back to the correct waiting thread.</p>\n<p><strong>Connection State</strong>: The client must manage the TCP connection lifecycle carefully. Connections can break at any time due to network issues, server restarts, or firewall timeouts. The client detects these failures during send or receive operations and can optionally retry or reconnect.</p>\n<p><strong>Server Threading</strong>: The server handles multiple client connections concurrently, with each connection processed in its own thread. Within each connection thread, requests are processed sequentially to maintain ordering guarantees. This threading model is simple but scales reasonably well for moderate loads.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: The request ID serves as the critical coordination mechanism that allows multiple concurrent RPC calls to share the same TCP connection without interference. Without this correlation mechanism, responses could be delivered to the wrong caller, causing subtle and hard-to-debug errors.</p>\n</blockquote>\n<h2 id=\"error-flow\">Error Flow</h2>\n<p>Error handling in RPC systems is significantly more complex than local function calls because failures can occur at multiple layers - network, protocol, serialization, and application logic. The error flow must gracefully handle each category and provide meaningful feedback to the client application.</p>\n<h3 id=\"error-categories-and-propagation\">Error Categories and Propagation</h3>\n<p>RPC errors fall into four distinct categories, each handled differently by the framework:</p>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Detection Point</th>\n<th>Error Type</th>\n<th>Propagation Method</th>\n<th>Client Experience</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network Errors</td>\n<td>Client or Server</td>\n<td><code>RPCTransportError</code></td>\n<td>Exception raised immediately</td>\n<td>Connection refused, timeout</td>\n</tr>\n<tr>\n<td>Protocol Errors</td>\n<td>Client or Server</td>\n<td><code>RPCProtocolError</code></td>\n<td>JSON-RPC error response</td>\n<td>Invalid request format</td>\n</tr>\n<tr>\n<td>Method Errors</td>\n<td>Server</td>\n<td><code>RPCMethodError</code></td>\n<td>JSON-RPC error response</td>\n<td>Method not found, bad params</td>\n</tr>\n<tr>\n<td>Execution Errors</td>\n<td>Server</td>\n<td><code>RPCMethodError</code></td>\n<td>JSON-RPC error response</td>\n<td>Exception in user code</td>\n</tr>\n</tbody></table>\n<h4 id=\"network-error-flow\">Network Error Flow</h4>\n<p>Network errors represent failures in the underlying TCP communication and are the most disruptive type of RPC failure. These errors are detected at the socket layer and cannot be communicated through the normal JSON-RPC response mechanism because the communication channel itself is compromised.</p>\n<p>When a network error occurs during <code>send_all()</code> or <code>recv_all()</code>, the client immediately raises an <code>RPCTransportError</code> exception. The client also marks its connection as broken and closes the socket to prevent further attempts to use the damaged connection. Subsequent RPC calls will trigger connection re-establishment.</p>\n<p>Common network error scenarios include:</p>\n<ol>\n<li><strong>Connection Refused</strong>: Server is not running or not accepting connections on the specified port</li>\n<li><strong>Connection Reset</strong>: Server process crashed or was forcibly terminated</li>\n<li><strong>Connection Timeout</strong>: Network is unreachable or server is not responding within timeout period</li>\n<li><strong>Partial Send/Receive</strong>: Connection was broken mid-transmission, leaving message incomplete</li>\n</ol>\n<p>The client handles these by immediately cleaning up the broken connection and propagating the transport error to the application. The application can choose to retry, connect to an alternative server, or fail gracefully.</p>\n<h4 id=\"protocol-error-flow\">Protocol Error Flow</h4>\n<p>Protocol errors occur when messages don&#39;t conform to the JSON-RPC specification, even though network communication is successful. These errors can be detected by either client or server during message parsing and validation.</p>\n<p>Server-detected protocol errors follow this sequence:</p>\n<ol>\n<li>Server receives and deserializes message successfully</li>\n<li>Server validates message format and discovers violation (missing required field, invalid JSON-RPC version, malformed structure)</li>\n<li>Server creates JSON-RPC error response with appropriate error code (<code>PARSE_ERROR</code>, <code>INVALID_REQUEST</code>)</li>\n<li>Server sends error response back to client using normal response mechanism</li>\n<li>Client receives error response and raises <code>RPCProtocolError</code> with server&#39;s error details</li>\n</ol>\n<p>This approach allows protocol errors to be communicated through the normal RPC channel, providing detailed error information to help debug message format issues.</p>\n<h4 id=\"method-error-flow\">Method Error Flow</h4>\n<p>Method errors occur when the JSON-RPC message is well-formed but the requested method cannot be executed. This includes method-not-found errors and parameter validation failures.</p>\n<p>The method error sequence:</p>\n<ol>\n<li>Server successfully parses and validates request message format</li>\n<li>Server attempts to look up requested method name in <code>MethodRegistry</code></li>\n<li>If method not found, server creates error response with <code>METHOD_NOT_FOUND</code> error code</li>\n<li>If method found but parameter count/types don&#39;t match, server creates error response with <code>INVALID_PARAMS</code> error code</li>\n<li>Server sends JSON-RPC error response with detailed error information</li>\n<li>Client receives error response and raises <code>RPCMethodError</code> with method-specific error details</li>\n</ol>\n<p>This category of errors is particularly important for API usability - clear error messages help developers understand what methods are available and how to call them correctly.</p>\n<h4 id=\"execution-error-flow\">Execution Error Flow</h4>\n<p>Execution errors represent exceptions thrown by the registered method during actual execution. These are application-level errors that occur after successful method dispatch but during the business logic execution.</p>\n<p>The execution error handling sequence:</p>\n<ol>\n<li>Server successfully looks up method and begins execution</li>\n<li>Registered method raises exception during execution (divide by zero, invalid business logic, etc.)</li>\n<li>Server catches exception and examines its type</li>\n<li>Server creates JSON-RPC error response with <code>INTERNAL_ERROR</code> code and exception details</li>\n<li>Server sends error response back to client</li>\n<li>Client receives error response and raises <code>RPCMethodError</code> with execution error details</li>\n</ol>\n<blockquote>\n<p><strong>Design Decision: Exception Serialization</strong></p>\n<ul>\n<li><strong>Context</strong>: When user methods throw exceptions, we need to decide how much exception detail to send to clients</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Send full exception traceback including server file paths</li>\n<li>Send only exception message and type</li>\n<li>Send generic &quot;internal error&quot; message</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Send exception type and message but not full traceback</li>\n<li><strong>Rationale</strong>: Provides useful debugging information without exposing server implementation details or file system structure</li>\n<li><strong>Consequences</strong>: Clients get actionable error information while server security is maintained</li>\n</ul>\n</blockquote>\n<h3 id=\"error-response-message-format\">Error Response Message Format</h3>\n<p>All server-detected errors (protocol, method, and execution errors) are communicated using standardized JSON-RPC error response messages. This consistency allows clients to handle all server errors through the same mechanism.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n<th>Example Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>jsonrpc</td>\n<td>str</td>\n<td>JSON-RPC version identifier</td>\n<td>&quot;2.0&quot;</td>\n</tr>\n<tr>\n<td>id</td>\n<td>str/null</td>\n<td>Request ID from original request</td>\n<td>&quot;req_12345&quot;</td>\n</tr>\n<tr>\n<td>error</td>\n<td>dict</td>\n<td>Error details object</td>\n<td>See error object format</td>\n</tr>\n</tbody></table>\n<p>The error object within the response contains structured error information:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n<th>Example Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>code</td>\n<td>int</td>\n<td>Standard JSON-RPC error code</td>\n<td>-32601</td>\n</tr>\n<tr>\n<td>message</td>\n<td>str</td>\n<td>Human-readable error description</td>\n<td>&quot;Method not found&quot;</td>\n</tr>\n<tr>\n<td>data</td>\n<td>any</td>\n<td>Additional error-specific information</td>\n<td>{&quot;method&quot;: &quot;nonexistent&quot;}</td>\n</tr>\n</tbody></table>\n<h3 id=\"timeout-handling\">Timeout Handling</h3>\n<p>Timeout errors deserve special attention because they can occur even when both client and server are functioning correctly but network latency is high or server processing time exceeds expectations.</p>\n<p>The client&#39;s timeout mechanism works as follows:</p>\n<ol>\n<li>Client starts timeout timer when sending request</li>\n<li>Client blocks in <code>_wait_for_response()</code> but checks elapsed time periodically</li>\n<li>If timeout expires before response arrives, client raises <code>RPCTimeoutError</code></li>\n<li>Client marks request as timed out but keeps connection open (timeout doesn&#39;t necessarily indicate connection failure)</li>\n<li>If response eventually arrives for timed-out request, client discards it to prevent delivering stale results</li>\n</ol>\n<blockquote>\n<p><strong>Important Consideration</strong>: Timeout handling creates a potential resource leak. If the server eventually sends a response for a timed-out request, that response must be properly discarded to prevent it from being mistakenly matched to a future request with the same ID.</p>\n</blockquote>\n<h3 id=\"error-recovery-strategies\">Error Recovery Strategies</h3>\n<p>Different error categories suggest different recovery strategies for client applications:</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Suggested Recovery</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>RPCTransportError</code></td>\n<td>Retry with exponential backoff, try alternative server</td>\n<td>Network issues often transient</td>\n</tr>\n<tr>\n<td><code>RPCProtocolError</code></td>\n<td>Fix client code, don&#39;t retry</td>\n<td>Protocol violations indicate programming errors</td>\n</tr>\n<tr>\n<td><code>RPCMethodError</code> (not found)</td>\n<td>Fix client code, check available methods</td>\n<td>Method name typos or API misunderstanding</td>\n</tr>\n<tr>\n<td><code>RPCMethodError</code> (invalid params)</td>\n<td>Fix client code parameters</td>\n<td>Parameter type or count mismatch</td>\n</tr>\n<tr>\n<td><code>RPCMethodError</code> (execution)</td>\n<td>Retry with different parameters or fail gracefully</td>\n<td>Server-side business logic error</td>\n</tr>\n<tr>\n<td><code>RPCTimeoutError</code></td>\n<td>Retry with longer timeout or fail</td>\n<td>Server may be overloaded</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-error-scenarios\">Common Error Scenarios</h3>\n<p>Real-world RPC systems encounter several common error patterns that developers should be prepared to handle:</p>\n<p>⚠️ <strong>Pitfall: Ignoring Network Errors</strong>\nMany developers assume network connections are reliable and don&#39;t properly handle <code>RPCTransportError</code> exceptions. In production environments, networks frequently experience transient failures, server restarts, and connection drops. Applications should catch transport errors and implement appropriate retry logic rather than crashing on the first network hiccup.</p>\n<p>⚠️ <strong>Pitfall: Confusing Timeout with Failure</strong>\nA timeout doesn&#39;t necessarily mean the server is broken - it might just be processing a complex request that takes longer than expected. Immediately reducing timeout values or switching to alternative servers can make problems worse. Instead, applications should distinguish between timeout errors and other error types, potentially retrying with longer timeouts.</p>\n<p>⚠️ <strong>Pitfall: Leaking Request IDs</strong>\nIf request IDs are not properly managed, the client can run out of unique identifiers or accidentally reuse IDs while previous requests are still pending. This leads to response correlation errors where responses are delivered to the wrong callers. Proper cleanup in the error path is essential.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The error handling implementation requires careful coordination between exception types, error codes, and message formats to provide a consistent developer experience.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Types</td>\n<td>Standard Python exceptions with inheritance</td>\n<td>Custom exception hierarchy with error codes</td>\n</tr>\n<tr>\n<td>Error Serialization</td>\n<td>JSON with string messages</td>\n<td>Structured error objects with metadata</td>\n</tr>\n<tr>\n<td>Timeout Mechanism</td>\n<td>Simple socket timeout</td>\n<td>Configurable per-request timeouts</td>\n</tr>\n<tr>\n<td>Retry Logic</td>\n<td>Manual retry in application code</td>\n<td>Automatic retry with backoff in client</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>rpc_framework/\n├── exceptions.py          ← All RPC exception classes\n├── error_codes.py         ← JSON-RPC error code constants\n├── client.py             ← Client with error handling\n├── server.py             ← Server with error responses\n└── protocol.py           ← Error message creation helpers</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete Exception Hierarchy (exceptions.py)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"RPC Framework exception hierarchy for structured error handling.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for all RPC framework errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message, error_code</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, error_data</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.error_code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> error_code</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.error_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> error_data</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCTransportError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Network communication errors - connection refused, timeout, etc.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCProtocolError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"JSON-RPC protocol violations - malformed messages, version mismatch.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCMethodError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Method-related errors - not found, invalid params, execution failure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCTimeoutError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Request timeout - server didn't respond within specified time limit.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message, timeout_seconds):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.timeout_seconds </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timeout_seconds</span></span></code></pre></div>\n\n<p><strong>Error Code Constants (error_codes.py)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"JSON-RPC 2.0 standard error codes and framework-specific extensions.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># JSON-RPC 2.0 Standard Error Codes</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">PARSE_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32700</span><span style=\"color:#6A737D\">      # Invalid JSON received</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">INVALID_REQUEST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32600</span><span style=\"color:#6A737D\">  # JSON is not valid JSON-RPC request</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">METHOD_NOT_FOUND</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32601</span><span style=\"color:#6A737D\"> # Method does not exist or is not available</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">INVALID_PARAMS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32602</span><span style=\"color:#6A737D\">   # Invalid method parameter(s)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">INTERNAL_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32603</span><span style=\"color:#6A737D\">   # Internal JSON-RPC error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Framework-specific Error Codes (per JSON-RPC spec, -32000 to -32099 reserved)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">TRANSPORT_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32000</span><span style=\"color:#6A737D\">  # Network communication failure</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">TIMEOUT_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32001</span><span style=\"color:#6A737D\">    # Request timeout</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">CONNECTION_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32002</span><span style=\"color:#6A737D\"> # Connection establishment failure</span></span></code></pre></div>\n\n<h4 id=\"core-error-handling-skeleton\">Core Error Handling Skeleton</h4>\n<p><strong>Server Error Response Logic</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> process_request</span><span style=\"color:#E1E4E8\">(self, request):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Process incoming RPC request and return response or error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    request_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request.get(</span><span style=\"color:#9ECBFF\">'id'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate JSON-RPC message format (version, required fields)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract method name and parameters from request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Look up method in registry - raise METHOD_NOT_FOUND if missing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate parameter count/types against method signature</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Execute method with parameters - catch any exceptions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return create_response_message(request_id, result)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> KeyError</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Missing required field in request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> create_error_message(request_id, </span><span style=\"color:#79B8FF\">INVALID_REQUEST</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                   f</span><span style=\"color:#9ECBFF\">\"Missing required field: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Parameter count/type mismatch</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> create_error_message(request_id, </span><span style=\"color:#79B8FF\">INVALID_PARAMS</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(e))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Execution error in user method</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> create_error_message(request_id, </span><span style=\"color:#79B8FF\">INTERNAL_ERROR</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                   f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{type</span><span style=\"color:#E1E4E8\">(e).</span><span style=\"color:#79B8FF\">__name__}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Client Error Handling Logic</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> _handle_response</span><span style=\"color:#E1E4E8\">(self, response):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert JSON-RPC response to result or raise appropriate exception.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#9ECBFF\"> 'error'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> response:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        error </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> response[</span><span style=\"color:#9ECBFF\">'error'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        error_code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> error.get(</span><span style=\"color:#9ECBFF\">'code'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        error_message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> error.get(</span><span style=\"color:#9ECBFF\">'message'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Unknown error'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        error_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> error.get(</span><span style=\"color:#9ECBFF\">'data'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check error code and raise appropriate exception type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For PARSE_ERROR, INVALID_REQUEST -> RPCProtocolError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For METHOD_NOT_FOUND, INVALID_PARAMS -> RPCMethodError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For INTERNAL_ERROR -> RPCMethodError with execution details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: For TIMEOUT_ERROR -> RPCTimeoutError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: For unknown codes -> generic RPCError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> response.get(</span><span style=\"color:#9ECBFF\">'result'</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Error Handling Verification</strong></p>\n<p>After implementing error handling, verify these behaviors:</p>\n<ol>\n<li><strong>Network Errors</strong>: Stop the server, make RPC call, should get <code>RPCTransportError</code></li>\n<li><strong>Method Not Found</strong>: Call non-existent method, should get <code>RPCMethodError</code> with METHOD_NOT_FOUND code</li>\n<li><strong>Invalid Parameters</strong>: Call method with wrong parameter count, should get <code>RPCMethodError</code> with INVALID_PARAMS code</li>\n<li><strong>Execution Errors</strong>: Register method that throws exception, call it, should get <code>RPCMethodError</code> with exception details</li>\n<li><strong>Timeout Errors</strong>: Make call with very short timeout to slow method, should get <code>RPCTimeoutError</code></li>\n</ol>\n<p><strong>Test Commands</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test script to verify error handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">client </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> RPCClient(</span><span style=\"color:#9ECBFF\">'localhost'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 1: Network error (server not running)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client.call(</span><span style=\"color:#9ECBFF\">'add'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ERROR: Should have raised RPCTransportError\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">except</span><span style=\"color:#E1E4E8\"> RPCTransportError:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ Network error handling works\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 2: Method not found (server running)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client.call(</span><span style=\"color:#9ECBFF\">'nonexistent_method'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ERROR: Should have raised RPCMethodError\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">except</span><span style=\"color:#E1E4E8\"> RPCMethodError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> e.error_code </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> METHOD_NOT_FOUND</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ Method not found error handling works\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Generic &quot;connection error&quot;</td>\n<td>Not distinguishing error types</td>\n<td>Check exception type in handler</td>\n<td>Use specific exception classes</td>\n</tr>\n<tr>\n<td>Wrong error delivered to client</td>\n<td>Response correlation failure</td>\n<td>Log request IDs on both sides</td>\n<td>Ensure request ID in error response matches</td>\n</tr>\n<tr>\n<td>Timeout but server still processing</td>\n<td>Short timeout, long operation</td>\n<td>Monitor server logs for completion</td>\n<td>Increase timeout or make operation async</td>\n</tr>\n<tr>\n<td>Connection keeps breaking</td>\n<td>Not handling partial sends/receives</td>\n<td>Check socket error logs</td>\n<td>Use send_all/recv_all helpers</td>\n</tr>\n<tr>\n<td>Error details lost</td>\n<td>Only passing error message</td>\n<td>Check error object serialization</td>\n<td>Include error code and data fields</td>\n</tr>\n</tbody></table>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - error handling is critical throughout message protocol (Milestone 1), server implementation (Milestone 2), and client implementation (Milestone 3)</p>\n</blockquote>\n<h3 id=\"mental-model-the-emergency-response-system\">Mental Model: The Emergency Response System</h3>\n<p>Think of RPC error handling like a well-designed emergency response system in a large organization. Just as emergency responders need clear protocols to categorize incidents (fire vs. medical vs. security), identify the appropriate response team, and escalate through proper channels, an RPC framework needs systematic error categorization, handling strategies, and propagation mechanisms.</p>\n<p>When a fire alarm sounds, the emergency system doesn&#39;t just panic - it identifies the type of emergency, determines the severity, notifies the right responders, and follows established procedures. Similarly, when network connections fail or methods throw exceptions, our RPC framework must categorize the error, determine the appropriate recovery action, and ensure the client receives meaningful information about what went wrong and what they can do about it.</p>\n<p>The key insight is that different types of errors require fundamentally different handling strategies. A network timeout should trigger retry logic, while a &quot;method not found&quot; error should immediately return to the client with diagnostic information. Just as you wouldn&#39;t send firefighters to handle a medical emergency, you shouldn&#39;t handle serialization errors the same way you handle connection failures.</p>\n<h3 id=\"error-categories\">Error Categories</h3>\n<p>Our RPC framework encounters errors from multiple sources and at different stages of request processing. Understanding these categories is crucial because each requires distinct handling strategies and recovery mechanisms.</p>\n<p><img src=\"/api/project/rpc-basic/architecture-doc/asset?path=diagrams%2Ferror-handling-flow.svg\" alt=\"Error Handling Flowchart\"></p>\n<p>The error taxonomy follows a hierarchy based on where the error originates and whether recovery is possible:</p>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Description</th>\n<th>Recovery Strategy</th>\n<th>Client Experience</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Transport Errors</strong></td>\n<td>Network connectivity, socket operations, connection management failures</td>\n<td>Retry with exponential backoff, connection re-establishment</td>\n<td><code>RPCTransportError</code> with retry suggestion</td>\n</tr>\n<tr>\n<td><strong>Protocol Errors</strong></td>\n<td>Message parsing, invalid JSON-RPC format, serialization failures</td>\n<td>Immediate failure, diagnostic information</td>\n<td><code>RPCProtocolError</code> with format details</td>\n</tr>\n<tr>\n<td><strong>Method Errors</strong></td>\n<td>Method not found, parameter validation, execution exceptions</td>\n<td>Method-specific handling, error propagation</td>\n<td><code>RPCMethodError</code> with method context</td>\n</tr>\n<tr>\n<td><strong>Timeout Errors</strong></td>\n<td>Request exceeds configured time limit, server unresponsive</td>\n<td>Configurable retry or immediate failure</td>\n<td><code>RPCTimeoutError</code> with timeout duration</td>\n</tr>\n<tr>\n<td><strong>Internal Errors</strong></td>\n<td>Server bugs, resource exhaustion, unexpected conditions</td>\n<td>Graceful degradation, logging, monitoring alerts</td>\n<td>Generic error with request ID for support</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: Error Type Hierarchy</strong></p>\n<ul>\n<li><strong>Context</strong>: Need structured way to represent different error conditions with appropriate handling</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Single generic error class with error codes</li>\n<li>Flat error classes without inheritance</li>\n<li>Hierarchical error classes inheriting from base <code>RPCError</code></li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hierarchical error classes with specific types for each category</li>\n<li><strong>Rationale</strong>: Type system helps client code handle different errors appropriately, inheritance reduces code duplication, specific types enable targeted recovery strategies</li>\n<li><strong>Consequences</strong>: More complex type definitions but clearer error handling logic and better debugging experience</li>\n</ul>\n</blockquote>\n<p>The error class hierarchy provides both type safety and semantic clarity:</p>\n<table>\n<thead>\n<tr>\n<th>Error Class</th>\n<th>Base Fields</th>\n<th>Additional Fields</th>\n<th>Usage Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>RPCError</code></td>\n<td><code>message: str</code>, <code>error_code: int</code>, <code>error_data: any</code></td>\n<td>None (base class)</td>\n<td>Generic error handling, logging</td>\n</tr>\n<tr>\n<td><code>RPCTransportError</code></td>\n<td>Inherits base fields</td>\n<td><code>host: str</code>, <code>port: int</code>, <code>operation: str</code></td>\n<td>Connection failures, socket errors</td>\n</tr>\n<tr>\n<td><code>RPCProtocolError</code></td>\n<td>Inherits base fields</td>\n<td><code>raw_data: bytes</code>, <code>parse_stage: str</code></td>\n<td>Message format violations, encoding issues</td>\n</tr>\n<tr>\n<td><code>RPCMethodError</code></td>\n<td>Inherits base fields</td>\n<td><code>method_name: str</code>, <code>params: list</code>, <code>execution_phase: str</code></td>\n<td>Method dispatch and execution failures</td>\n</tr>\n<tr>\n<td><code>RPCTimeoutError</code></td>\n<td>Inherits base fields</td>\n<td><code>timeout_seconds: float</code>, <code>elapsed_seconds: float</code></td>\n<td>Request timeout handling</td>\n</tr>\n</tbody></table>\n<p>Each error type carries contextual information that enables intelligent handling. For example, <code>RPCTransportError</code> includes the host and port for connection diagnostics, while <code>RPCMethodError</code> includes the method name and parameters for debugging method invocations.</p>\n<blockquote>\n<p>The critical insight is that error context determines recovery strategy. Transport errors often warrant retries, while protocol errors indicate client bugs that retries cannot fix.</p>\n</blockquote>\n<h3 id=\"network-failure-handling\">Network Failure Handling</h3>\n<p>Network failures represent the most common and complex error category in distributed systems. Unlike local function calls that either succeed or raise exceptions, network operations introduce a spectrum of partial failure modes that require sophisticated handling strategies.</p>\n<p><img src=\"/api/project/rpc-basic/architecture-doc/asset?path=diagrams%2Fclient-state-machine.svg\" alt=\"Client Request State Machine\"></p>\n<p>The network failure landscape includes multiple failure modes, each with distinct characteristics and recovery approaches:</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Method</th>\n<th>Immediate Action</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Connection Refused</strong></td>\n<td><code>socket.connect()</code> raises <code>ConnectionRefusedError</code></td>\n<td>Mark connection as failed</td>\n<td>Exponential backoff retry, server health check</td>\n</tr>\n<tr>\n<td><strong>Connection Reset</strong></td>\n<td><code>socket.send()</code> raises <code>ConnectionResetError</code></td>\n<td>Close socket, clear connection state</td>\n<td>Re-establish connection, replay request</td>\n</tr>\n<tr>\n<td><strong>Connection Timeout</strong></td>\n<td><code>socket.settimeout()</code> expires during operation</td>\n<td>Abort current operation</td>\n<td>Retry with increased timeout or different endpoint</td>\n</tr>\n<tr>\n<td><strong>Partial Send/Receive</strong></td>\n<td><code>socket.send()</code> returns fewer bytes than requested</td>\n<td>Continue operation from partial position</td>\n<td>Complete the operation or abort after threshold</td>\n</tr>\n<tr>\n<td><strong>Sudden Disconnection</strong></td>\n<td><code>socket.recv()</code> returns empty bytes</td>\n<td>Detect connection closure</td>\n<td>Re-establish connection, determine request status</td>\n</tr>\n<tr>\n<td><strong>DNS Resolution Failure</strong></td>\n<td><code>socket.getaddrinfo()</code> raises <code>gaierror</code></td>\n<td>Cache negative result temporarily</td>\n<td>Retry with different DNS server or cached IP</td>\n</tr>\n</tbody></table>\n<p>The connection state machine helps understand valid transitions and error recovery points:</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Network Event</th>\n<th>Next State</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DISCONNECTED</code></td>\n<td>Connection refused</td>\n<td><code>DISCONNECTED</code></td>\n<td>Schedule retry with backoff</td>\n</tr>\n<tr>\n<td><code>CONNECTING</code></td>\n<td>Timeout during connect</td>\n<td><code>DISCONNECTED</code></td>\n<td>Try next address or increase timeout</td>\n</tr>\n<tr>\n<td><code>CONNECTED</code></td>\n<td>Socket error during send</td>\n<td><code>DISCONNECTED</code></td>\n<td>Re-queue request for retry</td>\n</tr>\n<tr>\n<td><code>WAITING_RESPONSE</code></td>\n<td>Connection reset</td>\n<td><code>DISCONNECTED</code></td>\n<td>Mark request as failed, retry if idempotent</td>\n</tr>\n<tr>\n<td><code>RECEIVING_DATA</code></td>\n<td>Partial receive timeout</td>\n<td><code>DISCONNECTED</code></td>\n<td>Abort request, connection likely dead</td>\n</tr>\n</tbody></table>\n<p>The <code>send_all</code> and <code>recv_all</code> functions implement robust network I/O with proper timeout handling and partial operation support. These functions abstract the complexity of socket operations while providing consistent error reporting:</p>\n<table>\n<thead>\n<tr>\n<th>Function</th>\n<th>Responsibility</th>\n<th>Timeout Behavior</th>\n<th>Error Propagation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>send_all(sock, data, timeout)</code></td>\n<td>Send complete message handling partial sends</td>\n<td>Per-operation timeout, not total timeout</td>\n<td>Raises <code>RPCTransportError</code> with bytes sent</td>\n</tr>\n<tr>\n<td><code>recv_all(sock, size, timeout)</code></td>\n<td>Receive exact byte count handling partial receives</td>\n<td>Cumulative timeout across all recv operations</td>\n<td>Raises <code>RPCTransportError</code> with bytes received</td>\n</tr>\n<tr>\n<td><code>recv_message(sock, timeout)</code></td>\n<td>Receive length-prefixed message</td>\n<td>Timeout applies to complete message</td>\n<td>Raises <code>RPCProtocolError</code> for invalid framing</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: Connection Recovery Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Network connections can fail at any point during RPC communication</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Immediate failure - no retry logic</li>\n<li>Transparent retry - hide failures from client</li>\n<li>Configurable retry - client controls retry behavior</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Configurable retry with exponential backoff and maximum attempt limits</li>\n<li><strong>Rationale</strong>: Balances reliability (automatic recovery from transient failures) with control (client can tune for their use case) and prevents infinite retry loops</li>\n<li><strong>Consequences</strong>: More complex client implementation but better resilience to network issues and clearer failure semantics</li>\n</ul>\n</blockquote>\n<p>The retry mechanism uses exponential backoff to avoid overwhelming failed servers while providing reasonable recovery times for transient network issues:</p>\n<table>\n<thead>\n<tr>\n<th>Retry Attempt</th>\n<th>Base Delay</th>\n<th>Backoff Multiplier</th>\n<th>Maximum Delay</th>\n<th>Total Elapsed</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>100ms</td>\n<td>1.0x</td>\n<td>100ms</td>\n<td>100ms</td>\n</tr>\n<tr>\n<td>2</td>\n<td>100ms</td>\n<td>2.0x</td>\n<td>200ms</td>\n<td>300ms</td>\n</tr>\n<tr>\n<td>3</td>\n<td>100ms</td>\n<td>4.0x</td>\n<td>400ms</td>\n<td>700ms</td>\n</tr>\n<tr>\n<td>4</td>\n<td>100ms</td>\n<td>8.0x</td>\n<td>800ms</td>\n<td>1500ms</td>\n</tr>\n<tr>\n<td>5</td>\n<td>100ms</td>\n<td>16.0x</td>\n<td>5000ms (capped)</td>\n<td>6500ms</td>\n</tr>\n</tbody></table>\n<h3 id=\"serialization-error-handling\">Serialization Error Handling</h3>\n<p>Serialization errors occur when converting between Python objects and the JSON wire format. Unlike network errors that might be transient, serialization errors usually indicate programming bugs, data corruption, or incompatible message formats between client and server versions.</p>\n<p><img src=\"/api/project/rpc-basic/architecture-doc/asset?path=diagrams%2Fserver-state-machine.svg\" alt=\"Server Connection State Machine\"></p>\n<p>The serialization error landscape encompasses both encoding and decoding failures:</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Occurrence Point</th>\n<th>Common Causes</th>\n<th>Detection Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>JSON Encoding Errors</strong></td>\n<td><code>serialize_message()</code> on client/server</td>\n<td>Non-serializable objects, circular references</td>\n<td><code>json.dumps()</code> raises <code>TypeError</code></td>\n</tr>\n<tr>\n<td><strong>JSON Decoding Errors</strong></td>\n<td><code>deserialize_message()</code> on client/server</td>\n<td>Malformed JSON, truncated messages</td>\n<td><code>json.loads()</code> raises <code>json.JSONDecodeError</code></td>\n</tr>\n<tr>\n<td><strong>Type Conversion Errors</strong></td>\n<td>Parameter processing in method dispatch</td>\n<td>Wrong parameter types, missing fields</td>\n<td>Type validation raises <code>TypeError</code></td>\n</tr>\n<tr>\n<td><strong>Message Format Errors</strong></td>\n<td>Request/response validation</td>\n<td>Missing required fields, invalid structure</td>\n<td>Schema validation fails</td>\n</tr>\n<tr>\n<td><strong>Encoding/Decoding Errors</strong></td>\n<td>Byte string conversion</td>\n<td>Unicode issues, character encoding problems</td>\n<td><code>str.encode()</code> raises <code>UnicodeError</code></td>\n</tr>\n<tr>\n<td><strong>Size Limit Errors</strong></td>\n<td>Large message handling</td>\n<td>Messages exceeding configured limits</td>\n<td>Length prefix validation fails</td>\n</tr>\n</tbody></table>\n<p>The message processing pipeline includes validation at multiple stages to catch serialization errors early and provide diagnostic information:</p>\n<table>\n<thead>\n<tr>\n<th>Processing Stage</th>\n<th>Validation Applied</th>\n<th>Error Type Raised</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Pre-Serialization</strong></td>\n<td>Object type checking, circular reference detection</td>\n<td><code>RPCProtocolError</code></td>\n<td>Reject request with validation details</td>\n</tr>\n<tr>\n<td><strong>JSON Encoding</strong></td>\n<td>JSON serialization compatibility</td>\n<td><code>RPCProtocolError</code></td>\n<td>Log object types, suggest alternatives</td>\n</tr>\n<tr>\n<td><strong>Message Framing</strong></td>\n<td>Length prefix validation, size limits</td>\n<td><code>RPCProtocolError</code></td>\n<td>Reject oversized messages with limit info</td>\n</tr>\n<tr>\n<td><strong>Network Transport</strong></td>\n<td>Byte encoding, socket compatibility</td>\n<td><code>RPCTransportError</code></td>\n<td>Encoding failure, suggest UTF-8</td>\n</tr>\n<tr>\n<td><strong>JSON Decoding</strong></td>\n<td>JSON parsing, structure validation</td>\n<td><code>RPCProtocolError</code></td>\n<td>Log raw data for debugging</td>\n</tr>\n<tr>\n<td><strong>Post-Deserialization</strong></td>\n<td>Message schema validation, required fields</td>\n<td><code>RPCProtocolError</code></td>\n<td>Missing field details for client</td>\n</tr>\n</tbody></table>\n<p>The <code>deserialize_message</code> function implements defensive parsing with comprehensive error context:</p>\n<table>\n<thead>\n<tr>\n<th>Parse Phase</th>\n<th>Validation Check</th>\n<th>Error Condition</th>\n<th>Error Context Provided</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Length Prefix</strong></td>\n<td>4-byte integer, reasonable size</td>\n<td>Invalid prefix, oversized message</td>\n<td>Raw bytes, expected format</td>\n</tr>\n<tr>\n<td><strong>JSON Parsing</strong></td>\n<td>Valid JSON syntax</td>\n<td>Malformed JSON, encoding issues</td>\n<td>Parse position, syntax error details</td>\n</tr>\n<tr>\n<td><strong>Schema Validation</strong></td>\n<td>Required fields present</td>\n<td>Missing fields, wrong types</td>\n<td>Field name, expected vs actual type</td>\n</tr>\n<tr>\n<td><strong>Content Validation</strong></td>\n<td>Method names, parameter types</td>\n<td>Invalid characters, unsupported types</td>\n<td>Specific validation rule violated</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: Serialization Error Recovery</strong></p>\n<ul>\n<li><strong>Context</strong>: Serialization failures can occur during encoding (client) or decoding (server/client)</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Fail fast - abort operation immediately </li>\n<li>Best effort - attempt partial serialization/skip problematic fields</li>\n<li>Structured errors - detailed diagnostics with recovery suggestions</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Structured errors with detailed diagnostics and no data corruption</li>\n<li><strong>Rationale</strong>: Data integrity is more important than availability; partial serialization could cause subtle bugs; detailed errors help developers fix issues quickly</li>\n<li><strong>Consequences</strong>: Operations fail completely on serialization errors, but developers get clear guidance for fixes</li>\n</ul>\n</blockquote>\n<p>The error response format for serialization failures includes diagnostic information:</p>\n<table>\n<thead>\n<tr>\n<th>Error Field</th>\n<th>Content</th>\n<th>Purpose</th>\n<th>Example Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>error_code</code></td>\n<td>Standard JSON-RPC error code</td>\n<td>Client error categorization</td>\n<td><code>PARSE_ERROR</code> (-32700)</td>\n</tr>\n<tr>\n<td><code>message</code></td>\n<td>Human-readable description</td>\n<td>Developer debugging</td>\n<td>&quot;Invalid JSON syntax at position 45&quot;</td>\n</tr>\n<tr>\n<td><code>error_data.raw_data</code></td>\n<td>Original problematic data (truncated)</td>\n<td>Debugging the exact input</td>\n<td><code>&quot;{\\&quot;method\\&quot;: \\&quot;test\\&quot;, \\&quot;params\\&quot;: [1,2,3&quot;</code></td>\n</tr>\n<tr>\n<td><code>error_data.parse_stage</code></td>\n<td>Where parsing failed</td>\n<td>Narrowing down the issue</td>\n<td>&quot;json_decode&quot; or &quot;schema_validation&quot;</td>\n</tr>\n<tr>\n<td><code>error_data.expected_format</code></td>\n<td>What was expected</td>\n<td>Helping fix the problem</td>\n<td>&quot;JSON-RPC 2.0 request object&quot;</td>\n</tr>\n<tr>\n<td><code>error_data.suggestions</code></td>\n<td>Possible fixes</td>\n<td>Actionable guidance</td>\n<td>[&quot;Check for missing closing brace&quot;, &quot;Verify UTF-8 encoding&quot;]</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Logging Sensitive Data in Errors</strong></p>\n<p>A common mistake is including complete message content in error responses, potentially exposing sensitive information. Always truncate or sanitize error data before sending it over the network. The raw data should be logged server-side for debugging but not transmitted to clients unless specifically configured for development environments.</p>\n<p>⚠️ <strong>Pitfall: Partial Message Processing</strong></p>\n<p>When message framing fails (invalid length prefix or truncated data), avoid attempting to parse partial JSON. This can lead to interpreting part of one message as the beginning of the next message, causing cascading parse errors. Always validate the complete message frame before attempting JSON parsing.</p>\n<p>⚠️ <strong>Pitfall: Unicode Encoding Assumptions</strong></p>\n<p>Don&#39;t assume all messages use UTF-8 encoding. While JSON requires UTF-8, network data might be corrupted or use different encodings. Always handle <code>UnicodeDecodeError</code> exceptions and provide encoding diagnostics in error responses.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The error handling system provides the foundation for reliable RPC communication by transforming various failure modes into structured, actionable error information that clients can handle appropriately.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Exception Hierarchy</strong></td>\n<td>Built-in Python exceptions with custom messages</td>\n<td>Custom exception classes with structured data</td>\n</tr>\n<tr>\n<td><strong>Error Serialization</strong></td>\n<td>JSON with standard fields</td>\n<td>MessagePack with binary error data</td>\n</tr>\n<tr>\n<td><strong>Logging Integration</strong></td>\n<td>Python <code>logging</code> module with structured logs</td>\n<td>Structured logging with correlation IDs</td>\n</tr>\n<tr>\n<td><strong>Network Error Detection</strong></td>\n<td>Socket exception handling</td>\n<td>Connection health monitoring with heartbeats</td>\n</tr>\n<tr>\n<td><strong>Retry Logic</strong></td>\n<td>Simple exponential backoff</td>\n<td>Circuit breaker pattern with failure tracking</td>\n</tr>\n</tbody></table>\n<h4 id=\"core-error-classes\">Core Error Classes</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">RPC Framework Error Handling</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">This module provides comprehensive error handling for all RPC operations</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">including network failures, serialization issues, and method execution errors.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Optional, Dict, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> threading </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Lock</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all RPC-related errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, error_code: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32603</span><span style=\"color:#E1E4E8\">, error_data: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.error_code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> error_code</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.error_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> error_data </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert error to JSON-RPC error object format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create error object with code, message, and data fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Include error_data only if it contains useful information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Sanitize error_data to prevent sensitive information leakage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Human-readable error representation for logging.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Format error with code, message, and key data fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Truncate large data fields to prevent log spam</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCTransportError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Network and transport-related errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, host: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 operation: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, original_error: </span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        error_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"host\"</span><span style=\"color:#E1E4E8\">: host,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"port\"</span><span style=\"color:#E1E4E8\">: port,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"operation\"</span><span style=\"color:#E1E4E8\">: operation,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"original_error\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(original_error) </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> original_error </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">32000</span><span style=\"color:#E1E4E8\">, error_data)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.host </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> host</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> port</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.operation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> operation</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.original_error </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> original_error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCProtocolError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Message format and serialization errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, raw_data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, parse_stage: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        error_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"raw_data\"</span><span style=\"color:#E1E4E8\">: raw_data[:</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">].decode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">errors</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'replace'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> raw_data </span><span style=\"color:#F97583\">else</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"parse_stage\"</span><span style=\"color:#E1E4E8\">: parse_stage,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"data_length\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(raw_data)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">32700</span><span style=\"color:#E1E4E8\">, error_data)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.raw_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> raw_data</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parse_stage </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parse_stage</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCMethodError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Method execution and dispatch errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, method_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, params: </span><span style=\"color:#79B8FF\">list</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 execution_phase: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, original_error: </span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        error_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"method_name\"</span><span style=\"color:#E1E4E8\">: method_name,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"params\"</span><span style=\"color:#E1E4E8\">: params </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> [],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"execution_phase\"</span><span style=\"color:#E1E4E8\">: execution_phase,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"original_error\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(original_error) </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> original_error </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">32601</span><span style=\"color:#E1E4E8\">, error_data)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.method_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> method_name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.params </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> params </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.execution_phase </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> execution_phase</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.original_error </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> original_error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCTimeoutError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Request timeout errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, timeout_seconds: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">, elapsed_seconds: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        error_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"timeout_seconds\"</span><span style=\"color:#E1E4E8\">: timeout_seconds,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"elapsed_seconds\"</span><span style=\"color:#E1E4E8\">: elapsed_seconds,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"timed_out\"</span><span style=\"color:#E1E4E8\">: elapsed_seconds </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> timeout_seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">32001</span><span style=\"color:#E1E4E8\">, error_data)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.timeout_seconds </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timeout_seconds</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.elapsed_seconds </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> elapsed_seconds</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Standard JSON-RPC error codes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorCode</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PARSE_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32700</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVALID_REQUEST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32600</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    METHOD_NOT_FOUND</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32601</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVALID_PARAMS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32602</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INTERNAL_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32603</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TRANSPORT_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32000</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TIMEOUT_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32001</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CONNECTION_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32002</span></span></code></pre></div>\n\n<h4 id=\"network-operation-helpers\">Network Operation Helpers</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Robust network operations with comprehensive error handling.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> select</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> errno</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SocketHelper</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Utility class for robust socket operations with timeout handling.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> send_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Send all data, handling partial sends and timeouts.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Set socket to non-blocking mode for timeout control</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Use select() to wait for socket writability with timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle partial sends by tracking bytes sent and continuing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Raise RPCTransportError with context on failures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Restore original socket blocking mode before returning</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: socket.send() may send fewer bytes than requested</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recv_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Receive exact number of bytes, handling partial receives.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Set socket to non-blocking mode and track received data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Loop until all requested bytes are received</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Use select() with remaining timeout for each recv operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle partial receives by accumulating data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Detect connection closure (recv returns 0 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Raise appropriate errors for timeouts and connection issues</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recv_message</span><span style=\"color:#E1E4E8\">(sock: socket.socket, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Receive length-prefixed message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Receive 4-byte length prefix using recv_all</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Unpack length as big-endian unsigned integer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate message length is reasonable (not > MAX_MESSAGE_SIZE)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Receive message body using recv_all with remaining timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return complete message bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use struct.unpack('>I', length_bytes)[0] for length</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> send_message</span><span style=\"color:#E1E4E8\">(sock: socket.socket, message_bytes: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Send length-prefixed message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create 4-byte length prefix using struct.pack('>I', len(message))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Send length prefix using send_all</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Send message body using send_all</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle any transport errors and re-raise with context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> handle_socket_error</span><span style=\"color:#E1E4E8\">(error: </span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">, operation: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, host: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) -> RPCTransportError:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert socket exceptions to structured RPC transport errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check error type and map to appropriate error message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle ConnectionRefusedError, ConnectionResetError, timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle OSError with specific errno values (EPIPE, ECONNRESET, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Provide specific guidance based on error type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return RPCTransportError with original error context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"serialization-error-handling\">Serialization Error Handling</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Message serialization with comprehensive error handling and validation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> struct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MAX_MESSAGE_SIZE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#6A737D\">  # 1MB message limit</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> serialize_message</span><span style=\"color:#E1E4E8\">(message: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Serialize message to JSON with error handling.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate message structure has required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check for circular references in message data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Serialize to JSON string with ensure_ascii=False</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Encode JSON string to UTF-8 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Check message size against MAX_MESSAGE_SIZE limit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return serialized bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">TypeError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">ValueError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Analyze error and provide specific guidance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Check if error is due to non-serializable objects</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Raise RPCProtocolError with diagnostic information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> UnicodeEncodeError</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 10: Handle Unicode encoding issues</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 11: Provide character position and encoding details</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> deserialize_message</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Deserialize JSON message with comprehensive error handling.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate input data is not empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Decode bytes to UTF-8 string with error handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Parse JSON string to Python dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate message has required JSON-RPC fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return validated message dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> UnicodeDecodeError</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle encoding issues with position information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Suggest UTF-8 encoding and provide sample bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#E1E4E8\"> json.JSONDecodeError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Handle JSON parsing errors with position details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Provide context around error position for debugging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 10: Suggest common JSON syntax fixes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">KeyError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">TypeError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 11: Handle schema validation errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 12: Identify missing or wrong-type fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_request_message</span><span style=\"color:#E1E4E8\">(message: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validate JSON-RPC request message format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check required fields: jsonrpc, method, id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate jsonrpc version is \"2.0\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate method is string and not empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate id is string, number, or null</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Validate params is array or object if present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Raise RPCProtocolError with specific field issues</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_response_message</span><span style=\"color:#E1E4E8\">(message: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validate JSON-RPC response message format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check required fields: jsonrpc, id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate exactly one of 'result' or 'error' is present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate error object has code, message, and optional data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate error code is integer and message is string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Raise RPCProtocolError with validation details</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"error-recovery-and-retry-logic\">Error Recovery and Retry Logic</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Configurable retry logic with exponential backoff for transient failures.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> random</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Callable, Any, Optional, List, Type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RetryConfig</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Configuration for retry behavior.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_attempts: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    base_delay: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.1</span><span style=\"color:#6A737D\">  # 100ms</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_delay: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5.0</span><span style=\"color:#6A737D\">   # 5 seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    backoff_multiplier: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jitter: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retryable_errors: List[Type[</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.retryable_errors </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.retryable_errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [RPCTransportError, RPCTimeoutError]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RetryHandler</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Implements exponential backoff retry logic for RPC operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, config: RetryConfig):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> config</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._attempt_lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Lock()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> execute_with_retry</span><span style=\"color:#E1E4E8\">(self, operation: Callable[[], Any], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          operation_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"rpc_call\"</span><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute operation with retry logic.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        last_error </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> attempt </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.config.max_attempts </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Execute the operation and return result if successful</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Log retry attempts for debugging (not first attempt)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> error:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check if error type is retryable using isinstance()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If not retryable or last attempt, re-raise immediately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Calculate delay for this attempt using exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Add jitter if configured (random factor 0.5-1.5x)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Sleep for calculated delay before next attempt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Store error for final re-raise if all attempts fail</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: All attempts failed - re-raise the last error with retry context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> calculate_delay</span><span style=\"color:#E1E4E8\">(self, attempt: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Calculate delay for retry attempt using exponential backoff.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate base delay: base_delay * (backoff_multiplier ^ (attempt-1))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Apply maximum delay cap</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add jitter if enabled: multiply by random factor 0.5 to 1.5</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return final delay value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_retryable_error</span><span style=\"color:#E1E4E8\">(self, error: </span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if error type should trigger retry logic.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if error is instance of any retryable error type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For transport errors, check specific conditions (not auth failures)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For timeout errors, check if timeout was reasonable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return True if retry is appropriate, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After Milestone 1 (Message Protocol):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test serialization error handling</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_protocol_errors.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Invalid JSON messages raise RPCProtocolError with parse details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Oversized messages are rejected with size information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Missing required fields provide specific field names in errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Unicode encoding issues include character position details</span></span></code></pre></div>\n\n<p><strong>After Milestone 2 (Server Implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test server error handling</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_server_errors.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Method not found returns structured error response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Method execution errors are caught and returned as RPC errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Network disconnections are detected and connections cleaned up</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Invalid requests receive appropriate error codes</span></span></code></pre></div>\n\n<p><strong>After Milestone 3 (Client Implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test end-to-end error handling</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_client_errors.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Connection failures trigger retry logic with exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Timeout errors include timing information and don't hang</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Serialization errors prevent request sending with clear diagnostics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Server errors are converted to appropriate client exceptions</span></span></code></pre></div>\n\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Client hangs indefinitely</td>\n<td>Network timeout not properly handled</td>\n<td>Check if <code>socket.settimeout()</code> is set</td>\n<td>Implement proper timeout in <code>recv_all</code></td>\n</tr>\n<tr>\n<td>&quot;Connection reset by peer&quot; errors</td>\n<td>Server closing connections abruptly</td>\n<td>Monitor server logs for exceptions during request processing</td>\n<td>Add exception handling in server request loop</td>\n</tr>\n<tr>\n<td>JSON parse errors with valid JSON</td>\n<td>Unicode encoding mismatch</td>\n<td>Check raw bytes in error data for non-UTF8</td>\n<td>Ensure consistent UTF-8 encoding on both ends</td>\n</tr>\n<tr>\n<td>Intermittent &quot;Broken pipe&quot; errors</td>\n<td>Client disconnecting during response send</td>\n<td>Add connection health check before sending</td>\n<td>Gracefully handle client disconnections</td>\n</tr>\n<tr>\n<td>Retry logic not triggering</td>\n<td>Error not classified as retryable</td>\n<td>Check error type inheritance and retry configuration</td>\n<td>Verify <code>RPCTransportError</code> inheritance chain</td>\n</tr>\n<tr>\n<td>Memory usage growing over time</td>\n<td>Error objects retaining large message data</td>\n<td>Check error_data size in exception objects</td>\n<td>Truncate large data in error serialization</td>\n</tr>\n</tbody></table>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - comprehensive testing approach for message protocol (Milestone 1), server implementation (Milestone 2), and client implementation (Milestone 3)</p>\n</blockquote>\n<h3 id=\"mental-model-the-quality-control-factory\">Mental Model: The Quality Control Factory</h3>\n<p>Think of testing your RPC framework like a quality control factory with multiple inspection stations. Each milestone represents a production line stage where components must pass specific quality checks before moving to the next station. At the message protocol station, inspectors verify that every envelope (message) has the correct addressing and contents. At the server station, they test that the factory machinery (method registry and request dispatch) processes orders correctly. At the client station, they verify that the shipping department (proxy objects and connection management) delivers results reliably. Finally, the integration station tests the entire production line end-to-end, simulating real-world customer scenarios to ensure the whole system works harmoniously.</p>\n<p>The key insight is that testing an RPC framework requires both <strong>component isolation</strong> and <strong>system integration</strong>. Component tests verify individual pieces work correctly in controlled conditions, while integration tests validate that components collaborate properly under realistic network conditions and error scenarios.</p>\n<h3 id=\"milestone-checkpoints\">Milestone Checkpoints</h3>\n<p>Each milestone introduces specific functionality that must be thoroughly verified before proceeding to the next stage. The checkpoint approach ensures that foundational components work correctly before building dependent layers, preventing cascading failures that become difficult to debug in later milestones.</p>\n<h4 id=\"milestone-1-message-protocol-checkpoints\">Milestone 1: Message Protocol Checkpoints</h4>\n<p>The message protocol checkpoint verifies that request/response serialization works correctly and handles all specified parameter types and error conditions.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>What to Verify</th>\n<th>Expected Behavior</th>\n<th>Failure Signals</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Request Serialization</td>\n<td><code>create_request_message</code> produces valid JSON-RPC</td>\n<td>Method name, params, and ID present in serialized bytes</td>\n<td>Missing fields, invalid JSON, incorrect format</td>\n</tr>\n<tr>\n<td>Response Serialization</td>\n<td><code>create_response_message</code> and <code>create_error_message</code> work</td>\n<td>Result or error paired with matching request ID</td>\n<td>ID mismatch, malformed error structure</td>\n</tr>\n<tr>\n<td>Message Deserialization</td>\n<td><code>deserialize_message</code> parses valid JSON correctly</td>\n<td>Returns dict with expected fields and types</td>\n<td>JSON decode errors, missing required fields</td>\n</tr>\n<tr>\n<td>Parameter Type Handling</td>\n<td>Strings, numbers, objects, arrays serialize correctly</td>\n<td>Round-trip preserves original values and types</td>\n<td>Type conversion errors, precision loss</td>\n</tr>\n<tr>\n<td>Error Format Validation</td>\n<td>Error messages follow JSON-RPC specification</td>\n<td>Error code, message, and optional data fields present</td>\n<td>Missing error codes, inconsistent format</td>\n</tr>\n</tbody></table>\n<p><strong>Verification Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_protocol.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> tests/manual_protocol_test.py</span></span></code></pre></div>\n\n<p><strong>Manual Testing Approach:</strong>\nCreate test scripts that serialize various message types and verify the output manually. For example, create a request with complex nested parameters (lists containing objects with string and numeric fields) and confirm that deserialization produces identical data structures.</p>\n<blockquote>\n<p><strong>Key Insight:</strong> Protocol testing must validate both the happy path and edge cases. Test with empty parameter lists, null values, very large messages approaching <code>MAX_MESSAGE_SIZE</code>, and malformed JSON to ensure robust error handling.</p>\n</blockquote>\n<p><strong>Signs of Success:</strong></p>\n<ul>\n<li>All message types serialize to valid JSON that matches the JSON-RPC specification format</li>\n<li>Deserialization of serialized messages produces identical data structures (round-trip integrity)</li>\n<li>Error messages contain all required fields and use standard error codes from <code>ErrorCode</code> constants</li>\n<li>Large messages (approaching 1MB) serialize without truncation or memory issues</li>\n</ul>\n<p><strong>Troubleshooting Common Issues:</strong></p>\n<p>⚠️ <strong>Pitfall: JSON Serialization Type Errors</strong>\nSymptom: TypeError when calling <code>serialize_message</code> with certain parameter types\nCause: Python objects that aren&#39;t JSON-serializable (like custom classes or datetime objects)\nFix: Implement custom JSON encoder or validate parameter types before serialization</p>\n<p>⚠️ <strong>Pitfall: Unicode Encoding Problems</strong>\nSymptom: UnicodeDecodeError when deserializing messages containing non-ASCII characters\nCause: Inconsistent UTF-8 encoding/decoding between serialization and deserialization\nFix: Explicitly specify UTF-8 encoding in all string-to-bytes conversions</p>\n<h4 id=\"milestone-2-server-implementation-checkpoints\">Milestone 2: Server Implementation Checkpoints</h4>\n<p>The server checkpoint validates that method registration, request dispatch, and error handling work correctly for concurrent client connections.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>What to Verify</th>\n<th>Expected Behavior</th>\n<th>Failure Signals</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Method Registry</td>\n<td><code>register_method</code> stores callable functions correctly</td>\n<td>Methods accessible by name, callable with correct signatures</td>\n<td>KeyError when calling registered methods, signature mismatches</td>\n</tr>\n<tr>\n<td>TCP Server Startup</td>\n<td><code>start_server</code> listens on specified host and port</td>\n<td>Server accepts incoming connections, binds to correct endpoint</td>\n<td>Address already in use, permission denied, socket errors</td>\n</tr>\n<tr>\n<td>Request Parsing</td>\n<td><code>handle_connection</code> parses incoming JSON-RPC requests</td>\n<td>Valid requests deserialize correctly, invalid requests return parse errors</td>\n<td>Silent failures, missing error responses</td>\n</tr>\n<tr>\n<td>Method Dispatch</td>\n<td><code>process_request</code> invokes registered methods with parameters</td>\n<td>Method execution with provided arguments returns expected results</td>\n<td>Method not found errors, parameter count mismatches</td>\n</tr>\n<tr>\n<td>Error Response Format</td>\n<td>Server returns properly formatted JSON-RPC errors</td>\n<td>Error responses contain matching request ID and standard error codes</td>\n<td>Missing request IDs, invalid error format</td>\n</tr>\n<tr>\n<td>Concurrent Handling</td>\n<td>Multiple clients can connect and make requests simultaneously</td>\n<td>Each request processed independently without interference</td>\n<td>Request mixing, shared state corruption</td>\n</tr>\n</tbody></table>\n<p><strong>Verification Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_server.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> tests/server_integration_test.py</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"import rpc_server; server = rpc_server.RPCServer('localhost', 8080); server.start_server()\"</span></span></code></pre></div>\n\n<p><strong>Manual Testing Approach:</strong>\nStart the server in one terminal, then use telnet or a simple client script to send raw JSON-RPC requests. Verify that the server responds with correctly formatted responses and handles malformed requests gracefully.</p>\n<p><strong>Test Method Registry:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Register a simple test method</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> add</span><span style=\"color:#E1E4E8\">(a, b):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> b</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">server.register_method(</span><span style=\"color:#9ECBFF\">\"add\"</span><span style=\"color:#E1E4E8\">, add)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify method is callable through registry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> server.registry.methods[</span><span style=\"color:#9ECBFF\">\"add\"</span><span style=\"color:#E1E4E8\">](</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 8</span></span></code></pre></div>\n\n<p><strong>Test Concurrent Connections:</strong>\nUse multiple client connections simultaneously to verify that the thread-per-connection model handles concurrent requests without blocking or corrupting shared state.</p>\n<blockquote>\n<p><strong>Key Insight:</strong> Server testing requires verifying both functional correctness and concurrent behavior. The <code>MethodRegistry</code> must be thread-safe, and each client connection should operate independently without affecting other concurrent requests.</p>\n</blockquote>\n<p><strong>Signs of Success:</strong></p>\n<ul>\n<li>Server starts successfully and listens on the specified port without binding errors</li>\n<li>Method registry stores and retrieves callable functions correctly with thread safety</li>\n<li>Valid JSON-RPC requests execute registered methods and return properly formatted responses</li>\n<li>Invalid requests (malformed JSON, method not found, parameter errors) return standard JSON-RPC error responses</li>\n<li>Multiple concurrent clients can connect and make requests simultaneously without interference</li>\n<li>Server handles client disconnections gracefully without crashing or resource leaks</li>\n</ul>\n<p><strong>Troubleshooting Common Issues:</strong></p>\n<p>⚠️ <strong>Pitfall: Socket Address Reuse Problems</strong>\nSymptom: &quot;Address already in use&quot; error when restarting server quickly\nCause: Operating system holding socket in TIME_WAIT state after server shutdown\nFix: Set <code>SO_REUSEADDR</code> socket option and implement proper server shutdown cleanup</p>\n<p>⚠️ <strong>Pitfall: Thread Resource Exhaustion</strong>\nSymptom: Server stops accepting new connections after handling many clients\nCause: Creating new threads without proper cleanup when connections end\nFix: Use thread cleanup or implement connection pooling to limit concurrent threads</p>\n<p>⚠️ <strong>Pitfall: Shared State Corruption</strong>\nSymptom: Method calls return unexpected results when multiple clients connect\nCause: Registered methods accessing shared global variables without synchronization\nFix: Use thread-local storage or proper locking for shared state in registered methods</p>\n<h4 id=\"milestone-3-client-implementation-checkpoints\">Milestone 3: Client Implementation Checkpoints</h4>\n<p>The client checkpoint validates that method proxying, connection management, and timeout handling work correctly under various network conditions.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>What to Verify</th>\n<th>Expected Behavior</th>\n<th>Failure Signals</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Server Connection</td>\n<td><code>call</code> establishes TCP connection to server</td>\n<td>Client connects to specified host and port successfully</td>\n<td>Connection refused, timeout errors, network unreachable</td>\n</tr>\n<tr>\n<td>Method Proxying</td>\n<td><code>RPCProxy.__getattr__</code> creates callable methods</td>\n<td>Proxy objects allow natural method call syntax</td>\n<td>AttributeError, method calls don&#39;t send requests</td>\n</tr>\n<tr>\n<td>Request Transmission</td>\n<td><code>call</code> sends properly formatted JSON-RPC requests</td>\n<td>Requests include method name, parameters, and unique IDs</td>\n<td>Malformed requests, missing request IDs</td>\n</tr>\n<tr>\n<td>Response Correlation</td>\n<td>Client matches responses to correct pending requests</td>\n<td>Responses return to the originating method call</td>\n<td>Request/response ID mismatches, blocking forever</td>\n</tr>\n<tr>\n<td>Timeout Handling</td>\n<td><code>call</code> respects timeout parameter and raises <code>RPCTimeoutError</code></td>\n<td>Calls abort after specified timeout duration</td>\n<td>Hanging indefinitely, premature timeouts</td>\n</tr>\n<tr>\n<td>Connection Reuse</td>\n<td>Multiple calls use the same TCP connection efficiently</td>\n<td>Single connection handles multiple sequential requests</td>\n<td>New connection for every request, connection leaks</td>\n</tr>\n<tr>\n<td>Error Propagation</td>\n<td>Server errors propagate to client as appropriate exceptions</td>\n<td>JSON-RPC errors raise <code>RPCMethodError</code> with server details</td>\n<td>Silent failures, generic exceptions without context</td>\n</tr>\n</tbody></table>\n<p><strong>Verification Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_client.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> tests/client_integration_test.py</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> tests/client_server_integration.py</span></span></code></pre></div>\n\n<p><strong>Manual Testing Approach:</strong>\nStart a test server with known methods, then create client instances and verify that proxy method calls work as expected. Test timeout behavior by calling methods that intentionally delay longer than the timeout setting.</p>\n<p><strong>Test Method Proxying:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create client and proxy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">client </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> RPCClient(</span><span style=\"color:#9ECBFF\">\"localhost\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8080</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">proxy </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> RPCProxy(client)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Call methods using natural syntax</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proxy.add(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 30</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify timeout behavior</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proxy.slow_method(</span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Method takes 5 seconds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Should have timed out\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">except</span><span style=\"color:#E1E4E8\"> RPCTimeoutError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#E1E4E8\"> e.timeout_seconds </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1.0</span></span></code></pre></div>\n\n<p><strong>Test Connection Management:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">client </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> RPCClient(</span><span style=\"color:#9ECBFF\">\"localhost\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8080</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify connection reuse</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> client.call(</span><span style=\"color:#9ECBFF\">\"method1\"</span><span style=\"color:#E1E4E8\">, [])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> client.call(</span><span style=\"color:#9ECBFF\">\"method2\"</span><span style=\"color:#E1E4E8\">, [])</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Both calls should use same socket connection</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify connection cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">client._disconnect()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> client._connected </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> False</span></span></code></pre></div>\n\n<blockquote>\n<p><strong>Key Insight:</strong> Client testing must validate both the programming interface (method proxying feels natural) and the network behavior (connection reuse, timeout handling, error propagation). The proxy pattern should be transparent to the user while handling all RPC complexity internally.</p>\n</blockquote>\n<p><strong>Signs of Success:</strong></p>\n<ul>\n<li>Client connects to server successfully and establishes stable TCP connection</li>\n<li>Proxy objects allow method calls with natural Python syntax (proxy.method_name(args))</li>\n<li>Method calls send correctly formatted JSON-RPC requests and receive matching responses</li>\n<li>Request IDs are generated uniquely and responses correlate to the correct pending requests</li>\n<li>Timeout handling works reliably, aborting slow requests after the specified duration</li>\n<li>Connection reuse functions correctly, using a single TCP connection for multiple sequential calls</li>\n<li>Server errors propagate as appropriate client-side exceptions with diagnostic information</li>\n</ul>\n<p><strong>Troubleshooting Common Issues:</strong></p>\n<p>⚠️ <strong>Pitfall: Request/Response ID Correlation Errors</strong>\nSymptom: Method calls return results from different requests or hang indefinitely\nCause: Request ID generation not unique or response matching logic incorrect\nFix: Use UUID for request IDs and verify response correlation logic handles concurrent requests</p>\n<p>⚠️ <strong>Pitfall: Connection State Corruption</strong>\nSymptom: Client errors after first successful call or intermittent connection failures\nCause: Socket state not properly managed between requests\nFix: Implement proper connection state tracking and recovery logic in <code>_ensure_connected</code></p>\n<p>⚠️ <strong>Pitfall: Timeout Not Interrupting Socket Operations</strong>\nSymptom: Timeout parameter ignored, client hangs on unresponsive server\nCause: Socket operations (send/recv) not respecting timeout settings\nFix: Set socket timeout before each operation and handle socket timeout exceptions properly</p>\n<h3 id=\"integration-test-scenarios\">Integration Test Scenarios</h3>\n<p>Integration testing verifies that the complete RPC framework functions correctly under realistic conditions, testing the interactions between all components and handling real-world edge cases that don&#39;t appear in unit tests.</p>\n<h4 id=\"end-to-end-rpc-call-scenarios\">End-to-End RPC Call Scenarios</h4>\n<p>These scenarios test the complete flow from client method invocation through network transport to server execution and response handling.</p>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Setup</th>\n<th>Expected Behavior</th>\n<th>Validation Points</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Basic Method Call</td>\n<td>Server with <code>add(a, b)</code> method, client calls <code>proxy.add(5, 3)</code></td>\n<td>Returns 8, request/response IDs match</td>\n<td>Message format, method execution, response correlation</td>\n</tr>\n<tr>\n<td>Complex Parameter Types</td>\n<td>Server method accepting nested objects and arrays</td>\n<td>Parameters preserve types and structure through serialization</td>\n<td>JSON round-trip integrity, type preservation</td>\n</tr>\n<tr>\n<td>Method Not Found</td>\n<td>Client calls <code>proxy.nonexistent_method()</code> on server without that method</td>\n<td>Raises <code>RPCMethodError</code> with <code>METHOD_NOT_FOUND</code> error code</td>\n<td>Error propagation, standard error codes</td>\n</tr>\n<tr>\n<td>Server Method Exception</td>\n<td>Registered method raises Python exception during execution</td>\n<td>Client receives <code>RPCMethodError</code> with exception details</td>\n<td>Error handling, exception message preservation</td>\n</tr>\n<tr>\n<td>Large Message Transfer</td>\n<td>Method with parameters approaching <code>MAX_MESSAGE_SIZE</code></td>\n<td>Successful transfer without truncation or memory errors</td>\n<td>Message framing, size limits, memory efficiency</td>\n</tr>\n<tr>\n<td>Multiple Sequential Calls</td>\n<td>Client makes 10 method calls using same connection</td>\n<td>All calls succeed with connection reuse</td>\n<td>Connection management, request correlation</td>\n</tr>\n<tr>\n<td>Concurrent Client Connections</td>\n<td>5 clients simultaneously calling server methods</td>\n<td>All requests processed correctly without interference</td>\n<td>Thread safety, concurrent request handling</td>\n</tr>\n</tbody></table>\n<p><strong>Basic End-to-End Test Implementation:</strong></p>\n<p>The following test scenario validates that a complete RPC call works correctly from client method invocation to server response:</p>\n<ol>\n<li>Start <code>RPCServer</code> with a registered <code>add</code> method that returns the sum of two parameters</li>\n<li>Create <code>RPCClient</code> and <code>RPCProxy</code> connecting to the server</li>\n<li>Call <code>proxy.add(10, 20)</code> using natural method syntax</li>\n<li>Verify that the call returns 30 and the request/response correlation worked correctly</li>\n<li>Check that the TCP connection remains open for subsequent calls</li>\n<li>Validate that the JSON-RPC message format was used correctly throughout the exchange</li>\n</ol>\n<p><strong>Complex Parameter Handling Test:</strong></p>\n<p>This scenario ensures that complex data structures survive the serialization round-trip correctly:</p>\n<ol>\n<li>Register server method <code>process_data(data)</code> that returns a modified version of the input data structure</li>\n<li>Create test data containing nested objects, arrays, strings, numbers, and null values</li>\n<li>Call <code>proxy.process_data(complex_data)</code> and verify the response preserves all data types and structure</li>\n<li>Test edge cases like empty arrays, deeply nested objects, and Unicode strings</li>\n<li>Verify that the serialization process doesn&#39;t introduce type conversion errors or data loss</li>\n</ol>\n<p><strong>Error Handling Integration Test:</strong></p>\n<p>This scenario validates that errors propagate correctly from server to client with proper diagnostic information:</p>\n<ol>\n<li>Register server method that intentionally raises various types of exceptions</li>\n<li>Call methods that trigger different error conditions: method not found, parameter validation errors, execution exceptions</li>\n<li>Verify that each error type results in the appropriate client-side exception with accurate error codes and messages</li>\n<li>Test error handling during network failures: server disconnection, timeout scenarios, malformed responses</li>\n<li>Ensure that error conditions don&#39;t corrupt the connection state for subsequent requests</li>\n</ol>\n<h4 id=\"network-failure-and-recovery-scenarios\">Network Failure and Recovery Scenarios</h4>\n<p>These scenarios test how the RPC framework handles various network failure modes and recovery situations.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Trigger Condition</th>\n<th>Expected Behavior</th>\n<th>Recovery Validation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Server Disconnect During Call</td>\n<td>Server process killed while client waiting for response</td>\n<td>Client raises <code>RPCTransportError</code> with connection details</td>\n<td>Subsequent calls detect disconnection and attempt reconnection</td>\n</tr>\n<tr>\n<td>Connection Timeout</td>\n<td>Server accepts connection but doesn&#39;t respond to requests</td>\n<td>Client raises <code>RPCTimeoutError</code> after specified timeout</td>\n<td>Connection marked as failed, new connection established for next call</td>\n</tr>\n<tr>\n<td>Partial Message Transmission</td>\n<td>Network interruption during large message transfer</td>\n<td>Client detects incomplete message and raises transport error</td>\n<td>Connection reset, retry logic handles partial transfers</td>\n</tr>\n<tr>\n<td>Server Overload</td>\n<td>Server cannot accept new connections due to resource limits</td>\n<td>Client receives connection refused error with retry suggestion</td>\n<td>Client implements exponential backoff for connection retries</td>\n</tr>\n<tr>\n<td>Intermittent Network Issues</td>\n<td>Connection drops randomly during request/response cycle</td>\n<td>Framework detects connection failures and recovers gracefully</td>\n<td>Automatic reconnection without user intervention</td>\n</tr>\n</tbody></table>\n<p><strong>Connection Failure Recovery Test:</strong></p>\n<p>This scenario validates that the client handles server disconnection gracefully and recovers for subsequent requests:</p>\n<ol>\n<li>Start server and establish client connection with successful initial request</li>\n<li>Kill server process while client has a pending request waiting for response</li>\n<li>Verify that client detects connection failure and raises <code>RPCTransportError</code> with appropriate error details</li>\n<li>Restart server and make another client request</li>\n<li>Confirm that client establishes new connection automatically and request succeeds</li>\n<li>Validate that connection state tracking correctly reflects the disconnection and reconnection</li>\n</ol>\n<p><strong>Timeout Handling Integration Test:</strong></p>\n<p>This scenario ensures that timeout handling works correctly under realistic network conditions:</p>\n<ol>\n<li>Configure server method that intentionally delays longer than client timeout setting</li>\n<li>Make client request with specific timeout value shorter than method execution time</li>\n<li>Verify that client raises <code>RPCTimeoutError</code> with accurate timeout duration and elapsed time</li>\n<li>Ensure that timed-out connection is properly cleaned up and doesn&#39;t interfere with subsequent requests</li>\n<li>Test timeout handling with various timeout values to ensure accuracy across different durations</li>\n</ol>\n<h4 id=\"stress-and-performance-scenarios\">Stress and Performance Scenarios</h4>\n<p>These scenarios validate that the RPC framework maintains correctness under load and performs adequately for typical use cases.</p>\n<table>\n<thead>\n<tr>\n<th>Load Scenario</th>\n<th>Configuration</th>\n<th>Success Criteria</th>\n<th>Performance Expectations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>High Request Rate</td>\n<td>Single client making 1000 sequential requests</td>\n<td>All requests complete successfully with correct responses</td>\n<td>Average latency under 10ms for simple methods</td>\n</tr>\n<tr>\n<td>Multiple Concurrent Clients</td>\n<td>20 clients each making 100 requests simultaneously</td>\n<td>No request mixing, all responses correlate correctly</td>\n<td>Server handles concurrent load without blocking</td>\n</tr>\n<tr>\n<td>Large Message Stress</td>\n<td>Requests with payloads near maximum message size</td>\n<td>All large messages transfer completely without corruption</td>\n<td>Memory usage remains bounded, no memory leaks</td>\n</tr>\n<tr>\n<td>Long-Running Server</td>\n<td>Server handling requests continuously for 1 hour</td>\n<td>No resource leaks, consistent response times</td>\n<td>Memory and file descriptor usage remains stable</td>\n</tr>\n<tr>\n<td>Connection Pool Stress</td>\n<td>Rapid connection/disconnection cycles</td>\n<td>No socket resource exhaustion, proper cleanup</td>\n<td>Operating system socket limits not exceeded</td>\n</tr>\n</tbody></table>\n<p><strong>Concurrent Client Load Test:</strong></p>\n<p>This scenario validates that the server&#39;s thread-per-connection model handles concurrent requests correctly:</p>\n<ol>\n<li>Create 10 client instances, each running in a separate thread</li>\n<li>Each client makes 50 requests to different server methods simultaneously</li>\n<li>Verify that all 500 total requests complete successfully with correct results</li>\n<li>Check that request/response correlation works correctly across concurrent clients</li>\n<li>Monitor server resource usage to ensure thread creation and cleanup work properly</li>\n<li>Validate that no shared state corruption occurs between concurrent requests</li>\n</ol>\n<p><strong>Memory and Resource Stress Test:</strong></p>\n<p>This scenario ensures that the framework doesn&#39;t leak resources under sustained load:</p>\n<ol>\n<li>Run client making continuous requests for 30 minutes with periodic garbage collection</li>\n<li>Monitor memory usage of both client and server processes throughout the test</li>\n<li>Verify that socket file descriptors are properly closed after use</li>\n<li>Check that thread resources are cleaned up when client connections end</li>\n<li>Ensure that message buffers and connection state don&#39;t accumulate over time</li>\n</ol>\n<blockquote>\n<p><strong>Key Insight:</strong> Integration testing reveals issues that don&#39;t appear in unit tests, particularly around resource management, concurrent access, and network failure handling. These scenarios test the framework&#39;s behavior under realistic conditions rather than ideal laboratory settings.</p>\n</blockquote>\n<h4 id=\"error-recovery-and-resilience-scenarios\">Error Recovery and Resilience Scenarios</h4>\n<p>These scenarios test how well the framework handles and recovers from various error conditions that occur in production environments.</p>\n<table>\n<thead>\n<tr>\n<th>Error Condition</th>\n<th>Setup</th>\n<th>Expected Recovery</th>\n<th>Validation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Serialization Failure</td>\n<td>Method parameters that can&#39;t be JSON-serialized</td>\n<td>Client raises appropriate error before sending request</td>\n<td>No malformed data sent to server</td>\n</tr>\n<tr>\n<td>Server Method Crash</td>\n<td>Registered method with unhandled exception</td>\n<td>Server sends error response, remains available for other requests</td>\n<td>Server doesn&#39;t crash, other clients unaffected</td>\n</tr>\n<tr>\n<td>Network Partition</td>\n<td>Temporary network disconnection during active session</td>\n<td>Client detects failure, retries when network recovers</td>\n<td>Automatic recovery without manual intervention</td>\n</tr>\n<tr>\n<td>Server Resource Exhaustion</td>\n<td>Server running out of memory or file descriptors</td>\n<td>Graceful degradation with appropriate error responses</td>\n<td>Server remains stable, doesn&#39;t crash completely</td>\n</tr>\n<tr>\n<td>Message Size Limit Exceeded</td>\n<td>Request larger than <code>MAX_MESSAGE_SIZE</code></td>\n<td>Client or server rejects message before processing</td>\n<td>Clear error message about size limits</td>\n</tr>\n</tbody></table>\n<p><strong>Serialization Error Handling Test:</strong></p>\n<p>This scenario validates that serialization errors are caught and handled appropriately:</p>\n<ol>\n<li>Attempt to call server method with parameters containing non-serializable objects (e.g., file handles, custom classes)</li>\n<li>Verify that client detects serialization failure before sending request to server</li>\n<li>Ensure that serialization error raises <code>RPCProtocolError</code> with diagnostic information about the problematic data</li>\n<li>Test that client connection remains usable after serialization error for subsequent valid requests</li>\n</ol>\n<p><strong>Server Resilience Test:</strong></p>\n<p>This scenario ensures that server errors don&#39;t affect other clients or crash the server:</p>\n<ol>\n<li>Register server method that raises various types of exceptions (ValueError, KeyError, custom exceptions)</li>\n<li>Create multiple client connections, some calling problematic methods and others calling normal methods</li>\n<li>Verify that method exceptions are caught, converted to JSON-RPC error responses, and sent to the appropriate client</li>\n<li>Confirm that server continues running and handling requests from other clients normally</li>\n<li>Test that exception details are preserved in error responses for debugging purposes</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical testing infrastructure and verification procedures to help implement comprehensive testing for the RPC framework.</p>\n<h4 id=\"testing-technology-recommendations\">Testing Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unit Testing</td>\n<td>Python unittest (built-in)</td>\n<td>pytest with fixtures and parameterized tests</td>\n</tr>\n<tr>\n<td>Integration Testing</td>\n<td>Manual test scripts</td>\n<td>pytest with test containers</td>\n</tr>\n<tr>\n<td>Network Testing</td>\n<td>Local loopback connections</td>\n<td>Docker containers with network simulation</td>\n</tr>\n<tr>\n<td>Load Testing</td>\n<td>Threading module with simple loops</td>\n<td>locust or concurrent.futures for realistic load</td>\n</tr>\n<tr>\n<td>Mocking</td>\n<td>unittest.mock (built-in)</td>\n<td>pytest-mock with advanced stubbing</td>\n</tr>\n</tbody></table>\n<h4 id=\"test-file-structure\">Test File Structure</h4>\n<p>Organize test files to match the component structure and separate unit tests from integration tests:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>rpc_framework/\n  src/\n    rpc/\n      protocol.py          ← Message protocol implementation\n      server.py           ← RPC server implementation  \n      client.py           ← RPC client implementation\n      errors.py           ← Error classes\n  tests/\n    unit/\n      test_protocol.py    ← Protocol serialization tests\n      test_server.py      ← Server component tests\n      test_client.py      ← Client component tests\n      test_errors.py      ← Error handling tests\n    integration/\n      test_end_to_end.py  ← Full RPC call scenarios\n      test_failure_modes.py ← Network failure tests\n      test_load.py        ← Performance and stress tests\n    helpers/\n      test_server.py      ← Test server utilities\n      test_client.py      ← Test client utilities\n      fixtures.py         ← Common test data</code></pre></div>\n\n<h4 id=\"unit-test-infrastructure-starter-code\">Unit Test Infrastructure Starter Code</h4>\n<p>Complete testing utilities that provide the foundation for all milestone testing:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/helpers/test_server.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Callable, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.rpc.server </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> RPCServer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestServerHelper</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Helper class for managing test servers in unit and integration tests.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, host: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"localhost\"</span><span style=\"color:#E1E4E8\">, port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.host </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> host</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> port</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.server: Optional[RPCServer] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.server_thread: Optional[threading.Thread] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._methods: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Callable] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_method</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, method: Callable):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register a method for the test server.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._methods[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> method</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> start</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Start the test server and return the actual port number.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create RPCServer instance with host and port</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Register all methods from self._methods</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Start server in background thread</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Wait for server to start listening</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return actual port number (important when port=0)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> stop</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Stop the test server and clean up resources.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Signal server to stop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Wait for server thread to complete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Clean up server resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_running</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if the test server is currently running.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check server state and thread status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># tests/helpers/test_client.py  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, List, Dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.rpc.client </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> RPCClient</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.rpc.errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> RPCError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestClientHelper</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Helper for testing client behavior and collecting metrics.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, host: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.host </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> host</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> port</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.client </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> RPCClient(host, port)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.call_history: List[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> call_with_timing</span><span style=\"color:#E1E4E8\">(self, method_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, params: List[Any], timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5.0</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Make an RPC call and record timing and result information.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        error </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.client.call(method_name, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">params, </span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">timeout)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            error </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> e</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        call_record </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'method'</span><span style=\"color:#E1E4E8\">: method_name,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'params'</span><span style=\"color:#E1E4E8\">: params,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'start_time'</span><span style=\"color:#E1E4E8\">: start_time,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'end_time'</span><span style=\"color:#E1E4E8\">: end_time,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'duration'</span><span style=\"color:#E1E4E8\">: end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'result'</span><span style=\"color:#E1E4E8\">: result,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'error'</span><span style=\"color:#E1E4E8\">: error,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'success'</span><span style=\"color:#E1E4E8\">: error </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.call_history.append(call_record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> error:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_average_latency</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Calculate average latency for successful calls.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate average duration from call_history for successful calls</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_error_rate</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Calculate percentage of calls that resulted in errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate ratio of failed calls to total calls</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> reset_metrics</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Clear call history and reset metrics.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.call_history.clear()</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint-implementation\">Milestone Checkpoint Implementation</h4>\n<p>Complete test cases that verify each milestone&#39;s core functionality:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/unit/test_protocol.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.rpc.protocol </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> create_request_message, create_response_message, serialize_message, deserialize_message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.rpc.errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ErrorCode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestProtocolMilestone</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Tests for Milestone 1 - Message Protocol implementation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_create_request_message_basic</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify request message contains required fields.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create request with method name, parameters, and request ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Assert message contains 'jsonrpc', 'method', 'params', 'id' fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify field values match input parameters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_request_response_serialization_roundtrip</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify messages can be serialized and deserialized without data loss.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create request with complex nested parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Serialize to bytes using serialize_message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Deserialize bytes back to dict using deserialize_message  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Assert original and deserialized data are identical</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @pytest.mark.parametrize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"params,expected_type\"</span><span style=\"color:#E1E4E8\">, [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ([</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ({</span><span style=\"color:#9ECBFF\">\"key\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"value\"</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#9ECBFF\">\"test string\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#79B8FF\">42.5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">type</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_parameter_type_preservation</span><span style=\"color:#E1E4E8\">(self, params, expected_type):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify different parameter types are preserved through serialization.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create request message with given params</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Serialize and deserialize the message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Assert parameter types are preserved exactly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_error_message_format</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify error messages follow JSON-RPC specification.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create error message with code, message, and data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Assert error structure contains required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify error codes match ErrorCode constants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># tests/integration/test_end_to_end.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> tests.helpers.test_server </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TestServerHelper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> tests.helpers.test_client </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TestClientHelper</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestEndToEndScenarios</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Integration tests for complete RPC framework functionality.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> setup_method</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set up test server with sample methods.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.server_helper </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TestServerHelper()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Register test methods</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.server_helper.register_method(</span><span style=\"color:#9ECBFF\">\"add\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">lambda</span><span style=\"color:#E1E4E8\"> a, b: a </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> b)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.server_helper.register_method(</span><span style=\"color:#9ECBFF\">\"echo\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">lambda</span><span style=\"color:#E1E4E8\"> msg: msg)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.server_helper.register_method(</span><span style=\"color:#9ECBFF\">\"slow_method\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">lambda</span><span style=\"color:#E1E4E8\">: time.sleep(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Start server and get port</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.port </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.server_helper.start()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.client_helper </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TestClientHelper(</span><span style=\"color:#9ECBFF\">\"localhost\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.port)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> teardown_method</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Clean up test server and client.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.server_helper.stop()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_basic_method_call</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify basic RPC call works end-to-end.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Make simple method call using client helper</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Verify correct result is returned</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check that call completed in reasonable time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_multiple_sequential_calls</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify connection reuse for multiple calls.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Make 10 sequential method calls</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Verify all calls succeed with correct results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check that connection was reused (timing analysis)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_timeout_handling</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify timeout behavior for slow methods.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Call slow_method with short timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Assert RPCTimeoutError is raised</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify timeout duration is respected</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_concurrent_clients</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify server handles multiple concurrent clients.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create multiple client threads</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Each client makes multiple requests simultaneously</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify all requests complete successfully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Assert no request mixing or correlation errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"load-and-stress-testing-infrastructure\">Load and Stress Testing Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/integration/test_load.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> concurrent.futures </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ThreadPoolExecutor, as_completed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> tests.helpers.test_server </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TestServerHelper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> tests.helpers.test_client </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TestClientHelper</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestLoadScenarios</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Stress and performance tests for RPC framework.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> setup_method</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.server_helper </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TestServerHelper()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Register performance test methods</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.server_helper.register_method(</span><span style=\"color:#9ECBFF\">\"fast_add\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">lambda</span><span style=\"color:#E1E4E8\"> a, b: a </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> b)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.server_helper.register_method(</span><span style=\"color:#9ECBFF\">\"cpu_intensive\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._cpu_work)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.server_helper.register_method(</span><span style=\"color:#9ECBFF\">\"large_response\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._generate_large_data)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.port </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.server_helper.start()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _cpu_work</span><span style=\"color:#E1E4E8\">(self, iterations: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"CPU-intensive method for performance testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement method that does meaningful CPU work</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _generate_large_data</span><span style=\"color:#E1E4E8\">(self, size_kb: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate large response data for testing message size limits.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate dictionary with specified size in KB</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_high_request_rate</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test server performance under high request rate.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        client </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TestClientHelper(</span><span style=\"color:#9ECBFF\">\"localhost\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.port)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Make 1000 requests as quickly as possible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Record latency for each request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Assert average latency is under threshold</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify no requests failed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_concurrent_client_load</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test server with multiple concurrent clients.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        num_clients </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 20</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        requests_per_client </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 50</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#B392F0\"> client_worker</span><span style=\"color:#E1E4E8\">(client_id):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create client helper for this thread</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Make specified number of requests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return performance metrics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create thread pool with client workers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Execute all workers concurrently</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Collect and analyze results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Assert performance requirements are met</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_memory_stability</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify no memory leaks during sustained operation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        import</span><span style=\"color:#E1E4E8\"> psutil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> psutil.Process(os.getpid())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        initial_memory </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> process.memory_info().rss</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Run continuous requests for 5 minutes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Monitor memory usage throughout test</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Assert memory growth is bounded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify garbage collection works correctly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"debugging-and-verification-tools\">Debugging and Verification Tools</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/helpers/debug_tools.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.rpc.protocol </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> serialize_message, deserialize_message</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCDebugger</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Tools for debugging RPC framework issues.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_message_format</span><span style=\"color:#E1E4E8\">(message_dict: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate JSON-RPC message format and return list of issues.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        issues </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check for required JSON-RPC fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate field types and values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return list of format violations found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> trace_rpc_call</span><span style=\"color:#E1E4E8\">(host: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, method: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, params: List[Any]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Make RPC call with detailed tracing of message flow.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"=== RPC Call Trace: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">method</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">(</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">params</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">) ===\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create and display request message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Show serialized bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Connect to server and trace network communication</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Display response and any errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_server_connectivity</span><span style=\"color:#E1E4E8\">(host: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5.0</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test basic connectivity to RPC server.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'host'</span><span style=\"color:#E1E4E8\">: host,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'port'</span><span style=\"color:#E1E4E8\">: port,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'connected'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'error'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'latency_ms'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Attempt TCP connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Measure connection latency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Test basic socket communication</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return diagnostic information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p>This comprehensive testing strategy ensures that each milestone is properly validated before proceeding to the next, while integration tests verify that all components work together correctly under realistic conditions. The provided infrastructure code gives learners a solid foundation for implementing their own test cases without getting bogged down in testing framework setup.</p>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - debugging techniques apply throughout message protocol (Milestone 1), server implementation (Milestone 2), and client implementation (Milestone 3), and their integration</p>\n</blockquote>\n<p>Building an RPC framework involves multiple layers of complexity - network communication, serialization, concurrency, and error propagation. When something goes wrong, the symptoms often manifest far from the root cause, making debugging challenging for developers new to distributed systems. This guide provides systematic approaches to identify, diagnose, and resolve the most common issues encountered when implementing our RPC framework.</p>\n<p><img src=\"/api/project/rpc-basic/architecture-doc/asset?path=diagrams%2Ferror-handling-flow.svg\" alt=\"Error Handling Flowchart\"></p>\n<h3 id=\"mental-model-the-detective39s-investigation-process\">Mental Model: The Detective&#39;s Investigation Process</h3>\n<p>Think of debugging RPC issues like a detective investigating a crime scene. You start with symptoms (the &quot;crime&quot;) - perhaps a client call hangs indefinitely, or the server crashes with a cryptic error. Like a detective, you must gather evidence systematically, form hypotheses about what went wrong, and test each theory until you find the root cause. The key is following a structured process rather than randomly changing code and hoping for the best.</p>\n<p>Just as a detective looks for patterns (multiple similar crimes suggest a serial perpetrator), RPC debugging benefits from recognizing common failure patterns. Network issues have different &quot;fingerprints&quot; than serialization problems, which look different from timing issues. Learning to read these patterns accelerates diagnosis.</p>\n<p>The detective also knows that the most obvious suspect isn&#39;t always guilty. In RPC debugging, the error message you see might be a secondary effect. A &quot;connection refused&quot; error might actually be caused by the server crashing due to a serialization bug, not a networking problem. Always dig deeper than the surface symptoms.</p>\n<h3 id=\"connection-and-network-issues\">Connection and Network Issues</h3>\n<p>Network problems are often the first roadblock when building RPC systems, because they involve multiple moving parts - sockets, TCP protocol behavior, firewalls, and operating system networking stacks. These issues can be particularly frustrating because they often work fine in development but fail in different environments.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: Network issues usually manifest as exceptions during connection establishment or data transfer, but the root cause might be configuration, timing, or resource exhaustion rather than actual network connectivity problems.</p>\n</blockquote>\n<h4 id=\"common-network-failure-patterns\">Common Network Failure Patterns</h4>\n<p>The following table catalogs the most frequent network-related issues and their diagnostic approaches:</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Root Cause</th>\n<th>Diagnostic Steps</th>\n<th>Resolution Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ConnectionRefusedError</code> on client</td>\n<td>Server not running or wrong port</td>\n<td><code>netstat -an | grep PORT</code>, <code>telnet HOST PORT</code></td>\n<td>Verify server startup, check port binding</td>\n</tr>\n<tr>\n<td>Client hangs on <code>connect()</code></td>\n<td>Firewall blocking, wrong IP</td>\n<td><code>ping HOST</code>, <code>traceroute HOST</code>, check firewall rules</td>\n<td>Network configuration, security groups</td>\n</tr>\n<tr>\n<td><code>BrokenPipeError</code> during send</td>\n<td>Server closed connection unexpectedly</td>\n<td>Check server logs for crashes, monitor server process</td>\n<td>Fix server-side errors causing disconnection</td>\n</tr>\n<tr>\n<td><code>ConnectionResetError</code> mid-call</td>\n<td>Server or network dropped connection</td>\n<td>Network monitoring, server resource usage</td>\n<td>Implement connection health checks, retry logic</td>\n</tr>\n<tr>\n<td>Intermittent <code>TimeoutError</code></td>\n<td>Network latency spikes or server overload</td>\n<td>Measure round-trip times, server CPU usage</td>\n<td>Increase timeouts, add server capacity</td>\n</tr>\n<tr>\n<td><code>AddressAlreadyInUse</code> on server start</td>\n<td>Previous server instance still bound to port</td>\n<td><code>lsof -i :PORT</code>, check for zombie processes</td>\n<td>Clean shutdown, SO_REUSEADDR socket option</td>\n</tr>\n</tbody></table>\n<h4 id=\"socket-state-debugging\">Socket State Debugging</h4>\n<p>Understanding TCP socket states helps diagnose connection issues. The <code>RPCClient</code> and <code>RPCServer</code> maintain socket connections that transition through predictable states. When debugging, check the actual socket state against the expected state:</p>\n<table>\n<thead>\n<tr>\n<th>Expected Client State</th>\n<th>Socket State</th>\n<th>Diagnostic Command</th>\n<th>Common Mismatches</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Disconnected</td>\n<td>No socket entry</td>\n<td><code>netstat -an</code></td>\n<td>Leaked sockets from previous connections</td>\n</tr>\n<tr>\n<td>Connecting</td>\n<td><code>SYN_SENT</code></td>\n<td><code>ss -t state syn-sent</code></td>\n<td>Stuck in connecting due to firewall</td>\n</tr>\n<tr>\n<td>Connected</td>\n<td><code>ESTABLISHED</code></td>\n<td><code>ss -t state established</code></td>\n<td>Socket shows established but RPC calls fail</td>\n</tr>\n<tr>\n<td>Disconnecting</td>\n<td><code>FIN_WAIT1</code>, <code>FIN_WAIT2</code></td>\n<td><code>ss -t state fin-wait-1</code></td>\n<td>Clean shutdown taking too long</td>\n</tr>\n</tbody></table>\n<h4 id=\"server-connection-handling\">Server Connection Handling</h4>\n<p>The <code>RPCServer</code> accepts incoming connections and spawns threads to handle each client. Common issues arise from resource limits, thread management, and proper socket cleanup:</p>\n<p><strong>Connection Accept Loop Issues:</strong></p>\n<ol>\n<li><p><strong>Server stops accepting new connections</strong>: Usually caused by the accept loop exiting due to an unhandled exception. Check server logs for stack traces around the last successful connection.</p>\n</li>\n<li><p><strong><code>accept()</code> returns immediately with <code>EMFILE</code></strong>: The server has exhausted file descriptors. This happens when client connections aren&#39;t properly closed, leading to fd leaks.</p>\n</li>\n<li><p><strong>New connections hang in <code>SYN_RECEIVED</code></strong>: The server&#39;s accept backlog is full. Increase the backlog parameter in <code>listen()</code> or process connections faster.</p>\n</li>\n</ol>\n<p><strong>Thread Management Problems:</strong></p>\n<p>Server threading issues often manifest as resource exhaustion or hanging connections. The thread-per-connection model can consume significant resources:</p>\n<table>\n<thead>\n<tr>\n<th>Problem</th>\n<th>Symptoms</th>\n<th>Diagnosis</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Thread leak</td>\n<td>Memory usage grows indefinitely</td>\n<td><code>ps -eLf | grep python | wc -l</code></td>\n<td>Ensure threads join after client disconnect</td>\n</tr>\n<tr>\n<td>Too many threads</td>\n<td><code>OSError: can&#39;t create thread</code></td>\n<td>Monitor thread count vs system limits</td>\n<td>Connection pooling, async I/O</td>\n</tr>\n<tr>\n<td>Deadlock in threads</td>\n<td>Some connections hang indefinitely</td>\n<td>Thread dump, check <code>MethodRegistry</code> lock usage</td>\n<td>Review locking order, use timeouts</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Forgetting to set <code>daemon=True</code> on handler threads</strong></p>\n<p>When creating threads to handle client connections, forgetting to set <code>daemon=True</code> means the server process won&#39;t exit cleanly when the main thread ends. The process hangs waiting for handler threads to complete, which never happens if clients are still connected. Always use <code>daemon=True</code> for connection handler threads, and implement graceful shutdown if you need to wait for requests to complete.</p>\n<h4 id=\"client-connection-management\">Client Connection Management</h4>\n<p>The <code>RPCClient</code> maintains a persistent connection to the server, which introduces complexity around connection lifecycle management:</p>\n<p><strong>Connection Establishment Issues:</strong></p>\n<ol>\n<li><p><strong>Initial connection succeeds but subsequent calls fail</strong>: The client socket might be in an inconsistent state. Implement connection health checks by sending a small test message before important RPC calls.</p>\n</li>\n<li><p><strong>Connection works locally but fails in production</strong>: Different network environments (NAT, load balancers, proxies) can interfere with TCP connections. Log the actual IP addresses being used to ensure correct routing.</p>\n</li>\n<li><p><strong>Connection timeouts are too short/long</strong>: Network conditions vary dramatically. Implement adaptive timeouts that adjust based on measured round-trip times.</p>\n</li>\n</ol>\n<p><strong>Connection Reuse Problems:</strong></p>\n<p>The <code>_ensure_connected()</code> method determines when to establish or reuse connections. Common mistakes include:</p>\n<ul>\n<li>Not detecting broken connections before reuse</li>\n<li>Racing between connection cleanup and new requests</li>\n<li>Sharing connections across threads without proper synchronization</li>\n</ul>\n<h4 id=\"network-timeout-behavior\">Network Timeout Behavior</h4>\n<p>Timeouts in network programming have subtle behavior that often surprises developers. The <code>RPCClient</code> must handle multiple timeout scenarios:</p>\n<table>\n<thead>\n<tr>\n<th>Timeout Type</th>\n<th>What It Controls</th>\n<th>Default Behavior</th>\n<th>Debugging Tips</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection timeout</td>\n<td>Time to establish socket connection</td>\n<td>OS default (often 60+ seconds)</td>\n<td>Use <code>socket.settimeout()</code> before <code>connect()</code></td>\n</tr>\n<tr>\n<td>Send timeout</td>\n<td>Time to send complete message</td>\n<td>Blocks indefinitely</td>\n<td>Use <code>select()</code> or async I/O</td>\n</tr>\n<tr>\n<td>Receive timeout</td>\n<td>Time to receive complete response</td>\n<td>Blocks indefinitely</td>\n<td>Set socket timeout, handle <code>socket.timeout</code></td>\n</tr>\n<tr>\n<td>RPC call timeout</td>\n<td>End-to-end call completion</td>\n<td>Application-defined</td>\n<td>Track time from request send to response</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight</strong>: Network timeouts should be layered - a short connection timeout (5-10 seconds), medium send/receive timeouts (30 seconds), and longer RPC call timeouts (60+ seconds). This provides fast feedback for obvious failures while allowing legitimate long-running operations to complete.</p>\n</blockquote>\n<h4 id=\"testing-network-edge-cases\">Testing Network Edge Cases</h4>\n<p>Network issues are often intermittent and environment-dependent. Systematic testing helps identify problems before they occur in production:</p>\n<p><strong>Network Simulation Techniques:</strong></p>\n<ol>\n<li><p><strong>Latency injection</strong>: Use <code>tc</code> (traffic control) on Linux to add artificial network delays: <code>tc qdisc add dev lo root netem delay 100ms</code></p>\n</li>\n<li><p><strong>Packet loss simulation</strong>: Simulate unreliable networks: <code>tc qdisc add dev lo root netem loss 1%</code></p>\n</li>\n<li><p><strong>Bandwidth limiting</strong>: Test behavior under slow connections: <code>tc qdisc add dev lo root tbf rate 1kbit burst 1600 limit 3000</code></p>\n</li>\n<li><p><strong>Connection interruption</strong>: Use <code>iptables</code> to drop connections mid-stream and test recovery logic.</p>\n</li>\n</ol>\n<h3 id=\"serialization-and-protocol-issues\">Serialization and Protocol Issues</h3>\n<p>Serialization problems occur when converting between Python objects and the JSON wire format. These issues often manifest as parsing errors, type mismatches, or corrupted data. Unlike network issues that typically fail fast, serialization problems can cause subtle data corruption that&#39;s discovered much later.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: Serialization bugs often stem from assumptions about data types that hold during testing but break with real-world data variations. Always test with edge cases like empty values, very large numbers, Unicode strings, and nested data structures.</p>\n</blockquote>\n<h4 id=\"json-serialization-edge-cases\">JSON Serialization Edge Cases</h4>\n<p>JSON serialization seems straightforward but has numerous edge cases that can break RPC communication:</p>\n<table>\n<thead>\n<tr>\n<th>Data Type</th>\n<th>JSON Limitation</th>\n<th>Failure Mode</th>\n<th>Workaround</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>datetime</code> objects</td>\n<td>No native datetime type</td>\n<td><code>TypeError: datetime not JSON serializable</code></td>\n<td>Convert to ISO strings, custom serializer</td>\n</tr>\n<tr>\n<td><code>Decimal</code> numbers</td>\n<td>Only supports float precision</td>\n<td>Precision loss, rounding errors</td>\n<td>String encoding for exact decimals</td>\n</tr>\n<tr>\n<td><code>bytes</code> objects</td>\n<td>No binary data support</td>\n<td><code>TypeError: bytes not JSON serializable</code></td>\n<td>Base64 encoding</td>\n</tr>\n<tr>\n<td><code>set</code> collections</td>\n<td>No set type</td>\n<td><code>TypeError: set not JSON serializable</code></td>\n<td>Convert to list, document ordering loss</td>\n</tr>\n<tr>\n<td><code>None</code> vs empty string</td>\n<td>Both can represent &quot;missing&quot;</td>\n<td>Logic errors in parameter validation</td>\n<td>Explicit null checking</td>\n</tr>\n<tr>\n<td>Very large integers</td>\n<td>Implementation limits vary</td>\n<td>Precision loss in JavaScript clients</td>\n<td>String encoding for big integers</td>\n</tr>\n<tr>\n<td>NaN/Infinity floats</td>\n<td>Not part of JSON spec</td>\n<td>Varies by JSON library</td>\n<td>Replace with null or string representation</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Assuming JSON round-trip fidelity</strong></p>\n<p>A common mistake is assuming that <code>deserialize_message(serialize_message(data))</code> always returns data identical to the original. JSON serialization loses type information and precision. For example, Python tuples become lists, Decimal numbers become floats, and dictionary keys must be strings. Design your RPC interface to handle these transformations gracefully.</p>\n<h4 id=\"message-format-validation\">Message Format Validation</h4>\n<p>The <code>validate_request_message()</code> and <code>validate_response_message()</code> functions check JSON-RPC format compliance, but validation failures often indicate deeper issues:</p>\n<p><strong>Request Validation Failures:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Validation Error</th>\n<th>Potential Cause</th>\n<th>Investigation Steps</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Missing <code>method</code> field</td>\n<td>Client serialization bug</td>\n<td>Check <code>create_request_message()</code> logic</td>\n</tr>\n<tr>\n<td>Invalid <code>params</code> type</td>\n<td>Parameter marshaling error</td>\n<td>Log raw parameters before serialization</td>\n</tr>\n<tr>\n<td>Missing <code>id</code> field</td>\n<td>Request ID generation failure</td>\n<td>Verify <code>generate_request_id()</code> function</td>\n</tr>\n<tr>\n<td>Extra fields in request</td>\n<td>Version mismatch, debugging code</td>\n<td>Compare client/server protocol versions</td>\n</tr>\n</tbody></table>\n<p><strong>Response Validation Failures:</strong></p>\n<p>Response validation errors usually indicate server-side problems in request processing or response generation:</p>\n<ol>\n<li><p><strong>Missing <code>result</code> and <code>error</code> fields</strong>: The server&#39;s request dispatcher isn&#39;t following JSON-RPC protocol. Check the <code>process_request()</code> method for edge cases where neither result nor error is set.</p>\n</li>\n<li><p><strong>Wrong <code>id</code> field</strong>: Response correlation failure. This serious bug means responses can be delivered to the wrong pending request. Debug the request tracking logic in <code>_track_request()</code> and <code>_wait_for_response()</code>.</p>\n</li>\n<li><p><strong>Invalid error format</strong>: The server&#39;s error handling doesn&#39;t conform to JSON-RPC error structure. Verify that all error paths use <code>create_error_message()</code> with proper error codes.</p>\n</li>\n</ol>\n<h4 id=\"parameter-type-marshaling\">Parameter Type Marshaling</h4>\n<p>RPC calls involve converting Python function signatures to JSON arrays and back. Type mismatches cause failures that can be hard to debug:</p>\n<p><strong>Common Type Marshaling Issues:</strong></p>\n<ol>\n<li><p><strong>Positional vs keyword arguments</strong>: JSON-RPC traditionally uses positional parameters (JSON arrays), but Python functions often use keyword arguments. The <code>call()</code> method must decide how to marshal mixed args/kwargs.</p>\n</li>\n<li><p><strong>Complex nested objects</strong>: While simple types serialize cleanly, custom objects require explicit serialization logic. Attempting to serialize objects with circular references will cause infinite recursion.</p>\n</li>\n<li><p><strong>Function signature validation</strong>: The server should validate that the provided parameters match the registered function&#39;s signature. Mismatches should return <code>INVALID_PARAMS</code> errors, not Python exceptions.</p>\n</li>\n</ol>\n<h4 id=\"message-framing-errors\">Message Framing Errors</h4>\n<p>The length-prefix message framing protocol can fail in subtle ways, especially under high load or with large messages:</p>\n<p><strong>Framing Protocol Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Root Cause</th>\n<th>Diagnostic Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>recv()</code> returns fewer bytes than expected</td>\n<td>Network fragmentation or slow sender</td>\n<td>Log actual vs expected byte counts</td>\n</tr>\n<tr>\n<td>Length prefix reads as impossibly large number</td>\n<td>Byte order issues or corruption</td>\n<td>Check endianness, validate length bounds</td>\n</tr>\n<tr>\n<td>Message appears truncated</td>\n<td>Premature connection close</td>\n<td>Monitor socket state during receive</td>\n</tr>\n<tr>\n<td>JSON parsing fails on seemingly valid data</td>\n<td>UTF-8 encoding issues</td>\n<td>Hex dump received bytes, check encoding</td>\n</tr>\n</tbody></table>\n<p><strong>Message Size Validation:</strong></p>\n<p>The <code>MAX_MESSAGE_SIZE</code> constant protects against memory exhaustion from malicious or corrupted length prefixes. However, legitimate large messages can trigger this protection:</p>\n<ol>\n<li><p><strong>Large parameter lists</strong>: RPC calls with many parameters or large string/binary data can exceed size limits. Consider pagination or chunking for large data transfers.</p>\n</li>\n<li><p><strong>Detailed error messages</strong>: Error responses containing full stack traces can be surprisingly large. Truncate or summarize error details for production systems.</p>\n</li>\n</ol>\n<h4 id=\"debugging-serialization-problems\">Debugging Serialization Problems</h4>\n<p>Systematic debugging of serialization issues requires visibility into the data transformation pipeline:</p>\n<p><strong>Data Flow Tracing:</strong></p>\n<ol>\n<li><p><strong>Pre-serialization logging</strong>: Log the exact Python objects before JSON conversion to verify the input data integrity.</p>\n</li>\n<li><p><strong>Wire format inspection</strong>: Log the raw bytes sent over the network to check for encoding issues or corruption.</p>\n</li>\n<li><p><strong>Post-deserialization validation</strong>: After parsing JSON, log the reconstructed Python objects to verify round-trip accuracy.</p>\n</li>\n</ol>\n<p><strong>JSON Library Behavior:</strong></p>\n<p>Different JSON libraries have subtly different behavior that can cause interoperability issues:</p>\n<ul>\n<li>Standard <code>json</code> module: Strict JSON compliance, good error messages</li>\n<li><code>orjson</code>: High performance, but slightly different float formatting</li>\n<li><code>ujson</code>: Fast parsing, but less robust error handling</li>\n</ul>\n<blockquote>\n<p><strong>Design Principle</strong>: Use the standard <code>json</code> module during development for better error messages, then consider performance alternatives only if profiling shows JSON parsing as a bottleneck.</p>\n</blockquote>\n<h3 id=\"timing-and-concurrency-issues\">Timing and Concurrency Issues</h3>\n<p>Timing and concurrency bugs are among the most challenging to debug in RPC systems because they&#39;re often non-deterministic, environment-dependent, and may only manifest under specific load conditions. These issues arise from the inherent concurrency in network programming - multiple clients connecting simultaneously, overlapping requests and responses, and the need to correlate asynchronous operations.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: Concurrency bugs in RPC systems often involve shared state that seems fine during single-threaded testing but breaks when multiple operations access it simultaneously. The key to debugging is making these race conditions reproducible through stress testing and careful instrumentation.</p>\n</blockquote>\n<h4 id=\"request-id-correlation-problems\">Request ID Correlation Problems</h4>\n<p>The request ID mechanism allows clients to match responses with their originating requests when multiple calls are in flight. Bugs in this correlation system can cause responses to be delivered to the wrong callers or lost entirely:</p>\n<p><strong>Request ID Generation Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Problem</th>\n<th>Symptoms</th>\n<th>Debugging Approach</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Duplicate request IDs</td>\n<td>Responses delivered to wrong calls</td>\n<td>Log all generated IDs, check for duplicates</td>\n<td>Use UUIDs instead of counters</td>\n</tr>\n<tr>\n<td>ID wraparound in counters</td>\n<td>Old responses match new requests</td>\n<td>Monitor ID space exhaustion</td>\n<td>64-bit IDs or UUID4 generation</td>\n</tr>\n<tr>\n<td>Thread-unsafe ID generation</td>\n<td>Race conditions in ID assignment</td>\n<td>Stress test with concurrent calls</td>\n<td>Thread-safe ID generator</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Using simple incrementing counters for request IDs</strong></p>\n<p>A common mistake is using a simple counter like <code>self._next_id += 1</code> to generate request IDs. This creates two problems: thread safety (multiple threads can get the same ID) and eventual wraparound (after 2^32 requests, IDs repeat). Use <code>uuid.uuid4()</code> or a thread-safe counter with sufficient bit width.</p>\n<p><strong>Request Tracking Race Conditions:</strong></p>\n<p>The <code>_pending_requests</code> dictionary tracks active requests, but concurrent access creates race conditions:</p>\n<ol>\n<li><p><strong>Lost response handling</strong>: A response arrives just as the timeout handler is cleaning up the request. Both threads try to modify <code>_pending_requests</code> simultaneously.</p>\n</li>\n<li><p><strong>Double response processing</strong>: Network duplication causes the same response to arrive twice. Without proper cleanup, both copies might be processed.</p>\n</li>\n<li><p><strong>Memory leaks from orphaned requests</strong>: If request cleanup fails due to exceptions, entries remain in <code>_pending_requests</code> indefinitely.</p>\n</li>\n</ol>\n<p><strong>Request Tracking Debug Strategy:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># Effective debugging requires logging request lifecycle events:\n# 1. Request creation and tracking registration\n# 2. Response arrival and correlation\n# 3. Timeout expiration and cleanup\n# 4. Manual cleanup (disconnect/shutdown)</code></pre></div>\n\n<h4 id=\"timeout-handling-complexity\">Timeout Handling Complexity</h4>\n<p>Timeout handling involves multiple concurrent operations: sending requests, waiting for responses, and cleaning up expired requests. These operations must coordinate without blocking each other:</p>\n<p><strong>Timeout Implementation Challenges:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Timeout Type</th>\n<th>Concurrency Challenge</th>\n<th>Failure Mode</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Fixed timeouts</td>\n<td>All requests use same duration</td>\n<td>Fast operations wait unnecessarily, slow operations timeout prematurely</td>\n</tr>\n<tr>\n<td>Per-request timeouts</td>\n<td>Complex timeout tracking</td>\n<td>Race between timeout and response arrival</td>\n</tr>\n<tr>\n<td>Adaptive timeouts</td>\n<td>Requires RTT measurement</td>\n<td>Feedback loops can cause instability</td>\n</tr>\n</tbody></table>\n<p><strong>Timeout Race Conditions:</strong></p>\n<p>The most common timeout bug occurs when a response arrives just as the timeout expires:</p>\n<ol>\n<li><strong>Thread A</strong>: Waits for response, timeout expires, starts cleanup</li>\n<li><strong>Thread B</strong>: Receives response from network, starts processing</li>\n<li><strong>Race condition</strong>: Both threads try to remove the request from <code>_pending_requests</code></li>\n</ol>\n<p>The solution requires atomic operations and careful ordering:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># Timeout handler must:\n# 1. Atomically remove request from tracking (only if still present)\n# 2. Signal waiting thread with timeout error\n# 3. Avoid double-signaling if response already arrived\n\n# Response handler must:\n# 1. Atomically remove request from tracking (only if still present) \n# 2. Signal waiting thread with response\n# 3. Gracefully handle case where request was already timed out</code></pre></div>\n\n<h4 id=\"server-concurrency-issues\">Server Concurrency Issues</h4>\n<p>The <code>RPCServer</code> handles multiple client connections concurrently, creating shared state access patterns that can cause race conditions:</p>\n<p><strong>Method Registry Thread Safety:</strong></p>\n<p>The <code>MethodRegistry</code> allows dynamic registration and execution of RPC methods. Concurrent access creates several race conditions:</p>\n<table>\n<thead>\n<tr>\n<th>Operation Combination</th>\n<th>Race Condition</th>\n<th>Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Register + Execute</td>\n<td>Method added while call in progress</td>\n<td>Call might use old or new version inconsistently</td>\n</tr>\n<tr>\n<td>Unregister + Execute</td>\n<td>Method removed while call in progress</td>\n<td>Call fails with method-not-found despite being valid</td>\n</tr>\n<tr>\n<td>Multiple Registers</td>\n<td>Same method name registered by different threads</td>\n<td>Undefined which implementation wins</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: Method Registry Locking Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: The MethodRegistry needs thread-safe access for reading (method lookup) and writing (registration)</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Single mutex for all operations</li>\n<li>Read-write lock allowing concurrent reads</li>\n<li>Copy-on-write with atomic pointer swap</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Read-write lock (<code>threading.RLock</code>)</li>\n<li><strong>Rationale</strong>: Method execution (reads) vastly outnumbers registration (writes), so allowing concurrent reads improves performance significantly</li>\n<li><strong>Consequences</strong>: More complex lock management, but better scalability under load</li>\n</ul>\n</blockquote>\n<p><strong>Connection Handler Thread Lifecycle:</strong></p>\n<p>Each client connection gets its own handler thread, but thread management introduces timing issues:</p>\n<ol>\n<li><p><strong>Thread creation overhead</strong>: Creating threads for each connection is expensive. Under high connection rates, the server spends more time creating threads than processing requests.</p>\n</li>\n<li><p><strong>Thread cleanup timing</strong>: Handler threads must clean up resources when clients disconnect. If the client closes the connection abruptly, the cleanup code might not execute properly.</p>\n</li>\n<li><p><strong>Graceful shutdown coordination</strong>: When the server shuts down, it must wait for all handler threads to complete their current requests before exiting.</p>\n</li>\n</ol>\n<h4 id=\"deadlock-detection-and-prevention\">Deadlock Detection and Prevention</h4>\n<p>Deadlocks in RPC systems typically involve multiple locks being acquired in different orders by different threads. The most common scenario involves the method registry lock and request tracking locks:</p>\n<p><strong>Common Deadlock Patterns:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Thread 1 Operations</th>\n<th>Thread 2 Operations</th>\n<th>Deadlock Scenario</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. Acquire registry lock<br>2. Wait for tracking lock</td>\n<td>1. Acquire tracking lock<br>2. Wait for registry lock</td>\n<td>Classic two-lock deadlock</td>\n</tr>\n<tr>\n<td>1. Process request (registry)<br>2. Send response (socket)</td>\n<td>1. Handle timeout (tracking)<br>2. Update registry stats</td>\n<td>Nested lock acquisition with I/O</td>\n</tr>\n</tbody></table>\n<p><strong>Deadlock Prevention Strategies:</strong></p>\n<ol>\n<li><p><strong>Lock ordering</strong>: Always acquire locks in the same order across all code paths. Document the lock hierarchy clearly.</p>\n</li>\n<li><p><strong>Lock timeouts</strong>: Use timed lock acquisition to detect potential deadlocks. If a lock can&#39;t be acquired within a reasonable time, log a warning and abort the operation.</p>\n</li>\n<li><p><strong>Minimize lock scope</strong>: Hold locks for the shortest time possible. Don&#39;t perform I/O operations while holding locks.</p>\n</li>\n</ol>\n<h4 id=\"load-testing-for-concurrency-issues\">Load Testing for Concurrency Issues</h4>\n<p>Concurrency bugs often only appear under specific load patterns. Systematic load testing helps expose race conditions that don&#39;t occur during development:</p>\n<p><strong>Effective Load Testing Patterns:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Test Pattern</th>\n<th>Purpose</th>\n<th>Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Burst connections</td>\n<td>Test connection handling limits</td>\n<td>Open 100+ connections simultaneously</td>\n</tr>\n<tr>\n<td>Concurrent method calls</td>\n<td>Expose request tracking races</td>\n<td>Multiple threads calling same method</td>\n</tr>\n<tr>\n<td>Mixed read/write operations</td>\n<td>Test registry lock contention</td>\n<td>Register methods while handling calls</td>\n</tr>\n<tr>\n<td>Connection drops during calls</td>\n<td>Test cleanup logic</td>\n<td>Kill client connections mid-request</td>\n</tr>\n</tbody></table>\n<p><strong>Concurrency Bug Indicators:</strong></p>\n<p>Watch for these symptoms during load testing:</p>\n<ol>\n<li><strong>Inconsistent test results</strong>: The same test passes sometimes and fails others</li>\n<li><strong>Resource leaks</strong>: Memory or file descriptor usage grows over time  </li>\n<li><strong>Hanging operations</strong>: Requests never complete or timeout</li>\n<li><strong>Assertion failures</strong>: Race conditions causing invalid state</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Testing only single-threaded scenarios</strong></p>\n<p>Many developers test RPC functionality with a single client making sequential calls. This approach misses most concurrency bugs. Always include multi-threaded and multi-client test scenarios. Use tools like <code>threading.Barrier</code> to coordinate multiple threads and create worst-case race condition scenarios.</p>\n<h4 id=\"performance-monitoring-and-profiling\">Performance Monitoring and Profiling</h4>\n<p>Timing issues often manifest as performance problems rather than functional failures. Monitoring key metrics helps identify concurrency bottlenecks:</p>\n<p><strong>Key Timing Metrics:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Metric</th>\n<th>What It Reveals</th>\n<th>Monitoring Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Request latency distribution</td>\n<td>Lock contention, queueing delays</td>\n<td>Histogram of response times</td>\n</tr>\n<tr>\n<td>Thread pool utilization</td>\n<td>Resource exhaustion, blocking operations</td>\n<td>Active thread count over time</td>\n</tr>\n<tr>\n<td>Lock acquisition time</td>\n<td>Contention hotspots</td>\n<td>Time spent waiting for locks</td>\n</tr>\n<tr>\n<td>Connection establishment rate</td>\n<td>Network or threading bottlenecks</td>\n<td>Connections per second</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Debugging Principle</strong>: Performance problems and correctness problems in concurrent systems are often related. A performance degradation might indicate race conditions, lock contention, or resource leaks that will eventually cause functional failures.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical tools and techniques for systematically debugging RPC framework issues. The debugging utilities help isolate problems quickly and provide detailed diagnostic information.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Debugging Category</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network diagnostics</td>\n<td><code>netstat</code>, <code>telnet</code>, basic socket logging</td>\n<td><code>tcpdump</code>, <code>wireshark</code>, network monitoring tools</td>\n</tr>\n<tr>\n<td>Concurrency debugging</td>\n<td><code>threading</code> module logging, manual trace points</td>\n<td>Thread profilers, deadlock detection tools</td>\n</tr>\n<tr>\n<td>Serialization validation</td>\n<td>JSON pretty-printing, manual data inspection</td>\n<td>Schema validation libraries, fuzzing tools</td>\n</tr>\n<tr>\n<td>Performance monitoring</td>\n<td>Basic timing with <code>time.time()</code></td>\n<td><code>cProfile</code>, <code>py-spy</code>, APM tools</td>\n</tr>\n</tbody></table>\n<h4 id=\"debugging-infrastructure\">Debugging Infrastructure</h4>\n<p><strong>Complete Socket Diagnostic Helper:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ConnectionDiagnostics</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Diagnostic information about a socket connection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    local_address: </span><span style=\"color:#79B8FF\">tuple</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    remote_address: </span><span style=\"color:#79B8FF\">tuple</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    socket_state: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_sent: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_received: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    connection_time: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    last_activity: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SocketDiagnosticsHelper</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Helper for debugging socket-related issues.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._connections: Dict[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, ConnectionDiagnostics] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> threading.Lock()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_connection</span><span style=\"color:#E1E4E8\">(self, sock: socket.socket) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register a socket for diagnostic tracking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                local_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sock.getsockname()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                remote_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sock.getpeername()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                sock_fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sock.fileno()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">._connections[sock_fd] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ConnectionDiagnostics(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    local_address</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">local_addr,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    remote_address</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">remote_addr,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    socket_state</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"CONNECTED\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    bytes_sent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    bytes_received</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    connection_time</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">time.time(),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    last_activity</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#79B8FF\"> OSError</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Failed to register socket: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> record_send</span><span style=\"color:#E1E4E8\">(self, sock: socket.socket, byte_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record bytes sent on a socket.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Update connection diagnostics with send activity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Update last_activity timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Increment bytes_sent counter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle case where socket is not registered</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> record_receive</span><span style=\"color:#E1E4E8\">(self, sock: socket.socket, byte_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record bytes received on a socket.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Update connection diagnostics with receive activity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Update last_activity timestamp  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Increment bytes_received counter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle case where socket is not registered</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_connectivity</span><span style=\"color:#E1E4E8\">(self, host: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5.0</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test basic connectivity to a server.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create test socket with timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Attempt connection to host:port</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Measure connection time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test basic send/receive capability</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return diagnostic dictionary with results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Include success/failure, timing, and any error details</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Message Serialization Debugger:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> traceback</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict, List, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SerializationDebugger</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Helper for debugging JSON serialization issues.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_serializable</span><span style=\"color:#E1E4E8\">(data: Any, path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"root\"</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate that data can be JSON serialized and return issues.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        issues </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Recursively check data structure for serialization problems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check for non-serializable types (datetime, bytes, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check for circular references</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that dictionary keys are strings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check for very large numbers that might lose precision</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return list of issues with their paths in the data structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> issues</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> safe_serialize</span><span style=\"color:#E1E4E8\">(data: Any) -> Optional[</span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Attempt serialization with detailed error reporting.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Try to serialize data to JSON</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return encoded bytes if successful</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Catch and log specific serialization errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return None if serialization fails</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Serialization failed: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            traceback.print_exc()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> compare_round_trip</span><span style=\"color:#E1E4E8\">(original: Any) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test round-trip serialization and report differences.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Serialize original data to JSON</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Deserialize back to Python object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Compare original with round-trip result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Report type changes, precision loss, etc.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return detailed comparison report</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Request Tracking Diagnostics:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RequestDiagnostics</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Diagnostic information about an RPC request.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    request_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    method_name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_time: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timeout_seconds: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    thread_id: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"PENDING\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response_time: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    error_info: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RequestTrackingDiagnostics</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Helper for debugging request correlation and timeout issues.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._active_requests: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, RequestDiagnostics] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._completed_requests: List[RequestDiagnostics] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> threading.RLock()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._max_completed_history </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_request</span><span style=\"color:#E1E4E8\">(self, request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, method_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, timeout_seconds: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register a new request for tracking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create RequestDiagnostics object with current time and thread</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add to active_requests dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Use lock for thread safety</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> mark_response_received</span><span style=\"color:#E1E4E8\">(self, request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Mark request as having received a response.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Find request in active_requests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Update state to \"COMPLETED\" and set response_time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Move from active to completed list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return True if found, False if not</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle case where request was already cleaned up</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> mark_timeout</span><span style=\"color:#E1E4E8\">(self, request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Mark request as timed out.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Find request in active_requests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Update state to \"TIMEOUT\" and set error_info</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Move from active to completed list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return True if found, False if already cleaned up</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_diagnostics_summary</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get summary of request tracking state.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            active_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._active_requests)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate statistics on active requests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Find oldest active request and check if it's overdue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Count requests by state in completed history</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate average response times</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return comprehensive diagnostic dictionary</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"active_requests\"</span><span style=\"color:#E1E4E8\">: active_count,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"completed_requests\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._completed_requests),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"timestamp\"</span><span style=\"color:#E1E4E8\">: current_time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Add more diagnostic fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After Milestone 1 (Message Protocol):</strong></p>\n<p>Test serialization robustness with edge cases:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run this test to validate message protocol</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from your_rpc.protocol import create_request_message, serialize_message, deserialize_message</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">import json</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\"># Test edge cases</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">edge_cases = [</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    ('test_method', []),  # Empty parameters</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    ('test_method', [None, '', 0, False]),  # Falsy values</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    ('test_method', ['unicode: 你好', 'emoji: 😀']),  # Unicode strings</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    ('test_method', [1.7976931348623157e+308]),  # Very large float</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">for method, params in edge_cases:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    msg = create_request_message(method, params, 'test-id')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    serialized = serialize_message(msg)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    deserialized = deserialize_message(serialized)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    print(f'✓ {method} with {params} serialized successfully')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p>Expected output: All edge cases should serialize without exceptions.</p>\n<p><strong>After Milestone 2 (Server Implementation):</strong></p>\n<p>Test server concurrency and error handling:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test concurrent connections to the server</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">import threading</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">import socket</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">import time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">def test_connection():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    try:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        sock.connect(('localhost', 8000))</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        sock.send(b'test message')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        sock.close()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        print('✓ Connection successful')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    except Exception as e:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        print(f'✗ Connection failed: {e}')</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\"># Start 10 concurrent connections</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">threads = [threading.Thread(target=test_connection) for _ in range(10)]</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">for t in threads:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    t.start()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">for t in threads:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    t.join()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p>Expected output: All 10 connections should succeed without server errors.</p>\n<p><strong>After Milestone 3 (Client Implementation):</strong></p>\n<p>Test timeout handling and request correlation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test client timeout behavior</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from your_rpc.client import RPCClient</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">import threading</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">import time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">client = RPCClient('localhost', 8000)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">def make_call(method, delay):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    try:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        result = client.call(method, delay, timeout=2.0)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        print(f'✓ {method} completed: {result}')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    except Exception as e:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        print(f'✗ {method} failed: {e}')</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\"># Test concurrent calls with different timeouts</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">threads = [</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    threading.Thread(target=make_call, args=('fast_method', 0.5)),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    threading.Thread(target=make_call, args=('slow_method', 5.0)),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    threading.Thread(target=make_call, args=('medium_method', 1.5)),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">for t in threads:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    t.start()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">for t in threads:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    t.join()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p>Expected output: Fast and medium calls succeed, slow call times out after 2 seconds.</p>\n<h4 id=\"common-debugging-scenarios\">Common Debugging Scenarios</h4>\n<p><strong>Symptom: Client calls hang indefinitely</strong></p>\n<table>\n<thead>\n<tr>\n<th>Diagnosis Step</th>\n<th>Command/Technique</th>\n<th>Expected Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Check server running</td>\n<td><code>netstat -an | grep 8000</code></td>\n<td>Should show <code>LISTEN</code> state</td>\n</tr>\n<tr>\n<td>Test basic connectivity</td>\n<td><code>telnet localhost 8000</code></td>\n<td>Should connect successfully</td>\n</tr>\n<tr>\n<td>Check request ID tracking</td>\n<td>Add logging to <code>_track_request()</code></td>\n<td>Should show request being registered</td>\n</tr>\n<tr>\n<td>Monitor response correlation</td>\n<td>Add logging to response handler</td>\n<td>Should show if responses arrive</td>\n</tr>\n</tbody></table>\n<p><strong>Symptom: Intermittent serialization errors</strong></p>\n<table>\n<thead>\n<tr>\n<th>Diagnosis Step</th>\n<th>Investigation Technique</th>\n<th>What to Look For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Log pre-serialization data</td>\n<td>Add logging before <code>json.dumps()</code></td>\n<td>Non-serializable types, circular refs</td>\n</tr>\n<tr>\n<td>Test with simple data first</td>\n<td>Replace complex params with basic types</td>\n<td>Isolate problematic data structures</td>\n</tr>\n<tr>\n<td>Check Unicode handling</td>\n<td>Test with various string encodings</td>\n<td>UTF-8 encoding issues</td>\n</tr>\n<tr>\n<td>Validate JSON compliance</td>\n<td>Use strict JSON parser</td>\n<td>Invalid JSON constructs</td>\n</tr>\n</tbody></table>\n<p><strong>Symptom: Server handles some requests but not others</strong></p>\n<table>\n<thead>\n<tr>\n<th>Diagnosis Area</th>\n<th>Investigation Steps</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Method registry</td>\n<td>Log all registered methods, check method name matching</td>\n</tr>\n<tr>\n<td>Parameter validation</td>\n<td>Log received parameters vs expected function signature</td>\n</tr>\n<tr>\n<td>Exception handling</td>\n<td>Ensure all exceptions in method handlers are caught</td>\n</tr>\n<tr>\n<td>Thread synchronization</td>\n<td>Check for deadlocks in method registry access</td>\n</tr>\n</tbody></table>\n<h4 id=\"performance-debugging-tools\">Performance Debugging Tools</h4>\n<p><strong>Request Latency Tracker:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> collections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> DefaultDict, List</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LatencyTracker</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Track RPC call latencies for performance debugging.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._method_times: DefaultDict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> collections.defaultdict(</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._request_starts: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> start_request</span><span style=\"color:#E1E4E8\">(self, request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, method_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record request start time.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Store current timestamp for request_id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Associate with method_name for categorization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> end_request</span><span style=\"color:#E1E4E8\">(self, request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, method_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record request completion and calculate latency.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate elapsed time from start</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add to method_times list for the method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Remove from request_starts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle case where request_id not found (late response)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_latency_stats</span><span style=\"color:#E1E4E8\">(self, method_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get latency statistics for debugging.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate min, max, mean, median, 95th percentile</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return for specific method or all methods</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle case where no data is available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p>This debugging guide provides systematic approaches to identify and resolve the most common issues in RPC framework development. The key is following structured diagnostic processes rather than random troubleshooting, using proper instrumentation to make problems visible, and testing edge cases that don&#39;t occur during normal development.</p>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Beyond Milestones 1, 2, and 3 - advanced features that build upon the basic RPC framework foundation</p>\n</blockquote>\n<p>The basic RPC framework provides a solid foundation for remote procedure calls, but real-world systems require additional capabilities for performance, reliability, and scalability. This section explores natural extensions that transform our educational framework into a production-ready system. These enhancements follow the same design principles we&#39;ve established while addressing the operational challenges that emerge when RPC systems face high load, unreliable networks, and security requirements.</p>\n<h3 id=\"mental-model-the-growing-city-analogy\">Mental Model: The Growing City Analogy</h3>\n<p>Think of our basic RPC framework as a small town with a simple postal service. The town has grown successful, and now needs urban infrastructure improvements. The postal service (our message protocol) needs express lanes for high-priority mail (performance extensions). The town needs security systems and backup services (reliability extensions). Each extension addresses specific growing pains while preserving the fundamental architecture that made the original system work.</p>\n<p>The extensions fall into two primary categories: <strong>performance extensions</strong> that make the system faster and more efficient, and <strong>reliability extensions</strong> that make the system more robust and secure. Like urban planning, these improvements must be carefully designed to work together without creating conflicts or compromising the system&#39;s core simplicity.</p>\n<h3 id=\"performance-extensions\">Performance Extensions</h3>\n<p>Performance extensions focus on reducing latency, increasing throughput, and minimizing resource consumption. These improvements are essential when the RPC framework must handle thousands of concurrent requests or when network efficiency becomes critical.</p>\n<h4 id=\"connection-pooling\">Connection Pooling</h4>\n<p>Connection pooling transforms the client from establishing a new TCP connection for each RPC call to maintaining a reusable pool of persistent connections. This eliminates the overhead of TCP handshaking and connection teardown that becomes significant under high request volumes.</p>\n<p><strong>Current Limitation</strong>: The basic <code>RPCClient</code> establishes a single connection and reuses it for sequential requests. This creates a bottleneck when multiple threads need to make concurrent RPC calls, as they must wait for the shared connection to become available.</p>\n<blockquote>\n<p><strong>Decision: Connection Pool Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Multiple threads making concurrent RPC calls are serialized by the single shared connection, creating a throughput bottleneck and blocking threads unnecessarily</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Thread-local connections (one connection per thread)</li>\n<li>Shared connection pool with borrowing/returning semantics</li>\n<li>Connection-per-request with caching</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Shared connection pool with borrowing/returning semantics</li>\n<li><strong>Rationale</strong>: Thread-local connections can create too many connections under high thread counts, while connection-per-request loses reuse benefits. A shared pool provides optimal balance of connection reuse and concurrency.</li>\n<li><strong>Consequences</strong>: Requires connection lifecycle management and pool sizing configuration, but enables true concurrent RPC calls without thread blocking</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Design Aspect</th>\n<th>Thread-Local Connections</th>\n<th>Shared Connection Pool</th>\n<th>Connection-Per-Request</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Concurrency</td>\n<td>Excellent</td>\n<td>Good</td>\n<td>Excellent</td>\n</tr>\n<tr>\n<td>Resource Usage</td>\n<td>High (many connections)</td>\n<td>Medium</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Connection Reuse</td>\n<td>Good</td>\n<td>Excellent</td>\n<td>Poor</td>\n</tr>\n<tr>\n<td>Implementation Complexity</td>\n<td>Medium</td>\n<td>High</td>\n<td>Low</td>\n</tr>\n<tr>\n<td><strong>Chosen</strong></td>\n<td>No</td>\n<td><strong>Yes</strong></td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p>The connection pool maintains a collection of established TCP connections that can be borrowed for RPC calls and returned when complete. The pool handles connection health checking, automatic reconnection for stale connections, and pool size management based on demand.</p>\n<p><strong>Connection Pool Components:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>connections</code></td>\n<td><code>List[socket.socket]</code></td>\n<td>Available connections ready for use</td>\n</tr>\n<tr>\n<td><code>in_use</code></td>\n<td><code>Set[socket.socket]</code></td>\n<td>Connections currently borrowed for active requests</td>\n</tr>\n<tr>\n<td><code>max_size</code></td>\n<td><code>int</code></td>\n<td>Maximum number of connections to maintain</td>\n</tr>\n<tr>\n<td><code>min_size</code></td>\n<td><code>int</code></td>\n<td>Minimum connections to keep alive</td>\n</tr>\n<tr>\n<td><code>idle_timeout</code></td>\n<td><code>float</code></td>\n<td>Seconds before closing idle connections</td>\n</tr>\n<tr>\n<td><code>health_check_interval</code></td>\n<td><code>float</code></td>\n<td>Seconds between connection health checks</td>\n</tr>\n<tr>\n<td><code>pool_lock</code></td>\n<td><code>threading.RLock</code></td>\n<td>Protects pool state during concurrent access</td>\n</tr>\n</tbody></table>\n<p><strong>Connection Borrowing Algorithm:</strong></p>\n<ol>\n<li>Acquire the pool lock to ensure thread-safe access to pool state</li>\n<li>Check if any healthy connections are available in the connections list</li>\n<li>If available connection exists, move it from connections to in_use and return it</li>\n<li>If no connections available but pool size under maximum, create new connection</li>\n<li>Establish TCP connection to server with timeout and connection validation</li>\n<li>Add new connection to in_use set and return it to caller</li>\n<li>If pool at maximum size, block waiting for connection to be returned</li>\n<li>Implement timeout mechanism to prevent infinite blocking on pool exhaustion</li>\n</ol>\n<p><strong>Connection Health Checking:</strong>\nThe pool periodically validates that connections are still usable by sending lightweight ping messages or checking socket status. Broken connections are automatically removed from the pool and replaced with fresh connections.</p>\n<blockquote>\n<p>The key insight for connection pooling is that the complexity of pool management is isolated within the connection pool component, while the RPC calling interface remains unchanged. Existing code using <code>call()</code> methods continues to work transparently.</p>\n</blockquote>\n<h4 id=\"asynchronous-support\">Asynchronous Support</h4>\n<p>Asynchronous support transforms the blocking RPC client into a non-blocking system that can handle thousands of concurrent requests without dedicating a thread to each pending call. This is essential for building responsive applications that make many RPC calls concurrently.</p>\n<p><strong>Current Limitation</strong>: The basic <code>RPCClient.call()</code> method blocks the calling thread until the response arrives or timeout occurs. Applications making hundreds of concurrent RPC calls must create hundreds of threads, leading to resource exhaustion and context switching overhead.</p>\n<blockquote>\n<p><strong>Decision: Async/Await Integration</strong></p>\n<ul>\n<li><strong>Context</strong>: Blocking RPC calls force applications to use thread-per-request patterns that don&#39;t scale well under high concurrency loads</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Callback-based asynchronous interface</li>\n<li>Future/Promise-based interface</li>\n<li>Python asyncio integration with async/await</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Python asyncio integration with async/await syntax</li>\n<li><strong>Rationale</strong>: Async/await provides the most natural programming model for asynchronous code, avoiding callback hell and making error handling straightforward</li>\n<li><strong>Consequences</strong>: Requires asyncio event loop and separate async client implementation, but enables single-threaded high concurrency</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Async Approach</th>\n<th>Learning Curve</th>\n<th>Error Handling</th>\n<th>Debugging</th>\n<th>Performance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Callbacks</td>\n<td>High</td>\n<td>Complex</td>\n<td>Difficult</td>\n<td>Good</td>\n</tr>\n<tr>\n<td>Futures/Promises</td>\n<td>Medium</td>\n<td>Good</td>\n<td>Medium</td>\n<td>Good</td>\n</tr>\n<tr>\n<td><strong>Async/Await</strong></td>\n<td><strong>Medium</strong></td>\n<td><strong>Excellent</strong></td>\n<td><strong>Good</strong></td>\n<td><strong>Excellent</strong></td>\n</tr>\n</tbody></table>\n<p>The asynchronous client uses Python&#39;s <code>asyncio</code> library to manage concurrent RPC calls without blocking threads. Instead of blocking on socket operations, the client registers interest in socket readiness with the event loop and yields control to other coroutines.</p>\n<p><strong>Async Client Components:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>_event_loop</code></td>\n<td><code>asyncio.AbstractEventLoop</code></td>\n<td>Event loop managing async operations</td>\n</tr>\n<tr>\n<td><code>_connection_pool</code></td>\n<td><code>AsyncConnectionPool</code></td>\n<td>Non-blocking connection management</td>\n</tr>\n<tr>\n<td><code>_pending_requests</code></td>\n<td><code>Dict[str, asyncio.Future]</code></td>\n<td>Futures awaiting responses</td>\n</tr>\n<tr>\n<td><code>_response_handler_task</code></td>\n<td><code>asyncio.Task</code></td>\n<td>Background task processing incoming responses</td>\n</tr>\n<tr>\n<td><code>_request_semaphore</code></td>\n<td><code>asyncio.Semaphore</code></td>\n<td>Limits concurrent request count</td>\n</tr>\n</tbody></table>\n<p><strong>Async Call Flow:</strong></p>\n<ol>\n<li>Create request message with unique ID and serialize to bytes</li>\n<li>Acquire connection from async connection pool (may await if pool full)</li>\n<li>Send request bytes over connection using asyncio socket operations</li>\n<li>Create Future object for this request ID and store in pending requests</li>\n<li>Return the Future to caller for awaiting (call is now non-blocking)</li>\n<li>Background response handler receives responses and resolves matching Futures</li>\n<li>When response arrives, lookup Future by request ID and set result/exception</li>\n<li>Calling code awaits the Future and receives the result when available</li>\n</ol>\n<p><strong>Background Response Handler:</strong>\nA dedicated asyncio task continuously reads responses from all active connections and routes them to the appropriate Future objects. This single task can handle responses from thousands of concurrent requests efficiently.</p>\n<blockquote>\n<p>The async transformation maintains the same logical request/response model while eliminating thread blocking. The programming model changes from <code>result = client.call(method, args)</code> to <code>result = await async_client.call(method, args)</code>.</p>\n</blockquote>\n<h4 id=\"binary-serialization\">Binary Serialization</h4>\n<p>Binary serialization replaces JSON encoding with more efficient binary formats like MessagePack or Protocol Buffers. This reduces message size and serialization overhead, especially important for large payloads or high-frequency RPC calls.</p>\n<p><strong>Current Limitation</strong>: JSON serialization is human-readable and easy to debug, but produces large messages and requires significant CPU time for encoding/decoding. For RPC calls with large data structures or high call volumes, serialization becomes a performance bottleneck.</p>\n<blockquote>\n<p><strong>Decision: MessagePack as Primary Binary Format</strong></p>\n<ul>\n<li><strong>Context</strong>: JSON serialization creates large messages and high CPU overhead for complex data structures with nested objects and arrays</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>MessagePack (schema-less binary JSON equivalent)</li>\n<li>Protocol Buffers (schema-based with code generation)</li>\n<li>Apache Avro (schema-based with runtime schema evolution)</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: MessagePack as primary format with JSON fallback</li>\n<li><strong>Rationale</strong>: MessagePack maintains JSON&#39;s schema-less flexibility while providing binary efficiency, and requires no schema management or code generation</li>\n<li><strong>Consequences</strong>: Smaller messages and faster serialization, but loses human readability and requires binary debugging tools</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Serialization Format</th>\n<th>Message Size</th>\n<th>CPU Overhead</th>\n<th>Schema Management</th>\n<th>Debugging</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JSON</td>\n<td>Large</td>\n<td>High</td>\n<td>None</td>\n<td>Excellent</td>\n</tr>\n<tr>\n<td><strong>MessagePack</strong></td>\n<td><strong>Small</strong></td>\n<td><strong>Low</strong></td>\n<td><strong>None</strong></td>\n<td><strong>Fair</strong></td>\n</tr>\n<tr>\n<td>Protocol Buffers</td>\n<td>Smallest</td>\n<td>Lowest</td>\n<td>Complex</td>\n<td>Poor</td>\n</tr>\n<tr>\n<td>Apache Avro</td>\n<td>Small</td>\n<td>Medium</td>\n<td>Medium</td>\n<td>Fair</td>\n</tr>\n</tbody></table>\n<p><strong>Binary Serialization Architecture:</strong>\nThe framework supports multiple serialization formats through a pluggable serialization interface. Clients and servers negotiate the serialization format during connection establishment, with fallback to JSON for compatibility.</p>\n<p><strong>Serialization Interface:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>serialize_message(message, format)</code></td>\n<td><code>Dict, str</code></td>\n<td><code>bytes</code></td>\n<td>Encode message using specified format</td>\n</tr>\n<tr>\n<td><code>deserialize_message(data, format)</code></td>\n<td><code>bytes, str</code></td>\n<td><code>Dict</code></td>\n<td>Decode bytes using specified format</td>\n</tr>\n<tr>\n<td><code>get_supported_formats()</code></td>\n<td>None</td>\n<td><code>List[str]</code></td>\n<td>List available serialization formats</td>\n</tr>\n<tr>\n<td><code>negotiate_format(client_formats, server_formats)</code></td>\n<td><code>List[str], List[str]</code></td>\n<td><code>str</code></td>\n<td>Select optimal compatible format</td>\n</tr>\n</tbody></table>\n<p><strong>Format Negotiation Process:</strong></p>\n<ol>\n<li>Client sends connection handshake including list of supported serialization formats</li>\n<li>Server responds with its supported formats and selects best mutual format</li>\n<li>Both client and server use negotiated format for all subsequent messages</li>\n<li>If no mutual format exists, fall back to JSON as universal compatibility format</li>\n<li>Format selection considers efficiency, with preference for binary formats over JSON</li>\n</ol>\n<p><strong>MessagePack Integration Benefits:</strong></p>\n<ul>\n<li>Message size typically 30-50% smaller than equivalent JSON</li>\n<li>Serialization speed 2-3x faster than JSON for complex objects</li>\n<li>Direct mapping from JSON data types (no schema required)</li>\n<li>Preserves type information (distinguishes integers from floats)</li>\n<li>Support for binary data without base64 encoding overhead</li>\n</ul>\n<blockquote>\n<p>Binary serialization provides the most significant performance improvement for RPC systems with large payloads or high call volumes, often reducing network bandwidth by 40% and serialization CPU usage by 60%.</p>\n</blockquote>\n<h3 id=\"reliability-extensions\">Reliability Extensions</h3>\n<p>Reliability extensions focus on making the RPC framework robust against failures, secure against attacks, and resilient under adverse conditions. These improvements are essential for production systems that must operate continuously despite network failures, server crashes, and malicious actors.</p>\n<h4 id=\"authentication-and-authorization\">Authentication and Authorization</h4>\n<p>Authentication verifies the identity of RPC clients, while authorization determines which methods each authenticated client is permitted to invoke. This prevents unauthorized access and enables fine-grained permission control over RPC services.</p>\n<p><strong>Current Limitation</strong>: The basic RPC framework has no security mechanisms. Any client that can connect to the server can invoke any registered method, creating serious security vulnerabilities in production environments.</p>\n<blockquote>\n<p><strong>Decision: Token-Based Authentication with Method-Level Authorization</strong></p>\n<ul>\n<li><strong>Context</strong>: Production RPC services need to verify client identity and restrict access to sensitive methods based on client permissions</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>HTTP Basic Authentication (simple but sends credentials repeatedly)</li>\n<li>JWT tokens (stateless but require signature verification)</li>\n<li>Session-based authentication (stateful but requires session storage)</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: JWT token authentication with method-level authorization rules</li>\n<li><strong>Rationale</strong>: JWT tokens are stateless, self-contained, and can carry authorization claims, eliminating the need for server-side session storage while supporting fine-grained permissions</li>\n<li><strong>Consequences</strong>: Adds token verification overhead to each request, but provides robust security without server-side state management</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Authentication Method</th>\n<th>Stateless</th>\n<th>Performance</th>\n<th>Security</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Basic Auth</td>\n<td>Yes</td>\n<td>Excellent</td>\n<td>Poor</td>\n<td>Low</td>\n</tr>\n<tr>\n<td><strong>JWT Tokens</strong></td>\n<td><strong>Yes</strong></td>\n<td><strong>Good</strong></td>\n<td><strong>Excellent</strong></td>\n<td><strong>Medium</strong></td>\n</tr>\n<tr>\n<td>Session-Based</td>\n<td>No</td>\n<td>Good</td>\n<td>Good</td>\n<td>High</td>\n</tr>\n</tbody></table>\n<p><strong>Authentication Architecture:</strong>\nAuthentication is implemented as a middleware layer that intercepts requests before they reach the method registry. The middleware extracts authentication tokens, validates them, and enriches the request context with identity and permission information.</p>\n<p><strong>Authentication Components:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>token_validator</code></td>\n<td><code>JWTValidator</code></td>\n<td>Validates JWT token signatures and expiration</td>\n</tr>\n<tr>\n<td><code>permission_store</code></td>\n<td><code>PermissionStore</code></td>\n<td>Maps user identities to method permissions</td>\n</tr>\n<tr>\n<td><code>auth_middleware</code></td>\n<td><code>AuthMiddleware</code></td>\n<td>Intercepts requests and enforces authentication</td>\n</tr>\n<tr>\n<td><code>client_identity</code></td>\n<td><code>ClientIdentity</code></td>\n<td>Represents authenticated client with permissions</td>\n</tr>\n</tbody></table>\n<p><strong>Authentication Request Flow:</strong></p>\n<ol>\n<li>Client includes JWT token in request message header or dedicated auth field</li>\n<li>Server&#39;s auth middleware extracts token from incoming request message</li>\n<li>Middleware validates token signature using configured public key or shared secret</li>\n<li>Middleware checks token expiration time and other standard JWT claims</li>\n<li>Middleware extracts user identity and roles from token&#39;s custom claims</li>\n<li>Permission store lookup determines which methods this identity can invoke</li>\n<li>If target method is authorized, request continues to method registry for execution</li>\n<li>If authentication fails or method unauthorized, return error without invoking method</li>\n</ol>\n<p><strong>JWT Token Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Header: {&quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;}\nPayload: {\n  &quot;sub&quot;: &quot;user_id&quot;,\n  &quot;exp&quot;: 1234567890,\n  &quot;iat&quot;: 1234567800,\n  &quot;roles&quot;: [&quot;read_user&quot;, &quot;write_orders&quot;],\n  &quot;permissions&quot;: [&quot;get_user_info&quot;, &quot;create_order&quot;, &quot;update_order&quot;]\n}</code></pre></div>\n\n<p><strong>Method-Level Authorization:</strong>\nEach registered method can specify required permissions through decorators or configuration. The auth middleware checks that the authenticated client possesses all required permissions before allowing method execution.</p>\n<table>\n<thead>\n<tr>\n<th>Permission Model</th>\n<th>Granularity</th>\n<th>Management Overhead</th>\n<th>Flexibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Role-Based</td>\n<td>Medium</td>\n<td>Low</td>\n<td>Good</td>\n</tr>\n<tr>\n<td><strong>Permission-Based</strong></td>\n<td><strong>High</strong></td>\n<td><strong>Medium</strong></td>\n<td><strong>Excellent</strong></td>\n</tr>\n<tr>\n<td>Method-Level ACLs</td>\n<td>Highest</td>\n<td>High</td>\n<td>Good</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>Authentication and authorization add security at the cost of performance overhead. Token validation typically adds 1-2ms per request, which is acceptable for most applications but may require caching optimizations for extremely high-throughput systems.</p>\n</blockquote>\n<h4 id=\"encryption-and-transport-security\">Encryption and Transport Security</h4>\n<p>Encryption protects RPC messages from eavesdropping and tampering during network transmission. This is essential when RPC calls contain sensitive data or traverse untrusted networks like the public internet.</p>\n<p><strong>Current Limitation</strong>: The basic RPC framework uses plain TCP sockets that transmit messages in cleartext. Network attackers can read all RPC traffic and potentially modify messages in transit.</p>\n<blockquote>\n<p><strong>Decision: TLS 1.3 for Transport Encryption</strong></p>\n<ul>\n<li><strong>Context</strong>: RPC messages may contain sensitive data and travel across untrusted networks where eavesdropping and tampering are possible</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Application-level encryption (encrypt message payloads)</li>\n<li>TLS transport encryption (encrypt entire TCP connection)</li>\n<li>VPN-based network encryption (encrypt at network layer)</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: TLS 1.3 for transport-level encryption</li>\n<li><strong>Rationale</strong>: TLS provides proven security with minimal application code changes, handles key exchange automatically, and encrypts all traffic including metadata</li>\n<li><strong>Consequences</strong>: Adds TLS handshake overhead and CPU cost for encryption/decryption, but provides comprehensive protection against network-level attacks</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Encryption Approach</th>\n<th>Protection Scope</th>\n<th>Performance Impact</th>\n<th>Implementation Effort</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Application-Level</td>\n<td>Message Content</td>\n<td>Low</td>\n<td>High</td>\n</tr>\n<tr>\n<td><strong>TLS Transport</strong></td>\n<td><strong>Complete Traffic</strong></td>\n<td><strong>Medium</strong></td>\n<td><strong>Low</strong></td>\n</tr>\n<tr>\n<td>Network-Level VPN</td>\n<td>Complete Traffic</td>\n<td>Low</td>\n<td>External</td>\n</tr>\n</tbody></table>\n<p><strong>TLS Integration Architecture:</strong>\nTLS encryption is implemented by wrapping the TCP sockets in TLS sockets that handle encryption/decryption transparently. The existing RPC message protocol operates unchanged over the encrypted transport.</p>\n<p><strong>TLS Configuration Components:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>tls_context</code></td>\n<td><code>ssl.SSLContext</code></td>\n<td>TLS configuration including cipher suites and certificates</td>\n</tr>\n<tr>\n<td><code>server_certificate</code></td>\n<td><code>ssl.Certificate</code></td>\n<td>Server&#39;s public key certificate for client verification</td>\n</tr>\n<tr>\n<td><code>private_key</code></td>\n<td><code>ssl.PrivateKey</code></td>\n<td>Server&#39;s private key for TLS handshake</td>\n</tr>\n<tr>\n<td><code>ca_certificates</code></td>\n<td><code>List[ssl.Certificate]</code></td>\n<td>Certificate authorities trusted for client certificates</td>\n</tr>\n<tr>\n<td><code>cipher_preferences</code></td>\n<td><code>List[str]</code></td>\n<td>Ordered list of acceptable cipher suites</td>\n</tr>\n</tbody></table>\n<p><strong>TLS Handshake Process:</strong></p>\n<ol>\n<li>Client initiates TCP connection to server as before</li>\n<li>Client immediately starts TLS handshake by sending ClientHello message</li>\n<li>Server responds with ServerHello, certificate, and key exchange information</li>\n<li>Client validates server certificate against trusted certificate authorities</li>\n<li>Client and server complete key exchange to establish shared encryption keys</li>\n<li>Both sides send Finished messages to confirm successful handshake</li>\n<li>All subsequent RPC messages are encrypted using established session keys</li>\n<li>RPC protocol operates normally over the encrypted TLS connection</li>\n</ol>\n<p><strong>Certificate Management:</strong>\nProduction deployments require proper certificate management with certificate rotation, certificate authority validation, and secure private key storage. Development environments can use self-signed certificates for testing.</p>\n<blockquote>\n<p>TLS encryption typically adds 5-10ms latency for the initial handshake and 10-20% CPU overhead for encryption/decryption. Connection reuse amortizes the handshake cost across many RPC calls.</p>\n</blockquote>\n<h4 id=\"retry-mechanisms-and-circuit-breakers\">Retry Mechanisms and Circuit Breakers</h4>\n<p>Retry mechanisms automatically re-execute failed RPC calls, while circuit breakers prevent cascading failures by temporarily stopping calls to unresponsive services. Together, they make RPC systems resilient to transient network failures and server overload.</p>\n<p><strong>Current Limitation</strong>: The basic RPC framework treats all failures as permanent. A temporary network glitch or momentary server overload causes RPC calls to fail immediately, even though a retry seconds later would likely succeed.</p>\n<blockquote>\n<p><strong>Decision: Exponential Backoff Retry with Circuit Breaker Protection</strong></p>\n<ul>\n<li><strong>Context</strong>: Transient network failures and temporary server overload should not cause permanent RPC failures, but naive retry can amplify problems during outages</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Fixed interval retry (simple but can overwhelm recovering servers)</li>\n<li>Exponential backoff retry (reduces load on recovering servers)</li>\n<li>Circuit breaker only (prevents cascading failures but no retry)</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Exponential backoff retry with circuit breaker protection</li>\n<li><strong>Rationale</strong>: Exponential backoff handles transient failures gracefully while circuit breakers prevent retry storms during extended outages</li>\n<li><strong>Consequences</strong>: Improves reliability but adds complexity and potential for longer response times during failures</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Resilience Pattern</th>\n<th>Transient Failures</th>\n<th>Extended Outages</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Fixed Retry</td>\n<td>Good</td>\n<td>Poor</td>\n<td>Low</td>\n</tr>\n<tr>\n<td><strong>Exponential Backoff</strong></td>\n<td><strong>Excellent</strong></td>\n<td><strong>Fair</strong></td>\n<td><strong>Medium</strong></td>\n</tr>\n<tr>\n<td>Circuit Breaker</td>\n<td>Poor</td>\n<td>Excellent</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td><strong>Combined Approach</strong></td>\n<td><strong>Excellent</strong></td>\n<td><strong>Excellent</strong></td>\n<td><strong>High</strong></td>\n</tr>\n</tbody></table>\n<p><strong>Retry Configuration:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>max_attempts</code></td>\n<td><code>int</code></td>\n<td>Maximum retry attempts before permanent failure</td>\n</tr>\n<tr>\n<td><code>base_delay</code></td>\n<td><code>float</code></td>\n<td>Initial delay before first retry (seconds)</td>\n</tr>\n<tr>\n<td><code>max_delay</code></td>\n<td><code>float</code></td>\n<td>Maximum delay between retries (seconds)</td>\n</tr>\n<tr>\n<td><code>backoff_multiplier</code></td>\n<td><code>float</code></td>\n<td>Multiplier for exponential delay increase</td>\n</tr>\n<tr>\n<td><code>jitter_enabled</code></td>\n<td><code>bool</code></td>\n<td>Add randomization to prevent thundering herd</td>\n</tr>\n<tr>\n<td><code>retryable_errors</code></td>\n<td><code>Set[ErrorCode]</code></td>\n<td>Which error types should trigger retry</td>\n</tr>\n</tbody></table>\n<p><strong>Exponential Backoff Algorithm:</strong></p>\n<ol>\n<li>Execute initial RPC call attempt and capture any resulting error</li>\n<li>Check if error type is in the configured set of retryable errors</li>\n<li>If not retryable (e.g., authentication failure), return error immediately</li>\n<li>If retryable and attempts remain, calculate delay as base_delay * (multiplier ^ attempt)</li>\n<li>Add random jitter to delay to prevent synchronized retry storms</li>\n<li>Sleep for calculated delay period before attempting next retry</li>\n<li>Increment attempt counter and repeat from step 1 until success or max attempts</li>\n<li>If all attempts exhausted, return the last error to the caller</li>\n</ol>\n<p><strong>Circuit Breaker States:</strong></p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th>Request Handling</th>\n<th>Transition Conditions</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CLOSED</code></td>\n<td>Pass all requests</td>\n<td>Failure rate exceeds threshold → OPEN</td>\n<td>Normal operation</td>\n</tr>\n<tr>\n<td><code>OPEN</code></td>\n<td>Reject immediately</td>\n<td>Timeout expires → HALF_OPEN</td>\n<td>Prevent cascading failures</td>\n</tr>\n<tr>\n<td><code>HALF_OPEN</code></td>\n<td>Allow single test request</td>\n<td>Success → CLOSED, Failure → OPEN</td>\n<td>Test service recovery</td>\n</tr>\n</tbody></table>\n<p><strong>Circuit Breaker Algorithm:</strong></p>\n<ol>\n<li>Track success and failure rates using sliding window of recent requests</li>\n<li>When failure rate exceeds threshold (e.g., 50% failures in last 100 requests), trip to OPEN</li>\n<li>In OPEN state, immediately return circuit breaker error without attempting RPC call</li>\n<li>After timeout period (e.g., 60 seconds), transition to HALF_OPEN state</li>\n<li>In HALF_OPEN, allow single test request to determine if service has recovered</li>\n<li>If test request succeeds, reset failure counters and return to CLOSED state</li>\n<li>If test request fails, return to OPEN state and restart timeout period</li>\n</ol>\n<blockquote>\n<p>The combination of retry and circuit breaker provides comprehensive resilience: retries handle brief failures while circuit breakers prevent retry storms during extended outages. This is essential for building robust distributed systems.</p>\n</blockquote>\n<p>⚠️ <strong>Common Pitfall: Retry Without Idempotency Consideration</strong>\nMany developers implement retry logic without considering whether the RPC methods are idempotent (safe to call multiple times). Retrying non-idempotent operations like &quot;transfer money&quot; or &quot;send email&quot; can cause duplicate actions. The solution is to either ensure all retried methods are idempotent, or implement request deduplication using unique request IDs to detect and ignore duplicate calls.</p>\n<p>⚠️ <strong>Common Pitfall: Circuit Breaker Per Client Instead of Per Service</strong>\nImplementing circuit breakers at the client instance level rather than per remote service can cause false positives. If one service is down but others are healthy, a per-client circuit breaker might prevent all RPC calls. Instead, maintain separate circuit breaker state for each remote service endpoint.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>These performance and reliability extensions build upon the basic RPC framework established in earlier milestones. The implementation approach follows a modular design where extensions can be added incrementally without breaking existing functionality.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Extension Category</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection Pooling</td>\n<td>Thread-safe queue with basic pooling</td>\n<td><code>asyncio</code> connection pool with health checks</td>\n</tr>\n<tr>\n<td>Async Support</td>\n<td>Threading with futures</td>\n<td>Full <code>asyncio</code> integration</td>\n</tr>\n<tr>\n<td>Binary Serialization</td>\n<td>MessagePack with fallback to JSON</td>\n<td>Protocol Buffers with schema evolution</td>\n</tr>\n<tr>\n<td>Authentication</td>\n<td>Simple API keys</td>\n<td>JWT tokens with role-based permissions</td>\n</tr>\n<tr>\n<td>Encryption</td>\n<td>TLS with self-signed certificates</td>\n<td>TLS with proper CA certificates</td>\n</tr>\n<tr>\n<td>Retry Logic</td>\n<td>Fixed delay retry</td>\n<td>Exponential backoff with jitter</td>\n</tr>\n<tr>\n<td>Circuit Breakers</td>\n<td>Simple failure counting</td>\n<td>Sliding window with configurable thresholds</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>rpc-framework/\n├── rpc/\n│   ├── extensions/\n│   │   ├── __init__.py\n│   │   ├── connection_pool.py      ← Connection pooling implementation\n│   │   ├── async_client.py         ← Asyncio-based RPC client\n│   │   ├── serialization.py        ← Pluggable serialization formats\n│   │   ├── auth/\n│   │   │   ├── __init__.py\n│   │   │   ├── middleware.py       ← Authentication middleware\n│   │   │   ├── jwt_validator.py    ← JWT token validation\n│   │   │   └── permissions.py      ← Permission management\n│   │   ├── security/\n│   │   │   ├── __init__.py\n│   │   │   ├── tls_config.py       ← TLS configuration helpers\n│   │   │   └── certificates.py     ← Certificate management\n│   │   └── resilience/\n│   │       ├── __init__.py\n│   │       ├── retry_handler.py    ← Retry logic with exponential backoff\n│   │       └── circuit_breaker.py  ← Circuit breaker implementation\n│   ├── core/                       ← Basic RPC framework from earlier milestones\n│   │   ├── protocol.py\n│   │   ├── server.py\n│   │   └── client.py\n│   └── utils/\n│       ├── diagnostics.py          ← Enhanced debugging for extensions\n│       └── testing.py              ← Test helpers for extensions\n├── examples/\n│   ├── pooled_client_example.py    ← Connection pooling demo\n│   ├── async_client_example.py     ← Async RPC calls demo\n│   ├── secure_server_example.py    ← TLS + authentication demo\n│   └── resilient_client_example.py ← Retry + circuit breaker demo\n└── tests/\n    ├── test_extensions/\n    │   ├── test_connection_pool.py\n    │   ├── test_async_client.py\n    │   ├── test_authentication.py\n    │   └── test_resilience.py\n    └── integration/\n        └── test_production_scenarios.py</code></pre></div>\n\n<h4 id=\"connection-pool-infrastructure\">Connection Pool Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc/extensions/connection_pool.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Set, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> queue </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Queue, Empty</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> contextlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> contextmanager</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ConnectionPool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Thread-safe connection pool for RPC clients.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, host: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, max_size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 min_size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">, idle_timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300.0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize pool state with empty connections and in_use sets</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Store connection parameters (host, port) for creating new connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Set up threading primitives (lock, condition variable for waiting)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Start background thread for connection health checking and cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> borrow_connection</span><span style=\"color:#E1E4E8\">(self, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Borrow connection from pool, automatically return when done.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Acquire lock and look for available connection in pool</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If no connection available, try to create new one if under max_size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If at max_size, wait for connection to be returned (with timeout)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Move borrowed connection from available to in_use set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Yield connection to caller for use in with statement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: In finally block, return connection to pool and notify waiters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _create_connection</span><span style=\"color:#E1E4E8\">(self) -> socket.socket:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create new TCP connection to RPC server.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create TCP socket with appropriate options (SO_REUSEADDR, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Set socket timeout for connection establishment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Connect to configured host and port</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate connection is working (send/receive test message)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return established socket ready for RPC communication</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _health_check_worker</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Background thread that validates connection health and manages pool size.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Run infinite loop with periodic sleep (health_check_interval)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Acquire pool lock and iterate through available connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Test each connection health (try sending ping or check socket status)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Remove dead connections from pool and close their sockets</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If pool below min_size, create new connections to reach minimum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"async-client-core-implementation\">Async Client Core Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc/extensions/async_client.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> rpc.core.protocol </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> create_request_message, serialize_message</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AsyncRPCClient</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Asyncio-based RPC client for high-concurrency applications.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, host: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, max_concurrent: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Store connection parameters and initialize async state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create semaphore to limit concurrent requests (prevent resource exhaustion)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Initialize pending requests dict for tracking futures by request ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Set up connection state (reader, writer, connected flag)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> call</span><span style=\"color:#E1E4E8\">(self, method_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Make async RPC call, returns coroutine that resolves to result.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate unique request ID for correlation with response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create request message with method name and parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Serialize message to bytes for network transmission</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Acquire semaphore to limit concurrent requests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Ensure connection is established (call _ensure_connected)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Send serialized request over asyncio stream writer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Create Future for this request and store in pending_requests dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Set up timeout task to cancel future if response doesn't arrive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Return awaitable future that caller can await for result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _ensure_connected</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Establish asyncio connection if not already connected.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if already connected (self._connected flag)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If not connected, use asyncio.open_connection to connect</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Store reader and writer streams for sending/receiving</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Start background task for reading responses (_response_handler)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Set connected flag and handle connection errors appropriately</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _response_handler</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Background coroutine that reads responses and resolves pending futures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Run infinite loop reading from asyncio stream reader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Read length-prefixed messages from stream (handle partial reads)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Deserialize received bytes to response message dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Extract request ID from response to find matching pending future</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Check if response contains result or error and resolve future appropriately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Remove completed request from pending_requests dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Handle connection errors by rejecting all pending futures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"authentication-middleware-foundation\">Authentication Middleware Foundation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc/extensions/auth/middleware.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional, Set</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> jwt</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> rpc.core.protocol </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> create_error_message, ErrorCode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuthMiddleware</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Authentication middleware that validates JWT tokens and enforces permissions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, jwt_secret: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, permission_store: </span><span style=\"color:#9ECBFF\">'PermissionStore'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Store JWT validation secret and permission store reference</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Configure JWT validation options (algorithms, expiration checking)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Initialize any caching for token validation results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_request</span><span style=\"color:#E1E4E8\">(self, request_message: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process incoming request, return error dict if authentication fails.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract authentication token from request (header or dedicated field)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If no token present, return authentication required error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate JWT token signature and expiration using jwt library</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Extract user identity and roles/permissions from token claims</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Check if user has permission to invoke the requested method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If authorized, add user context to request and return None (success)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: If unauthorized, return error message with appropriate error code</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_jwt_token</span><span style=\"color:#E1E4E8\">(self, token: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate JWT token and return claims dict, or None if invalid.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Use jwt.decode() to validate token signature and expiration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check standard claims (exp, iat, etc.) for validity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return decoded claims dict if token is valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return None if token is expired, malformed, or signature invalid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Log authentication failures for security monitoring</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _check_method_permission</span><span style=\"color:#E1E4E8\">(self, user_claims: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               method_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if authenticated user has permission to call method.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract user roles/permissions from JWT claims</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Query permission store for required permissions for method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check if user has all required permissions (intersection check)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return True if authorized, False if missing permissions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"circuit-breaker-implementation\">Circuit Breaker Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># rpc/extensions/resilience/circuit_breaker.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Callable, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> collections </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> deque</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CircuitState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CLOSED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"closed\"</span><span style=\"color:#6A737D\">      # Normal operation</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OPEN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"open\"</span><span style=\"color:#6A737D\">          # Rejecting requests</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HALF_OPEN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"half_open\"</span><span style=\"color:#6A737D\">  # Testing recovery</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CircuitBreaker</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Circuit breaker to prevent cascading failures in RPC calls.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, failure_threshold: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#E1E4E8\">, window_size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 timeout_seconds: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 60.0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize circuit state to CLOSED (normal operation)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Set up failure tracking with sliding window (use deque)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Store configuration (failure threshold, window size, timeout)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Initialize threading primitives for concurrent access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Set up timing variables for OPEN -> HALF_OPEN transitions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> call</span><span style=\"color:#E1E4E8\">(self, func: Callable, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute function with circuit breaker protection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check current circuit state and handle OPEN state (immediate failure)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If HALF_OPEN, allow only single test request through</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If CLOSED or test request, execute function and capture result/exception</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Record success or failure in sliding window</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Update circuit state based on recent failure rate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return result or raise exception as appropriate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _update_circuit_state</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Update circuit state based on recent failure rate.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate current failure rate from sliding window</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If CLOSED and failure rate exceeds threshold, transition to OPEN</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If OPEN and timeout expired, transition to HALF_OPEN</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If HALF_OPEN and test succeeded, transition to CLOSED</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If HALF_OPEN and test failed, return to OPEN with new timeout</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _record_result</span><span style=\"color:#E1E4E8\">(self, success: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record success or failure in sliding window.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Acquire lock for thread-safe access to sliding window</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add success/failure boolean to sliding window deque</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If window exceeds max size, remove oldest entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Update failure rate calculation based on new window contents</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints-for-extensions\">Milestone Checkpoints for Extensions</h4>\n<p><strong>Connection Pool Checkpoint:</strong>\nAfter implementing connection pooling:</p>\n<ol>\n<li>Run <code>python -m pytest tests/test_extensions/test_connection_pool.py</code> - all tests should pass</li>\n<li>Start test server with <code>python examples/pooled_server_example.py</code></li>\n<li>Run concurrent client test: <code>python examples/concurrent_client_test.py</code></li>\n<li>Expected behavior: 100+ concurrent RPC calls complete in under 5 seconds</li>\n<li>Check that connection count stays reasonable (under max_pool_size)</li>\n</ol>\n<p><strong>Async Client Checkpoint:</strong>\nAfter implementing async support:</p>\n<ol>\n<li>Run <code>python -m pytest tests/test_extensions/test_async_client.py</code></li>\n<li>Start server and run: <code>python examples/async_client_example.py</code></li>\n<li>Expected behavior: 1000 concurrent async calls complete in under 3 seconds</li>\n<li>Memory usage should remain stable (no memory leaks from futures)</li>\n</ol>\n<p><strong>Authentication Checkpoint:</strong>\nAfter implementing auth middleware:</p>\n<ol>\n<li>Start secure server: <code>python examples/secure_server_example.py</code></li>\n<li>Test with valid token: Should allow method calls</li>\n<li>Test without token: Should return &quot;Authentication required&quot; error</li>\n<li>Test with expired token: Should return &quot;Token expired&quot; error</li>\n<li>Test unauthorized method: Should return &quot;Insufficient permissions&quot; error</li>\n</ol>\n<p><strong>Circuit Breaker Checkpoint:</strong>\nAfter implementing circuit breaker:</p>\n<ol>\n<li>Start unreliable server (randomly fails 60% of requests)</li>\n<li>Run client with circuit breaker enabled</li>\n<li>Expected behavior: Initial requests fail, circuit opens, subsequent requests fail fast</li>\n<li>After timeout, circuit allows test request through</li>\n<li>If server recovers, circuit closes and normal operation resumes</li>\n</ol>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all milestones - provides essential terminology and concepts used throughout message protocol (Milestone 1), server implementation (Milestone 2), and client implementation (Milestone 3)</p>\n</blockquote>\n<p>This glossary defines the key terms, concepts, and technical vocabulary used throughout the RPC Framework design document. Understanding these terms is essential for implementing the framework successfully and communicating about RPC systems effectively.</p>\n<h3 id=\"mental-model-the-technical-dictionary\">Mental Model: The Technical Dictionary</h3>\n<p>Think of this glossary as a specialized technical dictionary for our RPC framework domain. Just as a medical dictionary defines terms like &quot;hypertension&quot; and &quot;myocardial infarction&quot; that have precise meanings in healthcare, this glossary defines terms like &quot;method proxying&quot; and &quot;connection pooling&quot; that have specific meanings in distributed systems.</p>\n<p>Each term represents a concept, pattern, or technique that solves a particular problem in remote procedure calls. When we say &quot;request correlation,&quot; we&#39;re referring to a specific mechanism for matching responses to their originating requests - not just any kind of matching or correlation. This precision in terminology helps developers communicate clearly about complex distributed system behaviors.</p>\n<h3 id=\"core-rpc-concepts\">Core RPC Concepts</h3>\n<p>The foundational concepts that define how remote procedure calls work and what problems they solve.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>JSON-RPC</strong></td>\n<td>Lightweight remote procedure call protocol using JSON for message encoding. Defines standard request/response message formats with method names, parameters, and unique identifiers.</td>\n<td>&quot;Our framework implements JSON-RPC 2.0 specification for cross-language compatibility.&quot;</td>\n</tr>\n<tr>\n<td><strong>Remote Procedure Call (RPC)</strong></td>\n<td>Programming paradigm where a program can call functions or methods that execute on a different machine or process, appearing as if they were local function calls.</td>\n<td>&quot;The client uses RPC to invoke the <code>calculate_taxes</code> method running on the accounting server.&quot;</td>\n</tr>\n<tr>\n<td><strong>Method Proxying</strong></td>\n<td>Technique where a client-side proxy object converts method calls into RPC requests transparently, making remote methods appear as local methods to calling code.</td>\n<td>&quot;The <code>RPCProxy</code> class implements method proxying through Python&#39;s <code>__getattr__</code> mechanism.&quot;</td>\n</tr>\n<tr>\n<td><strong>Request ID</strong></td>\n<td>Unique identifier assigned to each RPC request that allows correlation between requests and their corresponding responses in async or concurrent scenarios.</td>\n<td>&quot;Request ID &#39;req_12345&#39; ensures the client matches the tax calculation response to the correct calling thread.&quot;</td>\n</tr>\n<tr>\n<td><strong>Wire Format</strong></td>\n<td>The specific serialized message format sent over the network between RPC client and server, including both message content and any framing or delimiting information.</td>\n<td>&quot;Our wire format uses 4-byte length prefix followed by JSON-encoded message body.&quot;</td>\n</tr>\n<tr>\n<td><strong>Method Registry</strong></td>\n<td>Server-side mapping that associates function names (strings) with callable handler functions, enabling request dispatch to the appropriate implementation.</td>\n<td>&quot;The server&#39;s method registry maps &#39;user.create&#39; to the <code>create_user_handler</code> function.&quot;</td>\n</tr>\n<tr>\n<td><strong>Request Dispatch</strong></td>\n<td>Server process of receiving an RPC request, looking up the requested method in the registry, and routing the call to the appropriate handler function.</td>\n<td>&quot;Request dispatch failed because &#39;calculate_orbit&#39; method was not found in the registry.&quot;</td>\n</tr>\n</tbody></table>\n<h3 id=\"network-communication-terms\">Network Communication Terms</h3>\n<p>Technical vocabulary for the underlying network protocols and communication patterns that enable RPC functionality.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Message Framing</strong></td>\n<td>Technique for delimiting individual messages within a continuous byte stream, solving the problem of where one message ends and another begins.</td>\n<td>&quot;TCP provides a byte stream, so we need message framing to identify complete RPC messages.&quot;</td>\n</tr>\n<tr>\n<td><strong>Length Prefix</strong></td>\n<td>Message framing approach where each message begins with a fixed-size header indicating the total message size, allowing the receiver to read exactly the right number of bytes.</td>\n<td>&quot;Our 4-byte length prefix supports messages up to 4GB, though we limit them to 1MB for safety.&quot;</td>\n</tr>\n<tr>\n<td><strong>Connection Management</strong></td>\n<td>Strategies for handling TCP socket lifecycle including establishment, reuse, health checking, and graceful cleanup to optimize performance and reliability.</td>\n<td>&quot;Proper connection management prevents socket descriptor leaks and reduces connection setup overhead.&quot;</td>\n</tr>\n<tr>\n<td><strong>Connection Reuse</strong></td>\n<td>Performance optimization where a single persistent TCP connection carries multiple RPC requests/responses instead of creating new connections for each call.</td>\n<td>&quot;Connection reuse reduced average call latency from 15ms to 3ms by eliminating TCP handshake overhead.&quot;</td>\n</tr>\n<tr>\n<td><strong>Connection Pooling</strong></td>\n<td>Advanced connection management pattern maintaining a pool of reusable connections to a server, allowing concurrent requests while limiting total connection count.</td>\n<td>&quot;The connection pool maintains 5-20 connections to the database server based on current load.&quot;</td>\n</tr>\n<tr>\n<td><strong>Thread-per-Connection</strong></td>\n<td>Server threading model where each client connection is handled by a dedicated thread, providing isolation and simplicity at the cost of memory overhead.</td>\n<td>&quot;Thread-per-connection model supports 1000 concurrent clients with 1000 server threads.&quot;</td>\n</tr>\n<tr>\n<td><strong>Send All</strong></td>\n<td>Network programming pattern ensuring complete message transmission by repeatedly calling send() until all bytes are transmitted, handling partial sends gracefully.</td>\n<td>&quot;The <code>send_all</code> function prevents message truncation when TCP buffers are full.&quot;</td>\n</tr>\n<tr>\n<td><strong>Receive All</strong></td>\n<td>Network programming pattern ensuring complete message reception by repeatedly calling receive() until the expected number of bytes have been read.</td>\n<td>&quot;The <code>recv_all</code> function blocks until the complete 1024-byte message is received.&quot;</td>\n</tr>\n</tbody></table>\n<h3 id=\"concurrency-and-state-management\">Concurrency and State Management</h3>\n<p>Terms related to handling multiple simultaneous RPC calls and managing shared state safely across threads.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Request Tracking</strong></td>\n<td>Mechanism for correlating responses with their originating requests, typically using request IDs and pending request data structures.</td>\n<td>&quot;Request tracking prevents responses from being delivered to the wrong calling thread.&quot;</td>\n</tr>\n<tr>\n<td><strong>Response Correlation</strong></td>\n<td>Process of matching incoming responses to pending requests using request IDs, enabling proper delivery in concurrent environments.</td>\n<td>&quot;Response correlation failed when request ID &#39;abc123&#39; was not found in pending requests map.&quot;</td>\n</tr>\n<tr>\n<td><strong>Timeout Handling</strong></td>\n<td>Strategy for preventing indefinite blocking when remote servers are unresponsive, including timeout detection and appropriate error response generation.</td>\n<td>&quot;Timeout handling raises <code>RPCTimeoutError</code> when no response arrives within 30 seconds.&quot;</td>\n</tr>\n<tr>\n<td><strong>Pending Requests</strong></td>\n<td>Client-side data structure tracking active RPC calls that are waiting for responses, typically mapping request IDs to calling thread information.</td>\n<td>&quot;The pending requests dictionary grew to 500 entries during the load test spike.&quot;</td>\n</tr>\n<tr>\n<td><strong>Connection Health Check</strong></td>\n<td>Periodic validation that pooled or persistent connections are still usable, detecting dead connections before they cause RPC failures.</td>\n<td>&quot;Connection health checks detected 3 stale connections and removed them from the pool.&quot;</td>\n</tr>\n<tr>\n<td><strong>Race Condition</strong></td>\n<td>Timing-dependent bug in concurrent code where the outcome depends on the relative timing of events, often causing intermittent failures.</td>\n<td>&quot;The race condition occurred when two threads modified the pending requests map simultaneously.&quot;</td>\n</tr>\n<tr>\n<td><strong>Deadlock</strong></td>\n<td>Circular waiting condition where two or more threads are blocked forever, each waiting for resources held by the others.</td>\n<td>&quot;Deadlock happened when thread A held the registry lock while waiting for connection lock held by thread B.&quot;</td>\n</tr>\n</tbody></table>\n<h3 id=\"error-handling-and-reliability\">Error Handling and Reliability</h3>\n<p>Terminology for managing failures, errors, and edge cases in distributed RPC systems.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Error Propagation</strong></td>\n<td>Mechanism for transmitting error information from the server back to the client, including error codes, messages, and diagnostic data.</td>\n<td>&quot;Error propagation ensures that database connection failures are reported to the calling client.&quot;</td>\n</tr>\n<tr>\n<td><strong>Structured Errors</strong></td>\n<td>Error objects with consistent fields and diagnostic information, making them easier to handle programmatically and debug effectively.</td>\n<td>&quot;Structured errors include error codes, human-readable messages, and optional diagnostic data.&quot;</td>\n</tr>\n<tr>\n<td><strong>Error Categorization</strong></td>\n<td>Classification system for different types of errors (network, serialization, application logic) that enables appropriate handling strategies for each category.</td>\n<td>&quot;Error categorization routes network errors to retry logic and application errors to user feedback.&quot;</td>\n</tr>\n<tr>\n<td><strong>Graceful Degradation</strong></td>\n<td>System design principle where the system continues operating with reduced functionality during partial failures rather than complete shutdown.</td>\n<td>&quot;Graceful degradation allows read-only operations to continue when the write database is unavailable.&quot;</td>\n</tr>\n<tr>\n<td><strong>Exponential Backoff</strong></td>\n<td>Retry delay strategy that increases the wait time between retry attempts exponentially, preventing overwhelming of failing services.</td>\n<td>&quot;Exponential backoff waits 1s, 2s, 4s, 8s between retry attempts for the failing payment service.&quot;</td>\n</tr>\n<tr>\n<td><strong>Retry Logic</strong></td>\n<td>Automatic re-execution strategy for failed operations, typically with limits on attempt count and delays between attempts.</td>\n<td>&quot;Retry logic attempts the account lookup operation up to 3 times with exponential backoff.&quot;</td>\n</tr>\n<tr>\n<td><strong>Circuit Breaker</strong></td>\n<td>Failure prevention pattern that stops making calls to an unresponsive service for a period, allowing it time to recover.</td>\n<td>&quot;The circuit breaker opened after 10 consecutive failures to the recommendation service.&quot;</td>\n</tr>\n<tr>\n<td><strong>Transport Error</strong></td>\n<td>Network-level error related to TCP connections, socket operations, or message transmission, distinct from application-level errors.</td>\n<td>&quot;Transport error indicates the connection was reset by peer during message transmission.&quot;</td>\n</tr>\n<tr>\n<td><strong>Serialization Error</strong></td>\n<td>Error occurring during conversion between objects and their wire format representation, often due to unsupported data types or encoding issues.</td>\n<td>&quot;Serialization error occurred when trying to encode the <code>datetime</code> object to JSON.&quot;</td>\n</tr>\n<tr>\n<td><strong>Protocol Error</strong></td>\n<td>Error in message format or structure that violates the RPC protocol specification, making the message unparseable or invalid.</td>\n<td>&quot;Protocol error: request message missing required &#39;method&#39; field in JSON-RPC format.&quot;</td>\n</tr>\n</tbody></table>\n<h3 id=\"testing-and-quality-assurance\">Testing and Quality Assurance</h3>\n<p>Terms related to validating RPC system behavior and ensuring reliability through testing strategies.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Integration Testing</strong></td>\n<td>Testing approach that validates interactions between multiple components under realistic conditions, ensuring they work together correctly.</td>\n<td>&quot;Integration testing revealed that client timeouts were too short for database-heavy operations.&quot;</td>\n</tr>\n<tr>\n<td><strong>End-to-End Testing</strong></td>\n<td>Comprehensive testing that validates complete workflows from client method invocation through network transport to server execution and response.</td>\n<td>&quot;End-to-end testing confirmed that the entire user authentication flow works across service boundaries.&quot;</td>\n</tr>\n<tr>\n<td><strong>Load Testing</strong></td>\n<td>Performance validation technique that measures system behavior under expected traffic patterns and user loads.</td>\n<td>&quot;Load testing showed the server handles 1000 concurrent clients before response times degrade.&quot;</td>\n</tr>\n<tr>\n<td><strong>Stress Testing</strong></td>\n<td>Testing approach that pushes the system beyond normal operating conditions to identify breaking points and failure modes.</td>\n<td>&quot;Stress testing with 10,000 concurrent connections revealed memory leaks in connection handling.&quot;</td>\n</tr>\n<tr>\n<td><strong>Checkpoint Verification</strong></td>\n<td>Testing milestone that validates specific behaviors after implementing each component, providing incremental validation during development.</td>\n<td>&quot;Checkpoint verification confirmed that message serialization works before implementing network transport.&quot;</td>\n</tr>\n<tr>\n<td><strong>Test Double</strong></td>\n<td>Testing pattern using fake implementations of dependencies (mocks, stubs, fakes) to isolate components under test.</td>\n<td>&quot;The test double simulates network failures to verify client retry behavior.&quot;</td>\n</tr>\n</tbody></table>\n<h3 id=\"performance-and-optimization\">Performance and Optimization</h3>\n<p>Technical vocabulary related to optimizing RPC system performance and resource utilization.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Latency</strong></td>\n<td>Time delay between initiating an RPC call and receiving the response, including network transmission and server processing time.</td>\n<td>&quot;RPC latency increased from 5ms to 50ms when the database server was moved to a different datacenter.&quot;</td>\n</tr>\n<tr>\n<td><strong>Throughput</strong></td>\n<td>Number of RPC requests the system can process per unit time, typically measured in requests per second.</td>\n<td>&quot;System throughput peaked at 10,000 requests per second during the benchmark test.&quot;</td>\n</tr>\n<tr>\n<td><strong>Connection Overhead</strong></td>\n<td>Resource costs associated with establishing and maintaining TCP connections, including memory usage and setup time.</td>\n<td>&quot;Connection overhead was reduced by 60% when we switched from per-request to persistent connections.&quot;</td>\n</tr>\n<tr>\n<td><strong>Serialization Overhead</strong></td>\n<td>Performance cost of converting objects to and from wire format, including CPU time and memory allocation.</td>\n<td>&quot;JSON serialization overhead accounts for 20% of total RPC call time in our profiling data.&quot;</td>\n</tr>\n<tr>\n<td><strong>Binary Serialization</strong></td>\n<td>Efficient message encoding using binary formats like MessagePack or Protocol Buffers instead of text-based formats like JSON.</td>\n<td>&quot;Binary serialization reduced message size by 40% and encoding time by 60%.&quot;</td>\n</tr>\n<tr>\n<td><strong>Async Support</strong></td>\n<td>Non-blocking RPC implementation using asynchronous programming patterns, allowing clients to perform other work while waiting for responses.</td>\n<td>&quot;Async support enables the web server to handle 1000 concurrent RPC calls without blocking threads.&quot;</td>\n</tr>\n<tr>\n<td><strong>Connection Multiplexing</strong></td>\n<td>Advanced technique allowing multiple concurrent RPC calls over a single TCP connection, improving efficiency and reducing connection overhead.</td>\n<td>&quot;Connection multiplexing allows 100 concurrent requests over just 5 TCP connections.&quot;</td>\n</tr>\n</tbody></table>\n<h3 id=\"security-and-authentication\">Security and Authentication</h3>\n<p>Terms related to securing RPC communications and controlling access to remote methods.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>JWT Authentication</strong></td>\n<td>Stateless authentication mechanism using JSON Web Tokens that embed user claims and permissions within the token itself.</td>\n<td>&quot;JWT authentication eliminates the need for server-side session storage in our RPC service.&quot;</td>\n</tr>\n<tr>\n<td><strong>Method-Level Authorization</strong></td>\n<td>Fine-grained access control system that validates permissions for individual RPC methods based on user credentials.</td>\n<td>&quot;Method-level authorization prevents regular users from calling administrative methods.&quot;</td>\n</tr>\n<tr>\n<td><strong>TLS Transport Security</strong></td>\n<td>Encryption of network traffic using Transport Layer Security protocol, protecting RPC messages from eavesdropping and tampering.</td>\n<td>&quot;TLS transport security ensures that sensitive financial data is encrypted during RPC calls.&quot;</td>\n</tr>\n<tr>\n<td><strong>Token Validation</strong></td>\n<td>Process of verifying JWT tokens including signature validation, expiration checking, and claims verification.</td>\n<td>&quot;Token validation rejected the request because the JWT had expired 5 minutes ago.&quot;</td>\n</tr>\n<tr>\n<td><strong>Permission Store</strong></td>\n<td>Repository mapping users to their allowed permissions and methods to their required permissions, enabling authorization decisions.</td>\n<td>&quot;The permission store indicates that &#39;admin&#39; role can call &#39;user.delete&#39; but &#39;user&#39; role cannot.&quot;</td>\n</tr>\n</tbody></table>\n<h3 id=\"development-and-implementation\">Development and Implementation</h3>\n<p>Terms related to the practical aspects of building and organizing RPC framework code.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Receptionist Pattern</strong></td>\n<td>Design pattern where the server acts as a receptionist, routing incoming requests to the appropriate department (handler function).</td>\n<td>&quot;The receptionist pattern centralizes request routing logic in the server&#39;s main dispatch method.&quot;</td>\n</tr>\n<tr>\n<td><strong>Secretary Pattern</strong></td>\n<td>Design pattern where the client acts as a secretary, handling communication complexity on behalf of the calling code.</td>\n<td>&quot;The secretary pattern hides network failures and retries from application code making RPC calls.&quot;</td>\n</tr>\n<tr>\n<td><strong>Method Cache</strong></td>\n<td>Performance optimization storing references to proxy methods to avoid recreating them on each attribute access.</td>\n<td>&quot;The method cache prevents creating new proxy functions every time <code>client.remote_method</code> is accessed.&quot;</td>\n</tr>\n<tr>\n<td><strong>Proxy Object</strong></td>\n<td>Client-side object that intercepts method calls and converts them into RPC requests, providing transparent remote method invocation.</td>\n<td>&quot;The proxy object makes calling <code>remote.calculate(x, y)</code> look identical to local function calls.&quot;</td>\n</tr>\n<tr>\n<td><strong>Handler Registration</strong></td>\n<td>Process of associating function names with callable implementations in the server&#39;s method registry.</td>\n<td>&quot;Handler registration maps the string &#39;math.add&#39; to the <code>addition_handler</code> function.&quot;</td>\n</tr>\n<tr>\n<td><strong>Request Dispatcher</strong></td>\n<td>Server component responsible for parsing incoming requests and invoking the appropriate registered handler functions.</td>\n<td>&quot;The request dispatcher validates the message format before looking up the requested method.&quot;</td>\n</tr>\n<tr>\n<td><strong>Response Builder</strong></td>\n<td>Utility component that constructs properly formatted RPC response messages with results, errors, and correlation IDs.</td>\n<td>&quot;The response builder ensures all success responses include the original request ID.&quot;</td>\n</tr>\n</tbody></table>\n<h3 id=\"debugging-and-diagnostics\">Debugging and Diagnostics</h3>\n<p>Terms for troubleshooting RPC systems and understanding their runtime behavior.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Request Tracing</strong></td>\n<td>Diagnostic technique that follows a request through all stages of processing, providing visibility into timing and decision points.</td>\n<td>&quot;Request tracing showed the tax calculation spent 2 seconds waiting for the database query.&quot;</td>\n</tr>\n<tr>\n<td><strong>Connection Diagnostics</strong></td>\n<td>Monitoring and debugging information about network connections including state, byte counts, and error history.</td>\n<td>&quot;Connection diagnostics revealed that 30% of connections were being closed by network timeouts.&quot;</td>\n</tr>\n<tr>\n<td><strong>Latency Tracking</strong></td>\n<td>Performance monitoring that measures and records timing information for RPC calls, enabling identification of slow operations.</td>\n<td>&quot;Latency tracking identified that user lookup calls take 500ms on average during peak hours.&quot;</td>\n</tr>\n<tr>\n<td><strong>Error Correlation</strong></td>\n<td>Diagnostic technique for linking related errors across client and server logs using request IDs and timestamps.</td>\n<td>&quot;Error correlation matched the client timeout with the server&#39;s database deadlock exception.&quot;</td>\n</tr>\n<tr>\n<td><strong>Socket State Monitoring</strong></td>\n<td>Tracking the current state and health of TCP sockets used for RPC communication.</td>\n<td>&quot;Socket state monitoring detected 15 connections in CLOSE_WAIT state, indicating a resource leak.&quot;</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical guidance for implementing the concepts defined in this glossary using Python.</p>\n<h4 id=\"core-implementation-classes\">Core Implementation Classes</h4>\n<p>The following table shows the main classes you&#39;ll implement and their essential attributes:</p>\n<table>\n<thead>\n<tr>\n<th>Class Name</th>\n<th>Key Attributes</th>\n<th>Primary Responsibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>RPCServer</code></td>\n<td><code>host</code>, <code>port</code>, <code>registry</code>, <code>server_socket</code>, <code>running</code></td>\n<td>Accept connections and dispatch requests</td>\n</tr>\n<tr>\n<td><code>RPCClient</code></td>\n<td><code>host</code>, <code>port</code>, <code>default_timeout</code>, <code>_socket</code>, <code>_pending_requests</code></td>\n<td>Send requests and manage responses</td>\n</tr>\n<tr>\n<td><code>MethodRegistry</code></td>\n<td><code>methods</code>, <code>lock</code>, <code>descriptions</code></td>\n<td>Store and lookup registered methods</td>\n</tr>\n<tr>\n<td><code>RPCProxy</code></td>\n<td><code>_client</code>, <code>_timeout</code>, <code>_method_cache</code></td>\n<td>Provide transparent method call interface</td>\n</tr>\n<tr>\n<td><code>ConnectionPool</code></td>\n<td><code>host</code>, <code>port</code>, <code>max_size</code>, <code>connections</code>, <code>pool_lock</code></td>\n<td>Manage reusable connections efficiently</td>\n</tr>\n</tbody></table>\n<h4 id=\"error-hierarchy-implementation\">Error Hierarchy Implementation</h4>\n<p>Create a comprehensive error class hierarchy to support structured error handling:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all RPC-related errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, error_code: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, error_data: </span><span style=\"color:#79B8FF\">any</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.error_code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> error_code</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.error_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> error_data</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCProtocolError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Error in message format or protocol compliance.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, raw_data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, parse_stage: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#79B8FF\">PARSE_ERROR</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.raw_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> raw_data</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parse_stage </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parse_stage</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCTransportError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Network-level communication error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, host: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, operation: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#79B8FF\">TRANSPORT_ERROR</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.host </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> host</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> port</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.operation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> operation</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCTimeoutError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Request timeout error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, timeout_seconds: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">, elapsed_seconds: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#79B8FF\">TIMEOUT_ERROR</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.timeout_seconds </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timeout_seconds</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.elapsed_seconds </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> elapsed_seconds</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RPCMethodError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RPCError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Error during method execution.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, method_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, params: </span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">, execution_phase: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#79B8FF\">INTERNAL_ERROR</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.method_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> method_name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.params </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> params</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.execution_phase </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> execution_phase</span></span></code></pre></div>\n\n<h4 id=\"standard-error-codes\">Standard Error Codes</h4>\n<p>Define error codes following JSON-RPC specification:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorCode</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PARSE_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32700</span><span style=\"color:#6A737D\">      # Invalid JSON received</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVALID_REQUEST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32600</span><span style=\"color:#6A737D\">   # JSON is not a valid request object</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    METHOD_NOT_FOUND</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32601</span><span style=\"color:#6A737D\">  # Method does not exist</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVALID_PARAMS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32602</span><span style=\"color:#6A737D\">    # Invalid method parameters</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INTERNAL_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32603</span><span style=\"color:#6A737D\">    # Internal JSON-RPC error</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TRANSPORT_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32000</span><span style=\"color:#6A737D\">   # Network/transport error</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TIMEOUT_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32001</span><span style=\"color:#6A737D\">     # Request timeout</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CONNECTION_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">32002</span><span style=\"color:#6A737D\">  # Connection failed</span></span></code></pre></div>\n\n<h4 id=\"message-utilities\">Message Utilities</h4>\n<p>Essential functions for message handling:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> struct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> socket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> generate_request_id</span><span style=\"color:#E1E4E8\">() -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Generate unique request identifier using UUID4.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(uuid.uuid4())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_request_message</span><span style=\"color:#E1E4E8\">(method: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, params: </span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">, request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create JSON-RPC 2.0 request message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"jsonrpc\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2.0\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"method\"</span><span style=\"color:#E1E4E8\">: method,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"params\"</span><span style=\"color:#E1E4E8\">: params,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"id\"</span><span style=\"color:#E1E4E8\">: request_id</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_response_message</span><span style=\"color:#E1E4E8\">(request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, result: Any) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create JSON-RPC 2.0 success response message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"jsonrpc\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2.0\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"result\"</span><span style=\"color:#E1E4E8\">: result,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"id\"</span><span style=\"color:#E1E4E8\">: request_id</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_error_message</span><span style=\"color:#E1E4E8\">(request_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, code: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, data: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create JSON-RPC 2.0 error response message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    error_obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"code\"</span><span style=\"color:#E1E4E8\">: code, </span><span style=\"color:#9ECBFF\">\"message\"</span><span style=\"color:#E1E4E8\">: message}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> data </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        error_obj[</span><span style=\"color:#9ECBFF\">\"data\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"jsonrpc\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2.0\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"error\"</span><span style=\"color:#E1E4E8\">: error_obj,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"id\"</span><span style=\"color:#E1E4E8\">: request_id</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> serialize_message</span><span style=\"color:#E1E4E8\">(message: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert message dictionary to JSON bytes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    json_str </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.dumps(message, </span><span style=\"color:#FFAB70\">separators</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">','</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">':'</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> json_str.encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> deserialize_message</span><span style=\"color:#E1E4E8\">(data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parse JSON bytes to message dictionary.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        json_str </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data.decode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> json.loads(json_str)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">UnicodeDecodeError</span><span style=\"color:#E1E4E8\">, json.JSONDecodeError) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> RPCProtocolError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Failed to deserialize message: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, data, </span><span style=\"color:#9ECBFF\">\"json_parsing\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"network-helper-functions\">Network Helper Functions</h4>\n<p>Low-level socket operations with proper error handling:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> select</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MAX_MESSAGE_SIZE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1048576</span><span style=\"color:#6A737D\">  # 1MB maximum message size</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> send_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, data: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Send complete message handling partial sends.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sock.settimeout(timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_sent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    total_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(data)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> bytes_sent </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> total_bytes:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> timeout:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> RPCTimeoutError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Send timeout after </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">timeout</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">s\"</span><span style=\"color:#E1E4E8\">, timeout, time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sent </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sock.send(data[bytes_sent:])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> sent </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#9ECBFF\">\"Socket connection broken during send\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                      sock.getpeername()[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], sock.getpeername()[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"send\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            bytes_sent </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> sent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> socket.error </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Send failed: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  sock.getpeername()[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], sock.getpeername()[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"send\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> recv_all</span><span style=\"color:#E1E4E8\">(sock: socket.socket, size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Receive exact byte count with timeout.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sock.settimeout(timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    chunks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_received </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> bytes_received </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> size:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> timeout:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> RPCTimeoutError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Receive timeout after </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">timeout</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">s\"</span><span style=\"color:#E1E4E8\">, timeout, time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sock.recv(</span><span style=\"color:#79B8FF\">min</span><span style=\"color:#E1E4E8\">(size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> bytes_received, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> chunk:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#9ECBFF\">\"Socket connection closed during receive\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                      sock.getpeername()[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], sock.getpeername()[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"recv\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            chunks.append(chunk)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            bytes_received </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(chunk)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> socket.error </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> RPCTransportError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Receive failed: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  sock.getpeername()[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], sock.getpeername()[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"recv\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">.join(chunks)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> send_message</span><span style=\"color:#E1E4E8\">(sock: socket.socket, message_bytes: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Send length-prefixed message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(message_bytes) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> MAX_MESSAGE_SIZE</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> RPCProtocolError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Message too large: </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(message_bytes)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              message_bytes, </span><span style=\"color:#9ECBFF\">\"size_check\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Send 4-byte length prefix in network byte order</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    length_prefix </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> struct.pack(</span><span style=\"color:#9ECBFF\">'!I'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(message_bytes))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    send_all(sock, length_prefix, timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    send_all(sock, message_bytes, timeout)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> recv_message</span><span style=\"color:#E1E4E8\">(sock: socket.socket, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Receive length-prefixed message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Read 4-byte length prefix</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    length_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> recv_all(sock, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    message_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> struct.unpack(</span><span style=\"color:#9ECBFF\">'!I'</span><span style=\"color:#E1E4E8\">, length_data)[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> message_length </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> MAX_MESSAGE_SIZE</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> RPCProtocolError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Message too large: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">message_length</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              length_data, </span><span style=\"color:#9ECBFF\">\"length_check\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Read message body</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> recv_all(sock, message_length, timeout)</span></span></code></pre></div>\n\n<h4 id=\"file-structure-recommendation\">File Structure Recommendation</h4>\n<p>Organize your RPC framework code using this structure:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>rpc_framework/\n├── __init__.py                 # Package exports\n├── protocol.py                 # Message formats and serialization\n├── server.py                   # RPCServer implementation\n├── client.py                   # RPCClient and RPCProxy implementation\n├── registry.py                 # MethodRegistry implementation\n├── errors.py                   # Error class hierarchy\n├── transport.py                # Network helper functions\n├── utils.py                    # Utility functions\n└── tests/\n    ├── __init__.py\n    ├── test_protocol.py        # Message protocol tests\n    ├── test_server.py          # Server component tests\n    ├── test_client.py          # Client component tests\n    └── test_integration.py     # End-to-end tests</code></pre></div>\n\n<p>This structure separates concerns cleanly while keeping related functionality together. Each module has a clear responsibility and can be developed and tested independently.</p>\n","toc":[{"level":1,"text":"RPC Framework: Design Document","id":"rpc-framework-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: The Postal Service Analogy","id":"mental-model-the-postal-service-analogy"},{"level":3,"text":"Existing RPC Approaches","id":"existing-rpc-approaches"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Mental Model: The Swiss Army Knife vs. The Hammer","id":"mental-model-the-swiss-army-knife-vs-the-hammer"},{"level":3,"text":"Functional Goals","id":"functional-goals"},{"level":3,"text":"Non-Goals","id":"non-goals"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Overview","id":"component-overview"},{"level":4,"text":"Message Protocol Component","id":"message-protocol-component"},{"level":4,"text":"Server Component","id":"server-component"},{"level":4,"text":"Client Component","id":"client-component"},{"level":3,"text":"Component Interaction Patterns","id":"component-interaction-patterns"},{"level":3,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Module Responsibilities","id":"core-module-responsibilities"},{"level":4,"text":"Development Workflow","id":"development-workflow"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Project Structure Setup","id":"project-structure-setup"},{"level":4,"text":"Socket Utilities Infrastructure","id":"socket-utilities-infrastructure"},{"level":4,"text":"Component Implementation Skeletons","id":"component-implementation-skeletons"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Python-Specific Implementation Hints","id":"python-specific-implementation-hints"},{"level":2,"text":"Message Protocol Design","id":"message-protocol-design"},{"level":3,"text":"Mental Model: The International Mail System","id":"mental-model-the-international-mail-system"},{"level":3,"text":"Message Formats","id":"message-formats"},{"level":4,"text":"Request Message Structure","id":"request-message-structure"},{"level":4,"text":"Response Message Structure","id":"response-message-structure"},{"level":4,"text":"Error Message Structure","id":"error-message-structure"},{"level":3,"text":"Serialization Strategy","id":"serialization-strategy"},{"level":4,"text":"JSON Encoding Decisions","id":"json-encoding-decisions"},{"level":4,"text":"Message Framing Protocol","id":"message-framing-protocol"},{"level":4,"text":"Parameter Type Handling","id":"parameter-type-handling"},{"level":4,"text":"Serialization Error Handling","id":"serialization-error-handling"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Core Protocol Implementation","id":"core-protocol-implementation"},{"level":4,"text":"Message Validation Logic","id":"message-validation-logic"},{"level":4,"text":"Socket Helper Utilities","id":"socket-helper-utilities"},{"level":4,"text":"Parameter Type Serialization","id":"parameter-type-serialization"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Common Pitfalls and Debugging","id":"common-pitfalls-and-debugging"},{"level":2,"text":"Server Component Design","id":"server-component-design"},{"level":3,"text":"Mental Model: The Receptionist Pattern","id":"mental-model-the-receptionist-pattern"},{"level":3,"text":"Method Registry","id":"method-registry"},{"level":3,"text":"Request Dispatch Algorithm","id":"request-dispatch-algorithm"},{"level":3,"text":"Architecture Decision Records","id":"architecture-decision-records"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Client Component Design","id":"client-component-design"},{"level":3,"text":"Mental Model: The Secretary Pattern","id":"mental-model-the-secretary-pattern"},{"level":3,"text":"Method Proxying","id":"method-proxying"},{"level":3,"text":"Connection Management","id":"connection-management"},{"level":3,"text":"Timeout and ID Tracking","id":"timeout-and-id-tracking"},{"level":3,"text":"Architecture Decision Records","id":"architecture-decision-records"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Mental Model: The Phone Call Choreography","id":"mental-model-the-phone-call-choreography"},{"level":2,"text":"RPC Call Sequence","id":"rpc-call-sequence"},{"level":3,"text":"Step-by-Step Call Flow","id":"step-by-step-call-flow"},{"level":4,"text":"Detailed Sequence Narrative","id":"detailed-sequence-narrative"},{"level":3,"text":"Timing and Concurrency Considerations","id":"timing-and-concurrency-considerations"},{"level":2,"text":"Error Flow","id":"error-flow"},{"level":3,"text":"Error Categories and Propagation","id":"error-categories-and-propagation"},{"level":4,"text":"Network Error Flow","id":"network-error-flow"},{"level":4,"text":"Protocol Error Flow","id":"protocol-error-flow"},{"level":4,"text":"Method Error Flow","id":"method-error-flow"},{"level":4,"text":"Execution Error Flow","id":"execution-error-flow"},{"level":3,"text":"Error Response Message Format","id":"error-response-message-format"},{"level":3,"text":"Timeout Handling","id":"timeout-handling"},{"level":3,"text":"Error Recovery Strategies","id":"error-recovery-strategies"},{"level":3,"text":"Common Error Scenarios","id":"common-error-scenarios"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Error Handling Skeleton","id":"core-error-handling-skeleton"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Mental Model: The Emergency Response System","id":"mental-model-the-emergency-response-system"},{"level":3,"text":"Error Categories","id":"error-categories"},{"level":3,"text":"Network Failure Handling","id":"network-failure-handling"},{"level":3,"text":"Serialization Error Handling","id":"serialization-error-handling"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Core Error Classes","id":"core-error-classes"},{"level":4,"text":"Network Operation Helpers","id":"network-operation-helpers"},{"level":4,"text":"Serialization Error Handling","id":"serialization-error-handling"},{"level":4,"text":"Error Recovery and Retry Logic","id":"error-recovery-and-retry-logic"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Mental Model: The Quality Control Factory","id":"mental-model-the-quality-control-factory"},{"level":3,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Milestone 1: Message Protocol Checkpoints","id":"milestone-1-message-protocol-checkpoints"},{"level":4,"text":"Milestone 2: Server Implementation Checkpoints","id":"milestone-2-server-implementation-checkpoints"},{"level":4,"text":"Milestone 3: Client Implementation Checkpoints","id":"milestone-3-client-implementation-checkpoints"},{"level":3,"text":"Integration Test Scenarios","id":"integration-test-scenarios"},{"level":4,"text":"End-to-End RPC Call Scenarios","id":"end-to-end-rpc-call-scenarios"},{"level":4,"text":"Network Failure and Recovery Scenarios","id":"network-failure-and-recovery-scenarios"},{"level":4,"text":"Stress and Performance Scenarios","id":"stress-and-performance-scenarios"},{"level":4,"text":"Error Recovery and Resilience Scenarios","id":"error-recovery-and-resilience-scenarios"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Testing Technology Recommendations","id":"testing-technology-recommendations"},{"level":4,"text":"Test File Structure","id":"test-file-structure"},{"level":4,"text":"Unit Test Infrastructure Starter Code","id":"unit-test-infrastructure-starter-code"},{"level":4,"text":"Milestone Checkpoint Implementation","id":"milestone-checkpoint-implementation"},{"level":4,"text":"Load and Stress Testing Infrastructure","id":"load-and-stress-testing-infrastructure"},{"level":4,"text":"Debugging and Verification Tools","id":"debugging-and-verification-tools"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Mental Model: The Detective&#39;s Investigation Process","id":"mental-model-the-detective39s-investigation-process"},{"level":3,"text":"Connection and Network Issues","id":"connection-and-network-issues"},{"level":4,"text":"Common Network Failure Patterns","id":"common-network-failure-patterns"},{"level":4,"text":"Socket State Debugging","id":"socket-state-debugging"},{"level":4,"text":"Server Connection Handling","id":"server-connection-handling"},{"level":4,"text":"Client Connection Management","id":"client-connection-management"},{"level":4,"text":"Network Timeout Behavior","id":"network-timeout-behavior"},{"level":4,"text":"Testing Network Edge Cases","id":"testing-network-edge-cases"},{"level":3,"text":"Serialization and Protocol Issues","id":"serialization-and-protocol-issues"},{"level":4,"text":"JSON Serialization Edge Cases","id":"json-serialization-edge-cases"},{"level":4,"text":"Message Format Validation","id":"message-format-validation"},{"level":4,"text":"Parameter Type Marshaling","id":"parameter-type-marshaling"},{"level":4,"text":"Message Framing Errors","id":"message-framing-errors"},{"level":4,"text":"Debugging Serialization Problems","id":"debugging-serialization-problems"},{"level":3,"text":"Timing and Concurrency Issues","id":"timing-and-concurrency-issues"},{"level":4,"text":"Request ID Correlation Problems","id":"request-id-correlation-problems"},{"level":4,"text":"Timeout Handling Complexity","id":"timeout-handling-complexity"},{"level":4,"text":"Server Concurrency Issues","id":"server-concurrency-issues"},{"level":4,"text":"Deadlock Detection and Prevention","id":"deadlock-detection-and-prevention"},{"level":4,"text":"Load Testing for Concurrency Issues","id":"load-testing-for-concurrency-issues"},{"level":4,"text":"Performance Monitoring and Profiling","id":"performance-monitoring-and-profiling"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Debugging Infrastructure","id":"debugging-infrastructure"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Common Debugging Scenarios","id":"common-debugging-scenarios"},{"level":4,"text":"Performance Debugging Tools","id":"performance-debugging-tools"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Mental Model: The Growing City Analogy","id":"mental-model-the-growing-city-analogy"},{"level":3,"text":"Performance Extensions","id":"performance-extensions"},{"level":4,"text":"Connection Pooling","id":"connection-pooling"},{"level":4,"text":"Asynchronous Support","id":"asynchronous-support"},{"level":4,"text":"Binary Serialization","id":"binary-serialization"},{"level":3,"text":"Reliability Extensions","id":"reliability-extensions"},{"level":4,"text":"Authentication and Authorization","id":"authentication-and-authorization"},{"level":4,"text":"Encryption and Transport Security","id":"encryption-and-transport-security"},{"level":4,"text":"Retry Mechanisms and Circuit Breakers","id":"retry-mechanisms-and-circuit-breakers"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Connection Pool Infrastructure","id":"connection-pool-infrastructure"},{"level":4,"text":"Async Client Core Implementation","id":"async-client-core-implementation"},{"level":4,"text":"Authentication Middleware Foundation","id":"authentication-middleware-foundation"},{"level":4,"text":"Circuit Breaker Implementation","id":"circuit-breaker-implementation"},{"level":4,"text":"Milestone Checkpoints for Extensions","id":"milestone-checkpoints-for-extensions"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Mental Model: The Technical Dictionary","id":"mental-model-the-technical-dictionary"},{"level":3,"text":"Core RPC Concepts","id":"core-rpc-concepts"},{"level":3,"text":"Network Communication Terms","id":"network-communication-terms"},{"level":3,"text":"Concurrency and State Management","id":"concurrency-and-state-management"},{"level":3,"text":"Error Handling and Reliability","id":"error-handling-and-reliability"},{"level":3,"text":"Testing and Quality Assurance","id":"testing-and-quality-assurance"},{"level":3,"text":"Performance and Optimization","id":"performance-and-optimization"},{"level":3,"text":"Security and Authentication","id":"security-and-authentication"},{"level":3,"text":"Development and Implementation","id":"development-and-implementation"},{"level":3,"text":"Debugging and Diagnostics","id":"debugging-and-diagnostics"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Core Implementation Classes","id":"core-implementation-classes"},{"level":4,"text":"Error Hierarchy Implementation","id":"error-hierarchy-implementation"},{"level":4,"text":"Standard Error Codes","id":"standard-error-codes"},{"level":4,"text":"Message Utilities","id":"message-utilities"},{"level":4,"text":"Network Helper Functions","id":"network-helper-functions"},{"level":4,"text":"File Structure Recommendation","id":"file-structure-recommendation"}],"title":"RPC Framework: Design Document","markdown":"# RPC Framework: Design Document\n\n\n## Overview\n\nThis system implements a simple Remote Procedure Call (RPC) framework that allows clients to invoke functions on remote servers as if they were local method calls. The key architectural challenge is transparently handling network communication, serialization, and error propagation while maintaining the illusion of local function invocation.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** Foundation for Milestones 1, 2, and 3 - understanding the core RPC challenge\n\n### Mental Model: The Postal Service Analogy\n\nUnderstanding Remote Procedure Calls becomes intuitive when we think about how the postal service operates. Imagine you need to ask your grandmother for her famous cookie recipe, but she lives in another city. You can't simply walk into her kitchen and ask - there's a physical distance barrier that requires a communication protocol.\n\nIn the traditional postal approach, you write a letter with your request, put it in an envelope with her address, mail it, and wait for her response letter with the recipe. This exchange involves several key elements that directly mirror RPC concepts: you need a **standardized message format** (letter writing conventions), a **delivery mechanism** (postal service), **addressing** (her mailing address), **request identification** (so she knows which letter she's responding to), and **error handling** (what happens if the letter gets lost?).\n\nThe **sender** (you) doesn't need to understand the complex logistics of mail sorting, truck routes, or delivery scheduling - you just write the letter and trust the postal service to handle delivery. Similarly, the **recipient** (your grandmother) doesn't need to know how the letter traveled - she just reads your request and writes a response. This **transparency** is the fundamental goal of RPC: making remote function calls feel as natural as local function calls.\n\nHowever, unlike face-to-face conversation, postal communication introduces several challenges. Letters can get **lost in transit** (network failures), arrive **out of order** (if you send multiple requests), take **unpredictable amounts of time** (latency), or contain **illegible handwriting** (serialization errors). Your grandmother might be **unavailable** (server down), **not understand your request** (method not found), or **unable to fulfill it** (execution error). The postal service requires both parties to agree on message formatting, addressing schemes, and error handling procedures.\n\nIn our RPC framework, the **client** acts like you writing letters with function call requests. The **network transport** serves as the postal service, routing messages between locations. The **server** functions like your grandmother, receiving requests and sending back responses. The **message protocol** defines the standardized format for requests and responses, just like letter-writing conventions ensure clear communication.\n\n![RPC Framework System Overview](./diagrams/system-overview.svg)\n\nThis analogy helps us understand why RPC frameworks need several sophisticated components that don't exist in local function calls. We need **message serialization** to convert function parameters into a format suitable for network transmission (like writing legibly). We need **connection management** to establish and maintain communication channels (like ensuring the postal service has correct addresses). We need **error handling** for all the ways remote communication can fail (like dealing with lost or delayed mail). Most importantly, we need **transparency mechanisms** that hide these complexities from the application developer, making remote calls look identical to local calls.\n\n### Existing RPC Approaches\n\nThe software industry has developed numerous approaches for enabling remote procedure calls, each with different trade-offs between simplicity, performance, and feature richness. Understanding these existing solutions helps us appreciate the design decisions in our educational RPC framework and provides context for why certain patterns have emerged as standards.\n\n**REST APIs with HTTP/JSON** represent the most ubiquitous approach to remote communication in modern web applications. REST treats remote operations as HTTP requests to resource-oriented URLs, using standard HTTP verbs (GET, POST, PUT, DELETE) to indicate operation types. Parameters are typically passed as URL query parameters, request bodies, or path segments, with JSON serving as the serialization format for complex data structures.\n\n| Aspect | REST APIs | Our Assessment |\n|--------|-----------|----------------|\n| **Learning Curve** | Shallow - builds on familiar HTTP concepts | Excellent for beginners |\n| **Tooling Support** | Extensive - every language has HTTP libraries | Universal availability |\n| **Performance** | Moderate - HTTP overhead, JSON parsing costs | Acceptable for most use cases |\n| **Type Safety** | Weak - JSON is dynamically typed | Requires careful validation |\n| **Transport** | HTTP-only - bound to request/response model | Limited flexibility |\n| **Discovery** | Manual - developers must know endpoints | No built-in service discovery |\n\nREST's primary strength lies in its **conceptual simplicity** and **universal tooling support**. Every programming language provides HTTP client libraries, making REST APIs immediately accessible. The **stateless, cacheable** nature of HTTP aligns well with web architecture patterns, and **human-readable** URLs and JSON payloads simplify debugging and testing. However, REST's resource-oriented model can feel **unnatural for procedure-oriented operations**, and the **lack of formal contracts** means API changes can break clients in subtle ways.\n\n**gRPC with Protocol Buffers** represents Google's high-performance, strongly-typed approach to RPC. gRPC uses HTTP/2 as its transport layer, providing features like **multiplexing, flow control, and header compression**. Protocol Buffers serve as both the **interface definition language** (defining service contracts in `.proto` files) and the **binary serialization format**, offering **strong typing, forward/backward compatibility, and compact wire encoding**.\n\n| Aspect | gRPC | Our Assessment |\n|--------|------|----------------|\n| **Performance** | High - binary encoding, HTTP/2 multiplexing | Excellent for high-throughput systems |\n| **Type Safety** | Strong - generated client/server code | Prevents many integration bugs |\n| **Tooling** | Excellent - code generation, reflection, debugging | Rich ecosystem |\n| **Learning Curve** | Steep - requires Protocol Buffer knowledge | Challenging for beginners |\n| **Transport** | HTTP/2 required - complex proxy configuration | Infrastructure complexity |\n| **Human Readability** | Poor - binary format difficult to debug | Harder to troubleshoot |\n\ngRPC excels in **microservice architectures** where **performance and type safety** are critical. The **automatic code generation** from `.proto` files ensures client and server implementations stay synchronized. **Streaming support** enables real-time communication patterns like chat systems or live data feeds. However, gRPC's **binary format complicates debugging**, and **HTTP/2 requirements** can create deployment challenges in environments with legacy proxy servers or firewalls.\n\n**JSON-RPC** provides a lightweight, specification-based approach that directly mirrors traditional function call semantics. Unlike REST's resource orientation, JSON-RPC explicitly models **method invocation with parameters and return values**. The protocol defines standardized message formats for **requests, responses, and errors**, making implementations more consistent across languages and frameworks.\n\n| Aspect | JSON-RPC | Our Assessment |\n|--------|----------|----------------|\n| **Conceptual Model** | Natural - direct function call mapping | Intuitive for developers |\n| **Specification** | Formal - well-defined message formats | Promotes interoperability |\n| **Implementation** | Simple - just JSON over HTTP/TCP/WebSocket | Easy to implement correctly |\n| **Flexibility** | High - transport-agnostic protocol | Adaptable to different needs |\n| **Tooling** | Limited - fewer frameworks than REST/gRPC | Requires more manual work |\n| **Performance** | Moderate - JSON overhead, no streaming | Adequate for most applications |\n\nJSON-RPC strikes a **balance between simplicity and formality** that makes it an excellent educational choice. The **specification provides clear guidance** for message formats and error handling, while the **transport independence** allows implementations over TCP sockets, HTTP, WebSockets, or message queues. **Batching support** enables multiple method calls in a single request, reducing network round-trips for bulk operations.\n\n**Message Queue Systems** like RabbitMQ, Apache Kafka, or Redis Pub/Sub take a fundamentally different approach, treating remote communication as **asynchronous message passing** rather than synchronous function calls. Clients publish **request messages** to queues, servers consume and process these messages, then publish **response messages** back to reply queues or topics.\n\n| Aspect | Message Queues | Our Assessment |\n|--------|----------------|----------------|\n| **Decoupling** | Excellent - clients and servers independent | Great for scalable architectures |\n| **Reliability** | High - message persistence, delivery guarantees | Handles failures gracefully |\n| **Scalability** | Excellent - natural load balancing, fan-out | Scales to high message volumes |\n| **Complexity** | High - requires message broker infrastructure | Significant operational overhead |\n| **Latency** | Higher - broker adds network hops | Not suitable for low-latency calls |\n| **Programming Model** | Asynchronous - requires careful state management | More complex application logic |\n\nMessage queues excel in **distributed systems** where **fault tolerance and scalability** outweigh latency concerns. The **broker-mediated communication** provides **natural load balancing** and **failure isolation** - if one server instance crashes, others can continue processing queued messages. However, the **asynchronous programming model** requires applications to carefully manage **request correlation and state**, making simple function call patterns more complex to implement.\n\n> **Design Insight**: Our educational RPC framework adopts JSON-RPC's message format because it provides **formal specification guidance** while remaining **simple enough for beginners** to implement without extensive tooling. We'll use **TCP sockets for transport** to focus on core RPC concepts rather than HTTP complexities, and **synchronous request-response patterns** to maintain familiar function call semantics.\n\nThe choice of **JSON-RPC over TCP** for our educational framework reflects several pedagogical priorities. **JSON serialization** allows students to **inspect wire format messages** during debugging, unlike binary protocols that require specialized tools. **TCP sockets** expose **fundamental networking concepts** like connection management and byte stream handling, providing deeper systems understanding than HTTP abstraction layers. **Synchronous patterns** maintain the **mental model of function calls** that students already understand, avoiding the complexity of asynchronous programming and callback management.\n\n**Architecture Decision Records**\n\n> **Decision: JSON-RPC Message Format**\n> - **Context**: Need a message protocol that balances formal specification with educational clarity\n> - **Options Considered**: \n>   1. Custom binary protocol (maximum control, high complexity)\n>   2. HTTP REST with JSON (familiar, but resource-oriented doesn't match RPC semantics)\n>   3. JSON-RPC 2.0 specification (formal, function-call oriented)\n> - **Decision**: JSON-RPC 2.0 specification with minor adaptations\n> - **Rationale**: Provides formal specification for message formats while maintaining human-readable JSON encoding that aids debugging and learning\n> - **Consequences**: Students learn standard protocol patterns and can easily inspect/debug message exchanges, but JSON parsing adds some performance overhead\n\n| Option | Pros | Cons |\n|--------|------|------|\n| **Custom Binary** | Maximum performance and control | High complexity, no existing tooling, difficult to debug |\n| **HTTP REST** | Universal tooling, familiar to web developers | Resource-oriented model doesn't match function call semantics |\n| **JSON-RPC** | Formal spec, function-call oriented, human-readable | Less tooling than HTTP, moderate performance overhead |\n\n> **Decision: TCP Socket Transport**\n> - **Context**: Need transport layer that exposes fundamental networking concepts for educational value\n> - **Options Considered**:\n>   1. HTTP with standard libraries (simple, abstracted)\n>   2. Raw TCP sockets (educational, full control)\n>   3. WebSockets (real-time capable, browser-friendly)\n> - **Decision**: Raw TCP sockets with JSON message framing\n> - **Rationale**: Forces students to understand connection management, byte streams, and message framing - core networking concepts hidden by HTTP abstractions\n> - **Consequences**: Students gain deeper networking understanding but must implement connection pooling and error handling manually\n\n| Option | Pros | Cons |\n|--------|------|------|\n| **HTTP** | Familiar, extensive tooling, handles framing automatically | Hides networking concepts, adds protocol overhead |\n| **TCP Sockets** | Educational value, full control, minimal overhead | Requires manual connection and framing management |\n| **WebSockets** | Real-time capable, familiar to web developers | More complex than needed for basic RPC |\n\n> **Decision: Synchronous Request-Response Pattern**\n> - **Context**: Need to choose between synchronous and asynchronous client API design\n> - **Options Considered**:\n>   1. Synchronous blocking calls (simple, familiar function semantics)\n>   2. Asynchronous with callbacks (scalable, complex error handling)\n>   3. Asynchronous with futures/promises (modern, requires concurrency understanding)\n> - **Decision**: Synchronous blocking calls with configurable timeouts\n> - **Rationale**: Maintains familiar function call semantics while teaching core RPC concepts without concurrent programming complexity\n> - **Consequences**: Simple to understand and use, but limits scalability for high-concurrency applications\n\n| Option | Pros | Cons |\n|--------|------|------|\n| **Synchronous** | Familiar function semantics, simple error handling | Blocks calling thread, limits concurrency |\n| **Callbacks** | Non-blocking, scalable | Complex error handling, callback hell |\n| **Futures/Promises** | Modern async patterns, composable | Requires understanding of concurrent programming |\n\nThese architectural decisions collectively create an RPC framework that **prioritizes learning value over production features**. Students will understand **message serialization, network programming, and distributed error handling** without being overwhelmed by **performance optimizations, concurrent programming, or complex tooling requirements**. The resulting system provides a solid foundation for understanding more sophisticated frameworks like gRPC or enterprise message queuing systems.\n\n### Implementation Guidance\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **JSON Handling** | `json` module (built-in) | `ujson` or `orjson` for performance |\n| **Socket Management** | `socket` module (built-in) | `asyncio` for async patterns |\n| **Logging** | `logging` module (built-in) | `structlog` for structured logs |\n| **Testing** | `unittest` (built-in) | `pytest` with fixtures |\n\n**Recommended Project Structure:**\n\n```\nrpc-framework/\n├── rpc/\n│   ├── __init__.py\n│   ├── protocol.py          ← Message formats and serialization (Milestone 1)\n│   ├── server.py           ← RPC server implementation (Milestone 2)  \n│   ├── client.py           ← RPC client implementation (Milestone 3)\n│   └── exceptions.py       ← Custom exception classes\n├── examples/\n│   ├── calculator_server.py ← Example server with math functions\n│   ├── calculator_client.py ← Example client usage\n│   └── echo_server.py      ← Simple echo service for testing\n├── tests/\n│   ├── test_protocol.py    ← Message format tests\n│   ├── test_server.py      ← Server functionality tests\n│   ├── test_client.py      ← Client functionality tests\n│   └── test_integration.py ← End-to-end RPC call tests\n└── README.md\n```\n\n**Core Exception Hierarchy:**\n\n```python\n# rpc/exceptions.py - Complete exception infrastructure\nclass RPCError(Exception):\n    \"\"\"Base class for all RPC-related errors.\"\"\"\n    pass\n\nclass RPCProtocolError(RPCError):\n    \"\"\"Errors related to message format or protocol violations.\"\"\"\n    pass\n\nclass RPCTransportError(RPCError):\n    \"\"\"Errors related to network communication.\"\"\"\n    pass\n\nclass RPCTimeoutError(RPCTransportError):\n    \"\"\"Request timeout exceeded.\"\"\"\n    pass\n\nclass RPCMethodError(RPCError):\n    \"\"\"Errors related to method execution.\"\"\"\n    def __init__(self, code, message, data=None):\n        self.code = code\n        self.message = message\n        self.data = data\n        super().__init__(f\"RPC Error {code}: {message}\")\n\n# Standard JSON-RPC error codes\nclass ErrorCode:\n    PARSE_ERROR = -32700\n    INVALID_REQUEST = -32600\n    METHOD_NOT_FOUND = -32601\n    INVALID_PARAMS = -32602\n    INTERNAL_ERROR = -32603\n```\n\n**JSON Message Utilities:**\n\n```python\n# rpc/protocol.py - Complete message handling infrastructure\nimport json\nimport uuid\nfrom typing import Any, Dict, Optional, Union\n\ndef generate_request_id() -> str:\n    \"\"\"Generate unique request ID for RPC calls.\"\"\"\n    return str(uuid.uuid4())\n\ndef create_request_message(method: str, params: Any = None, request_id: str = None) -> Dict:\n    \"\"\"Create a JSON-RPC 2.0 request message.\"\"\"\n    # TODO 1: Create message dict with jsonrpc version \"2.0\"\n    # TODO 2: Add method name and request_id (generate if None)\n    # TODO 3: Add params only if not None (supports both list and dict params)\n    # TODO 4: Return complete request message dict\n    pass\n\ndef create_response_message(request_id: str, result: Any) -> Dict:\n    \"\"\"Create a JSON-RPC 2.0 success response message.\"\"\"\n    # TODO 1: Create message dict with jsonrpc version \"2.0\" \n    # TODO 2: Add matching request_id and result\n    # TODO 3: Return complete response message dict\n    pass\n\ndef create_error_message(request_id: str, code: int, message: str, data: Any = None) -> Dict:\n    \"\"\"Create a JSON-RPC 2.0 error response message.\"\"\"\n    # TODO 1: Create message dict with jsonrpc version \"2.0\"\n    # TODO 2: Add matching request_id \n    # TODO 3: Create error object with code and message\n    # TODO 4: Add data to error object if provided\n    # TODO 5: Return complete error response message dict\n    pass\n\ndef serialize_message(message: Dict) -> bytes:\n    \"\"\"Serialize message to JSON bytes with length prefix.\"\"\"\n    # TODO 1: Convert message dict to JSON string\n    # TODO 2: Encode JSON string to UTF-8 bytes\n    # TODO 3: Create length prefix (4-byte big-endian integer)\n    # TODO 4: Return length prefix + message bytes\n    # Hint: Use struct.pack('>I', length) for big-endian 32-bit int\n    pass\n\ndef deserialize_message(data: bytes) -> Dict:\n    \"\"\"Deserialize JSON bytes to message dict.\"\"\" \n    # TODO 1: Decode UTF-8 bytes to JSON string\n    # TODO 2: Parse JSON string to dict\n    # TODO 3: Validate required fields (jsonrpc, id)\n    # TODO 4: Return message dict or raise RPCProtocolError\n    pass\n```\n\n**Socket Helper Utilities:**\n\n```python\n# rpc/transport.py - Complete network transport utilities\nimport socket\nimport struct\nfrom typing import Optional\n\nclass SocketHelper:\n    \"\"\"Utility class for socket operations with proper error handling.\"\"\"\n    \n    @staticmethod\n    def send_all(sock: socket.socket, data: bytes, timeout: float = 30.0) -> None:\n        \"\"\"Send all bytes, handling partial sends.\"\"\"\n        # TODO 1: Set socket timeout\n        # TODO 2: Track bytes sent with offset\n        # TODO 3: Loop until all bytes sent, handle EAGAIN/EWOULDBLOCK\n        # TODO 4: Raise RPCTransportError on socket errors\n        pass\n    \n    @staticmethod \n    def recv_all(sock: socket.socket, size: int, timeout: float = 30.0) -> bytes:\n        \"\"\"Receive exact number of bytes.\"\"\"\n        # TODO 1: Set socket timeout\n        # TODO 2: Track bytes received with buffer\n        # TODO 3: Loop until exact size received\n        # TODO 4: Handle connection closed (recv returns empty bytes)\n        # TODO 5: Raise RPCTransportError on socket errors\n        pass\n    \n    @staticmethod\n    def recv_message(sock: socket.socket, timeout: float = 30.0) -> bytes:\n        \"\"\"Receive length-prefixed message.\"\"\"\n        # TODO 1: Receive 4-byte length prefix\n        # TODO 2: Unpack big-endian integer from prefix\n        # TODO 3: Receive message bytes of specified length\n        # TODO 4: Return message bytes\n        # Hint: Use struct.unpack('>I', prefix)[0] for big-endian 32-bit int\n        pass\n```\n\n**Language-Specific Implementation Hints:**\n\n- **JSON Handling**: Use `json.loads()` and `json.dumps()` for message serialization. Handle `json.JSONDecodeError` for malformed messages.\n- **Socket Programming**: Use `socket.socket(socket.AF_INET, socket.SOCK_STREAM)` for TCP sockets. Always call `close()` in finally blocks.\n- **Error Propagation**: Wrap socket exceptions in custom `RPCTransportError` to provide consistent error handling across the framework.\n- **Thread Safety**: Use `threading.Lock()` if implementing concurrent request handling in the server.\n- **Timeout Handling**: Use `socket.settimeout()` for network operations and catch `socket.timeout` exceptions.\n\n**Development Workflow:**\n\n1. **Start with Protocol**: Implement message creation and serialization functions first - these are the foundation for client and server.\n2. **Build Server Next**: Create the method registry and request dispatcher - easier to test than client since you control both ends.\n3. **Add Client Last**: Implement the proxy object and connection management - can test against your working server.\n4. **Test Integration**: Write end-to-end tests that exercise client → server → client round trips with various scenarios.\n\n**Common Setup Mistakes to Avoid:**\n\n⚠️ **Pitfall: Forgetting Message Framing**\nTCP is a byte stream, not a message stream. Without length prefixes, you can't tell where one JSON message ends and the next begins. Always use length-prefixed framing.\n\n⚠️ **Pitfall: Not Handling Partial Socket Operations**  \n`socket.send()` and `socket.recv()` may not send/receive all requested bytes in a single call. Always loop until complete.\n\n⚠️ **Pitfall: Mixing Bytes and Strings**\nJSON serialization produces strings, but sockets require bytes. Always encode/decode at the socket boundary using UTF-8.\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** Foundation for all milestones - defines the scope and boundaries of our RPC framework implementation\n\n### Mental Model: The Swiss Army Knife vs. The Hammer\n\nThink of our RPC framework like choosing between a Swiss Army knife and a hammer. A Swiss Army knife has dozens of tools - screwdrivers, scissors, can opener, magnifying glass - and can handle almost any situation you encounter. However, each tool is small and somewhat awkward to use. In contrast, a hammer does exactly one thing: drive nails. It's simple, reliable, and excellent at its specific job, but useless for cutting wire or opening bottles.\n\nProduction RPC frameworks like gRPC are Swiss Army knives. They handle authentication, load balancing, circuit breakers, multiple serialization formats, streaming, compression, service discovery, and dozens of other concerns. They're incredibly powerful but also complex to understand and implement.\n\nOur educational RPC framework is the hammer. It does one thing well: allow a client to call a function on a remote server as if it were local. By focusing solely on this core mechanism, we can understand the fundamental principles without getting lost in production concerns. Once you master the hammer, you'll appreciate why the Swiss Army knife needs all those extra tools.\n\n### Functional Goals\n\nOur RPC framework must demonstrate the core concepts that make remote procedure calls possible. These goals define the minimum viable system that teaches the essential patterns and challenges of distributed function invocation.\n\n**Core RPC Semantics**\n\nThe framework must provide the illusion of local function calls despite network boundaries. When a client calls `calculator.add(5, 3)`, it should feel identical to calling a local method, even though the actual computation happens on a remote server. This transparency is the defining characteristic of RPC systems.\n\nThe system must support **method registration** on the server side, allowing developers to expose specific functions for remote invocation. A server should be able to register functions like `add`, `subtract`, `get_user`, or `process_payment` and make them available to remote clients through a simple registry mechanism.\n\n**JSON-RPC Protocol Implementation**\n\nWe will implement a subset of the JSON-RPC 2.0 specification, which provides a lightweight, human-readable protocol for remote procedure calls. Our implementation must handle the three core message types defined by this specification.\n\n| Message Type | Required Fields | Purpose |\n|--------------|----------------|---------|\n| Request | `method`, `params`, `id` | Invoke remote function with parameters |\n| Response | `result`, `id` | Return successful function result |\n| Error | `error`, `id` | Report function execution or protocol errors |\n\nThe protocol must support **request-response correlation** using unique request IDs. When a client sends a request with ID \"abc123\", it must receive a response with the matching ID \"abc123\". This correlation allows clients to handle multiple concurrent requests and match responses to their originating calls.\n\n**Network Transport and Serialization**\n\nThe framework must implement **TCP socket communication** for reliable message delivery between clients and servers. TCP provides the ordered, reliable byte stream we need for RPC communication, handling packet loss, reordering, and corruption at the network level.\n\nAll messages must use **JSON serialization** for cross-language compatibility and human readability during development. The system must handle serialization of common Python types including strings, numbers, lists, dictionaries, and `None` values.\n\nThe implementation must solve the **message framing problem** - determining where one message ends and the next begins in a continuous byte stream. We'll use a simple length-prefix framing protocol where each message is preceded by a 4-byte header indicating the message size.\n\n**Error Handling and Propagation**\n\nThe framework must provide comprehensive error handling that distinguishes between different failure modes and propagates appropriate error information back to clients.\n\n| Error Category | Example Causes | Client Experience |\n|----------------|----------------|-------------------|\n| Protocol Errors | Invalid JSON, missing fields | `RPCProtocolError` exception |\n| Transport Errors | Connection dropped, network unreachable | `RPCTransportError` exception |\n| Method Errors | Function not found, execution failed | `RPCMethodError` exception with details |\n| Timeout Errors | Server too slow, network congestion | `RPCTimeoutError` exception |\n\nEach error type must include sufficient information for debugging while maintaining security boundaries. Method execution errors should include the error message and type information, but not sensitive server-side details like file paths or stack traces.\n\n**Client Proxy Interface**\n\nThe client must provide a **proxy object** that converts method calls into RPC requests transparently. Instead of manually constructing JSON messages, developers should write natural Python code:\n\n```python\n# This natural syntax...\nresult = client.calculator.add(5, 3)\n\n# ...should automatically generate and send this RPC request:\n# {\"method\": \"add\", \"params\": [5, 3], \"id\": \"req_001\"}\n```\n\nThe proxy must handle **timeout management**, raising `RPCTimeoutError` when remote calls exceed the configured deadline. This prevents clients from waiting indefinitely for servers that have crashed or become unresponsive.\n\n**Server Method Registry and Dispatch**\n\nThe server must implement a **method registry** that maps string method names to callable Python functions. The registry should support simple registration syntax:\n\n```python\nserver.register_method(\"add\", lambda a, b: a + b)\nserver.register_method(\"get_user\", user_service.get_user_by_id)\n```\n\nThe server must implement **request dispatch logic** that parses incoming messages, looks up the requested method in the registry, invokes the method with the provided parameters, and serializes the result back to the client. This dispatch process must handle parameter validation, method execution, and error response generation.\n\n### Non-Goals\n\nUnderstanding what we will NOT implement is equally important for maintaining focus and managing scope. These exclusions allow us to concentrate on core RPC concepts without getting distracted by production concerns.\n\n**Production Reliability Features**\n\nWe will not implement **authentication or authorization** mechanisms. Our framework assumes a trusted network environment where all clients are permitted to invoke all registered methods. Production systems require sophisticated access control, API keys, OAuth tokens, or certificate-based authentication, but these concerns are orthogonal to understanding RPC fundamentals.\n\nThe framework will not include **encryption or transport security**. All communication happens in plaintext over TCP sockets. Production RPC systems use TLS encryption to protect sensitive data in transit, but implementing cryptography would obscure the core message exchange patterns we're trying to learn.\n\nWe will not implement **connection pooling or persistent connections**. Each RPC call will establish a new TCP connection, send the request, receive the response, and close the connection. This approach is inefficient but simpler to understand and debug. Production systems maintain connection pools to amortize connection establishment costs across multiple calls.\n\n**Performance and Scalability Features**\n\nThe system will not support **asynchronous or streaming calls**. Every RPC call follows a simple synchronous request-response pattern where the client blocks until the server returns a result. Asynchronous RPC systems use callbacks, futures, or async/await patterns to handle multiple concurrent calls without blocking threads.\n\nWe will not implement **load balancing or service discovery**. Clients must know the exact IP address and port of the server they want to contact. Production systems use service registries, DNS-based discovery, or load balancers to distribute requests across multiple server instances.\n\nThe framework will not include **circuit breakers or retry mechanisms**. If a server is unreachable or returns an error, the client will immediately report the failure to the application. Production systems implement sophisticated retry policies with exponential backoff, circuit breakers that stop calling failing services, and graceful degradation strategies.\n\n**Advanced Protocol Features**\n\nWe will not support **binary serialization formats** like Protocol Buffers, MessagePack, or Apache Avro. JSON serialization is less efficient but much easier to debug and understand. Binary formats require schema definitions, code generation, and specialized tooling that would complicate our learning objectives.\n\nThe system will not implement **batch requests or pipelining**. Each RPC call requires a separate network round-trip. Some RPC protocols allow clients to send multiple requests in a single message or send requests without waiting for responses, but these optimizations add protocol complexity.\n\nWe will not support **bidirectional communication or server push**. Communication flows strictly from client to server and back. Modern RPC frameworks support streaming responses, server-initiated callbacks, and full-duplex communication channels, but these patterns require more sophisticated connection management.\n\n**Error Recovery and Reliability**\n\nThe framework will not implement **automatic retry logic**. If a network error occurs or a server becomes unavailable, the client will immediately raise an exception. Production systems implement retry policies that distinguish between transient errors (network congestion, temporary server overload) and permanent errors (method not found, invalid parameters).\n\nWe will not include **distributed tracing or monitoring** capabilities. Each RPC call happens in isolation without correlation IDs, performance metrics, or observability hooks. Production systems instrument every remote call with tracing data to help debug performance issues and understand system behavior.\n\nThe system will not support **graceful shutdown or connection draining**. Servers will terminate immediately when stopped, potentially interrupting in-flight requests. Production servers implement graceful shutdown sequences that stop accepting new requests while allowing existing requests to complete.\n\n**Multi-Language and Compatibility Features**\n\nWhile our protocol uses JSON and could theoretically support multiple languages, we will not provide **client libraries for other languages**. The implementation will be Python-only, with Python-specific error types, proxy mechanisms, and API patterns.\n\nWe will not implement **schema validation or interface definition languages**. Methods can be called with any parameters, and type checking happens at runtime during method execution. Production RPC systems often use schema languages like Protocol Buffer definitions or OpenAPI specifications to define and validate interfaces.\n\n> **Design Principle: Educational Focus Over Production Readiness**\n>\n> Every non-goal represents a deliberate choice to prioritize learning over completeness. Production RPC frameworks are complex because distributed systems are complex. By temporarily ignoring these concerns, we can focus on the core insight: how to make a function call traverse a network boundary while maintaining the illusion of local execution.\n\n### Implementation Guidance\n\nThis framework serves as a foundation for understanding distributed systems concepts. The implementation should be straightforward enough for junior developers to complete in a few days while demonstrating the essential patterns used in production RPC systems.\n\n**A. Technology Recommendations**\n\n| Component | Simple Option | Advanced Option | Chosen |\n|-----------|---------------|-----------------|---------|\n| Serialization | JSON with `json` module | MessagePack or Protocol Buffers | JSON ✓ |\n| Transport | Raw TCP sockets with `socket` module | HTTP with `requests` library | TCP ✓ |\n| Threading | Single-threaded blocking server | `threading` or `asyncio` for concurrency | Single-threaded ✓ |\n| Error Handling | Exception hierarchy with custom types | Result types or error codes | Exceptions ✓ |\n| Message Framing | Length-prefix (4 bytes + payload) | Delimiter-based or HTTP chunking | Length-prefix ✓ |\n\n**B. Recommended File Structure**\n\nThe codebase should be organized into focused modules that separate concerns and make testing easier:\n\n```\nrpc_framework/\n├── __init__.py                 # Main package exports\n├── protocol.py                 # Message formats and serialization\n├── errors.py                   # Exception hierarchy\n├── server.py                   # RPC server implementation\n├── client.py                   # RPC client and proxy\n├── utils.py                    # Socket helpers and utilities\n└── examples/\n    ├── calculator_server.py    # Example server with math functions\n    ├── calculator_client.py    # Example client usage\n    └── test_integration.py     # End-to-end integration tests\n```\n\nThis structure separates the protocol definition from the client and server implementations, making it easier to understand each component independently.\n\n**C. Infrastructure Starter Code**\n\n**Socket Helper Utilities (`utils.py`)**\n\n```python\nimport socket\nimport struct\nimport time\nfrom typing import Optional\n\nclass SocketHelper:\n    \"\"\"Utility functions for reliable socket communication with timeouts.\"\"\"\n    \n    @staticmethod\n    def send_all(sock: socket.socket, data: bytes, timeout: Optional[float] = None) -> None:\n        \"\"\"Send all bytes, handling partial sends and timeouts.\n        \n        Args:\n            sock: Connected socket\n            data: Bytes to send\n            timeout: Maximum time to wait (None for blocking)\n            \n        Raises:\n            RPCTransportError: If send fails or times out\n        \"\"\"\n        if timeout is not None:\n            sock.settimeout(timeout)\n        \n        total_sent = 0\n        while total_sent < len(data):\n            try:\n                sent = sock.send(data[total_sent:])\n                if sent == 0:\n                    raise RPCTransportError(\"Socket connection broken\")\n                total_sent += sent\n            except socket.timeout:\n                raise RPCTimeoutError(f\"Send timeout after {timeout}s\")\n            except socket.error as e:\n                raise RPCTransportError(f\"Send failed: {e}\")\n    \n    @staticmethod\n    def recv_all(sock: socket.socket, size: int, timeout: Optional[float] = None) -> bytes:\n        \"\"\"Receive exactly size bytes, handling partial receives.\n        \n        Args:\n            sock: Connected socket\n            size: Number of bytes to receive\n            timeout: Maximum time to wait\n            \n        Returns:\n            Exact number of bytes requested\n            \n        Raises:\n            RPCTransportError: If receive fails or connection closes\n            RPCTimeoutError: If receive times out\n        \"\"\"\n        if timeout is not None:\n            sock.settimeout(timeout)\n        \n        chunks = []\n        bytes_received = 0\n        \n        while bytes_received < size:\n            try:\n                chunk = sock.recv(size - bytes_received)\n                if not chunk:\n                    raise RPCTransportError(\"Connection closed by peer\")\n                chunks.append(chunk)\n                bytes_received += len(chunk)\n            except socket.timeout:\n                raise RPCTimeoutError(f\"Receive timeout after {timeout}s\")\n            except socket.error as e:\n                raise RPCTransportError(f\"Receive failed: {e}\")\n        \n        return b''.join(chunks)\n    \n    @staticmethod\n    def recv_message(sock: socket.socket, timeout: Optional[float] = None) -> bytes:\n        \"\"\"Receive a length-prefixed message.\n        \n        Protocol: 4-byte length (network byte order) + message payload\n        \n        Args:\n            sock: Connected socket\n            timeout: Maximum time to wait\n            \n        Returns:\n            Message payload bytes\n        \"\"\"\n        # First receive the 4-byte length header\n        length_data = SocketHelper.recv_all(sock, 4, timeout)\n        message_length = struct.unpack('!I', length_data)[0]\n        \n        # Validate message length to prevent memory attacks\n        if message_length > 1024 * 1024:  # 1MB limit\n            raise RPCProtocolError(f\"Message too large: {message_length} bytes\")\n        \n        # Then receive the actual message\n        return SocketHelper.recv_all(sock, message_length, timeout)\n```\n\n**Error Hierarchy (`errors.py`)**\n\n```python\nclass RPCError(Exception):\n    \"\"\"Base class for all RPC-related errors.\"\"\"\n    pass\n\nclass RPCProtocolError(RPCError):\n    \"\"\"Errors in message format or protocol violations.\"\"\"\n    pass\n\nclass RPCTransportError(RPCError):\n    \"\"\"Network communication errors.\"\"\"\n    pass\n\nclass RPCTimeoutError(RPCError):\n    \"\"\"Request timeout errors.\"\"\"\n    pass\n\nclass RPCMethodError(RPCError):\n    \"\"\"Method execution errors with JSON-RPC error details.\"\"\"\n    \n    def __init__(self, code: int, message: str, data=None):\n        super().__init__(f\"RPC Method Error [{code}]: {message}\")\n        self.code = code\n        self.message = message\n        self.data = data\n\nclass ErrorCode:\n    \"\"\"Standard JSON-RPC error codes.\"\"\"\n    PARSE_ERROR = -32700\n    INVALID_REQUEST = -32600\n    METHOD_NOT_FOUND = -32601\n    INVALID_PARAMS = -32602\n    INTERNAL_ERROR = -32603\n```\n\n**D. Core Logic Skeleton Code**\n\n**Protocol Message Handling (`protocol.py`)**\n\n```python\nimport json\nimport struct\nimport uuid\nfrom typing import Dict, Any, Optional\n\ndef generate_request_id() -> str:\n    \"\"\"Generate a unique request ID for correlating requests and responses.\n    \n    Returns:\n        Unique string identifier\n    \"\"\"\n    # TODO: Generate a unique ID using uuid4() and return as string\n    # Hint: Use uuid.uuid4().hex for a simple string representation\n\ndef create_request_message(method: str, params: Any, request_id: str) -> Dict:\n    \"\"\"Create a JSON-RPC request message.\n    \n    Args:\n        method: Remote method name to invoke\n        params: Parameters to pass to method (list or dict)\n        request_id: Unique identifier for this request\n        \n    Returns:\n        Dictionary representing JSON-RPC request\n    \"\"\"\n    # TODO: Create dictionary with required JSON-RPC fields:\n    # - \"jsonrpc\": \"2.0\" (protocol version)\n    # - \"method\": method name\n    # - \"params\": parameters\n    # - \"id\": request_id\n\ndef create_response_message(request_id: str, result: Any) -> Dict:\n    \"\"\"Create a JSON-RPC response message for successful calls.\n    \n    Args:\n        request_id: ID from the original request\n        result: Return value from method execution\n        \n    Returns:\n        Dictionary representing JSON-RPC response\n    \"\"\"\n    # TODO: Create dictionary with required JSON-RPC response fields:\n    # - \"jsonrpc\": \"2.0\"\n    # - \"result\": the return value\n    # - \"id\": request_id\n\ndef create_error_message(request_id: str, code: int, message: str, data: Any = None) -> Dict:\n    \"\"\"Create a JSON-RPC error message.\n    \n    Args:\n        request_id: ID from the original request\n        code: Standard error code (see ErrorCode class)\n        message: Human-readable error description\n        data: Optional additional error information\n        \n    Returns:\n        Dictionary representing JSON-RPC error\n    \"\"\"\n    # TODO: Create dictionary with JSON-RPC error structure:\n    # - \"jsonrpc\": \"2.0\"\n    # - \"error\": {\"code\": code, \"message\": message, \"data\": data}\n    # - \"id\": request_id\n    # Note: Only include \"data\" field if data is not None\n\ndef serialize_message(message: Dict) -> bytes:\n    \"\"\"Convert message dictionary to length-prefixed bytes for network transmission.\n    \n    Protocol: 4-byte length header (network byte order) + JSON payload\n    \n    Args:\n        message: Dictionary to serialize\n        \n    Returns:\n        Length-prefixed message bytes\n        \n    Raises:\n        RPCProtocolError: If JSON serialization fails\n    \"\"\"\n    # TODO 1: Convert message dict to JSON string using json.dumps()\n    # TODO 2: Encode JSON string to UTF-8 bytes\n    # TODO 3: Calculate message length\n    # TODO 4: Pack length as 4-byte network byte order integer using struct.pack('!I', length)\n    # TODO 5: Concatenate length header + message bytes and return\n\ndef deserialize_message(data: bytes) -> Dict:\n    \"\"\"Parse bytes to message dictionary.\n    \n    Args:\n        data: Raw message bytes (no length prefix)\n        \n    Returns:\n        Parsed message dictionary\n        \n    Raises:\n        RPCProtocolError: If JSON parsing fails\n    \"\"\"\n    # TODO 1: Decode bytes to UTF-8 string\n    # TODO 2: Parse JSON string to dictionary using json.loads()\n    # TODO 3: Validate that result is a dictionary\n    # TODO 4: Return the parsed dictionary\n    # Hint: Wrap json.loads() in try/except and raise RPCProtocolError for invalid JSON\n```\n\n**E. Language-Specific Hints**\n\n**Socket Programming in Python:**\n- Use `socket.socket(socket.AF_INET, socket.SOCK_STREAM)` for TCP sockets\n- Call `sock.bind(('localhost', port))` and `sock.listen(1)` to create a server\n- Use `sock.accept()` to wait for client connections (returns new socket + address)\n- Call `sock.connect((host, port))` from client to establish connection\n- Always call `sock.close()` in a `finally` block or use `with` statement\n\n**JSON Serialization:**\n- `json.dumps(obj)` converts Python object to JSON string\n- `json.loads(string)` parses JSON string to Python object\n- JSON supports: strings, numbers, booleans, None (becomes null), lists, dictionaries\n- JSON cannot serialize: functions, classes, bytes, datetime objects\n\n**Struct for Binary Data:**\n- `struct.pack('!I', value)` packs integer as 4-byte network byte order\n- `struct.unpack('!I', bytes)[0]` unpacks 4-byte network byte order to integer\n- The `!` means network byte order (big-endian)\n- The `I` means unsigned 32-bit integer\n\n**F. Milestone Checkpoints**\n\n**After Milestone 1 (Message Protocol):**\n- Run: `python -c \"from protocol import *; print(create_request_message('add', [1,2], 'test'))\"`\n- Expected: `{'jsonrpc': '2.0', 'method': 'add', 'params': [1, 2], 'id': 'test'}`\n- Test serialization round-trip: message → serialize → deserialize → should equal original\n- Verify length-prefix format: serialized message should start with 4-byte length\n\n**After Milestone 2 (Server Implementation):**\n- Run: `python calculator_server.py` (should start server on localhost:8000)\n- Test with telnet: `telnet localhost 8000`\n- Send raw JSON-RPC request and verify you get a JSON-RPC response\n- Server should handle multiple sequential connections (connect, call, disconnect, repeat)\n\n**After Milestone 3 (Client Implementation):**\n- Run server in one terminal: `python calculator_server.py`\n- Run client in another: `python calculator_client.py`\n- Expected: Client should print results like \"5 + 3 = 8\"\n- Test timeout: Stop server, client should raise `RPCTimeoutError`\n- Test invalid method: Call non-existent method, should raise `RPCMethodError`\n\n**G. Debugging Tips**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| \"Connection refused\" | Server not running | Check if server process is active | Start server first |\n| \"JSON decode error\" | Malformed message | Print raw bytes before deserializing | Fix message construction |\n| Client hangs forever | Wrong message length | Verify 4-byte length header matches payload | Use `struct.pack('!I', len(data))` |\n| \"Method not found\" | Method not registered | Check server method registry | Call `server.register_method()` |\n| Partial message received | Not using `recv_all` | Use provided `SocketHelper.recv_all()` | Always receive exact byte count |\n| \"Broken pipe\" error | Client disconnected early | Check client timeout settings | Increase timeout or fix server speed |\n\n> **Key Learning Checkpoint**: By the end of this implementation, you should understand how network boundaries affect function calls, why serialization is necessary, how to correlate requests with responses, and what kinds of errors can occur in distributed systems. These concepts form the foundation for understanding more sophisticated distributed systems patterns.\n\n\n## High-Level Architecture\n\n> **Milestone(s):** Foundation for Milestones 1, 2, and 3 - establishes the overall system structure and component responsibilities\n\nThe RPC Framework consists of three primary components that work together to enable transparent remote method invocation. Understanding how these components interact and their individual responsibilities is crucial for successful implementation. This architecture follows a clear separation of concerns, where each component has a well-defined role in the overall RPC communication process.\n\n### Component Overview\n\nThink of our RPC framework as a **telephone system connecting different offices**. The message protocol acts like the standardized language and format everyone uses when making calls. The server is like a corporate switchboard operator who receives calls, understands what department the caller needs, and routes them to the right person. The client is like an executive assistant who knows how to dial the switchboard, speak the standard language, and handle the responses on behalf of their boss.\n\nThis mental model helps illustrate the key principle: **each component has a single, focused responsibility** that contributes to the illusion of local method calls across a network boundary.\n\n#### Message Protocol Component\n\nThe **message protocol component** serves as the foundation layer that defines how RPC communication is structured and serialized. This component establishes the wire format and message structure that both client and server must understand. It acts as the common language that enables interoperability between different RPC endpoints.\n\nThe protocol component's primary responsibilities include defining the JSON-RPC message formats, handling message serialization and deserialization, implementing message framing for TCP streams, and providing error code definitions. This component ensures that all communication follows a consistent, predictable structure that can be reliably parsed and understood by both ends of the connection.\n\n| Responsibility | Description | Key Functions |\n|---|---|---|\n| Message Structure | Defines request, response, and error message formats | `create_request_message`, `create_response_message`, `create_error_message` |\n| Serialization | Converts messages to/from wire format | `serialize_message`, `deserialize_message` |\n| Message Framing | Handles length-prefixed message boundaries | Built into serialize/deserialize functions |\n| Request ID Management | Generates unique identifiers for request correlation | `generate_request_id` |\n| Error Classification | Defines standard error codes and formats | `ErrorCode` constants |\n\nThe protocol component must handle several critical aspects of RPC communication. **Message framing** solves the fundamental problem of determining where one message ends and another begins in a TCP byte stream. Since TCP provides a stream of bytes without message boundaries, we use a length prefix approach where each message is preceded by a 4-byte header indicating the message size.\n\n**Request ID correlation** ensures that responses can be matched to their corresponding requests, especially important when multiple requests are in flight simultaneously. Each request receives a unique identifier that must be echoed back in the response, allowing the client to properly route responses to waiting callers.\n\n#### Server Component\n\nThe **server component** acts as the RPC service provider, accepting incoming connections and executing remote method calls. Think of it as a **receptionist and call routing system** - it listens for incoming requests, understands what the client wants to do, finds the right function to handle that request, and sends back the appropriate response.\n\nThe server's architecture centers around the concept of a **method registry** - a mapping from string names to callable Python functions. When a client requests a method call, the server looks up the method name in its registry, validates the parameters, executes the function, and returns the result or error.\n\n| Responsibility | Description | Implementation Strategy |\n|---|---|---|\n| Connection Management | Accept and handle TCP connections | Single-threaded with connection reuse |\n| Method Registry | Map method names to callable functions | Dictionary-based lookup |\n| Request Processing | Parse messages and dispatch to handlers | Sequential message processing |\n| Parameter Validation | Ensure method calls have correct parameters | Runtime type checking |\n| Response Generation | Create and send response messages | Automatic serialization and framing |\n| Error Handling | Convert exceptions to RPC error responses | Structured error code mapping |\n\nThe server follows a **synchronous, single-threaded model** for simplicity. Each incoming connection is handled sequentially, processing one request at a time before moving to the next. This design choice eliminates concurrency complexity while still providing a functional RPC service suitable for learning purposes.\n\n**Method registration** happens at server startup, where application code registers functions by providing a string name and a callable object. The server stores these mappings and uses them to dispatch incoming requests to the appropriate handlers.\n\n> **Design Insight**: The single-threaded server design prioritizes simplicity over performance. Real-world RPC servers would use threading or async I/O, but for educational purposes, the sequential model makes debugging easier and eliminates race conditions.\n\n#### Client Component\n\nThe **client component** provides the caller-side interface for making RPC calls. Its primary goal is to make remote method invocation feel as natural as calling a local function. Think of the client as a **personal secretary** who handles all the complex details of making phone calls - they know the right numbers to dial, speak the proper protocol language, wait for responses, and handle any problems that arise.\n\nThe client's most important feature is **method proxying** - the ability to intercept method calls on a proxy object and convert them into RPC requests. When application code calls `proxy.calculate(5, 3)`, the client automatically creates an RPC request message, sends it to the server, waits for the response, and returns the result as if the method had been executed locally.\n\n| Responsibility | Description | Key Mechanisms |\n|---|---|---|\n| Connection Management | Establish and maintain TCP connections | Socket lifecycle management |\n| Method Proxying | Convert method calls to RPC requests | Python `__getattr__` magic method |\n| Request Correlation | Track pending requests by ID | Dictionary mapping request IDs to futures |\n| Timeout Handling | Abort requests that take too long | Socket timeout configuration |\n| Response Processing | Convert RPC responses back to return values | Automatic deserialization |\n| Error Translation | Convert RPC errors to Python exceptions | Custom exception hierarchy |\n\n**Connection management** in the client involves establishing TCP connections to the server and handling connection lifecycle. For simplicity, our client creates a new connection for each RPC call, though production systems would typically use connection pooling for better performance.\n\n**Timeout handling** is critical for preventing client applications from hanging indefinitely when servers become unresponsive. The client sets socket timeouts and raises `RPCTimeoutError` exceptions when requests exceed their deadline.\n\n> **Architecture Decision: Synchronous vs Asynchronous Client API**\n> - **Context**: Clients can provide either blocking method calls or async/callback-based APIs\n> - **Options Considered**: \n>   1. Synchronous blocking calls that wait for responses\n>   2. Asynchronous calls with callbacks or futures\n>   3. Both options with a configuration flag\n> - **Decision**: Synchronous blocking calls only\n> - **Rationale**: Blocking calls are much simpler to implement and use, matching the mental model of \"remote calls that work like local calls.\" Async support adds significant complexity in error handling, timeout management, and API design.\n> - **Consequences**: Enables simple, intuitive client code but limits performance in scenarios requiring many concurrent calls\n\n### Component Interaction Patterns\n\nThe three components interact through well-defined interfaces and protocols. Understanding these interaction patterns is crucial for implementing each component correctly and debugging issues that span component boundaries.\n\n**Request Flow** follows a predictable sequence: the client proxy converts method calls to protocol messages, sends them over the network to the server, which deserializes the messages, executes the requested methods, and sends back protocol-formatted responses. Each step in this flow has specific responsibilities and error handling requirements.\n\n**Error Propagation** must work correctly across component boundaries. Server-side exceptions become RPC error messages, which the client converts back to Python exceptions. This requires consistent error classification and proper serialization of error details.\n\n**State Management** is distributed across components. The protocol component is stateless, handling individual messages independently. The server maintains method registry state and connection state. The client maintains connection state and tracks pending requests by ID.\n\n![RPC Framework System Overview](./diagrams/system-overview.svg)\n\n### Recommended File Structure\n\nOrganizing the RPC framework code into logical modules makes the implementation more maintainable and helps separate concerns clearly. The recommended structure follows Python packaging conventions while grouping related functionality together.\n\n```\nrpc_framework/\n├── __init__.py                 # Package initialization and public API\n├── protocol.py                 # Message protocol implementation\n├── server.py                   # RPC server implementation  \n├── client.py                   # RPC client implementation\n├── exceptions.py               # Exception hierarchy and error codes\n├── utils.py                    # Socket utilities and helpers\n└── examples/\n    ├── __init__.py\n    ├── calculator_server.py    # Example server with math functions\n    ├── calculator_client.py    # Example client usage\n    └── test_integration.py     # End-to-end integration tests\n```\n\nThis file organization supports the natural development progression through the three milestones. Each major component lives in its own module, making it easy to focus on one piece at a time while maintaining clear interfaces between components.\n\n#### Core Module Responsibilities\n\n**The `protocol.py` module** (Milestone 1) contains all message format definitions, serialization functions, and protocol constants. This module should be completely independent of networking code, focusing purely on message structure and wire format encoding. It exports the message creation functions, serialization utilities, and error code constants that other modules depend on.\n\n**The `server.py` module** (Milestone 2) implements the RPC server class, method registry, and request dispatch logic. This module imports the protocol module for message handling but is independent of client-side code. It exports the main server class and any server-specific configuration options.\n\n**The `client.py` module** (Milestone 3) implements the RPC client class, proxy object, and connection management. This module imports the protocol module for message handling but is independent of server-side code. It exports the main client class and proxy object that application code interacts with.\n\n**The `exceptions.py` module** defines the complete exception hierarchy used throughout the framework. This includes both protocol-level errors (like `RPCProtocolError`) and application-level errors (like `RPCMethodError`). Having all exceptions in one module makes error handling consistent across components.\n\n**The `utils.py` module** contains networking utilities and helper functions shared by both client and server. This includes the `SocketHelper` class with functions like `send_all`, `recv_all`, and `recv_message` that handle the low-level details of TCP communication with proper error handling.\n\n| Module | Primary Classes | Key Functions | Dependencies |\n|---|---|---|---|\n| `protocol.py` | `ErrorCode` | `create_request_message`, `serialize_message`, `generate_request_id` | None (pure protocol) |\n| `server.py` | `RPCServer` | `register_method`, `start_server`, `handle_request` | protocol, utils, exceptions |\n| `client.py` | `RPCClient`, `RPCProxy` | `call_method`, `connect`, `__getattr__` | protocol, utils, exceptions |\n| `exceptions.py` | `RPCError`, `RPCTimeoutError`, etc. | Exception constructors | None |\n| `utils.py` | `SocketHelper` | `send_all`, `recv_all`, `recv_message` | socket, struct |\n\n#### Development Workflow\n\nThe recommended file structure supports a natural development progression where each milestone builds on the previous one. **Milestone 1** focuses entirely on `protocol.py` and `exceptions.py`, allowing you to perfect message handling before dealing with networking complexity. **Milestone 2** adds `server.py` and the networking parts of `utils.py`, building the service side of the RPC system. **Milestone 3** completes the framework by implementing `client.py` and the proxy mechanism.\n\nThis structure also supports good testing practices. Each module can be unit tested independently, and the `examples/` directory provides integration tests that exercise the complete system. The examples serve both as test cases and as documentation showing how to use the framework.\n\n> **Implementation Insight**: Start each milestone by defining the public interface in `__init__.py`. This forces you to think about what other modules need from each component and helps maintain clean separation of concerns.\n\n### Implementation Guidance\n\nThe high-level architecture provides the foundation for implementing a working RPC framework. This guidance covers technology choices, starter code structure, and practical implementation approaches for each component.\n\n#### Technology Recommendations\n\n| Component | Simple Approach | Advanced Alternative |\n|---|---|---|\n| Message Protocol | JSON with length-prefix framing | MessagePack or Protocol Buffers |\n| Server Transport | Raw TCP sockets with blocking I/O | Async I/O with asyncio |\n| Client Transport | Raw TCP sockets with timeouts | HTTP/2 or connection pooling |\n| Serialization | Python json module | Custom binary protocol |\n| Error Handling | Exception-based with structured errors | Result types or error codes |\n| Method Registry | Simple dict mapping names to functions | Decorator-based registration |\n\nFor this educational implementation, we recommend the simple approaches. JSON is human-readable and easy to debug, raw TCP sockets expose the fundamental networking concepts, and exception-based error handling matches Python idioms.\n\n#### Project Structure Setup\n\nCreate the initial project structure with proper Python packaging:\n\n```python\n# rpc_framework/__init__.py\n\"\"\"Simple RPC Framework for educational purposes.\"\"\"\n\n__version__ = \"1.0.0\"\n\n# Public API - expose main classes\nfrom .server import RPCServer\nfrom .client import RPCClient\nfrom .exceptions import (\n    RPCError, \n    RPCProtocolError, \n    RPCTransportError, \n    RPCTimeoutError,\n    RPCMethodError\n)\n\n__all__ = [\n    'RPCServer', \n    'RPCClient', \n    'RPCError', \n    'RPCProtocolError', \n    'RPCTransportError', \n    'RPCTimeoutError',\n    'RPCMethodError'\n]\n```\n\n```python\n# rpc_framework/exceptions.py\n\"\"\"Exception hierarchy for RPC framework.\"\"\"\n\nclass RPCError(Exception):\n    \"\"\"Base class for all RPC-related errors.\"\"\"\n    pass\n\nclass RPCProtocolError(RPCError):\n    \"\"\"Raised when message format is invalid or cannot be parsed.\"\"\"\n    pass\n\nclass RPCTransportError(RPCError):\n    \"\"\"Raised when network communication fails.\"\"\"\n    pass\n\nclass RPCTimeoutError(RPCError):\n    \"\"\"Raised when request times out waiting for response.\"\"\"\n    pass\n\nclass RPCMethodError(RPCError):\n    \"\"\"Raised when remote method execution fails.\"\"\"\n    \n    def __init__(self, code, message, data=None):\n        self.code = code\n        self.message = message\n        self.data = data\n        super().__init__(f\"RPC Method Error {code}: {message}\")\n\nclass ErrorCode:\n    \"\"\"Standard JSON-RPC error codes.\"\"\"\n    PARSE_ERROR = -32700\n    INVALID_REQUEST = -32600\n    METHOD_NOT_FOUND = -32601\n    INVALID_PARAMS = -32602\n    INTERNAL_ERROR = -32603\n```\n\n#### Socket Utilities Infrastructure\n\nProvide complete socket helper functions that both client and server can use:\n\n```python\n# rpc_framework/utils.py\n\"\"\"Networking utilities for RPC framework.\"\"\"\n\nimport socket\nimport struct\nimport time\nfrom typing import Optional\nfrom .exceptions import RPCTransportError, RPCTimeoutError\n\nclass SocketHelper:\n    \"\"\"Utility class for reliable socket operations.\"\"\"\n    \n    @staticmethod\n    def send_all(sock: socket.socket, data: bytes, timeout: Optional[float] = None) -> None:\n        \"\"\"Send all bytes, handling partial sends and timeouts.\"\"\"\n        if timeout:\n            sock.settimeout(timeout)\n        \n        total_sent = 0\n        while total_sent < len(data):\n            try:\n                sent = sock.send(data[total_sent:])\n                if sent == 0:\n                    raise RPCTransportError(\"Socket connection broken during send\")\n                total_sent += sent\n            except socket.timeout:\n                raise RPCTimeoutError(f\"Send timeout after {timeout} seconds\")\n            except socket.error as e:\n                raise RPCTransportError(f\"Socket send error: {e}\")\n    \n    @staticmethod\n    def recv_all(sock: socket.socket, size: int, timeout: Optional[float] = None) -> bytes:\n        \"\"\"Receive exactly size bytes, handling partial receives and timeouts.\"\"\"\n        if timeout:\n            sock.settimeout(timeout)\n            \n        chunks = []\n        bytes_received = 0\n        \n        while bytes_received < size:\n            try:\n                chunk = sock.recv(min(size - bytes_received, 4096))\n                if not chunk:\n                    raise RPCTransportError(\"Socket connection closed during receive\")\n                chunks.append(chunk)\n                bytes_received += len(chunk)\n            except socket.timeout:\n                raise RPCTimeoutError(f\"Receive timeout after {timeout} seconds\")\n            except socket.error as e:\n                raise RPCTransportError(f\"Socket receive error: {e}\")\n        \n        return b''.join(chunks)\n    \n    @staticmethod\n    def recv_message(sock: socket.socket, timeout: Optional[float] = None) -> bytes:\n        \"\"\"Receive a length-prefixed message.\"\"\"\n        # First receive the 4-byte length header\n        length_data = SocketHelper.recv_all(sock, 4, timeout)\n        message_length = struct.unpack('!I', length_data)[0]\n        \n        # Then receive the message body\n        return SocketHelper.recv_all(sock, message_length, timeout)\n```\n\n#### Component Implementation Skeletons\n\nProvide skeletal implementations that define the interfaces and main methods without implementing the core logic:\n\n```python\n# rpc_framework/protocol.py\n\"\"\"Message protocol implementation for RPC framework.\"\"\"\n\nimport json\nimport struct\nimport uuid\nfrom typing import Dict, Any, Optional, Union\nfrom .exceptions import RPCProtocolError, ErrorCode\n\ndef generate_request_id() -> str:\n    \"\"\"Generate a unique request identifier.\"\"\"\n    # TODO: Return a unique string ID for correlating requests and responses\n    # Hint: uuid.uuid4().hex provides a good unique identifier\n    pass\n\ndef create_request_message(method: str, params: Any, request_id: str) -> Dict:\n    \"\"\"Create a JSON-RPC request message.\"\"\"\n    # TODO: Create dict with required fields: jsonrpc, method, params, id\n    # TODO: Validate that method is a string and request_id is provided\n    # TODO: Return properly formatted request message dict\n    pass\n\ndef create_response_message(request_id: str, result: Any) -> Dict:\n    \"\"\"Create a JSON-RPC response message for successful calls.\"\"\"\n    # TODO: Create dict with required fields: jsonrpc, result, id\n    # TODO: Ensure request_id matches the original request\n    # TODO: Return properly formatted response message dict\n    pass\n\ndef create_error_message(request_id: str, code: int, message: str, data: Optional[Any] = None) -> Dict:\n    \"\"\"Create a JSON-RPC error response message.\"\"\"\n    # TODO: Create dict with required fields: jsonrpc, error, id\n    # TODO: Error field should contain: code, message, and optional data\n    # TODO: Use standard error codes from ErrorCode class\n    # TODO: Return properly formatted error message dict\n    pass\n\ndef serialize_message(message: Dict) -> bytes:\n    \"\"\"Convert message dict to length-prefixed bytes for network transmission.\"\"\"\n    # TODO 1: Convert message dict to JSON string using json.dumps\n    # TODO 2: Encode JSON string to UTF-8 bytes\n    # TODO 3: Create 4-byte length prefix using struct.pack('!I', length)\n    # TODO 4: Concatenate length prefix + message bytes\n    # TODO 5: Handle JSON serialization errors and raise RPCProtocolError\n    # Hint: Use '!I' format for network byte order unsigned int\n    pass\n\ndef deserialize_message(data: bytes) -> Dict:\n    \"\"\"Parse length-prefixed bytes back to message dict.\"\"\"\n    # TODO 1: Extract 4-byte length prefix using struct.unpack('!I', data[:4])\n    # TODO 2: Extract message bytes using the length: data[4:4+length]\n    # TODO 3: Decode message bytes from UTF-8 to string\n    # TODO 4: Parse JSON string to dict using json.loads\n    # TODO 5: Handle parsing errors and raise RPCProtocolError\n    # TODO 6: Validate message has required JSON-RPC fields\n    pass\n```\n\n```python\n# rpc_framework/server.py\n\"\"\"RPC Server implementation.\"\"\"\n\nimport socket\nimport json\nfrom typing import Dict, Callable, Any, Optional\nfrom .protocol import deserialize_message, serialize_message, create_response_message, create_error_message\nfrom .utils import SocketHelper\nfrom .exceptions import RPCError, RPCProtocolError, RPCTransportError, ErrorCode\n\nclass RPCServer:\n    \"\"\"RPC Server that handles method registration and request processing.\"\"\"\n    \n    def __init__(self, host: str = 'localhost', port: int = 8000):\n        self.host = host\n        self.port = port\n        self.methods: Dict[str, Callable] = {}\n        self.running = False\n    \n    def register_method(self, name: str, method: Callable) -> None:\n        \"\"\"Register a method that can be called remotely.\"\"\"\n        # TODO: Add method to self.methods dict with name as key\n        # TODO: Validate that method is callable\n        # TODO: Consider logging the registration for debugging\n        pass\n    \n    def start_server(self) -> None:\n        \"\"\"Start the RPC server and listen for connections.\"\"\"\n        # TODO 1: Create TCP socket using socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        # TODO 2: Set SO_REUSEADDR socket option to avoid \"Address already in use\" errors\n        # TODO 3: Bind socket to (self.host, self.port)\n        # TODO 4: Start listening with sock.listen()\n        # TODO 5: Set self.running = True\n        # TODO 6: Enter main server loop accepting connections\n        # TODO 7: For each connection, call self.handle_connection(client_sock)\n        # TODO 8: Handle KeyboardInterrupt to allow clean shutdown\n        pass\n    \n    def handle_connection(self, client_sock: socket.socket) -> None:\n        \"\"\"Handle a single client connection.\"\"\"\n        # TODO 1: Use SocketHelper.recv_message to receive request bytes\n        # TODO 2: Deserialize bytes to message dict using deserialize_message\n        # TODO 3: Call self.process_request(message) to get response\n        # TODO 4: Serialize response using serialize_message\n        # TODO 5: Send response using SocketHelper.send_all\n        # TODO 6: Close client socket\n        # TODO 7: Handle all exceptions and convert to error responses\n        pass\n    \n    def process_request(self, request: Dict) -> Dict:\n        \"\"\"Process an RPC request and return response or error.\"\"\"\n        # TODO 1: Validate request has required fields (jsonrpc, method, id)\n        # TODO 2: Extract method name from request\n        # TODO 3: Look up method in self.methods registry\n        # TODO 4: If method not found, return METHOD_NOT_FOUND error\n        # TODO 5: Extract params from request (handle missing params)\n        # TODO 6: Call method with params (handle *args and **kwargs)\n        # TODO 7: Return success response with result\n        # TODO 8: Catch exceptions and convert to INTERNAL_ERROR responses\n        pass\n```\n\n#### Milestone Checkpoints\n\nAfter implementing each component, verify it works with these checkpoints:\n\n**Milestone 1 Checkpoint (Protocol):**\n```python\n# Test basic protocol functionality\nfrom rpc_framework.protocol import generate_request_id, create_request_message, serialize_message, deserialize_message\n\n# Generate unique IDs\nid1 = generate_request_id()\nid2 = generate_request_id()\nassert id1 != id2, \"Request IDs should be unique\"\n\n# Create and serialize a request\nrequest = create_request_message(\"add\", [5, 3], id1)\nserialized = serialize_message(request)\ndeserialized = deserialize_message(serialized)\nassert deserialized == request, \"Round-trip serialization should preserve message\"\n\nprint(\"✅ Protocol component working correctly\")\n```\n\n**Milestone 2 Checkpoint (Server):**\n```python\n# Test server with simple method\nfrom rpc_framework import RPCServer\nimport threading\nimport time\n\ndef add(a, b):\n    return a + b\n\nserver = RPCServer(host='localhost', port=8001)\nserver.register_method('add', add)\n\n# Start server in background thread\nserver_thread = threading.Thread(target=server.start_server)\nserver_thread.daemon = True\nserver_thread.start()\ntime.sleep(0.1)  # Let server start\n\n# TODO: Send a raw JSON-RPC request using socket and verify response\nprint(\"✅ Server component working correctly\")\n```\n\n**Milestone 3 Checkpoint (Client):**\n```python\n# Test complete RPC call\nfrom rpc_framework import RPCServer, RPCClient\nimport threading\nimport time\n\n# Set up server (same as above)\n# Create client and make call\nclient = RPCClient(host='localhost', port=8001)\nresult = client.call('add', [5, 3])\nassert result == 8, f\"Expected 8, got {result}\"\n\nprint(\"✅ Complete RPC framework working correctly\")\n```\n\n#### Python-Specific Implementation Hints\n\n- **Use `json.dumps()` and `json.loads()`** for message serialization. Handle `JSONDecodeError` exceptions and convert them to `RPCProtocolError`.\n\n- **Use `struct.pack('!I', length)` and `struct.unpack('!I', data)`** for the 4-byte length prefix. The `!` ensures network byte order (big-endian).\n\n- **Use `socket.settimeout()`** for implementing client timeouts. Catch `socket.timeout` exceptions and convert to `RPCTimeoutError`.\n\n- **Use `uuid.uuid4().hex`** for generating unique request IDs. This provides sufficiently unique identifiers without collision concerns.\n\n- **Use `**kwargs` unpacking** when calling registered methods to handle both positional and keyword arguments from RPC calls.\n\n- **Use context managers** (`with` statements) for socket management to ensure proper cleanup even when exceptions occur.\n\n\n## Message Protocol Design\n\n> **Milestone(s):** Milestone 1 (Message Protocol) - defines request/response message format, serialization, and error handling\n\nThe message protocol serves as the common language between RPC clients and servers, defining how method calls are encoded, transmitted, and decoded across network boundaries. This protocol must handle the fundamental challenge of converting programming language function calls into structured messages that can travel over TCP connections and be reconstructed on the remote end.\n\n### Mental Model: The International Mail System\n\nThink of the RPC message protocol like the international postal system. When you send a letter to another country, you can't just write the address in your local format and hope it arrives. Instead, there's a standardized format that postal workers worldwide understand: recipient name, street address, city, postal code, and country, arranged in a specific order with clear delimiters.\n\nSimilarly, when a client wants to call a remote method, it can't just send \"call getUserById with parameter 123\" as plain text. The message must follow a structured format that both client and server understand: which method to call, what parameters to pass, how to identify this specific request, and how to handle the response or any errors that occur.\n\nJust as international mail includes return address information so replies can find their way back, RPC messages include request identifiers that allow responses to be matched with their original requests. And just as postal systems have standard procedures for handling undeliverable mail, RPC protocols define standard error codes and formats for when things go wrong.\n\n### Message Formats\n\nThe message protocol defines three fundamental message types that enable complete request-response communication cycles with comprehensive error handling.\n\n![Message Protocol Structure](./diagrams/message-formats.svg)\n\n#### Request Message Structure\n\nRequest messages carry method invocation information from client to server, including all necessary context for the server to locate and execute the requested function. Each request follows a standardized structure that ensures reliable method dispatch and response correlation.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `jsonrpc` | String | Protocol version identifier, always \"2.0\" for JSON-RPC compliance |\n| `method` | String | Name of the remote method to invoke, must match server registry |\n| `params` | Array or Object | Method parameters, either positional array or named object |\n| `id` | String or Number | Unique request identifier for correlating responses |\n\nThe `method` field specifies which registered server function to execute. Method names should follow clear naming conventions and must exactly match the names used when registering functions in the server's method registry. The server uses this string to perform method lookup and dispatch.\n\nThe `params` field carries the arguments to pass to the remote method. Parameters can be structured as either a JSON array for positional arguments or a JSON object for named arguments. The array format `[arg1, arg2, arg3]` passes arguments in order to the method signature, while the object format `{\"name\": \"value\", \"count\": 42}` allows parameter names to be specified explicitly.\n\nThe `id` field enables request-response correlation in concurrent environments where multiple requests may be in flight simultaneously. Each client-generated request must include a unique identifier that the server echoes back in the corresponding response message. This allows clients to match responses with their originating requests even when network delays cause responses to arrive out of order.\n\n#### Response Message Structure\n\nResponse messages carry successful method execution results back to the requesting client. The response structure mirrors the request format while providing the method's return value and maintaining request correlation.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `jsonrpc` | String | Protocol version identifier, always \"2.0\" |\n| `result` | Any | Method return value, can be any JSON-serializable type |\n| `id` | String or Number | Request identifier copied from the corresponding request |\n\nThe `result` field contains the actual return value from the executed method. This can be any JSON-serializable data type including strings, numbers, booleans, arrays, objects, or null. Complex return values like custom objects must be serializable to JSON, which may require custom serialization logic for certain data types.\n\nResponse messages must not contain both `result` and `error` fields. A successful method execution produces a response with a `result` field, while method failures produce error messages with an `error` field instead.\n\n#### Error Message Structure\n\nError messages communicate method execution failures, protocol violations, and system errors back to clients. The error structure provides detailed information about what went wrong and how clients might handle or recover from the failure.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `jsonrpc` | String | Protocol version identifier, always \"2.0\" |\n| `error` | Object | Error details containing code, message, and optional data |\n| `id` | String or Number or null | Request identifier, or null if request parsing failed |\n\nThe `error` field itself is an object containing structured error information that allows programmatic error handling and user-friendly error reporting.\n\n| Error Field | Type | Description |\n|-------------|------|-------------|\n| `code` | Integer | Numeric error code following JSON-RPC standard codes |\n| `message` | String | Human-readable error description |\n| `data` | Any (optional) | Additional error context like stack traces or validation details |\n\nStandard error codes follow the JSON-RPC specification to ensure consistent error handling across different RPC implementations. Pre-defined error codes cover common failure scenarios while custom application codes can address domain-specific errors.\n\n| Error Code | Constant Name | Description |\n|-----------|---------------|-------------|\n| -32700 | `PARSE_ERROR` | Invalid JSON received, cannot parse message |\n| -32600 | `INVALID_REQUEST` | JSON is valid but doesn't conform to RPC format |\n| -32601 | `METHOD_NOT_FOUND` | Requested method not registered on server |\n| -32602 | `INVALID_PARAMS` | Method parameters are invalid or missing |\n| -32603 | `INTERNAL_ERROR` | Server internal error during method execution |\n\n### Serialization Strategy\n\nThe serialization strategy defines how structured message objects transform into byte streams for network transmission and how received byte streams reconstruct into message objects. This process must handle the challenges of network protocols that deliver unstructured byte streams rather than discrete messages.\n\n#### JSON Encoding Decisions\n\nJSON serves as the wire format for message serialization due to its widespread language support, human readability, and reasonable performance characteristics. While binary formats like MessagePack or Protocol Buffers offer better performance, JSON provides the best balance of simplicity and interoperability for an educational RPC framework.\n\n> **Decision: JSON Wire Format**\n> - **Context**: Need a serialization format that balances simplicity, readability, and cross-language support for an educational RPC framework\n> - **Options Considered**: \n>   - JSON: Human-readable, widely supported, simple parsing\n>   - MessagePack: More compact, faster parsing, binary format\n>   - Protocol Buffers: Excellent performance, requires schema definition\n> - **Decision**: Use JSON as the primary serialization format\n> - **Rationale**: JSON maximizes learning value by being human-readable during debugging, has universal language support, and requires minimal setup complexity. Performance is not critical for educational use cases.\n> - **Consequences**: Slightly larger message sizes and slower parsing compared to binary formats, but greatly improved debugging experience and implementation simplicity.\n\n#### Message Framing Protocol\n\nTCP connections provide a continuous byte stream rather than discrete message boundaries, creating the fundamental challenge of determining where one message ends and the next begins. The message framing protocol solves this by prefixing each JSON message with a length header that specifies the exact number of bytes in the following message.\n\nThe length prefix consists of a 4-byte big-endian unsigned integer that specifies the length of the JSON message in bytes. This approach provides several advantages over alternative framing strategies:\n\n1. **Fixed-size header**: The receiver always knows to read exactly 4 bytes for the length field\n2. **Binary length encoding**: More efficient than text-based length prefixes\n3. **Maximum message size**: 4 bytes allows messages up to 4GB, far exceeding practical needs\n4. **Simple parsing**: No need to scan for delimiters or escape sequences\n\nThe complete wire format structure follows this pattern:\n```\n[4-byte length][JSON message bytes]\n```\n\nFor example, a 45-byte JSON message would be transmitted as a 4-byte big-endian integer containing the value 45, followed immediately by the 45 bytes of JSON data.\n\n#### Parameter Type Handling\n\nJSON's limited type system requires careful handling of programming language types that don't map directly to JSON primitives. The protocol defines standard mappings between common language types and JSON representations.\n\n| Language Type | JSON Representation | Handling Notes |\n|---------------|-------------------|----------------|\n| String | JSON string | Direct mapping, UTF-8 encoding |\n| Integer | JSON number | Direct mapping, 64-bit precision |\n| Float | JSON number | Direct mapping, may lose precision |\n| Boolean | JSON boolean | Direct mapping |\n| Null/None | JSON null | Direct mapping |\n| Array/List | JSON array | Recursive serialization of elements |\n| Object/Dict | JSON object | String keys required, recursive values |\n| Date/Time | ISO 8601 string | Custom serialization required |\n| Binary Data | Base64 string | Custom encoding required |\n\nCustom types that don't map directly to JSON require application-specific serialization logic. The protocol supports this through the `data` field in error messages, which can contain arbitrary structured information about serialization failures or type conversion errors.\n\n> **Decision: Strict JSON Type Mapping**\n> - **Context**: Programming languages have richer type systems than JSON supports natively\n> - **Options Considered**:\n>   - Strict JSON mapping with custom type serialization\n>   - Extended JSON with type annotations\n>   - Binary serialization for complex types\n> - **Decision**: Use strict JSON mapping with explicit custom serialization for unsupported types\n> - **Rationale**: Maintains protocol simplicity and JSON compatibility while making type conversion explicit and controllable by the application\n> - **Consequences**: Applications must handle custom type serialization explicitly, but the protocol remains simple and debuggable\n\n#### Serialization Error Handling\n\nSerialization failures can occur at multiple points in the message lifecycle: when creating request messages, when serializing responses, or when deserializing received data. The protocol defines specific error handling strategies for each scenario.\n\nRequest serialization errors occur on the client side when method parameters cannot be converted to JSON. These errors should be raised as `RPCProtocolError` exceptions immediately, without sending any message to the server.\n\nResponse serialization errors occur on the server side when method return values cannot be converted to JSON. The server should catch these errors and send an `INTERNAL_ERROR` response instead of the failed serialization.\n\nDeserialization errors occur when parsing received JSON data that is malformed or doesn't conform to the expected message structure. These should generate `PARSE_ERROR` or `INVALID_REQUEST` responses depending on whether the JSON itself is malformed or just doesn't match the RPC message format.\n\n### Implementation Guidance\n\nThe message protocol implementation provides the foundation for all client-server communication, focusing on robust serialization, proper message framing, and comprehensive error handling.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| JSON Library | `json` (built-in) | `ujson` for performance |\n| Message Framing | Manual length prefix | Custom protocol library |\n| Error Handling | Exception hierarchy | Result/Maybe types |\n| ID Generation | `uuid.uuid4()` | Timestamp + counter |\n\n#### Core Protocol Implementation\n\nThe message protocol implementation centers around message creation, serialization, and deserialization functions that handle the complete message lifecycle.\n\n```python\nimport json\nimport struct\nimport uuid\nfrom typing import Dict, Any, Union, Optional\n\nclass ErrorCode:\n    \"\"\"Standard JSON-RPC error codes.\"\"\"\n    PARSE_ERROR = -32700\n    INVALID_REQUEST = -32600\n    METHOD_NOT_FOUND = -32601\n    INVALID_PARAMS = -32602\n    INTERNAL_ERROR = -32603\n\nclass RPCError(Exception):\n    \"\"\"Base class for all RPC errors.\"\"\"\n    pass\n\nclass RPCProtocolError(RPCError):\n    \"\"\"Raised when message format is invalid.\"\"\"\n    pass\n\nclass RPCTransportError(RPCError):\n    \"\"\"Raised when network communication fails.\"\"\"\n    pass\n\nclass RPCTimeoutError(RPCError):\n    \"\"\"Raised when request times out.\"\"\"\n    pass\n\nclass RPCMethodError(RPCError):\n    \"\"\"Raised when method execution fails.\"\"\"\n    def __init__(self, code: int, message: str, data: Any = None):\n        self.code = code\n        self.message = message\n        self.data = data\n        super().__init__(f\"RPC Error {code}: {message}\")\n\ndef generate_request_id() -> str:\n    \"\"\"Generate unique request ID for correlation.\"\"\"\n    # TODO: Return string representation of UUID4\n    # Hint: Use str(uuid.uuid4()) for simplicity\n    pass\n\ndef create_request_message(method: str, params: Union[list, dict], request_id: str) -> Dict:\n    \"\"\"Create JSON-RPC request message.\"\"\"\n    # TODO 1: Create message dict with jsonrpc=\"2.0\"\n    # TODO 2: Add method name from parameter\n    # TODO 3: Add params (can be list or dict)\n    # TODO 4: Add request_id for response correlation\n    # TODO 5: Return complete message dict\n    pass\n\ndef create_response_message(request_id: str, result: Any) -> Dict:\n    \"\"\"Create JSON-RPC response message.\"\"\"\n    # TODO 1: Create message dict with jsonrpc=\"2.0\"\n    # TODO 2: Add result field with method return value\n    # TODO 3: Add id field copied from request\n    # TODO 4: Return complete message dict\n    # Note: Response must not have both result and error fields\n    pass\n\ndef create_error_message(request_id: Optional[str], code: int, message: str, data: Any = None) -> Dict:\n    \"\"\"Create JSON-RPC error message.\"\"\"\n    # TODO 1: Create message dict with jsonrpc=\"2.0\"\n    # TODO 2: Create error object with code and message\n    # TODO 3: Add data to error object if provided\n    # TODO 4: Add error object to message\n    # TODO 5: Add id field (can be None if request parsing failed)\n    # TODO 6: Return complete error message dict\n    pass\n\ndef serialize_message(message: Dict) -> bytes:\n    \"\"\"Convert message dict to length-prefixed bytes.\"\"\"\n    # TODO 1: Convert message dict to JSON string using json.dumps()\n    # TODO 2: Encode JSON string to UTF-8 bytes\n    # TODO 3: Get byte length of JSON data\n    # TODO 4: Create 4-byte big-endian length prefix using struct.pack('>I', length)\n    # TODO 5: Return length prefix + JSON bytes\n    # Handle: json.JSONEncodeError should raise RPCProtocolError\n    pass\n\ndef deserialize_message(data: bytes) -> Dict:\n    \"\"\"Parse length-prefixed bytes to message dict.\"\"\"\n    # TODO 1: Check that data has at least 4 bytes for length prefix\n    # TODO 2: Unpack length from first 4 bytes using struct.unpack('>I', data[:4])\n    # TODO 3: Extract JSON bytes using the length (data[4:4+length])\n    # TODO 4: Decode JSON bytes to UTF-8 string\n    # TODO 5: Parse JSON string to dict using json.loads()\n    # TODO 6: Validate message has required fields (jsonrpc, etc.)\n    # TODO 7: Return message dict\n    # Handle: struct.error, UnicodeDecodeError, json.JSONDecodeError should raise RPCProtocolError\n    pass\n```\n\n#### Message Validation Logic\n\nRobust message validation ensures that all received messages conform to the JSON-RPC specification before processing.\n\n```python\ndef validate_request_message(message: Dict) -> None:\n    \"\"\"Validate request message format.\"\"\"\n    # TODO 1: Check jsonrpc field is present and equals \"2.0\"\n    # TODO 2: Check method field is present and is a string\n    # TODO 3: Check id field is present (string, number, or None)\n    # TODO 4: Check params field if present is list or dict\n    # TODO 5: Raise RPCProtocolError with descriptive message for any validation failure\n    # Hint: Use isinstance() to check types\n    pass\n\ndef validate_response_message(message: Dict) -> None:\n    \"\"\"Validate response message format.\"\"\"\n    # TODO 1: Check jsonrpc field is present and equals \"2.0\"\n    # TODO 2: Check id field is present\n    # TODO 3: Check exactly one of 'result' or 'error' field is present\n    # TODO 4: If error field present, validate error object structure\n    # TODO 5: Raise RPCProtocolError for validation failures\n    pass\n\ndef validate_error_object(error: Dict) -> None:\n    \"\"\"Validate error object structure.\"\"\"\n    # TODO 1: Check error is a dict\n    # TODO 2: Check 'code' field is present and is an integer\n    # TODO 3: Check 'message' field is present and is a string\n    # TODO 4: Check 'data' field if present is JSON-serializable\n    # TODO 5: Raise RPCProtocolError for validation failures\n    pass\n```\n\n#### Socket Helper Utilities\n\nNetwork communication requires careful handling of partial sends and receives that can occur with TCP sockets.\n\n```python\nimport socket\nimport time\nfrom typing import Optional\n\nclass SocketHelper:\n    \"\"\"Utility class for reliable socket operations.\"\"\"\n    \n    @staticmethod\n    def send_all(sock: socket.socket, data: bytes, timeout: Optional[float] = None) -> None:\n        \"\"\"Send all bytes handling partial sends.\"\"\"\n        # TODO 1: Set socket timeout if specified\n        # TODO 2: Track total bytes sent and remaining data\n        # TODO 3: Loop while data remains to send\n        # TODO 4: Call sock.send() with remaining data\n        # TODO 5: Update sent counter and slice remaining data\n        # TODO 6: Handle socket.error exceptions as RPCTransportError\n        # Note: send() may not send all bytes at once\n        pass\n    \n    @staticmethod\n    def recv_all(sock: socket.socket, size: int, timeout: Optional[float] = None) -> bytes:\n        \"\"\"Receive exactly size bytes.\"\"\"\n        # TODO 1: Set socket timeout if specified\n        # TODO 2: Initialize empty buffer for received data\n        # TODO 3: Loop until exactly size bytes received\n        # TODO 4: Call sock.recv() for remaining bytes needed\n        # TODO 5: Check for connection closed (empty recv result)\n        # TODO 6: Append received data to buffer\n        # TODO 7: Return complete buffer when size bytes received\n        # Handle: socket.error, socket.timeout as RPCTransportError\n        pass\n    \n    @staticmethod\n    def recv_message(sock: socket.socket, timeout: Optional[float] = None) -> bytes:\n        \"\"\"Receive length-prefixed message.\"\"\"\n        # TODO 1: Receive 4-byte length prefix using recv_all()\n        # TODO 2: Unpack length from prefix using struct.unpack('>I', prefix)\n        # TODO 3: Receive message bytes using recv_all() with unpacked length\n        # TODO 4: Return complete message bytes\n        # TODO 5: Handle struct.error as RPCProtocolError\n        pass\n```\n\n#### Parameter Type Serialization\n\nCustom serialization helpers handle types that don't map directly to JSON.\n\n```python\nimport datetime\nimport base64\nfrom decimal import Decimal\n\ndef serialize_custom_types(obj: Any) -> Any:\n    \"\"\"Convert custom types to JSON-serializable equivalents.\"\"\"\n    # TODO 1: Handle datetime objects by converting to ISO format string\n    # TODO 2: Handle Decimal objects by converting to float or string\n    # TODO 3: Handle bytes objects by converting to base64 string\n    # TODO 4: Handle set objects by converting to list\n    # TODO 5: Return obj unchanged if no custom serialization needed\n    # TODO 6: Recursively handle lists and dicts containing custom types\n    pass\n\ndef deserialize_custom_types(obj: Any, type_hints: Dict[str, type] = None) -> Any:\n    \"\"\"Convert JSON values back to custom types using type hints.\"\"\"\n    # TODO 1: Check if type_hints provided for this field\n    # TODO 2: Convert ISO format strings back to datetime if hinted\n    # TODO 3: Convert base64 strings back to bytes if hinted\n    # TODO 4: Convert lists back to sets if hinted\n    # TODO 5: Recursively handle nested structures\n    # TODO 6: Return obj unchanged if no conversion needed\n    pass\n```\n\n#### Milestone Checkpoints\n\nAfter implementing the message protocol, verify the following behavior:\n\n**Request Message Creation:**\n```python\n# Test that messages are created correctly\nrequest = create_request_message(\"getUserById\", [123], \"req-1\")\nassert request[\"jsonrpc\"] == \"2.0\"\nassert request[\"method\"] == \"getUserById\"\nassert request[\"params\"] == [123]\nassert request[\"id\"] == \"req-1\"\n```\n\n**Serialization Roundtrip:**\n```python\n# Test that messages serialize and deserialize correctly\noriginal = create_request_message(\"test\", {\"arg\": \"value\"}, \"test-id\")\nserialized = serialize_message(original)\ndeserialized = deserialize_message(serialized)\nassert deserialized == original\n```\n\n**Error Message Handling:**\n```python\n# Test that error messages are created correctly\nerror_msg = create_error_message(\"req-1\", ErrorCode.METHOD_NOT_FOUND, \"Method not found\")\nassert error_msg[\"error\"][\"code\"] == -32601\nassert \"Method not found\" in error_msg[\"error\"][\"message\"]\n```\n\n#### Common Pitfalls and Debugging\n\n⚠️ **Pitfall: Incorrect Length Prefix Byte Order**\nWhen implementing message framing, using little-endian instead of big-endian byte order causes length values to be misinterpreted, leading to connection hangs or protocol errors. Always use `'>I'` format in `struct.pack()` and `struct.unpack()` to ensure big-endian (network byte order) encoding.\n\n⚠️ **Pitfall: Partial JSON Message Parsing**\nAttempting to parse JSON before receiving the complete message (as indicated by the length prefix) results in JSON decode errors. Always receive exactly the number of bytes specified in the length prefix before calling `json.loads()`.\n\n⚠️ **Pitfall: Missing Request ID Validation**\nFailing to validate that request IDs are present and properly formatted breaks request-response correlation in concurrent scenarios. Always validate ID fields during message parsing and ensure they're echoed correctly in responses.\n\n⚠️ **Pitfall: JSON Serialization of Custom Types**\nPython objects that aren't JSON-serializable (like datetime, Decimal, or custom classes) cause `json.dumps()` to raise `TypeError`. Implement custom serialization logic or use the `default` parameter in `json.dumps()` to handle these types explicitly.\n\n⚠️ **Pitfall: Unicode Encoding Issues**\nForgetting to specify UTF-8 encoding when converting between strings and bytes can cause encoding errors with non-ASCII characters. Always use `.encode('utf-8')` and `.decode('utf-8')` explicitly when handling JSON message bytes.\n\n\n## Server Component Design\n\n> **Milestone(s):** Milestone 2 (Server Implementation) - builds the RPC server that registers methods, accepts connections, and dispatches requests to registered functions\n\nThe server component is the heart of our RPC framework, acting as the central dispatch point that receives remote method calls from clients and routes them to the appropriate local functions. The server must handle multiple concurrent connections, maintain a registry of callable methods, and gracefully manage errors while providing transparent remote access to local functionality.\n\n![Server Request Dispatch Flowchart](./diagrams/request-dispatch-flow.svg)\n\n### Mental Model: The Receptionist Pattern\n\nThink of the RPC server as a **corporate receptionist** working at the front desk of a large office building. Just as a receptionist receives phone calls from external visitors and routes them to the correct department or employee, the RPC server receives network requests from remote clients and routes them to the appropriate registered functions.\n\nThe receptionist analogy illuminates several key aspects of server design:\n\n**Call Routing**: When someone calls the main office number asking to speak with \"Dr. Smith in Cardiology,\" the receptionist doesn't need to know anything about cardiology procedures. They simply look up \"Dr. Smith\" in their directory and transfer the call. Similarly, when a client requests the method \"calculate_tax\" with parameters, the server looks up \"calculate_tax\" in its method registry and forwards the call to the registered function.\n\n**Multiple Simultaneous Calls**: A busy receptionist handles multiple phone lines simultaneously, placing some callers on hold while connecting others. The RPC server must handle multiple client connections concurrently, processing requests as they arrive without blocking other clients.\n\n**Error Handling**: When someone asks to speak with \"Dr. Johnson\" but no such person works at the hospital, the receptionist politely responds \"I'm sorry, we don't have a Dr. Johnson here.\" Similarly, when a client requests a non-existent method, the server responds with a structured error message rather than crashing.\n\n**Message Translation**: The receptionist might receive a call saying \"I need to speak to someone about my heart problem\" and translate this to \"connecting you to Cardiology.\" The server receives JSON-encoded method calls and translates them into actual Python function invocations with the correct parameters.\n\n**Directory Management**: The receptionist maintains an up-to-date directory of employees and departments. The server maintains a method registry mapping function names to callable Python objects.\n\nThis mental model helps us understand that the server's primary responsibility is **intelligent message routing** rather than performing the actual business logic. The registered methods contain the domain expertise; the server simply ensures that remote requests reach the right local functions with the correct parameters.\n\n### Method Registry\n\nThe **method registry** is the server's phone directory - a mapping from string method names to callable Python functions. This registry enables **dynamic method dispatch**, where the server can invoke different functions based on the method name received in client requests.\n\nThe registry design centers around a simple but powerful concept: **name-based function lookup**. Instead of hardcoding specific method calls, the server maintains a dictionary where keys are method names (strings) and values are callable objects. This approach provides flexibility and extensibility - new methods can be registered at runtime without modifying the server's core dispatch logic.\n\n| Registry Component | Type | Description | Example |\n|-------------------|------|-------------|---------|\n| Method Name | `str` | Unique identifier for the remote method | `\"calculate_tax\"` |\n| Handler Function | `Callable` | Python function that implements the method | `lambda rate, amount: amount * rate` |\n| Parameter Count | `int` | Expected number of parameters (optional validation) | `2` |\n| Documentation | `str` | Human-readable description (optional) | `\"Calculates tax given rate and amount\"` |\n\nThe registry supports several registration patterns to accommodate different use cases:\n\n**Direct Function Registration**: The simplest approach involves registering standalone functions by name. For example, registering a tax calculation function allows clients to call `calculate_tax(0.08, 100.0)` remotely.\n\n**Class Method Registration**: Object-oriented applications can register instance methods, enabling remote access to stateful operations. For instance, registering `user_service.create_user` allows clients to invoke methods on server-side service objects.\n\n**Lambda Registration**: Simple computations can be registered as lambda functions for lightweight remote operations. This pattern works well for mathematical calculations or data transformations.\n\n**Decorator-Based Registration**: A more elegant approach uses Python decorators to automatically register functions when they're defined. This reduces boilerplate and ensures that method registration happens alongside function definition.\n\n> **Key Design Insight**: The registry acts as a **capability list** - it explicitly defines which local functions are accessible to remote clients. This provides both security (unlisted functions cannot be called) and clarity (the registry serves as an API contract).\n\nMethod lookup follows a straightforward algorithm:\n\n1. Extract the method name from the incoming request message\n2. Check if the method name exists in the registry dictionary\n3. If found, retrieve the associated callable object\n4. If not found, prepare a METHOD_NOT_FOUND error response\n5. Return either the callable function or an error indicator\n\nThe registry implementation must consider **thread safety** since multiple client connections may perform method lookups simultaneously. Python's built-in dictionary provides thread-safe read operations, but method registration during server operation requires appropriate locking.\n\n| Registry Operation | Thread Safety | Performance | Use Case |\n|-------------------|---------------|-------------|----------|\n| Method Lookup | Thread-safe (read-only) | O(1) average | Request dispatch |\n| Method Registration | Requires locking | O(1) average | Server startup |\n| Method Unregistration | Requires locking | O(1) average | Dynamic updates |\n| Registry Enumeration | Requires snapshot | O(n) | Introspection |\n\n### Request Dispatch Algorithm\n\nThe **request dispatch algorithm** transforms incoming client messages into local function calls and converts the results back into response messages. This process involves message parsing, method lookup, parameter validation, function execution, and response serialization.\n\n![RPC Call Sequence](./diagrams/rpc-call-sequence.svg)\n\nThe dispatch algorithm operates as a **message transformation pipeline**, where each stage performs a specific transformation on the request data:\n\n1. **Message Reception**: The server receives length-prefixed JSON bytes from the client socket connection. The message framing ensures complete message boundaries in the TCP stream.\n\n2. **Deserialization**: The raw bytes are parsed as JSON and converted into a Python dictionary representing the request message. This stage can fail if the client sends malformed JSON.\n\n3. **Request Validation**: The server verifies that the message contains all required fields (`method`, `params`, `id`) and that field types match the JSON-RPC specification.\n\n4. **Method Lookup**: The server searches the method registry for a function matching the requested method name. This lookup determines whether the request can be fulfilled.\n\n5. **Parameter Preparation**: The parameter list from the request is unpacked for passing to the target function. This may involve type coercion or validation depending on the method's requirements.\n\n6. **Function Execution**: The server invokes the registered function with the provided parameters. This is where the actual business logic executes.\n\n7. **Result Handling**: The function's return value is captured and prepared for serialization. Exceptions during execution must be caught and converted to error responses.\n\n8. **Response Serialization**: The result or error is packaged into a JSON-RPC response message and serialized to bytes for transmission.\n\n9. **Message Transmission**: The response bytes are sent back to the client through the same socket connection that delivered the request.\n\nEach stage includes **error handling** that can terminate the pipeline early and generate an appropriate error response:\n\n| Error Type | Detection Stage | Error Code | Recovery Action |\n|------------|----------------|------------|-----------------|\n| Malformed JSON | Deserialization | `PARSE_ERROR` | Send error response if possible |\n| Missing Fields | Request Validation | `INVALID_REQUEST` | Send error response with details |\n| Unknown Method | Method Lookup | `METHOD_NOT_FOUND` | Send error response with method name |\n| Wrong Parameters | Parameter Preparation | `INVALID_PARAMS` | Send error response with expected signature |\n| Function Exception | Function Execution | `INTERNAL_ERROR` | Send error response with exception details |\n| Serialization Failure | Response Serialization | `INTERNAL_ERROR` | Log error and close connection |\n\nThe algorithm maintains **request context** throughout the pipeline to ensure proper error attribution and response correlation. Each request carries its unique ID from initial reception through final response transmission.\n\n> **Critical Design Decision**: The dispatch algorithm operates **synchronously** within each client connection. While the server handles multiple connections concurrently, individual requests execute sequentially within their connection context. This simplifies error handling and state management.\n\nThe dispatch process handles **parameter passing** by unpacking the JSON array into individual function arguments. For a request with `\"params\": [0.08, 100.0]`, the server calls `registered_function(0.08, 100.0)`. This approach supports positional parameters naturally while requiring careful parameter count validation.\n\n**Exception propagation** follows a convert-and-contain strategy. Python exceptions raised during method execution are caught, converted to JSON-RPC error responses, and sent to the client. The server continues operating normally after handling exceptions, ensuring that one client's error doesn't affect other connections.\n\n### Architecture Decision Records\n\n> **Decision: Synchronous Request Processing**\n> - **Context**: Each client connection must decide whether to process requests synchronously (one at a time) or asynchronously (multiple concurrent requests per connection)\n> - **Options Considered**: \n>   1. Synchronous processing with one request at a time per connection\n>   2. Asynchronous processing with multiple concurrent requests per connection\n>   3. Thread pool for request execution within each connection\n> - **Decision**: Synchronous request processing within each connection\n> - **Rationale**: Simplifies implementation for a beginner-level framework while still supporting multiple concurrent clients through separate connections. Eliminates race conditions and complex state management within connections.\n> - **Consequences**: Enables easier debugging and testing while limiting throughput for clients that could benefit from request pipelining. Acceptable trade-off for educational implementation.\n\n| Option | Pros | Cons | Complexity |\n|--------|------|------|------------|\n| Synchronous | Simple state management, easy debugging, predictable behavior | Lower throughput per connection, head-of-line blocking | Low |\n| Asynchronous | Higher throughput, request pipelining support | Complex error handling, race conditions, harder debugging | High |\n| Thread Pool | Balanced throughput and complexity | Thread overhead, synchronization issues | Medium |\n\n> **Decision: Thread-Per-Connection Model**\n> - **Context**: The server must handle multiple simultaneous client connections while maintaining isolation between clients\n> - **Options Considered**:\n>   1. Single-threaded event loop with select/poll\n>   2. Thread-per-connection model\n>   3. Thread pool with connection queuing\n> - **Decision**: Thread-per-connection model using Python threading\n> - **Rationale**: Provides natural isolation between clients and simplifies connection state management. Python's GIL limits true parallelism but still allows I/O concurrency for network operations.\n> - **Consequences**: Each connection gets dedicated thread context with simple blocking I/O. Memory overhead scales with connection count but remains manageable for typical RPC usage.\n\n| Option | Pros | Cons | Scalability |\n|--------|------|------|-------------|\n| Event Loop | Memory efficient, high scalability | Complex state machines, callback hell | High |\n| Thread-per-Connection | Simple programming model, natural isolation | Memory overhead, GIL limitations | Medium |\n| Thread Pool | Bounded resource usage, good for bursts | Complex work queuing, shared state issues | Medium |\n\n> **Decision: Exception-to-Error Response Conversion**\n> - **Context**: When registered methods throw exceptions, the server must decide how to communicate failures to clients\n> - **Options Considered**:\n>   1. Convert all exceptions to INTERNAL_ERROR responses\n>   2. Allow methods to raise specific RPC error exceptions\n>   3. Crash the server on any unhandled exception\n> - **Decision**: Convert Python exceptions to INTERNAL_ERROR responses with exception details in the data field\n> - **Rationale**: Provides robust error handling that doesn't crash the server while giving clients useful debugging information. Maintains service availability despite individual method failures.\n> - **Consequences**: Enables graceful degradation and easier debugging while potentially exposing internal implementation details to clients.\n\n| Option | Pros | Cons | Security |\n|--------|------|------|----------|\n| Generic Conversion | Simple, robust, maintains availability | Less specific error information | Medium |\n| Specific RPC Exceptions | Precise error communication, client-friendly | Requires method author cooperation | High |\n| Server Crash | Fails fast, obvious problems | Poor availability, affects all clients | Low |\n\n> **Decision: JSON-Only Parameter Serialization**\n> - **Context**: Client parameters must be converted from JSON to Python objects for function calls\n> - **Options Considered**:\n>   1. JSON-only with basic type mapping (str, int, float, bool, list, dict)\n>   2. Custom serialization with type hints and object reconstruction\n>   3. Binary serialization using pickle or msgpack\n> - **Decision**: JSON-only serialization with standard Python type mapping\n> - **Rationale**: Provides language-agnostic interoperability and simple implementation while supporting most common use cases. JSON types map naturally to Python built-ins.\n> - **Consequences**: Enables cross-language clients and simple debugging while limiting parameter types to JSON-compatible values.\n\n| Option | Pros | Cons | Interoperability |\n|--------|------|------|------------------|\n| JSON-Only | Language agnostic, simple, debuggable | Limited types, no custom objects | High |\n| Custom Serialization | Rich type support, Python-native | Complex, Python-specific clients | Low |\n| Binary | Efficient, type-preserving | Opaque, debugging difficulty | Medium |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Blocking Server with Long-Running Methods**\nWhen registered methods perform time-consuming operations like database queries or external API calls, they block the entire connection thread. Since our architecture uses one thread per connection, a slow method prevents that client from making additional requests until the current request completes.\n\n**Why it's wrong**: Clients expect responsiveness from RPC services. A method that takes 30 seconds to complete makes the connection unusable during that time, creating poor user experience and potential timeouts.\n\n**How to fix**: Implement request timeouts on both client and server sides. Consider moving long-running operations to background tasks and returning a job ID that clients can use to poll for results. For educational purposes, document this limitation and suggest that registered methods complete quickly.\n\n⚠️ **Pitfall: Registry Race Conditions During Dynamic Registration**\nIf the server allows method registration while handling client requests, concurrent access to the registry dictionary can cause race conditions. Python dictionaries aren't thread-safe for concurrent modifications, leading to corrupted state or KeyError exceptions.\n\n**Why it's wrong**: Race conditions create intermittent failures that are difficult to reproduce and debug. The server might crash or return inconsistent results depending on timing.\n\n**How to fix**: Use a threading lock (RLock) around registry modifications, or restrict method registration to server startup only. For read-heavy workloads, consider using a copy-on-write pattern where registry updates create new dictionary instances.\n\n⚠️ **Pitfall: Exposing Internal Functions Accidentally**\nDevelopers might register utility functions or internal helper methods that weren't intended for remote access. This creates security vulnerabilities and API confusion.\n\n**Why it's wrong**: Internal functions often assume trusted input or have side effects that shouldn't be accessible to remote clients. Exposing them violates the principle of least privilege and can lead to unintended system modifications.\n\n**How to fix**: Use explicit registration rather than automatic discovery. Consider implementing a decorator that marks functions as RPC-eligible, ensuring only intentionally exposed methods enter the registry. Review the registry contents during development.\n\n⚠️ **Pitfall: Poor Error Message Serialization**\nWhen converting Python exceptions to JSON error responses, including the full exception object or stack trace can cause serialization failures if the exception contains non-JSON-serializable data.\n\n**Why it's wrong**: Serialization failures during error handling can crash the connection or send malformed responses to clients. This creates cascading failures where error recovery itself fails.\n\n**How to fix**: Extract only the exception message string and type name for error responses. Use `str(exception)` and `type(exception).__name__` rather than trying to serialize the exception object directly. Test error paths with various exception types.\n\n⚠️ **Pitfall: Ignoring Parameter Count Validation**\nCalling Python functions with the wrong number of parameters causes TypeError exceptions, but these might not provide clear error messages for remote clients trying to understand the correct method signature.\n\n**Why it's wrong**: Generic \"TypeError: function() takes 2 positional arguments but 3 were given\" messages don't help remote clients understand the expected parameter format, leading to trial-and-error debugging.\n\n**How to fix**: Validate parameter count before function invocation and return INVALID_PARAMS errors with clear descriptions of the expected signature. Consider storing parameter metadata in the registry for better error messages.\n\n⚠️ **Pitfall: Connection Resource Leaks**\nFailing to properly close client sockets when connections end can exhaust the server's file descriptor limit, especially during testing with many short-lived connections.\n\n**Why it's wrong**: Resource leaks accumulate over time and can crash the server or prevent new connections. The operating system has limits on open file descriptors per process.\n\n**How to fix**: Use try-finally blocks or context managers to ensure socket cleanup. Implement proper connection termination handling that closes resources even when exceptions occur during request processing.\n\n### Implementation Guidance\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Threading | `threading.Thread` per connection | `concurrent.futures.ThreadPoolExecutor` |\n| Socket Handling | Raw `socket.socket` with manual framing | `socketserver.ThreadingTCPServer` |\n| Method Registry | Simple `dict` mapping | Class-based registry with validation |\n| Error Logging | Built-in `logging` module | Structured logging with JSON output |\n\n**Recommended File Structure:**\n\n```\nrpc_framework/\n  server/\n    __init__.py              ← exports RPCServer\n    registry.py              ← method registration logic  \n    server.py                ← main server implementation\n    connection.py            ← connection handling logic\n  protocol/\n    messages.py              ← from previous milestone\n    serialization.py         ← from previous milestone\n  common/\n    errors.py                ← RPC exception classes\n    socket_helper.py         ← socket utilities\n```\n\n**Socket Helper Infrastructure (Complete):**\n\n```python\nimport socket\nimport struct\nimport json\nimport time\nfrom typing import Dict, Any, Optional\n\nclass SocketHelper:\n    \"\"\"Utility class for socket operations with message framing.\"\"\"\n    \n    @staticmethod\n    def send_all(sock: socket.socket, data: bytes, timeout: float = 30.0) -> None:\n        \"\"\"Send all bytes, handling partial sends and timeouts.\"\"\"\n        sock.settimeout(timeout)\n        total_sent = 0\n        while total_sent < len(data):\n            try:\n                sent = sock.send(data[total_sent:])\n                if sent == 0:\n                    raise ConnectionError(\"Socket connection broken\")\n                total_sent += sent\n            except socket.timeout:\n                raise RPCTimeoutError(f\"Send timeout after {timeout}s\")\n    \n    @staticmethod\n    def recv_all(sock: socket.socket, size: int, timeout: float = 30.0) -> bytes:\n        \"\"\"Receive exact number of bytes.\"\"\"\n        sock.settimeout(timeout)\n        chunks = []\n        bytes_received = 0\n        while bytes_received < size:\n            try:\n                chunk = sock.recv(size - bytes_received)\n                if not chunk:\n                    raise ConnectionError(\"Socket connection broken\")\n                chunks.append(chunk)\n                bytes_received += len(chunk)\n            except socket.timeout:\n                raise RPCTimeoutError(f\"Receive timeout after {timeout}s\")\n        return b''.join(chunks)\n    \n    @staticmethod\n    def recv_message(sock: socket.socket, timeout: float = 30.0) -> bytes:\n        \"\"\"Receive a length-prefixed message.\"\"\"\n        # First receive 4-byte length prefix\n        length_bytes = SocketHelper.recv_all(sock, 4, timeout)\n        message_length = struct.unpack('>I', length_bytes)[0]\n        \n        # Then receive the actual message\n        return SocketHelper.recv_all(sock, message_length, timeout)\n    \n    @staticmethod\n    def send_message(sock: socket.socket, message_bytes: bytes, timeout: float = 30.0) -> None:\n        \"\"\"Send a length-prefixed message.\"\"\"\n        length_prefix = struct.pack('>I', len(message_bytes))\n        SocketHelper.send_all(sock, length_prefix + message_bytes, timeout)\n```\n\n**Method Registry Core (Complete):**\n\n```python\nimport threading\nfrom typing import Dict, Callable, Any, Optional\n\nclass MethodRegistry:\n    \"\"\"Thread-safe registry for RPC methods.\"\"\"\n    \n    def __init__(self):\n        self._methods: Dict[str, Callable] = {}\n        self._lock = threading.RLock()\n        self._descriptions: Dict[str, str] = {}\n    \n    def register_method(self, name: str, method: Callable, description: str = \"\") -> None:\n        \"\"\"Register a callable method by name.\"\"\"\n        with self._lock:\n            self._methods[name] = method\n            if description:\n                self._descriptions[name] = description\n    \n    def lookup_method(self, name: str) -> Optional[Callable]:\n        \"\"\"Look up a method by name. Thread-safe read operation.\"\"\"\n        return self._methods.get(name)\n    \n    def list_methods(self) -> Dict[str, str]:\n        \"\"\"Return a copy of all registered methods with descriptions.\"\"\"\n        with self._lock:\n            return {name: self._descriptions.get(name, \"No description\") \n                   for name in self._methods}\n    \n    def method_exists(self, name: str) -> bool:\n        \"\"\"Check if a method is registered.\"\"\"\n        return name in self._methods\n```\n\n**Server Core Logic Skeleton:**\n\n```python\nimport socket\nimport threading\nimport json\nimport logging\nfrom typing import Dict, Any\n\nclass RPCServer:\n    \"\"\"Simple RPC Server with method registry and connection handling.\"\"\"\n    \n    def __init__(self, host: str = 'localhost', port: int = 8000):\n        self.host = host\n        self.port = port\n        self.registry = MethodRegistry()\n        self.server_socket = None\n        self.running = False\n        self.logger = logging.getLogger(__name__)\n    \n    def register_method(self, name: str, method: Callable) -> None:\n        \"\"\"Register a method in the server's registry.\"\"\"\n        # TODO 1: Use the registry to register the method by name\n        # TODO 2: Log the registration for debugging\n        pass\n    \n    def start_server(self) -> None:\n        \"\"\"Start the RPC server and listen for connections.\"\"\"\n        # TODO 1: Create server socket and bind to host:port\n        # TODO 2: Start listening for connections (backlog=5)\n        # TODO 3: Set self.running = True\n        # TODO 4: Enter main accept loop, creating thread for each connection\n        # TODO 5: Handle KeyboardInterrupt for graceful shutdown\n        # Hint: Use threading.Thread(target=self.handle_connection, args=(client_sock,))\n        pass\n    \n    def handle_connection(self, client_sock: socket.socket) -> None:\n        \"\"\"Handle a single client connection.\"\"\"\n        try:\n            # TODO 1: Log the new connection\n            # TODO 2: Loop receiving messages until connection closes\n            # TODO 3: For each message, call process_request and send response\n            # TODO 4: Handle SocketHelper exceptions and close connection gracefully\n            # Hint: Use SocketHelper.recv_message() and SocketHelper.send_message()\n            pass\n        finally:\n            # TODO 5: Always close the client socket\n            pass\n    \n    def process_request(self, request_bytes: bytes) -> bytes:\n        \"\"\"Process a single RPC request and return response bytes.\"\"\"\n        try:\n            # TODO 1: Deserialize the request bytes to a dictionary\n            # TODO 2: Validate request has required fields (method, params, id)\n            # TODO 3: Look up the method in the registry\n            # TODO 4: If method not found, create METHOD_NOT_FOUND error response\n            # TODO 5: If found, call the method with params and create success response\n            # TODO 6: Handle any exceptions during method execution\n            # TODO 7: Serialize response dictionary to bytes and return\n            # Hint: Use deserialize_message() and serialize_message() from protocol\n            # Hint: Use create_response_message() and create_error_message()\n            pass\n        except json.JSONDecodeError:\n            # TODO 8: Handle JSON parsing errors with PARSE_ERROR response\n            pass\n        except Exception as e:\n            # TODO 9: Handle unexpected errors with INTERNAL_ERROR response\n            pass\n    \n    def stop_server(self) -> None:\n        \"\"\"Stop the server gracefully.\"\"\"\n        # TODO 1: Set self.running = False\n        # TODO 2: Close server socket if open\n        pass\n```\n\n**Milestone Checkpoint:**\n\nAfter implementing the server component, verify the following behavior:\n\n1. **Method Registration Test**: Create a simple function like `def add(a, b): return a + b`, register it with the server, and verify it appears in the registry.\n\n2. **Connection Handling Test**: Start the server and use telnet or a simple socket client to connect. The server should accept the connection without crashing.\n\n3. **Request Processing Test**: Send a properly formatted JSON-RPC request and verify you receive a JSON-RPC response. Use this test message:\n   ```json\n   {\"method\": \"add\", \"params\": [2, 3], \"id\": \"test-1\"}\n   ```\n\n4. **Error Handling Test**: Send an invalid request (malformed JSON or unknown method) and verify you receive an appropriate error response.\n\n5. **Concurrent Connection Test**: Open multiple connections simultaneously and verify the server handles them independently.\n\n**Language-Specific Hints:**\n\n- Use `socket.socket(socket.AF_INET, socket.SOCK_STREAM)` for TCP sockets\n- Set `socket.SO_REUSEADDR` to avoid \"Address already in use\" errors during testing\n- Use `threading.Thread(target=handler, args=(sock,), daemon=True)` for connection threads\n- Python's GIL limits true parallelism but allows I/O concurrency for socket operations\n- Use `logging.basicConfig(level=logging.INFO)` to see connection and request logs\n- Handle `ConnectionResetError` and `BrokenPipeError` for client disconnections\n\n\n## Client Component Design\n\n> **Milestone(s):** Milestone 3 (Client Implementation) - builds the RPC client that provides method proxying, manages network communication, and handles timeouts\n\nThe client component serves as the user-facing interface to the RPC framework, transforming local method calls into remote procedure calls and managing all the underlying network complexity. The client must provide a seamless experience where calling a remote function feels identical to calling a local function, while handling the inherent challenges of network communication, serialization, and error propagation.\n\n### Mental Model: The Secretary Pattern\n\nThink of the RPC client as your personal secretary who handles all your external communications. When you need to contact someone in another department, you don't dial the phone yourself, manage the conversation, or worry about busy signals. Instead, you simply tell your secretary \"I need to call the accounting department and ask them to calculate the tax for invoice #1234.\" Your secretary handles everything: looking up the phone number, making the call, translating your request into the proper format, waiting for the response, handling any errors (\"sorry, their line is busy, should I try again?\"), and finally delivering the result back to you in a format you can immediately use.\n\nThe RPC client works similarly. When your application code wants to call `remote.calculate_tax(invoice_id=\"1234\")`, the client proxy intercepts this call, translates it into a properly formatted RPC request message, manages the TCP connection to the server, sends the request, waits for the response, handles any network errors or timeouts, and finally returns the result as if it were a local function call. Just like a good secretary, the client handles all the complexity behind the scenes so you can focus on your actual work.\n\nThis mental model helps us understand the client's core responsibilities: **transparent proxying** (making remote calls look local), **connection management** (maintaining reliable communication channels), **request tracking** (ensuring responses match requests), and **error translation** (converting network failures into meaningful exceptions).\n\n### Method Proxying\n\nMethod proxying is the mechanism that creates the illusion of local function calls for remote procedures. The proxy object intercepts method calls using language-specific metaprogramming features and converts them into RPC requests. This requires careful handling of method names, parameter serialization, and response deserialization.\n\nThe proxy object acts as a stand-in for the remote service, implementing the same interface but routing calls over the network instead of executing them locally. When a method is called on the proxy, it captures the method name and arguments, creates an RPC request message using the protocol defined in Milestone 1, sends it to the server, waits for the response, and returns the result or raises an appropriate exception.\n\nThe key challenge in method proxying is maintaining the natural feel of local method calls while handling the additional complexity of network communication. This includes preserving parameter types through serialization, maintaining call semantics (synchronous by default), and translating remote errors into local exceptions.\n\n> **Design Insight**: The proxy pattern is crucial for RPC adoption because it eliminates the mental overhead of thinking about network details. Developers can write `result = calculator.add(5, 3)` instead of `result = rpc_client.call(\"add\", [5, 3])`, making remote calls feel natural and reducing cognitive load.\n\n**Proxy Object Structure:**\n\n| Component | Type | Description |\n|-----------|------|-------------|\n| `client` | `RPCClient` | Reference to the underlying RPC client that manages connections |\n| `timeout` | `float` | Default timeout for method calls in seconds |\n| `_method_cache` | `Dict[str, Callable]` | Cache of dynamically created method proxies for performance |\n\n**Method Proxy Interface:**\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `__getattr__` | `name: str` | `Callable` | Dynamically creates proxy methods for any attribute access |\n| `__call__` | `*args, **kwargs` | `Any` | Executes the actual RPC call when proxy method is invoked |\n| `_create_method_proxy` | `method_name: str` | `Callable` | Creates a callable that captures method name and forwards to RPC client |\n| `_validate_parameters` | `args: Tuple, kwargs: Dict` | `None` | Ensures parameters are JSON-serializable before sending |\n\nThe method proxying implementation uses Python's `__getattr__` magic method to intercept attribute access and return callable objects that perform RPC calls. When code calls `proxy.method_name(arg1, arg2)`, Python first calls `proxy.__getattr__(\"method_name\")` which returns a callable, then immediately calls that callable with the provided arguments.\n\n**Method Proxying Algorithm:**\n\n1. Application code calls a method on the proxy object (e.g., `proxy.calculate_tax(invoice_id=\"1234\")`)\n2. Python's attribute resolution triggers `__getattr__(\"calculate_tax\")`\n3. The proxy checks its method cache for an existing proxy function for this method name\n4. If not cached, it creates a new proxy function that captures the method name and stores it in the cache\n5. The proxy function is returned to Python, which immediately calls it with the provided arguments\n6. Inside the proxy function, parameters are validated for JSON serializability\n7. A unique request ID is generated using `generate_request_id()`\n8. The request message is created using `create_request_message(method_name, args, request_id)`\n9. The request is sent to the server via the underlying `RPCClient`\n10. The proxy function blocks waiting for the response with the matching request ID\n11. When the response arrives, it's either returned as the method result or converted to an exception\n12. The final result is returned to the application code as if it were a local function call\n\n> **Critical Design Decision**: We choose to make method calls synchronous (blocking) by default because this matches the semantics of local function calls and is easier for beginners to understand. Asynchronous support can be added later as an advanced feature.\n\n### Connection Management\n\nConnection management handles the TCP socket lifecycle, including establishing connections, reusing connections for multiple requests, handling connection failures, and properly closing connections when done. Effective connection management is crucial for both performance and reliability.\n\nThe client must decide whether to create a new connection for each RPC call or reuse connections across multiple calls. Connection reuse improves performance by avoiding the overhead of TCP handshakes, but introduces complexity around connection state management, error recovery, and concurrent access.\n\nFor this educational framework, we choose a simple connection-per-client model where each `RPCClient` instance maintains a single TCP connection that is established on first use and reused for all subsequent calls from that client instance. This strikes a balance between simplicity and performance while avoiding the complexity of connection pooling.\n\n> **Decision: Connection Reuse Strategy**\n> - **Context**: Each RPC call could create a new TCP connection or reuse an existing connection, with trade-offs between simplicity and performance\n> - **Options Considered**: \n>   1. New connection per call (simple but slow)\n>   2. Single persistent connection per client (balanced)\n>   3. Connection pool with multiple connections (complex but scalable)\n> - **Decision**: Single persistent connection per client instance\n> - **Rationale**: Provides good performance for typical usage patterns while keeping implementation simple. Most applications create one client instance and make many calls, so connection reuse provides significant benefits without the complexity of pool management.\n> - **Consequences**: Better performance than connection-per-call, simpler than connection pooling, but limits concurrency to one outstanding request per client instance.\n\n**Connection Management States:**\n\n| State | Description | Valid Transitions | Trigger Events |\n|-------|-------------|------------------|----------------|\n| `Disconnected` | No active connection, client is ready to connect | `Connecting` | First RPC call made |\n| `Connecting` | TCP connection establishment in progress | `Connected`, `Failed` | Socket connect completes or times out |\n| `Connected` | Active connection ready for requests | `Sending`, `Disconnected` | RPC call made or connection error detected |\n| `Sending` | Request being sent over connection | `Waiting`, `Failed` | Send completes or socket error occurs |\n| `Waiting` | Waiting for response from server | `Receiving`, `Timeout`, `Failed` | Response arrives, timeout expires, or connection error |\n| `Receiving` | Reading response from server | `Connected`, `Failed` | Response fully received or read error |\n| `Failed` | Connection failed and needs to be reset | `Disconnected` | Error handled and connection cleaned up |\n| `Timeout` | Request timed out waiting for response | `Disconnected` | Timeout handled and connection closed |\n\n**Connection Management Interface:**\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `_ensure_connected` | `timeout: float` | `None` | Establishes connection if not already connected, raises `RPCTransportError` on failure |\n| `_disconnect` | `None` | `None` | Closes the connection and resets state to disconnected |\n| `_is_connected` | `None` | `bool` | Checks if the connection is active and healthy |\n| `_handle_connection_error` | `error: Exception` | `None` | Handles connection failures by cleaning up and transitioning to failed state |\n| `_reset_connection` | `None` | `None` | Forces connection reset for recovery from errors |\n\n**Connection Establishment Algorithm:**\n\n1. Client receives an RPC call and checks if connection exists and is healthy\n2. If no connection exists, create a new TCP socket using the configured host and port\n3. Set socket options for timeout and TCP keepalive to detect dead connections\n4. Attempt to connect to the server with the specified connection timeout\n5. If connection fails, raise `RPCTransportError` with details about the failure\n6. If connection succeeds, store the socket and transition to connected state\n7. For subsequent calls, reuse the existing connection if it's still healthy\n8. If the connection becomes unhealthy (detected during send/receive), close it and establish a new one\n\nThe connection health check is performed before each RPC call by attempting to send/receive with a very short timeout. If this fails, the connection is considered dead and must be re-established. This handles cases where the server has closed the connection or network connectivity has been lost.\n\n> **Implementation Note**: Connection establishment should use a configurable timeout (default 5 seconds) to avoid hanging indefinitely when the server is unreachable. The timeout should be shorter than typical RPC call timeouts to provide fast feedback.\n\n### Timeout and ID Tracking\n\nTimeout and ID tracking ensures that RPC calls don't hang indefinitely and that responses are correctly matched to their originating requests. This is particularly important in network programming where messages can be delayed, reordered, or lost entirely.\n\nEach RPC request is assigned a unique request ID that allows the client to correlate responses with their originating requests. The client maintains a mapping of outstanding request IDs to their associated metadata (start time, timeout deadline, response callback) and actively monitors for timeouts.\n\nThe timeout mechanism prevents clients from blocking forever when servers are unresponsive or when network connectivity is lost. When a timeout occurs, the client should clean up the pending request, close the connection (since the server may still send a late response), and raise a `RPCTimeoutError` to the calling code.\n\n> **Design Challenge**: The biggest challenge in timeout handling is deciding what to do with late responses. If a request times out but the server eventually sends a response, should we ignore it, log it, or handle it somehow? For simplicity, we close the connection on timeout to avoid out-of-order message handling.\n\n**Request Tracking Structure:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `request_id` | `str` | Unique identifier for this request, generated by `generate_request_id()` |\n| `method_name` | `str` | Name of the remote method being called |\n| `start_time` | `float` | Timestamp when request was sent (from `time.time()`) |\n| `timeout_deadline` | `float` | Absolute time when request should timeout (`start_time + timeout`) |\n| `response_received` | `bool` | Flag indicating whether response has been received |\n| `result` | `Any` | Response result or error, set when response arrives |\n| `condition` | `threading.Condition` | Synchronization primitive for blocking until response or timeout |\n\n**Timeout Management Interface:**\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `_track_request` | `request_id: str, timeout: float` | `None` | Registers new request for timeout monitoring |\n| `_wait_for_response` | `request_id: str` | `Dict` | Blocks until response received or timeout occurs |\n| `_handle_response` | `response: Dict` | `None` | Processes incoming response and notifies waiting threads |\n| `_cleanup_request` | `request_id: str` | `None` | Removes request from tracking and releases resources |\n| `_check_timeout` | `request_id: str` | `bool` | Checks if request has exceeded its timeout deadline |\n\n**Request ID Generation Strategy:**\n\nRequest IDs must be unique within the lifetime of a client instance to avoid response mismatching. A simple approach is to combine a timestamp with a counter, or use a UUID. The ID should be short enough to minimize message overhead but unique enough to avoid collisions.\n\n```\nRequest ID Format: f\"{int(time.time() * 1000000)}-{counter}\"\nExample: \"1640995200123456-1\", \"1640995200123457-2\"\n```\n\nThis format provides microsecond timestamp precision combined with a sequential counter, making IDs unique and sortable while remaining human-readable for debugging.\n\n**Timeout Handling Algorithm:**\n\n1. When an RPC call begins, generate a unique request ID and calculate the timeout deadline\n2. Register the request in the tracking dictionary with its metadata and synchronization objects\n3. Send the request message to the server over the TCP connection\n4. Start blocking wait on the condition variable with the calculated timeout duration\n5. If a response arrives before timeout, `_handle_response` notifies the condition variable and the wait returns\n6. If the timeout expires first, clean up the request, close the connection, and raise `RPCTimeoutError`\n7. Background response handling checks incoming message IDs against tracked requests\n8. When a matching response is found, store the result and notify the waiting thread\n9. If an unmatched response arrives (expired request), log it and discard it\n\nThe timeout calculation should account for both network latency and server processing time. A reasonable default is 30 seconds for most applications, with the ability to customize per-call or per-client.\n\n> **Concurrency Consideration**: If we later add support for concurrent requests from a single client, the request tracking system is already designed to handle this with per-request condition variables and thread-safe dictionaries.\n\n### Architecture Decision Records\n\n> **Decision: Synchronous vs Asynchronous Client API**\n> - **Context**: RPC calls could be synchronous (blocking until response) or asynchronous (return immediately with future/callback), affecting both API design and implementation complexity\n> - **Options Considered**:\n>   1. Synchronous only (simple, matches local call semantics)\n>   2. Asynchronous only (complex, requires event loop or callback handling)\n>   3. Both synchronous and asynchronous APIs (flexible but doubles implementation complexity)\n> - **Decision**: Synchronous only for this educational framework\n> - **Rationale**: Synchronous calls match the semantics of local function calls, making the RPC abstraction more natural. Implementation is significantly simpler without callback management or event loops. Most RPC use cases can tolerate blocking calls, and async can be added later.\n> - **Consequences**: Simple implementation and natural API, but limits throughput for I/O-bound applications that could benefit from async concurrency.\n\n| Option | Pros | Cons |\n|--------|------|------|\n| Synchronous Only | Simple implementation, natural API, matches local calls | Blocks threads, limited concurrency |\n| Asynchronous Only | High concurrency, non-blocking | Complex implementation, unnatural API for beginners |\n| Both APIs | Flexible, covers all use cases | Double implementation complexity, API confusion |\n\n> **Decision: Connection Pooling vs Single Connection**\n> - **Context**: Clients could use a pool of connections for higher concurrency or a single connection per client for simplicity\n> - **Options Considered**:\n>   1. Single persistent connection per client (simple, adequate for most use cases)\n>   2. Connection pool with multiple connections (complex, supports high concurrency)\n>   3. New connection per request (very simple but poor performance)\n> - **Decision**: Single persistent connection per client instance\n> - **Rationale**: Most applications create one client instance and use it throughout the program lifetime. A single connection provides good performance through reuse while avoiding the complexity of pool management, sizing, and cleanup.\n> - **Consequences**: Good performance for typical usage, simple implementation, but limits each client instance to one outstanding request at a time.\n\n| Option | Pros | Cons |\n|--------|------|------|\n| Single Connection | Simple, good performance, easy connection management | No concurrency within one client |\n| Connection Pool | High concurrency, optimal resource usage | Complex implementation, pool sizing decisions |\n| Per-Request Connection | Very simple, no state management | Poor performance, high overhead |\n\n> **Decision: Error Handling Strategy**\n> - **Context**: Network and RPC errors need to be presented to application code in a way that's both informative and actionable\n> - **Options Considered**:\n>   1. Generic exceptions with error codes (simple but less type-safe)\n>   2. Specific exception types for each error category (more complex but better handling)\n>   3. Error return values instead of exceptions (doesn't match Python conventions)\n> - **Decision**: Specific exception hierarchy with `RPCError` base class\n> - **Rationale**: Python developers expect exceptions for error conditions. Specific exception types allow application code to handle different error categories appropriately (retry network errors, don't retry method not found errors).\n> - **Consequences**: More exception classes to implement and document, but better error handling capabilities and more Pythonic API design.\n\n| Option | Pros | Cons |\n|--------|------|------|\n| Specific Exception Types | Type-safe, targeted handling, clear semantics | More classes to implement |\n| Generic Exceptions | Simple implementation, fewer classes | Less precise error handling |\n| Error Return Values | Explicit error checking | Un-Pythonic, easy to ignore errors |\n\n> **Decision: Request ID Format**\n> - **Context**: Request IDs must be unique within client lifetime and should be efficient to generate and compare\n> - **Options Considered**:\n>   1. Sequential integers (simple but not globally unique)\n>   2. UUIDs (globally unique but longer and less human-readable)\n>   3. Timestamp + counter combination (unique, sortable, readable)\n> - **Decision**: Timestamp + counter combination format\n> - **Rationale**: Provides uniqueness within client lifetime (sufficient for our use case), remains human-readable for debugging, and creates sortable IDs that can help with troubleshooting message ordering issues.\n> - **Consequences**: Slightly more complex ID generation than simple counters, but much more debuggable than UUIDs and adequate uniqueness for single-client scenarios.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Forgetting to Handle Connection Failures During RPC Calls**\n\nMany beginners assume that once a connection is established, it will remain healthy for the duration of the program. However, network connections can fail at any time due to server restarts, network partitions, or idle timeouts. If the client doesn't detect and handle connection failures, RPC calls will hang or fail with cryptic socket errors.\n\n**Why this is wrong**: Socket operations (send/receive) can fail even after successful connection establishment. The server might close the connection, the network might drop packets, or intermediate firewalls might reset connections. Without proper error detection, clients become unusable after the first connection failure.\n\n**How to fix**: Always wrap socket operations in try/catch blocks and handle connection errors by closing the socket, transitioning to disconnected state, and optionally retrying the connection. Implement connection health checks before each RPC call to detect dead connections early.\n\n⚠️ **Pitfall: Not Cleaning Up Timed-Out Requests**\n\nWhen a request times out, beginners often simply raise a timeout exception but leave the request tracking data structures intact. This causes memory leaks as the request dictionary grows, and can lead to confusion if late responses eventually arrive.\n\n**Why this is wrong**: Timed-out requests consume memory indefinitely, and late responses might be delivered to the wrong caller if request IDs are reused. Additionally, the connection state becomes uncertain since the server might still send a response.\n\n**How to fix**: Always clean up request tracking data when a timeout occurs, and close the connection to prevent out-of-order responses. Use `_cleanup_request()` to remove the request from tracking dictionaries and release condition variables.\n\n⚠️ **Pitfall: Making Method Proxies That Don't Preserve Call Semantics**\n\nWhen implementing method proxying with `__getattr__`, beginners sometimes return the actual RPC result from `__getattr__` instead of returning a callable. This breaks the natural method call syntax and makes the API confusing.\n\n**Why this is wrong**: `proxy.method_name` should return a callable that can be invoked with arguments, not execute the RPC call immediately. The call `proxy.method_name(args)` requires two steps: first get the callable, then invoke it with arguments.\n\n**How to fix**: `__getattr__` should return a callable (lambda or bound method) that captures the method name and performs the RPC call when invoked. Don't execute the RPC call from within `__getattr__`.\n\n⚠️ **Pitfall: Ignoring Parameter Serialization Validation**\n\nJSON serialization has limitations on supported data types. Beginners often pass objects that can't be serialized (like file handles, custom classes, or functions) and get confusing errors during the RPC call rather than at parameter validation time.\n\n**Why this is wrong**: Serialization errors happen deep in the call stack and provide poor error messages. It's better to validate parameters early and provide clear feedback about what types are supported.\n\n**How to fix**: Implement `_validate_parameters()` that checks all arguments and keyword arguments for JSON serializability before creating the RPC request. Provide clear error messages explaining what types are supported.\n\n⚠️ **Pitfall: Race Conditions in Response Handling**\n\nWhen implementing request tracking with threading, beginners sometimes access the tracking dictionary without proper synchronization, leading to race conditions where responses are lost or delivered to the wrong caller.\n\n**Why this is wrong**: Multiple threads accessing shared data structures without synchronization can cause data corruption, lost responses, or responses delivered to the wrong waiting thread.\n\n**How to fix**: Use threading primitives (locks, condition variables) consistently around all access to shared data structures. Each request should have its own condition variable for waiting, and the tracking dictionary should be protected with a lock.\n\n⚠️ **Pitfall: Not Handling Partial Socket Reads/Writes**\n\nTCP sockets don't guarantee that `send()` will send all bytes or that `recv()` will receive the complete message in one call. Beginners often assume that one `recv()` call will return the complete response message, leading to protocol errors when messages are split across multiple TCP packets.\n\n**Why this is wrong**: TCP is a stream protocol, not a message protocol. Large messages will be split across multiple packets, and small messages might be combined into one packet. Without proper message framing and complete read/write handling, messages become corrupted.\n\n**How to fix**: Use the length-prefixed message framing from the protocol design, and implement `send_all()` and `recv_all()` utility functions that loop until all bytes are sent/received. Always read the length prefix first, then read exactly that many bytes for the message body.\n\n![Client Request State Machine](./diagrams/client-state-machine.svg)\n\n![RPC Call Sequence](./diagrams/rpc-call-sequence.svg)\n\n### Implementation Guidance\n\nThis subsection provides concrete implementation guidance for building the RPC client component in Python. The client is responsible for method proxying, connection management, and request/response handling.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Network Transport | Raw TCP sockets with JSON | HTTP with requests library |\n| Serialization | Built-in `json` module | `msgpack` for binary efficiency |\n| Concurrency | Threading with condition variables | `asyncio` for async support |\n| Connection Management | Single persistent connection | Connection pooling with queue |\n| Timeout Handling | Socket timeouts with threading | `select()` or `epoll()` for non-blocking |\n\n**Recommended File Structure:**\n\n```python\n# rpc_framework/\n#   client/\n#     __init__.py          ← exports RPCClient and proxy classes\n#     client.py            ← main RPCClient implementation  \n#     proxy.py             ← method proxy implementation\n#     connection.py        ← connection management utilities\n#     exceptions.py        ← client-specific exceptions\n#   common/\n#     protocol.py          ← shared protocol utilities (from Milestone 1)\n#     socket_helper.py     ← socket utilities (from server implementation)\n```\n\n**Infrastructure Starter Code (Complete Socket Helper):**\n\n```python\n# rpc_framework/common/socket_helper.py\nimport socket\nimport struct\nimport time\nfrom typing import Optional\n\nclass SocketHelper:\n    \"\"\"Utility class for reliable socket operations with timeout support.\"\"\"\n    \n    @staticmethod\n    def send_all(sock: socket.socket, data: bytes, timeout: float = 30.0) -> None:\n        \"\"\"Send all bytes, handling partial sends and timeouts.\"\"\"\n        sock.settimeout(timeout)\n        total_sent = 0\n        while total_sent < len(data):\n            try:\n                sent = sock.send(data[total_sent:])\n                if sent == 0:\n                    raise RPCTransportError(\"Socket connection broken during send\")\n                total_sent += sent\n            except socket.timeout:\n                raise RPCTimeoutError(f\"Send timeout after {timeout} seconds\")\n            except socket.error as e:\n                raise RPCTransportError(f\"Socket send error: {e}\")\n\n    @staticmethod  \n    def recv_all(sock: socket.socket, size: int, timeout: float = 30.0) -> bytes:\n        \"\"\"Receive exactly size bytes, handling partial receives and timeouts.\"\"\"\n        sock.settimeout(timeout)\n        chunks = []\n        bytes_received = 0\n        \n        while bytes_received < size:\n            try:\n                chunk = sock.recv(min(size - bytes_received, 4096))\n                if not chunk:\n                    raise RPCTransportError(\"Socket connection closed during receive\")\n                chunks.append(chunk)\n                bytes_received += len(chunk)\n            except socket.timeout:\n                raise RPCTimeoutError(f\"Receive timeout after {timeout} seconds\")\n            except socket.error as e:\n                raise RPCTransportError(f\"Socket receive error: {e}\")\n        \n        return b''.join(chunks)\n\n    @staticmethod\n    def recv_message(sock: socket.socket, timeout: float = 30.0) -> bytes:\n        \"\"\"Receive length-prefixed message using protocol framing.\"\"\"\n        # First, receive 4-byte length prefix\n        length_bytes = SocketHelper.recv_all(sock, 4, timeout)\n        message_length = struct.unpack('!I', length_bytes)[0]\n        \n        # Then receive the message body\n        if message_length > 1024 * 1024:  # 1MB limit\n            raise RPCProtocolError(f\"Message too large: {message_length} bytes\")\n        \n        return SocketHelper.recv_all(sock, message_length, timeout)\n\n    @staticmethod\n    def send_message(sock: socket.socket, message_bytes: bytes, timeout: float = 30.0) -> None:\n        \"\"\"Send length-prefixed message using protocol framing.\"\"\"\n        if len(message_bytes) > 1024 * 1024:  # 1MB limit\n            raise RPCProtocolError(f\"Message too large: {len(message_bytes)} bytes\")\n        \n        # Send 4-byte length prefix followed by message\n        length_prefix = struct.pack('!I', len(message_bytes))\n        SocketHelper.send_all(sock, length_prefix + message_bytes, timeout)\n```\n\n**Core Logic Skeleton (Client Implementation):**\n\n```python\n# rpc_framework/client/client.py\nimport socket\nimport threading\nimport time\nimport json\nfrom typing import Dict, Any, Optional\nfrom ..common.protocol import generate_request_id, create_request_message, deserialize_message\nfrom ..common.socket_helper import SocketHelper\nfrom .exceptions import RPCError, RPCTransportError, RPCTimeoutError\n\nclass RPCClient:\n    \"\"\"RPC client with connection management and request tracking.\"\"\"\n    \n    def __init__(self, host: str = 'localhost', port: int = 8000, default_timeout: float = 30.0):\n        self.host = host\n        self.port = port\n        self.default_timeout = default_timeout\n        \n        # Connection management\n        self._socket: Optional[socket.socket] = None\n        self._connected = False\n        self._connection_lock = threading.Lock()\n        \n        # Request tracking\n        self._pending_requests: Dict[str, Dict] = {}\n        self._request_lock = threading.Lock()\n        \n        # Response handling\n        self._response_thread: Optional[threading.Thread] = None\n        self._shutdown_event = threading.Event()\n\n    def call(self, method_name: str, *args, timeout: Optional[float] = None, **kwargs) -> Any:\n        \"\"\"Make an RPC call and return the result.\"\"\"\n        if timeout is None:\n            timeout = self.default_timeout\n            \n        # TODO 1: Generate unique request ID using generate_request_id()\n        # TODO 2: Validate that all parameters are JSON-serializable \n        # TODO 3: Create request message using create_request_message()\n        # TODO 4: Ensure connection is established using _ensure_connected()\n        # TODO 5: Register request for tracking using _track_request()\n        # TODO 6: Send request message using SocketHelper.send_message()\n        # TODO 7: Wait for response using _wait_for_response()\n        # TODO 8: Clean up request tracking using _cleanup_request()\n        # TODO 9: Return result or raise appropriate exception based on response\n        # Hint: Wrap steps 4-6 in try/catch to handle connection errors\n\n    def _ensure_connected(self, timeout: float) -> None:\n        \"\"\"Establish connection if not already connected.\"\"\"\n        with self._connection_lock:\n            if self._connected and self._socket:\n                # TODO 1: Check if existing connection is still healthy\n                # TODO 2: If healthy, return early without reconnecting\n                return\n                \n            # TODO 3: Create new TCP socket with appropriate options\n            # TODO 4: Set socket timeout for connection attempt  \n            # TODO 5: Connect to (self.host, self.port) with error handling\n            # TODO 6: Start response handling thread using _start_response_thread()\n            # TODO 7: Set self._connected = True and store socket reference\n            # Hint: Use socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    def _track_request(self, request_id: str, timeout: float) -> None:\n        \"\"\"Register request for response tracking and timeout monitoring.\"\"\"\n        request_info = {\n            'start_time': time.time(),\n            'timeout_deadline': time.time() + timeout,\n            'response_received': False,\n            'result': None,\n            'condition': threading.Condition()\n        }\n        \n        with self._request_lock:\n            # TODO 1: Add request_info to self._pending_requests[request_id]\n            # TODO 2: Validate that request_id is not already in use\n            pass\n\n    def _wait_for_response(self, request_id: str) -> Dict:\n        \"\"\"Block until response received or timeout occurs.\"\"\"\n        with self._request_lock:\n            if request_id not in self._pending_requests:\n                raise RPCError(f\"Request {request_id} not found in tracking\")\n            \n            request_info = self._pending_requests[request_id]\n            condition = request_info['condition']\n        \n        with condition:\n            # TODO 1: Calculate remaining timeout based on deadline\n            # TODO 2: Wait on condition variable with timeout\n            # TODO 3: Check if response was received or timeout occurred\n            # TODO 4: Return the response or raise RPCTimeoutError\n            # Hint: Use condition.wait(timeout) and check return value\n\n    def _start_response_thread(self) -> None:\n        \"\"\"Start background thread to handle incoming responses.\"\"\"\n        if self._response_thread and self._response_thread.is_alive():\n            return\n            \n        self._shutdown_event.clear()\n        self._response_thread = threading.Thread(\n            target=self._response_handler,\n            daemon=True,\n            name=\"RPC-ResponseHandler\"\n        )\n        self._response_thread.start()\n\n    def _response_handler(self) -> None:\n        \"\"\"Background thread that receives and dispatches responses.\"\"\"\n        while not self._shutdown_event.is_set():\n            try:\n                # TODO 1: Receive message using SocketHelper.recv_message()\n                # TODO 2: Deserialize message using deserialize_message()\n                # TODO 3: Extract request_id from response\n                # TODO 4: Find matching pending request using request_id\n                # TODO 5: Store response in request_info and notify waiting thread\n                # TODO 6: Handle case where no matching request found (log and discard)\n                # Hint: Use short timeout on recv_message to allow shutdown checking\n                pass\n            except socket.timeout:\n                # TODO 7: Continue loop to check shutdown event\n                continue\n            except Exception as e:\n                # TODO 8: Handle connection errors by breaking loop and disconnecting\n                break\n\n    def _cleanup_request(self, request_id: str) -> None:\n        \"\"\"Remove request from tracking and release resources.\"\"\"\n        with self._request_lock:\n            # TODO 1: Remove request_id from self._pending_requests if present\n            # TODO 2: Handle case where request_id not found (already cleaned up)\n            pass\n\n    def _disconnect(self) -> None:\n        \"\"\"Close connection and clean up resources.\"\"\"\n        with self._connection_lock:\n            # TODO 1: Set shutdown event to stop response thread\n            # TODO 2: Close socket if it exists\n            # TODO 3: Wait for response thread to finish\n            # TODO 4: Reset connection state variables\n            # TODO 5: Clean up any pending requests with connection errors\n            pass\n\n    def __enter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit - clean up connection.\"\"\"\n        self._disconnect()\n```\n\n**Method Proxy Implementation:**\n\n```python  \n# rpc_framework/client/proxy.py\nimport json\nfrom typing import Any, Callable\n\nclass RPCProxy:\n    \"\"\"Proxy object that converts method calls to RPC requests.\"\"\"\n    \n    def __init__(self, client, timeout: float = None):\n        # Use object.__setattr__ to avoid infinite recursion with __getattr__\n        object.__setattr__(self, '_client', client)\n        object.__setattr__(self, '_timeout', timeout)\n        object.__setattr__(self, '_method_cache', {})\n\n    def __getattr__(self, method_name: str) -> Callable:\n        \"\"\"Create proxy method for any attribute access.\"\"\"\n        # TODO 1: Check method cache for existing proxy function\n        # TODO 2: If not cached, create new proxy function using _create_method_proxy()\n        # TODO 3: Store in cache and return the callable\n        # Hint: Cache improves performance for repeated calls to same method\n\n    def _create_method_proxy(self, method_name: str) -> Callable:\n        \"\"\"Create a callable that performs RPC call for the given method.\"\"\"\n        def proxy_method(*args, **kwargs):\n            # TODO 1: Call self._client.call() with method_name and arguments\n            # TODO 2: Use self._timeout if specified, otherwise client default\n            # TODO 3: Return result from RPC call\n            pass\n        \n        # Set helpful attributes for debugging\n        proxy_method.__name__ = method_name\n        proxy_method.__doc__ = f\"RPC proxy for remote method '{method_name}'\"\n        return proxy_method\n\n    def _validate_json_serializable(self, obj: Any) -> None:\n        \"\"\"Validate that object can be JSON serialized.\"\"\"\n        try:\n            # TODO 1: Attempt to JSON serialize the object  \n            # TODO 2: Raise clear error message if serialization fails\n            # TODO 3: Include information about supported types\n            json.dumps(obj)\n        except (TypeError, ValueError) as e:\n            raise RPCError(f\"Parameter not JSON serializable: {e}. \"\n                         f\"Supported types: str, int, float, bool, list, dict, None\")\n```\n\n**Language-Specific Implementation Hints:**\n\n1. **Socket Management**: Use `socket.socket(socket.AF_INET, socket.SOCK_STREAM)` for TCP connections. Always set timeouts with `sock.settimeout()` to avoid infinite blocking.\n\n2. **Threading Synchronization**: Use `threading.Condition` for request/response coordination and `threading.Lock` for protecting shared data structures. Condition variables are perfect for the \"wait for specific response\" pattern.\n\n3. **JSON Validation**: Use `json.dumps()` in a try/catch block to validate serializability. The `json` module raises `TypeError` for unserializable objects.\n\n4. **Context Managers**: Implement `__enter__` and `__exit__` methods so clients can be used with `with` statements for automatic cleanup.\n\n5. **Magic Methods**: Use `object.__setattr__()` in `RPCProxy.__init__()` to avoid triggering `__getattr__` during initialization.\n\n**Milestone Checkpoint:**\n\nAfter implementing the client component, verify functionality with this test:\n\n```python\n# test_client.py\ndef test_basic_client():\n    # Assuming server is running with a 'add' method\n    with RPCClient('localhost', 8000) as client:\n        proxy = RPCProxy(client)\n        \n        # Test basic method call\n        result = proxy.add(5, 3)\n        assert result == 8\n        \n        # Test timeout behavior\n        try:\n            proxy.slow_method(timeout=1.0)\n            assert False, \"Should have timed out\"\n        except RPCTimeoutError:\n            pass  # Expected\n        \n        print(\"✓ Client implementation working correctly\")\n\nif __name__ == \"__main__\":\n    test_basic_client()\n```\n\nExpected behavior:\n- Client connects to server automatically on first call\n- Method calls return results as if they were local functions  \n- Timeouts raise `RPCTimeoutError` after specified duration\n- Connection is reused for multiple calls\n- Resources are cleaned up when client exits context manager\n\n**Common Implementation Issues:**\n\n| Symptom | Likely Cause | How to Fix |\n|---------|--------------|------------|\n| \"Connection refused\" | Server not running or wrong port | Check server status and port configuration |\n| Calls hang forever | No timeout set on socket operations | Always use `sock.settimeout()` before socket operations |\n| \"Broken pipe\" errors | Server closed connection unexpectedly | Implement connection health checks and retry logic |\n| Responses to wrong calls | Race condition in request tracking | Use proper locking around `_pending_requests` dictionary |\n| Memory leaks | Requests not cleaned up after timeout | Always call `_cleanup_request()` in finally blocks |\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** Integration of Milestones 1, 2, and 3 - demonstrates how message protocol, server, and client work together to execute remote procedure calls\n\n### Mental Model: The Phone Call Choreography\n\nThink of an RPC call like a carefully choreographed business phone call. The client (caller) dials the server (receiver), speaks a structured message in a shared language (protocol), waits for a response, and hangs up. Just like a phone call has predictable stages - dialing, waiting for pickup, speaking, listening, confirming understanding, hanging up - an RPC call follows a precise sequence that both sides understand.\n\nThe magic happens because both parties follow the same \"business phone etiquette\" - they know when to speak, what format to use, how to handle misunderstandings, and how to gracefully end the conversation. When something goes wrong (busy signal, wrong number, bad connection), there are standard ways to handle each situation.\n\nThis choreography is crucial because unlike a local function call that happens in nanoseconds within the same process, an RPC call crosses network boundaries, involves serialization, and can fail in dozens of ways. The protocol and error handling ensure that despite this complexity, the client can still pretend it's just calling a local function.\n\n## RPC Call Sequence\n\nThe successful RPC call sequence represents the \"happy path\" where everything works as designed. This sequence involves precise coordination between the client proxy, network transport layer, and server dispatcher to maintain the illusion that the remote function call is local.\n\n![RPC Call Sequence](./diagrams/rpc-call-sequence.svg)\n\n### Step-by-Step Call Flow\n\nThe complete RPC call sequence involves eleven distinct steps that transform a local method invocation into a remote procedure execution and back again:\n\n| Step | Component | Action | Data Transformed | Purpose |\n|------|-----------|--------|------------------|---------|\n| 1 | Client Code | Invokes method on proxy object | `calc.add(5, 3)` | Triggers RPC call |\n| 2 | RPCProxy | Intercepts call via `__getattr__` | Method name + args → internal call | Transparent proxying |\n| 3 | RPCClient | Generates request ID and creates message | Args → JSON-RPC request dict | Message preparation |\n| 4 | RPCClient | Serializes and sends message | Request dict → length-prefixed bytes | Network transmission |\n| 5 | RPCServer | Receives and deserializes message | Bytes → request dict | Message reception |\n| 6 | RPCServer | Looks up method in registry | Method name → callable function | Method resolution |\n| 7 | RPCServer | Executes registered function | Parameters → result value | Actual computation |\n| 8 | RPCServer | Creates and serializes response | Result → JSON-RPC response bytes | Response preparation |\n| 9 | RPCClient | Receives and deserializes response | Bytes → response dict | Response reception |\n| 10 | RPCClient | Matches response to pending request | Request ID → waiting thread | Response correlation |\n| 11 | Client Code | Receives result as return value | Response dict → Python object | Transparent result |\n\n#### Detailed Sequence Narrative\n\n**Phase 1: Client-Side Request Preparation**\n\nThe sequence begins when application code invokes what appears to be a method on a local object. For example, when the code calls `calc.add(5, 3)`, the `calc` object is actually an `RPCProxy` instance that intercepts this call through Python's `__getattr__` mechanism. The proxy recognizes that `add` is not a local method and triggers the RPC machinery.\n\nThe `RPCProxy` delegates to its underlying `RPCClient`, which performs several critical preparation steps. First, it generates a unique request ID using `generate_request_id()` to ensure this request can be correlated with its eventual response. The client maintains a dictionary of pending requests keyed by these IDs, which is essential for handling concurrent calls on the same connection.\n\nNext, the client constructs a JSON-RPC request message using `create_request_message()`. This transforms the method name \"add\", parameters `[5, 3]`, and generated request ID into a standardized dictionary format that the server can parse. The message includes version information and follows the JSON-RPC 2.0 specification exactly.\n\n**Phase 2: Network Transmission**\n\nThe client serializes the request message using `serialize_message()`, which converts the Python dictionary to JSON bytes and prepends a 4-byte length prefix for message framing. This length prefix is crucial because TCP provides a byte stream without message boundaries - the server needs to know exactly how many bytes constitute one complete message.\n\nBefore sending, the client calls `_ensure_connected()` to establish a TCP connection if one doesn't exist or verify that the existing connection is still healthy. Connection reuse is important for performance since establishing new TCP connections for every RPC call would add significant latency.\n\nThe client then transmits the serialized message using `send_all()`, which handles the complexity of partial sends. TCP doesn't guarantee that all bytes are sent in a single `send()` call, so this helper function loops until all bytes are transmitted successfully.\n\n**Phase 3: Server-Side Request Processing**\n\nThe server receives the incoming bytes through its `handle_connection()` method running in a dedicated thread for this client connection. The server first reads the 4-byte length prefix to determine how many additional bytes constitute the complete message, then reads exactly that many bytes using `recv_all()`.\n\nOnce the complete message is received, the server deserializes it back into a Python dictionary using `deserialize_message()`. The server validates that this is a well-formed JSON-RPC request with all required fields (method, params, id, jsonrpc version).\n\nThe server's `process_request()` method handles the core dispatch logic. It extracts the method name from the request and looks it up in the `MethodRegistry`. If the method exists, the server unpacks the parameters and invokes the registered function directly. The beauty of this approach is that any Python function can be registered - the server doesn't need special knowledge about what \"add\" does, it just calls the registered function with the provided parameters.\n\n**Phase 4: Server-Side Response Generation**\n\nAfter the registered function executes successfully and returns a result, the server packages this result into a JSON-RPC response message using `create_response_message()`. The response includes the original request ID (crucial for correlation), the result value, and the JSON-RPC version identifier.\n\nThe server serializes this response message the same way as requests - JSON encoding with a length prefix - and transmits it back to the client using the same TCP connection. The bidirectional nature of the connection allows responses to flow back through the same socket.\n\n**Phase 5: Client-Side Response Handling**\n\nMeanwhile, the client has been blocking in `_wait_for_response()`, continuously reading from the socket for incoming messages. When the response arrives, the client deserializes it and extracts the request ID to determine which pending request this response satisfies.\n\nThe client's request tracking mechanism uses the ID to find the correct thread or callback waiting for this response. For blocking calls, this typically means unblocking the thread that made the original RPC call and returning the result value.\n\nFinally, the client cleans up the request from its pending requests dictionary and returns the result to the application code. From the application's perspective, the call to `calc.add(5, 3)` simply returned `8` - all the network complexity was hidden by the RPC framework.\n\n### Timing and Concurrency Considerations\n\nThe RPC call sequence must handle several timing and concurrency challenges that don't exist in local function calls:\n\n**Request ID Management**: Since multiple threads might make concurrent RPC calls on the same client connection, the request ID mechanism prevents responses from being delivered to the wrong caller. Each request gets a unique ID, and responses are routed back to the correct waiting thread.\n\n**Connection State**: The client must manage the TCP connection lifecycle carefully. Connections can break at any time due to network issues, server restarts, or firewall timeouts. The client detects these failures during send or receive operations and can optionally retry or reconnect.\n\n**Server Threading**: The server handles multiple client connections concurrently, with each connection processed in its own thread. Within each connection thread, requests are processed sequentially to maintain ordering guarantees. This threading model is simple but scales reasonably well for moderate loads.\n\n> **Key Insight**: The request ID serves as the critical coordination mechanism that allows multiple concurrent RPC calls to share the same TCP connection without interference. Without this correlation mechanism, responses could be delivered to the wrong caller, causing subtle and hard-to-debug errors.\n\n## Error Flow\n\nError handling in RPC systems is significantly more complex than local function calls because failures can occur at multiple layers - network, protocol, serialization, and application logic. The error flow must gracefully handle each category and provide meaningful feedback to the client application.\n\n### Error Categories and Propagation\n\nRPC errors fall into four distinct categories, each handled differently by the framework:\n\n| Error Category | Detection Point | Error Type | Propagation Method | Client Experience |\n|----------------|----------------|------------|-------------------|------------------|\n| Network Errors | Client or Server | `RPCTransportError` | Exception raised immediately | Connection refused, timeout |\n| Protocol Errors | Client or Server | `RPCProtocolError` | JSON-RPC error response | Invalid request format |\n| Method Errors | Server | `RPCMethodError` | JSON-RPC error response | Method not found, bad params |\n| Execution Errors | Server | `RPCMethodError` | JSON-RPC error response | Exception in user code |\n\n#### Network Error Flow\n\nNetwork errors represent failures in the underlying TCP communication and are the most disruptive type of RPC failure. These errors are detected at the socket layer and cannot be communicated through the normal JSON-RPC response mechanism because the communication channel itself is compromised.\n\nWhen a network error occurs during `send_all()` or `recv_all()`, the client immediately raises an `RPCTransportError` exception. The client also marks its connection as broken and closes the socket to prevent further attempts to use the damaged connection. Subsequent RPC calls will trigger connection re-establishment.\n\nCommon network error scenarios include:\n\n1. **Connection Refused**: Server is not running or not accepting connections on the specified port\n2. **Connection Reset**: Server process crashed or was forcibly terminated\n3. **Connection Timeout**: Network is unreachable or server is not responding within timeout period\n4. **Partial Send/Receive**: Connection was broken mid-transmission, leaving message incomplete\n\nThe client handles these by immediately cleaning up the broken connection and propagating the transport error to the application. The application can choose to retry, connect to an alternative server, or fail gracefully.\n\n#### Protocol Error Flow\n\nProtocol errors occur when messages don't conform to the JSON-RPC specification, even though network communication is successful. These errors can be detected by either client or server during message parsing and validation.\n\nServer-detected protocol errors follow this sequence:\n\n1. Server receives and deserializes message successfully\n2. Server validates message format and discovers violation (missing required field, invalid JSON-RPC version, malformed structure)\n3. Server creates JSON-RPC error response with appropriate error code (`PARSE_ERROR`, `INVALID_REQUEST`)\n4. Server sends error response back to client using normal response mechanism\n5. Client receives error response and raises `RPCProtocolError` with server's error details\n\nThis approach allows protocol errors to be communicated through the normal RPC channel, providing detailed error information to help debug message format issues.\n\n#### Method Error Flow\n\nMethod errors occur when the JSON-RPC message is well-formed but the requested method cannot be executed. This includes method-not-found errors and parameter validation failures.\n\nThe method error sequence:\n\n1. Server successfully parses and validates request message format\n2. Server attempts to look up requested method name in `MethodRegistry`\n3. If method not found, server creates error response with `METHOD_NOT_FOUND` error code\n4. If method found but parameter count/types don't match, server creates error response with `INVALID_PARAMS` error code\n5. Server sends JSON-RPC error response with detailed error information\n6. Client receives error response and raises `RPCMethodError` with method-specific error details\n\nThis category of errors is particularly important for API usability - clear error messages help developers understand what methods are available and how to call them correctly.\n\n#### Execution Error Flow\n\nExecution errors represent exceptions thrown by the registered method during actual execution. These are application-level errors that occur after successful method dispatch but during the business logic execution.\n\nThe execution error handling sequence:\n\n1. Server successfully looks up method and begins execution\n2. Registered method raises exception during execution (divide by zero, invalid business logic, etc.)\n3. Server catches exception and examines its type\n4. Server creates JSON-RPC error response with `INTERNAL_ERROR` code and exception details\n5. Server sends error response back to client\n6. Client receives error response and raises `RPCMethodError` with execution error details\n\n> **Design Decision: Exception Serialization**\n> - **Context**: When user methods throw exceptions, we need to decide how much exception detail to send to clients\n> - **Options Considered**: \n>   1. Send full exception traceback including server file paths\n>   2. Send only exception message and type\n>   3. Send generic \"internal error\" message\n> - **Decision**: Send exception type and message but not full traceback\n> - **Rationale**: Provides useful debugging information without exposing server implementation details or file system structure\n> - **Consequences**: Clients get actionable error information while server security is maintained\n\n### Error Response Message Format\n\nAll server-detected errors (protocol, method, and execution errors) are communicated using standardized JSON-RPC error response messages. This consistency allows clients to handle all server errors through the same mechanism.\n\n| Field | Type | Description | Example Value |\n|-------|------|-------------|---------------|\n| jsonrpc | str | JSON-RPC version identifier | \"2.0\" |\n| id | str/null | Request ID from original request | \"req_12345\" |\n| error | dict | Error details object | See error object format |\n\nThe error object within the response contains structured error information:\n\n| Field | Type | Description | Example Value |\n|-------|------|-------------|---------------|\n| code | int | Standard JSON-RPC error code | -32601 |\n| message | str | Human-readable error description | \"Method not found\" |\n| data | any | Additional error-specific information | {\"method\": \"nonexistent\"} |\n\n### Timeout Handling\n\nTimeout errors deserve special attention because they can occur even when both client and server are functioning correctly but network latency is high or server processing time exceeds expectations.\n\nThe client's timeout mechanism works as follows:\n\n1. Client starts timeout timer when sending request\n2. Client blocks in `_wait_for_response()` but checks elapsed time periodically\n3. If timeout expires before response arrives, client raises `RPCTimeoutError`\n4. Client marks request as timed out but keeps connection open (timeout doesn't necessarily indicate connection failure)\n5. If response eventually arrives for timed-out request, client discards it to prevent delivering stale results\n\n> **Important Consideration**: Timeout handling creates a potential resource leak. If the server eventually sends a response for a timed-out request, that response must be properly discarded to prevent it from being mistakenly matched to a future request with the same ID.\n\n### Error Recovery Strategies\n\nDifferent error categories suggest different recovery strategies for client applications:\n\n| Error Type | Suggested Recovery | Rationale |\n|------------|-------------------|-----------|\n| `RPCTransportError` | Retry with exponential backoff, try alternative server | Network issues often transient |\n| `RPCProtocolError` | Fix client code, don't retry | Protocol violations indicate programming errors |\n| `RPCMethodError` (not found) | Fix client code, check available methods | Method name typos or API misunderstanding |\n| `RPCMethodError` (invalid params) | Fix client code parameters | Parameter type or count mismatch |\n| `RPCMethodError` (execution) | Retry with different parameters or fail gracefully | Server-side business logic error |\n| `RPCTimeoutError` | Retry with longer timeout or fail | Server may be overloaded |\n\n### Common Error Scenarios\n\nReal-world RPC systems encounter several common error patterns that developers should be prepared to handle:\n\n⚠️ **Pitfall: Ignoring Network Errors**\nMany developers assume network connections are reliable and don't properly handle `RPCTransportError` exceptions. In production environments, networks frequently experience transient failures, server restarts, and connection drops. Applications should catch transport errors and implement appropriate retry logic rather than crashing on the first network hiccup.\n\n⚠️ **Pitfall: Confusing Timeout with Failure**\nA timeout doesn't necessarily mean the server is broken - it might just be processing a complex request that takes longer than expected. Immediately reducing timeout values or switching to alternative servers can make problems worse. Instead, applications should distinguish between timeout errors and other error types, potentially retrying with longer timeouts.\n\n⚠️ **Pitfall: Leaking Request IDs**\nIf request IDs are not properly managed, the client can run out of unique identifiers or accidentally reuse IDs while previous requests are still pending. This leads to response correlation errors where responses are delivered to the wrong callers. Proper cleanup in the error path is essential.\n\n### Implementation Guidance\n\nThe error handling implementation requires careful coordination between exception types, error codes, and message formats to provide a consistent developer experience.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Error Types | Standard Python exceptions with inheritance | Custom exception hierarchy with error codes |\n| Error Serialization | JSON with string messages | Structured error objects with metadata |\n| Timeout Mechanism | Simple socket timeout | Configurable per-request timeouts |\n| Retry Logic | Manual retry in application code | Automatic retry with backoff in client |\n\n#### Recommended File Structure\n\n```\nrpc_framework/\n├── exceptions.py          ← All RPC exception classes\n├── error_codes.py         ← JSON-RPC error code constants\n├── client.py             ← Client with error handling\n├── server.py             ← Server with error responses\n└── protocol.py           ← Error message creation helpers\n```\n\n#### Infrastructure Starter Code\n\n**Complete Exception Hierarchy (exceptions.py)**\n\n```python\n\"\"\"RPC Framework exception hierarchy for structured error handling.\"\"\"\n\nclass RPCError(Exception):\n    \"\"\"Base exception for all RPC framework errors.\"\"\"\n    def __init__(self, message, error_code=None, error_data=None):\n        super().__init__(message)\n        self.error_code = error_code\n        self.error_data = error_data\n\nclass RPCTransportError(RPCError):\n    \"\"\"Network communication errors - connection refused, timeout, etc.\"\"\"\n    pass\n\nclass RPCProtocolError(RPCError):\n    \"\"\"JSON-RPC protocol violations - malformed messages, version mismatch.\"\"\"\n    pass\n\nclass RPCMethodError(RPCError):\n    \"\"\"Method-related errors - not found, invalid params, execution failure.\"\"\"\n    pass\n\nclass RPCTimeoutError(RPCError):\n    \"\"\"Request timeout - server didn't respond within specified time limit.\"\"\"\n    def __init__(self, message, timeout_seconds):\n        super().__init__(message)\n        self.timeout_seconds = timeout_seconds\n```\n\n**Error Code Constants (error_codes.py)**\n\n```python\n\"\"\"JSON-RPC 2.0 standard error codes and framework-specific extensions.\"\"\"\n\n# JSON-RPC 2.0 Standard Error Codes\nPARSE_ERROR = -32700      # Invalid JSON received\nINVALID_REQUEST = -32600  # JSON is not valid JSON-RPC request\nMETHOD_NOT_FOUND = -32601 # Method does not exist or is not available\nINVALID_PARAMS = -32602   # Invalid method parameter(s)\nINTERNAL_ERROR = -32603   # Internal JSON-RPC error\n\n# Framework-specific Error Codes (per JSON-RPC spec, -32000 to -32099 reserved)\nTRANSPORT_ERROR = -32000  # Network communication failure\nTIMEOUT_ERROR = -32001    # Request timeout\nCONNECTION_ERROR = -32002 # Connection establishment failure\n```\n\n#### Core Error Handling Skeleton\n\n**Server Error Response Logic**\n\n```python\ndef process_request(self, request):\n    \"\"\"Process incoming RPC request and return response or error.\"\"\"\n    request_id = request.get('id')\n    \n    try:\n        # TODO 1: Validate JSON-RPC message format (version, required fields)\n        # TODO 2: Extract method name and parameters from request\n        # TODO 3: Look up method in registry - raise METHOD_NOT_FOUND if missing\n        # TODO 4: Validate parameter count/types against method signature\n        # TODO 5: Execute method with parameters - catch any exceptions\n        # TODO 6: Return create_response_message(request_id, result)\n        pass\n    except KeyError as e:\n        # Missing required field in request\n        return create_error_message(request_id, INVALID_REQUEST, \n                                   f\"Missing required field: {e}\")\n    except TypeError as e:\n        # Parameter count/type mismatch\n        return create_error_message(request_id, INVALID_PARAMS, str(e))\n    except Exception as e:\n        # Execution error in user method\n        return create_error_message(request_id, INTERNAL_ERROR, \n                                   f\"{type(e).__name__}: {e}\")\n```\n\n**Client Error Handling Logic**\n\n```python\ndef _handle_response(self, response):\n    \"\"\"Convert JSON-RPC response to result or raise appropriate exception.\"\"\"\n    if 'error' in response:\n        error = response['error']\n        error_code = error.get('code')\n        error_message = error.get('message', 'Unknown error')\n        error_data = error.get('data')\n        \n        # TODO 1: Check error code and raise appropriate exception type\n        # TODO 2: For PARSE_ERROR, INVALID_REQUEST -> RPCProtocolError\n        # TODO 3: For METHOD_NOT_FOUND, INVALID_PARAMS -> RPCMethodError\n        # TODO 4: For INTERNAL_ERROR -> RPCMethodError with execution details\n        # TODO 5: For TIMEOUT_ERROR -> RPCTimeoutError\n        # TODO 6: For unknown codes -> generic RPCError\n        pass\n    else:\n        return response.get('result')\n```\n\n#### Milestone Checkpoints\n\n**Error Handling Verification**\n\nAfter implementing error handling, verify these behaviors:\n\n1. **Network Errors**: Stop the server, make RPC call, should get `RPCTransportError`\n2. **Method Not Found**: Call non-existent method, should get `RPCMethodError` with METHOD_NOT_FOUND code\n3. **Invalid Parameters**: Call method with wrong parameter count, should get `RPCMethodError` with INVALID_PARAMS code\n4. **Execution Errors**: Register method that throws exception, call it, should get `RPCMethodError` with exception details\n5. **Timeout Errors**: Make call with very short timeout to slow method, should get `RPCTimeoutError`\n\n**Test Commands**\n\n```python\n# Test script to verify error handling\nclient = RPCClient('localhost', 8000)\n\n# Test 1: Network error (server not running)\ntry:\n    client.call('add', 1, 2)\n    print(\"ERROR: Should have raised RPCTransportError\")\nexcept RPCTransportError:\n    print(\"✓ Network error handling works\")\n\n# Test 2: Method not found (server running)\ntry:\n    client.call('nonexistent_method')\n    print(\"ERROR: Should have raised RPCMethodError\")\nexcept RPCMethodError as e:\n    if e.error_code == METHOD_NOT_FOUND:\n        print(\"✓ Method not found error handling works\")\n```\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Generic \"connection error\" | Not distinguishing error types | Check exception type in handler | Use specific exception classes |\n| Wrong error delivered to client | Response correlation failure | Log request IDs on both sides | Ensure request ID in error response matches |\n| Timeout but server still processing | Short timeout, long operation | Monitor server logs for completion | Increase timeout or make operation async |\n| Connection keeps breaking | Not handling partial sends/receives | Check socket error logs | Use send_all/recv_all helpers |\n| Error details lost | Only passing error message | Check error object serialization | Include error code and data fields |\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** All milestones - error handling is critical throughout message protocol (Milestone 1), server implementation (Milestone 2), and client implementation (Milestone 3)\n\n### Mental Model: The Emergency Response System\n\nThink of RPC error handling like a well-designed emergency response system in a large organization. Just as emergency responders need clear protocols to categorize incidents (fire vs. medical vs. security), identify the appropriate response team, and escalate through proper channels, an RPC framework needs systematic error categorization, handling strategies, and propagation mechanisms.\n\nWhen a fire alarm sounds, the emergency system doesn't just panic - it identifies the type of emergency, determines the severity, notifies the right responders, and follows established procedures. Similarly, when network connections fail or methods throw exceptions, our RPC framework must categorize the error, determine the appropriate recovery action, and ensure the client receives meaningful information about what went wrong and what they can do about it.\n\nThe key insight is that different types of errors require fundamentally different handling strategies. A network timeout should trigger retry logic, while a \"method not found\" error should immediately return to the client with diagnostic information. Just as you wouldn't send firefighters to handle a medical emergency, you shouldn't handle serialization errors the same way you handle connection failures.\n\n### Error Categories\n\nOur RPC framework encounters errors from multiple sources and at different stages of request processing. Understanding these categories is crucial because each requires distinct handling strategies and recovery mechanisms.\n\n![Error Handling Flowchart](./diagrams/error-handling-flow.svg)\n\nThe error taxonomy follows a hierarchy based on where the error originates and whether recovery is possible:\n\n| Error Category | Description | Recovery Strategy | Client Experience |\n|---|---|---|---|\n| **Transport Errors** | Network connectivity, socket operations, connection management failures | Retry with exponential backoff, connection re-establishment | `RPCTransportError` with retry suggestion |\n| **Protocol Errors** | Message parsing, invalid JSON-RPC format, serialization failures | Immediate failure, diagnostic information | `RPCProtocolError` with format details |\n| **Method Errors** | Method not found, parameter validation, execution exceptions | Method-specific handling, error propagation | `RPCMethodError` with method context |\n| **Timeout Errors** | Request exceeds configured time limit, server unresponsive | Configurable retry or immediate failure | `RPCTimeoutError` with timeout duration |\n| **Internal Errors** | Server bugs, resource exhaustion, unexpected conditions | Graceful degradation, logging, monitoring alerts | Generic error with request ID for support |\n\n> **Architecture Decision: Error Type Hierarchy**\n> - **Context**: Need structured way to represent different error conditions with appropriate handling\n> - **Options Considered**: \n>   1. Single generic error class with error codes\n>   2. Flat error classes without inheritance\n>   3. Hierarchical error classes inheriting from base `RPCError`\n> - **Decision**: Hierarchical error classes with specific types for each category\n> - **Rationale**: Type system helps client code handle different errors appropriately, inheritance reduces code duplication, specific types enable targeted recovery strategies\n> - **Consequences**: More complex type definitions but clearer error handling logic and better debugging experience\n\nThe error class hierarchy provides both type safety and semantic clarity:\n\n| Error Class | Base Fields | Additional Fields | Usage Context |\n|---|---|---|---|\n| `RPCError` | `message: str`, `error_code: int`, `error_data: any` | None (base class) | Generic error handling, logging |\n| `RPCTransportError` | Inherits base fields | `host: str`, `port: int`, `operation: str` | Connection failures, socket errors |\n| `RPCProtocolError` | Inherits base fields | `raw_data: bytes`, `parse_stage: str` | Message format violations, encoding issues |\n| `RPCMethodError` | Inherits base fields | `method_name: str`, `params: list`, `execution_phase: str` | Method dispatch and execution failures |\n| `RPCTimeoutError` | Inherits base fields | `timeout_seconds: float`, `elapsed_seconds: float` | Request timeout handling |\n\nEach error type carries contextual information that enables intelligent handling. For example, `RPCTransportError` includes the host and port for connection diagnostics, while `RPCMethodError` includes the method name and parameters for debugging method invocations.\n\n> The critical insight is that error context determines recovery strategy. Transport errors often warrant retries, while protocol errors indicate client bugs that retries cannot fix.\n\n### Network Failure Handling\n\nNetwork failures represent the most common and complex error category in distributed systems. Unlike local function calls that either succeed or raise exceptions, network operations introduce a spectrum of partial failure modes that require sophisticated handling strategies.\n\n![Client Request State Machine](./diagrams/client-state-machine.svg)\n\nThe network failure landscape includes multiple failure modes, each with distinct characteristics and recovery approaches:\n\n| Failure Mode | Detection Method | Immediate Action | Recovery Strategy |\n|---|---|---|---|\n| **Connection Refused** | `socket.connect()` raises `ConnectionRefusedError` | Mark connection as failed | Exponential backoff retry, server health check |\n| **Connection Reset** | `socket.send()` raises `ConnectionResetError` | Close socket, clear connection state | Re-establish connection, replay request |\n| **Connection Timeout** | `socket.settimeout()` expires during operation | Abort current operation | Retry with increased timeout or different endpoint |\n| **Partial Send/Receive** | `socket.send()` returns fewer bytes than requested | Continue operation from partial position | Complete the operation or abort after threshold |\n| **Sudden Disconnection** | `socket.recv()` returns empty bytes | Detect connection closure | Re-establish connection, determine request status |\n| **DNS Resolution Failure** | `socket.getaddrinfo()` raises `gaierror` | Cache negative result temporarily | Retry with different DNS server or cached IP |\n\nThe connection state machine helps understand valid transitions and error recovery points:\n\n| Current State | Network Event | Next State | Recovery Action |\n|---|---|---|---|\n| `DISCONNECTED` | Connection refused | `DISCONNECTED` | Schedule retry with backoff |\n| `CONNECTING` | Timeout during connect | `DISCONNECTED` | Try next address or increase timeout |\n| `CONNECTED` | Socket error during send | `DISCONNECTED` | Re-queue request for retry |\n| `WAITING_RESPONSE` | Connection reset | `DISCONNECTED` | Mark request as failed, retry if idempotent |\n| `RECEIVING_DATA` | Partial receive timeout | `DISCONNECTED` | Abort request, connection likely dead |\n\nThe `send_all` and `recv_all` functions implement robust network I/O with proper timeout handling and partial operation support. These functions abstract the complexity of socket operations while providing consistent error reporting:\n\n| Function | Responsibility | Timeout Behavior | Error Propagation |\n|---|---|---|---|\n| `send_all(sock, data, timeout)` | Send complete message handling partial sends | Per-operation timeout, not total timeout | Raises `RPCTransportError` with bytes sent |\n| `recv_all(sock, size, timeout)` | Receive exact byte count handling partial receives | Cumulative timeout across all recv operations | Raises `RPCTransportError` with bytes received |\n| `recv_message(sock, timeout)` | Receive length-prefixed message | Timeout applies to complete message | Raises `RPCProtocolError` for invalid framing |\n\n> **Architecture Decision: Connection Recovery Strategy**\n> - **Context**: Network connections can fail at any point during RPC communication\n> - **Options Considered**:\n>   1. Immediate failure - no retry logic\n>   2. Transparent retry - hide failures from client\n>   3. Configurable retry - client controls retry behavior\n> - **Decision**: Configurable retry with exponential backoff and maximum attempt limits\n> - **Rationale**: Balances reliability (automatic recovery from transient failures) with control (client can tune for their use case) and prevents infinite retry loops\n> - **Consequences**: More complex client implementation but better resilience to network issues and clearer failure semantics\n\nThe retry mechanism uses exponential backoff to avoid overwhelming failed servers while providing reasonable recovery times for transient network issues:\n\n| Retry Attempt | Base Delay | Backoff Multiplier | Maximum Delay | Total Elapsed |\n|---|---|---|---|---|\n| 1 | 100ms | 1.0x | 100ms | 100ms |\n| 2 | 100ms | 2.0x | 200ms | 300ms |\n| 3 | 100ms | 4.0x | 400ms | 700ms |\n| 4 | 100ms | 8.0x | 800ms | 1500ms |\n| 5 | 100ms | 16.0x | 5000ms (capped) | 6500ms |\n\n### Serialization Error Handling\n\nSerialization errors occur when converting between Python objects and the JSON wire format. Unlike network errors that might be transient, serialization errors usually indicate programming bugs, data corruption, or incompatible message formats between client and server versions.\n\n![Server Connection State Machine](./diagrams/server-state-machine.svg)\n\nThe serialization error landscape encompasses both encoding and decoding failures:\n\n| Error Type | Occurrence Point | Common Causes | Detection Method |\n|---|---|---|---|\n| **JSON Encoding Errors** | `serialize_message()` on client/server | Non-serializable objects, circular references | `json.dumps()` raises `TypeError` |\n| **JSON Decoding Errors** | `deserialize_message()` on client/server | Malformed JSON, truncated messages | `json.loads()` raises `json.JSONDecodeError` |\n| **Type Conversion Errors** | Parameter processing in method dispatch | Wrong parameter types, missing fields | Type validation raises `TypeError` |\n| **Message Format Errors** | Request/response validation | Missing required fields, invalid structure | Schema validation fails |\n| **Encoding/Decoding Errors** | Byte string conversion | Unicode issues, character encoding problems | `str.encode()` raises `UnicodeError` |\n| **Size Limit Errors** | Large message handling | Messages exceeding configured limits | Length prefix validation fails |\n\nThe message processing pipeline includes validation at multiple stages to catch serialization errors early and provide diagnostic information:\n\n| Processing Stage | Validation Applied | Error Type Raised | Recovery Action |\n|---|---|---|---|\n| **Pre-Serialization** | Object type checking, circular reference detection | `RPCProtocolError` | Reject request with validation details |\n| **JSON Encoding** | JSON serialization compatibility | `RPCProtocolError` | Log object types, suggest alternatives |\n| **Message Framing** | Length prefix validation, size limits | `RPCProtocolError` | Reject oversized messages with limit info |\n| **Network Transport** | Byte encoding, socket compatibility | `RPCTransportError` | Encoding failure, suggest UTF-8 |\n| **JSON Decoding** | JSON parsing, structure validation | `RPCProtocolError` | Log raw data for debugging |\n| **Post-Deserialization** | Message schema validation, required fields | `RPCProtocolError` | Missing field details for client |\n\nThe `deserialize_message` function implements defensive parsing with comprehensive error context:\n\n| Parse Phase | Validation Check | Error Condition | Error Context Provided |\n|---|---|---|---|\n| **Length Prefix** | 4-byte integer, reasonable size | Invalid prefix, oversized message | Raw bytes, expected format |\n| **JSON Parsing** | Valid JSON syntax | Malformed JSON, encoding issues | Parse position, syntax error details |\n| **Schema Validation** | Required fields present | Missing fields, wrong types | Field name, expected vs actual type |\n| **Content Validation** | Method names, parameter types | Invalid characters, unsupported types | Specific validation rule violated |\n\n> **Architecture Decision: Serialization Error Recovery**\n> - **Context**: Serialization failures can occur during encoding (client) or decoding (server/client)\n> - **Options Considered**:\n>   1. Fail fast - abort operation immediately \n>   2. Best effort - attempt partial serialization/skip problematic fields\n>   3. Structured errors - detailed diagnostics with recovery suggestions\n> - **Decision**: Structured errors with detailed diagnostics and no data corruption\n> - **Rationale**: Data integrity is more important than availability; partial serialization could cause subtle bugs; detailed errors help developers fix issues quickly\n> - **Consequences**: Operations fail completely on serialization errors, but developers get clear guidance for fixes\n\nThe error response format for serialization failures includes diagnostic information:\n\n| Error Field | Content | Purpose | Example Value |\n|---|---|---|---|\n| `error_code` | Standard JSON-RPC error code | Client error categorization | `PARSE_ERROR` (-32700) |\n| `message` | Human-readable description | Developer debugging | \"Invalid JSON syntax at position 45\" |\n| `error_data.raw_data` | Original problematic data (truncated) | Debugging the exact input | `\"{\\\"method\\\": \\\"test\\\", \\\"params\\\": [1,2,3\"` |\n| `error_data.parse_stage` | Where parsing failed | Narrowing down the issue | \"json_decode\" or \"schema_validation\" |\n| `error_data.expected_format` | What was expected | Helping fix the problem | \"JSON-RPC 2.0 request object\" |\n| `error_data.suggestions` | Possible fixes | Actionable guidance | [\"Check for missing closing brace\", \"Verify UTF-8 encoding\"] |\n\n⚠️ **Pitfall: Logging Sensitive Data in Errors**\n\nA common mistake is including complete message content in error responses, potentially exposing sensitive information. Always truncate or sanitize error data before sending it over the network. The raw data should be logged server-side for debugging but not transmitted to clients unless specifically configured for development environments.\n\n⚠️ **Pitfall: Partial Message Processing**\n\nWhen message framing fails (invalid length prefix or truncated data), avoid attempting to parse partial JSON. This can lead to interpreting part of one message as the beginning of the next message, causing cascading parse errors. Always validate the complete message frame before attempting JSON parsing.\n\n⚠️ **Pitfall: Unicode Encoding Assumptions**\n\nDon't assume all messages use UTF-8 encoding. While JSON requires UTF-8, network data might be corrupted or use different encodings. Always handle `UnicodeDecodeError` exceptions and provide encoding diagnostics in error responses.\n\n### Implementation Guidance\n\nThe error handling system provides the foundation for reliable RPC communication by transforming various failure modes into structured, actionable error information that clients can handle appropriately.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|---|---|---|\n| **Exception Hierarchy** | Built-in Python exceptions with custom messages | Custom exception classes with structured data |\n| **Error Serialization** | JSON with standard fields | MessagePack with binary error data |\n| **Logging Integration** | Python `logging` module with structured logs | Structured logging with correlation IDs |\n| **Network Error Detection** | Socket exception handling | Connection health monitoring with heartbeats |\n| **Retry Logic** | Simple exponential backoff | Circuit breaker pattern with failure tracking |\n\n#### Core Error Classes\n\n```python\n\"\"\"\nRPC Framework Error Handling\n\nThis module provides comprehensive error handling for all RPC operations\nincluding network failures, serialization issues, and method execution errors.\n\"\"\"\n\nimport json\nimport socket\nimport time\nfrom typing import Any, Optional, Dict, Union\nfrom threading import Lock\n\nclass RPCError(Exception):\n    \"\"\"Base class for all RPC-related errors.\"\"\"\n    \n    def __init__(self, message: str, error_code: int = -32603, error_data: Any = None):\n        super().__init__(message)\n        self.message = message\n        self.error_code = error_code\n        self.error_data = error_data or {}\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert error to JSON-RPC error object format.\"\"\"\n        # TODO 1: Create error object with code, message, and data fields\n        # TODO 2: Include error_data only if it contains useful information\n        # TODO 3: Sanitize error_data to prevent sensitive information leakage\n        pass\n    \n    def __str__(self) -> str:\n        \"\"\"Human-readable error representation for logging.\"\"\"\n        # TODO 1: Format error with code, message, and key data fields\n        # TODO 2: Truncate large data fields to prevent log spam\n        pass\n\nclass RPCTransportError(RPCError):\n    \"\"\"Network and transport-related errors.\"\"\"\n    \n    def __init__(self, message: str, host: str = \"\", port: int = 0, \n                 operation: str = \"\", original_error: Exception = None):\n        error_data = {\n            \"host\": host,\n            \"port\": port,\n            \"operation\": operation,\n            \"original_error\": str(original_error) if original_error else None\n        }\n        super().__init__(message, -32000, error_data)\n        self.host = host\n        self.port = port\n        self.operation = operation\n        self.original_error = original_error\n\nclass RPCProtocolError(RPCError):\n    \"\"\"Message format and serialization errors.\"\"\"\n    \n    def __init__(self, message: str, raw_data: bytes = b\"\", parse_stage: str = \"\"):\n        error_data = {\n            \"raw_data\": raw_data[:100].decode('utf-8', errors='replace') if raw_data else \"\",\n            \"parse_stage\": parse_stage,\n            \"data_length\": len(raw_data)\n        }\n        super().__init__(message, -32700, error_data)\n        self.raw_data = raw_data\n        self.parse_stage = parse_stage\n\nclass RPCMethodError(RPCError):\n    \"\"\"Method execution and dispatch errors.\"\"\"\n    \n    def __init__(self, message: str, method_name: str = \"\", params: list = None, \n                 execution_phase: str = \"\", original_error: Exception = None):\n        error_data = {\n            \"method_name\": method_name,\n            \"params\": params or [],\n            \"execution_phase\": execution_phase,\n            \"original_error\": str(original_error) if original_error else None\n        }\n        super().__init__(message, -32601, error_data)\n        self.method_name = method_name\n        self.params = params or []\n        self.execution_phase = execution_phase\n        self.original_error = original_error\n\nclass RPCTimeoutError(RPCError):\n    \"\"\"Request timeout errors.\"\"\"\n    \n    def __init__(self, message: str, timeout_seconds: float, elapsed_seconds: float = 0.0):\n        error_data = {\n            \"timeout_seconds\": timeout_seconds,\n            \"elapsed_seconds\": elapsed_seconds,\n            \"timed_out\": elapsed_seconds >= timeout_seconds\n        }\n        super().__init__(message, -32001, error_data)\n        self.timeout_seconds = timeout_seconds\n        self.elapsed_seconds = elapsed_seconds\n\n# Standard JSON-RPC error codes\nclass ErrorCode:\n    PARSE_ERROR = -32700\n    INVALID_REQUEST = -32600\n    METHOD_NOT_FOUND = -32601\n    INVALID_PARAMS = -32602\n    INTERNAL_ERROR = -32603\n    TRANSPORT_ERROR = -32000\n    TIMEOUT_ERROR = -32001\n    CONNECTION_ERROR = -32002\n```\n\n#### Network Operation Helpers\n\n```python\n\"\"\"\nRobust network operations with comprehensive error handling.\n\"\"\"\n\nimport select\nimport errno\n\nclass SocketHelper:\n    \"\"\"Utility class for robust socket operations with timeout handling.\"\"\"\n    \n    @staticmethod\n    def send_all(sock: socket.socket, data: bytes, timeout: float) -> None:\n        \"\"\"Send all data, handling partial sends and timeouts.\"\"\"\n        # TODO 1: Set socket to non-blocking mode for timeout control\n        # TODO 2: Use select() to wait for socket writability with timeout\n        # TODO 3: Handle partial sends by tracking bytes sent and continuing\n        # TODO 4: Raise RPCTransportError with context on failures\n        # TODO 5: Restore original socket blocking mode before returning\n        # Hint: socket.send() may send fewer bytes than requested\n        pass\n    \n    @staticmethod\n    def recv_all(sock: socket.socket, size: int, timeout: float) -> bytes:\n        \"\"\"Receive exact number of bytes, handling partial receives.\"\"\"\n        # TODO 1: Set socket to non-blocking mode and track received data\n        # TODO 2: Loop until all requested bytes are received\n        # TODO 3: Use select() with remaining timeout for each recv operation\n        # TODO 4: Handle partial receives by accumulating data\n        # TODO 5: Detect connection closure (recv returns 0 bytes)\n        # TODO 6: Raise appropriate errors for timeouts and connection issues\n        pass\n    \n    @staticmethod\n    def recv_message(sock: socket.socket, timeout: float) -> bytes:\n        \"\"\"Receive length-prefixed message.\"\"\"\n        # TODO 1: Receive 4-byte length prefix using recv_all\n        # TODO 2: Unpack length as big-endian unsigned integer\n        # TODO 3: Validate message length is reasonable (not > MAX_MESSAGE_SIZE)\n        # TODO 4: Receive message body using recv_all with remaining timeout\n        # TODO 5: Return complete message bytes\n        # Hint: Use struct.unpack('>I', length_bytes)[0] for length\n        pass\n    \n    @staticmethod\n    def send_message(sock: socket.socket, message_bytes: bytes, timeout: float) -> None:\n        \"\"\"Send length-prefixed message.\"\"\"\n        # TODO 1: Create 4-byte length prefix using struct.pack('>I', len(message))\n        # TODO 2: Send length prefix using send_all\n        # TODO 3: Send message body using send_all\n        # TODO 4: Handle any transport errors and re-raise with context\n        pass\n\ndef handle_socket_error(error: Exception, operation: str, host: str = \"\", port: int = 0) -> RPCTransportError:\n    \"\"\"Convert socket exceptions to structured RPC transport errors.\"\"\"\n    # TODO 1: Check error type and map to appropriate error message\n    # TODO 2: Handle ConnectionRefusedError, ConnectionResetError, timeout\n    # TODO 3: Handle OSError with specific errno values (EPIPE, ECONNRESET, etc.)\n    # TODO 4: Provide specific guidance based on error type\n    # TODO 5: Return RPCTransportError with original error context\n    pass\n```\n\n#### Serialization Error Handling\n\n```python\n\"\"\"\nMessage serialization with comprehensive error handling and validation.\n\"\"\"\n\nimport struct\nfrom typing import Dict, Any\n\nMAX_MESSAGE_SIZE = 1024 * 1024  # 1MB message limit\n\ndef serialize_message(message: Dict[str, Any]) -> bytes:\n    \"\"\"Serialize message to JSON with error handling.\"\"\"\n    try:\n        # TODO 1: Validate message structure has required fields\n        # TODO 2: Check for circular references in message data\n        # TODO 3: Serialize to JSON string with ensure_ascii=False\n        # TODO 4: Encode JSON string to UTF-8 bytes\n        # TODO 5: Check message size against MAX_MESSAGE_SIZE limit\n        # TODO 6: Return serialized bytes\n        pass\n    except (TypeError, ValueError) as e:\n        # TODO 7: Analyze error and provide specific guidance\n        # TODO 8: Check if error is due to non-serializable objects\n        # TODO 9: Raise RPCProtocolError with diagnostic information\n        pass\n    except UnicodeEncodeError as e:\n        # TODO 10: Handle Unicode encoding issues\n        # TODO 11: Provide character position and encoding details\n        pass\n\ndef deserialize_message(data: bytes) -> Dict[str, Any]:\n    \"\"\"Deserialize JSON message with comprehensive error handling.\"\"\"\n    try:\n        # TODO 1: Validate input data is not empty\n        # TODO 2: Decode bytes to UTF-8 string with error handling\n        # TODO 3: Parse JSON string to Python dict\n        # TODO 4: Validate message has required JSON-RPC fields\n        # TODO 5: Return validated message dict\n        pass\n    except UnicodeDecodeError as e:\n        # TODO 6: Handle encoding issues with position information\n        # TODO 7: Suggest UTF-8 encoding and provide sample bytes\n        pass\n    except json.JSONDecodeError as e:\n        # TODO 8: Handle JSON parsing errors with position details\n        # TODO 9: Provide context around error position for debugging\n        # TODO 10: Suggest common JSON syntax fixes\n        pass\n    except (KeyError, TypeError) as e:\n        # TODO 11: Handle schema validation errors\n        # TODO 12: Identify missing or wrong-type fields\n        pass\n\ndef validate_request_message(message: Dict[str, Any]) -> None:\n    \"\"\"Validate JSON-RPC request message format.\"\"\"\n    # TODO 1: Check required fields: jsonrpc, method, id\n    # TODO 2: Validate jsonrpc version is \"2.0\"\n    # TODO 3: Validate method is string and not empty\n    # TODO 4: Validate id is string, number, or null\n    # TODO 5: Validate params is array or object if present\n    # TODO 6: Raise RPCProtocolError with specific field issues\n    pass\n\ndef validate_response_message(message: Dict[str, Any]) -> None:\n    \"\"\"Validate JSON-RPC response message format.\"\"\"\n    # TODO 1: Check required fields: jsonrpc, id\n    # TODO 2: Validate exactly one of 'result' or 'error' is present\n    # TODO 3: Validate error object has code, message, and optional data\n    # TODO 4: Validate error code is integer and message is string\n    # TODO 5: Raise RPCProtocolError with validation details\n    pass\n```\n\n#### Error Recovery and Retry Logic\n\n```python\n\"\"\"\nConfigurable retry logic with exponential backoff for transient failures.\n\"\"\"\n\nimport random\nimport time\nfrom typing import Callable, Any, Optional, List, Type\nfrom dataclasses import dataclass\n\n@dataclass\nclass RetryConfig:\n    \"\"\"Configuration for retry behavior.\"\"\"\n    max_attempts: int = 3\n    base_delay: float = 0.1  # 100ms\n    max_delay: float = 5.0   # 5 seconds\n    backoff_multiplier: float = 2.0\n    jitter: bool = True\n    retryable_errors: List[Type[Exception]] = None\n    \n    def __post_init__(self):\n        if self.retryable_errors is None:\n            self.retryable_errors = [RPCTransportError, RPCTimeoutError]\n\nclass RetryHandler:\n    \"\"\"Implements exponential backoff retry logic for RPC operations.\"\"\"\n    \n    def __init__(self, config: RetryConfig):\n        self.config = config\n        self._attempt_lock = Lock()\n    \n    def execute_with_retry(self, operation: Callable[[], Any], \n                          operation_name: str = \"rpc_call\") -> Any:\n        \"\"\"Execute operation with retry logic.\"\"\"\n        last_error = None\n        \n        for attempt in range(1, self.config.max_attempts + 1):\n            try:\n                # TODO 1: Execute the operation and return result if successful\n                # TODO 2: Log retry attempts for debugging (not first attempt)\n                pass\n            except Exception as error:\n                # TODO 3: Check if error type is retryable using isinstance()\n                # TODO 4: If not retryable or last attempt, re-raise immediately\n                # TODO 5: Calculate delay for this attempt using exponential backoff\n                # TODO 6: Add jitter if configured (random factor 0.5-1.5x)\n                # TODO 7: Sleep for calculated delay before next attempt\n                # TODO 8: Store error for final re-raise if all attempts fail\n                pass\n        \n        # TODO 9: All attempts failed - re-raise the last error with retry context\n        pass\n    \n    def calculate_delay(self, attempt: int) -> float:\n        \"\"\"Calculate delay for retry attempt using exponential backoff.\"\"\"\n        # TODO 1: Calculate base delay: base_delay * (backoff_multiplier ^ (attempt-1))\n        # TODO 2: Apply maximum delay cap\n        # TODO 3: Add jitter if enabled: multiply by random factor 0.5 to 1.5\n        # TODO 4: Return final delay value\n        pass\n    \n    def is_retryable_error(self, error: Exception) -> bool:\n        \"\"\"Check if error type should trigger retry logic.\"\"\"\n        # TODO 1: Check if error is instance of any retryable error type\n        # TODO 2: For transport errors, check specific conditions (not auth failures)\n        # TODO 3: For timeout errors, check if timeout was reasonable\n        # TODO 4: Return True if retry is appropriate, False otherwise\n        pass\n```\n\n#### Milestone Checkpoints\n\n**After Milestone 1 (Message Protocol):**\n```bash\n# Test serialization error handling\npython -m pytest tests/test_protocol_errors.py -v\n\n# Expected behavior:\n# - Invalid JSON messages raise RPCProtocolError with parse details\n# - Oversized messages are rejected with size information\n# - Missing required fields provide specific field names in errors\n# - Unicode encoding issues include character position details\n```\n\n**After Milestone 2 (Server Implementation):**\n```bash\n# Test server error handling\npython -m pytest tests/test_server_errors.py -v\n\n# Expected behavior:\n# - Method not found returns structured error response\n# - Method execution errors are caught and returned as RPC errors\n# - Network disconnections are detected and connections cleaned up\n# - Invalid requests receive appropriate error codes\n```\n\n**After Milestone 3 (Client Implementation):**\n```bash\n# Test end-to-end error handling\npython -m pytest tests/test_client_errors.py -v\n\n# Expected behavior:\n# - Connection failures trigger retry logic with exponential backoff\n# - Timeout errors include timing information and don't hang\n# - Serialization errors prevent request sending with clear diagnostics\n# - Server errors are converted to appropriate client exceptions\n```\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---|---|---|---|\n| Client hangs indefinitely | Network timeout not properly handled | Check if `socket.settimeout()` is set | Implement proper timeout in `recv_all` |\n| \"Connection reset by peer\" errors | Server closing connections abruptly | Monitor server logs for exceptions during request processing | Add exception handling in server request loop |\n| JSON parse errors with valid JSON | Unicode encoding mismatch | Check raw bytes in error data for non-UTF8 | Ensure consistent UTF-8 encoding on both ends |\n| Intermittent \"Broken pipe\" errors | Client disconnecting during response send | Add connection health check before sending | Gracefully handle client disconnections |\n| Retry logic not triggering | Error not classified as retryable | Check error type inheritance and retry configuration | Verify `RPCTransportError` inheritance chain |\n| Memory usage growing over time | Error objects retaining large message data | Check error_data size in exception objects | Truncate large data in error serialization |\n\n\n## Testing Strategy\n\n> **Milestone(s):** All milestones - comprehensive testing approach for message protocol (Milestone 1), server implementation (Milestone 2), and client implementation (Milestone 3)\n\n### Mental Model: The Quality Control Factory\n\nThink of testing your RPC framework like a quality control factory with multiple inspection stations. Each milestone represents a production line stage where components must pass specific quality checks before moving to the next station. At the message protocol station, inspectors verify that every envelope (message) has the correct addressing and contents. At the server station, they test that the factory machinery (method registry and request dispatch) processes orders correctly. At the client station, they verify that the shipping department (proxy objects and connection management) delivers results reliably. Finally, the integration station tests the entire production line end-to-end, simulating real-world customer scenarios to ensure the whole system works harmoniously.\n\nThe key insight is that testing an RPC framework requires both **component isolation** and **system integration**. Component tests verify individual pieces work correctly in controlled conditions, while integration tests validate that components collaborate properly under realistic network conditions and error scenarios.\n\n### Milestone Checkpoints\n\nEach milestone introduces specific functionality that must be thoroughly verified before proceeding to the next stage. The checkpoint approach ensures that foundational components work correctly before building dependent layers, preventing cascading failures that become difficult to debug in later milestones.\n\n#### Milestone 1: Message Protocol Checkpoints\n\nThe message protocol checkpoint verifies that request/response serialization works correctly and handles all specified parameter types and error conditions.\n\n| Test Category | What to Verify | Expected Behavior | Failure Signals |\n|---------------|----------------|-------------------|------------------|\n| Request Serialization | `create_request_message` produces valid JSON-RPC | Method name, params, and ID present in serialized bytes | Missing fields, invalid JSON, incorrect format |\n| Response Serialization | `create_response_message` and `create_error_message` work | Result or error paired with matching request ID | ID mismatch, malformed error structure |\n| Message Deserialization | `deserialize_message` parses valid JSON correctly | Returns dict with expected fields and types | JSON decode errors, missing required fields |\n| Parameter Type Handling | Strings, numbers, objects, arrays serialize correctly | Round-trip preserves original values and types | Type conversion errors, precision loss |\n| Error Format Validation | Error messages follow JSON-RPC specification | Error code, message, and optional data fields present | Missing error codes, inconsistent format |\n\n**Verification Commands:**\n```bash\npython -m pytest tests/test_protocol.py -v\npython tests/manual_protocol_test.py\n```\n\n**Manual Testing Approach:**\nCreate test scripts that serialize various message types and verify the output manually. For example, create a request with complex nested parameters (lists containing objects with string and numeric fields) and confirm that deserialization produces identical data structures.\n\n> **Key Insight:** Protocol testing must validate both the happy path and edge cases. Test with empty parameter lists, null values, very large messages approaching `MAX_MESSAGE_SIZE`, and malformed JSON to ensure robust error handling.\n\n**Signs of Success:**\n- All message types serialize to valid JSON that matches the JSON-RPC specification format\n- Deserialization of serialized messages produces identical data structures (round-trip integrity)\n- Error messages contain all required fields and use standard error codes from `ErrorCode` constants\n- Large messages (approaching 1MB) serialize without truncation or memory issues\n\n**Troubleshooting Common Issues:**\n\n⚠️ **Pitfall: JSON Serialization Type Errors**\nSymptom: TypeError when calling `serialize_message` with certain parameter types\nCause: Python objects that aren't JSON-serializable (like custom classes or datetime objects)\nFix: Implement custom JSON encoder or validate parameter types before serialization\n\n⚠️ **Pitfall: Unicode Encoding Problems**\nSymptom: UnicodeDecodeError when deserializing messages containing non-ASCII characters\nCause: Inconsistent UTF-8 encoding/decoding between serialization and deserialization\nFix: Explicitly specify UTF-8 encoding in all string-to-bytes conversions\n\n#### Milestone 2: Server Implementation Checkpoints\n\nThe server checkpoint validates that method registration, request dispatch, and error handling work correctly for concurrent client connections.\n\n| Test Category | What to Verify | Expected Behavior | Failure Signals |\n|---------------|----------------|-------------------|------------------|\n| Method Registry | `register_method` stores callable functions correctly | Methods accessible by name, callable with correct signatures | KeyError when calling registered methods, signature mismatches |\n| TCP Server Startup | `start_server` listens on specified host and port | Server accepts incoming connections, binds to correct endpoint | Address already in use, permission denied, socket errors |\n| Request Parsing | `handle_connection` parses incoming JSON-RPC requests | Valid requests deserialize correctly, invalid requests return parse errors | Silent failures, missing error responses |\n| Method Dispatch | `process_request` invokes registered methods with parameters | Method execution with provided arguments returns expected results | Method not found errors, parameter count mismatches |\n| Error Response Format | Server returns properly formatted JSON-RPC errors | Error responses contain matching request ID and standard error codes | Missing request IDs, invalid error format |\n| Concurrent Handling | Multiple clients can connect and make requests simultaneously | Each request processed independently without interference | Request mixing, shared state corruption |\n\n**Verification Commands:**\n```bash\npython -m pytest tests/test_server.py -v\npython tests/server_integration_test.py\npython -c \"import rpc_server; server = rpc_server.RPCServer('localhost', 8080); server.start_server()\"\n```\n\n**Manual Testing Approach:**\nStart the server in one terminal, then use telnet or a simple client script to send raw JSON-RPC requests. Verify that the server responds with correctly formatted responses and handles malformed requests gracefully.\n\n**Test Method Registry:**\n```python\n# Register a simple test method\ndef add(a, b):\n    return a + b\n\nserver.register_method(\"add\", add)\n\n# Verify method is callable through registry\nresult = server.registry.methods[\"add\"](5, 3)\nassert result == 8\n```\n\n**Test Concurrent Connections:**\nUse multiple client connections simultaneously to verify that the thread-per-connection model handles concurrent requests without blocking or corrupting shared state.\n\n> **Key Insight:** Server testing requires verifying both functional correctness and concurrent behavior. The `MethodRegistry` must be thread-safe, and each client connection should operate independently without affecting other concurrent requests.\n\n**Signs of Success:**\n- Server starts successfully and listens on the specified port without binding errors\n- Method registry stores and retrieves callable functions correctly with thread safety\n- Valid JSON-RPC requests execute registered methods and return properly formatted responses\n- Invalid requests (malformed JSON, method not found, parameter errors) return standard JSON-RPC error responses\n- Multiple concurrent clients can connect and make requests simultaneously without interference\n- Server handles client disconnections gracefully without crashing or resource leaks\n\n**Troubleshooting Common Issues:**\n\n⚠️ **Pitfall: Socket Address Reuse Problems**\nSymptom: \"Address already in use\" error when restarting server quickly\nCause: Operating system holding socket in TIME_WAIT state after server shutdown\nFix: Set `SO_REUSEADDR` socket option and implement proper server shutdown cleanup\n\n⚠️ **Pitfall: Thread Resource Exhaustion**\nSymptom: Server stops accepting new connections after handling many clients\nCause: Creating new threads without proper cleanup when connections end\nFix: Use thread cleanup or implement connection pooling to limit concurrent threads\n\n⚠️ **Pitfall: Shared State Corruption**\nSymptom: Method calls return unexpected results when multiple clients connect\nCause: Registered methods accessing shared global variables without synchronization\nFix: Use thread-local storage or proper locking for shared state in registered methods\n\n#### Milestone 3: Client Implementation Checkpoints\n\nThe client checkpoint validates that method proxying, connection management, and timeout handling work correctly under various network conditions.\n\n| Test Category | What to Verify | Expected Behavior | Failure Signals |\n|---------------|----------------|-------------------|------------------|\n| Server Connection | `call` establishes TCP connection to server | Client connects to specified host and port successfully | Connection refused, timeout errors, network unreachable |\n| Method Proxying | `RPCProxy.__getattr__` creates callable methods | Proxy objects allow natural method call syntax | AttributeError, method calls don't send requests |\n| Request Transmission | `call` sends properly formatted JSON-RPC requests | Requests include method name, parameters, and unique IDs | Malformed requests, missing request IDs |\n| Response Correlation | Client matches responses to correct pending requests | Responses return to the originating method call | Request/response ID mismatches, blocking forever |\n| Timeout Handling | `call` respects timeout parameter and raises `RPCTimeoutError` | Calls abort after specified timeout duration | Hanging indefinitely, premature timeouts |\n| Connection Reuse | Multiple calls use the same TCP connection efficiently | Single connection handles multiple sequential requests | New connection for every request, connection leaks |\n| Error Propagation | Server errors propagate to client as appropriate exceptions | JSON-RPC errors raise `RPCMethodError` with server details | Silent failures, generic exceptions without context |\n\n**Verification Commands:**\n```bash\npython -m pytest tests/test_client.py -v\npython tests/client_integration_test.py\npython tests/client_server_integration.py\n```\n\n**Manual Testing Approach:**\nStart a test server with known methods, then create client instances and verify that proxy method calls work as expected. Test timeout behavior by calling methods that intentionally delay longer than the timeout setting.\n\n**Test Method Proxying:**\n```python\n# Create client and proxy\nclient = RPCClient(\"localhost\", 8080)\nproxy = RPCProxy(client)\n\n# Call methods using natural syntax\nresult = proxy.add(10, 20)\nassert result == 30\n\n# Verify timeout behavior\ntry:\n    proxy.slow_method(timeout=1.0)  # Method takes 5 seconds\n    assert False, \"Should have timed out\"\nexcept RPCTimeoutError as e:\n    assert e.timeout_seconds == 1.0\n```\n\n**Test Connection Management:**\n```python\nclient = RPCClient(\"localhost\", 8080)\n\n# Verify connection reuse\nresult1 = client.call(\"method1\", [])\nresult2 = client.call(\"method2\", [])\n# Both calls should use same socket connection\n\n# Verify connection cleanup\nclient._disconnect()\nassert client._connected == False\n```\n\n> **Key Insight:** Client testing must validate both the programming interface (method proxying feels natural) and the network behavior (connection reuse, timeout handling, error propagation). The proxy pattern should be transparent to the user while handling all RPC complexity internally.\n\n**Signs of Success:**\n- Client connects to server successfully and establishes stable TCP connection\n- Proxy objects allow method calls with natural Python syntax (proxy.method_name(args))\n- Method calls send correctly formatted JSON-RPC requests and receive matching responses\n- Request IDs are generated uniquely and responses correlate to the correct pending requests\n- Timeout handling works reliably, aborting slow requests after the specified duration\n- Connection reuse functions correctly, using a single TCP connection for multiple sequential calls\n- Server errors propagate as appropriate client-side exceptions with diagnostic information\n\n**Troubleshooting Common Issues:**\n\n⚠️ **Pitfall: Request/Response ID Correlation Errors**\nSymptom: Method calls return results from different requests or hang indefinitely\nCause: Request ID generation not unique or response matching logic incorrect\nFix: Use UUID for request IDs and verify response correlation logic handles concurrent requests\n\n⚠️ **Pitfall: Connection State Corruption**\nSymptom: Client errors after first successful call or intermittent connection failures\nCause: Socket state not properly managed between requests\nFix: Implement proper connection state tracking and recovery logic in `_ensure_connected`\n\n⚠️ **Pitfall: Timeout Not Interrupting Socket Operations**\nSymptom: Timeout parameter ignored, client hangs on unresponsive server\nCause: Socket operations (send/recv) not respecting timeout settings\nFix: Set socket timeout before each operation and handle socket timeout exceptions properly\n\n### Integration Test Scenarios\n\nIntegration testing verifies that the complete RPC framework functions correctly under realistic conditions, testing the interactions between all components and handling real-world edge cases that don't appear in unit tests.\n\n#### End-to-End RPC Call Scenarios\n\nThese scenarios test the complete flow from client method invocation through network transport to server execution and response handling.\n\n| Scenario | Setup | Expected Behavior | Validation Points |\n|----------|-------|-------------------|-------------------|\n| Basic Method Call | Server with `add(a, b)` method, client calls `proxy.add(5, 3)` | Returns 8, request/response IDs match | Message format, method execution, response correlation |\n| Complex Parameter Types | Server method accepting nested objects and arrays | Parameters preserve types and structure through serialization | JSON round-trip integrity, type preservation |\n| Method Not Found | Client calls `proxy.nonexistent_method()` on server without that method | Raises `RPCMethodError` with `METHOD_NOT_FOUND` error code | Error propagation, standard error codes |\n| Server Method Exception | Registered method raises Python exception during execution | Client receives `RPCMethodError` with exception details | Error handling, exception message preservation |\n| Large Message Transfer | Method with parameters approaching `MAX_MESSAGE_SIZE` | Successful transfer without truncation or memory errors | Message framing, size limits, memory efficiency |\n| Multiple Sequential Calls | Client makes 10 method calls using same connection | All calls succeed with connection reuse | Connection management, request correlation |\n| Concurrent Client Connections | 5 clients simultaneously calling server methods | All requests processed correctly without interference | Thread safety, concurrent request handling |\n\n**Basic End-to-End Test Implementation:**\n\nThe following test scenario validates that a complete RPC call works correctly from client method invocation to server response:\n\n1. Start `RPCServer` with a registered `add` method that returns the sum of two parameters\n2. Create `RPCClient` and `RPCProxy` connecting to the server\n3. Call `proxy.add(10, 20)` using natural method syntax\n4. Verify that the call returns 30 and the request/response correlation worked correctly\n5. Check that the TCP connection remains open for subsequent calls\n6. Validate that the JSON-RPC message format was used correctly throughout the exchange\n\n**Complex Parameter Handling Test:**\n\nThis scenario ensures that complex data structures survive the serialization round-trip correctly:\n\n1. Register server method `process_data(data)` that returns a modified version of the input data structure\n2. Create test data containing nested objects, arrays, strings, numbers, and null values\n3. Call `proxy.process_data(complex_data)` and verify the response preserves all data types and structure\n4. Test edge cases like empty arrays, deeply nested objects, and Unicode strings\n5. Verify that the serialization process doesn't introduce type conversion errors or data loss\n\n**Error Handling Integration Test:**\n\nThis scenario validates that errors propagate correctly from server to client with proper diagnostic information:\n\n1. Register server method that intentionally raises various types of exceptions\n2. Call methods that trigger different error conditions: method not found, parameter validation errors, execution exceptions\n3. Verify that each error type results in the appropriate client-side exception with accurate error codes and messages\n4. Test error handling during network failures: server disconnection, timeout scenarios, malformed responses\n5. Ensure that error conditions don't corrupt the connection state for subsequent requests\n\n#### Network Failure and Recovery Scenarios\n\nThese scenarios test how the RPC framework handles various network failure modes and recovery situations.\n\n| Failure Mode | Trigger Condition | Expected Behavior | Recovery Validation |\n|--------------|-------------------|-------------------|---------------------|\n| Server Disconnect During Call | Server process killed while client waiting for response | Client raises `RPCTransportError` with connection details | Subsequent calls detect disconnection and attempt reconnection |\n| Connection Timeout | Server accepts connection but doesn't respond to requests | Client raises `RPCTimeoutError` after specified timeout | Connection marked as failed, new connection established for next call |\n| Partial Message Transmission | Network interruption during large message transfer | Client detects incomplete message and raises transport error | Connection reset, retry logic handles partial transfers |\n| Server Overload | Server cannot accept new connections due to resource limits | Client receives connection refused error with retry suggestion | Client implements exponential backoff for connection retries |\n| Intermittent Network Issues | Connection drops randomly during request/response cycle | Framework detects connection failures and recovers gracefully | Automatic reconnection without user intervention |\n\n**Connection Failure Recovery Test:**\n\nThis scenario validates that the client handles server disconnection gracefully and recovers for subsequent requests:\n\n1. Start server and establish client connection with successful initial request\n2. Kill server process while client has a pending request waiting for response\n3. Verify that client detects connection failure and raises `RPCTransportError` with appropriate error details\n4. Restart server and make another client request\n5. Confirm that client establishes new connection automatically and request succeeds\n6. Validate that connection state tracking correctly reflects the disconnection and reconnection\n\n**Timeout Handling Integration Test:**\n\nThis scenario ensures that timeout handling works correctly under realistic network conditions:\n\n1. Configure server method that intentionally delays longer than client timeout setting\n2. Make client request with specific timeout value shorter than method execution time\n3. Verify that client raises `RPCTimeoutError` with accurate timeout duration and elapsed time\n4. Ensure that timed-out connection is properly cleaned up and doesn't interfere with subsequent requests\n5. Test timeout handling with various timeout values to ensure accuracy across different durations\n\n#### Stress and Performance Scenarios\n\nThese scenarios validate that the RPC framework maintains correctness under load and performs adequately for typical use cases.\n\n| Load Scenario | Configuration | Success Criteria | Performance Expectations |\n|---------------|---------------|------------------|-------------------------|\n| High Request Rate | Single client making 1000 sequential requests | All requests complete successfully with correct responses | Average latency under 10ms for simple methods |\n| Multiple Concurrent Clients | 20 clients each making 100 requests simultaneously | No request mixing, all responses correlate correctly | Server handles concurrent load without blocking |\n| Large Message Stress | Requests with payloads near maximum message size | All large messages transfer completely without corruption | Memory usage remains bounded, no memory leaks |\n| Long-Running Server | Server handling requests continuously for 1 hour | No resource leaks, consistent response times | Memory and file descriptor usage remains stable |\n| Connection Pool Stress | Rapid connection/disconnection cycles | No socket resource exhaustion, proper cleanup | Operating system socket limits not exceeded |\n\n**Concurrent Client Load Test:**\n\nThis scenario validates that the server's thread-per-connection model handles concurrent requests correctly:\n\n1. Create 10 client instances, each running in a separate thread\n2. Each client makes 50 requests to different server methods simultaneously\n3. Verify that all 500 total requests complete successfully with correct results\n4. Check that request/response correlation works correctly across concurrent clients\n5. Monitor server resource usage to ensure thread creation and cleanup work properly\n6. Validate that no shared state corruption occurs between concurrent requests\n\n**Memory and Resource Stress Test:**\n\nThis scenario ensures that the framework doesn't leak resources under sustained load:\n\n1. Run client making continuous requests for 30 minutes with periodic garbage collection\n2. Monitor memory usage of both client and server processes throughout the test\n3. Verify that socket file descriptors are properly closed after use\n4. Check that thread resources are cleaned up when client connections end\n5. Ensure that message buffers and connection state don't accumulate over time\n\n> **Key Insight:** Integration testing reveals issues that don't appear in unit tests, particularly around resource management, concurrent access, and network failure handling. These scenarios test the framework's behavior under realistic conditions rather than ideal laboratory settings.\n\n#### Error Recovery and Resilience Scenarios\n\nThese scenarios test how well the framework handles and recovers from various error conditions that occur in production environments.\n\n| Error Condition | Setup | Expected Recovery | Validation |\n|-----------------|-------|-------------------|------------|\n| Serialization Failure | Method parameters that can't be JSON-serialized | Client raises appropriate error before sending request | No malformed data sent to server |\n| Server Method Crash | Registered method with unhandled exception | Server sends error response, remains available for other requests | Server doesn't crash, other clients unaffected |\n| Network Partition | Temporary network disconnection during active session | Client detects failure, retries when network recovers | Automatic recovery without manual intervention |\n| Server Resource Exhaustion | Server running out of memory or file descriptors | Graceful degradation with appropriate error responses | Server remains stable, doesn't crash completely |\n| Message Size Limit Exceeded | Request larger than `MAX_MESSAGE_SIZE` | Client or server rejects message before processing | Clear error message about size limits |\n\n**Serialization Error Handling Test:**\n\nThis scenario validates that serialization errors are caught and handled appropriately:\n\n1. Attempt to call server method with parameters containing non-serializable objects (e.g., file handles, custom classes)\n2. Verify that client detects serialization failure before sending request to server\n3. Ensure that serialization error raises `RPCProtocolError` with diagnostic information about the problematic data\n4. Test that client connection remains usable after serialization error for subsequent valid requests\n\n**Server Resilience Test:**\n\nThis scenario ensures that server errors don't affect other clients or crash the server:\n\n1. Register server method that raises various types of exceptions (ValueError, KeyError, custom exceptions)\n2. Create multiple client connections, some calling problematic methods and others calling normal methods\n3. Verify that method exceptions are caught, converted to JSON-RPC error responses, and sent to the appropriate client\n4. Confirm that server continues running and handling requests from other clients normally\n5. Test that exception details are preserved in error responses for debugging purposes\n\n### Implementation Guidance\n\nThis section provides practical testing infrastructure and verification procedures to help implement comprehensive testing for the RPC framework.\n\n#### Testing Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Unit Testing | Python unittest (built-in) | pytest with fixtures and parameterized tests |\n| Integration Testing | Manual test scripts | pytest with test containers |\n| Network Testing | Local loopback connections | Docker containers with network simulation |\n| Load Testing | Threading module with simple loops | locust or concurrent.futures for realistic load |\n| Mocking | unittest.mock (built-in) | pytest-mock with advanced stubbing |\n\n#### Test File Structure\n\nOrganize test files to match the component structure and separate unit tests from integration tests:\n\n```\nrpc_framework/\n  src/\n    rpc/\n      protocol.py          ← Message protocol implementation\n      server.py           ← RPC server implementation  \n      client.py           ← RPC client implementation\n      errors.py           ← Error classes\n  tests/\n    unit/\n      test_protocol.py    ← Protocol serialization tests\n      test_server.py      ← Server component tests\n      test_client.py      ← Client component tests\n      test_errors.py      ← Error handling tests\n    integration/\n      test_end_to_end.py  ← Full RPC call scenarios\n      test_failure_modes.py ← Network failure tests\n      test_load.py        ← Performance and stress tests\n    helpers/\n      test_server.py      ← Test server utilities\n      test_client.py      ← Test client utilities\n      fixtures.py         ← Common test data\n```\n\n#### Unit Test Infrastructure Starter Code\n\nComplete testing utilities that provide the foundation for all milestone testing:\n\n```python\n# tests/helpers/test_server.py\nimport threading\nimport time\nimport socket\nfrom typing import Optional, Callable, Dict, Any\nfrom src.rpc.server import RPCServer\n\nclass TestServerHelper:\n    \"\"\"Helper class for managing test servers in unit and integration tests.\"\"\"\n    \n    def __init__(self, host: str = \"localhost\", port: int = 0):\n        self.host = host\n        self.port = port\n        self.server: Optional[RPCServer] = None\n        self.server_thread: Optional[threading.Thread] = None\n        self._methods: Dict[str, Callable] = {}\n    \n    def register_method(self, name: str, method: Callable):\n        \"\"\"Register a method for the test server.\"\"\"\n        self._methods[name] = method\n    \n    def start(self) -> int:\n        \"\"\"Start the test server and return the actual port number.\"\"\"\n        # TODO 1: Create RPCServer instance with host and port\n        # TODO 2: Register all methods from self._methods\n        # TODO 3: Start server in background thread\n        # TODO 4: Wait for server to start listening\n        # TODO 5: Return actual port number (important when port=0)\n        pass\n    \n    def stop(self):\n        \"\"\"Stop the test server and clean up resources.\"\"\"\n        # TODO 1: Signal server to stop\n        # TODO 2: Wait for server thread to complete\n        # TODO 3: Clean up server resources\n        pass\n    \n    def is_running(self) -> bool:\n        \"\"\"Check if the test server is currently running.\"\"\"\n        # TODO: Check server state and thread status\n        pass\n\n# tests/helpers/test_client.py  \nimport time\nfrom typing import Any, List, Dict\nfrom src.rpc.client import RPCClient\nfrom src.rpc.errors import RPCError\n\nclass TestClientHelper:\n    \"\"\"Helper for testing client behavior and collecting metrics.\"\"\"\n    \n    def __init__(self, host: str, port: int):\n        self.host = host\n        self.port = port\n        self.client = RPCClient(host, port)\n        self.call_history: List[Dict[str, Any]] = []\n        \n    def call_with_timing(self, method_name: str, params: List[Any], timeout: float = 5.0) -> Dict[str, Any]:\n        \"\"\"Make an RPC call and record timing and result information.\"\"\"\n        start_time = time.time()\n        error = None\n        result = None\n        \n        try:\n            result = self.client.call(method_name, *params, timeout=timeout)\n        except Exception as e:\n            error = e\n        \n        end_time = time.time()\n        \n        call_record = {\n            'method': method_name,\n            'params': params,\n            'start_time': start_time,\n            'end_time': end_time,\n            'duration': end_time - start_time,\n            'result': result,\n            'error': error,\n            'success': error is None\n        }\n        \n        self.call_history.append(call_record)\n        \n        if error:\n            raise error\n        return result\n    \n    def get_average_latency(self) -> float:\n        \"\"\"Calculate average latency for successful calls.\"\"\"\n        # TODO: Calculate average duration from call_history for successful calls\n        pass\n    \n    def get_error_rate(self) -> float:\n        \"\"\"Calculate percentage of calls that resulted in errors.\"\"\"\n        # TODO: Calculate ratio of failed calls to total calls\n        pass\n    \n    def reset_metrics(self):\n        \"\"\"Clear call history and reset metrics.\"\"\"\n        self.call_history.clear()\n```\n\n#### Milestone Checkpoint Implementation\n\nComplete test cases that verify each milestone's core functionality:\n\n```python\n# tests/unit/test_protocol.py\nimport pytest\nimport json\nfrom src.rpc.protocol import create_request_message, create_response_message, serialize_message, deserialize_message\nfrom src.rpc.errors import ErrorCode\n\nclass TestProtocolMilestone:\n    \"\"\"Tests for Milestone 1 - Message Protocol implementation.\"\"\"\n    \n    def test_create_request_message_basic(self):\n        \"\"\"Verify request message contains required fields.\"\"\"\n        # TODO 1: Create request with method name, parameters, and request ID\n        # TODO 2: Assert message contains 'jsonrpc', 'method', 'params', 'id' fields\n        # TODO 3: Verify field values match input parameters\n        pass\n    \n    def test_request_response_serialization_roundtrip(self):\n        \"\"\"Verify messages can be serialized and deserialized without data loss.\"\"\"\n        # TODO 1: Create request with complex nested parameters\n        # TODO 2: Serialize to bytes using serialize_message\n        # TODO 3: Deserialize bytes back to dict using deserialize_message  \n        # TODO 4: Assert original and deserialized data are identical\n        pass\n    \n    @pytest.mark.parametrize(\"params,expected_type\", [\n        ([1, 2, 3], list),\n        ({\"key\": \"value\"}, dict),\n        (\"test string\", str),\n        (42.5, float),\n        (None, type(None))\n    ])\n    def test_parameter_type_preservation(self, params, expected_type):\n        \"\"\"Verify different parameter types are preserved through serialization.\"\"\"\n        # TODO 1: Create request message with given params\n        # TODO 2: Serialize and deserialize the message\n        # TODO 3: Assert parameter types are preserved exactly\n        pass\n    \n    def test_error_message_format(self):\n        \"\"\"Verify error messages follow JSON-RPC specification.\"\"\"\n        # TODO 1: Create error message with code, message, and data\n        # TODO 2: Assert error structure contains required fields\n        # TODO 3: Verify error codes match ErrorCode constants\n        pass\n\n# tests/integration/test_end_to_end.py\nimport pytest\nimport threading\nimport time\nfrom tests.helpers.test_server import TestServerHelper\nfrom tests.helpers.test_client import TestClientHelper\n\nclass TestEndToEndScenarios:\n    \"\"\"Integration tests for complete RPC framework functionality.\"\"\"\n    \n    def setup_method(self):\n        \"\"\"Set up test server with sample methods.\"\"\"\n        self.server_helper = TestServerHelper()\n        \n        # Register test methods\n        self.server_helper.register_method(\"add\", lambda a, b: a + b)\n        self.server_helper.register_method(\"echo\", lambda msg: msg)\n        self.server_helper.register_method(\"slow_method\", lambda: time.sleep(2))\n        \n        # Start server and get port\n        self.port = self.server_helper.start()\n        self.client_helper = TestClientHelper(\"localhost\", self.port)\n    \n    def teardown_method(self):\n        \"\"\"Clean up test server and client.\"\"\"\n        self.server_helper.stop()\n    \n    def test_basic_method_call(self):\n        \"\"\"Verify basic RPC call works end-to-end.\"\"\"\n        # TODO 1: Make simple method call using client helper\n        # TODO 2: Verify correct result is returned\n        # TODO 3: Check that call completed in reasonable time\n        pass\n    \n    def test_multiple_sequential_calls(self):\n        \"\"\"Verify connection reuse for multiple calls.\"\"\"\n        # TODO 1: Make 10 sequential method calls\n        # TODO 2: Verify all calls succeed with correct results\n        # TODO 3: Check that connection was reused (timing analysis)\n        pass\n    \n    def test_timeout_handling(self):\n        \"\"\"Verify timeout behavior for slow methods.\"\"\"\n        # TODO 1: Call slow_method with short timeout\n        # TODO 2: Assert RPCTimeoutError is raised\n        # TODO 3: Verify timeout duration is respected\n        pass\n    \n    def test_concurrent_clients(self):\n        \"\"\"Verify server handles multiple concurrent clients.\"\"\"\n        # TODO 1: Create multiple client threads\n        # TODO 2: Each client makes multiple requests simultaneously\n        # TODO 3: Verify all requests complete successfully\n        # TODO 4: Assert no request mixing or correlation errors\n        pass\n```\n\n#### Load and Stress Testing Infrastructure\n\n```python\n# tests/integration/test_load.py\nimport pytest\nimport threading\nimport time\nimport statistics\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nfrom tests.helpers.test_server import TestServerHelper\nfrom tests.helpers.test_client import TestClientHelper\n\nclass TestLoadScenarios:\n    \"\"\"Stress and performance tests for RPC framework.\"\"\"\n    \n    def setup_method(self):\n        self.server_helper = TestServerHelper()\n        \n        # Register performance test methods\n        self.server_helper.register_method(\"fast_add\", lambda a, b: a + b)\n        self.server_helper.register_method(\"cpu_intensive\", self._cpu_work)\n        self.server_helper.register_method(\"large_response\", self._generate_large_data)\n        \n        self.port = self.server_helper.start()\n    \n    def _cpu_work(self, iterations: int = 1000):\n        \"\"\"CPU-intensive method for performance testing.\"\"\"\n        # TODO: Implement method that does meaningful CPU work\n        pass\n    \n    def _generate_large_data(self, size_kb: int = 100):\n        \"\"\"Generate large response data for testing message size limits.\"\"\"\n        # TODO: Generate dictionary with specified size in KB\n        pass\n    \n    def test_high_request_rate(self):\n        \"\"\"Test server performance under high request rate.\"\"\"\n        client = TestClientHelper(\"localhost\", self.port)\n        \n        # TODO 1: Make 1000 requests as quickly as possible\n        # TODO 2: Record latency for each request\n        # TODO 3: Assert average latency is under threshold\n        # TODO 4: Verify no requests failed\n        pass\n    \n    def test_concurrent_client_load(self):\n        \"\"\"Test server with multiple concurrent clients.\"\"\"\n        num_clients = 20\n        requests_per_client = 50\n        \n        def client_worker(client_id):\n            # TODO 1: Create client helper for this thread\n            # TODO 2: Make specified number of requests\n            # TODO 3: Return performance metrics\n            pass\n        \n        # TODO 1: Create thread pool with client workers\n        # TODO 2: Execute all workers concurrently\n        # TODO 3: Collect and analyze results\n        # TODO 4: Assert performance requirements are met\n        pass\n    \n    def test_memory_stability(self):\n        \"\"\"Verify no memory leaks during sustained operation.\"\"\"\n        import psutil\n        import os\n        \n        process = psutil.Process(os.getpid())\n        initial_memory = process.memory_info().rss\n        \n        # TODO 1: Run continuous requests for 5 minutes\n        # TODO 2: Monitor memory usage throughout test\n        # TODO 3: Assert memory growth is bounded\n        # TODO 4: Verify garbage collection works correctly\n        pass\n```\n\n#### Debugging and Verification Tools\n\n```python\n# tests/helpers/debug_tools.py\nimport json\nimport socket\nfrom typing import Dict, Any, List\nfrom src.rpc.protocol import serialize_message, deserialize_message\n\nclass RPCDebugger:\n    \"\"\"Tools for debugging RPC framework issues.\"\"\"\n    \n    @staticmethod\n    def validate_message_format(message_dict: Dict[str, Any]) -> List[str]:\n        \"\"\"Validate JSON-RPC message format and return list of issues.\"\"\"\n        issues = []\n        \n        # TODO 1: Check for required JSON-RPC fields\n        # TODO 2: Validate field types and values\n        # TODO 3: Return list of format violations found\n        pass\n    \n    @staticmethod\n    def trace_rpc_call(host: str, port: int, method: str, params: List[Any]):\n        \"\"\"Make RPC call with detailed tracing of message flow.\"\"\"\n        print(f\"=== RPC Call Trace: {method}({params}) ===\")\n        \n        # TODO 1: Create and display request message\n        # TODO 2: Show serialized bytes\n        # TODO 3: Connect to server and trace network communication\n        # TODO 4: Display response and any errors\n        pass\n    \n    @staticmethod\n    def test_server_connectivity(host: str, port: int, timeout: float = 5.0) -> Dict[str, Any]:\n        \"\"\"Test basic connectivity to RPC server.\"\"\"\n        result = {\n            'host': host,\n            'port': port,\n            'connected': False,\n            'error': None,\n            'latency_ms': None\n        }\n        \n        # TODO 1: Attempt TCP connection\n        # TODO 2: Measure connection latency\n        # TODO 3: Test basic socket communication\n        # TODO 4: Return diagnostic information\n        pass\n```\n\nThis comprehensive testing strategy ensures that each milestone is properly validated before proceeding to the next, while integration tests verify that all components work together correctly under realistic conditions. The provided infrastructure code gives learners a solid foundation for implementing their own test cases without getting bogged down in testing framework setup.\n\n\n## Debugging Guide\n\n> **Milestone(s):** All milestones - debugging techniques apply throughout message protocol (Milestone 1), server implementation (Milestone 2), and client implementation (Milestone 3), and their integration\n\nBuilding an RPC framework involves multiple layers of complexity - network communication, serialization, concurrency, and error propagation. When something goes wrong, the symptoms often manifest far from the root cause, making debugging challenging for developers new to distributed systems. This guide provides systematic approaches to identify, diagnose, and resolve the most common issues encountered when implementing our RPC framework.\n\n![Error Handling Flowchart](./diagrams/error-handling-flow.svg)\n\n### Mental Model: The Detective's Investigation Process\n\nThink of debugging RPC issues like a detective investigating a crime scene. You start with symptoms (the \"crime\") - perhaps a client call hangs indefinitely, or the server crashes with a cryptic error. Like a detective, you must gather evidence systematically, form hypotheses about what went wrong, and test each theory until you find the root cause. The key is following a structured process rather than randomly changing code and hoping for the best.\n\nJust as a detective looks for patterns (multiple similar crimes suggest a serial perpetrator), RPC debugging benefits from recognizing common failure patterns. Network issues have different \"fingerprints\" than serialization problems, which look different from timing issues. Learning to read these patterns accelerates diagnosis.\n\nThe detective also knows that the most obvious suspect isn't always guilty. In RPC debugging, the error message you see might be a secondary effect. A \"connection refused\" error might actually be caused by the server crashing due to a serialization bug, not a networking problem. Always dig deeper than the surface symptoms.\n\n### Connection and Network Issues\n\nNetwork problems are often the first roadblock when building RPC systems, because they involve multiple moving parts - sockets, TCP protocol behavior, firewalls, and operating system networking stacks. These issues can be particularly frustrating because they often work fine in development but fail in different environments.\n\n> **Key Insight**: Network issues usually manifest as exceptions during connection establishment or data transfer, but the root cause might be configuration, timing, or resource exhaustion rather than actual network connectivity problems.\n\n#### Common Network Failure Patterns\n\nThe following table catalogs the most frequent network-related issues and their diagnostic approaches:\n\n| Symptom | Likely Root Cause | Diagnostic Steps | Resolution Strategy |\n|---------|------------------|------------------|-------------------|\n| `ConnectionRefusedError` on client | Server not running or wrong port | `netstat -an \\| grep PORT`, `telnet HOST PORT` | Verify server startup, check port binding |\n| Client hangs on `connect()` | Firewall blocking, wrong IP | `ping HOST`, `traceroute HOST`, check firewall rules | Network configuration, security groups |\n| `BrokenPipeError` during send | Server closed connection unexpectedly | Check server logs for crashes, monitor server process | Fix server-side errors causing disconnection |\n| `ConnectionResetError` mid-call | Server or network dropped connection | Network monitoring, server resource usage | Implement connection health checks, retry logic |\n| Intermittent `TimeoutError` | Network latency spikes or server overload | Measure round-trip times, server CPU usage | Increase timeouts, add server capacity |\n| `AddressAlreadyInUse` on server start | Previous server instance still bound to port | `lsof -i :PORT`, check for zombie processes | Clean shutdown, SO_REUSEADDR socket option |\n\n#### Socket State Debugging\n\nUnderstanding TCP socket states helps diagnose connection issues. The `RPCClient` and `RPCServer` maintain socket connections that transition through predictable states. When debugging, check the actual socket state against the expected state:\n\n| Expected Client State | Socket State | Diagnostic Command | Common Mismatches |\n|----------------------|--------------|-------------------|-------------------|\n| Disconnected | No socket entry | `netstat -an` | Leaked sockets from previous connections |\n| Connecting | `SYN_SENT` | `ss -t state syn-sent` | Stuck in connecting due to firewall |\n| Connected | `ESTABLISHED` | `ss -t state established` | Socket shows established but RPC calls fail |\n| Disconnecting | `FIN_WAIT1`, `FIN_WAIT2` | `ss -t state fin-wait-1` | Clean shutdown taking too long |\n\n#### Server Connection Handling\n\nThe `RPCServer` accepts incoming connections and spawns threads to handle each client. Common issues arise from resource limits, thread management, and proper socket cleanup:\n\n**Connection Accept Loop Issues:**\n\n1. **Server stops accepting new connections**: Usually caused by the accept loop exiting due to an unhandled exception. Check server logs for stack traces around the last successful connection.\n\n2. **`accept()` returns immediately with `EMFILE`**: The server has exhausted file descriptors. This happens when client connections aren't properly closed, leading to fd leaks.\n\n3. **New connections hang in `SYN_RECEIVED`**: The server's accept backlog is full. Increase the backlog parameter in `listen()` or process connections faster.\n\n**Thread Management Problems:**\n\nServer threading issues often manifest as resource exhaustion or hanging connections. The thread-per-connection model can consume significant resources:\n\n| Problem | Symptoms | Diagnosis | Solution |\n|---------|----------|-----------|----------|\n| Thread leak | Memory usage grows indefinitely | `ps -eLf \\| grep python \\| wc -l` | Ensure threads join after client disconnect |\n| Too many threads | `OSError: can't create thread` | Monitor thread count vs system limits | Connection pooling, async I/O |\n| Deadlock in threads | Some connections hang indefinitely | Thread dump, check `MethodRegistry` lock usage | Review locking order, use timeouts |\n\n⚠️ **Pitfall: Forgetting to set `daemon=True` on handler threads**\n\nWhen creating threads to handle client connections, forgetting to set `daemon=True` means the server process won't exit cleanly when the main thread ends. The process hangs waiting for handler threads to complete, which never happens if clients are still connected. Always use `daemon=True` for connection handler threads, and implement graceful shutdown if you need to wait for requests to complete.\n\n#### Client Connection Management\n\nThe `RPCClient` maintains a persistent connection to the server, which introduces complexity around connection lifecycle management:\n\n**Connection Establishment Issues:**\n\n1. **Initial connection succeeds but subsequent calls fail**: The client socket might be in an inconsistent state. Implement connection health checks by sending a small test message before important RPC calls.\n\n2. **Connection works locally but fails in production**: Different network environments (NAT, load balancers, proxies) can interfere with TCP connections. Log the actual IP addresses being used to ensure correct routing.\n\n3. **Connection timeouts are too short/long**: Network conditions vary dramatically. Implement adaptive timeouts that adjust based on measured round-trip times.\n\n**Connection Reuse Problems:**\n\nThe `_ensure_connected()` method determines when to establish or reuse connections. Common mistakes include:\n\n- Not detecting broken connections before reuse\n- Racing between connection cleanup and new requests\n- Sharing connections across threads without proper synchronization\n\n#### Network Timeout Behavior\n\nTimeouts in network programming have subtle behavior that often surprises developers. The `RPCClient` must handle multiple timeout scenarios:\n\n| Timeout Type | What It Controls | Default Behavior | Debugging Tips |\n|--------------|------------------|------------------|----------------|\n| Connection timeout | Time to establish socket connection | OS default (often 60+ seconds) | Use `socket.settimeout()` before `connect()` |\n| Send timeout | Time to send complete message | Blocks indefinitely | Use `select()` or async I/O |\n| Receive timeout | Time to receive complete response | Blocks indefinitely | Set socket timeout, handle `socket.timeout` |\n| RPC call timeout | End-to-end call completion | Application-defined | Track time from request send to response |\n\n> **Design Insight**: Network timeouts should be layered - a short connection timeout (5-10 seconds), medium send/receive timeouts (30 seconds), and longer RPC call timeouts (60+ seconds). This provides fast feedback for obvious failures while allowing legitimate long-running operations to complete.\n\n#### Testing Network Edge Cases\n\nNetwork issues are often intermittent and environment-dependent. Systematic testing helps identify problems before they occur in production:\n\n**Network Simulation Techniques:**\n\n1. **Latency injection**: Use `tc` (traffic control) on Linux to add artificial network delays: `tc qdisc add dev lo root netem delay 100ms`\n\n2. **Packet loss simulation**: Simulate unreliable networks: `tc qdisc add dev lo root netem loss 1%`\n\n3. **Bandwidth limiting**: Test behavior under slow connections: `tc qdisc add dev lo root tbf rate 1kbit burst 1600 limit 3000`\n\n4. **Connection interruption**: Use `iptables` to drop connections mid-stream and test recovery logic.\n\n### Serialization and Protocol Issues\n\nSerialization problems occur when converting between Python objects and the JSON wire format. These issues often manifest as parsing errors, type mismatches, or corrupted data. Unlike network issues that typically fail fast, serialization problems can cause subtle data corruption that's discovered much later.\n\n> **Key Insight**: Serialization bugs often stem from assumptions about data types that hold during testing but break with real-world data variations. Always test with edge cases like empty values, very large numbers, Unicode strings, and nested data structures.\n\n#### JSON Serialization Edge Cases\n\nJSON serialization seems straightforward but has numerous edge cases that can break RPC communication:\n\n| Data Type | JSON Limitation | Failure Mode | Workaround |\n|-----------|----------------|--------------|------------|\n| `datetime` objects | No native datetime type | `TypeError: datetime not JSON serializable` | Convert to ISO strings, custom serializer |\n| `Decimal` numbers | Only supports float precision | Precision loss, rounding errors | String encoding for exact decimals |\n| `bytes` objects | No binary data support | `TypeError: bytes not JSON serializable` | Base64 encoding |\n| `set` collections | No set type | `TypeError: set not JSON serializable` | Convert to list, document ordering loss |\n| `None` vs empty string | Both can represent \"missing\" | Logic errors in parameter validation | Explicit null checking |\n| Very large integers | Implementation limits vary | Precision loss in JavaScript clients | String encoding for big integers |\n| NaN/Infinity floats | Not part of JSON spec | Varies by JSON library | Replace with null or string representation |\n\n⚠️ **Pitfall: Assuming JSON round-trip fidelity**\n\nA common mistake is assuming that `deserialize_message(serialize_message(data))` always returns data identical to the original. JSON serialization loses type information and precision. For example, Python tuples become lists, Decimal numbers become floats, and dictionary keys must be strings. Design your RPC interface to handle these transformations gracefully.\n\n#### Message Format Validation\n\nThe `validate_request_message()` and `validate_response_message()` functions check JSON-RPC format compliance, but validation failures often indicate deeper issues:\n\n**Request Validation Failures:**\n\n| Validation Error | Potential Cause | Investigation Steps |\n|------------------|----------------|-------------------|\n| Missing `method` field | Client serialization bug | Check `create_request_message()` logic |\n| Invalid `params` type | Parameter marshaling error | Log raw parameters before serialization |\n| Missing `id` field | Request ID generation failure | Verify `generate_request_id()` function |\n| Extra fields in request | Version mismatch, debugging code | Compare client/server protocol versions |\n\n**Response Validation Failures:**\n\nResponse validation errors usually indicate server-side problems in request processing or response generation:\n\n1. **Missing `result` and `error` fields**: The server's request dispatcher isn't following JSON-RPC protocol. Check the `process_request()` method for edge cases where neither result nor error is set.\n\n2. **Wrong `id` field**: Response correlation failure. This serious bug means responses can be delivered to the wrong pending request. Debug the request tracking logic in `_track_request()` and `_wait_for_response()`.\n\n3. **Invalid error format**: The server's error handling doesn't conform to JSON-RPC error structure. Verify that all error paths use `create_error_message()` with proper error codes.\n\n#### Parameter Type Marshaling\n\nRPC calls involve converting Python function signatures to JSON arrays and back. Type mismatches cause failures that can be hard to debug:\n\n**Common Type Marshaling Issues:**\n\n1. **Positional vs keyword arguments**: JSON-RPC traditionally uses positional parameters (JSON arrays), but Python functions often use keyword arguments. The `call()` method must decide how to marshal mixed args/kwargs.\n\n2. **Complex nested objects**: While simple types serialize cleanly, custom objects require explicit serialization logic. Attempting to serialize objects with circular references will cause infinite recursion.\n\n3. **Function signature validation**: The server should validate that the provided parameters match the registered function's signature. Mismatches should return `INVALID_PARAMS` errors, not Python exceptions.\n\n#### Message Framing Errors\n\nThe length-prefix message framing protocol can fail in subtle ways, especially under high load or with large messages:\n\n**Framing Protocol Issues:**\n\n| Symptom | Root Cause | Diagnostic Approach |\n|---------|------------|-------------------|\n| `recv()` returns fewer bytes than expected | Network fragmentation or slow sender | Log actual vs expected byte counts |\n| Length prefix reads as impossibly large number | Byte order issues or corruption | Check endianness, validate length bounds |\n| Message appears truncated | Premature connection close | Monitor socket state during receive |\n| JSON parsing fails on seemingly valid data | UTF-8 encoding issues | Hex dump received bytes, check encoding |\n\n**Message Size Validation:**\n\nThe `MAX_MESSAGE_SIZE` constant protects against memory exhaustion from malicious or corrupted length prefixes. However, legitimate large messages can trigger this protection:\n\n1. **Large parameter lists**: RPC calls with many parameters or large string/binary data can exceed size limits. Consider pagination or chunking for large data transfers.\n\n2. **Detailed error messages**: Error responses containing full stack traces can be surprisingly large. Truncate or summarize error details for production systems.\n\n#### Debugging Serialization Problems\n\nSystematic debugging of serialization issues requires visibility into the data transformation pipeline:\n\n**Data Flow Tracing:**\n\n1. **Pre-serialization logging**: Log the exact Python objects before JSON conversion to verify the input data integrity.\n\n2. **Wire format inspection**: Log the raw bytes sent over the network to check for encoding issues or corruption.\n\n3. **Post-deserialization validation**: After parsing JSON, log the reconstructed Python objects to verify round-trip accuracy.\n\n**JSON Library Behavior:**\n\nDifferent JSON libraries have subtly different behavior that can cause interoperability issues:\n\n- Standard `json` module: Strict JSON compliance, good error messages\n- `orjson`: High performance, but slightly different float formatting\n- `ujson`: Fast parsing, but less robust error handling\n\n> **Design Principle**: Use the standard `json` module during development for better error messages, then consider performance alternatives only if profiling shows JSON parsing as a bottleneck.\n\n### Timing and Concurrency Issues\n\nTiming and concurrency bugs are among the most challenging to debug in RPC systems because they're often non-deterministic, environment-dependent, and may only manifest under specific load conditions. These issues arise from the inherent concurrency in network programming - multiple clients connecting simultaneously, overlapping requests and responses, and the need to correlate asynchronous operations.\n\n> **Key Insight**: Concurrency bugs in RPC systems often involve shared state that seems fine during single-threaded testing but breaks when multiple operations access it simultaneously. The key to debugging is making these race conditions reproducible through stress testing and careful instrumentation.\n\n#### Request ID Correlation Problems\n\nThe request ID mechanism allows clients to match responses with their originating requests when multiple calls are in flight. Bugs in this correlation system can cause responses to be delivered to the wrong callers or lost entirely:\n\n**Request ID Generation Issues:**\n\n| Problem | Symptoms | Debugging Approach | Solution |\n|---------|----------|-------------------|----------|\n| Duplicate request IDs | Responses delivered to wrong calls | Log all generated IDs, check for duplicates | Use UUIDs instead of counters |\n| ID wraparound in counters | Old responses match new requests | Monitor ID space exhaustion | 64-bit IDs or UUID4 generation |\n| Thread-unsafe ID generation | Race conditions in ID assignment | Stress test with concurrent calls | Thread-safe ID generator |\n\n⚠️ **Pitfall: Using simple incrementing counters for request IDs**\n\nA common mistake is using a simple counter like `self._next_id += 1` to generate request IDs. This creates two problems: thread safety (multiple threads can get the same ID) and eventual wraparound (after 2^32 requests, IDs repeat). Use `uuid.uuid4()` or a thread-safe counter with sufficient bit width.\n\n**Request Tracking Race Conditions:**\n\nThe `_pending_requests` dictionary tracks active requests, but concurrent access creates race conditions:\n\n1. **Lost response handling**: A response arrives just as the timeout handler is cleaning up the request. Both threads try to modify `_pending_requests` simultaneously.\n\n2. **Double response processing**: Network duplication causes the same response to arrive twice. Without proper cleanup, both copies might be processed.\n\n3. **Memory leaks from orphaned requests**: If request cleanup fails due to exceptions, entries remain in `_pending_requests` indefinitely.\n\n**Request Tracking Debug Strategy:**\n\n```\n# Effective debugging requires logging request lifecycle events:\n# 1. Request creation and tracking registration\n# 2. Response arrival and correlation\n# 3. Timeout expiration and cleanup\n# 4. Manual cleanup (disconnect/shutdown)\n```\n\n#### Timeout Handling Complexity\n\nTimeout handling involves multiple concurrent operations: sending requests, waiting for responses, and cleaning up expired requests. These operations must coordinate without blocking each other:\n\n**Timeout Implementation Challenges:**\n\n| Timeout Type | Concurrency Challenge | Failure Mode |\n|--------------|----------------------|--------------|\n| Fixed timeouts | All requests use same duration | Fast operations wait unnecessarily, slow operations timeout prematurely |\n| Per-request timeouts | Complex timeout tracking | Race between timeout and response arrival |\n| Adaptive timeouts | Requires RTT measurement | Feedback loops can cause instability |\n\n**Timeout Race Conditions:**\n\nThe most common timeout bug occurs when a response arrives just as the timeout expires:\n\n1. **Thread A**: Waits for response, timeout expires, starts cleanup\n2. **Thread B**: Receives response from network, starts processing\n3. **Race condition**: Both threads try to remove the request from `_pending_requests`\n\nThe solution requires atomic operations and careful ordering:\n\n```\n# Timeout handler must:\n# 1. Atomically remove request from tracking (only if still present)\n# 2. Signal waiting thread with timeout error\n# 3. Avoid double-signaling if response already arrived\n\n# Response handler must:\n# 1. Atomically remove request from tracking (only if still present) \n# 2. Signal waiting thread with response\n# 3. Gracefully handle case where request was already timed out\n```\n\n#### Server Concurrency Issues\n\nThe `RPCServer` handles multiple client connections concurrently, creating shared state access patterns that can cause race conditions:\n\n**Method Registry Thread Safety:**\n\nThe `MethodRegistry` allows dynamic registration and execution of RPC methods. Concurrent access creates several race conditions:\n\n| Operation Combination | Race Condition | Impact |\n|----------------------|---------------|---------|\n| Register + Execute | Method added while call in progress | Call might use old or new version inconsistently |\n| Unregister + Execute | Method removed while call in progress | Call fails with method-not-found despite being valid |\n| Multiple Registers | Same method name registered by different threads | Undefined which implementation wins |\n\n> **Architecture Decision: Method Registry Locking Strategy**\n> - **Context**: The MethodRegistry needs thread-safe access for reading (method lookup) and writing (registration)\n> - **Options Considered**: \n>   1. Single mutex for all operations\n>   2. Read-write lock allowing concurrent reads\n>   3. Copy-on-write with atomic pointer swap\n> - **Decision**: Read-write lock (`threading.RLock`)\n> - **Rationale**: Method execution (reads) vastly outnumbers registration (writes), so allowing concurrent reads improves performance significantly\n> - **Consequences**: More complex lock management, but better scalability under load\n\n**Connection Handler Thread Lifecycle:**\n\nEach client connection gets its own handler thread, but thread management introduces timing issues:\n\n1. **Thread creation overhead**: Creating threads for each connection is expensive. Under high connection rates, the server spends more time creating threads than processing requests.\n\n2. **Thread cleanup timing**: Handler threads must clean up resources when clients disconnect. If the client closes the connection abruptly, the cleanup code might not execute properly.\n\n3. **Graceful shutdown coordination**: When the server shuts down, it must wait for all handler threads to complete their current requests before exiting.\n\n#### Deadlock Detection and Prevention\n\nDeadlocks in RPC systems typically involve multiple locks being acquired in different orders by different threads. The most common scenario involves the method registry lock and request tracking locks:\n\n**Common Deadlock Patterns:**\n\n| Thread 1 Operations | Thread 2 Operations | Deadlock Scenario |\n|---------------------|--------------------|--------------------|\n| 1. Acquire registry lock<br>2. Wait for tracking lock | 1. Acquire tracking lock<br>2. Wait for registry lock | Classic two-lock deadlock |\n| 1. Process request (registry)<br>2. Send response (socket) | 1. Handle timeout (tracking)<br>2. Update registry stats | Nested lock acquisition with I/O |\n\n**Deadlock Prevention Strategies:**\n\n1. **Lock ordering**: Always acquire locks in the same order across all code paths. Document the lock hierarchy clearly.\n\n2. **Lock timeouts**: Use timed lock acquisition to detect potential deadlocks. If a lock can't be acquired within a reasonable time, log a warning and abort the operation.\n\n3. **Minimize lock scope**: Hold locks for the shortest time possible. Don't perform I/O operations while holding locks.\n\n#### Load Testing for Concurrency Issues\n\nConcurrency bugs often only appear under specific load patterns. Systematic load testing helps expose race conditions that don't occur during development:\n\n**Effective Load Testing Patterns:**\n\n| Test Pattern | Purpose | Implementation |\n|-------------|---------|---------------|\n| Burst connections | Test connection handling limits | Open 100+ connections simultaneously |\n| Concurrent method calls | Expose request tracking races | Multiple threads calling same method |\n| Mixed read/write operations | Test registry lock contention | Register methods while handling calls |\n| Connection drops during calls | Test cleanup logic | Kill client connections mid-request |\n\n**Concurrency Bug Indicators:**\n\nWatch for these symptoms during load testing:\n\n1. **Inconsistent test results**: The same test passes sometimes and fails others\n2. **Resource leaks**: Memory or file descriptor usage grows over time  \n3. **Hanging operations**: Requests never complete or timeout\n4. **Assertion failures**: Race conditions causing invalid state\n\n⚠️ **Pitfall: Testing only single-threaded scenarios**\n\nMany developers test RPC functionality with a single client making sequential calls. This approach misses most concurrency bugs. Always include multi-threaded and multi-client test scenarios. Use tools like `threading.Barrier` to coordinate multiple threads and create worst-case race condition scenarios.\n\n#### Performance Monitoring and Profiling\n\nTiming issues often manifest as performance problems rather than functional failures. Monitoring key metrics helps identify concurrency bottlenecks:\n\n**Key Timing Metrics:**\n\n| Metric | What It Reveals | Monitoring Approach |\n|--------|-----------------|-------------------|\n| Request latency distribution | Lock contention, queueing delays | Histogram of response times |\n| Thread pool utilization | Resource exhaustion, blocking operations | Active thread count over time |\n| Lock acquisition time | Contention hotspots | Time spent waiting for locks |\n| Connection establishment rate | Network or threading bottlenecks | Connections per second |\n\n> **Debugging Principle**: Performance problems and correctness problems in concurrent systems are often related. A performance degradation might indicate race conditions, lock contention, or resource leaks that will eventually cause functional failures.\n\n### Implementation Guidance\n\nThis section provides practical tools and techniques for systematically debugging RPC framework issues. The debugging utilities help isolate problems quickly and provide detailed diagnostic information.\n\n#### Technology Recommendations\n\n| Debugging Category | Simple Option | Advanced Option |\n|-------------------|---------------|-----------------|\n| Network diagnostics | `netstat`, `telnet`, basic socket logging | `tcpdump`, `wireshark`, network monitoring tools |\n| Concurrency debugging | `threading` module logging, manual trace points | Thread profilers, deadlock detection tools |\n| Serialization validation | JSON pretty-printing, manual data inspection | Schema validation libraries, fuzzing tools |\n| Performance monitoring | Basic timing with `time.time()` | `cProfile`, `py-spy`, APM tools |\n\n#### Debugging Infrastructure\n\n**Complete Socket Diagnostic Helper:**\n\n```python\nimport socket\nimport time\nimport threading\nfrom typing import Dict, Any, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass ConnectionDiagnostics:\n    \"\"\"Diagnostic information about a socket connection.\"\"\"\n    local_address: tuple\n    remote_address: tuple\n    socket_state: str\n    bytes_sent: int\n    bytes_received: int\n    connection_time: float\n    last_activity: float\n\nclass SocketDiagnosticsHelper:\n    \"\"\"Helper for debugging socket-related issues.\"\"\"\n    \n    def __init__(self):\n        self._connections: Dict[int, ConnectionDiagnostics] = {}\n        self._lock = threading.Lock()\n    \n    def register_connection(self, sock: socket.socket) -> None:\n        \"\"\"Register a socket for diagnostic tracking.\"\"\"\n        with self._lock:\n            try:\n                local_addr = sock.getsockname()\n                remote_addr = sock.getpeername()\n                sock_fd = sock.fileno()\n                \n                self._connections[sock_fd] = ConnectionDiagnostics(\n                    local_address=local_addr,\n                    remote_address=remote_addr,\n                    socket_state=\"CONNECTED\",\n                    bytes_sent=0,\n                    bytes_received=0,\n                    connection_time=time.time(),\n                    last_activity=time.time()\n                )\n            except OSError as e:\n                print(f\"Failed to register socket: {e}\")\n    \n    def record_send(self, sock: socket.socket, byte_count: int) -> None:\n        \"\"\"Record bytes sent on a socket.\"\"\"\n        # TODO: Update connection diagnostics with send activity\n        # TODO: Update last_activity timestamp\n        # TODO: Increment bytes_sent counter\n        # TODO: Handle case where socket is not registered\n        pass\n    \n    def record_receive(self, sock: socket.socket, byte_count: int) -> None:\n        \"\"\"Record bytes received on a socket.\"\"\"\n        # TODO: Update connection diagnostics with receive activity\n        # TODO: Update last_activity timestamp  \n        # TODO: Increment bytes_received counter\n        # TODO: Handle case where socket is not registered\n        pass\n    \n    def test_connectivity(self, host: str, port: int, timeout: float = 5.0) -> Dict[str, Any]:\n        \"\"\"Test basic connectivity to a server.\"\"\"\n        # TODO: Create test socket with timeout\n        # TODO: Attempt connection to host:port\n        # TODO: Measure connection time\n        # TODO: Test basic send/receive capability\n        # TODO: Return diagnostic dictionary with results\n        # Hint: Include success/failure, timing, and any error details\n        pass\n```\n\n**Message Serialization Debugger:**\n\n```python\nimport json\nimport traceback\nfrom typing import Any, Dict, List, Optional\n\nclass SerializationDebugger:\n    \"\"\"Helper for debugging JSON serialization issues.\"\"\"\n    \n    @staticmethod\n    def validate_serializable(data: Any, path: str = \"root\") -> List[str]:\n        \"\"\"Validate that data can be JSON serialized and return issues.\"\"\"\n        issues = []\n        \n        # TODO: Recursively check data structure for serialization problems\n        # TODO: Check for non-serializable types (datetime, bytes, etc.)\n        # TODO: Check for circular references\n        # TODO: Validate that dictionary keys are strings\n        # TODO: Check for very large numbers that might lose precision\n        # TODO: Return list of issues with their paths in the data structure\n        \n        return issues\n    \n    @staticmethod\n    def safe_serialize(data: Any) -> Optional[bytes]:\n        \"\"\"Attempt serialization with detailed error reporting.\"\"\"\n        try:\n            # TODO: Try to serialize data to JSON\n            # TODO: Return encoded bytes if successful\n            # TODO: Catch and log specific serialization errors\n            # TODO: Return None if serialization fails\n            pass\n        except Exception as e:\n            print(f\"Serialization failed: {e}\")\n            traceback.print_exc()\n            return None\n    \n    @staticmethod\n    def compare_round_trip(original: Any) -> Dict[str, Any]:\n        \"\"\"Test round-trip serialization and report differences.\"\"\"\n        # TODO: Serialize original data to JSON\n        # TODO: Deserialize back to Python object\n        # TODO: Compare original with round-trip result\n        # TODO: Report type changes, precision loss, etc.\n        # TODO: Return detailed comparison report\n        pass\n```\n\n**Request Tracking Diagnostics:**\n\n```python\nimport threading\nimport time\nfrom typing import Dict, Any\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass RequestDiagnostics:\n    \"\"\"Diagnostic information about an RPC request.\"\"\"\n    request_id: str\n    method_name: str\n    created_time: float\n    timeout_seconds: float\n    thread_id: int\n    state: str = \"PENDING\"\n    response_time: Optional[float] = None\n    error_info: Optional[str] = None\n\nclass RequestTrackingDiagnostics:\n    \"\"\"Helper for debugging request correlation and timeout issues.\"\"\"\n    \n    def __init__(self):\n        self._active_requests: Dict[str, RequestDiagnostics] = {}\n        self._completed_requests: List[RequestDiagnostics] = []\n        self._lock = threading.RLock()\n        self._max_completed_history = 100\n    \n    def register_request(self, request_id: str, method_name: str, timeout_seconds: float) -> None:\n        \"\"\"Register a new request for tracking.\"\"\"\n        # TODO: Create RequestDiagnostics object with current time and thread\n        # TODO: Add to active_requests dictionary\n        # TODO: Use lock for thread safety\n        pass\n    \n    def mark_response_received(self, request_id: str) -> bool:\n        \"\"\"Mark request as having received a response.\"\"\"\n        # TODO: Find request in active_requests\n        # TODO: Update state to \"COMPLETED\" and set response_time\n        # TODO: Move from active to completed list\n        # TODO: Return True if found, False if not\n        # TODO: Handle case where request was already cleaned up\n        pass\n    \n    def mark_timeout(self, request_id: str) -> bool:\n        \"\"\"Mark request as timed out.\"\"\"\n        # TODO: Find request in active_requests\n        # TODO: Update state to \"TIMEOUT\" and set error_info\n        # TODO: Move from active to completed list\n        # TODO: Return True if found, False if already cleaned up\n        pass\n    \n    def get_diagnostics_summary(self) -> Dict[str, Any]:\n        \"\"\"Get summary of request tracking state.\"\"\"\n        with self._lock:\n            current_time = time.time()\n            active_count = len(self._active_requests)\n            \n            # TODO: Calculate statistics on active requests\n            # TODO: Find oldest active request and check if it's overdue\n            # TODO: Count requests by state in completed history\n            # TODO: Calculate average response times\n            # TODO: Return comprehensive diagnostic dictionary\n            \n            return {\n                \"active_requests\": active_count,\n                \"completed_requests\": len(self._completed_requests),\n                \"timestamp\": current_time\n                # Add more diagnostic fields\n            }\n```\n\n#### Milestone Checkpoints\n\n**After Milestone 1 (Message Protocol):**\n\nTest serialization robustness with edge cases:\n```bash\n# Run this test to validate message protocol\npython -c \"\nfrom your_rpc.protocol import create_request_message, serialize_message, deserialize_message\nimport json\n\n# Test edge cases\nedge_cases = [\n    ('test_method', []),  # Empty parameters\n    ('test_method', [None, '', 0, False]),  # Falsy values\n    ('test_method', ['unicode: 你好', 'emoji: 😀']),  # Unicode strings\n    ('test_method', [1.7976931348623157e+308]),  # Very large float\n]\n\nfor method, params in edge_cases:\n    msg = create_request_message(method, params, 'test-id')\n    serialized = serialize_message(msg)\n    deserialized = deserialize_message(serialized)\n    print(f'✓ {method} with {params} serialized successfully')\n\"\n```\n\nExpected output: All edge cases should serialize without exceptions.\n\n**After Milestone 2 (Server Implementation):**\n\nTest server concurrency and error handling:\n```bash\n# Test concurrent connections to the server\npython -c \"\nimport threading\nimport socket\nimport time\n\ndef test_connection():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    try:\n        sock.connect(('localhost', 8000))\n        sock.send(b'test message')\n        sock.close()\n        print('✓ Connection successful')\n    except Exception as e:\n        print(f'✗ Connection failed: {e}')\n\n# Start 10 concurrent connections\nthreads = [threading.Thread(target=test_connection) for _ in range(10)]\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()\n\"\n```\n\nExpected output: All 10 connections should succeed without server errors.\n\n**After Milestone 3 (Client Implementation):**\n\nTest timeout handling and request correlation:\n```bash\n# Test client timeout behavior\npython -c \"\nfrom your_rpc.client import RPCClient\nimport threading\nimport time\n\nclient = RPCClient('localhost', 8000)\n\ndef make_call(method, delay):\n    try:\n        result = client.call(method, delay, timeout=2.0)\n        print(f'✓ {method} completed: {result}')\n    except Exception as e:\n        print(f'✗ {method} failed: {e}')\n\n# Test concurrent calls with different timeouts\nthreads = [\n    threading.Thread(target=make_call, args=('fast_method', 0.5)),\n    threading.Thread(target=make_call, args=('slow_method', 5.0)),\n    threading.Thread(target=make_call, args=('medium_method', 1.5)),\n]\n\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()\n\"\n```\n\nExpected output: Fast and medium calls succeed, slow call times out after 2 seconds.\n\n#### Common Debugging Scenarios\n\n**Symptom: Client calls hang indefinitely**\n\n| Diagnosis Step | Command/Technique | Expected Result |\n|----------------|-------------------|-----------------|\n| Check server running | `netstat -an \\| grep 8000` | Should show `LISTEN` state |\n| Test basic connectivity | `telnet localhost 8000` | Should connect successfully |\n| Check request ID tracking | Add logging to `_track_request()` | Should show request being registered |\n| Monitor response correlation | Add logging to response handler | Should show if responses arrive |\n\n**Symptom: Intermittent serialization errors**\n\n| Diagnosis Step | Investigation Technique | What to Look For |\n|----------------|------------------------|------------------|\n| Log pre-serialization data | Add logging before `json.dumps()` | Non-serializable types, circular refs |\n| Test with simple data first | Replace complex params with basic types | Isolate problematic data structures |\n| Check Unicode handling | Test with various string encodings | UTF-8 encoding issues |\n| Validate JSON compliance | Use strict JSON parser | Invalid JSON constructs |\n\n**Symptom: Server handles some requests but not others**\n\n| Diagnosis Area | Investigation Steps |\n|----------------|-------------------|\n| Method registry | Log all registered methods, check method name matching |\n| Parameter validation | Log received parameters vs expected function signature |\n| Exception handling | Ensure all exceptions in method handlers are caught |\n| Thread synchronization | Check for deadlocks in method registry access |\n\n#### Performance Debugging Tools\n\n**Request Latency Tracker:**\n\n```python\nimport time\nimport collections\nfrom typing import DefaultDict, List\n\nclass LatencyTracker:\n    \"\"\"Track RPC call latencies for performance debugging.\"\"\"\n    \n    def __init__(self):\n        self._method_times: DefaultDict[str, List[float]] = collections.defaultdict(list)\n        self._request_starts: Dict[str, float] = {}\n    \n    def start_request(self, request_id: str, method_name: str) -> None:\n        \"\"\"Record request start time.\"\"\"\n        # TODO: Store current timestamp for request_id\n        # TODO: Associate with method_name for categorization\n        pass\n    \n    def end_request(self, request_id: str, method_name: str) -> None:\n        \"\"\"Record request completion and calculate latency.\"\"\"\n        # TODO: Calculate elapsed time from start\n        # TODO: Add to method_times list for the method\n        # TODO: Remove from request_starts\n        # TODO: Handle case where request_id not found (late response)\n        pass\n    \n    def get_latency_stats(self, method_name: str = None) -> Dict[str, float]:\n        \"\"\"Get latency statistics for debugging.\"\"\"\n        # TODO: Calculate min, max, mean, median, 95th percentile\n        # TODO: Return for specific method or all methods\n        # TODO: Handle case where no data is available\n        pass\n```\n\nThis debugging guide provides systematic approaches to identify and resolve the most common issues in RPC framework development. The key is following structured diagnostic processes rather than random troubleshooting, using proper instrumentation to make problems visible, and testing edge cases that don't occur during normal development.\n\n\n## Future Extensions\n\n> **Milestone(s):** Beyond Milestones 1, 2, and 3 - advanced features that build upon the basic RPC framework foundation\n\nThe basic RPC framework provides a solid foundation for remote procedure calls, but real-world systems require additional capabilities for performance, reliability, and scalability. This section explores natural extensions that transform our educational framework into a production-ready system. These enhancements follow the same design principles we've established while addressing the operational challenges that emerge when RPC systems face high load, unreliable networks, and security requirements.\n\n### Mental Model: The Growing City Analogy\n\nThink of our basic RPC framework as a small town with a simple postal service. The town has grown successful, and now needs urban infrastructure improvements. The postal service (our message protocol) needs express lanes for high-priority mail (performance extensions). The town needs security systems and backup services (reliability extensions). Each extension addresses specific growing pains while preserving the fundamental architecture that made the original system work.\n\nThe extensions fall into two primary categories: **performance extensions** that make the system faster and more efficient, and **reliability extensions** that make the system more robust and secure. Like urban planning, these improvements must be carefully designed to work together without creating conflicts or compromising the system's core simplicity.\n\n### Performance Extensions\n\nPerformance extensions focus on reducing latency, increasing throughput, and minimizing resource consumption. These improvements are essential when the RPC framework must handle thousands of concurrent requests or when network efficiency becomes critical.\n\n#### Connection Pooling\n\nConnection pooling transforms the client from establishing a new TCP connection for each RPC call to maintaining a reusable pool of persistent connections. This eliminates the overhead of TCP handshaking and connection teardown that becomes significant under high request volumes.\n\n**Current Limitation**: The basic `RPCClient` establishes a single connection and reuses it for sequential requests. This creates a bottleneck when multiple threads need to make concurrent RPC calls, as they must wait for the shared connection to become available.\n\n> **Decision: Connection Pool Architecture**\n> - **Context**: Multiple threads making concurrent RPC calls are serialized by the single shared connection, creating a throughput bottleneck and blocking threads unnecessarily\n> - **Options Considered**: \n>   - Thread-local connections (one connection per thread)\n>   - Shared connection pool with borrowing/returning semantics\n>   - Connection-per-request with caching\n> - **Decision**: Shared connection pool with borrowing/returning semantics\n> - **Rationale**: Thread-local connections can create too many connections under high thread counts, while connection-per-request loses reuse benefits. A shared pool provides optimal balance of connection reuse and concurrency.\n> - **Consequences**: Requires connection lifecycle management and pool sizing configuration, but enables true concurrent RPC calls without thread blocking\n\n| Design Aspect | Thread-Local Connections | Shared Connection Pool | Connection-Per-Request |\n|---------------|-------------------------|------------------------|----------------------|\n| Concurrency | Excellent | Good | Excellent |\n| Resource Usage | High (many connections) | Medium | Low |\n| Connection Reuse | Good | Excellent | Poor |\n| Implementation Complexity | Medium | High | Low |\n| **Chosen** | No | **Yes** | No |\n\nThe connection pool maintains a collection of established TCP connections that can be borrowed for RPC calls and returned when complete. The pool handles connection health checking, automatic reconnection for stale connections, and pool size management based on demand.\n\n**Connection Pool Components:**\n\n| Component | Type | Description |\n|-----------|------|-------------|\n| `connections` | `List[socket.socket]` | Available connections ready for use |\n| `in_use` | `Set[socket.socket]` | Connections currently borrowed for active requests |\n| `max_size` | `int` | Maximum number of connections to maintain |\n| `min_size` | `int` | Minimum connections to keep alive |\n| `idle_timeout` | `float` | Seconds before closing idle connections |\n| `health_check_interval` | `float` | Seconds between connection health checks |\n| `pool_lock` | `threading.RLock` | Protects pool state during concurrent access |\n\n**Connection Borrowing Algorithm:**\n1. Acquire the pool lock to ensure thread-safe access to pool state\n2. Check if any healthy connections are available in the connections list\n3. If available connection exists, move it from connections to in_use and return it\n4. If no connections available but pool size under maximum, create new connection\n5. Establish TCP connection to server with timeout and connection validation\n6. Add new connection to in_use set and return it to caller\n7. If pool at maximum size, block waiting for connection to be returned\n8. Implement timeout mechanism to prevent infinite blocking on pool exhaustion\n\n**Connection Health Checking:**\nThe pool periodically validates that connections are still usable by sending lightweight ping messages or checking socket status. Broken connections are automatically removed from the pool and replaced with fresh connections.\n\n> The key insight for connection pooling is that the complexity of pool management is isolated within the connection pool component, while the RPC calling interface remains unchanged. Existing code using `call()` methods continues to work transparently.\n\n#### Asynchronous Support\n\nAsynchronous support transforms the blocking RPC client into a non-blocking system that can handle thousands of concurrent requests without dedicating a thread to each pending call. This is essential for building responsive applications that make many RPC calls concurrently.\n\n**Current Limitation**: The basic `RPCClient.call()` method blocks the calling thread until the response arrives or timeout occurs. Applications making hundreds of concurrent RPC calls must create hundreds of threads, leading to resource exhaustion and context switching overhead.\n\n> **Decision: Async/Await Integration**\n> - **Context**: Blocking RPC calls force applications to use thread-per-request patterns that don't scale well under high concurrency loads\n> - **Options Considered**:\n>   - Callback-based asynchronous interface\n>   - Future/Promise-based interface\n>   - Python asyncio integration with async/await\n> - **Decision**: Python asyncio integration with async/await syntax\n> - **Rationale**: Async/await provides the most natural programming model for asynchronous code, avoiding callback hell and making error handling straightforward\n> - **Consequences**: Requires asyncio event loop and separate async client implementation, but enables single-threaded high concurrency\n\n| Async Approach | Learning Curve | Error Handling | Debugging | Performance |\n|----------------|---------------|----------------|-----------|-------------|\n| Callbacks | High | Complex | Difficult | Good |\n| Futures/Promises | Medium | Good | Medium | Good |\n| **Async/Await** | **Medium** | **Excellent** | **Good** | **Excellent** |\n\nThe asynchronous client uses Python's `asyncio` library to manage concurrent RPC calls without blocking threads. Instead of blocking on socket operations, the client registers interest in socket readiness with the event loop and yields control to other coroutines.\n\n**Async Client Components:**\n\n| Component | Type | Description |\n|-----------|------|-------------|\n| `_event_loop` | `asyncio.AbstractEventLoop` | Event loop managing async operations |\n| `_connection_pool` | `AsyncConnectionPool` | Non-blocking connection management |\n| `_pending_requests` | `Dict[str, asyncio.Future]` | Futures awaiting responses |\n| `_response_handler_task` | `asyncio.Task` | Background task processing incoming responses |\n| `_request_semaphore` | `asyncio.Semaphore` | Limits concurrent request count |\n\n**Async Call Flow:**\n1. Create request message with unique ID and serialize to bytes\n2. Acquire connection from async connection pool (may await if pool full)\n3. Send request bytes over connection using asyncio socket operations\n4. Create Future object for this request ID and store in pending requests\n5. Return the Future to caller for awaiting (call is now non-blocking)\n6. Background response handler receives responses and resolves matching Futures\n7. When response arrives, lookup Future by request ID and set result/exception\n8. Calling code awaits the Future and receives the result when available\n\n**Background Response Handler:**\nA dedicated asyncio task continuously reads responses from all active connections and routes them to the appropriate Future objects. This single task can handle responses from thousands of concurrent requests efficiently.\n\n> The async transformation maintains the same logical request/response model while eliminating thread blocking. The programming model changes from `result = client.call(method, args)` to `result = await async_client.call(method, args)`.\n\n#### Binary Serialization\n\nBinary serialization replaces JSON encoding with more efficient binary formats like MessagePack or Protocol Buffers. This reduces message size and serialization overhead, especially important for large payloads or high-frequency RPC calls.\n\n**Current Limitation**: JSON serialization is human-readable and easy to debug, but produces large messages and requires significant CPU time for encoding/decoding. For RPC calls with large data structures or high call volumes, serialization becomes a performance bottleneck.\n\n> **Decision: MessagePack as Primary Binary Format**\n> - **Context**: JSON serialization creates large messages and high CPU overhead for complex data structures with nested objects and arrays\n> - **Options Considered**:\n>   - MessagePack (schema-less binary JSON equivalent)\n>   - Protocol Buffers (schema-based with code generation)\n>   - Apache Avro (schema-based with runtime schema evolution)\n> - **Decision**: MessagePack as primary format with JSON fallback\n> - **Rationale**: MessagePack maintains JSON's schema-less flexibility while providing binary efficiency, and requires no schema management or code generation\n> - **Consequences**: Smaller messages and faster serialization, but loses human readability and requires binary debugging tools\n\n| Serialization Format | Message Size | CPU Overhead | Schema Management | Debugging |\n|---------------------|--------------|--------------|-------------------|-----------|\n| JSON | Large | High | None | Excellent |\n| **MessagePack** | **Small** | **Low** | **None** | **Fair** |\n| Protocol Buffers | Smallest | Lowest | Complex | Poor |\n| Apache Avro | Small | Medium | Medium | Fair |\n\n**Binary Serialization Architecture:**\nThe framework supports multiple serialization formats through a pluggable serialization interface. Clients and servers negotiate the serialization format during connection establishment, with fallback to JSON for compatibility.\n\n**Serialization Interface:**\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `serialize_message(message, format)` | `Dict, str` | `bytes` | Encode message using specified format |\n| `deserialize_message(data, format)` | `bytes, str` | `Dict` | Decode bytes using specified format |\n| `get_supported_formats()` | None | `List[str]` | List available serialization formats |\n| `negotiate_format(client_formats, server_formats)` | `List[str], List[str]` | `str` | Select optimal compatible format |\n\n**Format Negotiation Process:**\n1. Client sends connection handshake including list of supported serialization formats\n2. Server responds with its supported formats and selects best mutual format\n3. Both client and server use negotiated format for all subsequent messages\n4. If no mutual format exists, fall back to JSON as universal compatibility format\n5. Format selection considers efficiency, with preference for binary formats over JSON\n\n**MessagePack Integration Benefits:**\n- Message size typically 30-50% smaller than equivalent JSON\n- Serialization speed 2-3x faster than JSON for complex objects\n- Direct mapping from JSON data types (no schema required)\n- Preserves type information (distinguishes integers from floats)\n- Support for binary data without base64 encoding overhead\n\n> Binary serialization provides the most significant performance improvement for RPC systems with large payloads or high call volumes, often reducing network bandwidth by 40% and serialization CPU usage by 60%.\n\n### Reliability Extensions\n\nReliability extensions focus on making the RPC framework robust against failures, secure against attacks, and resilient under adverse conditions. These improvements are essential for production systems that must operate continuously despite network failures, server crashes, and malicious actors.\n\n#### Authentication and Authorization\n\nAuthentication verifies the identity of RPC clients, while authorization determines which methods each authenticated client is permitted to invoke. This prevents unauthorized access and enables fine-grained permission control over RPC services.\n\n**Current Limitation**: The basic RPC framework has no security mechanisms. Any client that can connect to the server can invoke any registered method, creating serious security vulnerabilities in production environments.\n\n> **Decision: Token-Based Authentication with Method-Level Authorization**\n> - **Context**: Production RPC services need to verify client identity and restrict access to sensitive methods based on client permissions\n> - **Options Considered**:\n>   - HTTP Basic Authentication (simple but sends credentials repeatedly)\n>   - JWT tokens (stateless but require signature verification)\n>   - Session-based authentication (stateful but requires session storage)\n> - **Decision**: JWT token authentication with method-level authorization rules\n> - **Rationale**: JWT tokens are stateless, self-contained, and can carry authorization claims, eliminating the need for server-side session storage while supporting fine-grained permissions\n> - **Consequences**: Adds token verification overhead to each request, but provides robust security without server-side state management\n\n| Authentication Method | Stateless | Performance | Security | Implementation Complexity |\n|-----------------------|-----------|-------------|-----------|-------------------------|\n| Basic Auth | Yes | Excellent | Poor | Low |\n| **JWT Tokens** | **Yes** | **Good** | **Excellent** | **Medium** |\n| Session-Based | No | Good | Good | High |\n\n**Authentication Architecture:**\nAuthentication is implemented as a middleware layer that intercepts requests before they reach the method registry. The middleware extracts authentication tokens, validates them, and enriches the request context with identity and permission information.\n\n**Authentication Components:**\n\n| Component | Type | Description |\n|-----------|------|-------------|\n| `token_validator` | `JWTValidator` | Validates JWT token signatures and expiration |\n| `permission_store` | `PermissionStore` | Maps user identities to method permissions |\n| `auth_middleware` | `AuthMiddleware` | Intercepts requests and enforces authentication |\n| `client_identity` | `ClientIdentity` | Represents authenticated client with permissions |\n\n**Authentication Request Flow:**\n1. Client includes JWT token in request message header or dedicated auth field\n2. Server's auth middleware extracts token from incoming request message\n3. Middleware validates token signature using configured public key or shared secret\n4. Middleware checks token expiration time and other standard JWT claims\n5. Middleware extracts user identity and roles from token's custom claims\n6. Permission store lookup determines which methods this identity can invoke\n7. If target method is authorized, request continues to method registry for execution\n8. If authentication fails or method unauthorized, return error without invoking method\n\n**JWT Token Structure:**\n```\nHeader: {\"alg\": \"HS256\", \"typ\": \"JWT\"}\nPayload: {\n  \"sub\": \"user_id\",\n  \"exp\": 1234567890,\n  \"iat\": 1234567800,\n  \"roles\": [\"read_user\", \"write_orders\"],\n  \"permissions\": [\"get_user_info\", \"create_order\", \"update_order\"]\n}\n```\n\n**Method-Level Authorization:**\nEach registered method can specify required permissions through decorators or configuration. The auth middleware checks that the authenticated client possesses all required permissions before allowing method execution.\n\n| Permission Model | Granularity | Management Overhead | Flexibility |\n|------------------|-------------|-------------------|-------------|\n| Role-Based | Medium | Low | Good |\n| **Permission-Based** | **High** | **Medium** | **Excellent** |\n| Method-Level ACLs | Highest | High | Good |\n\n> Authentication and authorization add security at the cost of performance overhead. Token validation typically adds 1-2ms per request, which is acceptable for most applications but may require caching optimizations for extremely high-throughput systems.\n\n#### Encryption and Transport Security\n\nEncryption protects RPC messages from eavesdropping and tampering during network transmission. This is essential when RPC calls contain sensitive data or traverse untrusted networks like the public internet.\n\n**Current Limitation**: The basic RPC framework uses plain TCP sockets that transmit messages in cleartext. Network attackers can read all RPC traffic and potentially modify messages in transit.\n\n> **Decision: TLS 1.3 for Transport Encryption**\n> - **Context**: RPC messages may contain sensitive data and travel across untrusted networks where eavesdropping and tampering are possible\n> - **Options Considered**:\n>   - Application-level encryption (encrypt message payloads)\n>   - TLS transport encryption (encrypt entire TCP connection)\n>   - VPN-based network encryption (encrypt at network layer)\n> - **Decision**: TLS 1.3 for transport-level encryption\n> - **Rationale**: TLS provides proven security with minimal application code changes, handles key exchange automatically, and encrypts all traffic including metadata\n> - **Consequences**: Adds TLS handshake overhead and CPU cost for encryption/decryption, but provides comprehensive protection against network-level attacks\n\n| Encryption Approach | Protection Scope | Performance Impact | Implementation Effort |\n|---------------------|------------------|-------------------|---------------------|\n| Application-Level | Message Content | Low | High |\n| **TLS Transport** | **Complete Traffic** | **Medium** | **Low** |\n| Network-Level VPN | Complete Traffic | Low | External |\n\n**TLS Integration Architecture:**\nTLS encryption is implemented by wrapping the TCP sockets in TLS sockets that handle encryption/decryption transparently. The existing RPC message protocol operates unchanged over the encrypted transport.\n\n**TLS Configuration Components:**\n\n| Component | Type | Description |\n|-----------|------|-------------|\n| `tls_context` | `ssl.SSLContext` | TLS configuration including cipher suites and certificates |\n| `server_certificate` | `ssl.Certificate` | Server's public key certificate for client verification |\n| `private_key` | `ssl.PrivateKey` | Server's private key for TLS handshake |\n| `ca_certificates` | `List[ssl.Certificate]` | Certificate authorities trusted for client certificates |\n| `cipher_preferences` | `List[str]` | Ordered list of acceptable cipher suites |\n\n**TLS Handshake Process:**\n1. Client initiates TCP connection to server as before\n2. Client immediately starts TLS handshake by sending ClientHello message\n3. Server responds with ServerHello, certificate, and key exchange information\n4. Client validates server certificate against trusted certificate authorities\n5. Client and server complete key exchange to establish shared encryption keys\n6. Both sides send Finished messages to confirm successful handshake\n7. All subsequent RPC messages are encrypted using established session keys\n8. RPC protocol operates normally over the encrypted TLS connection\n\n**Certificate Management:**\nProduction deployments require proper certificate management with certificate rotation, certificate authority validation, and secure private key storage. Development environments can use self-signed certificates for testing.\n\n> TLS encryption typically adds 5-10ms latency for the initial handshake and 10-20% CPU overhead for encryption/decryption. Connection reuse amortizes the handshake cost across many RPC calls.\n\n#### Retry Mechanisms and Circuit Breakers\n\nRetry mechanisms automatically re-execute failed RPC calls, while circuit breakers prevent cascading failures by temporarily stopping calls to unresponsive services. Together, they make RPC systems resilient to transient network failures and server overload.\n\n**Current Limitation**: The basic RPC framework treats all failures as permanent. A temporary network glitch or momentary server overload causes RPC calls to fail immediately, even though a retry seconds later would likely succeed.\n\n> **Decision: Exponential Backoff Retry with Circuit Breaker Protection**\n> - **Context**: Transient network failures and temporary server overload should not cause permanent RPC failures, but naive retry can amplify problems during outages\n> - **Options Considered**:\n>   - Fixed interval retry (simple but can overwhelm recovering servers)\n>   - Exponential backoff retry (reduces load on recovering servers)\n>   - Circuit breaker only (prevents cascading failures but no retry)\n> - **Decision**: Exponential backoff retry with circuit breaker protection\n> - **Rationale**: Exponential backoff handles transient failures gracefully while circuit breakers prevent retry storms during extended outages\n> - **Consequences**: Improves reliability but adds complexity and potential for longer response times during failures\n\n| Resilience Pattern | Transient Failures | Extended Outages | Implementation Complexity |\n|---------------------|--------------------|-----------------|-----------------------|\n| Fixed Retry | Good | Poor | Low |\n| **Exponential Backoff** | **Excellent** | **Fair** | **Medium** |\n| Circuit Breaker | Poor | Excellent | Medium |\n| **Combined Approach** | **Excellent** | **Excellent** | **High** |\n\n**Retry Configuration:**\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `max_attempts` | `int` | Maximum retry attempts before permanent failure |\n| `base_delay` | `float` | Initial delay before first retry (seconds) |\n| `max_delay` | `float` | Maximum delay between retries (seconds) |\n| `backoff_multiplier` | `float` | Multiplier for exponential delay increase |\n| `jitter_enabled` | `bool` | Add randomization to prevent thundering herd |\n| `retryable_errors` | `Set[ErrorCode]` | Which error types should trigger retry |\n\n**Exponential Backoff Algorithm:**\n1. Execute initial RPC call attempt and capture any resulting error\n2. Check if error type is in the configured set of retryable errors\n3. If not retryable (e.g., authentication failure), return error immediately\n4. If retryable and attempts remain, calculate delay as base_delay * (multiplier ^ attempt)\n5. Add random jitter to delay to prevent synchronized retry storms\n6. Sleep for calculated delay period before attempting next retry\n7. Increment attempt counter and repeat from step 1 until success or max attempts\n8. If all attempts exhausted, return the last error to the caller\n\n**Circuit Breaker States:**\n\n| State | Request Handling | Transition Conditions | Purpose |\n|-------|-----------------|---------------------|---------|\n| `CLOSED` | Pass all requests | Failure rate exceeds threshold → OPEN | Normal operation |\n| `OPEN` | Reject immediately | Timeout expires → HALF_OPEN | Prevent cascading failures |\n| `HALF_OPEN` | Allow single test request | Success → CLOSED, Failure → OPEN | Test service recovery |\n\n**Circuit Breaker Algorithm:**\n1. Track success and failure rates using sliding window of recent requests\n2. When failure rate exceeds threshold (e.g., 50% failures in last 100 requests), trip to OPEN\n3. In OPEN state, immediately return circuit breaker error without attempting RPC call\n4. After timeout period (e.g., 60 seconds), transition to HALF_OPEN state\n5. In HALF_OPEN, allow single test request to determine if service has recovered\n6. If test request succeeds, reset failure counters and return to CLOSED state\n7. If test request fails, return to OPEN state and restart timeout period\n\n> The combination of retry and circuit breaker provides comprehensive resilience: retries handle brief failures while circuit breakers prevent retry storms during extended outages. This is essential for building robust distributed systems.\n\n⚠️ **Common Pitfall: Retry Without Idempotency Consideration**\nMany developers implement retry logic without considering whether the RPC methods are idempotent (safe to call multiple times). Retrying non-idempotent operations like \"transfer money\" or \"send email\" can cause duplicate actions. The solution is to either ensure all retried methods are idempotent, or implement request deduplication using unique request IDs to detect and ignore duplicate calls.\n\n⚠️ **Common Pitfall: Circuit Breaker Per Client Instead of Per Service**\nImplementing circuit breakers at the client instance level rather than per remote service can cause false positives. If one service is down but others are healthy, a per-client circuit breaker might prevent all RPC calls. Instead, maintain separate circuit breaker state for each remote service endpoint.\n\n### Implementation Guidance\n\nThese performance and reliability extensions build upon the basic RPC framework established in earlier milestones. The implementation approach follows a modular design where extensions can be added incrementally without breaking existing functionality.\n\n#### Technology Recommendations\n\n| Extension Category | Simple Option | Advanced Option |\n|-------------------|---------------|-----------------|\n| Connection Pooling | Thread-safe queue with basic pooling | `asyncio` connection pool with health checks |\n| Async Support | Threading with futures | Full `asyncio` integration |\n| Binary Serialization | MessagePack with fallback to JSON | Protocol Buffers with schema evolution |\n| Authentication | Simple API keys | JWT tokens with role-based permissions |\n| Encryption | TLS with self-signed certificates | TLS with proper CA certificates |\n| Retry Logic | Fixed delay retry | Exponential backoff with jitter |\n| Circuit Breakers | Simple failure counting | Sliding window with configurable thresholds |\n\n#### Recommended File Structure\n\n```\nrpc-framework/\n├── rpc/\n│   ├── extensions/\n│   │   ├── __init__.py\n│   │   ├── connection_pool.py      ← Connection pooling implementation\n│   │   ├── async_client.py         ← Asyncio-based RPC client\n│   │   ├── serialization.py        ← Pluggable serialization formats\n│   │   ├── auth/\n│   │   │   ├── __init__.py\n│   │   │   ├── middleware.py       ← Authentication middleware\n│   │   │   ├── jwt_validator.py    ← JWT token validation\n│   │   │   └── permissions.py      ← Permission management\n│   │   ├── security/\n│   │   │   ├── __init__.py\n│   │   │   ├── tls_config.py       ← TLS configuration helpers\n│   │   │   └── certificates.py     ← Certificate management\n│   │   └── resilience/\n│   │       ├── __init__.py\n│   │       ├── retry_handler.py    ← Retry logic with exponential backoff\n│   │       └── circuit_breaker.py  ← Circuit breaker implementation\n│   ├── core/                       ← Basic RPC framework from earlier milestones\n│   │   ├── protocol.py\n│   │   ├── server.py\n│   │   └── client.py\n│   └── utils/\n│       ├── diagnostics.py          ← Enhanced debugging for extensions\n│       └── testing.py              ← Test helpers for extensions\n├── examples/\n│   ├── pooled_client_example.py    ← Connection pooling demo\n│   ├── async_client_example.py     ← Async RPC calls demo\n│   ├── secure_server_example.py    ← TLS + authentication demo\n│   └── resilient_client_example.py ← Retry + circuit breaker demo\n└── tests/\n    ├── test_extensions/\n    │   ├── test_connection_pool.py\n    │   ├── test_async_client.py\n    │   ├── test_authentication.py\n    │   └── test_resilience.py\n    └── integration/\n        └── test_production_scenarios.py\n```\n\n#### Connection Pool Infrastructure\n\n```python\n# rpc/extensions/connection_pool.py\nimport threading\nimport socket\nimport time\nfrom typing import List, Set, Optional\nfrom queue import Queue, Empty\nfrom contextlib import contextmanager\n\nclass ConnectionPool:\n    \"\"\"Thread-safe connection pool for RPC clients.\"\"\"\n    \n    def __init__(self, host: str, port: int, max_size: int = 10, \n                 min_size: int = 2, idle_timeout: float = 300.0):\n        # TODO 1: Initialize pool state with empty connections and in_use sets\n        # TODO 2: Store connection parameters (host, port) for creating new connections\n        # TODO 3: Set up threading primitives (lock, condition variable for waiting)\n        # TODO 4: Start background thread for connection health checking and cleanup\n        pass\n    \n    @contextmanager\n    def borrow_connection(self, timeout: float = 30.0):\n        \"\"\"Borrow connection from pool, automatically return when done.\"\"\"\n        # TODO 1: Acquire lock and look for available connection in pool\n        # TODO 2: If no connection available, try to create new one if under max_size\n        # TODO 3: If at max_size, wait for connection to be returned (with timeout)\n        # TODO 4: Move borrowed connection from available to in_use set\n        # TODO 5: Yield connection to caller for use in with statement\n        # TODO 6: In finally block, return connection to pool and notify waiters\n        pass\n    \n    def _create_connection(self) -> socket.socket:\n        \"\"\"Create new TCP connection to RPC server.\"\"\"\n        # TODO 1: Create TCP socket with appropriate options (SO_REUSEADDR, etc.)\n        # TODO 2: Set socket timeout for connection establishment\n        # TODO 3: Connect to configured host and port\n        # TODO 4: Validate connection is working (send/receive test message)\n        # TODO 5: Return established socket ready for RPC communication\n        pass\n    \n    def _health_check_worker(self):\n        \"\"\"Background thread that validates connection health and manages pool size.\"\"\"\n        # TODO 1: Run infinite loop with periodic sleep (health_check_interval)\n        # TODO 2: Acquire pool lock and iterate through available connections\n        # TODO 3: Test each connection health (try sending ping or check socket status)\n        # TODO 4: Remove dead connections from pool and close their sockets\n        # TODO 5: If pool below min_size, create new connections to reach minimum\n        pass\n```\n\n#### Async Client Core Implementation\n\n```python\n# rpc/extensions/async_client.py\nimport asyncio\nimport json\nfrom typing import Dict, Any, Optional\nfrom rpc.core.protocol import create_request_message, serialize_message\n\nclass AsyncRPCClient:\n    \"\"\"Asyncio-based RPC client for high-concurrency applications.\"\"\"\n    \n    def __init__(self, host: str, port: int, max_concurrent: int = 1000):\n        # TODO 1: Store connection parameters and initialize async state\n        # TODO 2: Create semaphore to limit concurrent requests (prevent resource exhaustion)\n        # TODO 3: Initialize pending requests dict for tracking futures by request ID\n        # TODO 4: Set up connection state (reader, writer, connected flag)\n        pass\n    \n    async def call(self, method_name: str, *args, timeout: float = 30.0, **kwargs) -> Any:\n        \"\"\"Make async RPC call, returns coroutine that resolves to result.\"\"\"\n        # TODO 1: Generate unique request ID for correlation with response\n        # TODO 2: Create request message with method name and parameters\n        # TODO 3: Serialize message to bytes for network transmission\n        # TODO 4: Acquire semaphore to limit concurrent requests\n        # TODO 5: Ensure connection is established (call _ensure_connected)\n        # TODO 6: Send serialized request over asyncio stream writer\n        # TODO 7: Create Future for this request and store in pending_requests dict\n        # TODO 8: Set up timeout task to cancel future if response doesn't arrive\n        # TODO 9: Return awaitable future that caller can await for result\n        pass\n    \n    async def _ensure_connected(self):\n        \"\"\"Establish asyncio connection if not already connected.\"\"\"\n        # TODO 1: Check if already connected (self._connected flag)\n        # TODO 2: If not connected, use asyncio.open_connection to connect\n        # TODO 3: Store reader and writer streams for sending/receiving\n        # TODO 4: Start background task for reading responses (_response_handler)\n        # TODO 5: Set connected flag and handle connection errors appropriately\n        pass\n    \n    async def _response_handler(self):\n        \"\"\"Background coroutine that reads responses and resolves pending futures.\"\"\"\n        # TODO 1: Run infinite loop reading from asyncio stream reader\n        # TODO 2: Read length-prefixed messages from stream (handle partial reads)\n        # TODO 3: Deserialize received bytes to response message dict\n        # TODO 4: Extract request ID from response to find matching pending future\n        # TODO 5: Check if response contains result or error and resolve future appropriately\n        # TODO 6: Remove completed request from pending_requests dict\n        # TODO 7: Handle connection errors by rejecting all pending futures\n        pass\n```\n\n#### Authentication Middleware Foundation\n\n```python\n# rpc/extensions/auth/middleware.py\nfrom typing import Dict, Any, Optional, Set\nimport jwt\nfrom rpc.core.protocol import create_error_message, ErrorCode\n\nclass AuthMiddleware:\n    \"\"\"Authentication middleware that validates JWT tokens and enforces permissions.\"\"\"\n    \n    def __init__(self, jwt_secret: str, permission_store: 'PermissionStore'):\n        # TODO 1: Store JWT validation secret and permission store reference\n        # TODO 2: Configure JWT validation options (algorithms, expiration checking)\n        # TODO 3: Initialize any caching for token validation results\n        pass\n    \n    def process_request(self, request_message: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        \"\"\"Process incoming request, return error dict if authentication fails.\"\"\"\n        # TODO 1: Extract authentication token from request (header or dedicated field)\n        # TODO 2: If no token present, return authentication required error\n        # TODO 3: Validate JWT token signature and expiration using jwt library\n        # TODO 4: Extract user identity and roles/permissions from token claims\n        # TODO 5: Check if user has permission to invoke the requested method\n        # TODO 6: If authorized, add user context to request and return None (success)\n        # TODO 7: If unauthorized, return error message with appropriate error code\n        pass\n    \n    def _validate_jwt_token(self, token: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Validate JWT token and return claims dict, or None if invalid.\"\"\"\n        # TODO 1: Use jwt.decode() to validate token signature and expiration\n        # TODO 2: Check standard claims (exp, iat, etc.) for validity\n        # TODO 3: Return decoded claims dict if token is valid\n        # TODO 4: Return None if token is expired, malformed, or signature invalid\n        # TODO 5: Log authentication failures for security monitoring\n        pass\n    \n    def _check_method_permission(self, user_claims: Dict[str, Any], \n                               method_name: str) -> bool:\n        \"\"\"Check if authenticated user has permission to call method.\"\"\"\n        # TODO 1: Extract user roles/permissions from JWT claims\n        # TODO 2: Query permission store for required permissions for method\n        # TODO 3: Check if user has all required permissions (intersection check)\n        # TODO 4: Return True if authorized, False if missing permissions\n        pass\n```\n\n#### Circuit Breaker Implementation\n\n```python\n# rpc/extensions/resilience/circuit_breaker.py\nimport threading\nimport time\nfrom enum import Enum\nfrom typing import Callable, Any\nfrom collections import deque\n\nclass CircuitState(Enum):\n    CLOSED = \"closed\"      # Normal operation\n    OPEN = \"open\"          # Rejecting requests\n    HALF_OPEN = \"half_open\"  # Testing recovery\n\nclass CircuitBreaker:\n    \"\"\"Circuit breaker to prevent cascading failures in RPC calls.\"\"\"\n    \n    def __init__(self, failure_threshold: float = 0.5, window_size: int = 100,\n                 timeout_seconds: float = 60.0):\n        # TODO 1: Initialize circuit state to CLOSED (normal operation)\n        # TODO 2: Set up failure tracking with sliding window (use deque)\n        # TODO 3: Store configuration (failure threshold, window size, timeout)\n        # TODO 4: Initialize threading primitives for concurrent access\n        # TODO 5: Set up timing variables for OPEN -> HALF_OPEN transitions\n        pass\n    \n    def call(self, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"Execute function with circuit breaker protection.\"\"\"\n        # TODO 1: Check current circuit state and handle OPEN state (immediate failure)\n        # TODO 2: If HALF_OPEN, allow only single test request through\n        # TODO 3: If CLOSED or test request, execute function and capture result/exception\n        # TODO 4: Record success or failure in sliding window\n        # TODO 5: Update circuit state based on recent failure rate\n        # TODO 6: Return result or raise exception as appropriate\n        pass\n    \n    def _update_circuit_state(self):\n        \"\"\"Update circuit state based on recent failure rate.\"\"\"\n        # TODO 1: Calculate current failure rate from sliding window\n        # TODO 2: If CLOSED and failure rate exceeds threshold, transition to OPEN\n        # TODO 3: If OPEN and timeout expired, transition to HALF_OPEN\n        # TODO 4: If HALF_OPEN and test succeeded, transition to CLOSED\n        # TODO 5: If HALF_OPEN and test failed, return to OPEN with new timeout\n        pass\n    \n    def _record_result(self, success: bool):\n        \"\"\"Record success or failure in sliding window.\"\"\"\n        # TODO 1: Acquire lock for thread-safe access to sliding window\n        # TODO 2: Add success/failure boolean to sliding window deque\n        # TODO 3: If window exceeds max size, remove oldest entry\n        # TODO 4: Update failure rate calculation based on new window contents\n        pass\n```\n\n#### Milestone Checkpoints for Extensions\n\n**Connection Pool Checkpoint:**\nAfter implementing connection pooling:\n1. Run `python -m pytest tests/test_extensions/test_connection_pool.py` - all tests should pass\n2. Start test server with `python examples/pooled_server_example.py`\n3. Run concurrent client test: `python examples/concurrent_client_test.py`\n4. Expected behavior: 100+ concurrent RPC calls complete in under 5 seconds\n5. Check that connection count stays reasonable (under max_pool_size)\n\n**Async Client Checkpoint:**\nAfter implementing async support:\n1. Run `python -m pytest tests/test_extensions/test_async_client.py`\n2. Start server and run: `python examples/async_client_example.py`\n3. Expected behavior: 1000 concurrent async calls complete in under 3 seconds\n4. Memory usage should remain stable (no memory leaks from futures)\n\n**Authentication Checkpoint:**\nAfter implementing auth middleware:\n1. Start secure server: `python examples/secure_server_example.py`\n2. Test with valid token: Should allow method calls\n3. Test without token: Should return \"Authentication required\" error\n4. Test with expired token: Should return \"Token expired\" error\n5. Test unauthorized method: Should return \"Insufficient permissions\" error\n\n**Circuit Breaker Checkpoint:**\nAfter implementing circuit breaker:\n1. Start unreliable server (randomly fails 60% of requests)\n2. Run client with circuit breaker enabled\n3. Expected behavior: Initial requests fail, circuit opens, subsequent requests fail fast\n4. After timeout, circuit allows test request through\n5. If server recovers, circuit closes and normal operation resumes\n\n\n## Glossary\n\n> **Milestone(s):** Foundation for all milestones - provides essential terminology and concepts used throughout message protocol (Milestone 1), server implementation (Milestone 2), and client implementation (Milestone 3)\n\nThis glossary defines the key terms, concepts, and technical vocabulary used throughout the RPC Framework design document. Understanding these terms is essential for implementing the framework successfully and communicating about RPC systems effectively.\n\n### Mental Model: The Technical Dictionary\n\nThink of this glossary as a specialized technical dictionary for our RPC framework domain. Just as a medical dictionary defines terms like \"hypertension\" and \"myocardial infarction\" that have precise meanings in healthcare, this glossary defines terms like \"method proxying\" and \"connection pooling\" that have specific meanings in distributed systems.\n\nEach term represents a concept, pattern, or technique that solves a particular problem in remote procedure calls. When we say \"request correlation,\" we're referring to a specific mechanism for matching responses to their originating requests - not just any kind of matching or correlation. This precision in terminology helps developers communicate clearly about complex distributed system behaviors.\n\n### Core RPC Concepts\n\nThe foundational concepts that define how remote procedure calls work and what problems they solve.\n\n| Term | Definition | Example Usage |\n|------|------------|---------------|\n| **JSON-RPC** | Lightweight remote procedure call protocol using JSON for message encoding. Defines standard request/response message formats with method names, parameters, and unique identifiers. | \"Our framework implements JSON-RPC 2.0 specification for cross-language compatibility.\" |\n| **Remote Procedure Call (RPC)** | Programming paradigm where a program can call functions or methods that execute on a different machine or process, appearing as if they were local function calls. | \"The client uses RPC to invoke the `calculate_taxes` method running on the accounting server.\" |\n| **Method Proxying** | Technique where a client-side proxy object converts method calls into RPC requests transparently, making remote methods appear as local methods to calling code. | \"The `RPCProxy` class implements method proxying through Python's `__getattr__` mechanism.\" |\n| **Request ID** | Unique identifier assigned to each RPC request that allows correlation between requests and their corresponding responses in async or concurrent scenarios. | \"Request ID 'req_12345' ensures the client matches the tax calculation response to the correct calling thread.\" |\n| **Wire Format** | The specific serialized message format sent over the network between RPC client and server, including both message content and any framing or delimiting information. | \"Our wire format uses 4-byte length prefix followed by JSON-encoded message body.\" |\n| **Method Registry** | Server-side mapping that associates function names (strings) with callable handler functions, enabling request dispatch to the appropriate implementation. | \"The server's method registry maps 'user.create' to the `create_user_handler` function.\" |\n| **Request Dispatch** | Server process of receiving an RPC request, looking up the requested method in the registry, and routing the call to the appropriate handler function. | \"Request dispatch failed because 'calculate_orbit' method was not found in the registry.\" |\n\n### Network Communication Terms\n\nTechnical vocabulary for the underlying network protocols and communication patterns that enable RPC functionality.\n\n| Term | Definition | Example Usage |\n|------|------------|---------------|\n| **Message Framing** | Technique for delimiting individual messages within a continuous byte stream, solving the problem of where one message ends and another begins. | \"TCP provides a byte stream, so we need message framing to identify complete RPC messages.\" |\n| **Length Prefix** | Message framing approach where each message begins with a fixed-size header indicating the total message size, allowing the receiver to read exactly the right number of bytes. | \"Our 4-byte length prefix supports messages up to 4GB, though we limit them to 1MB for safety.\" |\n| **Connection Management** | Strategies for handling TCP socket lifecycle including establishment, reuse, health checking, and graceful cleanup to optimize performance and reliability. | \"Proper connection management prevents socket descriptor leaks and reduces connection setup overhead.\" |\n| **Connection Reuse** | Performance optimization where a single persistent TCP connection carries multiple RPC requests/responses instead of creating new connections for each call. | \"Connection reuse reduced average call latency from 15ms to 3ms by eliminating TCP handshake overhead.\" |\n| **Connection Pooling** | Advanced connection management pattern maintaining a pool of reusable connections to a server, allowing concurrent requests while limiting total connection count. | \"The connection pool maintains 5-20 connections to the database server based on current load.\" |\n| **Thread-per-Connection** | Server threading model where each client connection is handled by a dedicated thread, providing isolation and simplicity at the cost of memory overhead. | \"Thread-per-connection model supports 1000 concurrent clients with 1000 server threads.\" |\n| **Send All** | Network programming pattern ensuring complete message transmission by repeatedly calling send() until all bytes are transmitted, handling partial sends gracefully. | \"The `send_all` function prevents message truncation when TCP buffers are full.\" |\n| **Receive All** | Network programming pattern ensuring complete message reception by repeatedly calling receive() until the expected number of bytes have been read. | \"The `recv_all` function blocks until the complete 1024-byte message is received.\" |\n\n### Concurrency and State Management\n\nTerms related to handling multiple simultaneous RPC calls and managing shared state safely across threads.\n\n| Term | Definition | Example Usage |\n|------|------------|---------------|\n| **Request Tracking** | Mechanism for correlating responses with their originating requests, typically using request IDs and pending request data structures. | \"Request tracking prevents responses from being delivered to the wrong calling thread.\" |\n| **Response Correlation** | Process of matching incoming responses to pending requests using request IDs, enabling proper delivery in concurrent environments. | \"Response correlation failed when request ID 'abc123' was not found in pending requests map.\" |\n| **Timeout Handling** | Strategy for preventing indefinite blocking when remote servers are unresponsive, including timeout detection and appropriate error response generation. | \"Timeout handling raises `RPCTimeoutError` when no response arrives within 30 seconds.\" |\n| **Pending Requests** | Client-side data structure tracking active RPC calls that are waiting for responses, typically mapping request IDs to calling thread information. | \"The pending requests dictionary grew to 500 entries during the load test spike.\" |\n| **Connection Health Check** | Periodic validation that pooled or persistent connections are still usable, detecting dead connections before they cause RPC failures. | \"Connection health checks detected 3 stale connections and removed them from the pool.\" |\n| **Race Condition** | Timing-dependent bug in concurrent code where the outcome depends on the relative timing of events, often causing intermittent failures. | \"The race condition occurred when two threads modified the pending requests map simultaneously.\" |\n| **Deadlock** | Circular waiting condition where two or more threads are blocked forever, each waiting for resources held by the others. | \"Deadlock happened when thread A held the registry lock while waiting for connection lock held by thread B.\" |\n\n### Error Handling and Reliability\n\nTerminology for managing failures, errors, and edge cases in distributed RPC systems.\n\n| Term | Definition | Example Usage |\n|------|------------|---------------|\n| **Error Propagation** | Mechanism for transmitting error information from the server back to the client, including error codes, messages, and diagnostic data. | \"Error propagation ensures that database connection failures are reported to the calling client.\" |\n| **Structured Errors** | Error objects with consistent fields and diagnostic information, making them easier to handle programmatically and debug effectively. | \"Structured errors include error codes, human-readable messages, and optional diagnostic data.\" |\n| **Error Categorization** | Classification system for different types of errors (network, serialization, application logic) that enables appropriate handling strategies for each category. | \"Error categorization routes network errors to retry logic and application errors to user feedback.\" |\n| **Graceful Degradation** | System design principle where the system continues operating with reduced functionality during partial failures rather than complete shutdown. | \"Graceful degradation allows read-only operations to continue when the write database is unavailable.\" |\n| **Exponential Backoff** | Retry delay strategy that increases the wait time between retry attempts exponentially, preventing overwhelming of failing services. | \"Exponential backoff waits 1s, 2s, 4s, 8s between retry attempts for the failing payment service.\" |\n| **Retry Logic** | Automatic re-execution strategy for failed operations, typically with limits on attempt count and delays between attempts. | \"Retry logic attempts the account lookup operation up to 3 times with exponential backoff.\" |\n| **Circuit Breaker** | Failure prevention pattern that stops making calls to an unresponsive service for a period, allowing it time to recover. | \"The circuit breaker opened after 10 consecutive failures to the recommendation service.\" |\n| **Transport Error** | Network-level error related to TCP connections, socket operations, or message transmission, distinct from application-level errors. | \"Transport error indicates the connection was reset by peer during message transmission.\" |\n| **Serialization Error** | Error occurring during conversion between objects and their wire format representation, often due to unsupported data types or encoding issues. | \"Serialization error occurred when trying to encode the `datetime` object to JSON.\" |\n| **Protocol Error** | Error in message format or structure that violates the RPC protocol specification, making the message unparseable or invalid. | \"Protocol error: request message missing required 'method' field in JSON-RPC format.\" |\n\n### Testing and Quality Assurance\n\nTerms related to validating RPC system behavior and ensuring reliability through testing strategies.\n\n| Term | Definition | Example Usage |\n|------|------------|---------------|\n| **Integration Testing** | Testing approach that validates interactions between multiple components under realistic conditions, ensuring they work together correctly. | \"Integration testing revealed that client timeouts were too short for database-heavy operations.\" |\n| **End-to-End Testing** | Comprehensive testing that validates complete workflows from client method invocation through network transport to server execution and response. | \"End-to-end testing confirmed that the entire user authentication flow works across service boundaries.\" |\n| **Load Testing** | Performance validation technique that measures system behavior under expected traffic patterns and user loads. | \"Load testing showed the server handles 1000 concurrent clients before response times degrade.\" |\n| **Stress Testing** | Testing approach that pushes the system beyond normal operating conditions to identify breaking points and failure modes. | \"Stress testing with 10,000 concurrent connections revealed memory leaks in connection handling.\" |\n| **Checkpoint Verification** | Testing milestone that validates specific behaviors after implementing each component, providing incremental validation during development. | \"Checkpoint verification confirmed that message serialization works before implementing network transport.\" |\n| **Test Double** | Testing pattern using fake implementations of dependencies (mocks, stubs, fakes) to isolate components under test. | \"The test double simulates network failures to verify client retry behavior.\" |\n\n### Performance and Optimization\n\nTechnical vocabulary related to optimizing RPC system performance and resource utilization.\n\n| Term | Definition | Example Usage |\n|------|------------|---------------|\n| **Latency** | Time delay between initiating an RPC call and receiving the response, including network transmission and server processing time. | \"RPC latency increased from 5ms to 50ms when the database server was moved to a different datacenter.\" |\n| **Throughput** | Number of RPC requests the system can process per unit time, typically measured in requests per second. | \"System throughput peaked at 10,000 requests per second during the benchmark test.\" |\n| **Connection Overhead** | Resource costs associated with establishing and maintaining TCP connections, including memory usage and setup time. | \"Connection overhead was reduced by 60% when we switched from per-request to persistent connections.\" |\n| **Serialization Overhead** | Performance cost of converting objects to and from wire format, including CPU time and memory allocation. | \"JSON serialization overhead accounts for 20% of total RPC call time in our profiling data.\" |\n| **Binary Serialization** | Efficient message encoding using binary formats like MessagePack or Protocol Buffers instead of text-based formats like JSON. | \"Binary serialization reduced message size by 40% and encoding time by 60%.\" |\n| **Async Support** | Non-blocking RPC implementation using asynchronous programming patterns, allowing clients to perform other work while waiting for responses. | \"Async support enables the web server to handle 1000 concurrent RPC calls without blocking threads.\" |\n| **Connection Multiplexing** | Advanced technique allowing multiple concurrent RPC calls over a single TCP connection, improving efficiency and reducing connection overhead. | \"Connection multiplexing allows 100 concurrent requests over just 5 TCP connections.\" |\n\n### Security and Authentication\n\nTerms related to securing RPC communications and controlling access to remote methods.\n\n| Term | Definition | Example Usage |\n|------|------------|---------------|\n| **JWT Authentication** | Stateless authentication mechanism using JSON Web Tokens that embed user claims and permissions within the token itself. | \"JWT authentication eliminates the need for server-side session storage in our RPC service.\" |\n| **Method-Level Authorization** | Fine-grained access control system that validates permissions for individual RPC methods based on user credentials. | \"Method-level authorization prevents regular users from calling administrative methods.\" |\n| **TLS Transport Security** | Encryption of network traffic using Transport Layer Security protocol, protecting RPC messages from eavesdropping and tampering. | \"TLS transport security ensures that sensitive financial data is encrypted during RPC calls.\" |\n| **Token Validation** | Process of verifying JWT tokens including signature validation, expiration checking, and claims verification. | \"Token validation rejected the request because the JWT had expired 5 minutes ago.\" |\n| **Permission Store** | Repository mapping users to their allowed permissions and methods to their required permissions, enabling authorization decisions. | \"The permission store indicates that 'admin' role can call 'user.delete' but 'user' role cannot.\" |\n\n### Development and Implementation\n\nTerms related to the practical aspects of building and organizing RPC framework code.\n\n| Term | Definition | Example Usage |\n|------|------------|---------------|\n| **Receptionist Pattern** | Design pattern where the server acts as a receptionist, routing incoming requests to the appropriate department (handler function). | \"The receptionist pattern centralizes request routing logic in the server's main dispatch method.\" |\n| **Secretary Pattern** | Design pattern where the client acts as a secretary, handling communication complexity on behalf of the calling code. | \"The secretary pattern hides network failures and retries from application code making RPC calls.\" |\n| **Method Cache** | Performance optimization storing references to proxy methods to avoid recreating them on each attribute access. | \"The method cache prevents creating new proxy functions every time `client.remote_method` is accessed.\" |\n| **Proxy Object** | Client-side object that intercepts method calls and converts them into RPC requests, providing transparent remote method invocation. | \"The proxy object makes calling `remote.calculate(x, y)` look identical to local function calls.\" |\n| **Handler Registration** | Process of associating function names with callable implementations in the server's method registry. | \"Handler registration maps the string 'math.add' to the `addition_handler` function.\" |\n| **Request Dispatcher** | Server component responsible for parsing incoming requests and invoking the appropriate registered handler functions. | \"The request dispatcher validates the message format before looking up the requested method.\" |\n| **Response Builder** | Utility component that constructs properly formatted RPC response messages with results, errors, and correlation IDs. | \"The response builder ensures all success responses include the original request ID.\" |\n\n### Debugging and Diagnostics\n\nTerms for troubleshooting RPC systems and understanding their runtime behavior.\n\n| Term | Definition | Example Usage |\n|------|------------|---------------|\n| **Request Tracing** | Diagnostic technique that follows a request through all stages of processing, providing visibility into timing and decision points. | \"Request tracing showed the tax calculation spent 2 seconds waiting for the database query.\" |\n| **Connection Diagnostics** | Monitoring and debugging information about network connections including state, byte counts, and error history. | \"Connection diagnostics revealed that 30% of connections were being closed by network timeouts.\" |\n| **Latency Tracking** | Performance monitoring that measures and records timing information for RPC calls, enabling identification of slow operations. | \"Latency tracking identified that user lookup calls take 500ms on average during peak hours.\" |\n| **Error Correlation** | Diagnostic technique for linking related errors across client and server logs using request IDs and timestamps. | \"Error correlation matched the client timeout with the server's database deadlock exception.\" |\n| **Socket State Monitoring** | Tracking the current state and health of TCP sockets used for RPC communication. | \"Socket state monitoring detected 15 connections in CLOSE_WAIT state, indicating a resource leak.\" |\n\n### Implementation Guidance\n\nThis section provides practical guidance for implementing the concepts defined in this glossary using Python.\n\n#### Core Implementation Classes\n\nThe following table shows the main classes you'll implement and their essential attributes:\n\n| Class Name | Key Attributes | Primary Responsibility |\n|------------|----------------|------------------------|\n| `RPCServer` | `host`, `port`, `registry`, `server_socket`, `running` | Accept connections and dispatch requests |\n| `RPCClient` | `host`, `port`, `default_timeout`, `_socket`, `_pending_requests` | Send requests and manage responses |\n| `MethodRegistry` | `methods`, `lock`, `descriptions` | Store and lookup registered methods |\n| `RPCProxy` | `_client`, `_timeout`, `_method_cache` | Provide transparent method call interface |\n| `ConnectionPool` | `host`, `port`, `max_size`, `connections`, `pool_lock` | Manage reusable connections efficiently |\n\n#### Error Hierarchy Implementation\n\nCreate a comprehensive error class hierarchy to support structured error handling:\n\n```python\nclass RPCError(Exception):\n    \"\"\"Base class for all RPC-related errors.\"\"\"\n    def __init__(self, message: str, error_code: int, error_data: any = None):\n        super().__init__(message)\n        self.message = message\n        self.error_code = error_code\n        self.error_data = error_data\n\nclass RPCProtocolError(RPCError):\n    \"\"\"Error in message format or protocol compliance.\"\"\"\n    def __init__(self, message: str, raw_data: bytes, parse_stage: str):\n        super().__init__(message, PARSE_ERROR)\n        self.raw_data = raw_data\n        self.parse_stage = parse_stage\n\nclass RPCTransportError(RPCError):\n    \"\"\"Network-level communication error.\"\"\"\n    def __init__(self, message: str, host: str, port: int, operation: str):\n        super().__init__(message, TRANSPORT_ERROR)\n        self.host = host\n        self.port = port\n        self.operation = operation\n\nclass RPCTimeoutError(RPCError):\n    \"\"\"Request timeout error.\"\"\"\n    def __init__(self, message: str, timeout_seconds: float, elapsed_seconds: float):\n        super().__init__(message, TIMEOUT_ERROR)\n        self.timeout_seconds = timeout_seconds\n        self.elapsed_seconds = elapsed_seconds\n\nclass RPCMethodError(RPCError):\n    \"\"\"Error during method execution.\"\"\"\n    def __init__(self, message: str, method_name: str, params: list, execution_phase: str):\n        super().__init__(message, INTERNAL_ERROR)\n        self.method_name = method_name\n        self.params = params\n        self.execution_phase = execution_phase\n```\n\n#### Standard Error Codes\n\nDefine error codes following JSON-RPC specification:\n\n```python\nclass ErrorCode:\n    PARSE_ERROR = -32700      # Invalid JSON received\n    INVALID_REQUEST = -32600   # JSON is not a valid request object\n    METHOD_NOT_FOUND = -32601  # Method does not exist\n    INVALID_PARAMS = -32602    # Invalid method parameters\n    INTERNAL_ERROR = -32603    # Internal JSON-RPC error\n    TRANSPORT_ERROR = -32000   # Network/transport error\n    TIMEOUT_ERROR = -32001     # Request timeout\n    CONNECTION_ERROR = -32002  # Connection failed\n```\n\n#### Message Utilities\n\nEssential functions for message handling:\n\n```python\nimport json\nimport uuid\nimport struct\nimport socket\nfrom typing import Dict, Any, Optional\n\ndef generate_request_id() -> str:\n    \"\"\"Generate unique request identifier using UUID4.\"\"\"\n    return str(uuid.uuid4())\n\ndef create_request_message(method: str, params: list, request_id: str) -> Dict[str, Any]:\n    \"\"\"Create JSON-RPC 2.0 request message.\"\"\"\n    return {\n        \"jsonrpc\": \"2.0\",\n        \"method\": method,\n        \"params\": params,\n        \"id\": request_id\n    }\n\ndef create_response_message(request_id: str, result: Any) -> Dict[str, Any]:\n    \"\"\"Create JSON-RPC 2.0 success response message.\"\"\"\n    return {\n        \"jsonrpc\": \"2.0\",\n        \"result\": result,\n        \"id\": request_id\n    }\n\ndef create_error_message(request_id: str, code: int, message: str, data: Any = None) -> Dict[str, Any]:\n    \"\"\"Create JSON-RPC 2.0 error response message.\"\"\"\n    error_obj = {\"code\": code, \"message\": message}\n    if data is not None:\n        error_obj[\"data\"] = data\n    \n    return {\n        \"jsonrpc\": \"2.0\",\n        \"error\": error_obj,\n        \"id\": request_id\n    }\n\ndef serialize_message(message: Dict[str, Any]) -> bytes:\n    \"\"\"Convert message dictionary to JSON bytes.\"\"\"\n    json_str = json.dumps(message, separators=(',', ':'))\n    return json_str.encode('utf-8')\n\ndef deserialize_message(data: bytes) -> Dict[str, Any]:\n    \"\"\"Parse JSON bytes to message dictionary.\"\"\"\n    try:\n        json_str = data.decode('utf-8')\n        return json.loads(json_str)\n    except (UnicodeDecodeError, json.JSONDecodeError) as e:\n        raise RPCProtocolError(f\"Failed to deserialize message: {e}\", data, \"json_parsing\")\n```\n\n#### Network Helper Functions\n\nLow-level socket operations with proper error handling:\n\n```python\nimport time\nimport select\n\nMAX_MESSAGE_SIZE = 1048576  # 1MB maximum message size\n\ndef send_all(sock: socket.socket, data: bytes, timeout: float = 30.0) -> None:\n    \"\"\"Send complete message handling partial sends.\"\"\"\n    sock.settimeout(timeout)\n    bytes_sent = 0\n    total_bytes = len(data)\n    start_time = time.time()\n    \n    while bytes_sent < total_bytes:\n        if time.time() - start_time > timeout:\n            raise RPCTimeoutError(f\"Send timeout after {timeout}s\", timeout, time.time() - start_time)\n            \n        try:\n            sent = sock.send(data[bytes_sent:])\n            if sent == 0:\n                raise RPCTransportError(\"Socket connection broken during send\", \n                                      sock.getpeername()[0], sock.getpeername()[1], \"send\")\n            bytes_sent += sent\n        except socket.error as e:\n            raise RPCTransportError(f\"Send failed: {e}\", \n                                  sock.getpeername()[0], sock.getpeername()[1], \"send\")\n\ndef recv_all(sock: socket.socket, size: int, timeout: float = 30.0) -> bytes:\n    \"\"\"Receive exact byte count with timeout.\"\"\"\n    sock.settimeout(timeout)\n    chunks = []\n    bytes_received = 0\n    start_time = time.time()\n    \n    while bytes_received < size:\n        if time.time() - start_time > timeout:\n            raise RPCTimeoutError(f\"Receive timeout after {timeout}s\", timeout, time.time() - start_time)\n            \n        try:\n            chunk = sock.recv(min(size - bytes_received, 4096))\n            if not chunk:\n                raise RPCTransportError(\"Socket connection closed during receive\",\n                                      sock.getpeername()[0], sock.getpeername()[1], \"recv\")\n            chunks.append(chunk)\n            bytes_received += len(chunk)\n        except socket.error as e:\n            raise RPCTransportError(f\"Receive failed: {e}\",\n                                  sock.getpeername()[0], sock.getpeername()[1], \"recv\")\n    \n    return b''.join(chunks)\n\ndef send_message(sock: socket.socket, message_bytes: bytes, timeout: float = 30.0) -> None:\n    \"\"\"Send length-prefixed message.\"\"\"\n    if len(message_bytes) > MAX_MESSAGE_SIZE:\n        raise RPCProtocolError(f\"Message too large: {len(message_bytes)} bytes\", \n                              message_bytes, \"size_check\")\n    \n    # Send 4-byte length prefix in network byte order\n    length_prefix = struct.pack('!I', len(message_bytes))\n    send_all(sock, length_prefix, timeout)\n    send_all(sock, message_bytes, timeout)\n\ndef recv_message(sock: socket.socket, timeout: float = 30.0) -> bytes:\n    \"\"\"Receive length-prefixed message.\"\"\"\n    # Read 4-byte length prefix\n    length_data = recv_all(sock, 4, timeout)\n    message_length = struct.unpack('!I', length_data)[0]\n    \n    if message_length > MAX_MESSAGE_SIZE:\n        raise RPCProtocolError(f\"Message too large: {message_length} bytes\",\n                              length_data, \"length_check\")\n    \n    # Read message body\n    return recv_all(sock, message_length, timeout)\n```\n\n#### File Structure Recommendation\n\nOrganize your RPC framework code using this structure:\n\n```\nrpc_framework/\n├── __init__.py                 # Package exports\n├── protocol.py                 # Message formats and serialization\n├── server.py                   # RPCServer implementation\n├── client.py                   # RPCClient and RPCProxy implementation\n├── registry.py                 # MethodRegistry implementation\n├── errors.py                   # Error class hierarchy\n├── transport.py                # Network helper functions\n├── utils.py                    # Utility functions\n└── tests/\n    ├── __init__.py\n    ├── test_protocol.py        # Message protocol tests\n    ├── test_server.py          # Server component tests\n    ├── test_client.py          # Client component tests\n    └── test_integration.py     # End-to-end tests\n```\n\nThis structure separates concerns cleanly while keeping related functionality together. Each module has a clear responsibility and can be developed and tested independently.\n"}