{"html":"<h1 id=\"secret-management-system-design-document\">Secret Management System: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>A distributed secret management system inspired by HashiCorp Vault that provides secure storage, dynamic secret generation, and fine-grained access control for applications. The key architectural challenge is building a zero-trust security model that encrypts secrets at rest, enforces path-based policies, and maintains high availability while requiring human operators to unseal the system.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides the foundational context that applies to all milestones, establishing why we need a centralized secret management system and the security challenges it addresses.</p>\n</blockquote>\n<h3 id=\"the-bank-vault-analogy\">The Bank Vault Analogy</h3>\n<p>Think of a modern bank&#39;s security system as the perfect mental model for understanding secret management. A bank doesn&#39;t just throw cash into a filing cabinet and call it secure. Instead, it employs multiple layers of protection: a massive steel vault with time locks, individual safety deposit boxes within that vault, armed guards who verify your identity before granting access, detailed logs of who accessed what and when, and multiple keys or combinations required to open the main vault (no single person can access everything alone).</p>\n<p>Your application&#39;s secrets—database passwords, API keys, encryption keys, certificates—are just as valuable as the cash in that bank vault. A compromised database password can expose millions of customer records. A leaked API key can rack up thousands of dollars in cloud costs or grant access to sensitive services. An exposed encryption key can render all your &quot;secure&quot; data readable by attackers.</p>\n<p>Just as banks evolved from simple lockboxes to sophisticated multi-layered security systems, application secret management has evolved from simple configuration files to centralized secret management systems. The bank vault analogy maps perfectly to our secret management system:</p>\n<ul>\n<li><strong>The Steel Vault</strong> → Our encryption engine with envelope encryption</li>\n<li><strong>Individual Safety Deposit Boxes</strong> → Path-based secret storage with fine-grained access control</li>\n<li><strong>Bank Guards and ID Verification</strong> → Authentication and authorization engines</li>\n<li><strong>Access Logs and Cameras</strong> → Comprehensive audit logging</li>\n<li><strong>Multiple Keys Required</strong> → Shamir&#39;s secret sharing for unsealing the system</li>\n<li><strong>Branch Locations</strong> → High availability with multiple nodes</li>\n</ul>\n<p>The critical insight here is that security isn&#39;t just about encryption—it&#39;s about creating a <strong>zero-trust system</strong> where every request must be authenticated, authorized, logged, and encrypted, just like every bank transaction.</p>\n<h3 id=\"the-secret-sprawl-problem\">The Secret Sprawl Problem</h3>\n<p>In most organizations, secrets proliferate like weeds across the infrastructure landscape, creating what security professionals call &quot;secret sprawl.&quot; This scattered approach creates numerous attack vectors and operational nightmares.</p>\n<p>Consider a typical web application stack: the frontend needs API keys for third-party services, the backend needs database credentials and encryption keys, the deployment pipeline needs cloud provider credentials, monitoring systems need service account tokens, and backup scripts need storage access keys. Without centralized management, these secrets end up everywhere:</p>\n<p><strong>Configuration Files</strong> become secret repositories by accident. Developers embed database URLs with passwords directly into <code>config.yaml</code> files, then check them into version control. Even after rotating the password, it remains in git history forever. The <code>application.properties</code> file becomes a treasure trove of sensitive data that gets copied to every deployment environment.</p>\n<p><strong>Environment Variables</strong> seem safer initially, but they leak in process listings, crash dumps, and container orchestration logs. When a developer runs <code>env | grep DATABASE_PASSWORD</code> on a production server for debugging, that password appears in shell history. Container platforms often log environment variables during deployment, creating permanent records of sensitive data.</p>\n<p><strong>Hardcoded Secrets</strong> represent the worst-case scenario—passwords embedded directly in source code. These spread through copy-paste programming, appear in multiple repositories, and become nearly impossible to rotate without coordinating changes across dozens of codebases simultaneously.</p>\n<p>The fundamental problems with secret sprawl include:</p>\n<table>\n<thead>\n<tr>\n<th>Problem</th>\n<th>Impact</th>\n<th>Concrete Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>No Centralized Rotation</strong></td>\n<td>A single compromised secret requires manual updates across dozens of systems</td>\n<td>Database password leak requires updating 15 microservices, 3 batch jobs, and 5 monitoring scripts individually</td>\n</tr>\n<tr>\n<td><strong>Unclear Access Patterns</strong></td>\n<td>No visibility into which applications access which secrets</td>\n<td>Security team can&#39;t determine blast radius when API key is found in public GitHub repo</td>\n</tr>\n<tr>\n<td><strong>Long-Lived Secrets</strong></td>\n<td>Static passwords remain valid for months or years</td>\n<td>Production database password hasn&#39;t changed in 2 years; compromise goes undetected for months</td>\n</tr>\n<tr>\n<td><strong>Inconsistent Security</strong></td>\n<td>Each team implements their own secret handling with varying security levels</td>\n<td>Team A encrypts secrets with AES-256; Team B stores them in plain text</td>\n</tr>\n<tr>\n<td><strong>Audit Gaps</strong></td>\n<td>No comprehensive logging of secret access</td>\n<td>Compliance audit fails because company can&#39;t prove who accessed customer encryption keys</td>\n</tr>\n<tr>\n<td><strong>Emergency Response Delays</strong></td>\n<td>Incident response requires hunting secrets across multiple systems</td>\n<td>After data breach, team spends 6 hours finding all systems that need new credentials</td>\n</tr>\n</tbody></table>\n<p><strong>The Operational Nightmare</strong> manifests during incidents. Imagine your cloud provider notifies you that your S3 access keys were found in a public code repository. In a sprawled environment, you must:</p>\n<ol>\n<li>Identify every application, script, and service using those keys</li>\n<li>Generate new credentials in the cloud provider console</li>\n<li>Update configuration files across multiple repositories</li>\n<li>Deploy updated configurations to staging and production environments</li>\n<li>Verify that all systems are working with new credentials</li>\n<li>Monitor logs to ensure no systems are still using old credentials</li>\n</ol>\n<p>This process can take hours or days, during which your systems remain vulnerable. With centralized secret management, this same scenario becomes: update the secret in one location, and all authorized applications automatically receive the new credentials within minutes.</p>\n<h3 id=\"current-approaches-comparison\">Current Approaches Comparison</h3>\n<p>Organizations today employ various strategies for secret management, each with distinct trade-offs that influence security posture, operational complexity, and developer experience.</p>\n<blockquote>\n<p><strong>Decision: Secret Management Strategy Selection</strong></p>\n<ul>\n<li><strong>Context</strong>: Applications need secure access to databases, APIs, and other services requiring authentication, but must balance security, operational overhead, and development velocity</li>\n<li><strong>Options Considered</strong>: Environment variables, configuration files, cloud secret services, dedicated secret management systems</li>\n<li><strong>Decision</strong>: Implement a dedicated secret management system with centralized storage, encryption, and access control</li>\n<li><strong>Rationale</strong>: Provides strongest security guarantees while enabling automated secret rotation and comprehensive audit trails</li>\n<li><strong>Consequences</strong>: Requires additional infrastructure but eliminates secret sprawl and enables sophisticated security policies</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Security Level</th>\n<th>Operational Overhead</th>\n<th>Developer Experience</th>\n<th>Use Cases</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Environment Variables</strong></td>\n<td>Low-Medium</td>\n<td>Low</td>\n<td>Excellent</td>\n<td>Development environments, simple deployments</td>\n</tr>\n<tr>\n<td><strong>Configuration Files</strong></td>\n<td>Low</td>\n<td>Medium</td>\n<td>Good</td>\n<td>Traditional applications, legacy systems</td>\n</tr>\n<tr>\n<td><strong>Cloud Secret Services</strong></td>\n<td>High</td>\n<td>Medium</td>\n<td>Good</td>\n<td>Cloud-native applications, single-provider environments</td>\n</tr>\n<tr>\n<td><strong>Dedicated Secret Management</strong></td>\n<td>Very High</td>\n<td>High</td>\n<td>Medium</td>\n<td>Enterprise environments, multi-cloud, compliance requirements</td>\n</tr>\n</tbody></table>\n<p><strong>Environment Variables</strong> represent the simplest approach, leveraging the operating system&#39;s built-in capability to pass configuration to processes. Developers appreciate the simplicity—<code>os.Getenv(&quot;DATABASE_PASSWORD&quot;)</code> works identically across languages and platforms. However, environment variables appear in process lists (<code>ps aux</code> shows them to any user), get logged by container orchestration systems, and persist in shell history. They work well for development environments where security threats are minimal, but create significant risks in production.</p>\n<p>The environmental variable approach breaks down with secret rotation. Changing a database password requires updating environment variables across every deployment, then restarting all affected services. During the transition window, some services use old credentials while others use new ones, creating authentication failures and service disruptions.</p>\n<p><strong>Configuration Files</strong> offer more structure and can support encryption at rest. A <code>secrets.yaml</code> file can contain all application secrets in one location, potentially encrypted with a master key. This approach enables version control of secret configurations (with encrypted values) and supports complex secret hierarchies with nested structures.</p>\n<p>However, configuration files introduce key distribution problems—how do applications securely obtain the master key to decrypt the configuration file? The key often ends up in environment variables or hardcoded, recreating the original problem. Additionally, updating configuration files requires application restarts, preventing dynamic secret rotation.</p>\n<p><strong>Cloud Secret Services</strong> like AWS Secrets Manager, Azure Key Vault, or Google Secret Manager provide professionally managed secret storage with strong encryption, automated rotation capabilities, and comprehensive audit logging. These services integrate seamlessly with cloud-native applications and handle the operational complexity of secret management.</p>\n<p>The primary limitations of cloud secret services include vendor lock-in (applications become tightly coupled to specific cloud providers), limited customization options, and challenges in multi-cloud environments. Organizations using multiple cloud providers must integrate with different secret APIs, each with unique authentication models and feature sets.</p>\n<p><strong>Dedicated Secret Management Systems</strong> like HashiCorp Vault provide the highest level of security and flexibility. These systems implement sophisticated encryption schemes, support multiple authentication methods, enable dynamic secret generation, and offer granular access control policies. They operate independently of cloud providers, supporting multi-cloud and hybrid environments.</p>\n<p>The trade-off involves operational complexity—dedicated secret management systems require specialized knowledge to deploy, configure, and maintain. They introduce additional infrastructure dependencies and require careful attention to high availability and disaster recovery.</p>\n<blockquote>\n<p>The fundamental insight driving our architectural decisions is that <strong>security and convenience exist in constant tension</strong>. The most secure approach (air-gapped systems with manual key management) proves unusable for modern application development. The most convenient approach (hardcoded secrets) creates catastrophic security vulnerabilities. Our secret management system aims to find the optimal balance point.</p>\n</blockquote>\n<p><strong>Dynamic vs Static Secret Models</strong> represent a critical architectural distinction. Traditional approaches treat secrets as static configuration—passwords that change infrequently and must be distributed to applications. Dynamic secret systems generate unique, short-lived credentials on-demand for each application or session.</p>\n<p>Consider database access patterns: static approaches use shared database credentials across all application instances. If those credentials leak, every application instance is compromised, and rotation requires coordinating updates across the entire fleet. Dynamic approaches generate unique database users for each application instance, with automatic expiration after configurable time periods. Credential leaks affect only single instances, and rotation happens automatically without coordination.</p>\n<table>\n<thead>\n<tr>\n<th>Secret Model</th>\n<th>Credential Sharing</th>\n<th>Rotation Complexity</th>\n<th>Blast Radius</th>\n<th>Audit Granularity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Static</strong></td>\n<td>Multiple applications share same credentials</td>\n<td>High - requires coordination</td>\n<td>High - affects all users</td>\n<td>Low - can&#39;t distinguish application instances</td>\n</tr>\n<tr>\n<td><strong>Dynamic</strong></td>\n<td>Each application gets unique credentials</td>\n<td>Low - automatic with TTL</td>\n<td>Low - affects single application</td>\n<td>High - individual application tracking</td>\n</tr>\n</tbody></table>\n<p>The mental model for dynamic secrets resembles a hotel key card system. Instead of giving every guest the same master key, hotels generate unique key cards for each guest&#39;s stay, programmed to work only for specific rooms during specific dates. When a guest checks out, their key card automatically becomes invalid. If a key card is lost or stolen, it affects only that guest&#39;s access, not the entire hotel&#39;s security.</p>\n<p><strong>Implementation Complexity Considerations</strong> influence the architectural approach significantly. Simple secret management implementations can start with encrypted configuration files and basic environment variable injection. However, this approach doesn&#39;t scale to enterprise requirements for audit logging, fine-grained access control, or dynamic secret generation.</p>\n<p>Our architectural decision prioritizes <strong>security depth over implementation simplicity</strong>. While this increases initial development complexity, it provides a foundation for sophisticated security policies, comprehensive audit trails, and automated secret lifecycle management that prove essential for production environments and compliance requirements.</p>\n<p>The subsequent sections detail how our secret management system addresses each challenge identified in this problem statement, building from basic encrypted storage through sophisticated high-availability clustering with automated failover and recovery capabilities.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>HTTP Server</strong></td>\n<td><code>net/http</code> with JSON</td>\n<td><code>gRPC</code> with Protocol Buffers</td>\n</tr>\n<tr>\n<td><strong>Storage Backend</strong></td>\n<td>Local filesystem with <code>os.File</code></td>\n<td><code>etcd</code> or <code>consul</code> for distributed storage</td>\n</tr>\n<tr>\n<td><strong>Encryption</strong></td>\n<td><code>crypto/aes</code> with <code>crypto/rand</code></td>\n<td>Hardware Security Modules (HSMs)</td>\n</tr>\n<tr>\n<td><strong>Authentication</strong></td>\n<td>Simple bearer tokens</td>\n<td><code>x/crypto/bcrypt</code> + JWT with <code>github.com/golang-jwt/jwt</code></td>\n</tr>\n<tr>\n<td><strong>Logging</strong></td>\n<td>Standard library <code>log</code></td>\n<td>Structured logging with <code>github.com/sirupsen/logrus</code></td>\n</tr>\n<tr>\n<td><strong>Configuration</strong></td>\n<td>JSON files with <code>encoding/json</code></td>\n<td>YAML with <code>gopkg.in/yaml.v3</code></td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong></p>\n<p>Organize your secret management system with clear separation of concerns from the beginning:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>secret-manager/\n├── cmd/\n│   └── secret-server/\n│       └── main.go                 ← Entry point and server startup\n├── internal/\n│   ├── config/\n│   │   ├── config.go              ← Configuration loading and validation\n│   │   └── config_test.go\n│   ├── storage/\n│   │   ├── storage.go             ← Storage interface definition\n│   │   ├── file_storage.go        ← Filesystem storage implementation\n│   │   └── storage_test.go\n│   ├── crypto/\n│   │   ├── envelope.go            ← Envelope encryption implementation\n│   │   ├── keys.go                ← Key generation and management\n│   │   └── crypto_test.go\n│   ├── auth/\n│   │   ├── authenticator.go       ← Authentication interface\n│   │   ├── token_auth.go          ← Token-based authentication\n│   │   └── auth_test.go\n│   ├── policy/\n│   │   ├── evaluator.go           ← Policy evaluation engine\n│   │   ├── policy.go              ← Policy data structures\n│   │   └── policy_test.go\n│   └── server/\n│       ├── server.go              ← HTTP server and routing\n│       ├── handlers.go            ← HTTP request handlers\n│       └── server_test.go\n├── pkg/\n│   └── client/\n│       ├── client.go              ← Client library for applications\n│       └── client_test.go\n├── configs/\n│   ├── server.yaml                ← Server configuration template\n│   └── policies.yaml             ← Example policy configurations\n└── scripts/\n    ├── setup.sh                  ← Development environment setup\n    └── generate-certs.sh         ← TLS certificate generation</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p>Here&#39;s a complete configuration management system to handle server settings and policy loading:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/config/config.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> config</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ServerConfig holds all configuration for the secret management server</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ServerConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Server </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Address     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"address\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Port        </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">           `json:\"port\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TLSCertFile </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"tls_cert_file\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TLSKeyFile  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"tls_key_file\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ReadTimeout </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"read_timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#9ECBFF\">`json:\"server\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Storage </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Type </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"type\"`</span><span style=\"color:#6A737D\"> // \"file\", \"etcd\", \"consul\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Path </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"path\"`</span><span style=\"color:#6A737D\"> // For file storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        URL  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"url\"`</span><span style=\"color:#6A737D\">  // For distributed storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#9ECBFF\">`json:\"storage\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Encryption </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        MasterKeyFile </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"master_key_file\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Algorithm     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"algorithm\"`</span><span style=\"color:#6A737D\"> // \"aes-256-gcm\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#9ECBFF\">`json:\"encryption\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Auth </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Methods []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"methods\"`</span><span style=\"color:#6A737D\"> // [\"token\", \"mtls\"]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TokenTTL </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"token_ttl\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#9ECBFF\">`json:\"auth\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LoadConfig reads configuration from the specified file path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> LoadConfig</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">configPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ServerConfig</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Open</span><span style=\"color:#E1E4E8\">(configPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to open config file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> file.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> config </span><span style=\"color:#B392F0\">ServerConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    decoder </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">NewDecoder</span><span style=\"color:#E1E4E8\">(file)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> decoder.</span><span style=\"color:#B392F0\">Decode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">config); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to parse config file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> config.</span><span style=\"color:#B392F0\">validate</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid configuration: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">config, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// validate ensures all required configuration fields are present and valid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ServerConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">validate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.Server.Address </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.Server.Address </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"localhost\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.Server.Port </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.Server.Port </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 8443</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.Server.ReadTimeout </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.Server.ReadTimeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.Storage.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.Storage.Type </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"file\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.Storage.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"file\"</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> c.Storage.Path </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.Storage.Path </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"./data\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.Encryption.Algorithm </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.Encryption.Algorithm </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"aes-256-gcm\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(c.Auth.Methods) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.Auth.Methods </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"token\"</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> c.Auth.TokenTTL </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.Auth.TokenTTL </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 24</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Hour</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Complete HTTP server foundation with security headers and logging:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/server/server.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> server</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">secret-manager/internal/config</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SecretServer handles HTTP requests for the secret management system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SecretServer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">config</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ServerConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add encryption engine, auth engine, storage backend</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewSecretServer creates a new secret management server</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewSecretServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cfg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">config</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ServerConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretServer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">NewServeMux</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Addr:         fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, cfg.Server.Address, cfg.Server.Port),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Handler:      </span><span style=\"color:#B392F0\">securityMiddleware</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">loggingMiddleware</span><span style=\"color:#E1E4E8\">(mux)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ReadTimeout:  cfg.Server.ReadTimeout,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        WriteTimeout: cfg.Server.ReadTimeout,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        IdleTimeout:  cfg.Server.ReadTimeout </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">SecretServer</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config: cfg,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        server: server,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.</span><span style=\"color:#B392F0\">setupRoutes</span><span style=\"color:#E1E4E8\">(mux)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> s</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// setupRoutes configures all HTTP endpoints</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">setupRoutes</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mux</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ServeMux</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Health check endpoint</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/v1/health\"</span><span style=\"color:#E1E4E8\">, s.handleHealth)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Secret management endpoints (to be implemented in later milestones)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/v1/secret/\"</span><span style=\"color:#E1E4E8\">, s.handleSecret)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/v1/auth/\"</span><span style=\"color:#E1E4E8\">, s.handleAuth)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/v1/policy/\"</span><span style=\"color:#E1E4E8\">, s.handlePolicy)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Start begins serving HTTP requests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Secret server starting on </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, s.server.Addr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> s.config.Server.TLSCertFile </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> s.config.Server.TLSKeyFile </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> s.server.</span><span style=\"color:#B392F0\">ListenAndServeTLS</span><span style=\"color:#E1E4E8\">(s.config.Server.TLSCertFile, s.config.Server.TLSKeyFile)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> s.server.</span><span style=\"color:#B392F0\">ListenAndServe</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Shutdown gracefully stops the server</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Shutdown</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> s.server.</span><span style=\"color:#B392F0\">Shutdown</span><span style=\"color:#E1E4E8\">(ctx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Security middleware adds essential security headers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> securityMiddleware</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">next</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Handler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Handler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">HandlerFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"X-Content-Type-Options\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"nosniff\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"X-Frame-Options\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"DENY\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"X-XSS-Protection\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"1; mode=block\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Strict-Transport-Security\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"max-age=31536000; includeSubDomains\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next.</span><span style=\"color:#B392F0\">ServeHTTP</span><span style=\"color:#E1E4E8\">(w, r)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Logging middleware logs all requests for audit purposes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> loggingMiddleware</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">next</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Handler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Handler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">HandlerFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next.</span><span style=\"color:#B392F0\">ServeHTTP</span><span style=\"color:#E1E4E8\">(w, r)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#79B8FF\"> %s</span><span style=\"color:#79B8FF\"> %s</span><span style=\"color:#79B8FF\"> %v\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Format</span><span style=\"color:#E1E4E8\">(time.RFC3339),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            r.Method,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            r.URL.Path,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            r.RemoteAddr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(start))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p>The main server initialization logic that you&#39;ll expand throughout the milestones:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// cmd/secret-server/main.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">flag</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os/signal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">secret-manager/internal/config</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">secret-manager/internal/server</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    configPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> flag.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"config\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"configs/server.json\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Path to configuration file\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">Parse</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load and validate configuration from file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cfg, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> config.</span><span style=\"color:#B392F0\">LoadConfig</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">configPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to load configuration: </span><span style=\"color:#79B8FF\">%v\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize storage backend based on configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This will be implemented in Milestone 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize encryption engine with master key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This will be implemented in Milestone 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Initialize authentication and policy engines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This will be implemented in Milestone 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Initialize dynamic secret engines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This will be implemented in Milestone 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Check if vault is sealed and require unsealing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This will be implemented in Milestone 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    secretServer </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> server.</span><span style=\"color:#B392F0\">NewSecretServer</span><span style=\"color:#E1E4E8\">(cfg)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start server in background goroutine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> secretServer.</span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Server failed: </span><span style=\"color:#79B8FF\">%v\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Wait for shutdown signal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sigChan </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> os</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Signal</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    signal.</span><span style=\"color:#B392F0\">Notify</span><span style=\"color:#E1E4E8\">(sigChan, syscall.SIGINT, syscall.SIGTERM)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    &#x3C;-</span><span style=\"color:#E1E4E8\">sigChan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fmt.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Shutting down server...\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithTimeout</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">time.Second)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#B392F0\"> cancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> secretServer.</span><span style=\"color:#B392F0\">Shutdown</span><span style=\"color:#E1E4E8\">(ctx); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Forced shutdown: </span><span style=\"color:#79B8FF\">%v\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fmt.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Server stopped gracefully\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ul>\n<li><strong>Configuration Management</strong>: Use <code>encoding/json</code> for simple setups or <code>gopkg.in/yaml.v3</code> for more complex configurations with comments and multi-line strings</li>\n<li><strong>HTTP Security</strong>: Always use TLS in production; the <code>crypto/tls</code> package provides excellent defaults with <code>tls.Config{MinVersion: tls.VersionTLS12}</code></li>\n<li><strong>Error Handling</strong>: Wrap errors with context using <code>fmt.Errorf(&quot;operation failed: %w&quot;, err)</code> to maintain error chains</li>\n<li><strong>Graceful Shutdown</strong>: Use <code>context.WithTimeout()</code> for server shutdown to ensure connections close properly</li>\n<li><strong>File Operations</strong>: Use <code>os.OpenFile()</code> with specific permissions (0600 for secret files) and always <code>defer file.Close()</code></li>\n<li><strong>Memory Security</strong>: Use <code>crypto/rand</code> for all random number generation; never use <code>math/rand</code> for security-sensitive operations</li>\n</ul>\n<p><strong>F. Milestone Checkpoint</strong></p>\n<p>After implementing the foundational components described in this section, you should achieve these verification points:</p>\n<p><strong>Basic Server Startup:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/secret-server/main.go</span><span style=\"color:#79B8FF\"> -config</span><span style=\"color:#9ECBFF\"> configs/server.json</span></span></code></pre></div>\n<p>Expected output:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Secret server starting on localhost:8443\n[2024-01-01T12:00:00Z] GET /v1/health 127.0.0.1:54321 2.1ms</code></pre></div>\n\n<p><strong>Health Check Verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -k</span><span style=\"color:#9ECBFF\"> https://localhost:8443/v1/health</span></span></code></pre></div>\n<p>Expected response:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">\"status\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"ok\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\"version\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"1.0.0\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\"timestamp\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2024-01-01T12:00:00Z\"</span><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Configuration Validation:</strong>\nCreate a test configuration file with invalid settings to verify error handling works correctly. The server should refuse to start with clear error messages.</p>\n<p><strong>Security Headers Verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -I</span><span style=\"color:#79B8FF\"> -k</span><span style=\"color:#9ECBFF\"> https://localhost:8443/v1/health</span></span></code></pre></div>\n<p>Verify response includes security headers:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>X-Content-Type-Options: nosniff\nX-Frame-Options: DENY\nStrict-Transport-Security: max-age=31536000; includeSubDomains</code></pre></div>\n\n<p><strong>Signs of Problems and Diagnostics:</strong></p>\n<ul>\n<li><strong>Server won&#39;t start</strong>: Check configuration file syntax with <code>json.Valid()</code> or a JSON validator</li>\n<li><strong>TLS errors</strong>: Verify certificate files exist and have correct permissions (readable by server process)</li>\n<li><strong>Port binding failures</strong>: Ensure no other process is using the configured port with <code>netstat -tlnp | grep :8443</code></li>\n<li><strong>Configuration not loading</strong>: Add debug logging to see exactly which configuration values are being loaded</li>\n</ul>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section establishes the foundation for all milestones by defining system scope and success criteria that guide implementation decisions.</p>\n</blockquote>\n<p>Before diving into the technical architecture, we must clearly establish what this secret management system will and will not do. Think of this as the <strong>system charter</strong> — a contract between the development team and stakeholders that prevents scope creep while ensuring we build something genuinely useful. Just as a bank vault has specific purposes (storing valuables, controlling access) and explicit limitations (not a safety deposit box for oversized items), our secret management system must have clear boundaries.</p>\n<p>The goals we define here directly influence every architectural decision throughout the project. They determine which security models we implement, what performance characteristics we optimize for, and which features we deliberately exclude to maintain focus and simplicity.</p>\n<h3 id=\"functional-goals\">Functional Goals</h3>\n<p>These are the <strong>core capabilities</strong> our secret management system must deliver to be considered successful. Each functional goal maps to specific milestones and acceptance criteria, ensuring our implementation stays focused on essential features.</p>\n<h4 id=\"secret-storage-and-retrieval\">Secret Storage and Retrieval</h4>\n<p>The system must provide <strong>secure, versioned storage</strong> for sensitive data with strong encryption guarantees. Think of this as building a digital safe deposit box where each secret has its own compartment, complete history, and tamper-evident seals.</p>\n<table>\n<thead>\n<tr>\n<th>Capability</th>\n<th>Description</th>\n<th>Acceptance Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Encrypted Storage</td>\n<td>All secrets encrypted at rest using AES-256-GCM</td>\n<td>No plaintext secrets in storage backend</td>\n</tr>\n<tr>\n<td>Secret Versioning</td>\n<td>Maintain complete history of secret value changes</td>\n<td>Retrieve any previous version by ID</td>\n</tr>\n<tr>\n<td>Key Rotation</td>\n<td>Replace encryption keys without service interruption</td>\n<td>All secrets re-encrypted with new keys</td>\n</tr>\n<tr>\n<td>Atomic Operations</td>\n<td>Secret updates succeed completely or fail completely</td>\n<td>No partial writes during failures</td>\n</tr>\n</tbody></table>\n<p>The <strong>envelope encryption</strong> model forms the security foundation here. The master key encrypts data encryption keys, which in turn encrypt individual secrets. This creates multiple security layers — even if storage is compromised, secrets remain protected by the master key hierarchy.</p>\n<blockquote>\n<p><strong>Decision: Envelope Encryption Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Secrets need encryption at rest, but managing individual keys per secret creates complexity</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Single master key encrypts all secrets directly</li>\n<li>Envelope encryption with master key protecting data keys</li>\n<li>Per-secret encryption keys stored separately</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Envelope encryption with hierarchical key structure</li>\n<li><strong>Rationale</strong>: Provides key rotation without re-encrypting all data, isolates key management from data encryption, enables fine-grained access control</li>\n<li><strong>Consequences</strong>: Adds complexity but enables secure key rotation and better security isolation</li>\n</ul>\n</blockquote>\n<h4 id=\"access-control-and-authentication\">Access Control and Authentication</h4>\n<p>The system must implement <strong>zero-trust authentication</strong> and <strong>path-based authorization</strong> to ensure only authorized clients can access specific secrets. Consider this like a bank&#39;s security model — every person must identify themselves, and their identity determines which safe deposit boxes they can access.</p>\n<table>\n<thead>\n<tr>\n<th>Authentication Method</th>\n<th>Use Case</th>\n<th>Security Properties</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Token-based</td>\n<td>Service-to-service communication</td>\n<td>Revocable, time-limited, auditable</td>\n</tr>\n<tr>\n<td>Mutual TLS</td>\n<td>High-security environments</td>\n<td>Certificate-based identity, network encryption</td>\n</tr>\n<tr>\n<td>AppRole</td>\n<td>CI/CD and automated systems</td>\n<td>Role-based with secret delivery separation</td>\n</tr>\n</tbody></table>\n<p>The <strong>policy evaluation engine</strong> implements path-based access control using glob patterns. For example, a policy might grant the <code>web-service</code> role access to <code>secrets/production/web/*</code> but deny access to <code>secrets/production/database/*</code>. This fine-grained control ensures secrets follow the principle of least privilege.</p>\n<blockquote>\n<p><strong>Decision: Path-Based Access Control</strong></p>\n<ul>\n<li><strong>Context</strong>: Need flexible authorization that scales with organizational structure</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Role-based access control with fixed permission sets</li>\n<li>Path-based ACLs with pattern matching</li>\n<li>Attribute-based access control with complex rules</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Path-based ACLs with glob pattern support</li>\n<li><strong>Rationale</strong>: Maps naturally to secret organization, easy to understand and audit, performant evaluation</li>\n<li><strong>Consequences</strong>: Enables intuitive permission models but requires careful pattern design to avoid overly broad access</li>\n</ul>\n</blockquote>\n<h4 id=\"dynamic-secret-generation\">Dynamic Secret Generation</h4>\n<p>The system must generate <strong>short-lived credentials</strong> on demand for external systems like databases and cloud providers. Think of this as a <strong>credential vending machine</strong> — insert a valid request token, receive fresh credentials that automatically expire.</p>\n<table>\n<thead>\n<tr>\n<th>Backend Type</th>\n<th>Generated Credential</th>\n<th>Lifecycle Management</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database</td>\n<td>Username/password with limited privileges</td>\n<td>Auto-revocation on lease expiry</td>\n</tr>\n<tr>\n<td>Cloud Provider</td>\n<td>API keys with scoped permissions</td>\n<td>Cleanup via provider APIs</td>\n</tr>\n<tr>\n<td>SSH</td>\n<td>Certificate-based access</td>\n<td>Certificate expiration handling</td>\n</tr>\n</tbody></table>\n<p>The <strong>lease management system</strong> tracks every generated credential with time-to-live (TTL) limits. Background processes automatically revoke expired credentials, preventing credential accumulation in external systems. This solves the credential rotation problem by making credentials inherently temporary.</p>\n<h4 id=\"high-availability-and-disaster-recovery\">High Availability and Disaster Recovery</h4>\n<p>The system must operate reliably in distributed environments with <strong>automatic failover</strong> and <strong>data durability</strong> guarantees. Picture this as building multiple bank branches that stay synchronized — if one location fails, others continue serving customers with complete access to their accounts.</p>\n<table>\n<thead>\n<tr>\n<th>Availability Feature</th>\n<th>Implementation</th>\n<th>Recovery Time</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Leader Election</td>\n<td>Raft consensus algorithm</td>\n<td>&lt; 30 seconds failover</td>\n</tr>\n<tr>\n<td>Data Replication</td>\n<td>Write-ahead logging with quorum</td>\n<td>Zero data loss with majority</td>\n</tr>\n<tr>\n<td>Backup and Restore</td>\n<td>Encrypted backup snapshots</td>\n<td>Point-in-time recovery</td>\n</tr>\n<tr>\n<td>Auto-unseal</td>\n<td>Cloud KMS integration</td>\n<td>Automatic startup after restart</td>\n</tr>\n</tbody></table>\n<h3 id=\"non-functional-goals\">Non-Functional Goals</h3>\n<p>These <strong>quality attributes</strong> define how well the system performs its functional capabilities. Non-functional goals often drive architectural decisions more than functional requirements — they determine whether we choose simplicity or performance, consistency or availability.</p>\n<h4 id=\"security-properties\">Security Properties</h4>\n<p>The system must maintain <strong>defense in depth</strong> with multiple security layers protecting against various attack vectors. Security isn&#39;t a feature we add later — it&#39;s a foundational property that influences every design decision.</p>\n<table>\n<thead>\n<tr>\n<th>Security Property</th>\n<th>Target</th>\n<th>Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Encryption at Rest</td>\n<td>AES-256-GCM for all stored data</td>\n<td>No plaintext secrets in storage</td>\n</tr>\n<tr>\n<td>Encryption in Transit</td>\n<td>TLS 1.3 for all client communication</td>\n<td>Certificate validation required</td>\n</tr>\n<tr>\n<td>Authentication</td>\n<td>Multi-factor verification</td>\n<td>Token + certificate validation</td>\n</tr>\n<tr>\n<td>Audit Logging</td>\n<td>Complete access trail</td>\n<td>Every secret operation logged</td>\n</tr>\n<tr>\n<td>Memory Protection</td>\n<td>Clear sensitive data after use</td>\n<td>Zero sensitive data in memory dumps</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The critical security principle here is <strong>assume breach</strong> — design as if attackers will eventually access the storage backend, network traffic, or even application memory. Every protection layer should remain effective even if other layers are compromised.</p>\n</blockquote>\n<h4 id=\"performance-and-scalability\">Performance and Scalability</h4>\n<p>The system must handle production workloads with <strong>predictable latency</strong> and <strong>horizontal scaling</strong> capabilities. Performance goals must be realistic — we&#39;re not building a high-frequency trading system, but we need consistent response times for application startup and credential rotation.</p>\n<table>\n<thead>\n<tr>\n<th>Performance Metric</th>\n<th>Target</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Secret Retrieval Latency</td>\n<td>&lt; 100ms P95</td>\n<td>Acceptable for application startup</td>\n</tr>\n<tr>\n<td>Dynamic Secret Generation</td>\n<td>&lt; 500ms P95</td>\n<td>Database connection establishment time</td>\n</tr>\n<tr>\n<td>Throughput</td>\n<td>1000 requests/second/node</td>\n<td>Supports moderate application load</td>\n</tr>\n<tr>\n<td>Storage Efficiency</td>\n<td>&lt; 10KB overhead per secret</td>\n<td>Reasonable metadata storage cost</td>\n</tr>\n</tbody></table>\n<h4 id=\"operational-simplicity\">Operational Simplicity</h4>\n<p>The system must be <strong>operationally manageable</strong> with clear deployment procedures, monitoring capabilities, and troubleshooting guides. Complex systems that work perfectly in development often fail in production due to operational complexity.</p>\n<table>\n<thead>\n<tr>\n<th>Operational Aspect</th>\n<th>Requirement</th>\n<th>Benefit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single Binary Deployment</td>\n<td>No external runtime dependencies</td>\n<td>Simplified installation and updates</td>\n</tr>\n<tr>\n<td>Configuration Management</td>\n<td>File-based with validation</td>\n<td>Version control and audit trails</td>\n</tr>\n<tr>\n<td>Health Check Endpoints</td>\n<td>HTTP endpoints for load balancers</td>\n<td>Automated health monitoring</td>\n</tr>\n<tr>\n<td>Structured Logging</td>\n<td>JSON format with correlation IDs</td>\n<td>Centralized log aggregation</td>\n</tr>\n<tr>\n<td>Metrics Export</td>\n<td>Prometheus-compatible metrics</td>\n<td>Performance monitoring and alerting</td>\n</tr>\n</tbody></table>\n<h3 id=\"explicit-non-goals\">Explicit Non-Goals</h3>\n<p>These are <strong>intentional limitations</strong> we accept to maintain focus and avoid over-engineering. Explicitly stating what we won&#39;t build is as important as defining what we will build — it prevents feature creep and keeps the implementation manageable.</p>\n<h4 id=\"enterprise-features-out-of-scope\">Enterprise Features (Out of Scope)</h4>\n<p>We deliberately exclude enterprise-grade features that add significant complexity without providing core value for the learning objectives.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Feature</th>\n<th>Rationale</th>\n<th>Alternative</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Multi-tenancy</td>\n<td>Adds namespace isolation complexity</td>\n<td>Deploy separate instances per tenant</td>\n</tr>\n<tr>\n<td>LDAP/Active Directory</td>\n<td>Complex integration with legacy systems</td>\n<td>Focus on token and certificate auth</td>\n</tr>\n<tr>\n<td>Hardware Security Modules</td>\n<td>Requires specialized hardware</td>\n<td>Use cloud KMS for production</td>\n</tr>\n<tr>\n<td>GUI/Web Interface</td>\n<td>Frontend development outside scope</td>\n<td>CLI and REST API provide full functionality</td>\n</tr>\n<tr>\n<td>Plugin Architecture</td>\n<td>Dynamic loading adds security and complexity</td>\n<td>Built-in backends only</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: No Plugin Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Extensibility through plugins versus built-in secret backends</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Dynamic plugin loading with shared libraries</li>\n<li>Compile-time plugin registration</li>\n<li>Fixed set of built-in backends</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Built-in backends only (database, cloud providers)</li>\n<li><strong>Rationale</strong>: Avoids security risks of dynamic code loading, reduces operational complexity, sufficient for learning objectives</li>\n<li><strong>Consequences</strong>: Less extensible but more secure and simpler to operate</li>\n</ul>\n</blockquote>\n<h4 id=\"advanced-cryptographic-features\">Advanced Cryptographic Features</h4>\n<p>We focus on proven, standard cryptographic primitives rather than implementing cutting-edge or specialized crypto features.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Crypto Feature</th>\n<th>Rationale</th>\n<th>Standard Alternative</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Zero-Knowledge Proofs</td>\n<td>Complex math, limited practical benefit</td>\n<td>Standard authentication tokens</td>\n</tr>\n<tr>\n<td>Homomorphic Encryption</td>\n<td>Academic complexity, performance issues</td>\n<td>Decrypt for processing</td>\n</tr>\n<tr>\n<td>Custom Cipher Implementations</td>\n<td>High risk of implementation bugs</td>\n<td>Standard library AES-GCM</td>\n</tr>\n<tr>\n<td>Post-Quantum Cryptography</td>\n<td>Standards still evolving</td>\n<td>Current NIST recommendations</td>\n</tr>\n</tbody></table>\n<h4 id=\"performance-optimization-deferred\">Performance Optimization (Deferred)</h4>\n<p>We prioritize correctness and security over extreme performance optimization. A working, secure system is more valuable than a fast, broken one.</p>\n<table>\n<thead>\n<tr>\n<th>Optimization Not Implemented</th>\n<th>Rationale</th>\n<th>Acceptable Trade-off</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection Pooling</td>\n<td>Adds complexity to backend implementations</td>\n<td>Slight performance overhead acceptable</td>\n</tr>\n<tr>\n<td>Caching Layer</td>\n<td>Cache invalidation and consistency challenges</td>\n<td>Acceptable latency increase</td>\n</tr>\n<tr>\n<td>Horizontal Sharding</td>\n<td>Distributed system complexity</td>\n<td>Single cluster handles target load</td>\n</tr>\n<tr>\n<td>Async Processing</td>\n<td>Complicates error handling and consistency</td>\n<td>Synchronous operations simpler</td>\n</tr>\n</tbody></table>\n<h4 id=\"cloud-specific-features\">Cloud-Specific Features</h4>\n<p>We build a cloud-agnostic system rather than optimizing for specific cloud provider features.</p>\n<table>\n<thead>\n<tr>\n<th>Cloud Feature</th>\n<th>Exclusion Reason</th>\n<th>Generic Alternative</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AWS IAM Integration</td>\n<td>Vendor lock-in, complex permission mapping</td>\n<td>Generic token authentication</td>\n</tr>\n<tr>\n<td>GCP Service Accounts</td>\n<td>Platform-specific authentication flow</td>\n<td>Mutual TLS certificates</td>\n</tr>\n<tr>\n<td>Azure Key Vault</td>\n<td>Managed service, reduces learning value</td>\n<td>Self-managed encryption</td>\n</tr>\n<tr>\n<td>Kubernetes Secrets</td>\n<td>Platform coupling, different security model</td>\n<td>HTTP API works with any orchestrator</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The philosophy here is <strong>build once, deploy anywhere</strong>. While cloud-native features provide operational benefits, they couple the system to specific platforms and reduce the educational value of implementing core secret management concepts.</p>\n</blockquote>\n<h3 id=\"success-criteria-and-validation\">Success Criteria and Validation</h3>\n<p>To ensure we meet our goals, we define <strong>measurable success criteria</strong> for each functional goal and <strong>validation procedures</strong> to verify achievement.</p>\n<table>\n<thead>\n<tr>\n<th>Goal Category</th>\n<th>Success Metric</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Security</td>\n<td>All secrets encrypted with AES-256-GCM</td>\n<td>Audit storage backend for plaintext</td>\n</tr>\n<tr>\n<td>Access Control</td>\n<td>Policy violations return 403 Forbidden</td>\n<td>Attempt unauthorized secret access</td>\n</tr>\n<tr>\n<td>Dynamic Secrets</td>\n<td>Database credentials expire within TTL</td>\n<td>Monitor external system user tables</td>\n</tr>\n<tr>\n<td>High Availability</td>\n<td>&lt; 30 second failover during leader failure</td>\n<td>Kill leader node, measure recovery time</td>\n</tr>\n<tr>\n<td>Performance</td>\n<td>Secret retrieval under 100ms P95</td>\n<td>Load testing with realistic workloads</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This guidance helps translate our high-level goals into concrete development tasks and validation steps.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP Server</td>\n<td><code>net/http</code> with middleware</td>\n<td><code>gin-gonic/gin</code> framework</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td><code>encoding/json</code> with structs</td>\n<td><code>spf13/viper</code> with validation</td>\n</tr>\n<tr>\n<td>Database Backend</td>\n<td><code>database/sql</code> with SQLite</td>\n<td>PostgreSQL with connection pooling</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>Standard <code>testing</code> package</td>\n<td><code>stretchr/testify</code> with assertions</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard <code>log/slog</code> package</td>\n<td><code>uber-go/zap</code> structured logging</td>\n</tr>\n</tbody></table>\n<h4 id=\"goal-validation-checklist\">Goal Validation Checklist</h4>\n<p>Use this checklist after each milestone to verify you&#39;re meeting the established goals:</p>\n<p><strong>Milestone 1 Validation (Encrypted Storage):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Verify encryption at rest</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/encryption</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check no plaintext in storage</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\"> vault.db</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> \"expected_metadata\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -20</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show only encrypted binary data, no readable secrets</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Validation (Access Control):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test unauthorized access returns 403</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -k</span><span style=\"color:#9ECBFF\"> https://localhost:8443/v1/secrets/test</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should return: {\"error\": \"missing or invalid token\"}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test policy enforcement</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -k</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"X-Vault-Token: invalid\"</span><span style=\"color:#9ECBFF\"> https://localhost:8443/v1/secrets/test</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should return: {\"error\": \"permission denied\"}</span></span></code></pre></div>\n\n<p><strong>Milestone 3 Validation (Dynamic Secrets):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Generate database credentials</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -k</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"X-Vault-Token: </span><span style=\"color:#E1E4E8\">$ROOT_TOKEN</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  https://localhost:8443/v1/database/creds/my-role</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should return: {\"username\": \"v-root-my-role-XYZ\", \"password\": \"...\", \"lease_id\": \"...\"}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify TTL enforcement (wait for expiration)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check that generated user is removed from database</span></span></code></pre></div>\n\n<p><strong>Milestone 4 Validation (High Availability):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test unsealing with key shares</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./vault</span><span style=\"color:#9ECBFF\"> operator</span><span style=\"color:#9ECBFF\"> unseal</span><span style=\"color:#E1E4E8\"> $SHARE_1</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./vault</span><span style=\"color:#9ECBFF\"> operator</span><span style=\"color:#9ECBFF\"> unseal</span><span style=\"color:#E1E4E8\"> $SHARE_2  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./vault</span><span style=\"color:#9ECBFF\"> operator</span><span style=\"color:#9ECBFF\"> unseal</span><span style=\"color:#E1E4E8\"> $SHARE_3</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should transition from sealed to active state</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test failover (requires multi-node setup)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Kill leader, verify standby promotion within 30 seconds</span></span></code></pre></div>\n\n<h4 id=\"common-implementation-pitfalls\">Common Implementation Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Scope Creep During Development</strong>\nIt&#39;s tempting to add &quot;just one more feature&quot; when you see how easy it would be to implement. Resist this urge — every additional feature adds complexity, testing overhead, and potential security vulnerabilities. Stick to the defined functional goals and defer enhancements until the core system is solid.</p>\n<p>⚠️ <strong>Pitfall: Premature Performance Optimization</strong><br>Don&#39;t implement caching, connection pooling, or async processing until you&#39;ve measured actual performance problems. These optimizations add complexity that makes debugging harder and often introduce subtle bugs. Build a correct, simple system first, then optimize specific bottlenecks with measurement data.</p>\n<p>⚠️ <strong>Pitfall: Security Theater vs. Real Security</strong>\nAvoid implementing security features that look impressive but don&#39;t address real threats. For example, custom encryption algorithms or complex authentication schemes often introduce vulnerabilities. Focus on proven security practices: standard crypto libraries, defense in depth, and comprehensive audit logging.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Operational Requirements</strong>\nA system that works perfectly on your laptop but requires complex deployment procedures will fail in production. Design for operations from the beginning: single binary deployment, clear configuration, health checks, and structured logging. These aren&#39;t &quot;nice to have&quot; features — they&#39;re essential for any production system.</p>\n<h4 id=\"file-structure-for-goal-driven-development\">File Structure for Goal-Driven Development</h4>\n<p>Organize your code to reflect the functional goals, making it easy to work on one capability at a time:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>vault-system/\n├── cmd/vault/main.go              ← Single binary entry point\n├── internal/\n│   ├── server/                    ← HTTP server and routing (Goal: API access)\n│   │   ├── server.go\n│   │   └── handlers.go\n│   ├── encryption/                ← Encryption engine (Goal: Secure storage)\n│   │   ├── envelope.go\n│   │   └── rotation.go\n│   ├── auth/                      ← Authentication system (Goal: Access control)\n│   │   ├── tokens.go\n│   │   └── policies.go\n│   ├── dynamic/                   ← Dynamic secrets (Goal: Credential generation)\n│   │   ├── database.go\n│   │   └── leases.go\n│   ├── unsealing/                 ← HA and unsealing (Goal: Availability)\n│   │   ├── shamir.go\n│   │   └── consensus.go\n│   └── storage/                   ← Storage backends\n│       └── backend.go\n├── configs/                       ← Configuration examples\n│   └── vault.json\n└── docs/                         ← Goal validation procedures\n    └── testing.md</code></pre></div>\n\n<p>This structure makes it clear which code relates to which functional goal, enabling focused development and easier validation of individual capabilities.</p>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides the architectural foundation for all four milestones, establishing the component structure and security boundaries that will guide implementation across encrypted storage (Milestone 1), access control (Milestone 2), dynamic secrets (Milestone 3), and high availability (Milestone 4).</p>\n</blockquote>\n<p>The high-level architecture of our secret management system follows a <strong>defense in depth</strong> security model, where multiple layers of protection work together to create a <strong>zero-trust system</strong>. Think of it like a modern bank: the vault has multiple independent security systems (cameras, motion sensors, time locks, armed guards), and each system can detect different types of threats. If one system fails, the others continue protecting the assets.</p>\n<p>Our secret management system employs the same principle with four distinct subsystems, each responsible for a specific aspect of security. The encryption engine ensures that even if someone gains access to the storage, they cannot read the secrets. The authentication and authorization engine ensures that only verified identities with proper permissions can access secrets. The dynamic secret engine minimizes exposure by generating short-lived credentials. The unsealing mechanism ensures that the system cannot operate without human authorization, preventing automated attacks.</p>\n<h3 id=\"component-overview\">Component Overview</h3>\n<p>The secret management system is built around four main subsystems that work together to provide comprehensive secret protection. Each subsystem has clear responsibilities and operates with minimal trust assumptions about the others.</p>\n<p><strong>The Four Core Subsystems:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Subsystem</th>\n<th>Primary Responsibility</th>\n<th>Security Purpose</th>\n<th>Data Owned</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>API Server</td>\n<td>HTTP request handling and routing</td>\n<td>Entry point validation and protocol termination</td>\n<td>Request/response formatting, TLS certificates</td>\n</tr>\n<tr>\n<td>Encryption Engine</td>\n<td>Secret encryption, decryption, and key management</td>\n<td>Confidentiality and integrity of stored data</td>\n<td>Master keys, data encryption keys, encrypted secrets</td>\n</tr>\n<tr>\n<td>Authentication &amp; Authorization Engine</td>\n<td>Identity verification and policy enforcement</td>\n<td>Access control and audit trail</td>\n<td>Policies, tokens, identity mappings, audit logs</td>\n</tr>\n<tr>\n<td>Storage Backend</td>\n<td>Persistent data storage and retrieval</td>\n<td>Durability and consistency of encrypted data</td>\n<td>Raw encrypted data, metadata, configuration</td>\n</tr>\n</tbody></table>\n<p>Think of these subsystems like the departments in a secure facility. The <strong>API Server</strong> is like the front desk—it receives all requests, verifies that visitors are following proper protocols, and routes them to the appropriate department. It doesn&#39;t make security decisions but ensures that all communication follows established procedures.</p>\n<p>The <strong>Encryption Engine</strong> is like the vault mechanism itself—it knows how to lock and unlock the safes, manages the combination codes, and ensures that anything stored is properly secured. It never decides who can access what, but it guarantees that unauthorized access is impossible even if someone breaks into the storage room.</p>\n<p>The <strong>Authentication &amp; Authorization Engine</strong> is like the security department—it maintains the list of authorized personnel, checks credentials, and decides whether each person should have access to specific areas. It creates audit trails but doesn&#39;t handle the actual storage or encryption of assets.</p>\n<p>The <strong>Storage Backend</strong> is like the physical infrastructure—the walls, floors, and filing systems that hold everything. It provides reliable storage but doesn&#39;t understand what it&#39;s storing or who should access it.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: This separation follows the principle of <strong>single responsibility</strong> at the subsystem level. Each component can be secured, tested, and potentially replaced independently. For example, we could swap from a local file storage backend to a distributed database without changing the encryption or authorization logic.</p>\n</blockquote>\n<p><strong>Detailed Component Responsibilities:</strong></p>\n<p>The <strong>API Server</strong> subsystem handles all external communication and protocol concerns. It terminates TLS connections, parses HTTP requests, validates request formats, and serializes responses. This component implements rate limiting, request logging, and connection management. It routes authenticated requests to appropriate internal subsystems but never accesses secret data directly. The API server also handles the system&#39;s sealed/unsealed state, rejecting most operations when the system is sealed.</p>\n<p>The <strong>Encryption Engine</strong> subsystem manages all cryptographic operations using <strong>envelope encryption</strong>. It maintains the master key hierarchy, generates and rotates data encryption keys, and performs AES-256-GCM encryption/decryption operations. This component handles secret versioning, allowing multiple versions of the same secret path to coexist during key rotation. It also manages secure memory operations, ensuring that plaintext secrets and encryption keys are properly zeroed after use.</p>\n<p>The <strong>Authentication &amp; Authorization Engine</strong> subsystem implements a complete identity and access management system. It supports multiple authentication methods (tokens, mutual TLS, AppRole), maintains policy definitions with path-based access control, and evaluates authorization requests. This component generates and validates access tokens, maintains session state, and produces comprehensive audit logs. It implements the policy evaluation engine that matches requests against defined rules.</p>\n<p>The <strong>Storage Backend</strong> subsystem provides persistent, reliable storage for all system data. It stores encrypted secrets, policy definitions, token metadata, and system configuration. This component handles atomic operations, consistency guarantees, and backup/restore functionality. It implements key-value storage with support for transactions and range queries needed by higher-level components.</p>\n<blockquote>\n<p><strong>Decision: Component Communication Model</strong></p>\n<ul>\n<li><strong>Context</strong>: The four subsystems need to communicate reliably while maintaining security boundaries and enabling independent testing.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Direct function calls within a monolithic process</li>\n<li>Message passing through internal channels</li>\n<li>Internal API calls over localhost HTTP</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Direct function calls with well-defined interfaces</li>\n<li><strong>Rationale</strong>: Function calls provide the lowest latency and highest reliability for internal communication. They enable atomic operations across subsystems and simplify error handling. Interface-based design still allows for independent testing through mocking.</li>\n<li><strong>Consequences</strong>: All subsystems must run in the same process, but we gain performance and transactional consistency. Future scaling would require refactoring to a distributed model.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Communication Option</th>\n<th>Latency</th>\n<th>Reliability</th>\n<th>Testability</th>\n<th>Complexity</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Direct function calls</td>\n<td>Lowest</td>\n<td>Highest</td>\n<td>Good (mockable interfaces)</td>\n<td>Low</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>Message passing</td>\n<td>Medium</td>\n<td>Good</td>\n<td>Excellent</td>\n<td>Medium</td>\n<td>✗</td>\n</tr>\n<tr>\n<td>Internal HTTP</td>\n<td>Highest</td>\n<td>Medium</td>\n<td>Excellent</td>\n<td>High</td>\n<td>✗</td>\n</tr>\n</tbody></table>\n<h3 id=\"security-boundaries\">Security Boundaries</h3>\n<p>The secret management system implements multiple security boundaries to create <strong>defense in depth</strong>. Think of these boundaries like the security zones in a government facility—each zone has different clearance requirements, and moving between zones requires additional verification. Even if an attacker compromises one zone, they still cannot access resources in higher-security zones.</p>\n<p><strong>Trust Zones and Privilege Separation:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Trust Zone</th>\n<th>Components</th>\n<th>Data Access</th>\n<th>Privilege Level</th>\n<th>Threat Model</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>External Zone</td>\n<td>Client applications, operators</td>\n<td>None (encrypted requests only)</td>\n<td>No privileges</td>\n<td>Untrusted network, compromised clients</td>\n</tr>\n<tr>\n<td>API Boundary</td>\n<td>API Server, TLS termination</td>\n<td>Request metadata, routing info</td>\n<td>Limited (protocol handling)</td>\n<td>Network attacks, protocol exploits</td>\n</tr>\n<tr>\n<td>Application Zone</td>\n<td>Auth Engine, API routing</td>\n<td>Policies, tokens, encrypted secrets</td>\n<td>Medium (business logic)</td>\n<td>Logic bugs, injection attacks</td>\n</tr>\n<tr>\n<td>Cryptographic Zone</td>\n<td>Encryption Engine</td>\n<td>Plaintext secrets, encryption keys</td>\n<td>Highest (key material)</td>\n<td>Memory dumps, side-channel attacks</td>\n</tr>\n<tr>\n<td>Storage Zone</td>\n<td>Storage Backend</td>\n<td>Raw encrypted data only</td>\n<td>Low (persistence only)</td>\n<td>Storage compromise, backup theft</td>\n</tr>\n</tbody></table>\n<p>The <strong>External Zone</strong> represents completely untrusted territory. Client applications, even those with valid credentials, operate in this zone. All communication crosses the network and is assumed to be observable by attackers. Clients receive only encrypted responses and must prove their identity for every request.</p>\n<p>The <strong>API Boundary</strong> is the first line of defense within the system. The API Server component operates here, handling TLS termination and basic request validation. This component can see request metadata and routing information but never accesses plaintext secrets. It implements rate limiting and basic attack detection, protecting the inner zones from malicious or malformed requests.</p>\n<p>The <strong>Application Zone</strong> contains the business logic components: the Authentication &amp; Authorization Engine and API request routing. Components in this zone can access policy information, token metadata, and encrypted secret data, but they cannot decrypt secrets without coordinating with the Cryptographic Zone. This separation ensures that authorization bugs cannot directly expose plaintext secret data.</p>\n<p>The <strong>Cryptographic Zone</strong> represents the highest privilege level within the system. Only the Encryption Engine operates here, and it has access to master keys and can produce plaintext secrets. This component uses secure memory handling, implements constant-time operations where appropriate, and minimizes the lifetime of plaintext data in memory.</p>\n<p>The <strong>Storage Zone</strong> operates with intentionally limited privileges. The Storage Backend can persist and retrieve data but cannot interpret the encrypted contents. This ensures that storage compromise or backup theft cannot directly expose secret values—the attacker would also need access to the encryption keys from the Cryptographic Zone.</p>\n<p><strong>Inter-Zone Communication Security:</strong></p>\n<p>Communication between zones follows strict protocols designed to minimize privilege escalation risks. The API Server validates all external requests before forwarding them to internal components. The Authentication Engine verifies identity and authorization before allowing any secret access. The Encryption Engine only decrypts secrets after receiving valid authorization tokens from the Authentication Engine.</p>\n<blockquote>\n<p><strong>Critical Security Principle</strong>: <strong>Assume breach</strong> at every boundary. Each zone assumes that external zones may be compromised and implements defenses accordingly. The Encryption Engine assumes that API requests might be forged, so it requires cryptographically signed authorization tokens. The Storage Backend assumes that application logic might be compromised, so it never stores plaintext data.</p>\n</blockquote>\n<p><strong>Memory Protection and Data Handling:</strong></p>\n<p>Within each zone, components implement appropriate data protection measures. The Cryptographic Zone uses secure memory allocation and explicit zeroing of sensitive data. The Application Zone implements constant-time comparison for token validation to prevent timing attacks. The Storage Zone ensures that temporary buffers used for I/O operations are cleared after use.</p>\n<table>\n<thead>\n<tr>\n<th>Security Boundary</th>\n<th>Protection Mechanism</th>\n<th>Attack Prevention</th>\n<th>Recovery Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network boundary</td>\n<td>Mutual TLS, certificate validation</td>\n<td>Man-in-the-middle, eavesdropping</td>\n<td>Certificate rotation, connection retry</td>\n</tr>\n<tr>\n<td>Process boundary</td>\n<td>Memory isolation, secure allocation</td>\n<td>Memory dumps, cross-process access</td>\n<td>Process restart, memory encryption</td>\n</tr>\n<tr>\n<td>Component boundary</td>\n<td>Interface contracts, input validation</td>\n<td>Injection, privilege escalation</td>\n<td>Component isolation, audit logging</td>\n</tr>\n<tr>\n<td>Storage boundary</td>\n<td>Encryption at rest, access controls</td>\n<td>Storage compromise, backup theft</td>\n<td>Key rotation, encrypted backups</td>\n</tr>\n</tbody></table>\n<h3 id=\"deployment-topology\">Deployment Topology</h3>\n<p>The secret management system supports multiple deployment topologies to balance security, availability, and operational requirements. The architecture accommodates everything from single-node development environments to highly available production clusters with geographic distribution.</p>\n<p><strong>Single Node Deployment:</strong></p>\n<p>For development and small-scale production environments, all four subsystems run within a single process on one machine. Think of this like a small bank branch where one building contains the vault, teller windows, security office, and records storage. Everything is co-located, which simplifies operations but creates a single point of failure.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Process Location</th>\n<th>Data Storage</th>\n<th>Network Access</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>API Server</td>\n<td>Main process (port 8443)</td>\n<td>None (stateless)</td>\n<td>External clients</td>\n</tr>\n<tr>\n<td>Encryption Engine</td>\n<td>Main process (in-memory)</td>\n<td>Local file system</td>\n<td>Internal only</td>\n</tr>\n<tr>\n<td>Auth &amp; Policy Engine</td>\n<td>Main process (in-memory)</td>\n<td>Local file system</td>\n<td>Internal only</td>\n</tr>\n<tr>\n<td>Storage Backend</td>\n<td>Main process (file I/O)</td>\n<td>Local disk (encrypted)</td>\n<td>Internal only</td>\n</tr>\n</tbody></table>\n<p>The single-node deployment stores the master key on local disk, protected by file system permissions and encryption. Secret data, policies, and audit logs are stored as encrypted files in a configurable directory structure. This topology provides the simplest operational model but requires careful backup procedures since all system state exists on one machine.</p>\n<p><strong>High Availability Cluster Deployment:</strong></p>\n<p>For production environments requiring high availability, the system can operate as a cluster with multiple nodes. This resembles a banking network where multiple branches can serve customers, but they coordinate through a central system to maintain consistency. One node acts as the active leader while others remain on standby, ready to take over if the leader fails.</p>\n<table>\n<thead>\n<tr>\n<th>Node Role</th>\n<th>Active Components</th>\n<th>Data Replication</th>\n<th>Client Access</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Leader</td>\n<td>All four subsystems</td>\n<td>Writes to storage, replicates to followers</td>\n<td>Serves all requests</td>\n</tr>\n<tr>\n<td>Follower</td>\n<td>Storage Backend, limited API Server</td>\n<td>Receives replicated data</td>\n<td>Read-only operations (optional)</td>\n</tr>\n<tr>\n<td>Standby</td>\n<td>All subsystems (inactive)</td>\n<td>Maintains current state</td>\n<td>No client access</td>\n</tr>\n</tbody></table>\n<p>The high availability deployment uses a <strong>consensus protocol</strong> to coordinate between nodes and ensure that only one leader is active at a time. This prevents <strong>split-brain scenarios</strong> where multiple nodes might accept conflicting write operations. The leader performs all cryptographic operations and policy decisions, while follower nodes maintain synchronized copies of the encrypted data.</p>\n<blockquote>\n<p><strong>Decision: Leader-Follower vs Active-Active Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: High availability requires coordination between multiple nodes, but secret management has strict consistency requirements.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Active-active with conflict resolution</li>\n<li>Leader-follower with automatic failover</li>\n<li>Manual failover with cold standby</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Leader-follower with automatic failover</li>\n<li><strong>Rationale</strong>: Secret management requires strict consistency—conflicting policy changes or overlapping dynamic secret generation could create security vulnerabilities. Leader-follower ensures linearizable operations while still providing automatic recovery.</li>\n<li><strong>Consequences</strong>: Write operations are limited to leader capacity, but we maintain consistency guarantees and enable automated failover.</li>\n</ul>\n</blockquote>\n<p><strong>Network Architecture and Client Routing:</strong></p>\n<p>Clients connect to the cluster through a <strong>load balancer</strong> or <strong>service discovery mechanism</strong> that routes requests to the current leader. The load balancer performs health checks to detect leader changes and automatically redirects traffic during failover events. Follower nodes can optionally serve read-only requests for policies and audit logs, reducing load on the leader.</p>\n<table>\n<thead>\n<tr>\n<th>Traffic Type</th>\n<th>Routing Strategy</th>\n<th>Consistency Level</th>\n<th>Failover Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Secret read/write</td>\n<td>Leader only</td>\n<td>Strict consistency</td>\n<td>Redirect to new leader</td>\n</tr>\n<tr>\n<td>Policy evaluation</td>\n<td>Leader preferred, follower acceptable</td>\n<td>Eventually consistent</td>\n<td>Best-effort routing</td>\n</tr>\n<tr>\n<td>Audit log queries</td>\n<td>Any node</td>\n<td>Eventually consistent</td>\n<td>Round-robin distribution</td>\n</tr>\n<tr>\n<td>Health checks</td>\n<td>All nodes</td>\n<td>Local state</td>\n<td>Per-node response</td>\n</tr>\n</tbody></table>\n<p>The network topology implements <strong>defense in depth</strong> at the infrastructure level. All inter-node communication uses mutual TLS with node-specific certificates. Client connections require valid certificates and are rate-limited per identity. Network segmentation isolates the secret management cluster from other systems, with firewall rules allowing only necessary ports.</p>\n<p><strong>Data Distribution and Replication:</strong></p>\n<p>The cluster maintains <strong>strong consistency</strong> for critical data while allowing <strong>eventual consistency</strong> for less sensitive information. Secret data, policies, and encryption keys are replicated synchronously to ensure that failover doesn&#39;t lose recent changes. Audit logs and configuration data can be replicated asynchronously to improve write performance.</p>\n<table>\n<thead>\n<tr>\n<th>Data Type</th>\n<th>Replication Mode</th>\n<th>Consistency Requirement</th>\n<th>Storage Location</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Secrets (encrypted)</td>\n<td>Synchronous</td>\n<td>Strong consistency</td>\n<td>Leader + all followers</td>\n</tr>\n<tr>\n<td>Encryption keys</td>\n<td>Synchronous</td>\n<td>Strong consistency</td>\n<td>Leader + all followers</td>\n</tr>\n<tr>\n<td>Policies</td>\n<td>Synchronous</td>\n<td>Strong consistency</td>\n<td>Leader + all followers</td>\n</tr>\n<tr>\n<td>Tokens/sessions</td>\n<td>Synchronous</td>\n<td>Strong consistency</td>\n<td>Leader + all followers</td>\n</tr>\n<tr>\n<td>Audit logs</td>\n<td>Asynchronous</td>\n<td>Eventually consistent</td>\n<td>All nodes + external system</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>Asynchronous</td>\n<td>Eventually consistent</td>\n<td>All nodes</td>\n</tr>\n</tbody></table>\n<p><strong>Disaster Recovery and Backup Strategy:</strong></p>\n<p>The deployment topology supports multiple levels of backup and recovery. Regular <strong>encrypted backups</strong> capture the complete system state, including all secrets, policies, and configuration. These backups are encrypted with separate keys and stored in geographically distributed locations. For critical environments, <strong>cross-region replication</strong> maintains live copies of the data in multiple data centers.</p>\n<p>The <strong>unsealing process</strong> is designed to work with the distributed topology. Shamir&#39;s secret sharing key shares are distributed among multiple operators across different locations. During disaster recovery, operators can unseal a restored cluster without requiring access to the original master key material, since the key is reconstructed from the distributed shares.</p>\n<blockquote>\n<p><strong>Operational Insight</strong>: The deployment topology directly impacts the unsealing workflow. In a single-node deployment, all key shares might be held by operators in one location. In a distributed deployment, key shares should be distributed geographically to ensure that natural disasters or regional outages don&#39;t prevent unsealing operations.</p>\n</blockquote>\n<p><strong>Scaling Characteristics and Resource Requirements:</strong></p>\n<p>Different deployment topologies have distinct scaling characteristics and resource requirements. The single-node deployment scales vertically by adding CPU and memory to handle more concurrent requests. The cluster deployment scales primarily through read replicas, since write operations are constrained by the leader&#39;s capacity and the consensus protocol overhead.</p>\n<table>\n<thead>\n<tr>\n<th>Deployment Type</th>\n<th>CPU Utilization</th>\n<th>Memory Requirements</th>\n<th>Storage I/O</th>\n<th>Network Bandwidth</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single node</td>\n<td>Moderate (all operations)</td>\n<td>High (in-memory caching)</td>\n<td>High (all writes local)</td>\n<td>Low (no replication)</td>\n</tr>\n<tr>\n<td>HA leader</td>\n<td>High (all write operations)</td>\n<td>High (in-memory state)</td>\n<td>High (writes + replication)</td>\n<td>High (replication traffic)</td>\n</tr>\n<tr>\n<td>HA follower</td>\n<td>Low (replication only)</td>\n<td>Medium (replicated state)</td>\n<td>Medium (replicated writes)</td>\n<td>Medium (replication inbound)</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The high-level architecture maps to a modular Go codebase that separates concerns while enabling efficient communication between subsystems. Each subsystem is implemented as a separate package with well-defined interfaces, making the system testable and maintainable.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP Server</td>\n<td>net/http with gorilla/mux routing</td>\n<td>Custom HTTP/2 server with connection pooling</td>\n</tr>\n<tr>\n<td>Storage Backend</td>\n<td>Local JSON files with file locking</td>\n<td>Distributed key-value store (etcd, Consul)</td>\n</tr>\n<tr>\n<td>Cryptography</td>\n<td>Go crypto/aes and crypto/rand</td>\n<td>Hardware security module (HSM) integration</td>\n</tr>\n<tr>\n<td>Clustering</td>\n<td>Single node with file persistence</td>\n<td>Raft consensus with distributed storage</td>\n</tr>\n<tr>\n<td>TLS/Authentication</td>\n<td>Go crypto/tls with static certificates</td>\n<td>Dynamic certificate management with rotation</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>YAML files with validation</td>\n<td>Dynamic configuration with hot reloading</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<p>The codebase follows Go&#39;s standard project layout with clear separation between public APIs, internal implementation, and supporting tools:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>secret-vault/\n├── cmd/\n│   ├── server/\n│   │   └── main.go              ← Server entry point, configuration loading\n│   └── cli/\n│       └── main.go              ← Client CLI tool for operators\n├── internal/\n│   ├── server/\n│   │   ├── server.go            ← SecretServer implementation\n│   │   └── config.go            ← ServerConfig and LoadConfig\n│   ├── api/\n│   │   ├── handlers.go          ← HTTP request handlers\n│   │   ├── middleware.go        ← Authentication, logging middleware\n│   │   └── routes.go            ← Route definitions and registration\n│   ├── encryption/\n│   │   ├── engine.go            ← Envelope encryption implementation\n│   │   ├── keys.go              ← Key generation and rotation\n│   │   └── versioning.go        ← Secret version management\n│   ├── auth/\n│   │   ├── engine.go            ← Authentication and authorization\n│   │   ├── policies.go          ← Policy definition and evaluation\n│   │   ├── tokens.go            ← Token generation and validation\n│   │   └── audit.go             ← Audit logging\n│   ├── storage/\n│   │   ├── backend.go           ← Storage interface definition\n│   │   ├── file.go              ← File-based storage implementation\n│   │   └── memory.go            ← In-memory storage for testing\n│   ├── dynamic/\n│   │   ├── engine.go            ← Dynamic secret generation\n│   │   ├── database.go          ← Database credential backend\n│   │   └── leases.go            ← Lease management and TTL tracking\n│   └── unseal/\n│       ├── shamir.go            ← Shamir's secret sharing\n│       ├── seal.go              ← Seal/unseal operations\n│       └── ha.go                ← High availability and consensus\n├── pkg/\n│   └── client/\n│       └── client.go            ← Go client library for applications\n├── configs/\n│   ├── dev.yaml                 ← Development configuration\n│   └── prod.yaml               ← Production configuration template\n└── scripts/\n    ├── generate-certs.sh        ← TLS certificate generation\n    └── init-cluster.sh          ← Cluster initialization</code></pre></div>\n\n<p><strong>Core Configuration Structure:</strong></p>\n<p>The system configuration uses a hierarchical structure that maps to the component architecture:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ServerConfig holds all configuration for the secret management server</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ServerConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Server     </span><span style=\"color:#B392F0\">ServerSettings</span><span style=\"color:#9ECBFF\">     `yaml:\"server\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Storage    </span><span style=\"color:#B392F0\">StorageSettings</span><span style=\"color:#9ECBFF\">    `yaml:\"storage\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Encryption </span><span style=\"color:#B392F0\">EncryptionSettings</span><span style=\"color:#9ECBFF\"> `yaml:\"encryption\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Auth       </span><span style=\"color:#B392F0\">AuthSettings</span><span style=\"color:#9ECBFF\">       `yaml:\"auth\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cluster    </span><span style=\"color:#B392F0\">ClusterSettings</span><span style=\"color:#9ECBFF\">    `yaml:\"cluster\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ServerSettings</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Port         </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">           `yaml:\"port\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TLSCertPath  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `yaml:\"tls_cert_path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TLSKeyPath   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `yaml:\"tls_key_path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ReadTimeout  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `yaml:\"read_timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WriteTimeout </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `yaml:\"write_timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StorageSettings</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Backend   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `yaml:\"backend\"`</span><span style=\"color:#6A737D\">  // \"file\", \"memory\", \"etcd\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Config    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"config\"`</span><span style=\"color:#6A737D\">   // Backend-specific settings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BackupDir </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `yaml:\"backup_dir\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EncryptionSettings</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    KeySize      </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `yaml:\"key_size\"`</span><span style=\"color:#6A737D\">      // 256 for AES-256</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MasterKeyPath </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"master_key_path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AutoRotate   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">   `yaml:\"auto_rotate\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AuthSettings</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Methods      []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `yaml:\"methods\"`</span><span style=\"color:#6A737D\">       // [\"token\", \"mtls\", \"approle\"]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TokenTTL     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `yaml:\"token_ttl\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PolicyDir    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `yaml:\"policy_dir\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AuditLogPath </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `yaml:\"audit_log_path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ClusterSettings</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Enabled     </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">     `yaml:\"enabled\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NodeID      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `yaml:\"node_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Peers       []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"peers\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DataDir     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `yaml:\"data_dir\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BindAddress </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `yaml:\"bind_address\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Main Server Implementation Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// SecretServer represents the main secret management server with all subsystems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SecretServer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config      </span><span style=\"color:#B392F0\">ServerConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    httpServer  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Core subsystems - each implemented as a separate component</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storage     </span><span style=\"color:#B392F0\">storage</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Backend</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    encryption  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">encryption</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Engine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    auth        </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">auth</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Engine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dynamic     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">dynamic</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Engine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    unseal      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">unseal</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Server state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    isSealed    </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sealMutex   </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LoadConfig reads and validates configuration from the specified file path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> LoadConfig</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">configPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">ServerConfig</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read YAML file from configPath</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Parse YAML into ServerConfig struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate all required fields are present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Apply default values for optional fields (DEFAULT_PORT, DEFAULT_TIMEOUT)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate that certificate files exist if TLS is enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return validated configuration or descriptive error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewSecretServer creates a new server instance with the provided configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewSecretServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cfg</span><span style=\"color:#B392F0\"> ServerConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretServer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize storage backend based on cfg.Storage.Backend</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create encryption engine with master key from cfg.Encryption</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize auth engine with policy directory from cfg.Auth</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create dynamic secret engine for credential generation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Initialize unseal manager for Shamir's secret sharing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Create HTTP server with TLS configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Register HTTP routes connecting to subsystem handlers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Return configured SecretServer instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Server starts in sealed state - unseal operation required before serving secrets</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Start begins serving HTTP requests on the configured port</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify server is properly configured (all subsystems initialized)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Start background processes (lease renewal, audit log rotation)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Begin listening on configured port with TLS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Log startup message with server version and configuration summary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: Server will reject secret operations until unsealed, but health checks work</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Shutdown gracefully stops the server and cleans up resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Shutdown</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Stop accepting new HTTP connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Wait for existing requests to complete (up to context deadline)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Stop background processes (lease management, audit logging)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Seal the server (clear encryption keys from memory)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Close storage backend and flush any pending writes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return any errors encountered during shutdown</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Subsystem Interface Definitions:</strong></p>\n<p>Each subsystem exposes a clean interface that abstracts its internal complexity:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Storage backend interface - abstracts persistence mechanism</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Backend</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">key</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Put</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">key</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Delete</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">key</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    List</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">prefix</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Transaction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ops</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Operation</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Encryption engine interface - handles all cryptographic operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Engine</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Encrypt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">plaintext</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EncryptedData</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Decrypt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">encrypted</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">EncryptedData</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    RotateKeys</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetKeyVersion</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Authentication engine interface - identity and access control</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Engine</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Authenticate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">credentials</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Identity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Authorize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">identity</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Identity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">action</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CreateToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">identity</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Identity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ttl</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ValidateToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">token</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Identity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Constants and Defaults:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEFAULT_PORT</span><span style=\"color:#F97583\">    =</span><span style=\"color:#79B8FF\"> 8443</span><span style=\"color:#6A737D\">                  // HTTPS port for secret management</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEFAULT_TIMEOUT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second      </span><span style=\"color:#6A737D\">// HTTP request timeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Encryption constants</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AES_KEY_SIZE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#6A737D\">  // 256 bits for AES-256</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    GCM_NONCE_SIZE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#6A737D\">  // 96 bits for AES-GCM</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Authentication constants</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TOKEN_HEADER</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"X-Vault-Token\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEFAULT_TOKEN_TTL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Hour</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Storage constants</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SECRET_PREFIX</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"secret/\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    POLICY_PREFIX</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"policy/\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TOKEN_PREFIX</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"token/\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoints:</strong></p>\n<p>After implementing the basic server structure, verify these behaviors:</p>\n<ol>\n<li><strong>Configuration Loading</strong>: Run <code>go run cmd/server/main.go -config configs/dev.yaml</code> - server should start and log configuration summary</li>\n<li><strong>TLS Endpoint</strong>: Test with <code>curl -k https://localhost:8443/v1/sys/health</code> - should return sealed status</li>\n<li><strong>Component Integration</strong>: Check logs for successful initialization of all four subsystems</li>\n<li><strong>Graceful Shutdown</strong>: Send SIGTERM and verify clean shutdown with resource cleanup</li>\n</ol>\n<p><strong>Language-Specific Implementation Hints:</strong></p>\n<ul>\n<li>Use <code>sync.RWMutex</code> for the sealed state - multiple readers can check seal status concurrently, but unsealing requires exclusive write access</li>\n<li>Implement <code>context.Context</code> support throughout for request timeouts and cancellation</li>\n<li>Use <code>crypto/rand.Reader</code> for all random number generation - never use <code>math/rand</code> for cryptographic operations  </li>\n<li>Store sensitive data in <code>[]byte</code> slices and explicitly zero them with <code>for i := range data { data[i] = 0 }</code> after use</li>\n<li>Use <code>encoding/yaml</code> for configuration parsing with struct tags for validation</li>\n<li>Implement proper error wrapping with <code>fmt.Errorf(&quot;operation failed: %w&quot;, err)</code> for error context</li>\n</ul>\n<p><img src=\"/api/project/secret-management/architecture-doc/asset?path=diagrams%2Fsystem-architecture.svg\" alt=\"System Architecture Overview\"></p>\n<p><img src=\"/api/project/secret-management/architecture-doc/asset?path=diagrams%2Fha-cluster-topology.svg\" alt=\"High Availability Cluster Topology\"></p>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section establishes the core data structures that are implemented across all milestones, with specific focus on encrypted storage (Milestone 1), access control structures (Milestone 2), and dynamic secret management (Milestone 3).</p>\n</blockquote>\n<p>The data model forms the foundational layer of our secret management system, defining how secrets, policies, tokens, and leases are structured, stored, and related to each other. Think of the data model as the <strong>blueprint for a multi-vault bank</strong> - it specifies not just how individual safety deposit boxes (secrets) are constructed, but also how access cards (tokens), security policies, and time-limited access passes (leases) work together to create a comprehensive security system.</p>\n<p>Understanding this data model is crucial because every component of our system - from the encryption engine to the authentication system to the dynamic secret generators - operates on these core data structures. The model must balance security requirements (encrypted storage, access control) with operational needs (versioning, auditing, high availability) while maintaining the flexibility to support different types of secrets and backends.</p>\n<p><img src=\"/api/project/secret-management/architecture-doc/asset?path=diagrams%2Fdata-model-relationships.svg\" alt=\"Data Model Relationships\"></p>\n<h3 id=\"secret-storage-model\">Secret Storage Model</h3>\n<p>The secret storage model defines how secrets are versioned, encrypted, and persisted in our system. This model must address the fundamental challenge of <strong>envelope encryption</strong> while supporting secret versioning for operational safety and key rotation scenarios.</p>\n<h4 id=\"mental-model-the-nested-safe-system\">Mental Model: The Nested Safe System</h4>\n<p>Think of our secret storage like a <strong>high-security bank with nested safes</strong>. The bank has a master vault (master key) that protects individual safety deposit boxes (data encryption keys), and each safety deposit box contains multiple versions of a customer&#39;s valuables (secret versions). When a customer wants to access their valuables, the bank uses its master key to open the safety deposit box, retrieves the individual container key (data encryption key), and then uses that key to unlock the specific version of the valuables they need.</p>\n<p>This nested approach means that even if someone gains access to the encrypted safety deposit box contents, they still can&#39;t read the valuables without the master vault key. Similarly, if the master key needs to be changed (key rotation), the bank can re-encrypt all the safety deposit box keys without touching each individual valuable.</p>\n<h4 id=\"secret-entity-structure\">Secret Entity Structure</h4>\n<p>The <code>Secret</code> entity represents a logical secret path with all its versions and metadata. Each secret acts as a container for multiple encrypted versions, supporting both operational rollbacks and zero-downtime key rotation.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Path</code></td>\n<td><code>string</code></td>\n<td>Unique secret identifier (e.g., &quot;database/prod/password&quot;)</td>\n</tr>\n<tr>\n<td><code>Versions</code></td>\n<td><code>[]SecretVersion</code></td>\n<td>Ordered list of secret versions, newest first</td>\n</tr>\n<tr>\n<td><code>CurrentVersion</code></td>\n<td><code>int</code></td>\n<td>Version number of the active secret value</td>\n</tr>\n<tr>\n<td><code>MaxVersions</code></td>\n<td><code>int</code></td>\n<td>Maximum versions to retain (older versions auto-pruned)</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Timestamp when secret was first created</td>\n</tr>\n<tr>\n<td><code>UpdatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Timestamp of most recent version addition</td>\n</tr>\n<tr>\n<td><code>CreatedBy</code></td>\n<td><code>string</code></td>\n<td>Identity that created this secret path</td>\n</tr>\n<tr>\n<td><code>DeletedAt</code></td>\n<td><code>*time.Time</code></td>\n<td>Soft deletion timestamp (nil if not deleted)</td>\n</tr>\n<tr>\n<td><code>Metadata</code></td>\n<td><code>map[string]string</code></td>\n<td>User-defined key-value pairs for secret categorization</td>\n</tr>\n<tr>\n<td><code>CASRequired</code></td>\n<td><code>bool</code></td>\n<td>Whether check-and-set is required for updates</td>\n</tr>\n</tbody></table>\n<p>The secret path follows a hierarchical naming convention similar to file systems, enabling policy engines to apply path-based access controls using wildcard patterns. The versioning system ensures that secret updates never overwrite existing values immediately, providing safety during deployment rollbacks and key rotation operations.</p>\n<h4 id=\"secret-version-structure\">Secret Version Structure</h4>\n<p>Each <code>SecretVersion</code> represents a specific encrypted value of a secret at a point in time, along with all metadata necessary for decryption and audit trails.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Version</code></td>\n<td><code>int</code></td>\n<td>Monotonically increasing version number</td>\n</tr>\n<tr>\n<td><code>EncryptedValue</code></td>\n<td><code>[]byte</code></td>\n<td>Secret value encrypted with data encryption key</td>\n</tr>\n<tr>\n<td><code>KeyVersion</code></td>\n<td><code>int</code></td>\n<td>Version of data encryption key used for this secret</td>\n</tr>\n<tr>\n<td><code>Algorithm</code></td>\n<td><code>string</code></td>\n<td>Encryption algorithm (typically &quot;AES-256-GCM&quot;)</td>\n</tr>\n<tr>\n<td><code>Nonce</code></td>\n<td><code>[]byte</code></td>\n<td>Cryptographic nonce used for authenticated encryption</td>\n</tr>\n<tr>\n<td><code>AuthData</code></td>\n<td><code>[]byte</code></td>\n<td>Additional authenticated data (secret path + version)</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Timestamp when this version was created</td>\n</tr>\n<tr>\n<td><code>CreatedBy</code></td>\n<td><code>string</code></td>\n<td>Identity that created this version</td>\n</tr>\n<tr>\n<td><code>TTL</code></td>\n<td><code>time.Duration</code></td>\n<td>Time-to-live for this version (zero means no expiration)</td>\n</tr>\n<tr>\n<td><code>Checksum</code></td>\n<td><code>[]byte</code></td>\n<td>SHA-256 hash of plaintext for integrity verification</td>\n</tr>\n</tbody></table>\n<p>The <code>AuthData</code> field contains the secret path and version number, providing cryptographic binding between the encrypted value and its identity. This prevents attackers from copying encrypted values between different secret paths or versions. The checksum enables integrity verification after decryption without storing plaintext.</p>\n<h4 id=\"data-encryption-key-structure\">Data Encryption Key Structure</h4>\n<p>The <code>DataEncryptionKey</code> (DEK) represents the keys used to encrypt individual secrets, which are themselves encrypted by the master key in our envelope encryption scheme.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Version</code></td>\n<td><code>int</code></td>\n<td>Unique version number for this key</td>\n</tr>\n<tr>\n<td><code>EncryptedKey</code></td>\n<td><code>[]byte</code></td>\n<td>The DEK encrypted with current master key</td>\n</tr>\n<tr>\n<td><code>Algorithm</code></td>\n<td><code>string</code></td>\n<td>DEK algorithm (typically &quot;AES-256&quot;)</td>\n</tr>\n<tr>\n<td><code>MasterKeyVersion</code></td>\n<td><code>int</code></td>\n<td>Version of master key used to encrypt this DEK</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Timestamp when this key version was generated</td>\n</tr>\n<tr>\n<td><code>Status</code></td>\n<td><code>string</code></td>\n<td>Key lifecycle status (active, rotating, deprecated)</td>\n</tr>\n<tr>\n<td><code>UsageCount</code></td>\n<td><code>int64</code></td>\n<td>Number of secrets encrypted with this key (for rotation triggers)</td>\n</tr>\n</tbody></table>\n<p>The key versioning system enables gradual key rotation without service disruption. During rotation, new secrets use the latest key version while existing secrets continue using their original keys until they are naturally updated or explicitly re-encrypted.</p>\n<blockquote>\n<p><strong>Decision: Envelope Encryption with Versioned Data Keys</strong></p>\n<ul>\n<li><strong>Context</strong>: Secrets must be encrypted at rest, and we need to support key rotation without re-encrypting every secret simultaneously</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Single master key encrypts all secrets directly</li>\n<li>Envelope encryption with versioned data encryption keys</li>\n<li>Per-secret random keys encrypted with master key</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Envelope encryption with versioned data encryption keys</li>\n<li><strong>Rationale</strong>: Enables gradual key rotation, limits master key exposure, and provides operational flexibility for key management. Per-secret keys would create too much key management overhead, while single master key rotation would require atomic re-encryption of all secrets.</li>\n<li><strong>Consequences</strong>: Adds complexity with key versioning but enables zero-downtime key rotation and better security isolation.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Direct master key encryption</td>\n<td>Simple implementation, fewer keys to manage</td>\n<td>Key rotation requires re-encrypting all secrets atomically</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Envelope encryption with versioned DEKs</td>\n<td>Gradual rotation, operational flexibility, limited master key exposure</td>\n<td>More complex key management, additional storage overhead</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Per-secret random keys</td>\n<td>Maximum isolation, simple rotation per secret</td>\n<td>Excessive key storage, complex key lifecycle management</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h3 id=\"access-control-model\">Access Control Model</h3>\n<p>The access control model defines how identities are authenticated, policies are structured, and authorization decisions are made. This model implements a <strong>path-based access control</strong> system that combines the flexibility of wildcard matching with the security of explicit policy definitions.</p>\n<h4 id=\"mental-model-the-corporate-badge-system\">Mental Model: The Corporate Badge System</h4>\n<p>Think of our access control like a <strong>modern corporate badge system</strong>. Employees carry access cards (tokens) that identify who they are and which security groups they belong to. The building has policy rules (policies) that specify which badge types can access which areas - for example, &quot;Engineering badges can access floors 3-5&quot; or &quot;Facilities badges can access all floors but only during business hours.&quot; When someone tries to enter a secured area (access a secret), the card reader (authorization engine) checks their badge against the area&#39;s policy rules to make an access decision.</p>\n<p>Just as corporate policies use patterns (&quot;all Engineering areas&quot; rather than listing every room), our system uses path patterns to efficiently specify access rules across hierarchical secret namespaces.</p>\n<h4 id=\"policy-structure\">Policy Structure</h4>\n<p>The <code>Policy</code> entity defines access permissions for secret paths, supporting wildcard patterns and fine-grained capability controls.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>Unique policy identifier (e.g., &quot;database-admin-policy&quot;)</td>\n</tr>\n<tr>\n<td><code>Rules</code></td>\n<td><code>[]PolicyRule</code></td>\n<td>List of path-based access rules</td>\n</tr>\n<tr>\n<td><code>Description</code></td>\n<td><code>string</code></td>\n<td>Human-readable policy purpose description</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Policy creation timestamp</td>\n</tr>\n<tr>\n<td><code>UpdatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Policy last modification timestamp</td>\n</tr>\n<tr>\n<td><code>CreatedBy</code></td>\n<td><code>string</code></td>\n<td>Identity that created this policy</td>\n</tr>\n<tr>\n<td><code>Version</code></td>\n<td><code>int</code></td>\n<td>Policy version for audit and rollback purposes</td>\n</tr>\n</tbody></table>\n<h4 id=\"policy-rule-structure\">Policy Rule Structure</h4>\n<p>Each <code>PolicyRule</code> specifies capabilities (permissions) for a specific path pattern, enabling fine-grained access control across the secret hierarchy.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Path</code></td>\n<td><code>string</code></td>\n<td>Secret path pattern with wildcard support (e.g., &quot;database/prod/*&quot;)</td>\n</tr>\n<tr>\n<td><code>Capabilities</code></td>\n<td><code>[]string</code></td>\n<td>Allowed operations: &quot;read&quot;, &quot;write&quot;, &quot;delete&quot;, &quot;list&quot;</td>\n</tr>\n<tr>\n<td><code>RequiredParameters</code></td>\n<td><code>map[string][]string</code></td>\n<td>Required request parameters and allowed values</td>\n</tr>\n<tr>\n<td><code>AllowedParameters</code></td>\n<td><code>map[string][]string</code></td>\n<td>Optional parameters and their allowed values</td>\n</tr>\n<tr>\n<td><code>DeniedParameters</code></td>\n<td><code>map[string][]string</code></td>\n<td>Explicitly forbidden parameters</td>\n</tr>\n<tr>\n<td><code>MaxTTL</code></td>\n<td><code>time.Duration</code></td>\n<td>Maximum TTL for secrets created/read under this path</td>\n</tr>\n<tr>\n<td><code>MinWrappingTTL</code></td>\n<td><code>time.Duration</code></td>\n<td>Minimum TTL for response wrapping (if supported)</td>\n</tr>\n</tbody></table>\n<p>The path patterns support glob-style wildcards where <code>*</code> matches any characters within a path segment and <code>**</code> matches across multiple path segments. The capability system provides standard CRUD operations plus special operations like &quot;list&quot; for path enumeration.</p>\n<h4 id=\"token-structure\">Token Structure</h4>\n<p>The <code>Token</code> entity represents authentication credentials issued to identities, carrying policy attachments and usage constraints.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ID</code></td>\n<td><code>string</code></td>\n<td>Unique token identifier (cryptographically random)</td>\n</tr>\n<tr>\n<td><code>Accessor</code></td>\n<td><code>string</code></td>\n<td>Non-sensitive token reference for audit logs</td>\n</tr>\n<tr>\n<td><code>Policies</code></td>\n<td><code>[]string</code></td>\n<td>List of policy names attached to this token</td>\n</tr>\n<tr>\n<td><code>TokenType</code></td>\n<td><code>string</code></td>\n<td>Token type: &quot;service&quot; (long-lived) or &quot;batch&quot; (lightweight)</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Token issuance timestamp</td>\n</tr>\n<tr>\n<td><code>ExpiresAt</code></td>\n<td><code>*time.Time</code></td>\n<td>Token expiration (nil for non-expiring service tokens)</td>\n</tr>\n<tr>\n<td><code>LastUsedAt</code></td>\n<td><code>*time.Time</code></td>\n<td>Timestamp of most recent token usage</td>\n</tr>\n<tr>\n<td><code>UsageCount</code></td>\n<td><code>int64</code></td>\n<td>Number of times token has been used</td>\n</tr>\n<tr>\n<td><code>MaxUses</code></td>\n<td><code>int</code></td>\n<td>Maximum number of uses (0 = unlimited)</td>\n</tr>\n<tr>\n<td><code>Renewable</code></td>\n<td><code>bool</code></td>\n<td>Whether token TTL can be extended</td>\n</tr>\n<tr>\n<td><code>ParentToken</code></td>\n<td><code>string</code></td>\n<td>Token that created this token (for hierarchical revocation)</td>\n</tr>\n<tr>\n<td><code>DisplayName</code></td>\n<td><code>string</code></td>\n<td>Human-readable token description</td>\n</tr>\n<tr>\n<td><code>Metadata</code></td>\n<td><code>map[string]string</code></td>\n<td>Additional token metadata for audit purposes</td>\n</tr>\n<tr>\n<td><code>BoundCIDRs</code></td>\n<td><code>[]string</code></td>\n<td>IP address ranges from which token can be used</td>\n</tr>\n</tbody></table>\n<p>The token hierarchy supports parent-child relationships, enabling revocation of all child tokens when a parent token is revoked. The accessor field provides a way to reference tokens in audit logs without exposing the actual token value.</p>\n<h4 id=\"identity-structure\">Identity Structure</h4>\n<p>The <code>Identity</code> entity represents authenticated principals (users, services, applications) that can be assigned policies and issued tokens.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ID</code></td>\n<td><code>string</code></td>\n<td>Unique identity identifier</td>\n</tr>\n<tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>Human-readable identity name</td>\n</tr>\n<tr>\n<td><code>Type</code></td>\n<td><code>string</code></td>\n<td>Identity type: &quot;user&quot;, &quot;service&quot;, &quot;role&quot;</td>\n</tr>\n<tr>\n<td><code>AuthMethod</code></td>\n<td><code>string</code></td>\n<td>Authentication method used: &quot;token&quot;, &quot;tls-cert&quot;, &quot;approle&quot;</td>\n</tr>\n<tr>\n<td><code>Policies</code></td>\n<td><code>[]string</code></td>\n<td>Direct policy attachments for this identity</td>\n</tr>\n<tr>\n<td><code>Groups</code></td>\n<td><code>[]string</code></td>\n<td>Group memberships (groups have their own policies)</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Identity creation timestamp</td>\n</tr>\n<tr>\n<td><code>LastAuthAt</code></td>\n<td><code>*time.Time</code></td>\n<td>Most recent successful authentication</td>\n</tr>\n<tr>\n<td><code>AuthCount</code></td>\n<td><code>int64</code></td>\n<td>Total number of successful authentications</td>\n</tr>\n<tr>\n<td><code>Metadata</code></td>\n<td><code>map[string]string</code></td>\n<td>Identity-specific metadata (department, team, etc.)</td>\n</tr>\n<tr>\n<td><code>Disabled</code></td>\n<td><code>bool</code></td>\n<td>Whether identity is currently disabled</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Path-Based Access Control with Wildcard Patterns</strong></p>\n<ul>\n<li><strong>Context</strong>: Need flexible access control that scales across hierarchical secret namespaces without requiring individual rules for every secret path</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Per-secret explicit permissions (each secret lists authorized identities)</li>\n<li>Role-based access control with predefined roles</li>\n<li>Path-based policies with wildcard pattern matching</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Path-based policies with wildcard pattern matching</li>\n<li><strong>Rationale</strong>: Provides operational scalability (one policy rule covers many secrets), aligns with hierarchical secret organization, and offers flexibility for dynamic secret paths. RBAC alone would be too rigid for diverse secret access patterns.</li>\n<li><strong>Consequences</strong>: Requires careful policy design to avoid over-broad permissions, and wildcard matching adds complexity to authorization evaluation.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Per-secret explicit permissions</td>\n<td>Maximum security granularity</td>\n<td>Doesn&#39;t scale, management overhead</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Role-based access control</td>\n<td>Simple to understand, common pattern</td>\n<td>Too rigid for diverse access needs</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Path-based wildcard policies</td>\n<td>Scales well, flexible, intuitive</td>\n<td>Risk of over-broad patterns</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"dynamic-secret-model\">Dynamic Secret Model</h3>\n<p>The dynamic secret model defines how time-limited credentials are generated, tracked, and revoked across different backend systems. This model addresses the challenge of <strong>just-in-time credential provisioning</strong> while maintaining strong lifecycle management and cleanup guarantees.</p>\n<h4 id=\"mental-model-the-credential-vending-machine\">Mental Model: The Credential Vending Machine</h4>\n<p>Think of dynamic secrets like a <strong>sophisticated vending machine for credentials</strong>. When you need database access, you insert your token (authentication), select the type of access you need (role specification), and the machine generates a fresh set of credentials just for you with an expiration time clearly printed on them (lease). The machine keeps a record of what it dispensed and when it expires (lease tracking), and it has a cleanup crew (revocation engine) that goes around collecting expired credentials and deactivating them in the backend systems.</p>\n<p>Unlike static secrets that are like owning a key to a building, dynamic secrets are like getting a temporary visitor badge that automatically expires and gets deactivated - you get exactly the access you need for exactly the time you need it, and the system ensures cleanup happens automatically.</p>\n<h4 id=\"lease-structure\">Lease Structure</h4>\n<p>The <code>Lease</code> entity represents the lifecycle of a dynamically generated secret, tracking its validity period and enabling automatic revocation.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ID</code></td>\n<td><code>string</code></td>\n<td>Unique lease identifier (cryptographically random)</td>\n</tr>\n<tr>\n<td><code>SecretType</code></td>\n<td><code>string</code></td>\n<td>Type of secret: &quot;database&quot;, &quot;aws-iam&quot;, &quot;ssh-key&quot;, etc.</td>\n</tr>\n<tr>\n<td><code>BackendPath</code></td>\n<td><code>string</code></td>\n<td>Secret backend that generated this lease (e.g., &quot;database/prod&quot;)</td>\n</tr>\n<tr>\n<td><code>RoleName</code></td>\n<td><code>string</code></td>\n<td>Backend role used for credential generation</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Lease creation timestamp</td>\n</tr>\n<tr>\n<td><code>ExpiresAt</code></td>\n<td><code>time.Time</code></td>\n<td>Lease expiration timestamp (never nil for dynamic secrets)</td>\n</tr>\n<tr>\n<td><code>RenewedAt</code></td>\n<td><code>*time.Time</code></td>\n<td>Timestamp of most recent renewal</td>\n</tr>\n<tr>\n<td><code>RenewalCount</code></td>\n<td><code>int</code></td>\n<td>Number of times lease has been renewed</td>\n</tr>\n<tr>\n<td><code>MaxTTL</code></td>\n<td><code>time.Duration</code></td>\n<td>Maximum total lifetime regardless of renewals</td>\n</tr>\n<tr>\n<td><code>Renewable</code></td>\n<td><code>bool</code></td>\n<td>Whether this lease can have its TTL extended</td>\n</tr>\n<tr>\n<td><code>TokenID</code></td>\n<td><code>string</code></td>\n<td>Token that requested this lease (for audit and revocation)</td>\n</tr>\n<tr>\n<td><code>RevocationData</code></td>\n<td><code>map[string]interface{}</code></td>\n<td>Backend-specific data needed for credential cleanup</td>\n</tr>\n<tr>\n<td><code>SecretData</code></td>\n<td><code>map[string]interface{}</code></td>\n<td>The actual generated credentials (encrypted at rest)</td>\n</tr>\n<tr>\n<td><code>Status</code></td>\n<td><code>string</code></td>\n<td>Lease status: &quot;active&quot;, &quot;renewed&quot;, &quot;expired&quot;, &quot;revoked&quot;</td>\n</tr>\n</tbody></table>\n<p>The <code>RevocationData</code> field contains backend-specific information needed to clean up credentials - for database backends, this might include the username and connection parameters; for cloud providers, it might include the user ARN and access key ID.</p>\n<h4 id=\"secret-backend-configuration\">Secret Backend Configuration</h4>\n<p>The <code>SecretBackend</code> entity defines how dynamic secret engines connect to and manage credentials in external systems.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Path</code></td>\n<td><code>string</code></td>\n<td>Backend mount path (e.g., &quot;database/prod&quot;, &quot;aws/dev&quot;)</td>\n</tr>\n<tr>\n<td><code>Type</code></td>\n<td><code>string</code></td>\n<td>Backend type: &quot;database&quot;, &quot;aws&quot;, &quot;gcp&quot;, &quot;ssh&quot;, &quot;pki&quot;</td>\n</tr>\n<tr>\n<td><code>Description</code></td>\n<td><code>string</code></td>\n<td>Human-readable backend description</td>\n</tr>\n<tr>\n<td><code>Config</code></td>\n<td><code>map[string]interface{}</code></td>\n<td>Backend-specific configuration (connection strings, etc.)</td>\n</tr>\n<tr>\n<td><code>DefaultTTL</code></td>\n<td><code>time.Duration</code></td>\n<td>Default lease duration for secrets from this backend</td>\n</tr>\n<tr>\n<td><code>MaxTTL</code></td>\n<td><code>time.Duration</code></td>\n<td>Maximum allowed lease duration</td>\n</tr>\n<tr>\n<td><code>Roles</code></td>\n<td><code>map[string]BackendRole</code></td>\n<td>Named roles defining different credential types</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Backend creation timestamp</td>\n</tr>\n<tr>\n<td><code>UpdatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Backend last modification timestamp</td>\n</tr>\n</tbody></table>\n<p>The backend configuration is encrypted at rest since it contains sensitive connection information like database connection strings, cloud API keys, and service account credentials.</p>\n<h4 id=\"backend-role-configuration\">Backend Role Configuration</h4>\n<p>The <code>BackendRole</code> entity defines templates for generating specific types of credentials within a secret backend.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>Role name within the backend (e.g., &quot;readonly&quot;, &quot;admin&quot;)</td>\n</tr>\n<tr>\n<td><code>CreationStatements</code></td>\n<td><code>[]string</code></td>\n<td>Commands to create credentials (SQL, API calls, etc.)</td>\n</tr>\n<tr>\n<td><code>RevocationStatements</code></td>\n<td><code>[]string</code></td>\n<td>Commands to revoke/cleanup credentials</td>\n</tr>\n<tr>\n<td><code>RenewStatements</code></td>\n<td><code>[]string</code></td>\n<td>Commands to extend credential lifetime (if supported)</td>\n</tr>\n<tr>\n<td><code>DefaultTTL</code></td>\n<td><code>time.Duration</code></td>\n<td>Default lease duration for this role</td>\n</tr>\n<tr>\n<td><code>MaxTTL</code></td>\n<td><code>time.Duration</code></td>\n<td>Maximum lease duration for this role</td>\n</tr>\n<tr>\n<td><code>RenewIncrement</code></td>\n<td><code>time.Duration</code></td>\n<td>TTL increment when renewing leases</td>\n</tr>\n<tr>\n<td><code>AllowedDomains</code></td>\n<td><code>[]string</code></td>\n<td>Allowed domains/suffixes for generated usernames</td>\n</tr>\n<tr>\n<td><code>RoleOptions</code></td>\n<td><code>map[string]interface{}</code></td>\n<td>Backend-specific role configuration</td>\n</tr>\n</tbody></table>\n<p>For database backends, the <code>CreationStatements</code> might contain SQL commands like <code>CREATE USER &#39;{{username}}&#39;@&#39;%&#39; IDENTIFIED BY &#39;{{password}}&#39;</code> where the template variables are replaced with generated values. The revocation statements would contain corresponding cleanup commands.</p>\n<h4 id=\"lease-tracking-and-revocation\">Lease Tracking and Revocation</h4>\n<p>The lease management system maintains several tracking structures to enable efficient renewal and revocation operations.</p>\n<p>The <code>LeaseIndex</code> provides efficient lookups for lease operations:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ByExpiration</code></td>\n<td><code>map[time.Time][]string</code></td>\n<td>Lease IDs grouped by expiration time buckets</td>\n</tr>\n<tr>\n<td><code>ByToken</code></td>\n<td><code>map[string][]string</code></td>\n<td>Lease IDs associated with each token (for token revocation)</td>\n</tr>\n<tr>\n<td><code>ByBackend</code></td>\n<td><code>map[string][]string</code></td>\n<td>Lease IDs associated with each backend (for backend cleanup)</td>\n</tr>\n<tr>\n<td><code>ActiveCount</code></td>\n<td><code>int64</code></td>\n<td>Total number of active leases (for monitoring)</td>\n</tr>\n</tbody></table>\n<p>The <code>RevocationQueue</code> manages asynchronous cleanup of expired or revoked credentials:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LeaseID</code></td>\n<td><code>string</code></td>\n<td>Lease identifier to revoke</td>\n</tr>\n<tr>\n<td><code>BackendPath</code></td>\n<td><code>string</code></td>\n<td>Backend responsible for revocation</td>\n</tr>\n<tr>\n<td><code>RevocationData</code></td>\n<td><code>map[string]interface{}</code></td>\n<td>Data needed to clean up credentials</td>\n</tr>\n<tr>\n<td><code>QueuedAt</code></td>\n<td><code>time.Time</code></td>\n<td>When revocation was queued</td>\n</tr>\n<tr>\n<td><code>AttemptCount</code></td>\n<td><code>int</code></td>\n<td>Number of revocation attempts made</td>\n</tr>\n<tr>\n<td><code>NextAttempt</code></td>\n<td><code>time.Time</code></td>\n<td>When to retry revocation (for failed attempts)</td>\n</tr>\n<tr>\n<td><code>Priority</code></td>\n<td><code>int</code></td>\n<td>Revocation priority (expired vs. explicitly revoked)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Lease-Based Dynamic Secret Management</strong></p>\n<ul>\n<li><strong>Context</strong>: Dynamic secrets need automatic expiration and cleanup without manual intervention, while supporting renewal for long-running operations</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>TTL-based secrets with background cleanup scanning</li>\n<li>Lease-based tracking with explicit revocation queues</li>\n<li>Event-driven cleanup with external system notifications</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Lease-based tracking with explicit revocation queues</li>\n<li><strong>Rationale</strong>: Provides predictable cleanup guarantees, supports complex renewal patterns, and enables audit trails for credential lifecycle. Background scanning alone cannot handle revocation failures reliably.</li>\n<li><strong>Consequences</strong>: Adds complexity with lease tracking but ensures credential cleanup even when backend systems are temporarily unavailable.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TTL-based with background scanning</td>\n<td>Simple implementation, low storage overhead</td>\n<td>No cleanup guarantees, difficult failure handling</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Lease-based with revocation queues</td>\n<td>Reliable cleanup, audit trail, failure recovery</td>\n<td>Higher storage overhead, more complex</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Event-driven external notifications</td>\n<td>Minimal storage, real-time cleanup</td>\n<td>Depends on external systems, no retry logic</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h4 id=\"common-pitfalls\">Common Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Storing Revocation Data in Secret Data</strong>\nMany implementations mistakenly store backend cleanup information alongside the generated credentials. This creates problems because the secret data is typically returned to clients, potentially exposing internal backend details like connection strings or service account names. The revocation data should be stored separately and never exposed in API responses.</p>\n<p>⚠️ <strong>Pitfall: Not Encrypting Backend Configuration</strong>\nBackend configurations contain highly sensitive information like database passwords and cloud API keys. Storing this configuration in plaintext makes it a high-value target for attackers. All backend configuration should be encrypted using the same envelope encryption system as regular secrets.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Lease Revocation Failures</strong>\nWhen credential revocation fails (backend is down, network issues, etc.), many systems simply log the error and move on. This leaves orphaned credentials active in backend systems indefinitely. Implement retry logic with exponential backoff and alerting for repeatedly failed revocations.</p>\n<p>⚠️ <strong>Pitfall: Unbounded Lease Renewal</strong>\nWithout proper max TTL enforcement, clients can renew leases indefinitely, defeating the purpose of dynamic secrets. Always enforce a maximum total lifetime regardless of renewal count, and consider implementing renewal limits or decay factors.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The data model implementation requires careful attention to encryption, serialization, and database schema design. The following guidance provides practical approaches for implementing these structures in Go.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Storage Backend</td>\n<td>SQLite with GORM</td>\n<td>PostgreSQL with custom queries</td>\n</tr>\n<tr>\n<td>Serialization</td>\n<td>JSON with struct tags</td>\n<td>Protocol Buffers with schema evolution</td>\n</tr>\n<tr>\n<td>Encryption Library</td>\n<td>crypto/aes + crypto/cipher</td>\n<td>github.com/hashicorp/go-kms-wrapping</td>\n</tr>\n<tr>\n<td>Key Derivation</td>\n<td>crypto/pbkdf2</td>\n<td>golang.org/x/crypto/argon2</td>\n</tr>\n<tr>\n<td>Time Handling</td>\n<td>time.Time with UTC</td>\n<td>Custom time with nanosecond precision</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/\n  storage/\n    models/\n      secret.go          ← Secret and SecretVersion structs\n      policy.go          ← Policy, PolicyRule, Token, Identity structs  \n      lease.go           ← Lease, SecretBackend, BackendRole structs\n      encryption.go      ← DataEncryptionKey and crypto helpers\n    backends/\n      sqlite/\n        migrations/      ← Database schema migration files\n        sqlite.go        ← SQLite storage implementation\n      postgres/\n        postgres.go      ← PostgreSQL storage implementation (future)\n    storage.go           ← Storage interface definition\n  crypto/\n    envelope.go          ← Envelope encryption implementation\n    keys.go              ← Key generation and rotation</code></pre></div>\n\n<h4 id=\"core-data-structure-definitions\">Core Data Structure Definitions</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package models provides the core data structures for secret management.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> models</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Secret represents a versioned secret with metadata and access control.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Secret</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tPath           </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"path\" gorm:\"primaryKey\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tVersions       []</span><span style=\"color:#B392F0\">SecretVersion</span><span style=\"color:#9ECBFF\">   `json:\"versions\" gorm:\"foreignKey:SecretPath\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCurrentVersion </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">               `json:\"current_version\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMaxVersions    </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">               `json:\"max_versions\" gorm:\"default:10\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCreatedAt      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">         `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tUpdatedAt      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">         `json:\"updated_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCreatedBy      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"created_by\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDeletedAt      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">        `json:\"deleted_at,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMetadata       </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"metadata\" gorm:\"serializer:json\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCASRequired    </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">              `json:\"cas_required\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SecretVersion represents a specific encrypted version of a secret value.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SecretVersion</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tSecretPath     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"secret_path\" gorm:\"primaryKey\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tVersion        </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">       `json:\"version\" gorm:\"primaryKey\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tEncryptedValue []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#9ECBFF\">    `json:\"-\"`</span><span style=\"color:#6A737D\"> // Never serialize in JSON responses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tKeyVersion     </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">       `json:\"key_version\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAlgorithm      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"algorithm\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tNonce          []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#9ECBFF\">    `json:\"-\"`</span><span style=\"color:#6A737D\"> // Never serialize in JSON responses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAuthData       []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#9ECBFF\">    `json:\"-\"`</span><span style=\"color:#6A737D\"> // Never serialize in JSON responses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCreatedAt      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCreatedBy      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"created_by\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tTTL            </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"ttl\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tChecksum       []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#9ECBFF\">    `json:\"-\"`</span><span style=\"color:#6A737D\"> // Never serialize in JSON responses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Policy represents access control rules for secret paths.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Policy</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tName        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"name\" gorm:\"primaryKey\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tRules       []</span><span style=\"color:#B392F0\">PolicyRule</span><span style=\"color:#9ECBFF\"> `json:\"rules\" gorm:\"foreignKey:PolicyName\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDescription </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"description\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCreatedAt   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">    `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tUpdatedAt   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">    `json:\"updated_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCreatedBy   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"created_by\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tVersion     </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">          `json:\"version\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PolicyRule defines capabilities for a specific path pattern.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PolicyRule</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tID                 </span><span style=\"color:#F97583\">uint</span><span style=\"color:#9ECBFF\">              `json:\"-\" gorm:\"primaryKey\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tPolicyName         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"-\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tPath               </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCapabilities       []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"capabilities\" gorm:\"serializer:json\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tRequiredParameters </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"required_parameters\" gorm:\"serializer:json\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAllowedParameters  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"allowed_parameters\" gorm:\"serializer:json\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDeniedParameters   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"denied_parameters\" gorm:\"serializer:json\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMaxTTL             </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\">     `json:\"max_ttl\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMinWrappingTTL     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\">     `json:\"min_wrapping_ttl\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Token represents an authentication credential with policy attachments.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tID           </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"id\" gorm:\"primaryKey\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAccessor     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"accessor\" gorm:\"uniqueIndex\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tPolicies     []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"policies\" gorm:\"serializer:json\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tTokenType    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"token_type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCreatedAt    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">         `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tExpiresAt    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">        `json:\"expires_at,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tLastUsedAt   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">        `json:\"last_used_at,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tUsageCount   </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">             `json:\"usage_count\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMaxUses      </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">               `json:\"max_uses\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tRenewable    </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">              `json:\"renewable\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tParentToken  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"parent_token\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDisplayName  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"display_name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMetadata     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"metadata\" gorm:\"serializer:json\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tBoundCIDRs   []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"bound_cidrs\" gorm:\"serializer:json\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"storage-interface-implementation\">Storage Interface Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package storage defines the interface for persisting secret management data.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> storage</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">your-project/internal/storage/models</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Backend defines the interface for secret storage operations.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Backend</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Secret operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tCreateSecret</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">secret</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Secret</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tGetSecret</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Secret</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tGetSecretVersion</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">version</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SecretVersion</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tUpdateSecret</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">version</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SecretVersion</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tDeleteSecret</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tListSecrets</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pathPrefix</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Policy operations  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tCreatePolicy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">policy</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Policy</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tGetPolicy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Policy</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tUpdatePolicy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">policy</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Policy</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tDeletePolicy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tListPolicies</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Token operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tCreateToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">token</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tGetToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tUpdateToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">token</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tDeleteToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tDeleteTokensByParent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">parentID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Lease operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tCreateLease</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">lease</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Lease</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tGetLease</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Lease</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tUpdateLease</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">lease</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Lease</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tDeleteLease</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tGetExpiredLeases</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">before</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Lease</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tGetLeasesByToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tokenID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Lease</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Maintenance operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\tClose</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Implement SQLite backend with proper transaction handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Add connection pooling and prepared statement caching</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Implement database migration system for schema updates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Add metrics collection for storage operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Implement backup and restore functionality</span></span></code></pre></div>\n\n<h4 id=\"envelope-encryption-helper\">Envelope Encryption Helper</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package crypto provides envelope encryption for secret values.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> crypto</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">crypto/aes</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">crypto/cipher</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">crypto/rand</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">crypto/sha256</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">errors</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tAES_KEY_SIZE</span><span style=\"color:#F97583\">     =</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#6A737D\"> // 256-bit keys for AES-256</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tGCM_NONCE_SIZE</span><span style=\"color:#F97583\">   =</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#6A737D\"> // 96-bit nonces for GCM</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DataEncryptionKey represents a key used to encrypt secret data.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DataEncryptionKey</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tVersion          </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">       `json:\"version\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tEncryptedKey     []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#9ECBFF\">    `json:\"encrypted_key\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tAlgorithm        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"algorithm\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMasterKeyVersion </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">       `json:\"master_key_version\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCreatedAt        </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tStatus           </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"status\"`</span><span style=\"color:#6A737D\"> // active, rotating, deprecated</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tUsageCount       </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">     `json:\"usage_count\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EnvelopeEncryption handles the encryption and decryption of secrets using envelope encryption.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EnvelopeEncryption</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmasterKey []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\"> // Current master key (AES-256)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tkeyVersion </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">   // Current master key version</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Initialize envelope encryption with master key loaded from secure storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Implement master key rotation with gradual DEK re-encryption</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Add key derivation from password using Argon2 (for development/testing)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Integrate with cloud KMS for master key protection (auto-unseal)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EncryptSecret encrypts a plaintext secret using envelope encryption.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns encrypted data, nonce, and additional authenticated data.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EnvelopeEncryption</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">EncryptSecret</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">plaintext</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">version</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">dekVersion</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Generate or retrieve data encryption key for dekVersion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Generate random nonce for AES-GCM (12 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Create additional authenticated data from path + version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Create AES-GCM cipher with DEK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Encrypt plaintext with nonce and additional authenticated data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Return ciphertext, nonce, and auth data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DecryptSecret decrypts an encrypted secret using envelope encryption.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EnvelopeEncryption</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DecryptSecret</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ciphertext</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">nonce</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">authData</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">dekVersion</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Retrieve and decrypt data encryption key for dekVersion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Create AES-GCM cipher with decrypted DEK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Decrypt ciphertext using nonce and auth data for verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Verify checksum if provided (optional integrity check)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Securely zero DEK from memory after use</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateDataEncryptionKey creates a new data encryption key encrypted with the master key.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EnvelopeEncryption</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateDataEncryptionKey</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">version</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DataEncryptionKey</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Generate random 256-bit key for AES-256 using crypto/rand</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Encrypt the DEK with current master key using AES-GCM</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Create DataEncryptionKey struct with metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Securely zero the plaintext DEK from memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"database-migration-example\">Database Migration Example</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">-- Migration 001: Initial secret management schema</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- File: internal/storage/backends/sqlite/migrations/001_initial.sql</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Secrets table with versioning support</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> secrets</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    path</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#F97583\"> PRIMARY KEY</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_version </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_versions </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_at </span><span style=\"color:#F97583\">DATETIME</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#E1E4E8\"> CURRENT_TIMESTAMP,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    updated_at </span><span style=\"color:#F97583\">DATETIME</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#E1E4E8\"> CURRENT_TIMESTAMP,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_by </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    deleted_at </span><span style=\"color:#F97583\">DATETIME</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metadata </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">-- JSON encoded map[string]string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cas_required </span><span style=\"color:#F97583\">BOOLEAN</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#E1E4E8\"> FALSE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Secret versions table storing encrypted values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> secret_versions</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    secret_path </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    version</span><span style=\"color:#F97583\"> INTEGER</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    encrypted_value</span><span style=\"color:#E1E4E8\"> BLOB </span><span style=\"color:#F97583\">NOT NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    key_version </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    algorithm</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#9ECBFF\"> 'AES-256-GCM'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nonce BLOB </span><span style=\"color:#F97583\">NOT NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    auth_data BLOB </span><span style=\"color:#F97583\">NOT NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_at </span><span style=\"color:#F97583\">DATETIME</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#E1E4E8\"> CURRENT_TIMESTAMP,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_by </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ttl </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">-- TTL in nanoseconds, 0 = no expiration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    checksum</span><span style=\"color:#E1E4E8\"> BLOB </span><span style=\"color:#F97583\">NOT NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    PRIMARY KEY</span><span style=\"color:#E1E4E8\"> (secret_path, </span><span style=\"color:#F97583\">version</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    FOREIGN KEY</span><span style=\"color:#E1E4E8\"> (secret_path) </span><span style=\"color:#F97583\">REFERENCES</span><span style=\"color:#E1E4E8\"> secrets(</span><span style=\"color:#F97583\">path</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">ON DELETE CASCADE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Policies table for access control rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> policies</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    name</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#F97583\"> PRIMARY KEY</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    description</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_at </span><span style=\"color:#F97583\">DATETIME</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#E1E4E8\"> CURRENT_TIMESTAMP,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    updated_at </span><span style=\"color:#F97583\">DATETIME</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#E1E4E8\"> CURRENT_TIMESTAMP,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_by </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    version</span><span style=\"color:#F97583\"> INTEGER</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Policy rules table for path-based permissions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> policy_rules</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    id </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#F97583\"> PRIMARY KEY</span><span style=\"color:#E1E4E8\"> AUTOINCREMENT,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    policy_name </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    path</span><span style=\"color:#F97583\"> TEXT</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    capabilities </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">-- JSON encoded []string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    required_parameters </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#6A737D\">-- JSON encoded map[string][]string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    allowed_parameters </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#E1E4E8\">,    </span><span style=\"color:#6A737D\">-- JSON encoded map[string][]string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    denied_parameters </span><span style=\"color:#F97583\">TEXT</span><span style=\"color:#E1E4E8\">,     </span><span style=\"color:#6A737D\">-- JSON encoded map[string][]string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_ttl </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">-- TTL in nanoseconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    min_wrapping_ttl </span><span style=\"color:#F97583\">INTEGER</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    FOREIGN KEY</span><span style=\"color:#E1E4E8\"> (policy_name) </span><span style=\"color:#F97583\">REFERENCES</span><span style=\"color:#E1E4E8\"> policies(</span><span style=\"color:#F97583\">name</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">ON DELETE CASCADE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Indexes for efficient secret and policy lookups</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#B392F0\"> idx_secrets_path_prefix</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> secrets(</span><span style=\"color:#F97583\">path</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#B392F0\"> idx_secret_versions_created_at</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> secret_versions(created_at);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#B392F0\"> idx_policy_rules_path</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> policy_rules(</span><span style=\"color:#F97583\">path</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#B392F0\"> idx_policy_rules_policy</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> policy_rules(policy_name);</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After implementing Secret Storage Model:</strong></p>\n<ol>\n<li>Run <code>go test ./internal/storage/...</code> - all storage interface tests should pass</li>\n<li>Create a test secret: <code>POST /v1/secret/test</code> with JSON body <code>{&quot;value&quot;: &quot;test-secret&quot;}</code>  </li>\n<li>Retrieve the secret: <code>GET /v1/secret/test</code> should return the encrypted value decrypted</li>\n<li>Verify versioning: Update the same secret and confirm version increments</li>\n<li>Check encryption: Examine database directly - secret values should be encrypted blob data</li>\n</ol>\n<p><strong>After implementing Access Control Model:</strong></p>\n<ol>\n<li>Create a policy: <code>POST /v1/sys/policy/test-policy</code> with JSON policy rules</li>\n<li>Create a token: <code>POST /v1/auth/token/create</code> with the policy attached</li>\n<li>Test access: Use the token to access secrets matching the policy paths</li>\n<li>Test denial: Verify requests outside policy paths return 403 Forbidden</li>\n<li>Check audit logs: Confirm all access attempts are logged with token accessor</li>\n</ol>\n<p><strong>After implementing Dynamic Secret Model:</strong></p>\n<ol>\n<li>Configure a database backend: <code>POST /v1/database/config/test-db</code> with connection details</li>\n<li>Create a role: <code>POST /v1/database/roles/readonly</code> with SQL creation statements  </li>\n<li>Request credentials: <code>GET /v1/database/creds/readonly</code> should return username/password</li>\n<li>Verify TTL: Wait for lease expiration and confirm credentials are revoked</li>\n<li>Test renewal: Renew lease before expiration and verify extended lifetime</li>\n</ol>\n<h2 id=\"encryption-engine-design\">Encryption Engine Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section implements Milestone 1 (Encrypted Secret Storage), focusing on envelope encryption with master keys and data encryption keys, secret versioning, and key rotation mechanisms.</p>\n</blockquote>\n<p>The encryption engine forms the security heart of our secret management system, implementing a <strong>nested safe system</strong> that protects secrets through multiple layers of encryption. Like a bank that stores valuables in individual safety deposit boxes within a master vault, our system uses envelope encryption to create defense in depth against various attack vectors.</p>\n<p><img src=\"/api/project/secret-management/architecture-doc/asset?path=diagrams%2Fenvelope-encryption-flow.svg\" alt=\"Envelope Encryption Flow\"></p>\n<p>The encryption engine must solve several challenging problems simultaneously: protecting secrets at rest while maintaining performance, enabling key rotation without system downtime, supporting secret versioning for backward compatibility, and handling the cryptographic complexity of envelope encryption. Each of these requirements introduces technical constraints that shape our architectural decisions.</p>\n<h3 id=\"envelope-encryption-mental-model\">Envelope Encryption Mental Model</h3>\n<p><strong>Envelope encryption</strong> operates like a <strong>nested safe system</strong> where you have a master safe containing many smaller safes, each with their own keys. In a physical bank, the master vault key never leaves the secure control room, while individual deposit box keys are generated on demand and can be rotated regularly without touching the master vault.</p>\n<p>In our digital implementation, the <strong>master key</strong> acts like the bank&#39;s master vault key - it never directly encrypts user secrets but instead protects a collection of <strong>data encryption keys (DEKs)</strong>. Each DEK is like an individual safety deposit box key that actually encrypts the secrets. When a client stores a secret, we generate a fresh DEK, use it to encrypt the secret, then encrypt the DEK itself with the master key before storing both pieces.</p>\n<p>This separation provides several critical security properties. First, <strong>key rotation isolation</strong> - we can rotate DEKs regularly without touching the master key, and we can rotate the master key by re-encrypting all DEKs without re-encrypting every secret. Second, <strong>blast radius containment</strong> - if a single DEK is compromised, it only affects secrets encrypted with that specific key. Third, <strong>performance optimization</strong> - the expensive master key operations happen infrequently, while the bulk encryption work uses faster symmetric DEKs.</p>\n<p>The envelope structure creates multiple failure points that an attacker must compromise. Even if they gain access to the encrypted secrets and encrypted DEKs in storage, they still need the master key to decrypt the DEKs. Even if they compromise the master key, they must still perform the multi-step decryption process for each secret individually.</p>\n<blockquote>\n<p><strong>Critical Security Insight</strong>: The master key should never directly touch user data. This principle ensures that master key compromise requires additional steps to access secrets, buying time for detection and response.</p>\n</blockquote>\n<h3 id=\"key-hierarchy-and-rotation\">Key Hierarchy and Rotation</h3>\n<p>Our encryption system implements a <strong>three-tier key hierarchy</strong> that balances security, performance, and operational flexibility. At the top sits the <strong>master key</strong> - a 256-bit AES key that serves as the root of trust for the entire system. The master key encrypts <strong>data encryption keys (DEKs)</strong>, which are also 256-bit AES keys generated for each encryption operation or time period. Finally, <strong>secret-specific nonces</strong> ensure that identical secrets produce different ciphertext even when encrypted with the same DEK.</p>\n<table>\n<thead>\n<tr>\n<th>Key Type</th>\n<th>Size</th>\n<th>Lifetime</th>\n<th>Purpose</th>\n<th>Rotation Frequency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Master Key</td>\n<td>256-bit AES</td>\n<td>System lifetime</td>\n<td>Encrypts DEKs</td>\n<td>Yearly or on compromise</td>\n</tr>\n<tr>\n<td>Data Encryption Key</td>\n<td>256-bit AES</td>\n<td>Configurable (default 30 days)</td>\n<td>Encrypts secrets</td>\n<td>Monthly or on compromise</td>\n</tr>\n<tr>\n<td>Nonce</td>\n<td>96-bit random</td>\n<td>Per-operation</td>\n<td>Ensures ciphertext uniqueness</td>\n<td>Every encryption</td>\n</tr>\n</tbody></table>\n<p>The <strong>master key lifecycle</strong> follows strict operational procedures. During system initialization, we generate the master key using a cryptographically secure random number generator and immediately split it using Shamir&#39;s secret sharing (covered in the unsealing section). The master key remains in memory only while the system is unsealed, and we clear it from memory during system shutdown or sealing operations.</p>\n<p><strong>Data encryption key management</strong> implements a more dynamic lifecycle. We maintain a <strong>DEK rotation schedule</strong> where new DEKs are generated automatically based on time intervals or usage counts. Each DEK has a version number and lifecycle status: <code>active</code> for new encryptions, <code>retired</code> for decryption-only, and <code>revoked</code> for compromised keys. The system maintains multiple DEK versions simultaneously to support decryption of older secrets while using only the latest active DEK for new encryptions.</p>\n<blockquote>\n<p><strong>Decision: Time-Based DEK Rotation</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to determine when to generate new data encryption keys - time-based, usage-based, or administrative triggers</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Fixed time intervals (daily/weekly/monthly)</li>\n<li>Usage count thresholds (encrypt N secrets then rotate)</li>\n<li>Hybrid approach with maximum time and usage limits</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hybrid approach with 30-day maximum lifetime and 10,000 encryption maximum</li>\n<li><strong>Rationale</strong>: Time limits prevent indefinite key usage, usage limits prevent single key from encrypting too much data, hybrid provides flexibility for both high and low volume environments</li>\n<li><strong>Consequences</strong>: Requires tracking both time and usage metrics, provides defense against both long-term cryptanalysis and high-volume attacks</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Rotation Trigger</th>\n<th>Threshold</th>\n<th>Action Taken</th>\n<th>Backward Compatibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Time Limit</td>\n<td>30 days since creation</td>\n<td>Generate new active DEK, mark current as retired</td>\n<td>Retired DEKs remain available for decryption</td>\n</tr>\n<tr>\n<td>Usage Limit</td>\n<td>10,000 encryptions</td>\n<td>Generate new active DEK, mark current as retired</td>\n<td>All previous versions remain accessible</td>\n</tr>\n<tr>\n<td>Compromise Detection</td>\n<td>Administrative command</td>\n<td>Immediately revoke DEK, generate replacement</td>\n<td>Revoked DEK blocked, secrets must be re-encrypted</td>\n</tr>\n<tr>\n<td>Master Key Rotation</td>\n<td>Administrative command</td>\n<td>Re-encrypt all DEKs with new master key</td>\n<td>Transparent to secret access, versions preserved</td>\n</tr>\n</tbody></table>\n<p><strong>Key rotation algorithms</strong> implement careful state management to prevent data loss during transitions. The rotation process follows these steps:</p>\n<ol>\n<li><strong>Pre-rotation validation</strong> - verify the current active DEK exists and system is in healthy state</li>\n<li><strong>New DEK generation</strong> - create new 256-bit key using secure random generator and assign next version number</li>\n<li><strong>Master key encryption</strong> - encrypt the new DEK with current master key and store encrypted version</li>\n<li><strong>Atomic state transition</strong> - update the active DEK pointer and mark previous DEK as retired in a single transaction</li>\n<li><strong>Background cleanup</strong> - optionally re-encrypt old secrets with new DEK based on policy configuration</li>\n<li><strong>Audit logging</strong> - record rotation event with timestamps, versions, and triggering conditions</li>\n</ol>\n<p>The rotation process must handle <strong>concurrent operations gracefully</strong>. During rotation, in-flight encrypt operations complete with the DEK they started with, while new encrypt operations wait for rotation completion before proceeding with the new DEK. Decrypt operations are unaffected since they specify the exact DEK version needed.</p>\n<h3 id=\"encryptdecrypt-operations\">Encrypt/Decrypt Operations</h3>\n<p>The <strong>envelope encryption algorithm</strong> implements a carefully orchestrated sequence that ensures both security and performance. Each encryption operation must produce ciphertext that can be decrypted later, track all necessary metadata for the decryption process, and maintain compatibility with secret versioning and key rotation.</p>\n<p><strong>Secret Encryption Process:</strong></p>\n<ol>\n<li><strong>Input validation and preprocessing</strong> - verify the secret path is valid, check secret length limits, and normalize the plaintext data for encryption</li>\n<li><strong>DEK selection</strong> - identify the current active data encryption key version and retrieve the decrypted DEK from secure memory cache</li>\n<li><strong>Nonce generation</strong> - create a 96-bit cryptographically random nonce using the system&#39;s secure random number generator</li>\n<li><strong>Associated data preparation</strong> - construct authenticated additional data including secret path, version number, timestamp, and DEK version</li>\n<li><strong>AES-GCM encryption</strong> - encrypt the plaintext secret using AES-256-GCM with the selected DEK, nonce, and associated data</li>\n<li><strong>Metadata packaging</strong> - bundle the ciphertext, nonce, associated data, DEK version, and algorithm identifier for storage</li>\n<li><strong>Storage preparation</strong> - serialize the complete encryption package and compute integrity checksums for corruption detection</li>\n</ol>\n<p>The encryption operation produces a <code>SecretVersion</code> structure that contains all information needed for future decryption. The ciphertext itself is opaque, but the metadata provides versioning, integrity checking, and key identification without revealing the secret content.</p>\n<table>\n<thead>\n<tr>\n<th>Encryption Output Field</th>\n<th>Source</th>\n<th>Purpose</th>\n<th>Security Properties</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>EncryptedValue</code></td>\n<td>AES-GCM ciphertext</td>\n<td>Encrypted secret data</td>\n<td>Confidentiality via AES-256</td>\n</tr>\n<tr>\n<td><code>Nonce</code></td>\n<td>Secure random generator</td>\n<td>GCM initialization vector</td>\n<td>Prevents ciphertext reuse</td>\n</tr>\n<tr>\n<td><code>AuthData</code></td>\n<td>Path + version + timestamp</td>\n<td>Authenticated context</td>\n<td>Prevents ciphertext substitution</td>\n</tr>\n<tr>\n<td><code>KeyVersion</code></td>\n<td>Current active DEK</td>\n<td>Identifies decryption key</td>\n<td>Supports key rotation</td>\n</tr>\n<tr>\n<td><code>Algorithm</code></td>\n<td>Fixed &quot;AES-256-GCM&quot;</td>\n<td>Crypto algorithm identifier</td>\n<td>Enables future algorithm migration</td>\n</tr>\n<tr>\n<td><code>Checksum</code></td>\n<td>SHA-256 of complete package</td>\n<td>Corruption detection</td>\n<td>Integrity verification</td>\n</tr>\n</tbody></table>\n<p><strong>Secret Decryption Process:</strong></p>\n<ol>\n<li><strong>Metadata extraction</strong> - parse the stored <code>SecretVersion</code> to extract DEK version, nonce, associated data, and algorithm identifier</li>\n<li><strong>DEK retrieval</strong> - locate the specified DEK version, decrypt it with the master key if not cached, and verify the DEK is not revoked</li>\n<li><strong>Algorithm verification</strong> - confirm the encryption algorithm is supported and matches expected security parameters</li>\n<li><strong>Associated data reconstruction</strong> - rebuild the authenticated additional data using the same process as encryption</li>\n<li><strong>AES-GCM decryption</strong> - decrypt the ciphertext using AES-256-GCM with the retrieved DEK, stored nonce, and reconstructed associated data</li>\n<li><strong>Integrity verification</strong> - validate the authentication tag and verify the overall package checksum to detect corruption</li>\n<li><strong>Plaintext return</strong> - return the decrypted secret data and clear sensitive values from memory</li>\n</ol>\n<p>The decryption process must handle <strong>version compatibility</strong> across key rotations and system upgrades. Each <code>SecretVersion</code> is self-contained with all metadata needed for decryption, ensuring that secrets encrypted months ago can still be decrypted even after multiple key rotations.</p>\n<blockquote>\n<p><strong>Critical Implementation Detail</strong>: The associated data must be reconstructed identically during decryption. Any variation in path normalization, timestamp formatting, or version numbering will cause authentication failures that prevent decryption.</p>\n</blockquote>\n<p><strong>Performance optimization</strong> strategies focus on the expensive cryptographic operations. The system maintains an <strong>in-memory DEK cache</strong> that keeps recently used decrypted DEKs available without requiring master key operations. The cache implements LRU eviction and automatic clearing when DEKs are rotated or revoked. Additionally, <strong>batch operations</strong> can reuse the same DEK for multiple secrets, reducing the per-secret encryption overhead.</p>\n<p><strong>Error handling</strong> during encryption and decryption operations requires careful consideration of information disclosure. Decryption failures should not reveal whether the failure was due to wrong DEK version, corrupted ciphertext, or authentication failures, as this information could aid attackers. Instead, all decryption failures return a generic &quot;decryption failed&quot; error while logging detailed failure reasons for administrative debugging.</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Success Indicators</th>\n<th>Failure Modes</th>\n<th>Error Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Encrypt</td>\n<td>Valid ciphertext + metadata</td>\n<td>DEK unavailable, RNG failure, storage error</td>\n<td>Specific error for debugging</td>\n</tr>\n<tr>\n<td>Decrypt</td>\n<td>Valid plaintext</td>\n<td>Wrong DEK, corrupt data, auth failure</td>\n<td>Generic &quot;decryption failed&quot;</td>\n</tr>\n<tr>\n<td>DEK Retrieve</td>\n<td>DEK in memory or successfully decrypted</td>\n<td>Master key unavailable, corrupted DEK</td>\n<td>Internal error, retry logic</td>\n</tr>\n<tr>\n<td>Nonce Generation</td>\n<td>96 bits of entropy</td>\n<td>RNG failure, insufficient entropy</td>\n<td>System error, operation blocked</td>\n</tr>\n</tbody></table>\n<h3 id=\"secret-versioning\">Secret Versioning</h3>\n<p><strong>Secret versioning</strong> implements a sophisticated system for maintaining historical secret values while supporting key rotation and data migration. Like a document version control system, each secret maintains multiple timestamped versions that can be retrieved independently while sharing common metadata and access policies.</p>\n<p>The versioning system must solve several complex challenges. <strong>Version immutability</strong> ensures that once a secret version is created, its encrypted content cannot be changed - only new versions can be added. <strong>Key rotation compatibility</strong> allows old versions encrypted with rotated keys to remain accessible. <strong>Storage efficiency</strong> prevents unlimited version accumulation from consuming excessive storage. <strong>Access control consistency</strong> ensures that policy changes apply uniformly across all versions of a secret.</p>\n<p>Each secret is represented by a <code>Secret</code> structure that acts as a container for multiple <code>SecretVersion</code> entries. The secret container maintains metadata that applies to all versions: creation timestamp, access policies, maximum version limits, and soft deletion status. Individual versions contain the encrypted data, encryption metadata, and version-specific attributes like TTL and creator identity.</p>\n<table>\n<thead>\n<tr>\n<th>Secret Container Field</th>\n<th>Purpose</th>\n<th>Version Scope</th>\n<th>Mutability</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Path</code></td>\n<td>Unique secret identifier</td>\n<td>All versions</td>\n<td>Immutable after creation</td>\n</tr>\n<tr>\n<td><code>CurrentVersion</code></td>\n<td>Latest version number</td>\n<td>Container-level</td>\n<td>Incremented on updates</td>\n</tr>\n<tr>\n<td><code>MaxVersions</code></td>\n<td>Version retention limit</td>\n<td>Container-level</td>\n<td>Configurable policy</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td>Initial secret creation</td>\n<td>Container-level</td>\n<td>Immutable</td>\n</tr>\n<tr>\n<td><code>UpdatedAt</code></td>\n<td>Last version addition</td>\n<td>Container-level</td>\n<td>Updated on new versions</td>\n</tr>\n<tr>\n<td><code>DeletedAt</code></td>\n<td>Soft deletion timestamp</td>\n<td>All versions</td>\n<td>Set once, prevents new versions</td>\n</tr>\n<tr>\n<td><code>Metadata</code></td>\n<td>User-defined key-value pairs</td>\n<td>All versions</td>\n<td>Mutable via policy</td>\n</tr>\n</tbody></table>\n<p>The <strong>version lifecycle</strong> follows a strict progression from creation through active use to eventual cleanup. New versions receive sequential numbers starting from 1, ensuring a total ordering of all changes to the secret. The system maintains a <strong>current version pointer</strong> that identifies the latest version returned for unqualified read operations, while allowing explicit access to any historical version by number.</p>\n<p><strong>Version creation process</strong> implements atomic operations that prevent partial updates and ensure consistency:</p>\n<ol>\n<li><strong>Concurrency control</strong> - acquire write lock on the secret path to prevent concurrent version creation</li>\n<li><strong>Validation checks</strong> - verify the secret exists, is not soft-deleted, and has not reached the maximum version limit</li>\n<li><strong>Version number assignment</strong> - increment the current version counter and assign the new number atomically</li>\n<li><strong>Encryption operation</strong> - encrypt the new secret value using current active DEK and create <code>SecretVersion</code> structure</li>\n<li><strong>Storage transaction</strong> - store the new version and update container metadata in a single atomic operation</li>\n<li><strong>Index updates</strong> - update secondary indexes for version lookup and ensure audit log entries are created</li>\n<li><strong>Cleanup trigger</strong> - if versions exceed the maximum limit, schedule background cleanup of oldest versions</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Sequential Version Numbering vs UUID-Based Versions</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to uniquely identify secret versions while supporting efficient lookup and ordering</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Sequential integers (1, 2, 3, ...)</li>\n<li>UUID-based version identifiers</li>\n<li>Timestamp-based version numbers</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Sequential integers with atomic increment</li>\n<li><strong>Rationale</strong>: Provides natural ordering, enables efficient &quot;latest N versions&quot; queries, simplifies client usage patterns, and avoids clock synchronization issues in distributed deployments</li>\n<li><strong>Consequences</strong>: Requires atomic counter management, reveals version creation frequency, but provides predictable and efficient access patterns</li>\n</ul>\n</blockquote>\n<p><strong>Key rotation impact on versioning</strong> requires careful coordination between the encryption engine and version management. When DEKs are rotated, existing secret versions remain encrypted with their original keys, creating a dependency between version lifetime and key lifetime. The system must ensure that DEK versions remain available for decryption as long as any secret version depends on them.</p>\n<p>The system implements <strong>lazy re-encryption</strong> policies that allow administrators to migrate old secret versions to new keys without impacting system availability. Background processes can iterate through old versions, decrypt them with their original keys, and re-encrypt with current keys while preserving version numbers and metadata.</p>\n<table>\n<thead>\n<tr>\n<th>Re-encryption Policy</th>\n<th>Trigger Conditions</th>\n<th>Process</th>\n<th>Version Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Immediate</td>\n<td>DEK compromise detected</td>\n<td>Re-encrypt all affected versions synchronously</td>\n<td>Version numbers preserved, new encryption metadata</td>\n</tr>\n<tr>\n<td>Background Lazy</td>\n<td>DEK reaches retirement age</td>\n<td>Queue versions for background re-encryption</td>\n<td>Transparent to clients, gradual migration</td>\n</tr>\n<tr>\n<td>On-Access</td>\n<td>Version accessed after DEK retirement</td>\n<td>Re-encrypt during read operation if policy allows</td>\n<td>Single version updated on demand</td>\n</tr>\n<tr>\n<td>Manual</td>\n<td>Administrative command</td>\n<td>Re-encrypt specified secret or version range</td>\n<td>Controlled timing, batch operations</td>\n</tr>\n</tbody></table>\n<p><strong>Version cleanup and retention</strong> policies prevent unlimited storage growth while preserving important historical data. The system supports multiple retention strategies that can be combined based on organizational requirements.</p>\n<p>Default retention keeps the most recent 10 versions of each secret, automatically cleaning up older versions when new ones are created. <strong>Time-based retention</strong> deletes versions older than a specified age, while <strong>usage-based retention</strong> preserves frequently accessed versions regardless of age. <strong>Compliance retention</strong> can mark specific versions as immutable for regulatory requirements.</p>\n<p>The cleanup process implements <strong>safe deletion</strong> that ensures versions are not removed while they might be needed for decryption or audit purposes. Before deleting a version, the system verifies that no active leases reference it, no pending operations depend on it, and the retention policy explicitly allows its removal.</p>\n<p>⚠️ <strong>Pitfall: Version Cleanup During Key Rotation</strong>\nDeleting secret versions before their associated DEKs can create permanent data loss. If a secret version is deleted but its DEK is retained for other versions, there&#39;s no issue. However, if the DEK is deleted while secret versions still reference it, those versions become permanently undecryptable. The system must maintain reference counts from secret versions to DEK versions and prevent DEK deletion while references exist.</p>\n<p><strong>Version access patterns</strong> support both specific version retrieval and version-relative access. Clients can request version 5 of a secret explicitly, ask for the current version (default behavior), or use relative references like &quot;previous version&quot; or &quot;version from 24 hours ago&quot;. The system translates these relative references into specific version numbers before processing the request.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Master Key in Swap Space</strong>\nStoring the master key in regular memory variables allows the operating system to page that memory to disk swap files, where it persists after the process exits. An attacker with disk access could extract the master key from swap space. Use memory locking syscalls (<code>mlock</code> on Unix systems) to prevent sensitive memory pages from being swapped to disk, and explicitly zero memory before freeing it.</p>\n<p>⚠️ <strong>Pitfall: DEK Version Race Conditions</strong>\nWhen rotating DEKs, concurrent encryption operations might start with one DEK version but complete with metadata pointing to a different version, creating decryption failures. Always capture the DEK version at the start of the encryption operation and use that same version throughout the entire process. Implement proper locking to ensure version transitions are atomic from the perspective of concurrent operations.</p>\n<p>⚠️ <strong>Pitfall: Nonce Reuse Attacks</strong>\nReusing the same nonce with the same DEK completely breaks AES-GCM security, allowing attackers to recover plaintext or forge authenticated data. This can happen if the random number generator fails, if system clocks reset during nonce generation, or if DEK rotation doesn&#39;t properly coordinate with nonce generation. Always use a cryptographically secure random number generator for nonce creation, and consider including timestamp or counter components in nonce generation for additional protection.</p>\n<p>⚠️ <strong>Pitfall: Associated Data Inconsistency</strong>\nAES-GCM associated data must be identical between encryption and decryption, but subtle differences in path normalization, timestamp formatting, or metadata serialization can cause authentication failures. For example, storing paths as <code>/secret/app/db</code> during encryption but reconstructing as <code>secret/app/db</code> during decryption will fail authentication. Establish strict canonicalization rules for all associated data components and implement comprehensive test cases covering various input formats.</p>\n<p>⚠️ <strong>Pitfall: Version Number Overflow</strong>\nUsing fixed-size integers for version numbers can cause overflow after many updates, potentially wrapping around to previously used version numbers and causing conflicts. While 64-bit integers provide enormous capacity (9 quintillion versions), consider the implications of long-lived secrets in high-update environments. Implement monitoring for version number consumption and establish procedures for secret migration before overflow occurs.</p>\n<p>⚠️ <strong>Pitfall: Incomplete Cleanup on Errors</strong>\nIf encryption operations fail partway through (e.g., after generating the DEK but before storing the encrypted secret), sensitive data may remain in memory or temporary storage. Similarly, failed decryption operations might leave partially decrypted data accessible. Implement comprehensive cleanup using <code>defer</code> statements or similar mechanisms to ensure sensitive data is zeroed from memory regardless of operation outcome.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This implementation guidance provides the foundational encryption engine that handles envelope encryption, key management, and secret versioning. The core learning challenge is implementing the envelope encryption algorithm correctly while managing the complexity of key rotation and version compatibility.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Encryption</td>\n<td>Go crypto/aes + crypto/cipher (GCM)</td>\n<td>Hardware security modules (HSM)</td>\n</tr>\n<tr>\n<td>Key Storage</td>\n<td>Encrypted files with proper permissions</td>\n<td>Cloud KMS integration (AWS KMS, GCP KMS)</td>\n</tr>\n<tr>\n<td>Random Generation</td>\n<td>crypto/rand.Reader</td>\n<td>Hardware entropy sources</td>\n</tr>\n<tr>\n<td>Memory Security</td>\n<td>Manual zeroing with explicit loops</td>\n<td>Memory protection libraries</td>\n</tr>\n<tr>\n<td>Key Derivation</td>\n<td>crypto/pbkdf2 for password-based keys</td>\n<td>Argon2 with tuned parameters</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/encryption/\n  engine.go              ← main encryption engine\n  envelope.go            ← envelope encryption implementation\n  keys.go                ← DEK management and rotation\n  versioning.go          ← secret versioning logic\n  engine_test.go         ← comprehensive test suite\n  testdata/\n    test_secrets.json    ← test vectors for crypto operations\ninternal/storage/\n  backend.go             ← storage interface\n  memory.go              ← in-memory backend for development\ncmd/vault/\n  main.go                ← server entry point</code></pre></div>\n\n<p><strong>Infrastructure Starter Code (Complete and Ready to Use):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/encryption/crypto_utils.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> encryption</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/rand</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/sha256</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/subtle</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">io</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SecureRandom provides cryptographically secure random bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SecureRandom</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    source </span><span style=\"color:#B392F0\">io</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Reader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewSecureRandom</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecureRandom</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">SecureRandom</span><span style=\"color:#E1E4E8\">{source: rand.Reader}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sr </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecureRandom</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateKey</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">size</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    key </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, size)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> io.</span><span style=\"color:#B392F0\">ReadFull</span><span style=\"color:#E1E4E8\">(sr.source, key); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to generate random key: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> key, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sr </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecureRandom</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateNonce</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">size</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nonce </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, size)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> io.</span><span style=\"color:#B392F0\">ReadFull</span><span style=\"color:#E1E4E8\">(sr.source, nonce); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to generate random nonce: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> nonce, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SecureMemory provides utilities for secure memory handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SecureMemory</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecureMemory</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Zero</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> data {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        data[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecureMemory</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Compare</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> subtle.</span><span style=\"color:#B392F0\">ConstantTimeCompare</span><span style=\"color:#E1E4E8\">(a, b) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecureMemory</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ComputeChecksum</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hash </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sha256.</span><span style=\"color:#B392F0\">Sum256</span><span style=\"color:#E1E4E8\">(data)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> hash[:]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// KeyDerivation provides password-based key derivation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> KeyDerivation</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    iterations </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    saltSize   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewKeyDerivation</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">KeyDerivation</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">KeyDerivation</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        iterations: </span><span style=\"color:#79B8FF\">480000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// OWASP recommended minimum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        saltSize:   </span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">,     </span><span style=\"color:#6A737D\">// 256 bits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">kd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">KeyDerivation</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DeriveKey</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">password</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">salt</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">keySize</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Implementation would use golang.org/x/crypto/pbkdf2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This is a placeholder - implement PBKDF2 derivation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, keySize) </span><span style=\"color:#6A737D\">// TODO: Implement PBKDF2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton (Students Implement These):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/encryption/engine.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> encryption</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/aes</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/cipher</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Engine manages envelope encryption for the secret management system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Engine</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    masterKey      []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    keyVersion     </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dekCache       </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DataEncryptionKey</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentDEK     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DataEncryptionKey</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    random         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecureRandom</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    memory         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecureMemory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rotationPolicy </span><span style=\"color:#B392F0\">RotationPolicy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RotationPolicy</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxAge        </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxUsageCount </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AutoRotate    </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewEngine creates a new encryption engine with the specified master key</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewEngine</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">masterKey</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">policy</span><span style=\"color:#B392F0\"> RotationPolicy</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(masterKey) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> AES_KEY_SIZE {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"master key must be </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">, AES_KEY_SIZE)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize the engine with copied master key (don't store reference)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create secure random and memory utilities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize DEK cache and generate initial DEK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Set up rotation policy and start background rotation if enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use copy() to safely copy the master key into engine memory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EncryptSecret encrypts a secret using envelope encryption</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">EncryptSecret</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">plaintext</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">secretPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">version</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretVersion</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate input parameters (non-nil plaintext, valid path)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Acquire read lock and get current active DEK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Generate cryptographically secure nonce using e.random</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Construct associated data (path + version + timestamp + DEK version)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Create AES-GCM cipher using DEK and encrypt with associated data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Increment DEK usage count and check if rotation is needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Create SecretVersion with all encryption metadata and checksum</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use json.Marshal for consistent associated data serialization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DecryptSecret decrypts a secret using envelope encryption</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DecryptSecret</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">secretVersion</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">SecretVersion</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate secret version has required fields (EncryptedValue, KeyVersion, Nonce)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Retrieve the DEK for the specified version (check cache first)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify the encryption algorithm matches what we support</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Reconstruct associated data using same process as encryption</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Create AES-GCM cipher and decrypt with associated data verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify overall package checksum to detect corruption</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return plaintext and zero sensitive intermediate values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Authentication failures should return generic errors, not specific causes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateDataEncryptionKey creates a new DEK encrypted with the master key</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateDataEncryptionKey</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">version</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DataEncryptionKey</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate new 256-bit random key using secure random generator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create AES cipher using master key for DEK encryption</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Generate nonce for master key encryption of DEK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Encrypt the new DEK using AES-GCM with master key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Create DataEncryptionKey struct with encrypted DEK and metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Set status to \"active\" and initialize usage counter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Zero the plaintext DEK from memory before returning</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Store creation timestamp for rotation policy decisions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RotateDataEncryptionKey creates new DEK and marks current as retired</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RotateDataEncryptionKey</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire write lock to prevent concurrent rotation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Generate new DEK with incremented version number</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add new DEK to cache and update current DEK pointer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Mark previous DEK as \"retired\" but keep in cache</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Log rotation event with timestamps and version numbers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Optionally trigger background re-encryption of old secrets</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update rotation metrics and schedule next rotation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use atomic operations for DEK pointer updates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetDEKForVersion retrieves and decrypts DEK for specified version</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetDEKForVersion</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">version</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check DEK cache for requested version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If not cached, verify DEK exists and is not revoked</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create AES-GCM cipher using master key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Decrypt the stored encrypted DEK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Add decrypted DEK to cache with LRU eviction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return decrypted DEK (caller must zero when done)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Implement cache eviction when cache size exceeds limit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Shutdown securely cleans up the encryption engine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Shutdown</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire write lock to prevent new operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Zero master key from memory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Zero all cached DEKs from memory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Clear DEK cache and reset pointers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Stop any background rotation processes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Log shutdown event for audit trail</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use e.memory.Zero() to securely clear byte slices</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints:</strong></p>\n<ul>\n<li>Use <code>crypto/aes</code> and <code>crypto/cipher</code> packages for AES-GCM implementation</li>\n<li>Always check <code>cipher.NewGCM()</code> errors - some AES implementations don&#39;t support GCM</li>\n<li>Use <code>defer</code> statements to ensure sensitive memory is zeroed even on early returns</li>\n<li>The <code>sync.RWMutex</code> allows multiple concurrent decryptions but exclusive encryption</li>\n<li>Use <code>encoding/json.Marshal</code> for consistent associated data serialization</li>\n<li>Check random number generation errors - they indicate serious system problems</li>\n<li>Use <code>copy()</code> to safely duplicate byte slices containing sensitive data</li>\n</ul>\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing the encryption engine, verify the following behavior:</p>\n<ol>\n<li><strong>Basic Encryption Test</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/encryption/</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestBasicEncryption</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>   Expected: Encrypt and decrypt a simple secret successfully</p>\n<ol start=\"2\">\n<li><strong>Key Rotation Test</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/encryption/</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestKeyRotation</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>   Expected: Rotate DEK and decrypt old secrets with retired key</p>\n<ol start=\"3\">\n<li><strong>Version Management Test</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/encryption/</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestVersioning</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>   Expected: Create multiple secret versions and retrieve specific versions</p>\n<ol start=\"4\">\n<li><strong>Manual Testing</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   // Create test program in cmd/test-encryption/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   engine, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewEngine</span><span style=\"color:#E1E4E8\">(masterKey, policy)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   secretVersion, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> engine.</span><span style=\"color:#B392F0\">EncryptSecret</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"test-secret\"</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#9ECBFF\">\"/app/db\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   plaintext, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> engine.</span><span style=\"color:#B392F0\">DecryptSecret</span><span style=\"color:#E1E4E8\">(secretVersion)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   // plaintext should equal []byte(\"test-secret\")</span></span></code></pre></div>\n\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;cipher: message authentication failed&quot;</td>\n<td>Associated data mismatch between encrypt/decrypt</td>\n<td>Log associated data on both operations</td>\n<td>Ensure identical path/version/timestamp formatting</td>\n</tr>\n<tr>\n<td>&quot;DEK not found for version X&quot;</td>\n<td>Key rotation deleted DEK while secrets still reference it</td>\n<td>Check DEK cache contents and version references</td>\n<td>Implement reference counting for DEK cleanup</td>\n</tr>\n<tr>\n<td>Memory corruption or segfaults</td>\n<td>Not zeroing sensitive data after use</td>\n<td>Run with race detector: <code>go test -race</code></td>\n<td>Add defer statements to zero byte slices</td>\n</tr>\n<tr>\n<td>Slow encryption performance</td>\n<td>Regenerating DEKs on every operation</td>\n<td>Profile with <code>go test -cpuprofile=cpu.prof</code></td>\n<td>Implement DEK caching and reuse</td>\n</tr>\n<tr>\n<td>Nonce collision errors</td>\n<td>Weak random number generator or clock issues</td>\n<td>Test RNG quality with statistical tests</td>\n<td>Use crypto/rand.Reader and verify system entropy</td>\n</tr>\n</tbody></table>\n<h2 id=\"authentication-and-policy-engine\">Authentication and Policy Engine</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section implements Milestone 2 (Access Policies &amp; Authentication), focusing on path-based ACLs, multiple authentication methods, policy evaluation, and comprehensive audit logging.</p>\n</blockquote>\n<p>Think of authentication and authorization like a corporate badge system combined with a sophisticated building access control system. When you arrive at work, you first prove your identity by swiping your badge (authentication), then the system checks which floors, rooms, and resources your role allows you to access (authorization). The security desk maintains logs of every badge swipe and access attempt (audit logging). Our secret management system works similarly — clients must first prove their identity through tokens or certificates, then the system evaluates whether their assigned policies grant access to the requested secret path.</p>\n<p>The authentication and policy engine serves as the <strong>gatekeeper</strong> for our secret management system, implementing a zero-trust security model where every request must be authenticated and authorized before accessing any secrets. This engine consists of four interconnected subsystems: authentication methods that verify client identity, a policy definition language that specifies access rules, an authorization engine that evaluates requests against policies, and comprehensive audit logging that tracks every access attempt for security monitoring.</p>\n<h3 id=\"authentication-methods\">Authentication Methods</h3>\n<p>The authentication subsystem implements multiple methods for clients to prove their identity, similar to how a high-security facility might accept both employee badges and visitor certificates. Each authentication method produces a verified identity that the authorization engine can evaluate against policies.</p>\n<p><strong>Token-Based Authentication</strong> serves as our primary authentication method, functioning like a corporate access card that employees carry. When a client successfully authenticates through any method, the system issues a <strong>bearer token</strong> — a cryptographically signed identifier that proves the client&#39;s authenticated identity without requiring them to re-authenticate for subsequent requests.</p>\n<p>The token structure contains essential identity and authorization information:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ID</code></td>\n<td><code>string</code></td>\n<td>Unique token identifier for lookups and revocation</td>\n</tr>\n<tr>\n<td><code>Accessor</code></td>\n<td><code>string</code></td>\n<td>Public handle for token management without exposing ID</td>\n</tr>\n<tr>\n<td><code>Policies</code></td>\n<td><code>[]string</code></td>\n<td>List of policy names attached to this token</td>\n</tr>\n<tr>\n<td><code>TokenType</code></td>\n<td><code>string</code></td>\n<td>Either &quot;service&quot; for long-lived or &quot;batch&quot; for short-lived</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Token creation timestamp for audit trails</td>\n</tr>\n<tr>\n<td><code>ExpiresAt</code></td>\n<td><code>*time.Time</code></td>\n<td>Optional expiration time (nil for non-expiring tokens)</td>\n</tr>\n<tr>\n<td><code>LastUsedAt</code></td>\n<td><code>*time.Time</code></td>\n<td>Most recent usage timestamp for activity monitoring</td>\n</tr>\n<tr>\n<td><code>UsageCount</code></td>\n<td><code>int64</code></td>\n<td>Number of times token has been used</td>\n</tr>\n<tr>\n<td><code>MaxUses</code></td>\n<td><code>int</code></td>\n<td>Maximum allowed uses before token expires (0 for unlimited)</td>\n</tr>\n<tr>\n<td><code>Renewable</code></td>\n<td><code>bool</code></td>\n<td>Whether token can have its TTL extended</td>\n</tr>\n<tr>\n<td><code>ParentToken</code></td>\n<td><code>string</code></td>\n<td>Token that created this token (for hierarchical revocation)</td>\n</tr>\n<tr>\n<td><code>DisplayName</code></td>\n<td><code>string</code></td>\n<td>Human-readable identifier for audit logs</td>\n</tr>\n<tr>\n<td><code>Metadata</code></td>\n<td><code>map[string]string</code></td>\n<td>Additional context about token creation</td>\n</tr>\n<tr>\n<td><code>BoundCIDRs</code></td>\n<td><code>[]string</code></td>\n<td>IP address restrictions for token usage</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Bearer Token Authentication</strong></p>\n<ul>\n<li><strong>Context</strong>: Clients need to authenticate repeatedly for secret access, but re-authentication for every request creates performance bottlenecks and user experience problems</li>\n<li><strong>Options Considered</strong>: HTTP Basic Auth, JWT tokens, custom bearer tokens</li>\n<li><strong>Decision</strong>: Custom bearer tokens with server-side state</li>\n<li><strong>Rationale</strong>: Unlike stateless JWTs, server-side tokens allow immediate revocation and detailed usage tracking. Basic Auth would require credential transmission on every request</li>\n<li><strong>Consequences</strong>: Enables immediate token revocation and comprehensive audit trails, but requires server-side token storage and lookup overhead</li>\n</ul>\n</blockquote>\n<p><strong>Mutual TLS (mTLS) Authentication</strong> provides our strongest authentication method, similar to how diplomatic facilities require both photo identification and biometric verification. In mTLS, both the client and server present X.509 certificates to each other, creating a cryptographically verified bidirectional trust relationship.</p>\n<p>The mTLS authentication flow operates through these steps:</p>\n<ol>\n<li>Client initiates TLS connection to the secret management server</li>\n<li>Server presents its certificate to prove server identity</li>\n<li>Server requests client certificate as part of TLS handshake</li>\n<li>Client presents its certificate signed by a trusted Certificate Authority</li>\n<li>Server validates client certificate chain, expiration, and revocation status</li>\n<li>Server extracts identity information from certificate Common Name or Subject Alternative Names</li>\n<li>Server issues a bearer token bound to the certificate identity for subsequent API calls</li>\n</ol>\n<p>The identity structure captures authenticated client information regardless of authentication method:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ID</code></td>\n<td><code>string</code></td>\n<td>Unique identity identifier across all auth methods</td>\n</tr>\n<tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>Human-readable name (certificate CN, username, etc.)</td>\n</tr>\n<tr>\n<td><code>Type</code></td>\n<td><code>string</code></td>\n<td>Identity type: &quot;certificate&quot;, &quot;user&quot;, &quot;service&quot;, etc.</td>\n</tr>\n<tr>\n<td><code>AuthMethod</code></td>\n<td><code>string</code></td>\n<td>Which authentication method verified this identity</td>\n</tr>\n<tr>\n<td><code>Policies</code></td>\n<td><code>[]string</code></td>\n<td>Default policies assigned to this identity</td>\n</tr>\n<tr>\n<td><code>Groups</code></td>\n<td><code>[]string</code></td>\n<td>Group memberships for policy inheritance</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>When identity was first registered</td>\n</tr>\n<tr>\n<td><code>LastAuthAt</code></td>\n<td><code>*time.Time</code></td>\n<td>Most recent authentication timestamp</td>\n</tr>\n<tr>\n<td><code>AuthCount</code></td>\n<td><code>int64</code></td>\n<td>Total number of authentication attempts</td>\n</tr>\n<tr>\n<td><code>Metadata</code></td>\n<td><code>map[string]string</code></td>\n<td>Auth-method-specific context (certificate fingerprint, etc.)</td>\n</tr>\n<tr>\n<td><code>Disabled</code></td>\n<td><code>bool</code></td>\n<td>Whether identity is administratively disabled</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The critical security insight here is that authentication only establishes <strong>who</strong> the client is, not <strong>what</strong> they can access. The authentication engine&#39;s job ends once it produces a verified identity — the authorization engine handles all access control decisions based on that identity.</p>\n</blockquote>\n<p><strong>AppRole Authentication</strong> provides a specialized method designed for applications and services rather than human users. Think of AppRole like a combination of an application ID and a temporary access code — the application proves it knows both pieces of information to authenticate.</p>\n<p>AppRole authentication uses two credentials:</p>\n<ul>\n<li><strong>Role ID</strong>: A public identifier that specifies which application role the client claims</li>\n<li><strong>Secret ID</strong>: A private, time-limited credential that proves the client is authorized to assume that role</li>\n</ul>\n<p>This two-factor approach prevents common application security mistakes where developers embed long-lived credentials directly in application code. The Role ID can be embedded in configuration files or environment variables, while the Secret ID must be delivered through a separate, secure channel (such as a deployment system or init container).</p>\n<p>⚠️ <strong>Pitfall: Secret ID Distribution</strong>\nMany developers try to solve the Secret ID distribution problem by embedding both Role ID and Secret ID in the same configuration file or environment variables. This defeats the security purpose of AppRole authentication. The Secret ID must be delivered through a separate mechanism — ideally one that provides it just-in-time during application startup and doesn&#39;t persist it to disk.</p>\n<h3 id=\"policy-definition-language\">Policy Definition Language</h3>\n<p>The policy definition language provides a declarative way to specify <strong>what</strong> authenticated identities can access, using a path-based access control model similar to filesystem permissions but designed specifically for hierarchical secret storage.</p>\n<p><strong>Path-Based Access Control</strong> treats secrets like files in a directory tree, where policies specify access rules for path patterns. Think of this like building security where your badge might grant access to &quot;all rooms on floor 3&quot; or &quot;any conference room&quot; rather than having to list every specific room individually.</p>\n<p>A policy consists of one or more rules, where each rule specifies:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>Unique policy identifier for assignment to tokens/identities</td>\n</tr>\n<tr>\n<td><code>Rules</code></td>\n<td><code>[]PolicyRule</code></td>\n<td>Ordered list of access rules evaluated sequentially</td>\n</tr>\n<tr>\n<td><code>Description</code></td>\n<td><code>string</code></td>\n<td>Human-readable policy purpose documentation</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Policy creation timestamp for audit trails</td>\n</tr>\n<tr>\n<td><code>UpdatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Most recent policy modification timestamp</td>\n</tr>\n<tr>\n<td><code>CreatedBy</code></td>\n<td><code>string</code></td>\n<td>Identity that created this policy</td>\n</tr>\n<tr>\n<td><code>Version</code></td>\n<td><code>int</code></td>\n<td>Policy version number for change tracking</td>\n</tr>\n</tbody></table>\n<p>Each policy rule defines fine-grained access controls for specific path patterns:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Path</code></td>\n<td><code>string</code></td>\n<td>Secret path pattern with wildcards (* for segment, ** for recursive)</td>\n</tr>\n<tr>\n<td><code>Capabilities</code></td>\n<td><code>[]string</code></td>\n<td>Allowed operations: &quot;read&quot;, &quot;create&quot;, &quot;update&quot;, &quot;delete&quot;, &quot;list&quot;</td>\n</tr>\n<tr>\n<td><code>RequiredParameters</code></td>\n<td><code>map[string][]string</code></td>\n<td>Request parameters that MUST be present with allowed values</td>\n</tr>\n<tr>\n<td><code>AllowedParameters</code></td>\n<td><code>map[string][]string</code></td>\n<td>Request parameters that MAY be present with allowed values</td>\n</tr>\n<tr>\n<td><code>DeniedParameters</code></td>\n<td><code>map[string][]string</code></td>\n<td>Request parameters that explicitly DENY access</td>\n</tr>\n<tr>\n<td><code>MaxTTL</code></td>\n<td><code>time.Duration</code></td>\n<td>Maximum TTL for dynamic secrets generated under this path</td>\n</tr>\n<tr>\n<td><code>MinWrappingTTL</code></td>\n<td><code>time.Duration</code></td>\n<td>Minimum TTL for secret wrapping responses</td>\n</tr>\n</tbody></table>\n<p><strong>Wildcard Pattern Matching</strong> enables flexible path-based access control without requiring explicit rules for every possible secret path. The system supports two wildcard types:</p>\n<ul>\n<li><strong>Single Segment Wildcard (<code>*</code>)</strong>: Matches exactly one path segment</li>\n<li><strong>Recursive Wildcard (<code>**</code>)</strong>: Matches zero or more path segments at any depth</li>\n</ul>\n<p>Examples of wildcard pattern matching:</p>\n<ul>\n<li><code>secret/team-alpha/*</code> matches <code>secret/team-alpha/database</code> but NOT <code>secret/team-alpha/env/prod</code></li>\n<li><code>secret/team-alpha/**</code> matches both <code>secret/team-alpha/database</code> AND <code>secret/team-alpha/env/prod</code></li>\n<li><code>secret/*/database</code> matches <code>secret/team-alpha/database</code> and <code>secret/team-beta/database</code></li>\n<li><code>secret/**/credentials</code> matches <code>secret/app1/credentials</code>, <code>secret/team/app1/credentials</code>, etc.</li>\n</ul>\n<blockquote>\n<p><strong>Decision: Path-Based Access Control with Wildcards</strong></p>\n<ul>\n<li><strong>Context</strong>: Applications need flexible access control that doesn&#39;t require updating policies every time new secrets are added, while maintaining security through least-privilege principles</li>\n<li><strong>Options Considered</strong>: Explicit path lists, regex patterns, glob-style wildcards</li>\n<li><strong>Decision</strong>: Glob-style wildcards with single (*) and recursive (**) patterns</li>\n<li><strong>Rationale</strong>: Glob patterns provide intuitive syntax familiar to developers while being more predictable than regex. Explicit lists don&#39;t scale for dynamic environments</li>\n<li><strong>Consequences</strong>: Enables scalable access control policies but requires careful wildcard design to prevent overly broad access grants</li>\n</ul>\n</blockquote>\n<p><strong>Capability-Based Operations</strong> define what actions an identity can perform on matched secret paths. The system implements five core capabilities:</p>\n<table>\n<thead>\n<tr>\n<th>Capability</th>\n<th>Description</th>\n<th>Required For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>read</code></td>\n<td>Retrieve secret values and metadata</td>\n<td><code>GET /v1/secret/data/path</code></td>\n</tr>\n<tr>\n<td><code>create</code></td>\n<td>Create new secrets at non-existing paths</td>\n<td><code>POST /v1/secret/data/path</code> (new paths only)</td>\n</tr>\n<tr>\n<td><code>update</code></td>\n<td>Modify existing secrets or create new versions</td>\n<td><code>POST /v1/secret/data/path</code> (existing paths)</td>\n</tr>\n<tr>\n<td><code>delete</code></td>\n<td>Soft-delete secrets and versions</td>\n<td><code>DELETE /v1/secret/data/path</code></td>\n</tr>\n<tr>\n<td><code>list</code></td>\n<td>Enumerate secret paths under a prefix</td>\n<td><code>LIST /v1/secret/metadata/path</code></td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Overly Broad Wildcard Patterns</strong>\nA common mistake is using patterns like <code>secret/**</code> with <code>[&quot;read&quot;, &quot;create&quot;, &quot;update&quot;, &quot;delete&quot;]</code> capabilities, which grants unlimited access to all secrets. This defeats the purpose of access control. Instead, design policies with narrow wildcard patterns that match the minimum necessary paths for each application&#39;s requirements.</p>\n<p><strong>Parameter-Based Constraints</strong> provide fine-grained control over request parameters, enabling policies to restrict not just what paths can be accessed, but how they can be accessed. This is particularly important for dynamic secrets where policy might allow database access but restrict which database roles can be requested.</p>\n<p>Example policy rule with parameter constraints:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Path: secret/database/**\nCapabilities: [&quot;read&quot;]\nRequiredParameters: \n  environment: [&quot;staging&quot;, &quot;production&quot;]\nAllowedParameters:\n  role: [&quot;readonly&quot;, &quot;readwrite&quot;] \n  ttl: [&quot;1h&quot;, &quot;8h&quot;, &quot;24h&quot;]\nDeniedParameters:\n  role: [&quot;admin&quot;, &quot;superuser&quot;]</code></pre></div>\n\n<p>This rule ensures that database secret requests must specify a valid environment, can optionally specify allowed roles and TTL values, but explicitly denies access to administrative database roles.</p>\n<h3 id=\"authorization-flow\">Authorization Flow</h3>\n<p>The authorization engine evaluates every authenticated request against the requester&#39;s assigned policies to make allow/deny decisions. Think of this like a security guard consulting multiple access lists to determine if an employee&#39;s badge grants access to a specific resource at a specific time.</p>\n<p><strong>Request Evaluation Pipeline</strong> processes every secret access request through a structured sequence of authorization checks:</p>\n<ol>\n<li><strong>Request Parsing</strong>: Extract the secret path, HTTP method, and request parameters from the incoming API call</li>\n<li><strong>Identity Resolution</strong>: Look up the authenticated identity associated with the request token</li>\n<li><strong>Policy Collection</strong>: Gather all policies assigned directly to the identity or inherited through group membership</li>\n<li><strong>Rule Matching</strong>: For each policy, find rules where the secret path matches the rule&#39;s path pattern</li>\n<li><strong>Capability Checking</strong>: Verify the requested operation (read/create/update/delete/list) is included in matching rule capabilities</li>\n<li><strong>Parameter Validation</strong>: Check request parameters against rule constraints (required/allowed/denied parameters)</li>\n<li><strong>Decision Aggregation</strong>: Combine results from all matching rules to produce final allow/deny decision</li>\n<li><strong>Audit Logging</strong>: Record the authorization decision with full context for security monitoring</li>\n</ol>\n<blockquote>\n<p>The authorization engine implements <strong>default deny</strong> behavior — if no policy rule explicitly allows an operation, the request is denied. This ensures that new secrets and paths are protected by default until policies explicitly grant access.</p>\n</blockquote>\n<p><strong>Policy Evaluation Algorithm</strong> determines access by finding the most permissive rule that matches the request path. The algorithm processes rules in the order they appear in policies, allowing more specific rules to override general patterns:</p>\n<ol>\n<li>Initialize decision as DENY and collect empty capability set</li>\n<li>For each policy assigned to the requesting identity:\na. For each rule in the policy (in order):\n   i. Check if request path matches rule path pattern using wildcard matching\n   ii. If path matches, check if requested operation is in rule capabilities\n   iii. If operation is allowed, validate all parameter constraints\n   iv. If all checks pass, update decision to ALLOW for this operation</li>\n<li>Return final decision based on whether any rule explicitly allowed the operation</li>\n</ol>\n<p><strong>Path Matching Implementation</strong> uses efficient prefix matching with wildcard support to minimize evaluation overhead for policies with hundreds of rules. The matching algorithm handles both single-segment (<code>*</code>) and recursive (<code>**</code>) wildcards:</p>\n<ol>\n<li>Split both rule path pattern and request path into segments using &quot;/&quot; delimiter</li>\n<li>Initialize pattern index and path index to 0</li>\n<li>While both indices are within their respective arrays:\na. If pattern segment is &quot;*&quot;, advance both indices by 1 (exact segment match)\nb. If pattern segment is &quot;**&quot;, find next non-wildcard pattern segment and skip path segments until match found\nc. If pattern segment is literal, compare with path segment for exact match\nd. If segments don&#39;t match, rule doesn&#39;t apply to this path</li>\n<li>Rule matches if both pattern and path are fully consumed or pattern ends with &quot;**&quot;</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Policy Rule Ordering</strong>\nThe order of rules within a policy matters because the engine evaluates them sequentially and stops at the first matching rule. A common mistake is placing broad wildcard patterns before more specific rules, causing the specific rules to never be evaluated. Always order rules from most specific to least specific within each policy.</p>\n<p><strong>Token Policy Inheritance</strong> allows tokens to inherit policies from multiple sources, providing flexible authorization models for different organizational structures. When evaluating a request, the authorization engine considers policies from:</p>\n<ol>\n<li><strong>Direct Token Policies</strong>: Policies explicitly assigned when the token was created</li>\n<li><strong>Identity Policies</strong>: Default policies assigned to the authenticated identity</li>\n<li><strong>Group Policies</strong>: Policies inherited through group membership hierarchies</li>\n</ol>\n<p>The final authorization decision considers the union of all applicable policies — if any inherited policy grants access, the operation is allowed.</p>\n<h3 id=\"audit-logging\">Audit Logging</h3>\n<p>Comprehensive audit logging provides the security monitoring and compliance foundation for the secret management system. Think of audit logs like security camera recordings that capture every interaction with the vault, enabling forensic analysis of security incidents and demonstrating compliance with access control policies.</p>\n<p><strong>Audit Event Structure</strong> captures complete context for every interaction with the secret management system, ensuring security teams can reconstruct the full timeline of any security event:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Timestamp</code></td>\n<td><code>time.Time</code></td>\n<td>Precise event occurrence time in UTC</td>\n</tr>\n<tr>\n<td><code>RequestID</code></td>\n<td><code>string</code></td>\n<td>Unique identifier correlating related log entries</td>\n</tr>\n<tr>\n<td><code>EventType</code></td>\n<td><code>string</code></td>\n<td>Category: &quot;auth&quot;, &quot;secret&quot;, &quot;policy&quot;, &quot;admin&quot;</td>\n</tr>\n<tr>\n<td><code>Operation</code></td>\n<td><code>string</code></td>\n<td>Specific action: &quot;login&quot;, &quot;read&quot;, &quot;create&quot;, &quot;delete&quot;, etc.</td>\n</tr>\n<tr>\n<td><code>Path</code></td>\n<td><code>string</code></td>\n<td>Secret or resource path being accessed</td>\n</tr>\n<tr>\n<td><code>Identity</code></td>\n<td><code>string</code></td>\n<td>Authenticated identity performing the operation</td>\n</tr>\n<tr>\n<td><code>TokenID</code></td>\n<td><code>string</code></td>\n<td>Token accessor (not ID) for privacy</td>\n</tr>\n<tr>\n<td><code>AuthMethod</code></td>\n<td><code>string</code></td>\n<td>Authentication method used (&quot;token&quot;, &quot;tls-cert&quot;, &quot;approle&quot;)</td>\n</tr>\n<tr>\n<td><code>SourceIP</code></td>\n<td><code>string</code></td>\n<td>Client IP address for network-based analysis</td>\n</tr>\n<tr>\n<td><code>UserAgent</code></td>\n<td><code>string</code></td>\n<td>Client application identifier</td>\n</tr>\n<tr>\n<td><code>RequestMetadata</code></td>\n<td><code>map[string]interface{}</code></td>\n<td>Additional request context and parameters</td>\n</tr>\n<tr>\n<td><code>Result</code></td>\n<td><code>string</code></td>\n<td>Operation outcome: &quot;success&quot;, &quot;denied&quot;, &quot;error&quot;</td>\n</tr>\n<tr>\n<td><code>ErrorCode</code></td>\n<td><code>string</code></td>\n<td>Specific error code for failed operations</td>\n</tr>\n<tr>\n<td><code>ResponseMetadata</code></td>\n<td><code>map[string]interface{}</code></td>\n<td>Non-sensitive response context</td>\n</tr>\n<tr>\n<td><code>Duration</code></td>\n<td><code>time.Duration</code></td>\n<td>Request processing time for performance analysis</td>\n</tr>\n</tbody></table>\n<p><strong>Security Event Categories</strong> organize audit events into logical groups that align with common security monitoring and incident response workflows:</p>\n<table>\n<thead>\n<tr>\n<th>Event Type</th>\n<th>Operations</th>\n<th>Security Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>auth</code></td>\n<td>login, logout, token-create, token-revoke</td>\n<td>Track identity authentication and session management</td>\n</tr>\n<tr>\n<td><code>secret</code></td>\n<td>read, create, update, delete, list</td>\n<td>Monitor access to sensitive data and detect unauthorized attempts</td>\n</tr>\n<tr>\n<td><code>policy</code></td>\n<td>policy-create, policy-update, policy-delete</td>\n<td>Audit changes to access control rules</td>\n</tr>\n<tr>\n<td><code>admin</code></td>\n<td>unseal, seal, leader-election, backup</td>\n<td>Track administrative operations affecting system security</td>\n</tr>\n<tr>\n<td><code>dynamic</code></td>\n<td>lease-create, lease-renew, lease-revoke</td>\n<td>Monitor dynamic secret lifecycle for credential management</td>\n</tr>\n</tbody></table>\n<p><strong>Tamper-Evident Logging</strong> ensures audit logs cannot be modified or deleted by attackers who compromise the secret management system. The logging subsystem implements several protection mechanisms:</p>\n<ul>\n<li><strong>Append-Only Storage</strong>: Audit logs are written to append-only files or storage systems that prevent modification of existing entries</li>\n<li><strong>Remote Syslog</strong>: Critical events are immediately forwarded to external log collection systems outside the secret management infrastructure</li>\n<li><strong>Log Signing</strong>: Each audit entry includes a cryptographic signature that can detect tampering</li>\n<li><strong>Sequence Numbering</strong>: Monotonic sequence numbers enable detection of missing log entries</li>\n</ul>\n<blockquote>\n<p><strong>Decision: Structured JSON Audit Logging</strong></p>\n<ul>\n<li><strong>Context</strong>: Security teams need to correlate secret management events with other security data sources and must parse logs programmatically for threat detection</li>\n<li><strong>Options Considered</strong>: Plain text logs, structured JSON, binary format</li>\n<li><strong>Decision</strong>: Structured JSON with standardized field names</li>\n<li><strong>Rationale</strong>: JSON provides schema evolution and integrates easily with SIEM systems, log aggregators, and analysis tools. Plain text is hard to parse; binary format lacks tooling support</li>\n<li><strong>Consequences</strong>: Enables automated security analysis and correlation but requires more storage space than compact binary formats</li>\n</ul>\n</blockquote>\n<p><strong>Privacy and Compliance Considerations</strong> balance comprehensive security monitoring with protection of sensitive information. The audit logging system carefully excludes certain data from logs to prevent credential exposure:</p>\n<p>Never Logged:</p>\n<ul>\n<li>Actual secret values or encrypted content</li>\n<li>Full token IDs (only public accessors are logged)</li>\n<li>Sensitive request parameters like passwords or private keys</li>\n<li>Client certificate private keys or token secrets</li>\n</ul>\n<p>Always Logged:</p>\n<ul>\n<li>Secret paths and metadata (but not values)</li>\n<li>Authentication outcomes and identity information</li>\n<li>Authorization decisions and policy evaluations</li>\n<li>Error conditions and security violations</li>\n<li>Timing and performance metrics</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Logging Sensitive Data</strong>\nA common security vulnerability is accidentally logging sensitive information in request parameters or error messages. For example, logging <code>password=secret123</code> or including secret values in error responses. The audit system must sanitize all logged data to include only non-sensitive context needed for security monitoring.</p>\n<p><strong>Performance and Scalability Considerations</strong> ensure audit logging doesn&#39;t become a bottleneck for secret management operations. The logging subsystem implements several optimizations:</p>\n<ul>\n<li><strong>Asynchronous Logging</strong>: Audit events are queued and written asynchronously to prevent blocking secret operations</li>\n<li><strong>Batch Writing</strong>: Multiple audit events are written together to reduce I/O overhead</li>\n<li><strong>Log Rotation</strong>: Automatic rotation and compression of log files to manage storage growth</li>\n<li><strong>Sampling</strong>: Non-critical events may be sampled at high request volumes to prevent log flooding</li>\n</ul>\n<p>The audit logging system provides configurable log levels to balance detail with performance:</p>\n<table>\n<thead>\n<tr>\n<th>Log Level</th>\n<th>Events Included</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>minimal</code></td>\n<td>Authentication, authorization failures, administrative operations</td>\n<td>Compliance and basic security monitoring</td>\n</tr>\n<tr>\n<td><code>standard</code></td>\n<td>All secret operations, policy changes, error conditions</td>\n<td>Comprehensive security analysis</td>\n</tr>\n<tr>\n<td><code>verbose</code></td>\n<td>Request/response timing, debug information, performance metrics</td>\n<td>Troubleshooting and performance optimization</td>\n</tr>\n</tbody></table>\n<p><img src=\"/api/project/secret-management/architecture-doc/asset?path=diagrams%2Fdata-model-relationships.svg\" alt=\"Data Model Relationships\"></p>\n<p><img src=\"/api/project/secret-management/architecture-doc/asset?path=diagrams%2Fauthentication-sequence.svg\" alt=\"Authentication and Authorization Sequence\"></p>\n<p><img src=\"/api/project/secret-management/architecture-doc/asset?path=diagrams%2Frequest-processing-pipeline.svg\" alt=\"Request Processing Pipeline\"></p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Token Storage Without Expiration</strong>\nMany implementations create tokens without expiration dates and never clean up the token storage table. This leads to unbounded growth of the token database and potential memory exhaustion. Always implement token TTL with automatic cleanup processes, and consider using short-lived tokens with renewal mechanisms rather than long-lived tokens.</p>\n<p>⚠️ <strong>Pitfall: Timing Attack Vulnerabilities</strong>\nWhen validating tokens or comparing credentials, using standard string comparison functions can leak timing information that allows attackers to gradually guess valid tokens. Always use constant-time comparison functions (like <code>crypto/subtle.ConstantTimeCompare</code> in Go) when validating authentication credentials.</p>\n<p>⚠️ <strong>Pitfall: Policy Rule Conflicts</strong>\nWhen multiple policies apply to the same identity, conflicting rules can create security vulnerabilities. For example, one policy might grant <code>read</code> access to <code>secret/**</code> while another denies access to <code>secret/admin/*</code>. The authorization engine must have clear precedence rules — typically &quot;most specific rule wins&quot; or &quot;explicit deny overrides allow&quot; — and these rules must be consistently applied.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Request Context</strong>\nAuthentication engines often fail to capture sufficient context about the request environment, making forensic analysis difficult. Always log the complete request context including source IP, user agent, request parameters (sanitized), and timing information. This context is critical for detecting credential theft and analyzing security incidents.</p>\n<p>⚠️ <strong>Pitfall: Group Policy Infinite Recursion</strong>\nWhen implementing group-based policy inheritance, circular group memberships can cause infinite recursion during policy evaluation. Always implement cycle detection in group membership resolution, and consider limiting inheritance depth to prevent deep recursive chains that impact performance.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides concrete implementation guidance for building the authentication and policy engine in Go, with a focus on security best practices and production-ready patterns.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP Authentication</td>\n<td>Header parsing with <code>net/http</code></td>\n<td>JWT middleware with <code>github.com/golang-jwt/jwt</code></td>\n</tr>\n<tr>\n<td>TLS Certificate Handling</td>\n<td><code>crypto/x509</code> and <code>crypto/tls</code></td>\n<td><code>github.com/cloudflare/cfssl</code> for CA operations</td>\n</tr>\n<tr>\n<td>Token Storage</td>\n<td>In-memory map with <code>sync.RWMutex</code></td>\n<td>Redis with TTL support</td>\n</tr>\n<tr>\n<td>Policy Evaluation</td>\n<td>String matching with <code>path/filepath</code></td>\n<td>Compiled regex patterns with <code>regexp</code></td>\n</tr>\n<tr>\n<td>Audit Logging</td>\n<td>JSON lines to file with <code>encoding/json</code></td>\n<td>Structured logging with <code>github.com/sirupsen/logrus</code></td>\n</tr>\n<tr>\n<td>Password Hashing</td>\n<td><code>golang.org/x/crypto/argon2</code></td>\n<td><code>golang.org/x/crypto/scrypt</code> for compatibility</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/auth/\n  engine.go              ← main auth engine and policy evaluation\n  engine_test.go         ← auth engine tests\n  token.go               ← token creation, validation, and management\n  token_test.go          ← token handling tests\n  policy.go              ← policy parsing and rule evaluation\n  policy_test.go         ← policy evaluation tests\n  audit.go               ← audit logging and event capture\n  audit_test.go          ← audit logging tests\n  types.go               ← shared data structures (Token, Policy, Identity, etc.)\n  \ninternal/auth/methods/\n  token.go               ← bearer token authentication\n  mtls.go                ← mutual TLS authentication\n  approle.go             ← AppRole authentication method\n  \ncmd/auth-test/\n  main.go                ← standalone auth testing utility</code></pre></div>\n\n<h4 id=\"authentication-infrastructure-complete-implementation\">Authentication Infrastructure (Complete Implementation)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/auth/types.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> auth</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Token represents an authentication token with policies and metadata</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID           </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Accessor     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"accessor\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Policies     []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"policies\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TokenType    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"token_type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">         `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExpiresAt    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">        `json:\"expires_at,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastUsedAt   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">        `json:\"last_used_at,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UsageCount   </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">             `json:\"usage_count\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxUses      </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">               `json:\"max_uses\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Renewable    </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">              `json:\"renewable\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ParentToken  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"parent_token\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DisplayName  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"display_name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Metadata     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"metadata\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BoundCIDRs   []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"bound_cidrs\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Policy represents an access control policy with rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Policy</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Rules       []</span><span style=\"color:#B392F0\">PolicyRule</span><span style=\"color:#9ECBFF\"> `json:\"rules\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"description\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">    `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UpdatedAt   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">    `json:\"updated_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedBy   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"created_by\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Version     </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">          `json:\"version\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PolicyRule defines access control for a specific path pattern</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PolicyRule</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Path                </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">              `json:\"path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Capabilities        []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"capabilities\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RequiredParameters  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"required_parameters,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AllowedParameters   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"allowed_parameters,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DeniedParameters    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"denied_parameters,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxTTL              </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\">       `json:\"max_ttl,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MinWrappingTTL      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\">       `json:\"min_wrapping_ttl,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Identity represents an authenticated principal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Identity</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID          </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AuthMethod  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"auth_method\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Policies    []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"policies\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Groups      []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"groups\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">         `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastAuthAt  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">        `json:\"last_auth_at,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AuthCount   </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">             `json:\"auth_count\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Metadata    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"metadata\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Disabled    </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">              `json:\"disabled\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AuditEvent represents a security event for logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AuditEvent</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp        </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">              `json:\"timestamp\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RequestID        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"request_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EventType        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"event_type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Operation        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"operation\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Path             </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Identity         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"identity\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TokenID          </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"token_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AuthMethod       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"auth_method\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SourceIP         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"source_ip\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UserAgent        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"user_agent\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RequestMetadata  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"request_metadata\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Result           </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"result\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrorCode        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"error_code\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResponseMetadata </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"response_metadata\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Duration         </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\">          `json:\"duration\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Constants for authentication and authorization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TOKEN_HEADER</span><span style=\"color:#F97583\">     =</span><span style=\"color:#9ECBFF\"> \"X-Vault-Token\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEFAULT_TOKEN_TTL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> time.Hour</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Event types</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EVENT_AUTH</span><span style=\"color:#F97583\">   =</span><span style=\"color:#9ECBFF\"> \"auth\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EVENT_SECRET</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"secret\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EVENT_POLICY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"policy\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EVENT_ADMIN</span><span style=\"color:#F97583\">  =</span><span style=\"color:#9ECBFF\"> \"admin\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Results</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RESULT_SUCCESS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"success\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RESULT_DENIED</span><span style=\"color:#F97583\">  =</span><span style=\"color:#9ECBFF\"> \"denied\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RESULT_ERROR</span><span style=\"color:#F97583\">   =</span><span style=\"color:#9ECBFF\"> \"error\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/auth/audit.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> auth</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AuditLogger provides tamper-evident audit logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AuditLogger</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">os</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">File</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex      </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Mutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sequenceNum </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewAuditLogger creates a new audit logger writing to the specified file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewAuditLogger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">filename</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuditLogger</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">OpenFile</span><span style=\"color:#E1E4E8\">(filename, os.O_APPEND</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">os.O_CREATE</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">os.O_WRONLY, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to open audit log file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">AuditLogger</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file:        file,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sequenceNum: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LogEvent writes an audit event to the log file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">a </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuditLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">LogEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">event</span><span style=\"color:#B392F0\"> AuditEvent</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    a.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> a.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    a.sequenceNum</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add sequence number for tamper detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logEntry </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Sequence </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">      `json:\"sequence\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Event    </span><span style=\"color:#B392F0\">AuditEvent</span><span style=\"color:#9ECBFF\"> `json:\"event\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Sequence: a.sequenceNum,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Event:    event,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(logEntry)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to marshal audit event: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> a.file.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">append</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to write audit event: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Force write to disk for tamper evidence</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> a.file.</span><span style=\"color:#B392F0\">Sync</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Close closes the audit log file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">a </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuditLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> a.file.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-authentication-engine-skeleton-implementation\">Core Authentication Engine (Skeleton Implementation)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/auth/engine.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> auth</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/rand</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/subtle</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/hex</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Engine handles authentication, authorization, and audit logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Engine</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tokens       </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    policies     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Policy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    identities   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Identity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tokenMutex   </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    policyMutex  </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    auditLogger  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuditLogger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewEngine creates a new authentication engine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewEngine</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">auditLogPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    auditLogger, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewAuditLogger</span><span style=\"color:#E1E4E8\">(auditLogPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create audit logger: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tokens:      </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        policies:    </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Policy</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        identities:  </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Identity</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        auditLogger: auditLogger,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AuthenticateRequest extracts and validates authentication from HTTP request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AuthenticateRequest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Identity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract token from X-Vault-Token header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate token exists and is not expired</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Update token last_used_at and usage_count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Look up identity associated with token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check if identity is disabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Validate source IP against token bound_cidrs if configured</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return authenticated identity and token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use constant-time comparison for token validation to prevent timing attacks</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AuthorizeRequest evaluates whether identity can perform operation on path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AuthorizeRequest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">identity</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Identity</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">operation</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">params</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Collect all policies assigned to identity (direct + inherited)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each policy, evaluate rules in order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each rule, check if path matches rule.Path pattern</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If path matches, check if operation is in rule.Capabilities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate request parameters against rule constraints</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return true if any rule explicitly allows, false otherwise</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Implement path wildcard matching with * and ** support</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateToken generates a new authentication token for an identity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">request</span><span style=\"color:#B392F0\"> CreateTokenRequest</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Token</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate cryptographically secure random token ID and accessor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate requested policies exist and identity has permission</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate expiration time based on TTL and max TTL limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create token struct with all metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Store token in token map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Log token creation event to audit log</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use crypto/rand for token generation, 32+ bytes recommended</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreatePolicy creates or updates an access control policy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreatePolicy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">policy</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Policy</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate policy name and rule syntax</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check for path pattern conflicts with existing policies  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate capability names are recognized</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Store policy in policy map with version increment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Log policy creation/update to audit log</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Validate wildcard patterns don't create security holes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateTokenConstantTime performs constant-time token comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateTokenConstantTime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">provided</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">stored</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> subtle.</span><span style=\"color:#B392F0\">ConstantTimeCompare</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(provided), []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(stored)) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// matchesPath checks if a request path matches a policy rule path pattern</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">matchesPath</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pattern</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Split both pattern and path by \"/\" delimiter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Handle single segment wildcard (*) matching</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle recursive wildcard (**) matching  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle literal segment matching</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return true if pattern fully matches path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Recursive wildcard matching requires backtracking logic</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    panic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"implement me\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// generateSecureToken creates a cryptographically random token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">generateSecureToken</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rand.</span><span style=\"color:#B392F0\">Read</span><span style=\"color:#E1E4E8\">(bytes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> hex.</span><span style=\"color:#B392F0\">EncodeToString</span><span style=\"color:#E1E4E8\">(bytes), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CreateTokenRequest</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Policies    []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TTL         </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Renewable   </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DisplayName </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Metadata    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"path-matching-utility-complete-implementation\">Path Matching Utility (Complete Implementation)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/auth/pathmatch.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> auth</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PathMatcher provides efficient wildcard path matching for policies</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PathMatcher</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewPathMatcher creates a new path matching utility</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewPathMatcher</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PathMatcher</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">PathMatcher</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Match checks if a path matches a pattern with wildcards</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PathMatcher</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Match</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pattern</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pm.</span><span style=\"color:#B392F0\">matchSegments</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        strings.</span><span style=\"color:#B392F0\">Split</span><span style=\"color:#E1E4E8\">(pattern, </span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        strings.</span><span style=\"color:#B392F0\">Split</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// matchSegments recursively matches pattern segments against path segments</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PathMatcher</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">matchSegments</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pattern</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">patternIdx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pathIdx</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If we've consumed both pattern and path, it's a match</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> patternIdx </span><span style=\"color:#F97583\">>=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(pattern) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> pathIdx </span><span style=\"color:#F97583\">>=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(path) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If pattern is exhausted but path remains, no match</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> patternIdx </span><span style=\"color:#F97583\">>=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(pattern) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If path is exhausted but pattern has non-recursive wildcards, no match</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> pathIdx </span><span style=\"color:#F97583\">>=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(path) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if remaining pattern segments are all recursive wildcards</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> patternIdx; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(pattern); i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> pattern[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"**\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentPattern </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> pattern[patternIdx]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> currentPattern {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"*\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Single segment wildcard - match exactly one path segment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> pm.</span><span style=\"color:#B392F0\">matchSegments</span><span style=\"color:#E1E4E8\">(pattern, path, patternIdx</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, pathIdx</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"**\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Recursive wildcard - try matching zero or more segments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // First try consuming no path segments (** matches zero)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> pm.</span><span style=\"color:#B392F0\">matchSegments</span><span style=\"color:#E1E4E8\">(pattern, path, patternIdx</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, pathIdx) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Then try consuming one path segment and continuing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> pm.</span><span style=\"color:#B392F0\">matchSegments</span><span style=\"color:#E1E4E8\">(pattern, path, patternIdx, pathIdx</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Literal segment - must match exactly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> currentPattern </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> path[pathIdx] {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> pm.</span><span style=\"color:#B392F0\">matchSegments</span><span style=\"color:#E1E4E8\">(pattern, path, patternIdx</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, pathIdx</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Authentication Checkpoint:</strong>\nAfter implementing token authentication, test with:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start your auth engine</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/auth-test/main.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test token creation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8080/v1/auth/token/create</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -H</span><span style=\"color:#9ECBFF\"> \"X-Vault-Token: root-token\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -d</span><span style=\"color:#9ECBFF\"> '{\"policies\": [\"default\"], \"ttl\": \"1h\"}'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: JSON response with token ID and accessor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: Token appears in audit log with creation event</span></span></code></pre></div>\n\n<p><strong>Policy Evaluation Checkpoint:</strong>\nTest path-based access control:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create a policy</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8080/v1/sys/policy/test-policy</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -H</span><span style=\"color:#9ECBFF\"> \"X-Vault-Token: root-token\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -d</span><span style=\"color:#9ECBFF\"> '{\"policy\": \"path \\\"secret/app/*\\\" { capabilities = [\\\"read\\\"] }\"}'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test authorized access</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"X-Vault-Token: &#x3C;your-token>\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  http://localhost:8080/v1/secret/app/database</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test unauthorized access (should return 403)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"X-Vault-Token: &#x3C;your-token>\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  http://localhost:8080/v1/secret/admin/keys</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: First request succeeds, second returns 403 Forbidden</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: Both attempts appear in audit log with correct results</span></span></code></pre></div>\n\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>All requests return 401 Unauthorized</td>\n<td>Token lookup failing or tokens not being stored</td>\n<td>Check if tokens map contains expected tokens, verify token header extraction</td>\n<td>Ensure CreateToken actually stores in tokens map and AuthenticateRequest correctly extracts header</td>\n</tr>\n<tr>\n<td>Wildcard policies don&#39;t match expected paths</td>\n<td>Path matching algorithm incorrect</td>\n<td>Add debug logging to matchSegments function showing pattern/path at each step</td>\n<td>Test path matching in isolation with unit tests for edge cases</td>\n</tr>\n<tr>\n<td>Policy evaluation is slow</td>\n<td>Linear search through all policies for each request</td>\n<td>Profile policy evaluation with timing measurements</td>\n<td>Implement policy indexing by path prefix for faster lookup</td>\n</tr>\n<tr>\n<td>Audit logs missing events</td>\n<td>Events not being logged or file write failures</td>\n<td>Check audit log file permissions and disk space</td>\n<td>Ensure every authorization decision calls LogEvent, check file.Sync() errors</td>\n</tr>\n<tr>\n<td>Token cleanup not working</td>\n<td>Expired tokens accumulating in memory</td>\n<td>Check token expiration logic and cleanup goroutine</td>\n<td>Implement background cleanup that removes expired tokens from map</td>\n</tr>\n</tbody></table>\n<h2 id=\"dynamic-secret-engine\">Dynamic Secret Engine</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section implements Milestone 3 (Dynamic Secrets), focusing on on-demand credential generation, lease management, TTL tracking, and automatic revocation across multiple secret backends.</p>\n</blockquote>\n<p>The dynamic secret engine represents a fundamental shift from traditional static secret management to a <strong>credential vending machine</strong> model. Instead of storing long-lived passwords and API keys that accumulate risk over time, this system generates fresh credentials on demand with built-in expiration dates. Think of it like a parking meter that issues time-limited tickets - you get exactly what you need for exactly how long you need it, and the system automatically cleans up when time expires.</p>\n<h3 id=\"dynamic-secret-mental-model-understanding-just-in-time-credential-generation\">Dynamic Secret Mental Model: Understanding just-in-time credential generation</h3>\n<p>Before diving into implementation details, it&#39;s crucial to understand the mental model that underpins dynamic secret generation. Traditional secret management is like a safety deposit box - you store valuable items (passwords, keys) in a secure location and retrieve them when needed. The problem is that these items never change and accumulate risk the longer they exist.</p>\n<p><strong>Dynamic secrets work more like a hotel key card system.</strong> When you check in, the hotel doesn&#39;t give you a master key that works forever. Instead, they program a temporary card that works only for your room and only during your stay. The card is worthless before check-in and automatically stops working at checkout. If someone finds your lost card a week later, it&#39;s just plastic.</p>\n<p>This mental model extends to database credentials, cloud provider access keys, and API tokens. Instead of creating a shared database user &quot;app_user&quot; that every application instance uses, the dynamic secret engine creates unique database users like &quot;vault-db-app-20241201-142735&quot; that exist only long enough to serve a specific request or session. When the lease expires, that database user is automatically deleted.</p>\n<p>The <strong>credential vending machine</strong> analogy captures another important aspect - the system doesn&#39;t pre-generate credentials and store them. Instead, it has the blueprints (role configurations) and generates fresh credentials at request time. This eliminates the storage risk entirely - there&#39;s no static credential to steal from the vault&#39;s storage backend.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: Dynamic secrets shift the security model from &quot;protect stored credentials&quot; to &quot;minimize credential lifetime.&quot; A compromise can only access resources during the narrow window when credentials are active.</p>\n</blockquote>\n<p>The dynamic secret engine operates on three core principles:</p>\n<ol>\n<li><strong>Just-in-time generation</strong>: Credentials are created only when requested, not stored in advance</li>\n<li><strong>Lease-based tracking</strong>: Every credential has an explicit expiration time and unique lease ID</li>\n<li><strong>Automatic cleanup</strong>: The system takes responsibility for revoking credentials when leases expire</li>\n</ol>\n<p>This creates a <strong>blast radius containment</strong> effect. If an application is compromised, the attacker gains access to credentials that automatically expire. If the breach is detected within the lease duration, administrators can revoke specific leases immediately rather than rotating shared credentials across all applications.</p>\n<h3 id=\"secret-backend-plugins-database-and-cloud-provider-credential-generation\">Secret Backend Plugins: Database and cloud provider credential generation</h3>\n<p>The dynamic secret engine uses a plugin architecture where each <strong>secret backend</strong> implements the specific logic for generating, managing, and revoking credentials for a particular service type. This design provides extensibility while maintaining consistent lease management across all credential types.</p>\n<blockquote>\n<p><strong>Decision: Plugin Architecture for Secret Backends</strong></p>\n<ul>\n<li><strong>Context</strong>: Different services (databases, cloud providers, SSH) have completely different credential models and APIs for user management</li>\n<li><strong>Options Considered</strong>: Monolithic engine with hardcoded backends, plugin system with standardized interfaces, service-specific engines</li>\n<li><strong>Decision</strong>: Plugin system with standardized <code>SecretBackend</code> interface</li>\n<li><strong>Rationale</strong>: Enables extensibility without core engine changes, allows third-party backends, maintains consistent lease semantics across credential types</li>\n<li><strong>Consequences</strong>: Slightly more complex than monolithic approach, but enables supporting new services without modifying core vault code</li>\n</ul>\n</blockquote>\n<p>Each secret backend plugin implements a standardized interface that abstracts the credential lifecycle:</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>GenerateCredentials</code></td>\n<td><code>ctx context.Context</code>, <code>roleName string</code>, <code>ttl time.Duration</code></td>\n<td><code>map[string]interface{}</code>, <code>map[string]interface{}</code>, <code>error</code></td>\n<td>Creates new credentials and returns both the credentials data and revocation metadata</td>\n</tr>\n<tr>\n<td><code>RevokeCredentials</code></td>\n<td><code>ctx context.Context</code>, <code>revocationData map[string]interface{}</code></td>\n<td><code>error</code></td>\n<td>Removes or disables the credentials using stored revocation metadata</td>\n</tr>\n<tr>\n<td><code>RenewCredentials</code></td>\n<td><code>ctx context.Context</code>, <code>revocationData map[string]interface{}</code>, <code>increment time.Duration</code></td>\n<td><code>error</code></td>\n<td>Extends credential lifetime if backend supports renewal</td>\n</tr>\n<tr>\n<td><code>ValidateRole</code></td>\n<td><code>ctx context.Context</code>, <code>roleName string</code>, <code>roleConfig map[string]interface{}</code></td>\n<td><code>error</code></td>\n<td>Validates that role configuration is correct for this backend type</td>\n</tr>\n</tbody></table>\n<p>The <strong>database secret backend</strong> serves as the primary example of dynamic credential generation. When configured with connection details and appropriate privileges, it can generate unique database users with specific permissions and automatic cleanup:</p>\n<p><strong>Database Backend Role Configuration:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>Unique identifier for this role within the backend</td>\n</tr>\n<tr>\n<td><code>CreationStatements</code></td>\n<td><code>[]string</code></td>\n<td>SQL statements to execute when creating new database user</td>\n</tr>\n<tr>\n<td><code>RevocationStatements</code></td>\n<td><code>[]string</code></td>\n<td>SQL statements to execute when cleaning up expired user</td>\n</tr>\n<tr>\n<td><code>RenewStatements</code></td>\n<td><code>[]string</code></td>\n<td>SQL statements to execute when extending user lifetime (optional)</td>\n</tr>\n<tr>\n<td><code>DefaultTTL</code></td>\n<td><code>time.Duration</code></td>\n<td>Default lease duration if client doesn&#39;t specify</td>\n</tr>\n<tr>\n<td><code>MaxTTL</code></td>\n<td><code>time.Duration</code></td>\n<td>Maximum lease duration regardless of client request</td>\n</tr>\n<tr>\n<td><code>RenewIncrement</code></td>\n<td><code>time.Duration</code></td>\n<td>How much time to add during lease renewal</td>\n</tr>\n<tr>\n<td><code>AllowedDomains</code></td>\n<td><code>[]string</code></td>\n<td>Domain restrictions for cloud provider backends</td>\n</tr>\n<tr>\n<td><code>RoleOptions</code></td>\n<td><code>map[string]interface{}</code></td>\n<td>Backend-specific configuration options</td>\n</tr>\n</tbody></table>\n<p>When a client requests database credentials through the &quot;database/creds/readonly&quot; endpoint, the database backend executes the following sequence:</p>\n<ol>\n<li><strong>Generate unique username</strong>: Create a cryptographically unique username like &quot;vault-readonly-20241201-142735-abc123&quot; to avoid collisions</li>\n<li><strong>Execute creation statements</strong>: Run the configured SQL statements, substituting the generated username and a random password</li>\n<li><strong>Test connectivity</strong>: Attempt to authenticate with the new credentials to verify creation succeeded</li>\n<li><strong>Return credential data</strong>: Provide the username and password to the client</li>\n<li><strong>Store revocation metadata</strong>: Save the username and any cleanup information needed for later revocation</li>\n</ol>\n<p><strong>Database Backend Credential Generation Example:</strong></p>\n<p>For a role configured with creation statement:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#E1E4E8\"> USER </span><span style=\"color:#9ECBFF\">'{{name}}'</span><span style=\"color:#E1E4E8\">@</span><span style=\"color:#9ECBFF\">'%'</span><span style=\"color:#E1E4E8\"> IDENTIFIED </span><span style=\"color:#F97583\">BY</span><span style=\"color:#9ECBFF\"> '{{password}}'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">GRANT</span><span style=\"color:#F97583\"> SELECT</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> myapp.</span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> TO</span><span style=\"color:#9ECBFF\"> '{{name}}'</span><span style=\"color:#E1E4E8\">@</span><span style=\"color:#9ECBFF\">'%'</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<p>The backend generates:</p>\n<ul>\n<li>Username: &quot;vault-readonly-20241201-142735-abc123&quot;  </li>\n<li>Password: 32-character random string</li>\n<li>Executes: <code>CREATE USER &#39;vault-readonly-20241201-142735-abc123&#39;@&#39;%&#39; IDENTIFIED BY &#39;xK9mP...&#39;;</code></li>\n<li>Executes: <code>GRANT SELECT ON myapp.* TO &#39;vault-readonly-20241201-142735-abc123&#39;@&#39;%&#39;;</code></li>\n</ul>\n<p>The <strong>cloud provider secret backend</strong> follows similar patterns but generates API keys, access tokens, or service account credentials instead of database users. For AWS, this might involve creating temporary IAM users with specific policies. For Google Cloud, it could generate service account keys with defined roles.</p>\n<blockquote>\n<p><strong>Decision: Template-Based Statement Configuration</strong></p>\n<ul>\n<li><strong>Context</strong>: Different databases and versions have varying syntax for user management commands</li>\n<li><strong>Options Considered</strong>: Hardcoded statements per database type, template system with variable substitution, database-specific plugins</li>\n<li><strong>Decision</strong>: Template system with <code>{{name}}</code> and <code>{{password}}</code> variable substitution</li>\n<li><strong>Rationale</strong>: Provides flexibility for administrators to customize statements for their specific database configuration and security requirements</li>\n<li><strong>Consequences</strong>: Requires careful template validation to prevent SQL injection, but enables supporting any database with user management capabilities</li>\n</ul>\n</blockquote>\n<p><strong>Secret Backend Plugin Architecture:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Responsibility</th>\n<th>Key Data</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SecretBackend</code></td>\n<td>Manages credential lifecycle for specific service type</td>\n<td>Backend configuration, role definitions, connection details</td>\n</tr>\n<tr>\n<td><code>BackendRole</code></td>\n<td>Defines credential template and permissions</td>\n<td>Creation/revocation statements, TTL limits, role options</td>\n</tr>\n<tr>\n<td><code>CredentialPlugin</code></td>\n<td>Implements service-specific credential generation</td>\n<td>Service client connections, API credentials, user management logic</td>\n</tr>\n</tbody></table>\n<p>Each backend maintains its own connection pool to the target service to avoid connection overhead during credential generation. The database backend, for example, maintains persistent connections to configured database instances and reuses them across credential requests.</p>\n<p>⚠️ <strong>Pitfall: Connection Pool Resource Leaks</strong>\nMany implementations create a new database connection for each credential request, leading to connection exhaustion under load. The database backend should maintain a connection pool and reuse connections across credential operations. Similarly, cloud provider backends should reuse HTTP clients and authenticate once rather than per request.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Backend Privileges</strong>\nBackends need elevated privileges to create and delete users, which creates a <strong>privilege escalation</strong> risk if the vault itself is compromised. The backend service account should have only the minimum privileges needed for user lifecycle management. For databases, this means <code>CREATE USER</code>, <code>DROP USER</code>, and <code>GRANT</code> privileges but not data access. For cloud providers, it means user management permissions but not resource access.</p>\n<h3 id=\"lease-management-ttl-tracking-renewal-and-automatic-revocation\">Lease Management: TTL tracking, renewal, and automatic revocation</h3>\n<p>The lease management system serves as the <strong>control plane</strong> for all dynamic credentials, tracking their lifecycle from creation through expiration or explicit revocation. Think of it as an <strong>automated parking enforcement system</strong> - it tracks when each parking meter expires and automatically issues tickets (revokes credentials) for expired spots.</p>\n<p>Every dynamic credential request creates a <strong>lease</strong> that encapsulates the credential&#39;s lifecycle metadata:</p>\n<p><strong>Lease Data Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ID</code></td>\n<td><code>string</code></td>\n<td>Globally unique lease identifier (UUID)</td>\n</tr>\n<tr>\n<td><code>SecretType</code></td>\n<td><code>string</code></td>\n<td>Type of secret (database, aws, gcp) for routing to correct backend</td>\n</tr>\n<tr>\n<td><code>BackendPath</code></td>\n<td><code>string</code></td>\n<td>Which secret backend instance generated this lease</td>\n</tr>\n<tr>\n<td><code>RoleName</code></td>\n<td><code>string</code></td>\n<td>Role used for credential generation (affects permissions)</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>When the lease was initially created</td>\n</tr>\n<tr>\n<td><code>ExpiresAt</code></td>\n<td><code>time.Time</code></td>\n<td>When the lease expires and credentials become invalid</td>\n</tr>\n<tr>\n<td><code>RenewedAt</code></td>\n<td><code>*time.Time</code></td>\n<td>Last renewal timestamp (nil if never renewed)</td>\n</tr>\n<tr>\n<td><code>RenewalCount</code></td>\n<td><code>int</code></td>\n<td>How many times this lease has been renewed</td>\n</tr>\n<tr>\n<td><code>MaxTTL</code></td>\n<td><code>time.Duration</code></td>\n<td>Maximum lifetime regardless of renewals</td>\n</tr>\n<tr>\n<td><code>Renewable</code></td>\n<td><code>bool</code></td>\n<td>Whether this lease can be extended before expiration</td>\n</tr>\n<tr>\n<td><code>TokenID</code></td>\n<td><code>string</code></td>\n<td>Authentication token that created this lease (for audit)</td>\n</tr>\n<tr>\n<td><code>RevocationData</code></td>\n<td><code>map[string]interface{}</code></td>\n<td>Backend-specific data needed for credential cleanup</td>\n</tr>\n<tr>\n<td><code>SecretData</code></td>\n<td><code>map[string]interface{}</code></td>\n<td>Credential information returned to client (may be empty for security)</td>\n</tr>\n<tr>\n<td><code>Status</code></td>\n<td><code>string</code></td>\n<td>Current lease state (active, expired, revoked)</td>\n</tr>\n</tbody></table>\n<p>The lease management system operates through several coordinated processes:</p>\n<p><strong>Lease Creation Process:</strong></p>\n<ol>\n<li><strong>Validate request</strong>: Ensure client has permission for the requested backend path and role</li>\n<li><strong>Generate lease ID</strong>: Create globally unique identifier for tracking this credential lifecycle</li>\n<li><strong>Calculate expiration</strong>: Determine lease duration based on client request, role defaults, and maximum limits</li>\n<li><strong>Invoke backend</strong>: Call the appropriate secret backend to generate actual credentials</li>\n<li><strong>Store lease record</strong>: Persist lease metadata for tracking and future revocation</li>\n<li><strong>Index by expiration</strong>: Add lease to expiration index for efficient cleanup scanning</li>\n<li><strong>Return credentials</strong>: Provide credential data and lease ID to client</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Separate Credential Data from Revocation Data</strong></p>\n<ul>\n<li><strong>Context</strong>: Backends need different information for credential generation vs. cleanup, and storing credentials increases attack surface</li>\n<li><strong>Options Considered</strong>: Store complete credentials in lease, store only revocation data, store both separately</li>\n<li><strong>Decision</strong>: Store revocation data in lease, return credentials to client without persisting</li>\n<li><strong>Rationale</strong>: Minimizes stored secrets (credentials exist only during client session), while preserving cleanup capability through revocation metadata</li>\n<li><strong>Consequences</strong>: Clients must store credentials themselves, but vault storage doesn&#39;t contain usable credentials</li>\n</ul>\n</blockquote>\n<p><strong>Lease Renewal Process:</strong>\nRenewable leases can be extended before expiration to avoid credential cycling for long-running processes. The renewal process implements several safety checks:</p>\n<ol>\n<li><strong>Validate lease existence</strong>: Ensure the lease ID exists and is currently active</li>\n<li><strong>Check renewable flag</strong>: Verify that this lease type supports renewal</li>\n<li><strong>Enforce maximum TTL</strong>: Ensure renewed lease won&#39;t exceed the configured maximum lifetime</li>\n<li><strong>Calculate new expiration</strong>: Add the requested increment (bounded by role configuration)</li>\n<li><strong>Update lease record</strong>: Modify expiration time, renewal count, and last renewed timestamp</li>\n<li><strong>Update expiration index</strong>: Move lease to new expiration time bucket for cleanup tracking</li>\n<li><strong>Invoke backend renewal</strong>: Allow backend to extend underlying credentials if needed</li>\n</ol>\n<p><strong>Lease Expiration Tracking:</strong></p>\n<p>The lease management system maintains an <strong>expiration index</strong> that groups leases by expiration time for efficient batch processing:</p>\n<p><strong>LeaseIndex Data Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ByExpiration</code></td>\n<td><code>map[time.Time][]string</code></td>\n<td>Groups lease IDs by expiration timestamp for batch processing</td>\n</tr>\n<tr>\n<td><code>ByToken</code></td>\n<td><code>map[string][]string</code></td>\n<td>Groups leases by creating token for bulk revocation</td>\n</tr>\n<tr>\n<td><code>ByBackend</code></td>\n<td><code>map[string][]string</code></td>\n<td>Groups leases by backend path for backend-specific operations</td>\n</tr>\n<tr>\n<td><code>ActiveCount</code></td>\n<td><code>int64</code></td>\n<td>Running count of active leases for monitoring</td>\n</tr>\n</tbody></table>\n<p>The expiration index enables the <strong>lease reaper</strong> process to efficiently find expired leases without scanning the entire lease database:</p>\n<p><strong>Lease Reaper Algorithm:</strong></p>\n<ol>\n<li><strong>Scan expiration index</strong>: Find all lease buckets with expiration times before current time</li>\n<li><strong>Batch expired leases</strong>: Collect lease IDs from expired buckets (typically 100-1000 per batch)</li>\n<li><strong>Load lease details</strong>: Retrieve full lease records for the expired lease IDs</li>\n<li><strong>Group by backend</strong>: Organize leases by backend type for efficient revocation</li>\n<li><strong>Revoke credentials</strong>: Call backend revocation methods with stored revocation data</li>\n<li><strong>Update lease status</strong>: Mark leases as revoked in storage</li>\n<li><strong>Update indexes</strong>: Remove revoked leases from all index structures</li>\n<li><strong>Log revocation</strong>: Record successful revocation in audit log for compliance</li>\n</ol>\n<blockquote>\n<p><strong>Key Insight</strong>: The lease reaper runs as a background process every 30-60 seconds, but lease expiration times are honored by the authorization system immediately. This means expired credentials are denied access even if revocation hasn&#39;t completed yet.</p>\n</blockquote>\n<p>⚠️ <strong>Pitfall: Lease Reaper Failure Handling</strong>\nIf the lease reaper process crashes or becomes unable to revoke credentials, expired leases accumulate and credentials remain active past their intended lifetime. The system should implement <strong>revocation retry logic</strong> with exponential backoff and <strong>alerting</strong> when revocation fails repeatedly. Additionally, the authorization system should reject requests using expired leases regardless of backend credential status.</p>\n<p><strong>Lease Renewal Limits:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Original TTL</th>\n<th>Max TTL</th>\n<th>Renewal Request</th>\n<th>Result</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Normal renewal</td>\n<td>1 hour</td>\n<td>8 hours</td>\n<td>+1 hour after 30 minutes</td>\n<td>New expiration: 1.5 hours from creation</td>\n<td>Within limits</td>\n</tr>\n<tr>\n<td>Excessive renewal</td>\n<td>1 hour</td>\n<td>8 hours</td>\n<td>+24 hours after 30 minutes</td>\n<td>New expiration: 8 hours from creation</td>\n<td>Capped at max TTL</td>\n</tr>\n<tr>\n<td>Expired lease</td>\n<td>1 hour</td>\n<td>8 hours</td>\n<td>+1 hour after 2 hours</td>\n<td>Error: lease expired</td>\n<td>Cannot renew expired leases</td>\n</tr>\n<tr>\n<td>Max TTL reached</td>\n<td>8 hours</td>\n<td>8 hours</td>\n<td>+1 hour after 7 hours</td>\n<td>Error: would exceed max TTL</td>\n<td>Prevent infinite extension</td>\n</tr>\n</tbody></table>\n<h3 id=\"revocation-engine-cleanup-of-expired-credentials-across-backends\">Revocation Engine: Cleanup of expired credentials across backends</h3>\n<p>The revocation engine serves as the <strong>cleanup crew</strong> for the dynamic secret system, ensuring that expired or compromised credentials are properly removed from target systems. Unlike lease management which tracks metadata, the revocation engine actually interacts with external systems to disable database users, delete cloud IAM keys, and clean up other credential artifacts.</p>\n<p>Think of the revocation engine as a <strong>building security system that automatically deactivates keycards</strong>. When an employee leaves or a keycard expires, the system doesn&#39;t just mark it as inactive in the database - it actively tells all door readers that the keycard should no longer grant access.</p>\n<p><strong>Revocation Engine Architecture:</strong></p>\n<p>The revocation engine operates through a <strong>queue-based system</strong> that provides reliability, retry logic, and priority handling for credential cleanup operations:</p>\n<p><strong>RevocationQueue Data Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LeaseID</code></td>\n<td><code>string</code></td>\n<td>Unique identifier of the lease being revoked</td>\n</tr>\n<tr>\n<td><code>BackendPath</code></td>\n<td><code>string</code></td>\n<td>Which secret backend should handle this revocation</td>\n</tr>\n<tr>\n<td><code>RevocationData</code></td>\n<td><code>map[string]interface{}</code></td>\n<td>Backend-specific data needed for credential cleanup</td>\n</tr>\n<tr>\n<td><code>QueuedAt</code></td>\n<td><code>time.Time</code></td>\n<td>When this revocation was first queued</td>\n</tr>\n<tr>\n<td><code>AttemptCount</code></td>\n<td><code>int</code></td>\n<td>How many revocation attempts have been made</td>\n</tr>\n<tr>\n<td><code>NextAttempt</code></td>\n<td><code>time.Time</code></td>\n<td>When to try revocation again (for failed attempts)</td>\n</tr>\n<tr>\n<td><code>Priority</code></td>\n<td><code>int</code></td>\n<td>Revocation priority (1=immediate, 2=normal, 3=cleanup)</td>\n</tr>\n</tbody></table>\n<p>The revocation engine processes this queue continuously, handling both <strong>automatic expiration</strong> and <strong>explicit revocation</strong> requests:</p>\n<p><strong>Revocation Processing Algorithm:</strong></p>\n<ol>\n<li><strong>Dequeue revocation requests</strong>: Pull revocation requests from queue, ordered by priority and next attempt time</li>\n<li><strong>Load backend configuration</strong>: Retrieve the appropriate secret backend for this revocation</li>\n<li><strong>Execute revocation</strong>: Call backend-specific revocation method with stored revocation data</li>\n<li><strong>Handle success</strong>: Remove revocation request from queue and update lease status</li>\n<li><strong>Handle failure</strong>: Increment attempt count, calculate next retry time with exponential backoff</li>\n<li><strong>Re-queue failed attempts</strong>: Put failed revocations back in queue with updated retry timestamp</li>\n<li><strong>Alert on persistent failures</strong>: Send alerts if revocation fails repeatedly (typically after 5-10 attempts)</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Asynchronous Revocation with Retry Queue</strong></p>\n<ul>\n<li><strong>Context</strong>: Credential revocation involves network calls to external systems that may be temporarily unavailable</li>\n<li><strong>Options Considered</strong>: Synchronous revocation blocking lease expiration, fire-and-forget async revocation, queue-based async revocation with retries</li>\n<li><strong>Decision</strong>: Queue-based asynchronous revocation with exponential backoff retry</li>\n<li><strong>Rationale</strong>: Provides reliability without blocking lease expiration, handles transient network failures gracefully, enables monitoring and alerting for persistent failures</li>\n<li><strong>Consequences</strong>: Adds complexity but ensures credentials are eventually revoked even if target systems are temporarily unreachable</li>\n</ul>\n</blockquote>\n<p><strong>Backend-Specific Revocation Strategies:</strong></p>\n<p>Different types of credentials require different revocation approaches, each with unique failure modes and recovery strategies:</p>\n<table>\n<thead>\n<tr>\n<th>Backend Type</th>\n<th>Revocation Method</th>\n<th>Failure Scenarios</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database</td>\n<td><code>DROP USER</code> statement</td>\n<td>Connection timeout, database offline, user doesn&#39;t exist</td>\n<td>Retry with connection pool, verify user absence</td>\n</tr>\n<tr>\n<td>AWS IAM</td>\n<td>Delete user API call</td>\n<td>API rate limits, permission denied, user already deleted</td>\n<td>Retry with backoff, ignore &quot;user not found&quot; errors</td>\n</tr>\n<tr>\n<td>Cloud KMS</td>\n<td>Disable service account key</td>\n<td>Network partition, quota exceeded, key already disabled</td>\n<td>Retry different region, ignore &quot;already disabled&quot;</td>\n</tr>\n<tr>\n<td>SSH Certificate</td>\n<td>Revocation list update</td>\n<td>Certificate authority offline, signing key unavailable</td>\n<td>Queue for CA recovery, maintain revocation list</td>\n</tr>\n</tbody></table>\n<p><strong>Database Credential Revocation Example:</strong></p>\n<p>When revoking database credentials, the database backend executes the configured revocation statements with proper error handling:</p>\n<p><strong>Database Revocation Process:</strong></p>\n<ol>\n<li><strong>Extract username</strong>: Get database username from revocation data (e.g., &quot;vault-readonly-20241201-142735-abc123&quot;)</li>\n<li><strong>Terminate active sessions</strong>: Kill any active database sessions for this user to prevent continued access</li>\n<li><strong>Execute revocation statements</strong>: Run configured SQL statements, typically <code>DROP USER &#39;{{name}}&#39;@&#39;%&#39;</code></li>\n<li><strong>Verify deletion</strong>: Query user tables to confirm the user no longer exists</li>\n<li><strong>Handle cleanup errors</strong>: If user doesn&#39;t exist, treat as successful (idempotent operation)</li>\n<li><strong>Log revocation result</strong>: Record success or failure details for audit and debugging</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Revocation Statement Dependencies</strong>\nDatabase revocation statements must handle dependencies correctly. For example, MySQL requires dropping user privileges before dropping the user itself. The revocation statements should be ordered to handle these dependencies: <code>REVOKE ALL PRIVILEGES ON *.* FROM &#39;{{name}}&#39;@&#39;%&#39;; DROP USER &#39;{{name}}&#39;@&#39;%&#39;;</code></p>\n<p><strong>Revocation Failure Handling:</strong></p>\n<p>The revocation engine implements <strong>exponential backoff</strong> to handle transient failures without overwhelming external systems:</p>\n<p><strong>Retry Schedule:</strong></p>\n<ul>\n<li>Attempt 1: Immediate</li>\n<li>Attempt 2: 1 minute delay  </li>\n<li>Attempt 3: 2 minute delay</li>\n<li>Attempt 4: 4 minute delay</li>\n<li>Attempt 5: 8 minute delay</li>\n<li>Attempt 6+: 16 minute delay (maximum)</li>\n</ul>\n<p>After 10 consecutive failures, the revocation request is moved to a <strong>dead letter queue</strong> for manual intervention, and an alert is generated for the operations team.</p>\n<p><strong>Emergency Revocation:</strong></p>\n<p>For security incidents, the revocation engine supports <strong>priority revocation</strong> that bypasses normal queue ordering:</p>\n<p><strong>Revocation Priority Levels:</strong></p>\n<ol>\n<li><strong>Immediate (Priority 1)</strong>: Security incident response, suspected compromise - processed within seconds</li>\n<li><strong>Normal (Priority 2)</strong>: Regular lease expiration - processed within 1-2 minutes  </li>\n<li><strong>Cleanup (Priority 3)</strong>: Background cleanup, orphaned resources - processed during off-peak hours</li>\n</ol>\n<p>Priority 1 revocations also trigger <strong>parallel revocation</strong> across multiple backend instances and regions to ensure rapid credential invalidation.</p>\n<p><strong>Bulk Revocation Operations:</strong></p>\n<p>The revocation engine supports bulk operations for scenarios like token revocation (revoking all leases created by a specific token) or backend rotation (revoking all credentials from a compromised backend):</p>\n<p><strong>Bulk Revocation Algorithm:</strong></p>\n<ol>\n<li><strong>Identify affected leases</strong>: Query lease index by token ID, backend path, or other criteria</li>\n<li><strong>Queue all revocations</strong>: Add revocation requests for all identified leases</li>\n<li><strong>Process with concurrency limits</strong>: Revoke credentials in parallel but respect backend rate limits</li>\n<li><strong>Track completion</strong>: Monitor bulk revocation progress and report completion status</li>\n<li><strong>Handle partial failures</strong>: Continue bulk operation even if individual revocations fail</li>\n</ol>\n<p>This enables rapid response to security incidents where entire token families or backend instances need immediate revocation.</p>\n<p><img src=\"/api/project/secret-management/architecture-doc/asset?path=diagrams%2Fdynamic-secret-lifecycle.svg\" alt=\"Dynamic Secret Lifecycle\"></p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The dynamic secret engine requires careful coordination between lease management, backend plugins, and revocation processing. This implementation guidance provides complete infrastructure code and detailed skeletons for the core learning components.</p>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lease Storage</td>\n<td>In-memory map with periodic disk sync</td>\n<td>Embedded database (BadgerDB) with transactions</td>\n</tr>\n<tr>\n<td>Revocation Queue</td>\n<td>Go channels with worker goroutines</td>\n<td>Persistent queue (Redis/database-backed)</td>\n</tr>\n<tr>\n<td>Backend Plugins</td>\n<td>Direct interface implementation</td>\n<td>Plugin system with RPC/gRPC</td>\n</tr>\n<tr>\n<td>Time Management</td>\n<td>Standard <code>time.Time</code> with tickers</td>\n<td>Hierarchical timing wheels for efficiency</td>\n</tr>\n<tr>\n<td>Credential Generation</td>\n<td>Standard <code>crypto/rand</code> for passwords</td>\n<td>HSM integration for key material</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/dynamic/\n  engine.go              ← main dynamic engine\n  engine_test.go         ← engine tests\n  lease.go              ← lease management\n  lease_index.go        ← lease indexing and expiration tracking\n  revocation.go         ← revocation engine and queue\n  backends/\n    interface.go        ← SecretBackend interface definition\n    database/\n      database.go       ← database credential backend\n      mysql.go          ← MySQL-specific implementation\n      postgres.go       ← PostgreSQL-specific implementation\n    aws/\n      aws.go           ← AWS IAM backend\n    registry.go        ← backend plugin registry\n  internal/\n    credential_generator.go ← secure password/key generation\n    retry.go               ← exponential backoff utilities</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code:</strong></p>\n<p><strong>Credential Generator (complete implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/dynamic/internal/credential_generator.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> internal</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/rand</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">math/big</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Character sets for password generation</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PasswordChars</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UsernameChars</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"abcdefghijklmnopqrstuvwxyz0123456789\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DefaultPasswordLength</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 32</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DefaultUsernameLength</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 20</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CredentialGenerator provides secure random credential generation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CredentialGenerator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GeneratePassword creates a cryptographically secure random password</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CredentialGenerator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GeneratePassword</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">length</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> length </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DefaultPasswordLength</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    password </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, length)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> password {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        charIndex, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rand.</span><span style=\"color:#B392F0\">Int</span><span style=\"color:#E1E4E8\">(rand.Reader, big.</span><span style=\"color:#B392F0\">NewInt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(PasswordChars))))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to generate random character: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        password[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PasswordChars[charIndex.</span><span style=\"color:#B392F0\">Int64</span><span style=\"color:#E1E4E8\">()]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">(password), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateUsername creates a unique username with timestamp and random suffix</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CredentialGenerator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateUsername</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">prefix</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Format</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"20060102-150405\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Generate random suffix</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    suffix </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> suffix {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        charIndex, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rand.</span><span style=\"color:#B392F0\">Int</span><span style=\"color:#E1E4E8\">(rand.Reader, big.</span><span style=\"color:#B392F0\">NewInt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(UsernameChars))))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to generate random suffix: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        suffix[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UsernameChars[charIndex.</span><span style=\"color:#B392F0\">Int64</span><span style=\"color:#E1E4E8\">()]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Format: vault-prefix-20241201-142735-abc123</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    username </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"vault-</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">-</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">-</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, prefix, timestamp, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(suffix))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Ensure username doesn't exceed common database limits (32-64 chars)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(username) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Truncate prefix if needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxPrefix </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#F97583\"> -</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(timestamp) </span><span style=\"color:#F97583\">-</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(suffix) </span><span style=\"color:#F97583\">-</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"vault--\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(prefix) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> maxPrefix </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> maxPrefix </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            prefix </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> prefix[:maxPrefix]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            username </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"vault-</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">-</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">-</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, prefix, timestamp, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(suffix))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> username, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SubstituteTemplate replaces {{name}} and {{password}} in template strings</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CredentialGenerator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SubstituteTemplate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">template</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">password</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">ReplaceAll</span><span style=\"color:#E1E4E8\">(template, </span><span style=\"color:#9ECBFF\">\"{{name}}\"</span><span style=\"color:#E1E4E8\">, name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">ReplaceAll</span><span style=\"color:#E1E4E8\">(result, </span><span style=\"color:#9ECBFF\">\"{{password}}\"</span><span style=\"color:#E1E4E8\">, password)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Retry Logic (complete implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/dynamic/internal/retry.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> internal</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">math</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RetryConfig defines exponential backoff parameters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RetryConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InitialDelay </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxDelay     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Multiplier   </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxAttempts  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DefaultRetryConfig provides sensible defaults for revocation retries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> DefaultRetryConfig </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> RetryConfig</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InitialDelay: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Minute,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxDelay:     </span><span style=\"color:#79B8FF\">16</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Minute,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Multiplier:   </span><span style=\"color:#79B8FF\">2.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxAttempts:  </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CalculateDelay computes next retry delay using exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#B392F0\">RetryConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CalculateDelay</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">attemptNumber</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> attemptNumber </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#6A737D\"> // First attempt is immediate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    delay </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(c.InitialDelay) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> math.</span><span style=\"color:#B392F0\">Pow</span><span style=\"color:#E1E4E8\">(c.Multiplier, </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(attemptNumber</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(delay) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> c.MaxDelay {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        delay </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(c.MaxDelay)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(delay)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ShouldRetry determines if another attempt should be made</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#B392F0\">RetryConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ShouldRetry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">attemptNumber</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> attemptNumber </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> c.MaxAttempts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RetryOperation executes operation with exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> RetryOperation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> RetryConfig</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">operation</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> lastErr </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> attempt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; attempt </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> config.MaxAttempts; attempt</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> attempt </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            delay </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> config.</span><span style=\"color:#B392F0\">CalculateDelay</span><span style=\"color:#E1E4E8\">(attempt)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">time.</span><span style=\"color:#B392F0\">After</span><span style=\"color:#E1E4E8\">(delay):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Continue to retry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"retry cancelled: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ctx.</span><span style=\"color:#B392F0\">Err</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> operation</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lastErr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">config.</span><span style=\"color:#B392F0\">ShouldRetry</span><span style=\"color:#E1E4E8\">(attempt) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\"> // Success</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"operation failed after </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> attempts: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, config.MaxAttempts, lastErr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code:</strong></p>\n<p><strong>Dynamic Engine (core implementation skeleton):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/dynamic/engine.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> dynamic</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/internal/dynamic/backends</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/internal/dynamic/internal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Engine manages dynamic secret generation and lease tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Engine</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    backends     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">backends</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SecretBackend</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leases       </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Lease</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leaseIndex   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LeaseIndex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    revocationQueue </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">RevocationQueue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    credGen      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">internal</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CredentialGenerator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Synchronization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leaseMutex   </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Background workers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    reaperTicker </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Ticker</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stopChan     </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewEngine creates a new dynamic secret engine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewEngine</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        backends:        </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">backends</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SecretBackend</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        leases:          </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Lease</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        leaseIndex:      </span><span style=\"color:#B392F0\">NewLeaseIndex</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        revocationQueue: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">RevocationQueue</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        credGen:         </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">internal</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CredentialGenerator</span><span style=\"color:#E1E4E8\">{},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stopChan:        </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterBackend adds a secret backend at the specified path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterBackend</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">backend</span><span style=\"color:#B392F0\"> backends</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SecretBackend</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate that path is not already registered</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Store backend in backends map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize backend if it has an Init method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use path as key in backends map</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateSecret creates new dynamic credentials with lease tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateSecret</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">backendPath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roleName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ttl</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tokenID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Lease</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up backend by backendPath in backends map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Generate unique lease ID using crypto/rand or UUID library</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate lease expiration time (created + ttl)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Call backend.GenerateCredentials(ctx, roleName, ttl)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Create Lease struct with all required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Store lease in leases map with leaseMutex write lock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Add lease to expiration index for reaper processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Return lease and credentials (credentials are not stored)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: backend.GenerateCredentials returns (credentials, revocationData, error)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RenewLease extends an existing lease if renewable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RenewLease</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">leaseID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">increment</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Lease</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire read lock and look up lease by ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate lease exists and is currently active</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if lease.Renewable is true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Calculate new expiration (current + increment)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Ensure new expiration doesn't exceed lease.MaxTTL from creation time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Upgrade to write lock and update lease expiration fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update lease index with new expiration time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Call backend.RenewCredentials if backend supports it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: New expiration = min(current + increment, created + maxTTL)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RevokeLease immediately revokes a lease and queues credential cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RevokeLease</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">leaseID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up lease and validate it exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update lease status to \"revoked\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Remove lease from expiration index</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create RevocationQueue entry with priority 1 (immediate)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Send revocation request to revocation queue channel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return success immediately (async revocation)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Don't wait for actual credential cleanup - queue it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// startLeaseReaper begins background process to clean up expired leases</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">startLeaseReaper</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create ticker that runs every 30 seconds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Start goroutine that selects on ticker and stopChan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: On each tick, call e.processExpiredLeases()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Store ticker in e.reaperTicker for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use time.NewTicker(30 * time.Second)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// processExpiredLeases finds expired leases and queues them for revocation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">processExpiredLeases</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get current time and find all leases expired before now</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Use lease index to efficiently find expired lease IDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each expired lease, create RevocationQueue entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Queue revocation requests (priority 2 for normal expiration)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update lease status to \"expired\" </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Remove from expiration index</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Process in batches of 100-500 to avoid memory spikes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// startRevocationWorkers begins background workers to process revocation queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">startRevocationWorkers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">numWorkers</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Start numWorkers goroutines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Each worker should select on revocationQueue and stopChan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each revocation request, call e.processRevocation()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle panics in worker goroutines with recovery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use worker pool pattern with shared revocation queue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// processRevocation executes actual credential cleanup with retry logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">processRevocation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">revReq</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">RevocationQueue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up backend by revReq.BackendPath</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call backend.RevokeCredentials with revReq.RevocationData</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If successful, mark revocation complete and return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If failed, increment revReq.AttemptCount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Calculate next retry time using exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: If under max attempts, re-queue for retry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: If max attempts exceeded, move to dead letter queue and alert</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use internal.DefaultRetryConfig for backoff calculation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Lease Index (core data structure skeleton):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/dynamic/lease_index.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> dynamic</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LeaseIndex provides efficient lookup of leases by various criteria</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LeaseIndex</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ByExpiration </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ByToken      </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ByBackend    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ActiveCount  </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewLeaseIndex creates an empty lease index</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewLeaseIndex</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LeaseIndex</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">LeaseIndex</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ByExpiration: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ByToken:      </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ByBackend:    </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ActiveCount:  </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AddLease indexes a new lease by all relevant criteria</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LeaseIndex</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AddLease</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">lease</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Lease</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire write lock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Add lease.ID to ByExpiration[lease.ExpiresAt] slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add lease.ID to ByToken[lease.TokenID] slice  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Add lease.ID to ByBackend[lease.BackendPath] slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Increment ActiveCount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Initialize slices if map key doesn't exist yet</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RemoveLease removes a lease from all indexes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LeaseIndex</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RemoveLease</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">lease</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Lease</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire write lock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Remove lease.ID from ByExpiration[lease.ExpiresAt] slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Remove lease.ID from ByToken[lease.TokenID] slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Remove lease.ID from ByBackend[lease.BackendPath] slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Decrement ActiveCount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Clean up empty slices/map entries to prevent memory leaks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use slice filtering to remove specific lease ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetExpiredLeases returns all lease IDs that expired before the given time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LeaseIndex</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetExpiredLeases</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">before</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire read lock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Iterate through ByExpiration map keys (expiration times)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Collect lease ID slices where expiration time &#x3C;= before</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Flatten collected slices into single lease ID slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return deduplicated list of expired lease IDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use make([]string, 0, estimatedSize) for efficiency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetLeasesByToken returns all lease IDs created by the specified token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">idx </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LeaseIndex</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetLeasesByToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tokenID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire read lock  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Look up tokenID in ByToken map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return copy of lease ID slice (don't return internal slice)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return empty slice if token not found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use append([]string(nil), slice...) to copy slice</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints:</strong></p>\n<ul>\n<li>Use <code>sync.RWMutex</code> for lease storage to allow concurrent reads while protecting writes</li>\n<li>Use <code>crypto/rand</code> for secure lease ID generation: <code>uuid.NewRandom()</code> or similar</li>\n<li>Use <code>time.NewTicker()</code> for periodic lease reaper execution</li>\n<li>Use channel-based worker pools for revocation processing: <code>make(chan *RevocationQueue, bufferSize)</code></li>\n<li>Use <code>context.Context</code> throughout for cancellation and timeouts</li>\n<li>Use <code>database/sql</code> with connection pooling for database backends</li>\n<li>Store sensitive data like database passwords in <code>SecretData</code> map, not as struct fields</li>\n<li>Use <code>json</code> tags on structs for configuration serialization</li>\n</ul>\n<p><strong>F. Milestone Checkpoint:</strong></p>\n<p>After implementing the dynamic secret engine:</p>\n<p><strong>What to run:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/dynamic/...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/server/main.go</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"X-Vault-Token: </span><span style=\"color:#E1E4E8\">$TOKEN</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8443/v1/database/config/mydb</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -d</span><span style=\"color:#9ECBFF\"> '{\"connection_url\": \"user:pass@tcp(localhost:3306)/\", \"allowed_roles\": [\"readonly\"]}'</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"X-Vault-Token: </span><span style=\"color:#E1E4E8\">$TOKEN</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8443/v1/database/roles/readonly</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -d</span><span style=\"color:#9ECBFF\"> '{\"creation_statements\": [\"CREATE USER {{name}} IDENTIFIED BY {{password}}\", \"GRANT SELECT ON myapp.* TO {{name}}\"], \"default_ttl\": \"1h\", \"max_ttl\": \"24h\"}'</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"X-Vault-Token: </span><span style=\"color:#E1E4E8\">$TOKEN</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> GET</span><span style=\"color:#9ECBFF\"> http://localhost:8443/v1/database/creds/readonly</span></span></code></pre></div>\n\n<p><strong>Expected output:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"lease_id\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"database/creds/readonly/abc123-def456-789012\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"renewable\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"lease_duration\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">3600</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"data\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"username\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"vault-readonly-20241201-142735-xyz789\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"password\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"A1b2C3d4E5f6G7h8I9j0K1l2M3n4O5p6\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>What to verify:</strong></p>\n<ul>\n<li>Database should contain new user with generated username</li>\n<li>Lease should appear in lease index and be tracked for expiration</li>\n<li>After lease TTL expires, database user should be automatically removed</li>\n<li>Lease renewal should extend expiration time without creating new user</li>\n</ul>\n<p><strong>Signs something is wrong:</strong></p>\n<ul>\n<li>Credentials returned but no database user created → Check backend connection and privileges</li>\n<li>User created but not removed after expiration → Check lease reaper and revocation queue processing</li>\n<li>Lease renewal fails → Verify MaxTTL calculation and lease status checks</li>\n<li>High memory usage → Check for lease index cleanup and slice memory leaks</li>\n</ul>\n<h2 id=\"unsealing-and-high-availability\">Unsealing and High Availability</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section implements Milestone 4 (Unsealing &amp; High Availability), focusing on Shamir&#39;s secret sharing for master key protection, seal/unseal operations, distributed consensus for high availability, and cloud KMS integration for automated unsealing.</p>\n</blockquote>\n<p>The final milestone transforms our secret management system from a single-node service into a production-ready, highly available cluster that can operate even when some nodes fail. Think of this transformation like converting a personal safe in your home office into a bank&#39;s vault system with multiple security officers, where several officers must work together to open the vault, but the bank remains operational even if some officers are unavailable.</p>\n<p>This milestone introduces two critical capabilities that work together to provide enterprise-grade security and availability. First, <strong>Shamir&#39;s secret sharing</strong> protects the master key by splitting it into multiple shares, ensuring that no single person or compromised system can access all secrets. Second, <strong>high availability clustering</strong> ensures the secret management service remains accessible even during node failures, network partitions, or maintenance windows.</p>\n<p>The unsealing mechanism addresses a fundamental security principle: the master key should never exist in plaintext on persistent storage, and the system should start in a &quot;sealed&quot; state that requires human intervention or trusted external systems to become operational. This provides protection against scenarios like stolen hard drives, compromised backups, or unauthorized system restarts.</p>\n<p>The high availability features transform our system from a single point of failure into a distributed service that can tolerate node failures while maintaining consistency. This is critical for production environments where secret management downtime can cascade into application outages across an entire infrastructure.</p>\n<h3 id=\"shamir39s-secret-sharing-splitting-master-key-into-shares-for-security\">Shamir&#39;s Secret Sharing: Splitting Master Key into Shares for Security</h3>\n<p>Shamir&#39;s secret sharing provides the cryptographic foundation for protecting our master key through a threshold scheme that distributes trust across multiple parties. Think of it like a safety deposit box that requires multiple keys held by different bank officers - no single officer can access the contents alone, but any sufficient subset of officers working together can open the box.</p>\n<p>The mathematical elegance of Shamir&#39;s scheme lies in polynomial interpolation over finite fields. To protect a secret with a threshold of <code>t</code> shares from a total of <code>n</code> shares, we construct a random polynomial of degree <code>t-1</code> where the secret is the y-intercept (constant term). Each share represents a point on this polynomial, and any <code>t</code> points are sufficient to reconstruct the original polynomial and recover the secret. Fewer than <code>t</code> points reveal no information about the secret due to the randomness of the higher-order coefficients.</p>\n<blockquote>\n<p><strong>Decision: Shamir&#39;s Secret Sharing for Master Key Protection</strong></p>\n<ul>\n<li><strong>Context</strong>: Master key must be protected against single-point-of-compromise while remaining accessible for legitimate operations</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Store encrypted master key with password</li>\n<li>Hardware Security Module (HSM) only</li>\n<li>Shamir&#39;s secret sharing with configurable threshold</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Implement Shamir&#39;s secret sharing with 5 shares and 3-of-5 threshold as default</li>\n<li><strong>Rationale</strong>: Provides cryptographically sound distribution of trust, tolerates loss of 2 shares, requires collaboration of multiple operators, and works without specialized hardware</li>\n<li><strong>Consequences</strong>: Enables true zero-trust master key storage but requires coordination of multiple operators during unsealing operations</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Shamir Parameter</th>\n<th>Type</th>\n<th>Description</th>\n<th>Default Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Total Shares</td>\n<td>int</td>\n<td>Total number of key shares generated during initialization</td>\n<td>5</td>\n</tr>\n<tr>\n<td>Threshold</td>\n<td>int</td>\n<td>Minimum number of shares required to reconstruct master key</td>\n<td>3</td>\n</tr>\n<tr>\n<td>Share Length</td>\n<td>int</td>\n<td>Length of each share in bytes</td>\n<td>33 (1 byte x-coordinate + 32 bytes y-coordinate)</td>\n</tr>\n<tr>\n<td>Prime Field</td>\n<td>big.Int</td>\n<td>Prime number defining the finite field for polynomial arithmetic</td>\n<td>2^256 - 189</td>\n</tr>\n<tr>\n<td>Share Format</td>\n<td>string</td>\n<td>Encoding format for human-readable shares</td>\n<td>Base64 with checksums</td>\n</tr>\n</tbody></table>\n<p>The share generation process follows these mathematical steps during system initialization:</p>\n<ol>\n<li><strong>Generate Random Coefficients</strong>: Create <code>threshold - 1</code> random coefficients for polynomial of degree <code>threshold - 1</code>, ensuring the constant term equals the master key</li>\n<li><strong>Evaluate Polynomial</strong>: For each share <code>i</code> from 1 to <code>total_shares</code>, evaluate the polynomial <code>P(i)</code> to get the y-coordinate of share <code>i</code></li>\n<li><strong>Encode Shares</strong>: Format each share as <code>(x=i, y=P(i))</code> pair with checksums and base64 encoding for human handling</li>\n<li><strong>Verify Reconstruction</strong>: Test that any <code>threshold</code> subset of shares correctly reconstructs the original master key</li>\n<li><strong>Secure Distribution</strong>: Present shares to operators through secure channels, ensuring no single operator receives multiple shares</li>\n</ol>\n<p>The reconstruction process reverses this during unsealing operations:</p>\n<ol>\n<li><strong>Collect Threshold Shares</strong>: Gather at least <code>threshold</code> valid shares from operators through authenticated input channels</li>\n<li><strong>Parse and Validate</strong>: Decode base64 shares, verify checksums, and extract <code>(x, y)</code> coordinate pairs for each share</li>\n<li><strong>Lagrange Interpolation</strong>: Use Lagrange interpolation formula to reconstruct polynomial coefficients from the provided points</li>\n<li><strong>Extract Secret</strong>: Evaluate reconstructed polynomial at x=0 to recover the master key (constant term)</li>\n<li><strong>Validate Reconstruction</strong>: Verify reconstructed key matches expected format and can decrypt a test data encryption key</li>\n</ol>\n<p>The <code>ShamirManager</code> handles the cryptographic operations while maintaining security invariants:</p>\n<table>\n<thead>\n<tr>\n<th>ShamirManager Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GenerateShares</td>\n<td>masterKey []byte, threshold int, totalShares int</td>\n<td>([]Share, error)</td>\n<td>Splits master key into shares using polynomial over finite field</td>\n</tr>\n<tr>\n<td>ReconstructSecret</td>\n<td>shares []Share</td>\n<td>([]byte, error)</td>\n<td>Reconstructs master key from threshold number of valid shares</td>\n</tr>\n<tr>\n<td>ValidateShare</td>\n<td>share Share</td>\n<td>bool</td>\n<td>Verifies share format, checksum, and coordinate validity</td>\n</tr>\n<tr>\n<td>SecureInput</td>\n<td>prompt string</td>\n<td>(Share, error)</td>\n<td>Collects share from operator with secure terminal input (no echo)</td>\n</tr>\n<tr>\n<td>FormatShare</td>\n<td>x int, y []byte</td>\n<td>string</td>\n<td>Encodes coordinate pair as base64 string with checksum</td>\n</tr>\n<tr>\n<td>ParseShare</td>\n<td>shareData string</td>\n<td>(Share, error)</td>\n<td>Decodes and validates share from base64 string representation</td>\n</tr>\n</tbody></table>\n<p>Share security depends on several critical implementation details. Each share must include a cryptographic checksum to prevent typos or corruption during manual entry. The finite field arithmetic must use constant-time operations to prevent timing attacks during reconstruction. Share storage locations should be physically and logically separated - storing all shares on the same backup system defeats the security purpose.</p>\n<blockquote>\n<p>The critical security insight is that Shamir&#39;s scheme provides information-theoretic security: even with unlimited computational power, fewer than threshold shares reveal zero information about the secret. This is stronger than computational security based on hard mathematical problems.</p>\n</blockquote>\n<p><strong>Common Pitfalls in Shamir Implementation:</strong></p>\n<p>⚠️ <strong>Pitfall: Storing Multiple Shares Together</strong>\nMany implementations defeat Shamir&#39;s security by storing multiple shares in the same location (backup system, configuration management, etc.). This creates a single point of compromise that can gather enough shares to reconstruct the master key. Instead, ensure shares are distributed to different operators, stored in separate physical locations, and never aggregated in any single system or backup.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Randomness in Polynomial Coefficients</strong>\nUsing weak random number generation for polynomial coefficients can make the scheme vulnerable to attacks. The coefficients must be cryptographically random and uniformly distributed over the finite field. Use <code>/dev/urandom</code> or equivalent cryptographic RNG, never <code>math/rand</code> or similar pseudo-random generators.</p>\n<p>⚠️ <strong>Pitfall: Polynomial Degree Mismatch</strong>\nA polynomial of degree <code>t-1</code> requires exactly <code>t</code> points for unique reconstruction. Using degree <code>t</code> requires <code>t+1</code> points, which changes the threshold unexpectedly. Ensure the polynomial degree equals <code>threshold - 1</code> and that exactly <code>threshold</code> shares are required for reconstruction.</p>\n<p>⚠️ <strong>Pitfall: Memory Persistence of Reconstructed Key</strong>\nAfter reconstructing the master key from shares, the key must be cleared from memory when no longer needed. Go&#39;s garbage collector cannot guarantee memory clearing, so use explicit zeroing of byte slices and consider using <code>mlock()</code> to prevent swapping to disk during reconstruction operations.</p>\n<h3 id=\"seal-and-unseal-operations-system-startup-and-key-reconstruction-process\">Seal and Unseal Operations: System Startup and Key Reconstruction Process</h3>\n<p>The seal and unseal mechanism implements a security state machine that protects the system&#39;s cryptographic capabilities when not in active use. Think of this like a bank vault that automatically locks itself during non-business hours and requires multiple officers to unlock it each morning - the vault provides maximum security by default and only becomes accessible through deliberate, authenticated actions.</p>\n<p><img src=\"/api/project/secret-management/architecture-doc/asset?path=diagrams%2Funseal-process-flow.svg\" alt=\"Unseal Process Flow\"></p>\n<p>When sealed, our secret management system enters a hardened state where all cryptographic operations are disabled, the master key is absent from memory, and only basic administrative operations remain available. This provides defense against a wide range of attack scenarios: memory dumps cannot reveal the master key, compromised processes cannot access secrets, and even insider threats require coordination with multiple other operators.</p>\n<p>The unsealing process transforms the system from this secure but non-functional state into full operational capability by reconstructing the master key from operator-provided shares and loading the cryptographic engines. This state transition must be carefully orchestrated to maintain security properties while providing operational convenience.</p>\n<blockquote>\n<p><strong>Decision: Sealed-by-Default Security Model</strong></p>\n<ul>\n<li><strong>Context</strong>: System must protect secrets even when storage, memory, or processes are compromised</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Always-available model with encrypted master key</li>\n<li>Manual seal/unseal with Shamir&#39;s shares</li>\n<li>Automatic unseal with external key management service</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Implement sealed-by-default with both manual and automatic unseal options</li>\n<li><strong>Rationale</strong>: Provides maximum security against storage compromise, memory extraction, and unauthorized restarts while allowing operational flexibility</li>\n<li><strong>Consequences</strong>: Requires operator intervention after restarts but provides strongest security posture and compliance benefits</li>\n</ul>\n</blockquote>\n<p>The <code>UnsealManager</code> coordinates the state transitions and maintains security invariants:</p>\n<table>\n<thead>\n<tr>\n<th>UnsealManager Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>isSealed</td>\n<td>bool</td>\n<td>Current seal state - true blocks all secret operations</td>\n</tr>\n<tr>\n<td>sealMutex</td>\n<td>sync.RWMutex</td>\n<td>Protects state transitions and concurrent operation checks</td>\n</tr>\n<tr>\n<td>masterKey</td>\n<td>[]byte</td>\n<td>Reconstructed master key (nil when sealed)</td>\n</tr>\n<tr>\n<td>shamirConfig</td>\n<td>ShamirConfig</td>\n<td>Threshold and total share configuration from initialization</td>\n</tr>\n<tr>\n<td>collectedShares</td>\n<td>map[int]Share</td>\n<td>Shares collected during current unseal attempt</td>\n</tr>\n<tr>\n<td>autoUnsealConfig</td>\n<td>*AutoUnsealConfig</td>\n<td>Configuration for cloud KMS auto-unseal (optional)</td>\n</tr>\n<tr>\n<td>sealTime</td>\n<td>time.Time</td>\n<td>Timestamp when system was last sealed</td>\n</tr>\n<tr>\n<td>unsealProgress</td>\n<td>UnsealProgress</td>\n<td>Tracks share collection progress for monitoring</td>\n</tr>\n</tbody></table>\n<p>The seal operation immediately transitions the system to a secure state through these steps:</p>\n<ol>\n<li><strong>Acquire Write Lock</strong>: Take exclusive lock on seal mutex to prevent concurrent operations during state transition</li>\n<li><strong>Stop Secret Operations</strong>: Set sealed flag to true, causing all secret API endpoints to return &quot;sealed&quot; errors immediately  </li>\n<li><strong>Clear Cryptographic Material</strong>: Zero the master key byte slice in memory and set pointer to nil</li>\n<li><strong>Shutdown Engines</strong>: Stop encryption, authentication, and dynamic secret engines, clearing any cached keys or credentials</li>\n<li><strong>Persist Seal State</strong>: Write seal state marker to storage to maintain sealed state across restarts</li>\n<li><strong>Log Security Event</strong>: Record seal operation in audit log with timestamp, operator identity, and reason</li>\n</ol>\n<p>The unseal operation reverses this process but requires careful validation at each step:</p>\n<ol>\n<li><strong>Validate Unseal Preconditions</strong>: Check that system is currently sealed, required shares have been collected, and no conflicting operations are in progress</li>\n<li><strong>Reconstruct Master Key</strong>: Use Shamir&#39;s reconstruction algorithm on collected shares to recover the master key, validating mathematical consistency  </li>\n<li><strong>Verify Master Key</strong>: Test reconstructed key by attempting to decrypt a known data encryption key, ensuring the reconstruction was successful</li>\n<li><strong>Initialize Engines</strong>: Start encryption engine with reconstructed master key, load data encryption keys, and prepare cryptographic operations</li>\n<li><strong>Clear Collected Shares</strong>: Zero share data from memory to prevent future reconstruction attempts using same shares</li>\n<li><strong>Update System State</strong>: Set sealed flag to false and remove seal state marker from persistent storage</li>\n<li><strong>Log Security Event</strong>: Record successful unseal in audit log with participating operator count and timestamp</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Unseal State</th>\n<th>Description</th>\n<th>Allowed Operations</th>\n<th>Next States</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Sealed</td>\n<td>No master key in memory, all secret operations blocked</td>\n<td>Health checks, unseal share submission, status queries</td>\n<td>Unsealing, AutoUnsealing</td>\n</tr>\n<tr>\n<td>Unsealing</td>\n<td>Collecting shares for manual unseal</td>\n<td>Share submission, unseal status, cancel unseal</td>\n<td>Sealed, Active</td>\n</tr>\n<tr>\n<td>AutoUnsealing</td>\n<td>Attempting automatic unseal with external KMS</td>\n<td>Status queries, health checks</td>\n<td>Sealed, Active</td>\n</tr>\n<tr>\n<td>Active</td>\n<td>Master key available, all operations functional</td>\n<td>All secret operations, seal command</td>\n<td>Sealed</td>\n</tr>\n</tbody></table>\n<p>The share collection process during unsealing provides feedback to operators while maintaining security:</p>\n<table>\n<thead>\n<tr>\n<th>UnsealProgress Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SharesRequired</td>\n<td>int</td>\n<td>Total number of shares needed (threshold value)</td>\n</tr>\n<tr>\n<td>SharesCollected</td>\n<td>int</td>\n<td>Number of valid shares received so far</td>\n</tr>\n<tr>\n<td>SharesRemaining</td>\n<td>int</td>\n<td>Additional shares needed to complete unsealing</td>\n</tr>\n<tr>\n<td>CollectedShareIDs</td>\n<td>[]int</td>\n<td>X-coordinates of shares collected (not the share values)</td>\n</tr>\n<tr>\n<td>LastShareTime</td>\n<td>time.Time</td>\n<td>When most recent share was submitted</td>\n</tr>\n<tr>\n<td>UnsealStartTime</td>\n<td>time.Time</td>\n<td>When first share collection began</td>\n</tr>\n</tbody></table>\n<p>The unseal API provides a stateful interface for operators to submit shares incrementally:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>POST /sys/unseal\n{\n  &quot;share&quot;: &quot;base64-encoded-share-with-checksum&quot;,\n  &quot;reset&quot;: false  // optional: reset collected shares and start over\n}\n\nResponse:\n{\n  &quot;sealed&quot;: true/false,\n  &quot;progress&quot;: {\n    &quot;shares_required&quot;: 3,\n    &quot;shares_collected&quot;: 1, \n    &quot;shares_remaining&quot;: 2\n  },\n  &quot;unseal_time&quot;: &quot;2024-01-15T10:30:45Z&quot; // only present when unsealed\n}</code></pre></div>\n\n<p><strong>Error Handling During Unseal Operations:</strong></p>\n<p>The unseal process must handle various failure scenarios gracefully while maintaining security properties:</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Method</th>\n<th>Recovery Action</th>\n<th>Security Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Invalid Share Format</td>\n<td>Base64 decode failure, checksum mismatch</td>\n<td>Reject share, maintain collection state</td>\n<td>None - invalid input ignored</td>\n</tr>\n<tr>\n<td>Duplicate Share</td>\n<td>X-coordinate matches previously collected share</td>\n<td>Reject duplicate, continue collection</td>\n<td>None - prevents operator confusion</td>\n</tr>\n<tr>\n<td>Insufficient Shares</td>\n<td>Reconstruction attempted with &lt; threshold shares</td>\n<td>Return error, maintain collection state</td>\n<td>None - mathematical impossibility</td>\n</tr>\n<tr>\n<td>Reconstruction Failure</td>\n<td>Lagrange interpolation produces invalid key</td>\n<td>Clear all shares, return to sealed state</td>\n<td>High - indicates tampering or corruption</td>\n</tr>\n<tr>\n<td>Key Validation Failure</td>\n<td>Reconstructed key cannot decrypt test DEK</td>\n<td>Clear shares, seal system, alert</td>\n<td>High - indicates key corruption or attack</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The unsealing process represents a critical security boundary. Once shares are collected and the master key is reconstructed, the system transitions from maximum security (sealed) to operational capability (unsealed). This transition must be atomic and auditable.</p>\n</blockquote>\n<p><strong>Common Pitfalls in Seal/Unseal Implementation:</strong></p>\n<p>⚠️ <strong>Pitfall: Race Conditions During State Transitions</strong>\nConcurrent seal and unseal operations, or secret requests during state transitions, can lead to inconsistent state or security vulnerabilities. Always use proper locking (read locks for checking state, write locks for changing state) and ensure all secret operations check the sealed state under lock protection.</p>\n<p>⚠️ <strong>Pitfall: Persistent Share Storage</strong> \nSome implementations cache collected shares to disk &quot;for convenience&quot; during multi-step unseal operations. This completely undermines Shamir&#39;s security by creating a single point where multiple shares can be compromised. Shares must only exist in memory during the unseal process and be immediately zeroed afterward.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Master Key Validation</strong>\nAfter reconstructing the master key from shares, some implementations skip validation and assume the reconstruction was correct. This can lead to accepting corrupted or malicious keys. Always validate the reconstructed key by testing it against known encrypted data before transitioning to unsealed state.</p>\n<p>⚠️ <strong>Pitfall: Seal State Inconsistency</strong>\nThe seal state must be consistent across memory flags, persistent storage markers, and actual cryptographic engine state. Inconsistencies can lead to security bypasses or operational failures. Ensure all seal/unseal operations update all state locations atomically and include recovery logic for partial state updates.</p>\n<h3 id=\"high-availability-and-consensus-leader-election-and-data-replication-strategies\">High Availability and Consensus: Leader Election and Data Replication Strategies</h3>\n<p>High availability transforms our secret management system from a single-node service into a distributed cluster that continues operating despite node failures, network partitions, and maintenance activities. Think of this like a hospital emergency room with multiple doctors on duty - if one doctor becomes unavailable, the others continue providing care without interruption, and there&#39;s a clear protocol for who takes charge during critical situations.</p>\n<p>The fundamental challenge in distributed secret management lies in maintaining strong consistency while providing high availability. Unlike eventual consistency systems where temporary disagreement is acceptable, secret management requires that all nodes have identical views of policies, secrets, and leases. A policy change that allows access on one node but not another could create security vulnerabilities or operational confusion.</p>\n<p>Our approach implements a <strong>leader-follower architecture</strong> with <strong>Raft consensus</strong> to ensure linearizable consistency across all cluster operations. One node serves as the elected leader and handles all write operations, while follower nodes can serve read requests and automatically promote to leader if the current leader fails. This provides both consistency guarantees and fault tolerance.</p>\n<blockquote>\n<p><strong>Decision: Raft Consensus for Cluster Coordination</strong></p>\n<ul>\n<li><strong>Context</strong>: Need strong consistency for security policies while providing high availability and partition tolerance</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Multi-master with conflict resolution (eventual consistency)</li>\n<li>Paxos-based consensus with separate coordination service</li>\n<li>Raft consensus integrated into secret management nodes</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Implement Raft consensus directly within secret management nodes</li>\n<li><strong>Rationale</strong>: Raft provides understandable strong consistency, integrates well with our existing architecture, and avoids external dependencies for coordination</li>\n<li><strong>Consequences</strong>: Enables strongly consistent cluster operations but requires majority of nodes to be available for write operations</li>\n</ul>\n</blockquote>\n<p>The <code>ClusterManager</code> handles all distributed coordination and maintains cluster membership:</p>\n<table>\n<thead>\n<tr>\n<th>ClusterManager Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>nodeID</td>\n<td>string</td>\n<td>Unique identifier for this cluster node</td>\n</tr>\n<tr>\n<td>raftNode</td>\n<td>*raft.Raft</td>\n<td>Raft consensus implementation handling leader election and log replication</td>\n</tr>\n<tr>\n<td>transport</td>\n<td>raft.Transport</td>\n<td>Network transport for inter-node Raft messages</td>\n</tr>\n<tr>\n<td>logStore</td>\n<td>raft.LogStore</td>\n<td>Persistent storage for Raft log entries</td>\n</tr>\n<tr>\n<td>stableStore</td>\n<td>raft.StableStore</td>\n<td>Persistent storage for Raft metadata (current term, voted for)</td>\n</tr>\n<tr>\n<td>snapshotter</td>\n<td>raft.SnapshotStore</td>\n<td>Handles creation and restoration of cluster state snapshots</td>\n</tr>\n<tr>\n<td>peerSet</td>\n<td>[]string</td>\n<td>Current cluster membership configuration</td>\n</tr>\n<tr>\n<td>leadershipChan</td>\n<td>chan bool</td>\n<td>Notifies when this node gains or loses leadership</td>\n</tr>\n<tr>\n<td>isLeader</td>\n<td>bool</td>\n<td>Current leadership status of this node</td>\n</tr>\n<tr>\n<td>lastContact</td>\n<td>time.Time</td>\n<td>Timestamp of last successful contact with cluster leader</td>\n</tr>\n</tbody></table>\n<p>The Raft implementation manages three distinct roles that nodes can occupy:</p>\n<table>\n<thead>\n<tr>\n<th>Node Role</th>\n<th>Responsibilities</th>\n<th>Message Handling</th>\n<th>State Transitions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Leader</td>\n<td>Processes all write requests, sends heartbeats, replicates log entries</td>\n<td>Accepts client requests, sends AppendEntries to followers</td>\n<td>Can become follower on higher term or loss of majority</td>\n</tr>\n<tr>\n<td>Follower</td>\n<td>Serves read requests, forwards writes to leader, participates in elections</td>\n<td>Responds to AppendEntries and RequestVote messages</td>\n<td>Can become candidate on leader timeout</td>\n</tr>\n<tr>\n<td>Candidate</td>\n<td>Requests votes during leader election</td>\n<td>Sends RequestVote, counts responses</td>\n<td>Becomes leader with majority votes or follower with higher term</td>\n</tr>\n</tbody></table>\n<p><strong>Leader Election Process:</strong></p>\n<p>The leader election algorithm ensures exactly one leader exists at any time while handling various failure scenarios:</p>\n<ol>\n<li><strong>Detect Leader Failure</strong>: Followers monitor heartbeat messages from leader, starting election timer if no contact within election timeout (150-300ms randomized)</li>\n<li><strong>Become Candidate</strong>: Node increments term number, votes for itself, transitions to candidate role, and resets election timer with random component  </li>\n<li><strong>Request Votes</strong>: Send RequestVote messages to all other cluster members containing candidate term, node ID, and last log entry information</li>\n<li><strong>Evaluate Vote Responses</strong>: Collect votes from other nodes, checking that response term matches request term and vote is granted</li>\n<li><strong>Achieve Majority</strong>: If candidate receives votes from majority of nodes (including self), transition to leader role and begin sending heartbeats</li>\n<li><strong>Handle Split Vote</strong>: If no candidate achieves majority before timeout, increment term and restart election with new randomized timeout</li>\n</ol>\n<p><strong>Data Replication and Log Management:</strong></p>\n<p>All cluster state changes flow through the Raft log to ensure consistent ordering and durability across nodes:</p>\n<table>\n<thead>\n<tr>\n<th>Raft Log Entry Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Index</td>\n<td>uint64</td>\n<td>Sequential position in the Raft log (monotonically increasing)</td>\n</tr>\n<tr>\n<td>Term</td>\n<td>uint64</td>\n<td>Leader term when entry was created (for detecting stale leaders)</td>\n</tr>\n<tr>\n<td>Type</td>\n<td>LogEntryType</td>\n<td>Type of operation (SecretCreate, PolicyUpdate, TokenRevoke, etc.)</td>\n</tr>\n<tr>\n<td>Data</td>\n<td>[]byte</td>\n<td>Serialized operation data containing all information needed to apply change</td>\n</tr>\n<tr>\n<td>Timestamp</td>\n<td>time.Time</td>\n<td>When leader created this log entry</td>\n</tr>\n<tr>\n<td>ClientID</td>\n<td>string</td>\n<td>Identifier of client that initiated this operation (for deduplication)</td>\n</tr>\n<tr>\n<td>Checksum</td>\n<td>[]byte</td>\n<td>Integrity check for log entry corruption detection</td>\n</tr>\n</tbody></table>\n<p>The log replication process ensures all nodes maintain identical state:</p>\n<ol>\n<li><strong>Receive Client Request</strong>: Leader validates request, assigns unique log index, and creates log entry with current term</li>\n<li><strong>Append to Local Log</strong>: Leader writes entry to local Raft log with fsync for durability before proceeding</li>\n<li><strong>Replicate to Followers</strong>: Send AppendEntries messages containing new log entry to all follower nodes</li>\n<li><strong>Wait for Majority</strong>: Leader waits for successful acknowledgments from majority of cluster (including self) before committing</li>\n<li><strong>Apply to State Machine</strong>: Once majority confirms, leader applies operation to local state machine and marks entry as committed</li>\n<li><strong>Notify Client</strong>: Return success response to client only after operation is committed and applied</li>\n<li><strong>Propagate Commit</strong>: Next AppendEntries messages inform followers that entry is committed, triggering application to their state machines</li>\n</ol>\n<p><strong>Snapshot Management for Log Compaction:</strong></p>\n<p>Raft logs grow continuously and must be periodically compacted to prevent unbounded storage growth:</p>\n<table>\n<thead>\n<tr>\n<th>Snapshot Component</th>\n<th>Description</th>\n<th>Contents</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>State Machine Image</td>\n<td>Complete secret management state at specific log index</td>\n<td>All secrets, policies, tokens, leases, and dynamic secret backends</td>\n</tr>\n<tr>\n<td>Last Included Index</td>\n<td>Log index of last entry included in snapshot</td>\n<td>Used to determine which log entries can be safely deleted</td>\n</tr>\n<tr>\n<td>Last Included Term</td>\n<td>Term of last entry included in snapshot</td>\n<td>Required for maintaining Raft invariants during snapshot installation</td>\n</tr>\n<tr>\n<td>Cluster Configuration</td>\n<td>Membership and peer information</td>\n<td>Node IDs and addresses for cluster reconfiguration</td>\n</tr>\n<tr>\n<td>Encryption Context</td>\n<td>Current key versions and rotation state</td>\n<td>Necessary for continuing encryption operations after restore</td>\n</tr>\n</tbody></table>\n<p><strong>High Availability Deployment Topology:</strong></p>\n<p>A production cluster typically consists of 3 or 5 nodes deployed across multiple failure domains:</p>\n<table>\n<thead>\n<tr>\n<th>Cluster Size</th>\n<th>Fault Tolerance</th>\n<th>Split-Brain Protection</th>\n<th>Performance Characteristics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>3 nodes</td>\n<td>1 node failure</td>\n<td>Requires 2/3 majority</td>\n<td>Good performance, minimal resource usage</td>\n</tr>\n<tr>\n<td>5 nodes</td>\n<td>2 node failures</td>\n<td>Requires 3/5 majority</td>\n<td>Higher fault tolerance, more replication overhead</td>\n</tr>\n<tr>\n<td>7+ nodes</td>\n<td>3+ node failures</td>\n<td>Requires (n/2)+1 majority</td>\n<td>Maximum fault tolerance, significant replication cost</td>\n</tr>\n</tbody></table>\n<p>The cluster handles read and write operations differently to balance consistency and availability:</p>\n<table>\n<thead>\n<tr>\n<th>Operation Type</th>\n<th>Leader Behavior</th>\n<th>Follower Behavior</th>\n<th>Consistency Guarantee</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Write Operations</td>\n<td>Process locally, replicate via Raft, respond after majority commit</td>\n<td>Forward to leader, return leader response</td>\n<td>Linearizable (strongest)</td>\n</tr>\n<tr>\n<td>Read Operations</td>\n<td>Serve immediately from local state</td>\n<td>Serve from local state with staleness bounds</td>\n<td>Eventually consistent by default</td>\n</tr>\n<tr>\n<td>Consistent Reads</td>\n<td>Process locally after confirming leadership</td>\n<td>Forward to leader for consistency guarantee</td>\n<td>Linearizable when requested</td>\n</tr>\n</tbody></table>\n<p><strong>Network Partition Handling:</strong></p>\n<p>Network partitions represent one of the most challenging failure modes for distributed systems:</p>\n<table>\n<thead>\n<tr>\n<th>Partition Scenario</th>\n<th>Majority Partition Behavior</th>\n<th>Minority Partition Behavior</th>\n<th>Recovery Process</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Clean Split</td>\n<td>Continue serving requests normally</td>\n<td>Enter read-only mode, reject writes</td>\n<td>Rejoin cluster, sync from majority</td>\n</tr>\n<tr>\n<td>Flapping Network</td>\n<td>May experience leadership churn</td>\n<td>Cannot form stable quorum</td>\n<td>Use jitter and backoff in elections</td>\n</tr>\n<tr>\n<td>Isolated Leader</td>\n<td>Step down if cannot contact majority</td>\n<td>Elect new leader from remaining nodes</td>\n<td>Former leader rejoins as follower</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The key insight for partition tolerance is that Raft chooses consistency over availability - a minority partition becomes read-only rather than risk split-brain scenarios that could compromise security policies.</p>\n</blockquote>\n<p><strong>Common Pitfalls in High Availability Implementation:</strong></p>\n<p>⚠️ <strong>Pitfall: Split-Brain Scenarios</strong>\nAllowing multiple nodes to accept write operations simultaneously can lead to conflicting policies, duplicated secrets, or security vulnerabilities. Always ensure only the elected Raft leader processes writes, and that leadership changes require majority consensus. Use fencing mechanisms to prevent former leaders from processing requests after losing leadership.</p>\n<p>⚠️ <strong>Pitfall: Unbounded Log Growth</strong> \nRaft logs grow continuously and can consume all available disk space if not properly managed. Implement regular snapshotting with configurable thresholds (e.g., every 10,000 entries or 100MB), and ensure old log entries are safely deleted after successful snapshot creation.</p>\n<p>⚠️ <strong>Pitfall: Clock Synchronization Dependencies</strong>\nWhile Raft doesn&#39;t require synchronized clocks for correctness, significant clock skew can cause operational issues like incorrect lease expiration or audit log ordering. Use NTP or similar time synchronization, and design timeout values to be robust against reasonable clock drift (±100ms typically).</p>\n<p>⚠️ <strong>Pitfall: Inadequate Failure Detection</strong>\nSetting heartbeat intervals too long delays failure detection and increases unavailability windows, while too short intervals create unnecessary network traffic and false positives. Use randomized election timeouts (150-300ms) and heartbeat intervals around 50ms for good balance between responsiveness and stability.</p>\n<h3 id=\"auto-unseal-integration-cloud-kms-integration-for-automated-unsealing\">Auto-Unseal Integration: Cloud KMS Integration for Automated Unsealing</h3>\n<p>Auto-unseal integration addresses the operational challenge of manual unsealing in production environments while maintaining security properties through external key management services. Think of this like a bank vault that can automatically unlock using a secure communication channel with the bank&#39;s central security office - it provides operational convenience without compromising the fundamental security model of keeping the master key protected.</p>\n<p>Traditional manual unsealing requires human operators to input Shamir shares after every system restart, which creates operational burden and potential availability issues. Auto-unseal solves this by encrypting the master key with a key encryption key (KEK) managed by an external, highly available key management service. The system can then automatically retrieve and use the KEK to decrypt its master key during startup, eliminating the need for human intervention while maintaining the security property that the master key is never stored in plaintext.</p>\n<p>The critical security insight is that auto-unseal shifts the trust boundary rather than eliminating it - instead of trusting human operators with Shamir shares, we trust the external KMS provider with the key encryption key. This trade-off makes sense in cloud environments where the KMS provider offers hardware security modules, audit logging, and fine-grained access controls that may exceed what we can achieve with manual processes.</p>\n<blockquote>\n<p><strong>Decision: Hybrid Manual and Auto-Unseal Support</strong></p>\n<ul>\n<li><strong>Context</strong>: Production environments need automated recovery while maintaining option for air-gapped or manual control scenarios  </li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Manual Shamir shares only (maximum security, operational burden)</li>\n<li>Auto-unseal only (operational convenience, external dependencies)</li>\n<li>Hybrid approach supporting both methods</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Implement both manual and auto-unseal with configuration-driven selection</li>\n<li><strong>Rationale</strong>: Provides flexibility for different deployment scenarios, allows migration between methods, and maintains compatibility with security requirements that mandate manual control</li>\n<li><strong>Consequences</strong>: Increases implementation complexity but provides maximum deployment flexibility and migration paths</li>\n</ul>\n</blockquote>\n<p>The <code>AutoUnsealManager</code> handles integration with external key management services:</p>\n<table>\n<thead>\n<tr>\n<th>AutoUnsealManager Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>provider</td>\n<td>KMSProvider</td>\n<td>Interface to specific KMS service (AWS KMS, Azure KeyVault, etc.)</td>\n</tr>\n<tr>\n<td>keyID</td>\n<td>string</td>\n<td>External KMS key identifier for master key encryption</td>\n</tr>\n<tr>\n<td>encryptedMasterKey</td>\n<td>[]byte</td>\n<td>Master key encrypted with KMS key, stored locally</td>\n</tr>\n<tr>\n<td>authConfig</td>\n<td>KMSAuthConfig</td>\n<td>Authentication configuration for KMS service access</td>\n</tr>\n<tr>\n<td>retryConfig</td>\n<td>RetryConfig</td>\n<td>Backoff and timeout settings for KMS operations</td>\n</tr>\n<tr>\n<td>healthChecker</td>\n<td>*KMSHealthChecker</td>\n<td>Monitors KMS service availability and key accessibility</td>\n</tr>\n<tr>\n<td>lastUnsealTime</td>\n<td>time.Time</td>\n<td>Timestamp of most recent successful auto-unseal</td>\n</tr>\n<tr>\n<td>failureCount</td>\n<td>int64</td>\n<td>Count of consecutive auto-unseal failures for alerting</td>\n</tr>\n</tbody></table>\n<p><strong>Key Management Service Provider Interface:</strong></p>\n<p>The KMS provider abstraction allows integration with multiple external key management services:</p>\n<table>\n<thead>\n<tr>\n<th>KMSProvider Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Encrypt</td>\n<td>plaintext []byte, keyID string</td>\n<td>([]byte, error)</td>\n<td>Encrypts data using specified KMS key</td>\n</tr>\n<tr>\n<td>Decrypt</td>\n<td>ciphertext []byte, keyID string</td>\n<td>([]byte, error)</td>\n<td>Decrypts data using specified KMS key</td>\n</tr>\n<tr>\n<td>GenerateDataKey</td>\n<td>keyID string, keySize int</td>\n<td>(plaintext []byte, encrypted []byte, error)</td>\n<td>Generates new data encryption key</td>\n</tr>\n<tr>\n<td>DescribeKey</td>\n<td>keyID string</td>\n<td>(*KeyMetadata, error)</td>\n<td>Retrieves key information and access policies</td>\n</tr>\n<tr>\n<td>ListKeys</td>\n<td>maxResults int</td>\n<td>([]string, error)</td>\n<td>Lists available keys for key discovery</td>\n</tr>\n<tr>\n<td>HealthCheck</td>\n<td>keyID string</td>\n<td>error</td>\n<td>Verifies key exists and is accessible</td>\n</tr>\n</tbody></table>\n<p><strong>AWS KMS Integration Implementation:</strong></p>\n<p>AWS KMS represents the most common auto-unseal scenario and demonstrates the integration pattern:</p>\n<table>\n<thead>\n<tr>\n<th>AWS KMS Configuration</th>\n<th>Type</th>\n<th>Description</th>\n<th>Example Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Region</td>\n<td>string</td>\n<td>AWS region containing the KMS key</td>\n<td>us-west-2</td>\n</tr>\n<tr>\n<td>KeyID</td>\n<td>string</td>\n<td>KMS key identifier (ARN, alias, or key ID)</td>\n<td>alias/vault-unseal-key</td>\n</tr>\n<tr>\n<td>AccessKeyID</td>\n<td>string</td>\n<td>AWS access key for API authentication</td>\n<td>AKIAIOSFODNN7EXAMPLE</td>\n</tr>\n<tr>\n<td>SecretAccessKey</td>\n<td>string</td>\n<td>AWS secret key (should use IAM roles instead)</td>\n<td>wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY</td>\n</tr>\n<tr>\n<td>SessionToken</td>\n<td>string</td>\n<td>AWS session token for temporary credentials</td>\n<td>Optional for STS credentials</td>\n</tr>\n<tr>\n<td>Endpoint</td>\n<td>string</td>\n<td>Custom KMS endpoint for testing or regions</td>\n<td><a href=\"https://kms.us-west-2.amazonaws.com\">https://kms.us-west-2.amazonaws.com</a></td>\n</tr>\n</tbody></table>\n<p>The AWS KMS provider implements the interface using the AWS SDK:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AWSKMSProvider</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">kms</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">KMS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    region   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    keyID    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retries  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timeout  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Auto-Unseal Process Flow:</strong></p>\n<p>The automated unsealing process combines local cryptographic operations with external KMS calls:</p>\n<ol>\n<li><strong>Initialize KMS Client</strong>: Configure authentication credentials, endpoint URLs, and retry policies for the external KMS service</li>\n<li><strong>Retrieve Encrypted Master Key</strong>: Load the locally stored encrypted master key from persistent storage (created during initial seal with auto-unseal)</li>\n<li><strong>Authenticate with KMS</strong>: Present credentials to KMS service and verify access to the configured key encryption key</li>\n<li><strong>Decrypt Master Key</strong>: Call KMS decrypt operation with encrypted master key, receiving plaintext master key in response</li>\n<li><strong>Validate Decrypted Key</strong>: Verify decrypted master key has correct format and can successfully decrypt a test data encryption key</li>\n<li><strong>Initialize Cryptographic Engines</strong>: Start encryption, authentication, and dynamic secret engines using the decrypted master key</li>\n<li><strong>Clear Temporary Data</strong>: Zero the plaintext master key from local variables while leaving it in the encryption engine</li>\n<li><strong>Update System State</strong>: Transition from sealed to unsealed state and begin serving secret management requests</li>\n</ol>\n<p><strong>Failure Handling and Degradation:</strong></p>\n<p>Auto-unseal operations can fail due to network issues, authentication problems, or KMS service outages:</p>\n<table>\n<thead>\n<tr>\n<th>Failure Type</th>\n<th>Symptoms</th>\n<th>Recovery Strategy</th>\n<th>Fallback Options</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network Connectivity</td>\n<td>Timeout errors, connection refused</td>\n<td>Exponential backoff retry with circuit breaker</td>\n<td>Manual unseal if operators available</td>\n</tr>\n<tr>\n<td>Authentication Failure</td>\n<td>401/403 errors from KMS service</td>\n<td>Credential refresh, IAM role validation</td>\n<td>Alternative credentials or manual unseal</td>\n</tr>\n<tr>\n<td>Key Not Found</td>\n<td>404 errors, key disabled/deleted</td>\n<td>Alert operators, check key status</td>\n<td>Restore from backup or manual unseal</td>\n</tr>\n<tr>\n<td>Rate Limiting</td>\n<td>429 errors, quota exceeded</td>\n<td>Implement backoff and jitter</td>\n<td>Queue unseal requests or manual unseal</td>\n</tr>\n<tr>\n<td>KMS Service Outage</td>\n<td>500+ errors, service unavailable</td>\n<td>Extended retry with exponential backoff</td>\n<td>Manual unseal to maintain availability</td>\n</tr>\n</tbody></table>\n<p>The retry mechanism implements exponential backoff with jitter to avoid thundering herd problems:</p>\n<table>\n<thead>\n<tr>\n<th>Retry Attempt</th>\n<th>Base Delay</th>\n<th>Jitter Range</th>\n<th>Max Delay</th>\n<th>Total Elapsed</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>1 second</td>\n<td>±200ms</td>\n<td>1.2s</td>\n<td>1.2s</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2 seconds</td>\n<td>±400ms</td>\n<td>2.4s</td>\n<td>3.6s</td>\n</tr>\n<tr>\n<td>3</td>\n<td>4 seconds</td>\n<td>±800ms</td>\n<td>4.8s</td>\n<td>8.4s</td>\n</tr>\n<tr>\n<td>4</td>\n<td>8 seconds</td>\n<td>±1.6s</td>\n<td>9.6s</td>\n<td>18s</td>\n</tr>\n<tr>\n<td>5+</td>\n<td>30 seconds</td>\n<td>±6s</td>\n<td>36s</td>\n<td>54s+</td>\n</tr>\n</tbody></table>\n<p><strong>Security Considerations for Auto-Unseal:</strong></p>\n<p>Auto-unseal introduces new attack vectors that must be carefully managed:</p>\n<table>\n<thead>\n<tr>\n<th>Security Risk</th>\n<th>Description</th>\n<th>Mitigation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>KMS Key Compromise</td>\n<td>External KMS key is compromised or misused</td>\n<td>Use KMS key policies, audit logging, key rotation</td>\n</tr>\n<tr>\n<td>Credential Exposure</td>\n<td>AWS keys or similar credentials leaked</td>\n<td>Use IAM roles, temporary credentials, credential rotation</td>\n</tr>\n<tr>\n<td>Network Interception</td>\n<td>KMS API calls intercepted or modified</td>\n<td>Use TLS, certificate pinning, request signing</td>\n</tr>\n<tr>\n<td>Replay Attacks</td>\n<td>Old decrypt requests replayed to bypass controls</td>\n<td>Use nonces, timestamps, and request uniqueness</td>\n</tr>\n<tr>\n<td>Privilege Escalation</td>\n<td>Overly broad KMS permissions exploited</td>\n<td>Principle of least privilege, specific key access only</td>\n</tr>\n</tbody></table>\n<p>The KMS key policy should restrict access to only the secret management service:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"Version\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2012-10-17\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"Statement\"</span><span style=\"color:#E1E4E8\">: [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"Effect\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Allow\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"Principal\"</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#79B8FF\">\"AWS\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"arn:aws:iam::ACCOUNT:role/vault-unseal-role\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"Action\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"kms:Decrypt\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"kms:DescribeKey\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"Resource\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"*\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      \"Condition\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        \"StringEquals\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">          \"kms:ViaService\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"kms.REGION.amazonaws.com\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Monitoring and Observability:</strong></p>\n<p>Auto-unseal operations require comprehensive monitoring to detect failures and security issues:</p>\n<table>\n<thead>\n<tr>\n<th>Metric Category</th>\n<th>Key Metrics</th>\n<th>Alerting Thresholds</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Success Rate</td>\n<td>Successful unseals / Total attempts</td>\n<td>&lt; 95% success rate</td>\n</tr>\n<tr>\n<td>Latency</td>\n<td>Time from unseal start to completion</td>\n<td>&gt; 30 seconds</td>\n</tr>\n<tr>\n<td>Error Patterns</td>\n<td>KMS error types and frequencies</td>\n<td>&gt; 5 auth failures/hour</td>\n</tr>\n<tr>\n<td>Credential Health</td>\n<td>Time until credential expiration</td>\n<td>&lt; 24 hours remaining</td>\n</tr>\n<tr>\n<td>Key Accessibility</td>\n<td>KMS key describe success rate</td>\n<td>Any failures</td>\n</tr>\n</tbody></table>\n<p><strong>Common Pitfalls in Auto-Unseal Implementation:</strong></p>\n<p>⚠️ <strong>Pitfall: Storing KMS Credentials in Configuration</strong>\nHard-coding AWS access keys or similar credentials in configuration files creates a security vulnerability that defeats the purpose of external key management. Always use IAM roles, instance profiles, or other credential-less authentication methods when possible.</p>\n<p>⚠️ <strong>Pitfall: Insufficient KMS Error Handling</strong>\nKMS services can return various error types (throttling, authentication, key not found) that require different handling strategies. Implement specific retry logic for retriable errors while immediately failing for authentication issues that require operator intervention.</p>\n<p>⚠️ <strong>Pitfall: Missing Fallback to Manual Unseal</strong>\nIf auto-unseal fails and no manual unseal option is available, the system becomes completely inaccessible until the external dependency is resolved. Always maintain the ability to collect Shamir shares manually as a fallback recovery mechanism.</p>\n<p>⚠️ <strong>Pitfall: Overly Broad KMS Permissions</strong><br>Granting broad KMS permissions like <code>kms:*</code> or access to all keys increases the blast radius if credentials are compromised. Use fine-grained permissions that allow access only to the specific key needed for unsealing operations.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The unsealing and high availability components represent the most complex part of our secret management system, involving distributed systems concepts, cryptographic operations, and external service integration. This implementation guidance provides the foundation and structure needed to build these components incrementally.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Shamir&#39;s Secret Sharing</td>\n<td>Custom implementation with math/big</td>\n<td>Hashicorp go-shamir library</td>\n</tr>\n<tr>\n<td>Raft Consensus</td>\n<td>Hashicorp raft library</td>\n<td>etcd raft implementation</td>\n</tr>\n<tr>\n<td>KMS Integration</td>\n<td>AWS SDK with simple retry</td>\n<td>Multi-cloud abstraction layer</td>\n</tr>\n<tr>\n<td>Network Transport</td>\n<td>HTTP/1.1 with connection pooling</td>\n<td>gRPC with load balancing</td>\n</tr>\n<tr>\n<td>State Storage</td>\n<td>BoltDB embedded database</td>\n<td>Distributed storage backend</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/\n  unseal/\n    shamir.go              ← Shamir's secret sharing implementation\n    shamir_test.go         ← Cryptographic correctness tests\n    manager.go             ← Seal/unseal state machine\n    manager_test.go        ← State transition tests\n  cluster/\n    raft.go                ← Raft consensus integration\n    raft_test.go           ← Leader election and replication tests\n    transport.go           ← Network transport for Raft messages\n    snapshot.go            ← State machine snapshot handling\n  kms/\n    interface.go           ← KMS provider interface definition\n    aws.go                 ← AWS KMS implementation\n    azure.go               ← Azure Key Vault implementation\n    mock.go                ← Mock provider for testing\n    autounseal.go          ← Auto-unseal coordinator\n  server/\n    cluster_server.go      ← HTTP handlers for cluster operations\n    unseal_handlers.go     ← API endpoints for seal/unseal\ncmd/\n  vault-server/\n    main.go                ← Entry point with cluster startup\nconfig/\n  cluster-example.yaml    ← Example cluster configuration</code></pre></div>\n\n<p><strong>Shamir&#39;s Secret Sharing Foundation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> unseal</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/rand</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">errors</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">math/big</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ShamirConfig defines parameters for secret sharing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ShamirConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Threshold   </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">    // Minimum shares required for reconstruction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TotalShares </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">    // Total number of shares to generate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PrimeField  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">big</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Int</span><span style=\"color:#6A737D\"> // Prime number defining finite field</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Share represents a single Shamir share with coordinates</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Share</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    X        </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">    // X-coordinate (share number)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Y        []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\"> // Y-coordinate (share value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Checksum []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\"> // Integrity check for the share</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ShamirManager handles secret sharing operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ShamirManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config </span><span style=\"color:#B392F0\">ShamirConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewShamirManager creates a new manager with given configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewShamirManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">threshold</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">totalShares</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ShamirManager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate threshold &#x3C;= totalShares and both > 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Generate or load appropriate prime field for arithmetic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize ShamirManager with validated configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use a 256-bit prime like 2^256 - 189 for the field</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateShares splits secret into threshold shares</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ShamirManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateShares</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">secret</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">Share</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Convert secret bytes to big integer for polynomial arithmetic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Generate threshold-1 random coefficients for polynomial</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Evaluate polynomial at x=1,2,...,totalShares to create shares  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Add checksums to each share for integrity validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Test reconstruction with threshold shares before returning</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Polynomial is P(x) = secret + c1*x + c2*x^2 + ... + c(t-1)*x^(t-1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReconstructSecret rebuilds secret from threshold shares</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ShamirManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReconstructSecret</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">shares</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Share</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate we have at least threshold shares</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify checksums on all provided shares</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Use Lagrange interpolation to reconstruct polynomial coefficients</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Evaluate polynomial at x=0 to get secret (constant term)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Convert big integer result back to byte slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Lagrange formula: sum over i of (y_i * product over j≠i of (0-x_j)/(x_i-x_j))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Seal/Unseal State Machine:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> unseal</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UnsealManager coordinates system seal/unseal operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> UnsealManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    isSealed        </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sealMutex       </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    masterKey       []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    shamirManager   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ShamirManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    collectedShares </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Share</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    autoUnseal      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AutoUnsealManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // State tracking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sealTime        </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    unsealProgress  </span><span style=\"color:#B392F0\">UnsealProgress</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UnsealProgress tracks share collection during unsealing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> UnsealProgress</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SharesRequired   </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">       `json:\"shares_required\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SharesCollected  </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">       `json:\"shares_collected\"`</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SharesRemaining  </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">       `json:\"shares_remaining\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CollectedShareIDs []</span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `json:\"collected_share_ids\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastShareTime    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"last_share_time\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UnsealStartTime  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"unseal_start_time\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewUnsealManager creates manager with given Shamir configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewUnsealManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">threshold</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">totalShares</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">UnsealManager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create ShamirManager with provided parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize UnsealManager in sealed state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set up empty share collection map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Initialize progress tracking structures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Seal immediately transitions system to sealed state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">um </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">UnsealManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Seal</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire write lock to prevent concurrent operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set sealed flag to true to block secret operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Zero and nil the master key to clear from memory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Clear any collected shares from memory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Record seal time and log security event</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use explicit zeroing like for i := range um.masterKey { um.masterKey[i] = 0 }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SubmitShare adds a share to the unsealing process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">um </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">UnsealManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SubmitShare</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">shareData</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">UnsealProgress</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse and validate the provided share data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if share X-coordinate is already collected (reject duplicates)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add share to collection and update progress tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If threshold reached, attempt reconstruction and unsealing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return current progress status regardless of completion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Always return progress to show operator current state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsSealed returns current seal status (thread-safe)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">um </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">UnsealManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsSealed</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire read lock to safely check state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Return current sealed flag value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use RLock/RUnlock for concurrent read access</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Raft Cluster Integration:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> cluster</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/hashicorp/raft</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ClusterManager handles distributed consensus and replication</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ClusterManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    raftNode    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">raft</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Raft</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transport   </span><span style=\"color:#B392F0\">raft</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Transport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logStore    </span><span style=\"color:#B392F0\">raft</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">LogStore</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stableStore </span><span style=\"color:#B392F0\">raft</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">StableStore</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    snapshots   </span><span style=\"color:#B392F0\">raft</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SnapshotStore</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Leadership tracking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    isLeader       </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leadershipChan </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastContact    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ClusterConfig defines cluster membership and networking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ClusterConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NodeID      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `yaml:\"node_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BindAddress </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `yaml:\"bind_address\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DataDir     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `yaml:\"data_dir\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Peers       []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"peers\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Raft timing parameters</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HeartbeatTimeout   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `yaml:\"heartbeat_timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ElectionTimeout    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `yaml:\"election_timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CommitTimeout      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `yaml:\"commit_timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LeaderLeaseTimeout </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `yaml:\"leader_lease_timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewClusterManager initializes Raft consensus for the node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewClusterManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> ClusterConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterManager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create BoltDB stores for Raft log and stable storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set up TCP transport for inter-node communication</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Configure Raft timing parameters from config</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Initialize Raft node with stores and transport</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Set up leadership change notification channel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use raft.Config with reasonable defaults for timing parameters</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Start begins Raft consensus participation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Bootstrap cluster if this is the first node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Join existing cluster if peers are configured</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Start leadership monitoring goroutine</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Begin accepting client requests based on leadership status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check if stable store is empty to determine bootstrap vs join</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Apply submits operation to Raft for consensus and replication</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Apply</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">operation</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if this node is current leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create Raft log entry with operation data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Submit to Raft and wait for majority commitment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return error if operation fails consensus or times out</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Only leaders can accept write operations in Raft</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsLeader returns current leadership status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsLeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Return cached leadership status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Consider checking Raft state for authoritative answer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Cache leadership to avoid expensive Raft state checks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Auto-Unseal with AWS KMS:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> kms</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/aws/aws-sdk-go/service/kms</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// KMSProvider defines interface for key management services</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> KMSProvider</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Encrypt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">plaintext</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">keyID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Decrypt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ciphertext</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">keyID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    HealthCheck</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">keyID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AWSKMSProvider implements KMS interface for AWS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AWSKMSProvider</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">kms</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">KMS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    region  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    keyID   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retries </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timeout </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AutoUnsealManager coordinates automatic unsealing with external KMS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AutoUnsealManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    provider           </span><span style=\"color:#B392F0\">KMSProvider</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    keyID              </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    encryptedMasterKey []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retryConfig        </span><span style=\"color:#B392F0\">RetryConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    healthChecker      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">KMSHealthChecker</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Monitoring</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastUnsealTime </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failureCount   </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewAWSKMSProvider creates AWS KMS client with configuration  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewAWSKMSProvider</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">region</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">keyID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AWSKMSProvider</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create AWS session with region and credentials</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize KMS client with session</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Configure retry behavior and timeouts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate key exists and is accessible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use AWS SDK v1 for simpler credential handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Encrypt encrypts data using AWS KMS key</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">aws </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AWSKMSProvider</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Encrypt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">plaintext</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">keyID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create KMS encrypt request with data and key ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call KMS encrypt API with context for cancellation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle AWS-specific errors (throttling, auth, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return ciphertext blob from KMS response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: AWS returns base64-encoded ciphertext that includes metadata</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Decrypt decrypts data using AWS KMS  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">aws </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AWSKMSProvider</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Decrypt</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ciphertext</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">keyID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create KMS decrypt request with ciphertext blob</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call KMS decrypt API (key ID embedded in ciphertext)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Implement exponential backoff for retriable errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return plaintext from successful decrypt response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: KMS ciphertext includes key ID, so explicit keyID parameter not needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AttemptAutoUnseal tries to unseal using KMS-encrypted master key</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">am </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AutoUnsealManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AttemptAutoUnseal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load encrypted master key from local storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call KMS provider decrypt with retry logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate decrypted key format and test against known DEK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Initialize encryption engines with recovered master key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Clear plaintext key from local variables after use</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Implement circuit breaker pattern for repeated KMS failures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint for Unsealing and High Availability:</strong></p>\n<p>After implementing this milestone, your system should demonstrate the following capabilities:</p>\n<ol>\n<li><strong>Shamir Share Generation</strong>: Run <code>./vault-server generate-shares -threshold=3 -total=5</code> to create master key shares</li>\n<li><strong>Manual Unsealing</strong>: Start server in sealed mode, submit shares via API until threshold reached and system unseals</li>\n<li><strong>Cluster Formation</strong>: Start multiple nodes that discover each other and elect a leader for write operations</li>\n<li><strong>Auto-Unseal</strong>: Configure AWS KMS integration and verify automatic unsealing after restart</li>\n<li><strong>Failure Recovery</strong>: Stop leader node and verify follower promotion maintains service availability</li>\n</ol>\n<p><strong>Expected test outcomes:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test Shamir correctness</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/unseal</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestShamirReconstruction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should pass with various threshold combinations</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test seal/unseal state machine  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/unseal</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestSealUnsealCycle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should handle concurrent operations correctly</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test cluster consensus</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/cluster</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestLeaderElection</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should elect leader and replicate operations</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test auto-unseal integration</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/kms</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestAutoUnseal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should unseal using mocked KMS responses</span></span></code></pre></div>\n\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Shares don&#39;t reconstruct original key</td>\n<td>Polynomial degree mismatch or field arithmetic error</td>\n<td>Check that polynomial degree = threshold-1, verify field operations</td>\n<td>Use consistent prime field, validate coefficient generation</td>\n</tr>\n<tr>\n<td>System hangs during unseal</td>\n<td>Deadlock in seal mutex or blocking KMS call</td>\n<td>Check goroutine stacks, verify lock ordering</td>\n<td>Use context timeouts, avoid nested locking</td>\n</tr>\n<tr>\n<td>Cluster nodes can&#39;t find each other</td>\n<td>Network configuration or Raft transport issues</td>\n<td>Check bind addresses, firewall rules, DNS resolution</td>\n<td>Verify peer addresses match actual network interfaces</td>\n</tr>\n<tr>\n<td>Frequent leadership changes</td>\n<td>Network instability or timing parameter issues</td>\n<td>Monitor Raft logs for election triggers, check network latency</td>\n<td>Increase election timeout, improve network stability</td>\n</tr>\n<tr>\n<td>Auto-unseal fails intermittently</td>\n<td>KMS service throttling or credential expiration</td>\n<td>Check AWS CloudTrail logs, monitor KMS API responses</td>\n<td>Implement exponential backoff, refresh credentials</td>\n</tr>\n</tbody></table>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section spans all four milestones, demonstrating how the components developed in each milestone interact to process requests. It shows authentication and authorization flows (Milestone 2), secret encryption/decryption operations (Milestone 1), dynamic secret generation (Milestone 3), and how the system operates in sealed/unsealed states (Milestone 4).</p>\n</blockquote>\n<p>Think of the secret management system as a sophisticated corporate bank with multiple security checkpoints, automated vaults, and background maintenance systems. When a client makes a withdrawal request (secret retrieval), their identity gets verified at the front desk (authentication), their access permissions get checked against the account rules (authorization), the secure vault gets unlocked with the right keys (encryption), and background systems handle account maintenance like expiring temporary accounts (lease management). This section maps out all these interaction flows and background processes.</p>\n<p>The secret management system operates through three primary interaction patterns: synchronous request/response flows that handle client operations, asynchronous background processes that maintain system health, and internal component communication that coordinates distributed operations. Each pattern has distinct characteristics, error handling requirements, and performance considerations that shape the overall system behavior.</p>\n<h3 id=\"rest-api-design\">REST API Design</h3>\n<p>The REST API serves as the primary interface between clients and the secret management system, following a path-based URL structure that mirrors the internal policy hierarchy. The API design philosophy emphasizes consistency, security, and discoverability while maintaining compatibility with HashiCorp Vault&#39;s client ecosystem.</p>\n<h4 id=\"api-endpoint-structure\">API Endpoint Structure</h4>\n<p>The API follows a hierarchical path structure where each segment represents a different system concern. Think of the URL structure like a filing system in a corporate office - the first folder indicates the department (auth, secret, sys), the second folder indicates the specific service or mount point, and subsequent folders represent the actual resources being accessed. This hierarchy enables both human operators and automated tools to understand access patterns and implement appropriate security policies.</p>\n<table>\n<thead>\n<tr>\n<th>Endpoint Category</th>\n<th>Path Pattern</th>\n<th>Purpose</th>\n<th>Authentication Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Authentication</td>\n<td><code>/v1/auth/{method}/{operation}</code></td>\n<td>Login and token operations</td>\n<td>Partial (method-specific)</td>\n</tr>\n<tr>\n<td>Secret Operations</td>\n<td><code>/v1/secret/{path}</code></td>\n<td>Static secret CRUD operations</td>\n<td>Yes (bearer token)</td>\n</tr>\n<tr>\n<td>Dynamic Secrets</td>\n<td><code>/v1/{backend}/{operation}</code></td>\n<td>Dynamic credential generation</td>\n<td>Yes (bearer token)</td>\n</tr>\n<tr>\n<td>System Operations</td>\n<td><code>/v1/sys/{operation}</code></td>\n<td>Administrative and status operations</td>\n<td>Yes (elevated privileges)</td>\n</tr>\n<tr>\n<td>Health/Status</td>\n<td><code>/v1/sys/health</code></td>\n<td>System status and readiness checks</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p>The authentication endpoints handle the initial identity verification process, accepting different credential types based on the configured authentication methods. Secret operation endpoints manage static secrets with full CRUD capabilities, supporting both key-value operations and metadata management. Dynamic secret endpoints are mounted at configurable paths and provide credential generation specific to each backend type. System operation endpoints handle administrative tasks like policy management, unsealing, and configuration.</p>\n<h4 id=\"request-and-response-format-standards\">Request and Response Format Standards</h4>\n<p>All API interactions use JSON for request and response bodies, with consistent error handling and metadata structure across all endpoints. The response format follows a standardized envelope that provides both the requested data and contextual information needed for client decision-making.</p>\n<p><strong>Standard Response Envelope:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>request_id</code></td>\n<td>string</td>\n<td>Unique identifier for request tracking and audit correlation</td>\n</tr>\n<tr>\n<td><code>lease_id</code></td>\n<td>string</td>\n<td>Lease identifier for renewable/revocable responses (dynamic secrets)</td>\n</tr>\n<tr>\n<td><code>renewable</code></td>\n<td>boolean</td>\n<td>Whether this response can be renewed before expiration</td>\n</tr>\n<tr>\n<td><code>lease_duration</code></td>\n<td>integer</td>\n<td>Seconds until this response expires (0 for non-expiring)</td>\n</tr>\n<tr>\n<td><code>data</code></td>\n<td>object</td>\n<td>The actual response payload specific to the operation</td>\n</tr>\n<tr>\n<td><code>warnings</code></td>\n<td>array</td>\n<td>Non-fatal issues that clients should be aware of</td>\n</tr>\n<tr>\n<td><code>auth</code></td>\n<td>object</td>\n<td>Authentication information for login responses</td>\n</tr>\n<tr>\n<td><code>wrap_info</code></td>\n<td>object</td>\n<td>Response wrapping metadata for secure token delivery</td>\n</tr>\n</tbody></table>\n<p><strong>Error Response Format:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>errors</code></td>\n<td>array</td>\n<td>Human-readable error messages for debugging</td>\n</tr>\n<tr>\n<td><code>error_type</code></td>\n<td>string</td>\n<td>Machine-readable error category for client handling</td>\n</tr>\n<tr>\n<td><code>request_id</code></td>\n<td>string</td>\n<td>Request identifier for correlation with audit logs</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight</strong>: The response envelope pattern provides clients with all necessary information to handle credential lifecycle management without requiring additional API calls. The lease metadata enables clients to proactively renew credentials before expiration, while the request ID enables correlation between client operations and server audit logs for security investigations.</p>\n</blockquote>\n<h4 id=\"authentication-header-requirements\">Authentication Header Requirements</h4>\n<p>The API uses bearer token authentication carried in HTTP headers, following OAuth 2.0 conventions while supporting Vault-specific token features. Think of the authentication header like an electronic keycard that employees use to access different areas of a corporate building - the card identifies the person and contains access permissions that are checked at each secured door.</p>\n<table>\n<thead>\n<tr>\n<th>Header Name</th>\n<th>Format</th>\n<th>Purpose</th>\n<th>Required When</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>X-Vault-Token</code></td>\n<td>Bearer token string</td>\n<td>Primary authentication credential</td>\n<td>All authenticated requests</td>\n</tr>\n<tr>\n<td><code>X-Vault-Namespace</code></td>\n<td>Namespace path</td>\n<td>Multi-tenancy isolation (future extension)</td>\n<td>Multi-tenant deployments</td>\n</tr>\n<tr>\n<td><code>X-Vault-Request-ID</code></td>\n<td>UUID string</td>\n<td>Client-provided request correlation</td>\n<td>Optional (server generates if missing)</td>\n</tr>\n<tr>\n<td><code>X-Vault-Wrap-TTL</code></td>\n<td>Duration string</td>\n<td>Response wrapping TTL request</td>\n<td>When requesting wrapped responses</td>\n</tr>\n</tbody></table>\n<p><strong>Token Types and Behavior:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Token Type</th>\n<th>Characteristics</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Service</td>\n<td>Long-lived, renewable, bound to policies</td>\n<td>Application authentication</td>\n</tr>\n<tr>\n<td>Batch</td>\n<td>Short-lived, encrypted, lightweight</td>\n<td>High-throughput scenarios</td>\n</tr>\n<tr>\n<td>Orphan</td>\n<td>No parent relationship, manual lifecycle</td>\n<td>Root access and emergency recovery</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Bearer Token Authentication</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to balance security with client implementation simplicity across diverse application environments</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>HTTP Basic Auth with username/password</li>\n<li>JWT tokens with embedded claims</li>\n<li>Bearer tokens with server-side validation</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Bearer tokens with server-side state and validation</li>\n<li><strong>Rationale</strong>: Provides immediate revocation capability, supports fine-grained policy evaluation, and enables audit logging with full context</li>\n<li><strong>Consequences</strong>: Requires server-side token storage and validation, but enables precise access control and immediate security response</li>\n</ul>\n</blockquote>\n<h3 id=\"request-processing-pipeline\">Request Processing Pipeline</h3>\n<p>The request processing pipeline transforms incoming HTTP requests through multiple security and business logic stages before generating responses. Think of this pipeline like airport security screening - each checkpoint validates different aspects of the passenger (request) and their credentials, with the ability to reject the request at any stage if security requirements aren&#39;t met.</p>\n<p>The pipeline operates as a series of filters, where each stage can either pass the request to the next stage, return an error response, or modify the request context for downstream processing. This design enables consistent security policy enforcement while maintaining performance through early rejection of invalid requests.</p>\n<h4 id=\"stage-1-request-parsing-and-validation\">Stage 1: Request Parsing and Validation</h4>\n<p>The initial stage handles HTTP-level parsing and basic request validation before any security processing begins. This stage protects the system from malformed requests and provides early feedback for client debugging.</p>\n<p><strong>Request Parsing Process:</strong></p>\n<ol>\n<li><p><strong>HTTP Method and Path Extraction</strong>: The server extracts the HTTP method and URL path, validating that the method is supported for the requested endpoint. Unsupported methods return HTTP 405 Method Not Allowed with an Allow header indicating supported methods.</p>\n</li>\n<li><p><strong>Header Validation</strong>: All required headers are validated for presence and format correctness. The <code>Content-Type</code> header must be <code>application/json</code> for request bodies, and the <code>Accept</code> header should include <code>application/json</code> for response formatting.</p>\n</li>\n<li><p><strong>Body Size and Format Validation</strong>: Request bodies are limited to prevent memory exhaustion attacks. JSON parsing occurs with strict validation - malformed JSON immediately returns HTTP 400 Bad Request with parsing error details.</p>\n</li>\n<li><p><strong>Path Parameter Extraction</strong>: URL path segments are parsed and validated according to the endpoint&#39;s parameter requirements. Special characters are URL-decoded and validated against allowed character sets to prevent injection attacks.</p>\n</li>\n<li><p><strong>Query Parameter Processing</strong>: Query parameters are parsed and validated according to endpoint specifications. Parameters like <code>version</code> for secret operations and <code>ttl</code> for dynamic secrets undergo type and range validation.</p>\n</li>\n</ol>\n<p><strong>Request Validation Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Validation Type</th>\n<th>Check Performed</th>\n<th>Error Response</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Content-Type</td>\n<td>Must be application/json for POST/PUT</td>\n<td>415 Unsupported Media Type</td>\n<td>Client must set correct header</td>\n</tr>\n<tr>\n<td>Body Size</td>\n<td>Must be under 1MB limit</td>\n<td>413 Payload Too Large</td>\n<td>Client must reduce request size</td>\n</tr>\n<tr>\n<td>JSON Syntax</td>\n<td>Must parse as valid JSON</td>\n<td>400 Bad Request with parse error</td>\n<td>Client must fix JSON formatting</td>\n</tr>\n<tr>\n<td>Required Fields</td>\n<td>Must contain all mandatory fields</td>\n<td>400 Bad Request with missing fields</td>\n<td>Client must include required data</td>\n</tr>\n<tr>\n<td>Field Types</td>\n<td>Must match expected data types</td>\n<td>400 Bad Request with type errors</td>\n<td>Client must correct data types</td>\n</tr>\n</tbody></table>\n<h4 id=\"stage-2-authentication-and-identity-resolution\">Stage 2: Authentication and Identity Resolution</h4>\n<p>The authentication stage verifies client identity and resolves the authenticated entity to internal identity structures. This stage implements the bearer token authentication model while supporting extensibility for additional authentication methods.</p>\n<p><strong>Authentication Process Flow:</strong></p>\n<ol>\n<li><p><strong>Token Extraction</strong>: The <code>X-Vault-Token</code> header is extracted and validated for proper format. Missing tokens result in HTTP 401 Unauthorized for protected endpoints, while malformed tokens return HTTP 400 Bad Request with format guidance.</p>\n</li>\n<li><p><strong>Token Lookup and Validation</strong>: The token is looked up in the token store using constant-time comparison to prevent timing attacks. Invalid or expired tokens immediately return HTTP 403 Forbidden with appropriate error details.</p>\n</li>\n<li><p><strong>Token Metadata Resolution</strong>: Valid tokens have their associated metadata loaded, including policies, TTL information, usage constraints, and parent token relationships. This metadata drives subsequent authorization decisions.</p>\n</li>\n<li><p><strong>Identity Construction</strong>: An <code>Identity</code> object is constructed containing all relevant information about the authenticated entity, including resolved policies from direct assignment and group membership.</p>\n</li>\n<li><p><strong>Usage Tracking and Limits</strong>: Token usage is recorded for audit purposes and usage limits are enforced. Tokens that exceed their maximum usage count are immediately revoked.</p>\n</li>\n</ol>\n<p><strong>Authentication Methods Comparison:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Token Format</th>\n<th>Validation Approach</th>\n<th>Performance</th>\n<th>Security Level</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Token</td>\n<td>Random string</td>\n<td>Server-side lookup</td>\n<td>Fast (memory/cache)</td>\n<td>High (immediate revocation)</td>\n</tr>\n<tr>\n<td>JWT</td>\n<td>Signed JSON</td>\n<td>Cryptographic validation</td>\n<td>Faster (no lookup)</td>\n<td>Medium (revocation lag)</td>\n</tr>\n<tr>\n<td>mTLS</td>\n<td>X.509 Certificate</td>\n<td>Certificate chain validation</td>\n<td>Moderate</td>\n<td>Very High (crypto proof)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Server-Side Token Validation</strong></p>\n<ul>\n<li><strong>Context</strong>: Need immediate token revocation capability for security incidents while maintaining high request throughput</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>JWT tokens with embedded claims and expiration</li>\n<li>Server-side token store with fast lookup</li>\n<li>Hybrid approach with cached validation</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Server-side token store with memory caching</li>\n<li><strong>Rationale</strong>: Enables immediate revocation for security response, supports complex usage tracking, and provides full audit context</li>\n<li><strong>Consequences</strong>: Requires server-side state management but provides superior security control and immediate policy updates</li>\n</ul>\n</blockquote>\n<h4 id=\"stage-3-authorization-and-policy-evaluation\">Stage 3: Authorization and Policy Evaluation</h4>\n<p>The authorization stage determines whether the authenticated identity has permission to perform the requested operation on the specified resource path. This implements the path-based access control system with wildcard matching and parameter validation.</p>\n<p><strong>Policy Evaluation Algorithm:</strong></p>\n<ol>\n<li><p><strong>Path Normalization</strong>: The requested path is normalized by removing trailing slashes, resolving relative references, and converting to canonical form. This prevents authorization bypass through path manipulation.</p>\n</li>\n<li><p><strong>Policy Collection</strong>: All policies associated with the authenticated identity are collected, including directly assigned policies and policies inherited through group membership. Policy collection follows a breadth-first pattern to ensure complete coverage.</p>\n</li>\n<li><p><strong>Rule Matching</strong>: Each policy rule is evaluated against the normalized request path using wildcard matching. Rules are processed in order of specificity, with more specific patterns taking precedence over general patterns.</p>\n</li>\n<li><p><strong>Capability Verification</strong>: The requested operation is checked against the capabilities granted by matching policy rules. Operations must be explicitly allowed - the system implements default deny with explicit allow semantics.</p>\n</li>\n<li><p><strong>Parameter Validation</strong>: Request parameters are validated against policy constraints including allowed values, required parameters, and denied parameters. This provides fine-grained control over operation characteristics.</p>\n</li>\n<li><p><strong>TTL and Constraint Application</strong>: Maximum TTL limits and other constraints from matching policies are applied to the request context. These constraints are enforced during secret operations and lease generation.</p>\n</li>\n</ol>\n<p><strong>Policy Rule Evaluation Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Rule Type</th>\n<th>Pattern Example</th>\n<th>Matches</th>\n<th>Grants</th>\n<th>Constraints Applied</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Exact Path</td>\n<td><code>secret/myapp/db</code></td>\n<td>Exact path only</td>\n<td>Specified capabilities</td>\n<td>All policy constraints</td>\n</tr>\n<tr>\n<td>Single Wildcard</td>\n<td><code>secret/myapp/*</code></td>\n<td>Direct children only</td>\n<td>Specified capabilities</td>\n<td>All policy constraints</td>\n</tr>\n<tr>\n<td>Recursive Wildcard</td>\n<td><code>secret/myapp/**</code></td>\n<td>All descendants</td>\n<td>Specified capabilities</td>\n<td>All policy constraints</td>\n</tr>\n<tr>\n<td>Parameter Filter</td>\n<td><code>secret/+/config</code></td>\n<td>Paths with parameters</td>\n<td>Conditional on parameters</td>\n<td>Parameter-specific limits</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Security Insight</strong>: The policy evaluation must be performed on every request, even for cached or frequently accessed secrets. Authorization state can change independently of authentication state through policy updates, token revocation, or identity modifications. Caching authorization decisions creates security vulnerabilities where access continues after permissions are revoked.</p>\n</blockquote>\n<h4 id=\"stage-4-secret-operations-and-business-logic\">Stage 4: Secret Operations and Business Logic</h4>\n<p>The final stage implements the actual business logic for secret operations, including encryption, decryption, lease management, and audit logging. This stage coordinates between multiple system components to fulfill the client request while maintaining security and consistency guarantees.</p>\n<p><strong>Secret Retrieval Process:</strong></p>\n<ol>\n<li><p><strong>Path Resolution</strong>: The secret path is resolved to determine the storage backend and any path transformations required. Mount point processing handles backend-specific path mapping and parameter extraction.</p>\n</li>\n<li><p><strong>Encryption Context Preparation</strong>: For encrypted secrets, the encryption context is prepared including the data encryption key version, authentication data, and any path-specific encryption parameters.</p>\n</li>\n<li><p><strong>Storage Operation</strong>: The appropriate storage backend is invoked to retrieve the encrypted secret data. Storage errors are classified as temporary (retry) or permanent (fail immediately) based on error type.</p>\n</li>\n<li><p><strong>Decryption and Data Processing</strong>: Retrieved secrets undergo decryption using the envelope encryption system. Version resolution ensures the correct data encryption key is used for each secret version.</p>\n</li>\n<li><p><strong>Response Preparation</strong>: The decrypted secret data is formatted into the standard response envelope with appropriate metadata including version information, lease details, and renewal capabilities.</p>\n</li>\n<li><p><strong>Audit Event Generation</strong>: Comprehensive audit events are generated capturing the complete request context, operation outcome, and any security-relevant details for compliance and security monitoring.</p>\n</li>\n</ol>\n<p><strong>Dynamic Secret Generation Process:</strong></p>\n<ol>\n<li><p><strong>Backend Resolution</strong>: The dynamic secret request is routed to the appropriate secret backend based on the mount point. Backend-specific role and configuration validation occurs at this stage.</p>\n</li>\n<li><p><strong>Credential Generation</strong>: The secret backend generates new credentials according to the role configuration. This may involve database user creation, cloud IAM role assumption, or certificate generation.</p>\n</li>\n<li><p><strong>Lease Creation and Tracking</strong>: A lease is created to track the generated credentials including expiration time, renewal capabilities, and revocation data needed for cleanup.</p>\n</li>\n<li><p><strong>Credential Delivery</strong>: Generated credentials are packaged into the response with lease metadata. Sensitive credential data is never logged or stored in plaintext.</p>\n</li>\n<li><p><strong>Background Lease Registration</strong>: The lease is registered with the lease management system for tracking expiration and enabling background revocation processing.</p>\n</li>\n</ol>\n<h3 id=\"background-processes\">Background Processes</h3>\n<p>The secret management system operates several critical background processes that maintain security, performance, and operational health independently of client request processing. Think of these background processes like the maintenance staff in a corporate building - they work behind the scenes to ensure security systems function properly, expired access badges are deactivated, and facility operations continue smoothly without disrupting daily business operations.</p>\n<p>These processes implement the &quot;defense in depth&quot; principle by providing multiple independent layers of security enforcement and system maintenance. Each process operates on its own schedule with appropriate error handling and retry logic to ensure system reliability even during partial failures.</p>\n<h4 id=\"lease-management-and-revocation-engine\">Lease Management and Revocation Engine</h4>\n<p>The lease management system tracks all dynamic secrets throughout their lifecycle and ensures proper cleanup when credentials expire or are explicitly revoked. This system prevents credential accumulation that could create security vulnerabilities or resource exhaustion in target systems.</p>\n<p><strong>Lease Tracking Data Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Purpose</th>\n<th>Update Frequency</th>\n<th>Persistence Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lease Index by Expiration</td>\n<td>Fast lookup of expired leases</td>\n<td>Real-time on creation/renewal</td>\n<td>Memory with periodic snapshots</td>\n</tr>\n<tr>\n<td>Lease Index by Token</td>\n<td>Token revocation support</td>\n<td>Real-time on creation</td>\n<td>Memory with write-through</td>\n</tr>\n<tr>\n<td>Lease Index by Backend</td>\n<td>Backend-specific operations</td>\n<td>Real-time on creation</td>\n<td>Memory with write-through</td>\n</tr>\n<tr>\n<td>Revocation Queue</td>\n<td>Retry failed revocations</td>\n<td>As needed for failures</td>\n<td>Persistent storage required</td>\n</tr>\n</tbody></table>\n<p><strong>Lease Reaper Process:</strong></p>\n<p>The lease reaper operates as a continuous background process that identifies expired leases and initiates their revocation. Think of the lease reaper like a security guard who regularly patrols the building to check for expired access badges and deactivate them to prevent unauthorized access.</p>\n<ol>\n<li><p><strong>Expiration Scanning</strong>: Every 30 seconds, the reaper queries the lease index for leases that have expired within the last scan interval. The query includes a small buffer (5 seconds) to account for clock skew and processing delays.</p>\n</li>\n<li><p><strong>Batch Processing</strong>: Expired leases are processed in batches to optimize backend operations and reduce system load. Batch size is configurable but defaults to 100 leases to balance throughput and memory usage.</p>\n</li>\n<li><p><strong>Revocation Queuing</strong>: Each expired lease is queued for revocation with appropriate priority based on the credential type and security sensitivity. High-priority credentials (root database users, admin cloud roles) are processed immediately.</p>\n</li>\n<li><p><strong>Progress Tracking</strong>: The reaper maintains state about its last successful scan to ensure no leases are missed during system restarts or failures. This state is persisted to storage and recovered on startup.</p>\n</li>\n<li><p><strong>Error Handling</strong>: Failed revocation attempts are logged and retried according to exponential backoff policies. Persistent failures are escalated to dead letter queues for manual investigation.</p>\n</li>\n</ol>\n<p><strong>Revocation Worker Process:</strong></p>\n<p>Multiple revocation workers operate concurrently to process the revocation queue and perform actual credential cleanup in target systems. The number of workers is configurable based on expected load and backend capacity.</p>\n<ol>\n<li><p><strong>Queue Processing</strong>: Workers continuously poll the revocation queue for pending items, using priority ordering to ensure high-priority revocations are processed first. Queue polling includes exponential backoff to reduce system load during idle periods.</p>\n</li>\n<li><p><strong>Backend Invocation</strong>: For each revocation item, the appropriate secret backend is invoked with the stored revocation data. Backends implement credential-specific cleanup logic such as database user deletion or cloud IAM role revocation.</p>\n</li>\n<li><p><strong>Retry Logic with Circuit Breaker</strong>: Failed revocation attempts are retried according to configurable policies with exponential backoff. Circuit breaker patterns prevent cascade failures when backends are experiencing issues.</p>\n</li>\n<li><p><strong>Success Confirmation</strong>: Successfully revoked credentials are removed from all tracking indexes and their lease records are marked as revoked for audit purposes. Success confirmation may include verification queries to ensure cleanup completion.</p>\n</li>\n<li><p><strong>Failure Escalation</strong>: Revocation attempts that exceed maximum retry counts are moved to dead letter queues with detailed error information for operator investigation. These failures generate alert notifications for immediate attention.</p>\n</li>\n</ol>\n<p><strong>Revocation Retry Configuration:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Attempt</th>\n<th>Delay</th>\n<th>Total Time</th>\n<th>Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Immediate</td>\n<td>0s</td>\n<td>Direct revocation attempt</td>\n</tr>\n<tr>\n<td>2</td>\n<td>30 seconds</td>\n<td>30s</td>\n<td>First retry with backend health check</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2 minutes</td>\n<td>2m 30s</td>\n<td>Second retry with extended timeout</td>\n</tr>\n<tr>\n<td>4</td>\n<td>8 minutes</td>\n<td>10m 30s</td>\n<td>Third retry with debug logging</td>\n</tr>\n<tr>\n<td>5</td>\n<td>32 minutes</td>\n<td>42m 30s</td>\n<td>Final retry with operator notification</td>\n</tr>\n<tr>\n<td>Failed</td>\n<td>Dead letter</td>\n<td>N/A</td>\n<td>Manual intervention required</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Separate Lease Reaper and Revocation Workers</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to balance timely credential revocation with system stability under varying load conditions</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Single-threaded process handling both detection and revocation</li>\n<li>Multi-threaded process with shared queue</li>\n<li>Separate processes with persistent queue</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Separate processes communicating through persistent queue</li>\n<li><strong>Rationale</strong>: Enables independent scaling, fault isolation, and priority handling while maintaining processing guarantees</li>\n<li><strong>Consequences</strong>: Requires additional coordination and queue management but provides superior reliability and performance characteristics</li>\n</ul>\n</blockquote>\n<h4 id=\"token-maintenance-and-cleanup\">Token Maintenance and Cleanup</h4>\n<p>The token maintenance system handles token lifecycle management including expiration, usage limit enforcement, and orphaned token cleanup. This system prevents token accumulation and enforces security policies related to token usage patterns.</p>\n<p><strong>Token Expiration Processing:</strong></p>\n<ol>\n<li><p><strong>Expiration Detection</strong>: A background process scans the token store every minute to identify tokens that have exceeded their TTL. The scan uses indexed queries to minimize performance impact on active token operations.</p>\n</li>\n<li><p><strong>Grace Period Handling</strong>: Expired tokens enter a short grace period (30 seconds) during which they are marked as expired but not immediately deleted. This prevents race conditions where in-flight requests fail due to token expiration timing.</p>\n</li>\n<li><p><strong>Revocation Cascade</strong>: When parent tokens are revoked, all child tokens are automatically revoked in a cascading pattern. The revocation process maintains referential integrity and prevents orphaned authentication state.</p>\n</li>\n<li><p><strong>Audit Event Generation</strong>: Token revocation events are logged with comprehensive context including revocation reason, token metadata, and any associated leases that require cleanup.</p>\n</li>\n</ol>\n<p><strong>Token Usage Limit Enforcement:</strong></p>\n<ol>\n<li><p><strong>Usage Tracking</strong>: Every token authentication increments the token&#39;s usage counter in a thread-safe manner. Usage tracking includes protection against race conditions that could allow usage limit bypasses.</p>\n</li>\n<li><p><strong>Limit Validation</strong>: Before authentication succeeds, the token&#39;s usage count is compared against its maximum usage limit. Tokens that would exceed their limit are immediately revoked and the authentication fails.</p>\n</li>\n<li><p><strong>Usage Pattern Analysis</strong>: Token usage patterns are analyzed to detect anomalous behavior such as rapid usage spikes that might indicate credential compromise or client implementation errors.</p>\n</li>\n</ol>\n<p><strong>Orphaned Token Cleanup:</strong></p>\n<ol>\n<li><p><strong>Parent Relationship Validation</strong>: Tokens with parent relationships are validated to ensure their parent tokens still exist and are valid. Orphaned tokens from deleted parents are queued for cleanup.</p>\n</li>\n<li><p><strong>Policy Reference Validation</strong>: Tokens referencing policies that no longer exist are identified and either updated with replacement policies or revoked if no suitable replacement exists.</p>\n</li>\n<li><p><strong>Identity Reference Validation</strong>: Tokens associated with deleted or disabled identities are automatically revoked to prevent access after identity removal.</p>\n</li>\n</ol>\n<h4 id=\"encryption-key-rotation-and-migration\">Encryption Key Rotation and Migration</h4>\n<p>The encryption key management system handles periodic rotation of data encryption keys and migration of secrets to new key versions. This process maintains security by limiting the exposure time of any single encryption key while ensuring seamless access to historical secret versions.</p>\n<p><strong>Automatic Key Rotation Process:</strong></p>\n<ol>\n<li><p><strong>Rotation Schedule Evaluation</strong>: The key rotation scheduler evaluates configured rotation policies including maximum key age, maximum usage count, and external rotation triggers. Rotation policies can be configured per mount point or globally.</p>\n</li>\n<li><p><strong>New Key Generation</strong>: When rotation is triggered, a new data encryption key is generated using cryptographically secure random number generation. The new key is encrypted with the current master key and stored in the key store.</p>\n</li>\n<li><p><strong>Key Version Management</strong>: The new key is assigned the next sequential version number and marked as the active key for new encryptions. Previous key versions remain available for decryption but are no longer used for new operations.</p>\n</li>\n<li><p><strong>Migration Planning</strong>: The rotation process identifies existing secrets encrypted with old key versions and creates a migration plan. Migration is prioritized based on secret access frequency and age of the encryption key.</p>\n</li>\n</ol>\n<p><strong>Background Secret Re-encryption:</strong></p>\n<ol>\n<li><p><strong>Migration Queue Processing</strong>: A background process continuously works through the migration queue, re-encrypting secrets with the current data encryption key version. Processing rate is throttled to avoid impacting operational performance.</p>\n</li>\n<li><p><strong>Version Preservation</strong>: During re-encryption, all secret versions are preserved with their original metadata. Only the encryption key version and encrypted data are updated while maintaining version history.</p>\n</li>\n<li><p><strong>Atomic Updates</strong>: Secret re-encryption is performed atomically to prevent data corruption. The original secret version is preserved until the new version is successfully written and verified.</p>\n</li>\n<li><p><strong>Progress Tracking</strong>: Migration progress is tracked per mount point and globally to provide operational visibility into key rotation status. Progress information is exposed through monitoring APIs.</p>\n</li>\n<li><p><strong>Verification and Rollback</strong>: Re-encrypted secrets undergo verification by attempting decryption with the new key version. Failed verifications trigger automatic rollback to the previous version and error reporting.</p>\n</li>\n</ol>\n<p><strong>Key Retirement and Cleanup:</strong></p>\n<ol>\n<li><p><strong>Usage Monitoring</strong>: Old key versions are monitored for usage patterns. Keys that are no longer actively used for decryption operations become candidates for retirement.</p>\n</li>\n<li><p><strong>Retirement Timeline</strong>: Keys follow a configured retirement timeline where they progress from active to deprecated to retired status. Each status change has configurable time delays to ensure operational safety.</p>\n</li>\n<li><p><strong>Final Cleanup</strong>: Retired keys that are no longer referenced by any secrets are securely deleted from the key store. Key deletion includes secure memory wiping and audit event generation.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Security Principle</strong>: Key rotation operates on the principle of &quot;blast radius containment&quot; - limiting the amount of data encrypted with any single key version reduces the impact of potential key compromise while maintaining backward compatibility for legitimate access.</p>\n</blockquote>\n<h4 id=\"health-monitoring-and-alerting\">Health Monitoring and Alerting</h4>\n<p>The health monitoring system continuously evaluates system components and operational metrics to detect degraded performance, security issues, or impending failures. This system provides early warning of problems and enables proactive operational response.</p>\n<p><strong>Component Health Checks:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Health Metrics</th>\n<th>Check Frequency</th>\n<th>Alert Thresholds</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Storage Backend</td>\n<td>Response time, error rate, connection count</td>\n<td>30 seconds</td>\n<td>&gt;500ms response, &gt;5% errors</td>\n</tr>\n<tr>\n<td>Encryption Engine</td>\n<td>Key availability, encryption/decryption performance</td>\n<td>60 seconds</td>\n<td>Key lookup failures, &gt;100ms operations</td>\n</tr>\n<tr>\n<td>Authentication Engine</td>\n<td>Token validation performance, policy evaluation time</td>\n<td>30 seconds</td>\n<td>&gt;50ms validation, &gt;10% failures</td>\n</tr>\n<tr>\n<td>Dynamic Secret Backends</td>\n<td>Credential generation success rate, cleanup success</td>\n<td>2 minutes</td>\n<td>&gt;10% generation failures, &gt;5% cleanup failures</td>\n</tr>\n<tr>\n<td>Lease Management</td>\n<td>Revocation queue depth, processing rate</td>\n<td>60 seconds</td>\n<td>&gt;1000 queued items, &lt;90% success rate</td>\n</tr>\n</tbody></table>\n<p><strong>Operational Metrics Collection:</strong></p>\n<ol>\n<li><p><strong>Request Processing Metrics</strong>: Comprehensive timing and success rate metrics for all API endpoints, categorized by operation type, authentication method, and client identity. Metrics include percentile distributions for performance analysis.</p>\n</li>\n<li><p><strong>Security Event Metrics</strong>: Aggregated counts of authentication failures, authorization denials, and other security-relevant events. These metrics enable detection of potential attacks or misconfigurations.</p>\n</li>\n<li><p><strong>Resource Usage Metrics</strong>: Memory usage, storage consumption, network utilization, and other resource metrics that indicate system capacity and potential scaling needs.</p>\n</li>\n<li><p><strong>Background Process Metrics</strong>: Performance and health metrics for all background processes including lease reapers, token cleanup, and key rotation processes.</p>\n</li>\n</ol>\n<p><strong>Alert Generation and Escalation:</strong></p>\n<ol>\n<li><p><strong>Threshold-Based Alerts</strong>: Automated alerts are generated when metrics exceed configured thresholds. Alert severity is determined by the magnitude of threshold exceedance and the criticality of the affected component.</p>\n</li>\n<li><p><strong>Trend-Based Alerts</strong>: Statistical analysis of metric trends identifies gradual degradation that might not trigger threshold alerts but indicates developing issues requiring attention.</p>\n</li>\n<li><p><strong>Correlation Analysis</strong>: Multiple related metrics are analyzed together to distinguish between transient issues and systematic problems. Correlation reduces alert noise while improving detection accuracy.</p>\n</li>\n<li><p><strong>Escalation Policies</strong>: Alerts follow configured escalation policies with increasing severity and notification scope based on alert duration and system impact.</p>\n</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The interactions and data flow components require careful attention to HTTP server implementation, middleware processing, and background task management. The following guidance provides a foundation for building these interaction patterns with appropriate error handling and performance characteristics.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP Server</td>\n<td>Go net/http with gorilla/mux</td>\n<td>Go with gin-gonic or fiber frameworks</td>\n</tr>\n<tr>\n<td>JSON Processing</td>\n<td>Go encoding/json</td>\n<td>Go with easyjson for performance</td>\n</tr>\n<tr>\n<td>Background Jobs</td>\n<td>Go goroutines with sync primitives</td>\n<td>Go with machinery or asynq job queues</td>\n</tr>\n<tr>\n<td>Metrics Collection</td>\n<td>Go expvar with custom collectors</td>\n<td>Prometheus client library</td>\n</tr>\n<tr>\n<td>Request Logging</td>\n<td>Go log/slog with structured output</td>\n<td>Structured logging with logrus or zap</td>\n</tr>\n<tr>\n<td>HTTP Middleware</td>\n<td>Custom middleware functions</td>\n<td>Go middleware libraries (negroni, alice)</td>\n</tr>\n</tbody></table>\n<h4 id=\"file-structure-organization\">File Structure Organization</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/server/\n  server.go                 ← HTTP server setup and configuration\n  middleware.go             ← Authentication, authorization, logging middleware\n  handlers.go               ← HTTP request handlers for each endpoint\n  response.go               ← Standard response formatting utilities\n  validation.go             ← Request validation helpers\n\ninternal/api/\n  auth.go                   ← Authentication endpoint handlers\n  secrets.go                ← Secret operation endpoint handlers  \n  dynamic.go                ← Dynamic secret endpoint handlers\n  system.go                 ← System administration endpoint handlers\n\ninternal/background/\n  lease_reaper.go           ← Lease expiration detection and cleanup\n  token_cleaner.go          ← Token lifecycle maintenance\n  key_rotator.go            ← Encryption key rotation management\n  health_monitor.go         ← System health checking and alerting\n\ninternal/pipeline/\n  request.go                ← Request processing pipeline stages\n  context.go                ← Request context and metadata handling\n  audit.go                  ← Audit event generation and logging</code></pre></div>\n\n<h4 id=\"core-http-server-infrastructure\">Core HTTP Server Infrastructure</h4>\n<p>This complete HTTP server foundation handles basic server setup, graceful shutdown, and middleware composition. Use this as your starting point and add endpoint-specific handlers.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> server</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">log/slog</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/gorilla/mux</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete HTTP server with middleware pipeline and graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SecretServer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config     </span><span style=\"color:#B392F0\">ServerConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    httpServer </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storage    </span><span style=\"color:#B392F0\">Backend</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    encryption </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    auth       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dynamic    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    unseal     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">UnsealManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    isSealed   </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sealMutex  </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">slog</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewSecretServer creates a fully configured HTTP server with all middleware</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewSecretServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cfg</span><span style=\"color:#B392F0\"> ServerConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretServer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">SecretServer</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config: cfg,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger: slog.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(slog.</span><span style=\"color:#B392F0\">NewJSONHandler</span><span style=\"color:#E1E4E8\">(os.Stdout, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize all engines based on configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> server.</span><span style=\"color:#B392F0\">initializeEngines</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to initialize engines: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Setup HTTP router with all endpoints and middleware</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    router </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> server.</span><span style=\"color:#B392F0\">setupRouter</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server.httpServer </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Addr:         fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\":</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, cfg.Server.Port),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Handler:      router,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ReadTimeout:  cfg.Server.ReadTimeout,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        WriteTimeout: cfg.Server.WriteTimeout,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TLSConfig:    server.</span><span style=\"color:#B392F0\">buildTLSConfig</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> server, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Start begins HTTP server operation with TLS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Starting secret management server\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"port\"</span><span style=\"color:#E1E4E8\">, s.config.Server.Port,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"tls\"</span><span style=\"color:#E1E4E8\">, s.config.Server.TLSCertPath </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start background processes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    go</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">startBackgroundProcesses</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start HTTP server with TLS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> s.config.Server.TLSCertPath </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> s.httpServer.</span><span style=\"color:#B392F0\">ListenAndServeTLS</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            s.config.Server.TLSCertPath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            s.config.Server.TLSKeyPath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> s.httpServer.</span><span style=\"color:#B392F0\">ListenAndServe</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Shutdown gracefully stops the server and background processes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Shutdown</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Shutting down secret management server\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Stop background processes first</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s.</span><span style=\"color:#B392F0\">stopBackgroundProcesses</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Gracefully shutdown HTTP server</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> s.httpServer.</span><span style=\"color:#B392F0\">Shutdown</span><span style=\"color:#E1E4E8\">(ctx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// setupRouter configures all HTTP routes and middleware pipeline</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretServer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">setupRouter</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Handler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    router </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mux.</span><span style=\"color:#B392F0\">NewRouter</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Apply middleware in correct order (outermost first)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    router.</span><span style=\"color:#B392F0\">Use</span><span style=\"color:#E1E4E8\">(s.loggingMiddleware)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    router.</span><span style=\"color:#B392F0\">Use</span><span style=\"color:#E1E4E8\">(s.corsMiddleware) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    router.</span><span style=\"color:#B392F0\">Use</span><span style=\"color:#E1E4E8\">(s.sealCheckMiddleware)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // API v1 routes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    v1 </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> router.</span><span style=\"color:#B392F0\">PathPrefix</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/v1\"</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">Subrouter</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Public endpoints (no authentication)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    v1.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/sys/health\"</span><span style=\"color:#E1E4E8\">, s.handleHealth).</span><span style=\"color:#B392F0\">Methods</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GET\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    v1.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/sys/seal-status\"</span><span style=\"color:#E1E4E8\">, s.handleSealStatus).</span><span style=\"color:#B392F0\">Methods</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GET\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Authentication endpoints (partial auth required)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    auth </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> v1.</span><span style=\"color:#B392F0\">PathPrefix</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/auth\"</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">Subrouter</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    auth.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/token/create\"</span><span style=\"color:#E1E4E8\">, s.handleCreateToken).</span><span style=\"color:#B392F0\">Methods</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"POST\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    auth.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/token/lookup-self\"</span><span style=\"color:#E1E4E8\">, s.handleTokenLookup).</span><span style=\"color:#B392F0\">Methods</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GET\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Protected endpoints (full authentication required)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    protected </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> v1.</span><span style=\"color:#B392F0\">NewRoute</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Subrouter</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    protected.</span><span style=\"color:#B392F0\">Use</span><span style=\"color:#E1E4E8\">(s.authenticationMiddleware)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    protected.</span><span style=\"color:#B392F0\">Use</span><span style=\"color:#E1E4E8\">(s.authorizationMiddleware)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Secret operations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    protected.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/secret/{path:.*}\"</span><span style=\"color:#E1E4E8\">, s.handleSecretGet).</span><span style=\"color:#B392F0\">Methods</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GET\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    protected.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/secret/{path:.*}\"</span><span style=\"color:#E1E4E8\">, s.handleSecretPut).</span><span style=\"color:#B392F0\">Methods</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"POST\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"PUT\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    protected.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/secret/{path:.*}\"</span><span style=\"color:#E1E4E8\">, s.handleSecretDelete).</span><span style=\"color:#B392F0\">Methods</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"DELETE\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Dynamic secret operations  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    protected.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/database/creds/{role}\"</span><span style=\"color:#E1E4E8\">, s.handleDynamicSecret).</span><span style=\"color:#B392F0\">Methods</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GET\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    protected.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/aws/creds/{role}\"</span><span style=\"color:#E1E4E8\">, s.handleDynamicSecret).</span><span style=\"color:#B392F0\">Methods</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GET\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // System administration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    protected.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/sys/policy/{name}\"</span><span style=\"color:#E1E4E8\">, s.handlePolicyOperations).</span><span style=\"color:#B392F0\">Methods</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GET\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"POST\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"DELETE\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> router</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"request-processing-pipeline-implementation\">Request Processing Pipeline Implementation</h4>\n<p>The request processing pipeline handles the multi-stage validation, authentication, and authorization flow. Each stage can terminate the request early or enrich the request context for subsequent stages.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> pipeline</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RequestContext carries all information through the processing pipeline</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RequestContext</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RequestID    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartTime    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Identity     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Identity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Token        </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Operation    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Path         </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Parameters   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ClientIP     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UserAgent    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Authorized   </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AuditEvents  []</span><span style=\"color:#B392F0\">AuditEvent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ProcessingStage represents a single stage in the request pipeline</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ProcessingStage</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reqCtx</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">RequestContext</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RequestProcessor coordinates the multi-stage request processing pipeline</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RequestProcessor</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stages []</span><span style=\"color:#B392F0\">ProcessingStage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    audit  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuditLogger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">slog</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewRequestProcessor creates a processor with all standard stages configured</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewRequestProcessor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">audit</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">AuditLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RequestProcessor</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    processor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">RequestProcessor</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        audit:  audit,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger: slog.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(slog.</span><span style=\"color:#B392F0\">NewJSONHandler</span><span style=\"color:#E1E4E8\">(os.Stdout, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configure standard processing stages in order</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    processor.stages </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">ProcessingStage</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        processor.parseAndValidateStage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        processor.authenticateStage, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        processor.authorizeStage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        processor.auditStage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> processor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ProcessRequest executes all pipeline stages and returns processing result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RequestProcessor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ProcessRequest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RequestContext</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    reqCtx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">RequestContext</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        RequestID: </span><span style=\"color:#B392F0\">generateRequestID</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        StartTime: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ClientIP:  </span><span style=\"color:#B392F0\">extractClientIP</span><span style=\"color:#E1E4E8\">(r),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        UserAgent: r.</span><span style=\"color:#B392F0\">UserAgent</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Execute each processing stage in sequence</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, stage </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> p.stages {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> stage</span><span style=\"color:#E1E4E8\">(ctx, reqCtx, r); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Log pipeline failure with stage information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            p.logger.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Request processing failed\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"request_id\"</span><span style=\"color:#E1E4E8\">, reqCtx.RequestID,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"stage\"</span><span style=\"color:#E1E4E8\">, i,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"error\"</span><span style=\"color:#E1E4E8\">, err,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"duration\"</span><span style=\"color:#E1E4E8\">, time.</span><span style=\"color:#B392F0\">Since</span><span style=\"color:#E1E4E8\">(reqCtx.StartTime))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Generate failure audit event</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            p.</span><span style=\"color:#B392F0\">auditFailure</span><span style=\"color:#E1E4E8\">(reqCtx, err)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> reqCtx, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> reqCtx, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// parseAndValidateStage handles HTTP parsing and basic request validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RequestProcessor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">parseAndValidateStage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reqCtx</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">RequestContext</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract HTTP method and validate against allowed methods for endpoint</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Parse URL path and extract path parameters using mux.Vars(r)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate Content-Type header for requests with body (POST/PUT)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Parse and validate JSON request body with size limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Extract query parameters and validate types/ranges</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Store parsed operation and path in RequestContext</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use r.Body with io.LimitReader to prevent memory exhaustion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// authenticateStage verifies client identity and resolves authentication</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RequestProcessor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">authenticateStage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reqCtx</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">RequestContext</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract X-Vault-Token header from request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate token format and handle missing tokens for public endpoints  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Look up token in token store using constant-time comparison</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate token expiration and usage limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Load token metadata including policies and identity information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Construct Identity object with resolved policies and groups</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update token usage count and last used timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use ValidateTokenConstantTime to prevent timing attacks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// authorizeStage evaluates policies and determines access permissions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RequestProcessor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">authorizeStage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reqCtx</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">RequestContext</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Skip authorization for public endpoints (health, seal-status)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Collect all policies associated with authenticated identity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Evaluate each policy rule against normalized request path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check requested operation against capabilities in matching rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate request parameters against policy constraints</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Apply maximum TTL and other policy constraints to request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Set Authorized flag in RequestContext based on evaluation result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use PathMatcher.Match for wildcard pattern evaluation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// auditStage generates audit events for all request processing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RequestProcessor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">auditStage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reqCtx</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">RequestContext</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create AuditEvent with comprehensive request information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Include authentication and authorization results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add timing information and request metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Determine audit event type based on operation category</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Write audit event to configured audit log</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Generate audit events even for failed requests for security monitoring</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"background-process-infrastructure\">Background Process Infrastructure</h4>\n<p>Background processes require careful lifecycle management, error handling, and coordination. This infrastructure provides the foundation for lease management, token cleanup, and health monitoring.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> background</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BackgroundManager coordinates all background processes with lifecycle management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BackgroundManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    processes []</span><span style=\"color:#B392F0\">BackgroundProcess</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stopChan  </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    wg        </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">WaitGroup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">slog</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BackgroundProcess defines the interface for all background processes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BackgroundProcess</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Name</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Start</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stopChan</span><span style=\"color:#F97583\"> &#x3C;-chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    HealthCheck</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LeaseReaper handles expired lease detection and revocation queuing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LeaseReaper</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    engine     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storage    </span><span style=\"color:#B392F0\">Backend</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    interval   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    batchSize  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastScan   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">slog</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewLeaseReaper creates a lease reaper with configured scan interval</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewLeaseReaper</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">engine</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">storage</span><span style=\"color:#B392F0\"> Backend</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LeaseReaper</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">LeaseReaper</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        engine:    engine,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        storage:   storage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        interval:  </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        batchSize: </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger:    slog.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(slog.</span><span style=\"color:#B392F0\">NewJSONHandler</span><span style=\"color:#E1E4E8\">(os.Stdout, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Start begins the lease reaper background process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">lr </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LeaseReaper</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stopChan</span><span style=\"color:#F97583\"> &#x3C;-chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ticker </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">NewTicker</span><span style=\"color:#E1E4E8\">(lr.interval)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ticker.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lr.logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Starting lease reaper\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"interval\"</span><span style=\"color:#E1E4E8\">, lr.interval)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">stopChan:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lr.logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Stopping lease reaper\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ticker.C:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> lr.</span><span style=\"color:#B392F0\">processExpiredLeases</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                lr.logger.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Lease reaper processing failed\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"error\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Continue processing - don't stop on errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// processExpiredLeases finds and queues expired leases for revocation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">lr </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LeaseReaper</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">processExpiredLeases</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Query storage for leases expired since last scan time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Process expired leases in batches to manage memory usage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each expired lease, create revocation queue entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Queue revocation requests with appropriate priority</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update last scan time to current time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Log processing statistics (leases found, queued, errors)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Include small buffer time to account for clock skew</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RevocationWorker processes the revocation queue and performs credential cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RevocationWorker</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    workerID     </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    engine       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retryConfig  </span><span style=\"color:#B392F0\">RetryConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue        </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">RevocationQueue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stopChan     </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">slog</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewRevocationWorker creates a worker that processes revocation requests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewRevocationWorker</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">workerID</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">engine</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">queue</span><span style=\"color:#F97583\"> chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">RevocationQueue</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RevocationWorker</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">RevocationWorker</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        workerID: workerID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        engine:   engine,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        retryConfig: </span><span style=\"color:#B392F0\">RetryConfig</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            InitialDelay: </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            MaxDelay:     </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Minute,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Multiplier:   </span><span style=\"color:#79B8FF\">2.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            MaxAttempts:  </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        queue:  queue,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger: slog.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(slog.</span><span style=\"color:#B392F0\">NewJSONHandler</span><span style=\"color:#E1E4E8\">(os.Stdout, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Start begins processing revocation requests from the queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rw </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RevocationWorker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stopChan</span><span style=\"color:#F97583\"> &#x3C;-chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rw.stopChan </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stopChan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rw.logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Starting revocation worker\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"worker_id\"</span><span style=\"color:#E1E4E8\">, rw.workerID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">stopChan:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            rw.logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Stopping revocation worker\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"worker_id\"</span><span style=\"color:#E1E4E8\">, rw.workerID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> revReq </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">rw.queue:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rw.</span><span style=\"color:#B392F0\">processRevocation</span><span style=\"color:#E1E4E8\">(revReq); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                rw.logger.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Revocation processing failed\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    \"worker_id\"</span><span style=\"color:#E1E4E8\">, rw.workerID,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    \"lease_id\"</span><span style=\"color:#E1E4E8\">, revReq.LeaseID,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    \"error\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// processRevocation handles a single revocation request with retry logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rw </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RevocationWorker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">processRevocation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">revReq</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">RevocationQueue</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up secret backend for the lease being revoked</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Attempt credential revocation using backend-specific logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle revocation success by removing lease from indexes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle revocation failure with exponential backoff retry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Move persistently failing revocations to dead letter queue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update revocation statistics and monitoring metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use circuit breaker pattern to prevent cascade failures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing the interactions and data flow components, verify the system behavior with these checkpoints:</p>\n<p><strong>Authentication Pipeline Verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test valid token authentication</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"X-Vault-Token: valid-token-here\"</span><span style=\"color:#9ECBFF\"> https://localhost:8443/v1/secret/test</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: HTTP 200 with secret data or HTTP 404 if secret doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Signs of problems: HTTP 401 (auth failure), HTTP 500 (server error)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test invalid token handling  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"X-Vault-Token: invalid-token\"</span><span style=\"color:#9ECBFF\"> https://localhost:8443/v1/secret/test</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: HTTP 403 Forbidden with error message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Signs of problems: HTTP 500 (auth system failure), HTTP 200 (security bypass)</span></span></code></pre></div>\n\n<p><strong>Authorization Policy Verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test path-based policy enforcement</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"X-Vault-Token: limited-token\"</span><span style=\"color:#9ECBFF\"> https://localhost:8443/v1/secret/forbidden/path</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: HTTP 403 Forbidden with policy denial message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Signs of problems: HTTP 200 (policy bypass), HTTP 500 (policy evaluation failure)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify policy wildcard matching</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"X-Vault-Token: wildcard-token\"</span><span style=\"color:#9ECBFF\"> https://localhost:8443/v1/secret/allowed/subpath</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: HTTP 200 or 404 based on secret existence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Signs of problems: HTTP 403 (wildcard not working), HTTP 500 (pattern matching failure)</span></span></code></pre></div>\n\n<p><strong>Background Process Verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Check background process health</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> https://localhost:8443/v1/sys/health</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: JSON with background process status information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Look for: lease_reaper_status: \"healthy\", revocation_workers: \"active\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Signs of problems: process_status: \"failed\", high error counts</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Monitor lease cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create dynamic secret, wait for expiration, verify cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check logs for: \"lease expired and queued for revocation\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check target system for: credential actually removed</span></span></code></pre></div>\n\n<p><strong>Common Implementation Issues:</strong></p>\n<p>⚠️ <strong>Pitfall: Missing Request Context Propagation</strong>\nForgetting to pass the request context through all pipeline stages causes loss of audit information and makes debugging impossible. Each stage must receive and can modify the RequestContext object, and all audit events must reference the same request ID for correlation.</p>\n<p>⚠️ <strong>Pitfall: Blocking Background Processes</strong>\nBackground processes that don&#39;t properly handle the stop channel can prevent graceful shutdown and cause resource leaks. Always use select statements with the stop channel and ensure goroutines terminate cleanly when requested.</p>\n<p>⚠️ <strong>Pitfall: Inconsistent Error Response Format</strong>\nHTTP endpoints that return different error formats make client implementation difficult and break compatibility with Vault clients. Use a consistent error response structure across all endpoints with appropriate HTTP status codes.</p>\n<p>⚠️ <strong>Pitfall: Missing Constant-Time Token Comparison</strong>\nUsing standard string comparison for token validation enables timing attacks where attackers can determine valid token prefixes by measuring response times. Always use constant-time comparison functions for any security-sensitive string comparisons.</p>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section applies to all four milestones, with particular emphasis on Milestone 4 (High Availability) for cluster-related failures. Error handling strategies are built progressively through each milestone.</p>\n</blockquote>\n<p>A robust secret management system must operate reliably even when components fail, networks partition, or external systems become unavailable. Think of this as designing a bank vault system that continues to protect assets and serve authorized customers even during earthquakes, power outages, or attempted break-ins. The system must gracefully degrade functionality while maintaining its core security guarantees, never compromising secrets even in catastrophic failure scenarios.</p>\n<p>This section examines the primary failure modes that can affect a secret management system, the detection and recovery strategies for each failure type, and how the system maintains partial functionality when full operation is impossible. The key insight is that security requirements never relax during failures - if anything, the system must become more conservative and protective when operating in degraded states.</p>\n<h3 id=\"system-failure-modes\">System Failure Modes</h3>\n<p>Understanding potential failure modes is critical for building resilient secret management systems. Each failure mode requires specific detection mechanisms, recovery procedures, and fallback strategies. The system must be designed with the principle of &quot;assume breach&quot; - any component can fail at any time, and the system must continue to protect secrets.</p>\n<h4 id=\"network-partitions-and-communication-failures\">Network Partitions and Communication Failures</h4>\n<p>Network partitions represent one of the most challenging failure modes for distributed secret management systems. Unlike simple network outages where nodes are clearly unavailable, partitions create split-brain scenarios where subsets of nodes can communicate internally but cannot reach other subsets. This is analogous to a bank having multiple branches that can operate independently but cannot communicate with headquarters - each branch must decide whether to continue serving customers or temporarily halt operations.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Scenario</th>\n<th>Symptoms</th>\n<th>Detection Method</th>\n<th>Immediate Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network partition between cluster nodes</td>\n<td>Raft consensus timeouts, leader election failures</td>\n<td>Heartbeat monitoring, consensus operation failures</td>\n<td>Transition non-leader nodes to read-only mode</td>\n</tr>\n<tr>\n<td>Client-to-server network issues</td>\n<td>HTTP request timeouts, connection refused errors</td>\n<td>Client-side timeout detection, load balancer health checks</td>\n<td>Client retry with exponential backoff, circuit breaker activation</td>\n</tr>\n<tr>\n<td>Storage backend network failures</td>\n<td>Database connection timeouts, cloud storage API errors</td>\n<td>Backend health check failures, operation timeouts</td>\n<td>Switch to cached data, enable read-only mode</td>\n</tr>\n<tr>\n<td>KMS provider network issues</td>\n<td>Auto-unseal failures, key operation timeouts</td>\n<td>KMS health check timeouts, encryption operation failures</td>\n<td>Manual unseal fallback, defer key operations</td>\n</tr>\n</tbody></table>\n<p>The system implements several strategies to handle network-related failures. For cluster communication, the Raft consensus protocol provides built-in partition tolerance by requiring a majority quorum for write operations. When a partition occurs, only the subset containing a majority of nodes can continue accepting write requests, while minority partitions automatically transition to read-only mode. This prevents the dangerous split-brain scenario where multiple subsets accept conflicting writes.</p>\n<blockquote>\n<p><strong>Design Insight: Conservative Degradation</strong></p>\n<p>When facing ambiguous failure conditions, the system always chooses the more restrictive option. A node that cannot confirm it&#39;s part of the majority partition will refuse write operations rather than risk creating inconsistency. This &quot;fail-safe&quot; approach prioritizes data integrity over availability.</p>\n</blockquote>\n<p>Client-facing network failures require careful retry logic to avoid overwhelming a recovering system. The system implements exponential backoff with jitter to spread retry attempts over time. Circuit breaker patterns prevent cascading failures by temporarily halting requests to unresponsive backends, allowing them time to recover.</p>\n<p><strong>Decision: Network Partition Handling Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Network partitions can create split-brain scenarios where multiple nodes accept conflicting writes, leading to data inconsistency</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Allow all nodes to continue operations independently</li>\n<li>Require strict majority quorum for any operations</li>\n<li>Implement Byzantine fault tolerance with complex consensus</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Raft consensus with majority quorum requirement and read-only degradation for minority partitions</li>\n<li><strong>Rationale</strong>: Raft provides proven partition tolerance with simpler implementation than Byzantine consensus, while majority quorum prevents split-brain scenarios without complex coordination</li>\n<li><strong>Consequences</strong>: Enables consistent behavior during partitions but requires majority of nodes for write availability, increasing minimum cluster size requirements</li>\n</ul>\n<h4 id=\"storage-system-failures\">Storage System Failures</h4>\n<p>Storage failures can range from temporary connectivity issues to permanent data corruption. The secret management system must handle these failures without exposing unencrypted secrets or losing critical metadata. Think of this as a library system where individual books might become damaged, entire shelves might become inaccessible, or the card catalog might become corrupted - the library must continue operating while protecting its collection.</p>\n<table>\n<thead>\n<tr>\n<th>Storage Failure Type</th>\n<th>Detection Signals</th>\n<th>Data at Risk</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Disk corruption</td>\n<td>Checksum validation failures, read errors</td>\n<td>Individual secret versions</td>\n<td>Restore from backup, mark corrupted versions as unavailable</td>\n</tr>\n<tr>\n<td>Database connection loss</td>\n<td>Connection timeouts, SQL errors</td>\n<td>All persisted data temporarily inaccessible</td>\n<td>Retry with exponential backoff, switch to cached data</td>\n</tr>\n<tr>\n<td>Storage backend crash</td>\n<td>Health check failures, persistent connection errors</td>\n<td>All stored secrets and metadata</td>\n<td>Failover to backup storage, restore from replicated data</td>\n</tr>\n<tr>\n<td>Encryption key corruption</td>\n<td>Decryption failures, key validation errors</td>\n<td>Secrets encrypted with corrupted key</td>\n<td>Key recovery from shares, re-encryption with new key</td>\n</tr>\n<tr>\n<td>Transaction log corruption</td>\n<td>WAL read errors, sequence validation failures</td>\n<td>Recent writes may be lost</td>\n<td>Replay from last good checkpoint, rebuild from snapshots</td>\n</tr>\n</tbody></table>\n<p>The system implements multiple layers of protection against storage failures. At the data level, all secrets include cryptographic checksums to detect corruption. The envelope encryption design isolates failures - if a data encryption key becomes corrupted, only secrets encrypted with that specific key are affected, while other secrets remain accessible.</p>\n<p>For database connectivity issues, the system maintains read-through caches for frequently accessed secrets and policies. This allows continued read operations during temporary storage outages. Write operations are queued with persistent storage to ensure no requests are lost during brief connectivity issues.</p>\n<p>The most critical storage failure involves corruption of the master key or key shares. The system addresses this through redundant storage of encrypted key shares across multiple locations and automated integrity checking. If key corruption is detected, the system can reconstruct the master key from remaining shares and re-encrypt affected data.</p>\n<blockquote>\n<p><strong>Critical Security Principle: Fail Closed</strong></p>\n<p>When storage integrity cannot be verified, the system denies access rather than potentially serving corrupted or malicious data. A corrupted secret is treated the same as a missing secret - the request fails rather than returning potentially compromised data.</p>\n</blockquote>\n<h4 id=\"encryption-key-corruption-and-loss\">Encryption Key Corruption and Loss</h4>\n<p>Key management failures represent catastrophic scenarios for a secret management system. Unlike other data that can be restored from backups, encryption keys are unique - losing the master key means permanently losing access to all encrypted secrets. This is analogous to losing the combination to a bank vault - even if the vault and its contents are physically intact, they become inaccessible.</p>\n<table>\n<thead>\n<tr>\n<th>Key Failure Scenario</th>\n<th>Probability</th>\n<th>Impact Severity</th>\n<th>Detection Method</th>\n<th>Recovery Options</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Master key corruption in memory</td>\n<td>Low</td>\n<td>High</td>\n<td>Decryption operation failures</td>\n<td>Reconstruct from Shamir shares</td>\n</tr>\n<tr>\n<td>Single key share corruption</td>\n<td>Medium</td>\n<td>Low</td>\n<td>Share validation during reconstruction</td>\n<td>Use remaining shares, regenerate corrupted share</td>\n</tr>\n<tr>\n<td>Multiple key share corruption</td>\n<td>Low</td>\n<td>Critical</td>\n<td>Insufficient shares for reconstruction</td>\n<td>Restore shares from secure backup, emergency key escrow</td>\n</tr>\n<tr>\n<td>KMS provider key deletion</td>\n<td>Low</td>\n<td>Critical</td>\n<td>Auto-unseal failures, KMS API errors</td>\n<td>Manual unseal with backup shares, key recovery procedures</td>\n</tr>\n<tr>\n<td>Data encryption key corruption</td>\n<td>Medium</td>\n<td>Medium</td>\n<td>Secret decryption failures for specific key version</td>\n<td>Re-encrypt affected secrets with new DEK</td>\n</tr>\n</tbody></table>\n<p>The Shamir&#39;s secret sharing implementation provides redundancy for master key protection. The system can tolerate corruption of up to <code>threshold - 1</code> shares while maintaining full functionality. When share corruption is detected, the system can regenerate new shares from the reconstructed master key and distribute them to replace corrupted copies.</p>\n<p>For data encryption keys, the system maintains a key derivation tree that allows regeneration of corrupted DEKs from the master key and cryptographic parameters. This ensures that temporary DEK corruption doesn&#39;t result in permanent secret loss, though it may require re-encryption operations.</p>\n<p>The most sophisticated protection involves integration with hardware security modules (HSMs) or cloud key management services for key escrow. These external systems provide independent key recovery mechanisms when all local shares become unavailable.</p>\n<p><strong>Decision: Key Recovery Strategy Design</strong></p>\n<ul>\n<li><strong>Context</strong>: Encryption key loss or corruption could result in permanent data loss, requiring robust recovery mechanisms</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Rely solely on Shamir shares for all key recovery</li>\n<li>Implement key escrow with trusted third party</li>\n<li>Use deterministic key derivation from user passwords</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Combination of Shamir shares for primary recovery with optional KMS escrow for disaster scenarios</li>\n<li><strong>Rationale</strong>: Shamir shares provide offline recovery without external dependencies, while KMS escrow offers additional protection for catastrophic local failures without introducing routine external dependencies</li>\n<li><strong>Consequences</strong>: Enables robust key recovery with multiple fallback options but increases operational complexity and introduces potential external dependencies for disaster recovery</li>\n</ul>\n<h4 id=\"service-dependencies-and-external-systems\">Service Dependencies and External Systems</h4>\n<p>Secret management systems rely on numerous external services for full functionality. Database backends, cloud KMS providers, network time services, and certificate authorities can all experience outages or degraded performance. The system must continue protecting secrets and serving authorized requests even when these dependencies become unavailable.</p>\n<table>\n<thead>\n<tr>\n<th>Dependency Type</th>\n<th>Failure Impact</th>\n<th>Degraded Functionality</th>\n<th>Fallback Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database backend</td>\n<td>Cannot persist new secrets or leases</td>\n<td>Read from cache, reject writes</td>\n<td>Local storage, backup database</td>\n</tr>\n<tr>\n<td>Cloud KMS provider</td>\n<td>Auto-unseal unavailable, cannot encrypt new DEKs</td>\n<td>Manual unseal required, read-only mode</td>\n<td>Cached DEKs, manual key management</td>\n</tr>\n<tr>\n<td>Time service (NTP)</td>\n<td>Token expiration checks unreliable, lease management affected</td>\n<td>Conservative expiration handling</td>\n<td>Local clock with skew tolerance</td>\n</tr>\n<tr>\n<td>Certificate Authority</td>\n<td>Cannot issue new client certificates, mTLS validation issues</td>\n<td>Token authentication only, cached certificate validation</td>\n<td>Cached CA certificates, extended validity periods</td>\n</tr>\n<tr>\n<td>Dynamic secret backends</td>\n<td>Cannot generate new credentials, revocation may fail</td>\n<td>Static secret access only</td>\n<td>Cached credentials, manual cleanup</td>\n</tr>\n</tbody></table>\n<p>The system implements graceful degradation for each dependency type. When the database backend becomes unavailable, the system continues serving read requests from in-memory caches while queuing write operations for later processing. This maintains availability for secret retrieval operations while ensuring write requests aren&#39;t lost.</p>\n<p>Cloud KMS failures affect auto-unseal capabilities but don&#39;t prevent normal operations once the system is unsealed. The system falls back to manual unsealing procedures and can continue operating with locally managed encryption keys. New DEK generation may be deferred until KMS connectivity is restored.</p>\n<p>Dynamic secret backend failures have the most complex implications, as they affect both credential generation and revocation. The system implements queue-based revocation with persistent retry logic to ensure credentials are eventually cleaned up even if backends are temporarily unavailable.</p>\n<h3 id=\"recovery-strategies\">Recovery Strategies</h3>\n<p>Effective recovery strategies ensure the secret management system can restore full functionality after failures while maintaining security guarantees throughout the recovery process. Recovery procedures must be thoroughly documented, regularly tested, and executable under stress conditions. Think of these as emergency procedures for a nuclear power plant - they must be simple enough to execute correctly during crisis situations while maintaining all safety protocols.</p>\n<h4 id=\"backup-and-restore-procedures\">Backup and Restore Procedures</h4>\n<p>Comprehensive backup strategies protect against both data loss and complete system failures. The secret management system requires specialized backup procedures due to the sensitive nature of the data and the complex relationships between encrypted secrets, encryption keys, and access control metadata.</p>\n<table>\n<thead>\n<tr>\n<th>Backup Component</th>\n<th>Backup Frequency</th>\n<th>Encryption Requirements</th>\n<th>Restoration Priority</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Encrypted secret data</td>\n<td>Hourly incremental, daily full</td>\n<td>Separate encryption from operational keys</td>\n<td>High - core system functionality</td>\n</tr>\n<tr>\n<td>Shamir key shares</td>\n<td>Immediate after generation, stored offline</td>\n<td>Hardware security modules or air-gapped systems</td>\n<td>Critical - required for any secret access</td>\n</tr>\n<tr>\n<td>Access policies and tokens</td>\n<td>Daily full, immediate for policy changes</td>\n<td>Standard encryption, integrity protection</td>\n<td>Medium - affects authorization</td>\n</tr>\n<tr>\n<td>Audit logs</td>\n<td>Continuous streaming, hourly checkpoints</td>\n<td>Write-once storage, tamper-evident sealing</td>\n<td>Low - forensics and compliance</td>\n</tr>\n<tr>\n<td>System configuration</td>\n<td>After each change, weekly full</td>\n<td>Configuration-specific encryption</td>\n<td>Medium - system restoration</td>\n</tr>\n</tbody></table>\n<p>The backup strategy implements the principle of &quot;separation of concerns&quot; - secrets and keys are backed up using different procedures, storage locations, and encryption methods. This ensures that compromise of a backup system doesn&#39;t provide access to both encrypted data and the keys needed to decrypt it.</p>\n<p>Secret data backups include all encrypted content with full version history but exclude encryption keys. These backups can be stored in standard backup systems since the data remains encrypted. The backup process verifies data integrity through cryptographic checksums and maintains metadata about backup consistency points.</p>\n<p>Key share backups require the highest security measures. Shamir shares are distributed across multiple secure locations, with each location storing only a subset of shares insufficient for key reconstruction. Physical security measures include safe deposit boxes, HSMs, or geographically distributed key escrow services.</p>\n<blockquote>\n<p><strong>Security Principle: Backup Separation</strong></p>\n<p>No single backup system or location contains both encrypted secrets and the keys needed to decrypt them. Even if an attacker compromises backup infrastructure, they cannot access secret content without also compromising separate key storage systems.</p>\n</blockquote>\n<p>Restoration procedures follow carefully orchestrated sequences to ensure security throughout the recovery process. The system must be unsealed before secret restoration can begin, requiring collection of sufficient key shares. Once unsealed, data restoration proceeds in dependency order: storage backend, encryption keys, secret data, access policies, and finally audit log replay.</p>\n<p><strong>Decision: Backup Strategy Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Secret management systems require specialized backup procedures due to encryption key separation and security requirements</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Traditional database backups with encrypted tablespace</li>\n<li>Application-level export with separate key and data streams</li>\n<li>Continuous replication with encrypted transport</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Application-level export with cryptographically separated key and data backup streams</li>\n<li><strong>Rationale</strong>: Provides maximum control over encryption boundaries, enables independent key and data recovery procedures, and supports cross-platform restoration without database dependencies</li>\n<li><strong>Consequences</strong>: Enables flexible disaster recovery options with strong security isolation but requires custom backup tooling and more complex restoration procedures</li>\n</ul>\n<h4 id=\"disaster-recovery-procedures\">Disaster Recovery Procedures</h4>\n<p>Disaster recovery goes beyond simple backup restoration to address scenarios where entire data centers, regions, or operational teams become unavailable. The procedures must be executable by skeleton staff with minimal specialized knowledge while maintaining all security protocols.</p>\n<table>\n<thead>\n<tr>\n<th>Disaster Scenario</th>\n<th>Recovery Time Objective</th>\n<th>Recovery Point Objective</th>\n<th>Required Resources</th>\n<th>Automation Level</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single server failure</td>\n<td>5 minutes</td>\n<td>0 data loss</td>\n<td>Standby server, current backups</td>\n<td>Fully automated</td>\n</tr>\n<tr>\n<td>Data center outage</td>\n<td>30 minutes</td>\n<td>1 hour data loss</td>\n<td>Alternate data center, recent backups</td>\n<td>Semi-automated</td>\n</tr>\n<tr>\n<td>Regional disaster</td>\n<td>4 hours</td>\n<td>4 hours data loss</td>\n<td>Geographically distributed backups, emergency team</td>\n<td>Manual with automation tools</td>\n</tr>\n<tr>\n<td>Complete system compromise</td>\n<td>24 hours</td>\n<td>24 hours data loss</td>\n<td>Clean environment, offline backups, new hardware</td>\n<td>Fully manual</td>\n</tr>\n<tr>\n<td>Key personnel unavailable</td>\n<td>8 hours</td>\n<td>1 hour data loss</td>\n<td>Cross-trained staff, documented procedures</td>\n<td>Manual with guidance</td>\n</tr>\n</tbody></table>\n<p>Each disaster scenario has specific recovery procedures optimized for the expected conditions. Single server failures leverage automated failover with standby systems that continuously replicate data. The standby promotion process includes unsealing procedures and health verification before accepting production traffic.</p>\n<p>Data center outages require coordination between backup data centers and restoration of service at alternate locations. The procedures include network reconfiguration, DNS updates, and verification that all security boundaries remain intact during the transition.</p>\n<p>Regional disasters invoke the most comprehensive recovery procedures, potentially requiring reconstruction of the entire system infrastructure. These procedures emphasize security verification at each step, ensuring that restored systems haven&#39;t been compromised during the recovery process.</p>\n<p>The most critical disaster scenario involves complete system compromise, where attackers may have accessed both operational systems and backup infrastructure. Recovery procedures assume that all online systems are potentially compromised and require building new infrastructure from verified offline backups.</p>\n<blockquote>\n<p><strong>Operational Principle: Recovery Rehearsal</strong></p>\n<p>Disaster recovery procedures are practiced quarterly with rotating team members to ensure knowledge transfer and procedure validation. Each rehearsal identifies process improvements and updates documentation to reflect current system state.</p>\n</blockquote>\n<p>Recovery procedures include specific verification steps to confirm system integrity after restoration. These include cryptographic verification of restored data, access control validation, and security boundary testing. The system doesn&#39;t return to full operation until all verification procedures complete successfully.</p>\n<h4 id=\"data-consistency-and-integrity-validation\">Data Consistency and Integrity Validation</h4>\n<p>After any failure and recovery event, the system must verify that all data remains consistent and uncorrupted. This process goes beyond simple backup restoration to include cryptographic verification, cross-reference validation, and security boundary testing.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Type</th>\n<th>Verification Method</th>\n<th>Expected Duration</th>\n<th>Failure Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cryptographic integrity</td>\n<td>SHA-256 checksums for all secret versions</td>\n<td>10 minutes per 10k secrets</td>\n<td>Mark corrupted secrets as unavailable, restore from backup</td>\n</tr>\n<tr>\n<td>Encryption key validation</td>\n<td>Decrypt sample secrets with all key versions</td>\n<td>5 minutes per key version</td>\n<td>Regenerate corrupted keys, re-encrypt affected secrets</td>\n</tr>\n<tr>\n<td>Access policy consistency</td>\n<td>Policy rule parsing and conflict detection</td>\n<td>2 minutes per 100 policies</td>\n<td>Restore policy from backup, audit recent changes</td>\n</tr>\n<tr>\n<td>Audit log continuity</td>\n<td>Sequence number validation and timestamp verification</td>\n<td>1 minute per day of logs</td>\n<td>Investigate gap causes, restore missing log segments</td>\n</tr>\n<tr>\n<td>Dynamic secret lease validity</td>\n<td>Backend connectivity and credential verification</td>\n<td>30 seconds per active lease</td>\n<td>Revoke unverifiable leases, regenerate credentials</td>\n</tr>\n</tbody></table>\n<p>The validation process follows a systematic approach that verifies each system component independently before testing integrated functionality. Cryptographic verification confirms that all secrets can be successfully decrypted and that their content matches expected checksums. This catches both corruption and malicious tampering.</p>\n<p>Encryption key validation involves attempting to decrypt sample secrets using each available key version. Failed decryptions indicate key corruption and trigger key recovery procedures. The system maintains a small set of test secrets specifically for this validation process.</p>\n<p>Access policy validation parses all policy definitions to ensure they contain valid syntax and don&#39;t create security vulnerabilities such as overly broad wildcard permissions. The system also checks for policy conflicts that might create ambiguous authorization decisions.</p>\n<p><strong>Decision: Post-Recovery Validation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: After system recovery, comprehensive validation must confirm data integrity and security without disrupting restored service</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Background validation with immediate service restoration</li>\n<li>Complete validation before service restoration</li>\n<li>Incremental validation with gradual service enablement</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Incremental validation with gradual service enablement, starting with read-only access</li>\n<li><strong>Rationale</strong>: Balances service availability with security verification, allows early detection of validation failures without full service disruption, provides ability to halt service expansion if issues are discovered</li>\n<li><strong>Consequences</strong>: Enables faster partial service restoration with controlled risk exposure but requires more complex service state management during recovery periods</li>\n</ul>\n<h3 id=\"graceful-degradation\">Graceful Degradation</h3>\n<p>When the secret management system cannot operate at full capacity due to failures or resource constraints, it must gracefully reduce functionality while maintaining its core security guarantees. Think of this as a hospital operating on emergency power - certain services may be suspended, but life-critical functions continue with uncompromised safety standards.</p>\n<h4 id=\"read-only-mode-operation\">Read-Only Mode Operation</h4>\n<p>Read-only mode represents the most common degraded operation state, typically triggered by storage backend failures, cluster partition scenarios, or planned maintenance. In this mode, the system continues serving existing secrets to authorized clients while refusing all operations that would modify system state.</p>\n<table>\n<thead>\n<tr>\n<th>Operation Type</th>\n<th>Read-Only Behavior</th>\n<th>Error Response</th>\n<th>Client Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Secret retrieval</td>\n<td>Full functionality maintained</td>\n<td>None - normal operation</td>\n<td>No impact on existing secret access</td>\n</tr>\n<tr>\n<td>Secret creation/update</td>\n<td>Rejected with explicit error</td>\n<td>HTTP 503 Service Unavailable</td>\n<td>Applications must retry or use cached values</td>\n</tr>\n<tr>\n<td>Dynamic secret generation</td>\n<td>Rejected for new requests</td>\n<td>HTTP 503 Service Unavailable</td>\n<td>Applications must use existing credentials longer</td>\n</tr>\n<tr>\n<td>Policy changes</td>\n<td>Rejected with explicit error</td>\n<td>HTTP 503 Service Unavailable</td>\n<td>Administrative operations deferred</td>\n</tr>\n<tr>\n<td>Token creation</td>\n<td>Rejected for new requests</td>\n<td>HTTP 503 Service Unavailable</td>\n<td>Authentication uses existing tokens only</td>\n</tr>\n<tr>\n<td>Lease renewal</td>\n<td>Allowed if cached locally</td>\n<td>Partial functionality</td>\n<td>Existing leases continue, new leases unavailable</td>\n</tr>\n</tbody></table>\n<p>The transition to read-only mode is triggered automatically when the system detects conditions that make write operations unsafe or impossible. Common triggers include loss of majority quorum in a clustered deployment, storage backend connectivity issues, or explicit administrative commands during maintenance windows.</p>\n<p>During read-only mode, the system maintains full audit logging for all operations, including failed write attempts. This ensures complete visibility into system access patterns and helps identify when normal operations can safely resume. The audit system operates from local buffers and queues entries for later persistence when write access is restored.</p>\n<p>Critical to read-only mode operation is the handling of dynamic secrets and lease renewals. Existing leases can be renewed using cached policy information, preventing premature expiration of active credentials. However, new dynamic secret generation is suspended since it requires write access to create lease records and configure backend credentials.</p>\n<blockquote>\n<p><strong>Operational Principle: Transparent Degradation</strong></p>\n<p>Clients experience read-only mode as increased latency for write operations rather than service unavailability. The system returns explicit error codes and retry guidance, allowing well-designed clients to implement appropriate fallback behavior.</p>\n</blockquote>\n<p>The system provides detailed status information during read-only mode, including the specific failure conditions that triggered degradation and estimated time until full service restoration. This information helps operations teams prioritize recovery efforts and helps client applications make informed decisions about retry strategies.</p>\n<h4 id=\"reduced-functionality-scenarios\">Reduced Functionality Scenarios</h4>\n<p>Beyond simple read-only mode, the system may need to operate with various subsystems disabled or degraded. Each reduced functionality scenario maintains a specific subset of capabilities while clearly documenting what operations are unavailable and why.</p>\n<table>\n<thead>\n<tr>\n<th>Degraded Subsystem</th>\n<th>Available Functionality</th>\n<th>Unavailable Functionality</th>\n<th>Typical Causes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Dynamic secret engine</td>\n<td>Static secret access, policy evaluation</td>\n<td>New credential generation, lease renewals</td>\n<td>Backend connectivity issues, credential store failures</td>\n</tr>\n<tr>\n<td>Authentication engine</td>\n<td>Token validation from cache</td>\n<td>New token creation, policy updates</td>\n<td>Auth database unavailable, policy store corruption</td>\n</tr>\n<tr>\n<td>Encryption engine</td>\n<td>Decrypt cached DEKs</td>\n<td>Key rotation, new DEK generation</td>\n<td>KMS unavailable, master key access issues</td>\n</tr>\n<tr>\n<td>Audit logging</td>\n<td>Operation execution continues</td>\n<td>Compliance reporting, log analysis</td>\n<td>Log storage full, audit database unavailable</td>\n</tr>\n<tr>\n<td>Cluster consensus</td>\n<td>Local node operations</td>\n<td>Multi-node coordination, leadership changes</td>\n<td>Network partitions, node failures</td>\n</tr>\n</tbody></table>\n<p>Dynamic secret engine degradation significantly impacts applications that rely on just-in-time credential generation. The system extends existing lease expiration times where possible and provides clear guidance about when normal credential generation will resume. Applications must implement fallback mechanisms for extended use of existing credentials.</p>\n<p>Authentication engine degradation affects new user onboarding and policy changes but allows continued operation for existing authenticated clients. Token validation continues using cached policy information, though policy updates are deferred until full functionality is restored.</p>\n<p>Encryption engine degradation prevents key rotation activities and new secret encryption but allows continued access to existing secrets using cached decryption keys. This scenario often occurs during KMS provider outages and can be sustained for extended periods without impacting secret retrieval operations.</p>\n<p><strong>Decision: Degraded Mode Granularity</strong></p>\n<ul>\n<li><strong>Context</strong>: Different system components can fail independently, requiring fine-grained control over which functionality remains available during partial failures</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Binary availability (full service or complete shutdown)</li>\n<li>Component-level degradation (individual subsystems can be disabled)</li>\n<li>Operation-level degradation (specific operations can be disabled independently)</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Component-level degradation with clear capability boundaries between subsystems</li>\n<li><strong>Rationale</strong>: Provides meaningful partial functionality without excessive complexity, maps naturally to system architecture, allows operations teams to understand and manage degraded states effectively</li>\n<li><strong>Consequences</strong>: Enables continued service during partial failures with predictable behavior but requires careful dependency management and clear error reporting to clients</li>\n</ul>\n<h4 id=\"emergency-security-procedures\">Emergency Security Procedures</h4>\n<p>When the system detects potential security breaches or operating conditions that might compromise secret safety, it implements emergency security procedures that prioritize data protection over service availability. These procedures represent the system&#39;s final defense mechanisms when normal security controls may be insufficient.</p>\n<table>\n<thead>\n<tr>\n<th>Security Event</th>\n<th>Detection Triggers</th>\n<th>Emergency Response</th>\n<th>Service Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Potential key compromise</td>\n<td>Multiple decryption failures, unusual key access patterns</td>\n<td>Immediate key rotation, revoke all tokens</td>\n<td>Temporary service disruption during key replacement</td>\n</tr>\n<tr>\n<td>Unauthorized access patterns</td>\n<td>Failed authentication spikes, unusual geographic access</td>\n<td>Rate limiting, IP blocking, enhanced audit logging</td>\n<td>Legitimate users may experience delays</td>\n</tr>\n<tr>\n<td>Storage integrity issues</td>\n<td>Checksum failures, unexpected data modifications</td>\n<td>Read-only mode, enhanced validation</td>\n<td>Write operations suspended</td>\n</tr>\n<tr>\n<td>Time synchronization loss</td>\n<td>Clock skew detection, NTP failure</td>\n<td>Conservative token validation, extended grace periods</td>\n<td>Some authentication requests may fail</td>\n</tr>\n<tr>\n<td>Administrative account compromise</td>\n<td>Unusual admin activity, policy changes outside change windows</td>\n<td>Require additional authentication, suspend admin operations</td>\n<td>Administrative functions temporarily restricted</td>\n</tr>\n</tbody></table>\n<p>The most critical emergency procedure involves suspected master key compromise. The system immediately initiates emergency key rotation procedures, generates new master keys from fresh entropy sources, and begins re-encrypting all stored secrets. During this process, service availability may be completely suspended to prevent access using potentially compromised keys.</p>\n<p>Suspected authentication system compromise triggers comprehensive token revocation and enhanced authentication requirements. All active tokens are invalidated, and new authentication requires additional verification steps such as out-of-band confirmation or multi-factor authentication.</p>\n<p>Storage integrity emergencies place the system in a protective mode where all write operations are suspended and read operations include enhanced validation. The system maintains detailed forensic logs of all access attempts during integrity emergencies to support later investigation.</p>\n<blockquote>\n<p><strong>Security Principle: Emergency Conservatism</strong></p>\n<p>During emergency security procedures, the system errs on the side of denying legitimate access rather than potentially allowing unauthorized access. Service availability is secondary to maintaining the confidentiality and integrity of stored secrets.</p>\n</blockquote>\n<p>Emergency procedures include automatic notification mechanisms to alert security teams and system administrators. These notifications include detailed context about the triggering conditions and recommended manual intervention steps. The system maintains emergency contact lists and escalation procedures for different types of security events.</p>\n<p>Recovery from emergency security procedures requires explicit administrative action after investigation confirms the system is safe to return to normal operation. This prevents the system from automatically resuming normal operations if the emergency conditions recur or if manual intervention is needed to address underlying security issues.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical implementation guidance for building robust error handling and recovery capabilities into the secret management system. The focus is on creating production-ready error handling that maintains security guarantees even during failure conditions.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Handling Framework</td>\n<td>Standard library error wrapping (Go: <code>fmt.Errorf</code>, Python: <code>raise from</code>)</td>\n<td>Structured error library (<code>github.com/pkg/errors</code>, <code>structlog</code>)</td>\n</tr>\n<tr>\n<td>Health Check System</td>\n<td>HTTP endpoint with basic service status</td>\n<td>Comprehensive health monitoring (<code>go-health</code>, <code>healthcheck</code>)</td>\n</tr>\n<tr>\n<td>Circuit Breaker</td>\n<td>Simple timeout and retry logic</td>\n<td>Production circuit breaker (<code>hystrix-go</code>, <code>circuit-breaker</code>)</td>\n</tr>\n<tr>\n<td>Backup System</td>\n<td>File-based backups with cron scheduling</td>\n<td>Enterprise backup solution (Velero, Restic with encryption)</td>\n</tr>\n<tr>\n<td>Monitoring and Alerting</td>\n<td>Log file monitoring with grep</td>\n<td>Full observability stack (Prometheus, Grafana, AlertManager)</td>\n</tr>\n<tr>\n<td>Graceful Shutdown</td>\n<td>Signal handling with context cancellation</td>\n<td>Graceful shutdown library (<code>graceful</code>, <code>shutdown-manager</code>)</td>\n</tr>\n</tbody></table>\n<h4 id=\"file-structure-for-error-handling\">File Structure for Error Handling</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/\n  errors/\n    errors.go              ← Custom error types and utilities\n    codes.go              ← Error classification and HTTP status mapping\n    recovery.go           ← Recovery procedure implementations\n  health/\n    checker.go            ← Health check implementations\n    status.go             ← System status tracking\n  backup/\n    backup.go             ← Backup coordination and scheduling\n    restore.go            ← Restoration procedures\n    validation.go         ← Post-recovery validation\n  graceful/\n    shutdown.go           ← Graceful degradation implementation\n    readonly.go           ← Read-only mode coordination</code></pre></div>\n\n<h4 id=\"core-error-handling-infrastructure\">Core Error Handling Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> errors</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ErrorCode represents different categories of errors for appropriate handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ErrorCode</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrCodeStorageFailure</span><span style=\"color:#B392F0\">    ErrorCode</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"STORAGE_FAILURE\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrCodeEncryptionFailure</span><span style=\"color:#B392F0\"> ErrorCode</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ENCRYPTION_FAILURE\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrCodeNetworkFailure</span><span style=\"color:#B392F0\">    ErrorCode</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"NETWORK_FAILURE\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrCodeKeyCorruption</span><span style=\"color:#B392F0\">     ErrorCode</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"KEY_CORRUPTION\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrCodeAuthFailure</span><span style=\"color:#B392F0\">       ErrorCode</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"AUTH_FAILURE\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrCodeReadOnlyMode</span><span style=\"color:#B392F0\">      ErrorCode</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"READ_ONLY_MODE\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SecretManagementError provides structured error information for proper handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SecretManagementError</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Code        </span><span style=\"color:#B392F0\">ErrorCode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cause       </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Context     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Recoverable </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RetryAfter  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretManagementError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, e.Code, e.Message, e.Cause)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewStorageError creates an error for storage-related failures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewStorageError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">cause</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">recoverable</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretManagementError</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create SecretManagementError with ErrCodeStorageFailure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set appropriate retry delay based on error type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Include storage-specific context information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Determine if error is recoverable based on cause</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewEncryptionError creates an error for encryption-related failures  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewEncryptionError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">cause</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretManagementError</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create SecretManagementError with ErrCodeEncryptionFailure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Mark as non-recoverable (encryption errors are usually permanent)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Include key version and algorithm context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Set timestamp for audit trail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ToHTTPStatus maps error codes to appropriate HTTP status codes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretManagementError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ToHTTPStatus</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Map ErrCodeStorageFailure to 503 Service Unavailable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Map ErrCodeEncryptionFailure to 500 Internal Server Error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Map ErrCodeAuthFailure to 401 Unauthorized or 403 Forbidden</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Map ErrCodeReadOnlyMode to 503 Service Unavailable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Default to 500 for unmapped error codes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"health-check-and-status-monitoring\">Health Check and Status Monitoring</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> health</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ComponentStatus represents the health status of a system component</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ComponentStatus</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StatusHealthy</span><span style=\"color:#B392F0\">   ComponentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"healthy\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StatusDegraded</span><span style=\"color:#B392F0\">  ComponentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"degraded\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StatusUnhealthy</span><span style=\"color:#B392F0\"> ComponentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"unhealthy\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StatusUnknown</span><span style=\"color:#B392F0\">   ComponentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"unknown\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HealthCheck defines the interface for component health checking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HealthCheck</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Name</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Check</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">ComponentStatus</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Timeout</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SystemHealth tracks the overall health of the secret management system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SystemHealth</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    checks      </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">HealthCheck</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastResults </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">ComponentStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex       </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    checkInterval </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewSystemHealth</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">checkInterval</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SystemHealth</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">SystemHealth</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        checks:        </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">HealthCheck</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lastResults:   </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">ComponentStatus</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        checkInterval: checkInterval,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterCheck adds a health check for a system component</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SystemHealth</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterCheck</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">check</span><span style=\"color:#B392F0\"> HealthCheck</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Add check to checks map using check.Name() as key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize status as StatusUnknown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Consider thread safety for concurrent registration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartMonitoring begins continuous health checking for all components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SystemHealth</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartMonitoring</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create ticker for periodic health checks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Run health checks for all registered components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Update lastResults with current status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Log status changes and health degradation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Handle context cancellation for clean shutdown</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetOverallStatus determines system-wide health based on component statuses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SystemHealth</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetOverallStatus</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">ComponentStatus</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read all component statuses with appropriate locking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Return StatusUnhealthy if any critical component is unhealthy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return StatusDegraded if any component is degraded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return StatusHealthy only if all components are healthy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StorageHealthCheck implements health checking for storage backends</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StorageHealthCheck</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storage </span><span style=\"color:#B392F0\">Backend</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timeout </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StorageHealthCheck</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Check</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">ComponentStatus</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create context with timeout for storage operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Attempt simple read operation (like reading a health check key)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Measure response time and compare to thresholds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return StatusHealthy for fast responses, StatusDegraded for slow responses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return StatusUnhealthy for failed operations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"backup-and-recovery-implementation\">Backup and Recovery Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> backup</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/sha256</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">io</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BackupMetadata contains information about a backup for restoration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BackupMetadata</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BackupID      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Components    []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Checksum      []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EncryptionKey </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Consistency   </span><span style=\"color:#B392F0\">ConsistencyLevel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ConsistencyLevel</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ConsistencyEventual</span><span style=\"color:#B392F0\"> ConsistencyLevel</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ConsistencyStrong</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ConsistencySnapshot</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BackupManager coordinates backup and restore operations across system components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BackupManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storage        </span><span style=\"color:#B392F0\">Backend</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    encryptionKey  []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    backupLocation </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retentionDays  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewBackupManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">storage</span><span style=\"color:#B392F0\"> Backend</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">encryptionKey</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">location</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackupManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BackupManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        storage:        storage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        encryptionKey:  encryptionKey,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        backupLocation: location,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        retentionDays:  </span><span style=\"color:#79B8FF\">90</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Default retention</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateBackup performs a full system backup with consistency guarantees</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackupManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateBackup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">components</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackupMetadata</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate unique backup ID with timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create backup directory structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each component, call component-specific backup procedure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Calculate checksums for all backup files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Encrypt backup data using provided encryption key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Create and store backup metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Verify backup integrity before returning</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use consistent snapshot timestamp across all components</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RestoreFromBackup restores system state from a specific backup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackupManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RestoreFromBackup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">backupID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load and validate backup metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify backup integrity using stored checksums</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Decrypt backup data using stored encryption key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Stop all write operations (enter read-only mode)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Restore components in dependency order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Validate restored data consistency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Restart services and exit read-only mode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Implement rollback capability if restoration fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateBackupIntegrity checks that a backup can be successfully restored</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackupManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateBackupIntegrity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">backupID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load backup metadata and verify structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate checksums for all backup files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Compare calculated checksums with stored checksums</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Attempt to decrypt a sample of backup data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify component-specific validation (e.g., secret decryption)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return detailed error information for any validation failures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupExpiredBackups removes backups older than retention policy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BackupManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CleanupExpiredBackups</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: List all available backups with timestamps</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Identify backups older than retention period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each expired backup, verify it's safe to delete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Remove backup files and metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update backup indexes and cleanup empty directories</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Keep minimum number of backups regardless of age</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"graceful-degradation-implementation\">Graceful Degradation Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> graceful</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync/atomic</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DegradationLevel represents the current operational mode of the system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DegradationLevel</span><span style=\"color:#F97583\"> int32</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FullOperation</span><span style=\"color:#B392F0\"> DegradationLevel</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ReadOnlyMode</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EmergencyMode</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MaintenanceMode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GracefulDegradation manages system operation during failure conditions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> GracefulDegradation</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentLevel     </span><span style=\"color:#F97583\">int32</span><span style=\"color:#6A737D\"> // atomic access to DegradationLevel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    emergencyTrigger </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    statusCallbacks  []</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">DegradationLevel</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    healthChecker    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SystemHealth</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewGracefulDegradation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">healthChecker</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">SystemHealth</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GracefulDegradation</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">GracefulDegradation</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currentLevel:     </span><span style=\"color:#F97583\">int32</span><span style=\"color:#E1E4E8\">(FullOperation),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        emergencyTrigger: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        healthChecker:    healthChecker,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetCurrentLevel returns the current degradation level thread-safely</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GracefulDegradation</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetCurrentLevel</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">DegradationLevel</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> DegradationLevel</span><span style=\"color:#E1E4E8\">(atomic.</span><span style=\"color:#B392F0\">LoadInt32</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">g.currentLevel))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetDegradationLevel changes the operational mode and notifies all listeners</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GracefulDegradation</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetDegradationLevel</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">level</span><span style=\"color:#B392F0\"> DegradationLevel</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Use atomic operation to set new degradation level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Log degradation level change with timestamp and reason</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Call all registered status change callbacks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update system metrics and monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Send notifications to operations team for significant changes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MonitorSystemHealth continuously monitors health and adjusts degradation level</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GracefulDegradation</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MonitorSystemHealth</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ticker </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">NewTicker</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ticker.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ticker.C:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Get overall system health from health checker</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Evaluate if current degradation level is appropriate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: If storage is unhealthy, move to read-only mode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: If critical components fail, move to emergency mode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 5: If health improves, consider restoring higher service level</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">g.emergencyTrigger:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Immediately set EmergencyMode degradation level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Log emergency trigger with full context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Send high-priority alerts to operations team</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsOperationAllowed checks if a specific operation is permitted at current degradation level</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GracefulDegradation</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsOperationAllowed</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">operation</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentLevel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> g.</span><span style=\"color:#B392F0\">GetCurrentLevel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> currentLevel {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> FullOperation:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ReadOnlyMode:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Allow secret retrieval operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Allow policy evaluation operations  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Block secret creation/update operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Block dynamic secret generation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Allow lease renewals but not new lease creation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> EmergencyMode:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Allow only essential read operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Block all write operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Block all administrative operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Allow health check operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MaintenanceMode:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Block all client operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Allow administrative and maintenance operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Allow backup and restore operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TriggerEmergency immediately places system in emergency mode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GracefulDegradation</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TriggerEmergency</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Log emergency trigger with full context and reason</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Send signal to emergency trigger channel (non-blocking)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Generate audit event for emergency mode activation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update monitoring metrics for emergency state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After Milestone 1 (Encryption Engine):</strong></p>\n<ul>\n<li>Verify error handling for key corruption by corrupting a DEK file and confirming graceful failure</li>\n<li>Test backup and restore of encrypted secrets with key rotation</li>\n<li>Confirm system fails safely when master key is unavailable</li>\n</ul>\n<p><strong>After Milestone 2 (Authentication Engine):</strong></p>\n<ul>\n<li>Test graceful degradation when auth database becomes unavailable</li>\n<li>Verify token validation continues using cached policies in read-only mode</li>\n<li>Confirm audit logging continues during authentication failures</li>\n</ul>\n<p><strong>After Milestone 3 (Dynamic Secrets):</strong></p>\n<ul>\n<li>Test behavior when backend databases become unavailable</li>\n<li>Verify lease extension during degraded mode</li>\n<li>Confirm revocation queue persistence across system restarts</li>\n</ul>\n<p><strong>After Milestone 4 (High Availability):</strong></p>\n<ul>\n<li>Test cluster behavior during network partitions</li>\n<li>Verify automatic failover and read-only mode for minority partitions</li>\n<li>Test backup and restore procedures across clustered deployment</li>\n</ul>\n<h4 id=\"common-debugging-scenarios\">Common Debugging Scenarios</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Steps</th>\n<th>Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>System stuck in read-only mode</td>\n<td>Storage backend connectivity issues</td>\n<td>Check storage health endpoints, verify network connectivity</td>\n<td>Restore storage connectivity, manually exit read-only mode</td>\n</tr>\n<tr>\n<td>Backup restoration fails</td>\n<td>Encryption key mismatch or corruption</td>\n<td>Verify key shares, test key reconstruction</td>\n<td>Restore keys from separate backup, regenerate corrupted keys</td>\n</tr>\n<tr>\n<td>Health checks failing intermittently</td>\n<td>Network timeouts or resource exhaustion</td>\n<td>Monitor resource usage, check network latency</td>\n<td>Adjust health check timeouts, scale resources</td>\n</tr>\n<tr>\n<td>Emergency mode triggered unexpectedly</td>\n<td>Security monitoring false positives</td>\n<td>Review audit logs for trigger events</td>\n<td>Tune security monitoring thresholds, add exception rules</td>\n</tr>\n<tr>\n<td>Graceful shutdown hangs</td>\n<td>Background processes not responding to context cancellation</td>\n<td>Check goroutine dumps, identify blocking operations</td>\n<td>Add timeout enforcement, improve context handling</td>\n</tr>\n</tbody></table>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section spans all four milestones, with specific testing approaches for each: security testing for encrypted storage (Milestone 1), access control validation (Milestone 2), dynamic secret lifecycle testing (Milestone 3), and cluster consensus testing (Milestone 4).</p>\n</blockquote>\n<p>Testing a secret management system requires a fundamentally different approach than testing typical applications. Think of it like testing a bank vault system — you&#39;re not just verifying that the safe opens when given the correct combination, but also that it absolutely refuses to open for any incorrect combination, that the steel walls resist drilling attempts, that the alarm system triggers under all threat scenarios, and that the backup power systems work during emergencies. In secret management, a single security failure can compromise an entire organization&#39;s infrastructure, making comprehensive testing not just important but absolutely critical.</p>\n<p>The testing strategy for our secret management system operates on three complementary levels. <strong>Security testing</strong> forms the foundation, continuously verifying that our cryptographic implementations, access controls, and audit mechanisms work correctly under both normal and adversarial conditions. <strong>Milestone checkpoints</strong> provide structured validation points as we build each component, ensuring that fundamental behaviors work correctly before adding complexity. <strong>Integration testing</strong> validates the complete system workflows, testing how all components interact to deliver secure secret management capabilities to real applications.</p>\n<p>This multi-layered approach reflects the <strong>defense in depth</strong> principle — if one testing layer misses a vulnerability, the other layers should catch it. We test not just the happy path where everything works correctly, but also the adversarial scenarios where attackers attempt to exploit weaknesses, the chaos scenarios where infrastructure fails unpredictably, and the operational scenarios where human operators make mistakes under pressure.</p>\n<h3 id=\"security-testing\">Security Testing</h3>\n<p>Security testing for a secret management system goes far beyond checking that basic encryption works. Think of it like testing a corporate security system — you need to verify not just that authorized employees can enter the building, but that unauthorized individuals cannot gain access even with sophisticated attack techniques, that security cameras capture all relevant events, and that alarm systems function correctly during emergencies.</p>\n<p><strong>Encryption verification</strong> forms the cornerstone of our security testing approach. We must validate that our envelope encryption implementation provides the security properties we claim, that key rotation works without exposing plaintext secrets, and that our cryptographic implementations resist known attacks.</p>\n<p>The encryption testing matrix covers multiple dimensions of verification:</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Security Property</th>\n<th>Validation Method</th>\n<th>Failure Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Ciphertext Analysis</td>\n<td>Semantic Security</td>\n<td>Statistical randomness tests on encrypted output</td>\n<td>Reveals information about plaintext secrets</td>\n</tr>\n<tr>\n<td>Key Isolation</td>\n<td>Key Independence</td>\n<td>Decrypt with wrong DEK version, verify failure</td>\n<td>Cross-version secret exposure</td>\n</tr>\n<tr>\n<td>Nonce Uniqueness</td>\n<td>Replay Resistance</td>\n<td>Detect nonce reuse across encryptions</td>\n<td>Authentication bypass via replay</td>\n</tr>\n<tr>\n<td>Authentication Tag</td>\n<td>Tamper Detection</td>\n<td>Modify ciphertext, verify decryption failure</td>\n<td>Undetected data corruption</td>\n</tr>\n<tr>\n<td>Key Derivation</td>\n<td>Brute Force Resistance</td>\n<td>Time password cracking attempts</td>\n<td>Weak master key compromise</td>\n</tr>\n<tr>\n<td>Memory Protection</td>\n<td>Information Leakage</td>\n<td>Scan memory dumps for plaintext keys</td>\n<td>Key extraction from memory</td>\n</tr>\n</tbody></table>\n<p><strong>Cryptographic validation</strong> requires testing our encryption engine against known attack vectors and edge cases. We implement test cases that attempt to exploit common vulnerabilities in envelope encryption systems, such as key confusion attacks where attackers trick the system into using the wrong decryption key, or padding oracle attacks that reveal information through error messages.</p>\n<p>The key rotation security tests deserve particular attention. During key rotation, we temporarily have both old and new encryption keys in memory, creating a window where compromise of either key could affect system security. Our tests simulate various failure scenarios during rotation — such as power loss, network partitions, or process crashes — and verify that the system maintains security guarantees in all cases.</p>\n<blockquote>\n<p><strong>Decision: Continuous Cryptographic Testing</strong></p>\n<ul>\n<li><strong>Context</strong>: Cryptographic bugs can be subtle and may not manifest in functional testing, but can completely compromise security</li>\n<li><strong>Options Considered</strong>: Manual periodic reviews, automated test suite with crypto vectors, formal verification</li>\n<li><strong>Decision</strong>: Comprehensive automated test suite with known crypto test vectors plus property-based testing</li>\n<li><strong>Rationale</strong>: Automated testing catches regressions immediately, known vectors validate against published standards, property-based testing finds edge cases</li>\n<li><strong>Consequences</strong>: Higher confidence in crypto implementation, but requires significant test infrastructure investment</li>\n</ul>\n</blockquote>\n<p><strong>Access control validation</strong> tests our authentication and authorization mechanisms under both normal and adversarial conditions. This includes testing for <strong>constant-time comparison</strong> vulnerabilities, where timing differences in token validation could allow attackers to guess valid tokens, and policy bypass attempts where malformed requests might circumvent access controls.</p>\n<p>Our access control test scenarios include:</p>\n<table>\n<thead>\n<tr>\n<th>Attack Vector</th>\n<th>Test Method</th>\n<th>Expected Outcome</th>\n<th>Security Concern</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Token Guessing</td>\n<td>Brute force token validation with timing analysis</td>\n<td>Constant response time regardless of token validity</td>\n<td>Timing side-channel reveals valid token patterns</td>\n</tr>\n<tr>\n<td>Path Traversal</td>\n<td>Request secrets with manipulated paths (../, //)</td>\n<td>Access denied for all unauthorized paths</td>\n<td>Directory traversal bypasses path-based ACLs</td>\n</tr>\n<tr>\n<td>Policy Confusion</td>\n<td>Submit requests with conflicting policy claims</td>\n<td>Deny access when policies conflict</td>\n<td>Ambiguous policies might default to allow</td>\n</tr>\n<tr>\n<td>Token Replay</td>\n<td>Reuse expired or revoked tokens</td>\n<td>Reject all invalid tokens consistently</td>\n<td>Stale tokens continue to grant access</td>\n</tr>\n<tr>\n<td>Privilege Escalation</td>\n<td>Attempt to access admin endpoints with user tokens</td>\n<td>Enforce role separation strictly</td>\n<td>Users gain administrative privileges</td>\n</tr>\n<tr>\n<td>Session Fixation</td>\n<td>Predict or control token generation</td>\n<td>Cryptographically random, unpredictable tokens</td>\n<td>Attackers can guess or control user tokens</td>\n</tr>\n</tbody></table>\n<p>The <strong>audit logging security tests</strong> verify that our tamper-evident logging correctly captures all security-relevant events and resists attempts to modify or delete audit records. We test scenarios where attackers gain partial system access and attempt to cover their tracks by modifying log files.</p>\n<p><strong>Penetration testing</strong> simulates real-world attack scenarios against our deployed secret management system. These tests assume that attackers have gained some level of system access — perhaps through compromised application credentials or network position — and attempt to escalate their access to retrieve secrets they shouldn&#39;t have.</p>\n<p>Common penetration testing scenarios include:</p>\n<ol>\n<li><strong>Compromise Recovery Testing</strong>: Simulate discovery of a leaked token and verify that token revocation prevents further access</li>\n<li><strong>Insider Threat Simulation</strong>: Test system behavior when legitimate users attempt to access secrets outside their authorized scope</li>\n<li><strong>Network Attack Simulation</strong>: Test TLS configuration and certificate validation under man-in-the-middle attacks</li>\n<li><strong>Side-Channel Analysis</strong>: Monitor system resource usage patterns to detect information leakage through CPU, memory, or network timing</li>\n<li><strong>Social Engineering Simulation</strong>: Test operational procedures for responding to requests for emergency access or system recovery</li>\n</ol>\n<p><strong>Chaos security testing</strong> introduces failures during security-critical operations to verify that our system maintains security properties even under adverse conditions. For example, we might simulate power loss during key rotation, network partitions during authentication, or storage corruption during secret updates.</p>\n<p>The key insight from chaos security testing is that security vulnerabilities often emerge not from normal operation, but from the complex interactions between security mechanisms and failure recovery procedures. A system might correctly encrypt secrets during normal operation, but accidentally write plaintext to logs during error recovery.</p>\n<h3 id=\"milestone-checkpoints\">Milestone Checkpoints</h3>\n<p>Each milestone introduces new security-critical functionality that must be thoroughly validated before proceeding to the next phase. Think of these checkpoints like security clearance levels — you can&#39;t proceed to more sensitive information until you&#39;ve proven that the current level is completely secure.</p>\n<p><strong>Milestone 1 Checkpoint: Encrypted Secret Storage</strong></p>\n<p>The first milestone establishes the foundation of our security model through envelope encryption. The checkpoint validation must verify that secrets are never stored in plaintext and that our key management procedures work correctly.</p>\n<p>Critical validation points for Milestone 1:</p>\n<table>\n<thead>\n<tr>\n<th>Validation Category</th>\n<th>Test Description</th>\n<th>Success Criteria</th>\n<th>Failure Symptoms</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Envelope Encryption</td>\n<td>Store secret, examine storage backend directly</td>\n<td>No plaintext visible in stored data</td>\n<td>Secrets readable without decryption</td>\n</tr>\n<tr>\n<td>Key Rotation</td>\n<td>Rotate DEK, verify old and new versions decrypt correctly</td>\n<td>Both versions accessible, no downtime</td>\n<td>Secret access failures or plaintext exposure</td>\n</tr>\n<tr>\n<td>Secret Versioning</td>\n<td>Create multiple versions, verify independent retrieval</td>\n<td>Each version returns correct value</td>\n<td>Version confusion or data corruption</td>\n</tr>\n<tr>\n<td>Master Key Protection</td>\n<td>Examine memory dumps and storage for key material</td>\n<td>Keys only in memory when actively used</td>\n<td>Persistent key storage or memory leaks</td>\n</tr>\n<tr>\n<td>Recovery Testing</td>\n<td>Restart system, verify access to existing secrets</td>\n<td>All secrets accessible after restart</td>\n<td>Data loss or corruption after restart</td>\n</tr>\n<tr>\n<td>Storage Backend Independence</td>\n<td>Switch storage backends, verify secret accessibility</td>\n<td>Seamless backend migration</td>\n<td>Backend-specific secret corruption</td>\n</tr>\n</tbody></table>\n<p>The envelope encryption validation requires careful testing of the key hierarchy. We must verify that the master key never appears in persistent storage except when encrypted by external systems (for auto-unseal scenarios), that data encryption keys are properly versioned and rotated independently, and that secret values remain accessible across key rotation events.</p>\n<p><strong>Performance baseline testing</strong> establishes acceptable latency and throughput characteristics for the encryption engine. Secret management systems often become bottlenecks in application deployment pipelines, so understanding performance characteristics helps with capacity planning.</p>\n<p>Key performance metrics for Milestone 1:</p>\n<ul>\n<li><strong>Encryption latency</strong>: Time from secret submission to storage confirmation</li>\n<li><strong>Decryption latency</strong>: Time from secret request to plaintext delivery  </li>\n<li><strong>Key rotation duration</strong>: End-to-end time for DEK rotation with large secret volumes</li>\n<li><strong>Memory usage patterns</strong>: Peak memory consumption during encryption operations</li>\n<li><strong>Storage amplification</strong>: Ratio of encrypted storage size to plaintext size</li>\n</ul>\n<p><strong>Milestone 2 Checkpoint: Access Policies &amp; Authentication</strong></p>\n<p>The second milestone introduces authentication and authorization capabilities that protect the encrypted secrets created in Milestone 1. The validation must verify that only properly authenticated and authorized requests can access secrets.</p>\n<p>Authentication validation focuses on ensuring that our token-based and mTLS authentication mechanisms correctly identify clients and resist common attacks:</p>\n<table>\n<thead>\n<tr>\n<th>Authentication Test</th>\n<th>Attack Simulation</th>\n<th>Validation Method</th>\n<th>Security Property</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Token Validation</td>\n<td>Submit requests with forged tokens</td>\n<td>Reject all invalid tokens with constant timing</td>\n<td>Cryptographic token integrity</td>\n</tr>\n<tr>\n<td>Token Expiration</td>\n<td>Use expired tokens after TTL</td>\n<td>Access denied for expired credentials</td>\n<td>Temporal access control</td>\n</tr>\n<tr>\n<td>mTLS Certificate</td>\n<td>Present invalid or expired client certificates</td>\n<td>Reject connections with invalid certificates</td>\n<td>Certificate-based identity</td>\n</tr>\n<tr>\n<td>Replay Attack</td>\n<td>Reuse intercepted authentication tokens</td>\n<td>Detect and reject replayed tokens</td>\n<td>Replay resistance</td>\n</tr>\n<tr>\n<td>Timing Analysis</td>\n<td>Measure token validation response times</td>\n<td>Constant time regardless of token validity</td>\n<td>Side-channel resistance</td>\n</tr>\n<tr>\n<td>Concurrent Sessions</td>\n<td>Multiple simultaneous sessions with same token</td>\n<td>Proper session isolation and tracking</td>\n<td>Session security</td>\n</tr>\n</tbody></table>\n<p>Authorization validation ensures that our path-based policy engine correctly enforces access controls even with complex policy rules and edge cases:</p>\n<table>\n<thead>\n<tr>\n<th>Authorization Test</th>\n<th>Policy Scenario</th>\n<th>Request Pattern</th>\n<th>Expected Outcome</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Exact Path Match</td>\n<td>Policy allows <code>secret/app/db</code></td>\n<td>Request <code>secret/app/db</code></td>\n<td>Access granted</td>\n</tr>\n<tr>\n<td>Wildcard Matching</td>\n<td>Policy allows <code>secret/app/*</code></td>\n<td>Request <code>secret/app/api-key</code></td>\n<td>Access granted</td>\n</tr>\n<tr>\n<td>Path Traversal</td>\n<td>Policy allows <code>secret/app/*</code></td>\n<td>Request <code>secret/app/../admin/key</code></td>\n<td>Access denied</td>\n</tr>\n<tr>\n<td>Nested Wildcards</td>\n<td>Policy allows <code>secret/**</code></td>\n<td>Request <code>secret/deep/nested/path</code></td>\n<td>Access granted according to recursive pattern</td>\n</tr>\n<tr>\n<td>Policy Conflicts</td>\n<td>Multiple policies with different permissions</td>\n<td>Requests matching overlapping policies</td>\n<td>Secure default (deny) when ambiguous</td>\n</tr>\n<tr>\n<td>Missing Policies</td>\n<td>No policy covers requested path</td>\n<td>Any request to uncovered path</td>\n<td>Default deny behavior</td>\n</tr>\n</tbody></table>\n<p><strong>Audit logging validation</strong> ensures that all security-relevant events are properly captured and that the audit trail provides sufficient information for security investigations:</p>\n<ul>\n<li><strong>Event completeness</strong>: All authentication attempts, authorization decisions, and secret access events logged</li>\n<li><strong>Event integrity</strong>: Audit records resist tampering and provide cryptographic integrity guarantees</li>\n<li><strong>Event correlation</strong>: Related events (authentication → authorization → secret access) can be traced through request IDs</li>\n<li><strong>Performance impact</strong>: Audit logging doesn&#39;t significantly degrade system performance</li>\n<li><strong>Storage management</strong>: Audit logs rotate properly and don&#39;t exhaust available storage</li>\n</ul>\n<p><strong>Milestone 3 Checkpoint: Dynamic Secrets</strong></p>\n<p>The third milestone adds dynamic secret generation capabilities, introducing time-based security properties through lease management. Validation must verify that credentials are properly generated, tracked, and revoked.</p>\n<p>Dynamic secret generation testing focuses on the credential lifecycle and backend integration:</p>\n<table>\n<thead>\n<tr>\n<th>Backend Type</th>\n<th>Generation Test</th>\n<th>Revocation Test</th>\n<th>Renewal Test</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database</td>\n<td>Create unique user with limited privileges</td>\n<td>Remove user and verify access denied</td>\n<td>Extend user TTL and verify continued access</td>\n</tr>\n<tr>\n<td>AWS IAM</td>\n<td>Generate temporary access keys with scoped permissions</td>\n<td>Delete IAM user and verify API calls fail</td>\n<td>Renew access keys before expiration</td>\n</tr>\n<tr>\n<td>SSH</td>\n<td>Generate signed certificate with time limits</td>\n<td>Verify certificate invalid after TTL</td>\n<td>Issue renewed certificate with extended validity</td>\n</tr>\n<tr>\n<td>PKI</td>\n<td>Issue client certificate with usage constraints</td>\n<td>Revoke certificate via CRL</td>\n<td>Renew certificate with same subject but new validity period</td>\n</tr>\n</tbody></table>\n<p><strong>Lease management validation</strong> ensures that the time-based security model works correctly:</p>\n<ul>\n<li><strong>TTL enforcement</strong>: Credentials become invalid exactly when leases expire</li>\n<li><strong>Renewal mechanics</strong>: Renewable leases extend correctly, non-renewable leases reject renewal attempts  </li>\n<li><strong>Revocation timeliness</strong>: Explicit revocation requests disable credentials within acceptable time bounds</li>\n<li><strong>Cleanup completeness</strong>: Revocation removes all traces of credentials from target systems</li>\n<li><strong>Failure recovery</strong>: Failed revocation attempts retry with exponential backoff until successful</li>\n</ul>\n<p>The <strong>lease reaper testing</strong> validates the background processes that maintain system security by cleaning up expired credentials:</p>\n<ol>\n<li>Create multiple dynamic secrets with different TTLs</li>\n<li>Wait for natural expiration of some credentials</li>\n<li>Verify that expired credentials no longer grant access to target systems</li>\n<li>Confirm that lease records are properly cleaned from internal storage</li>\n<li>Test reaper behavior during system restart and recovery scenarios</li>\n</ol>\n<p><strong>Milestone 4 Checkpoint: Unsealing &amp; High Availability</strong></p>\n<p>The final milestone introduces distributed operation and master key protection through Shamir&#39;s secret sharing. Validation must verify that the cluster maintains security and availability guarantees under various failure scenarios.</p>\n<p><strong>Shamir&#39;s secret sharing validation</strong> ensures that our threshold scheme correctly protects the master key:</p>\n<table>\n<thead>\n<tr>\n<th>Share Configuration</th>\n<th>Test Scenario</th>\n<th>Validation Method</th>\n<th>Security Property</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>3-of-5 threshold</td>\n<td>Reconstruct with exactly 3 shares</td>\n<td>Successfully unseal system</td>\n<td>Minimum threshold suffices</td>\n</tr>\n<tr>\n<td>2-of-5 attempt</td>\n<td>Attempt reconstruction with only 2 shares</td>\n<td>Reconstruction fails completely</td>\n<td>Insufficient shares provide no information</td>\n</tr>\n<tr>\n<td>Share corruption</td>\n<td>Modify one share before reconstruction</td>\n<td>Detect corruption and reject invalid share</td>\n<td>Share integrity validation</td>\n</tr>\n<tr>\n<td>Share ordering</td>\n<td>Present shares in different orders</td>\n<td>Reconstruction produces identical results</td>\n<td>Order independence</td>\n</tr>\n<tr>\n<td>Share storage</td>\n<td>Examine individual share contents</td>\n<td>Shares reveal no information about master key</td>\n<td>Information-theoretic security</td>\n</tr>\n<tr>\n<td>Recovery procedure</td>\n<td>Simulate loss of shares, regenerate master key</td>\n<td>Complete system recovery with new shares</td>\n<td>Disaster recovery capabilities</td>\n</tr>\n</tbody></table>\n<p><strong>High availability validation</strong> tests the distributed consensus mechanisms and leader election procedures:</p>\n<ul>\n<li><strong>Leader election</strong>: Single leader emerges after cluster startup, leadership transfers correctly during failures</li>\n<li><strong>Split-brain prevention</strong>: Network partitions don&#39;t result in multiple active leaders accepting conflicting writes</li>\n<li><strong>Data consistency</strong>: All nodes converge to identical state after network partition recovery</li>\n<li><strong>Client failover</strong>: Clients automatically redirect to new leader after failover events</li>\n<li><strong>Performance impact</strong>: Consensus overhead doesn&#39;t significantly degrade operation latency</li>\n</ul>\n<p><strong>Auto-unseal integration testing</strong> validates the cloud KMS integration for automated system startup:</p>\n<ol>\n<li>Configure auto-unseal with mock KMS provider</li>\n<li>Seal the system and verify it requires external key to operate</li>\n<li>Test auto-unseal during normal startup procedures</li>\n<li>Simulate KMS failures during unseal attempts</li>\n<li>Verify fallback to manual unseal when auto-unseal unavailable</li>\n<li>Test key rotation scenarios with external KMS keys</li>\n</ol>\n<h3 id=\"integration-testing\">Integration Testing</h3>\n<p>Integration testing validates that all components work together correctly to provide secure secret management capabilities to real applications. Think of this as testing the entire bank vault system — not just the individual components like the safe, alarm system, and access controls, but how they all work together to protect valuable assets under realistic conditions.</p>\n<p><strong>End-to-end workflow testing</strong> simulates complete application interactions with our secret management system, from initial authentication through secret retrieval and dynamic credential generation. These tests use realistic application patterns and data volumes to surface integration issues that might not appear in unit tests.</p>\n<p>Primary integration test workflows include:</p>\n<table>\n<thead>\n<tr>\n<th>Workflow</th>\n<th>Description</th>\n<th>Components Tested</th>\n<th>Failure Modes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Application Bootstrap</td>\n<td>App authenticates and retrieves configuration secrets</td>\n<td>Auth engine, encryption engine, policy evaluation</td>\n<td>Auth failures prevent app startup</td>\n</tr>\n<tr>\n<td>Database Connection</td>\n<td>App requests dynamic DB credentials for data access</td>\n<td>Dynamic secret engine, lease management, DB backend</td>\n<td>Connection failures or credential conflicts</td>\n</tr>\n<tr>\n<td>Secret Rotation</td>\n<td>Background process rotates static secrets used by apps</td>\n<td>Encryption engine, versioning, client notification</td>\n<td>App service disruption during rotation</td>\n</tr>\n<tr>\n<td>Emergency Access</td>\n<td>Operator manually accesses secrets during incident response</td>\n<td>Unsealing, emergency policies, audit logging</td>\n<td>Security versus availability trade-offs</td>\n</tr>\n<tr>\n<td>Cluster Failover</td>\n<td>Primary node fails, backup takes over without service disruption</td>\n<td>HA cluster, leader election, data replication</td>\n<td>Client connection disruption or data loss</td>\n</tr>\n<tr>\n<td>Backup and Recovery</td>\n<td>Complete system restore from encrypted backups</td>\n<td>All components, unsealing, data verification</td>\n<td>Incomplete recovery or data corruption</td>\n</tr>\n</tbody></table>\n<p><strong>Backend plugin testing</strong> validates the integration between our dynamic secret engine and external systems that provide credentials. Each backend type has different integration patterns and failure modes that require specific testing approaches.</p>\n<p>Database backend integration testing covers multiple database platforms and credential patterns:</p>\n<ul>\n<li><strong>PostgreSQL integration</strong>: Test user creation, privilege assignment, connection validation, and cleanup procedures</li>\n<li><strong>MySQL integration</strong>: Validate account creation with proper grants, password policies, and revocation procedures  </li>\n<li><strong>MongoDB integration</strong>: Test role-based access control, database-specific permissions, and user removal</li>\n<li><strong>Connection pooling</strong>: Verify that credential generation doesn&#39;t overwhelm database connection limits</li>\n<li><strong>Schema permissions</strong>: Test that generated users receive only necessary privileges for their intended use case</li>\n</ul>\n<p>Cloud provider backend testing validates integration with major cloud platforms:</p>\n<ul>\n<li><strong>AWS IAM integration</strong>: Test temporary access key generation, policy attachment, and key revocation</li>\n<li><strong>Azure AD integration</strong>: Validate service principal creation, role assignment, and cleanup procedures</li>\n<li><strong>Google Cloud IAM integration</strong>: Test service account key generation, project-level permissions, and key deletion</li>\n<li><strong>Resource isolation</strong>: Verify that generated credentials can&#39;t access resources outside intended scope</li>\n</ul>\n<p><strong>Load testing</strong> evaluates system behavior under realistic traffic patterns and helps identify performance bottlenecks or resource exhaustion issues. Secret management systems often experience bursty traffic patterns — for example, during application deployment windows when many services simultaneously request credentials.</p>\n<p>Load testing scenarios include:</p>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Traffic Pattern</th>\n<th>Duration</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Steady State</td>\n<td>Constant rate of secret requests</td>\n<td>8 hours</td>\n<td>&lt; 100ms p99 latency, no errors</td>\n</tr>\n<tr>\n<td>Deployment Burst</td>\n<td>10x normal traffic for short periods</td>\n<td>30 minutes</td>\n<td>Graceful degradation, no failures</td>\n</tr>\n<tr>\n<td>Key Rotation</td>\n<td>Background key rotation during normal traffic</td>\n<td>2 hours</td>\n<td>No client impact, consistent latency</td>\n</tr>\n<tr>\n<td>Dynamic Secret Storm</td>\n<td>Many simultaneous dynamic credential requests</td>\n<td>15 minutes</td>\n<td>Backend rate limiting, queue management</td>\n</tr>\n<tr>\n<td>Cluster Recovery</td>\n<td>Traffic resumes after planned failover</td>\n<td>1 hour</td>\n<td>Automatic client reconnection, no data loss</td>\n</tr>\n<tr>\n<td>Memory Pressure</td>\n<td>Sustained high memory usage scenarios</td>\n<td>4 hours</td>\n<td>No memory leaks, graceful resource management</td>\n</tr>\n</tbody></table>\n<p><strong>Security integration testing</strong> validates that our security mechanisms work correctly when multiple components interact under realistic conditions. This includes testing for emergent security vulnerabilities that might arise from component interactions.</p>\n<p>Cross-component security scenarios:</p>\n<ul>\n<li><strong>Token lifecycle across components</strong>: Verify that token expiration in auth engine immediately affects access in all other components</li>\n<li><strong>Audit trail completeness</strong>: Confirm that operations involving multiple components generate complete audit trails</li>\n<li><strong>Error message information leakage</strong>: Ensure that error responses don&#39;t reveal sensitive information about system internal state</li>\n<li><strong>Resource exhaustion attacks</strong>: Test system behavior when attackers attempt to exhaust resources across multiple components</li>\n<li><strong>Privilege boundary enforcement</strong>: Verify that compromise of one component doesn&#39;t automatically compromise others</li>\n</ul>\n<p><strong>Monitoring and observability testing</strong> validates that our system provides sufficient visibility for operations teams to maintain security and availability. This includes testing that metrics, logs, and health checks correctly reflect system state and can support effective incident response.</p>\n<p>Observability validation points:</p>\n<ul>\n<li><strong>Health check accuracy</strong>: Health endpoints correctly reflect component status and dependency health</li>\n<li><strong>Metric completeness</strong>: Prometheus metrics cover all critical operations and performance characteristics  </li>\n<li><strong>Log correlation</strong>: Related events across components can be traced through correlation IDs</li>\n<li><strong>Alert threshold accuracy</strong>: Alert conditions trigger at appropriate times without excessive false positives</li>\n<li><strong>Dashboard effectiveness</strong>: Operational dashboards provide actionable information during incidents</li>\n</ul>\n<p>The integration testing phase also validates our <strong>graceful degradation</strong> capabilities — how the system behaves when some components fail but others remain operational. For example, if the dynamic secret engine fails, the system should continue serving static secrets while clearly indicating the reduced functionality.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The testing strategy implementation provides comprehensive validation for all aspects of our secret management system. This implementation focuses on Go testing frameworks and tools that provide robust security testing capabilities.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Testing Category</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unit Testing</td>\n<td>Go standard testing package</td>\n<td>Testify framework with assertions</td>\n</tr>\n<tr>\n<td>Security Testing</td>\n<td>Manual crypto test vectors</td>\n<td>Rapid property-based testing</td>\n</tr>\n<tr>\n<td>Integration Testing</td>\n<td>HTTP client tests against local server</td>\n<td>Testcontainers with real databases</td>\n</tr>\n<tr>\n<td>Load Testing</td>\n<td>Basic goroutine-based load generation</td>\n<td>Vegeta or k6 load testing tools</td>\n</tr>\n<tr>\n<td>Penetration Testing</td>\n<td>Manual security reviews</td>\n<td>OWASP ZAP automated scanning</td>\n</tr>\n<tr>\n<td>Chaos Testing</td>\n<td>Manual failure injection</td>\n<td>Chaos Monkey or Litmus chaos engineering</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended Testing File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  cmd/\n    server/\n      main_test.go              ← integration tests\n  internal/\n    encryption/\n      engine.go\n      engine_test.go            ← unit tests\n      engine_security_test.go   ← security-specific tests\n    auth/\n      engine.go  \n      engine_test.go\n      engine_integration_test.go ← cross-component tests\n    dynamic/\n      engine.go\n      engine_test.go\n      backends/\n        database_test.go        ← backend-specific tests\n  test/\n    security/\n      crypto_vectors_test.go    ← known answer tests\n      penetration_test.go       ← security scanning tests\n    integration/\n      workflows_test.go         ← end-to-end scenarios\n      load_test.go             ← performance testing\n    testdata/\n      policies/               ← test policy files\n      certificates/           ← test TLS certificates\n      vectors/               ← crypto test vectors\n  docker-compose.test.yml     ← test environment setup</code></pre></div>\n\n<p><strong>Security Testing Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package security provides comprehensive security testing utilities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// for the secret management system.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> security</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/rand</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/subtle</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CryptoTestVector represents a known-answer test for cryptographic operations.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CryptoTestVector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Plaintext  []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Key        []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Nonce      []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expected   []</span><span style=\"color:#F97583\">byte</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ShouldFail </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LoadKnownVectors loads standardized crypto test vectors from NIST or other sources.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> LoadKnownVectors</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">algorithm</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">CryptoTestVector</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read test vectors from testdata/vectors/ directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Parse vector format (usually hex-encoded values)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return structured test cases for the specified algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Include both positive (should succeed) and negative (should fail) cases</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TimingAttackTest validates constant-time operations by measuring execution times.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TimingAttackTest</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ValidInput   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InvalidInput </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Operation    </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Iterations   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Tolerance    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RunTimingAnalysis executes timing attack tests to detect side-channel vulnerabilities.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TimingAttackTest</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RunTimingAnalysis</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">test</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Execute operation with valid input multiple times, measure duration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Execute operation with invalid input multiple times, measure duration  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate statistical significance of timing differences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Fail test if timing difference exceeds tolerance threshold</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use runtime.GC() before timing measurements for consistency</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PropertyTest defines properties that should hold for cryptographic operations.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PropertyTest</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">input</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RunPropertyBasedTests executes randomized property testing for crypto operations.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> RunPropertyBasedTests</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">property</span><span style=\"color:#B392F0\"> PropertyTest</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">iterations</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> iterations; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Generate random input of varying lengths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Execute property test function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Report failure with specific input that violated property</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Use crypto/rand for cryptographically secure randomness</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PenetrationTestSuite coordinates security testing against running system.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PenetrationTestSuite</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BaseURL    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TestToken  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AdminToken </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Client     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TestAuthenticationBypass attempts various authentication bypass techniques.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PenetrationTestSuite</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TestAuthenticationBypass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    testCases </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        name        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headers     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expectError </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Add test cases for:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // - Missing authentication headers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // - Malformed tokens</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // - Expired tokens</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // - Tokens with invalid signatures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // - SQL injection in token fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // - Directory traversal in token claims</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Iterate through test cases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Make HTTP requests with crafted headers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify that unauthorized requests are rejected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check that error responses don't leak sensitive information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package checkpoint provides milestone validation utilities.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> checkpoint</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/stretchr/testify/assert</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/stretchr/testify/require</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Milestone1Validator validates encrypted secret storage functionality.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Milestone1Validator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretServer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storage  </span><span style=\"color:#B392F0\">Backend</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    testData </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateEnvelopeEncryption verifies that secrets are properly encrypted at rest.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Milestone1Validator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateEnvelopeEncryption</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    testSecret </span><span style=\"color:#F97583\">:=</span><span style=\"color:#9ECBFF\"> \"super-secret-password\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Store a secret through the API</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Examine the storage backend directly for the encrypted data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify that plaintext secret does not appear in storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify that encrypted data includes proper authentication tags</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Attempt to decrypt with wrong key and verify it fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected behavior: No plaintext visible in storage, proper encryption metadata</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateKeyRotation tests key rotation without affecting secret accessibility.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Milestone1Validator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateKeyRotation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create several test secrets</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Trigger key rotation operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify all existing secrets remain accessible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create new secret and verify it uses new key version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify that both old and new key versions work correctly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected behavior: Zero downtime rotation with version compatibility</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Milestone2Validator validates authentication and authorization functionality.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Milestone2Validator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecretServer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    testPolicies </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Policy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    testTokens   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateAccessControl tests policy enforcement and authentication.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Milestone2Validator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateAccessControl</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create test policies with different path permissions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create test tokens with different policy assignments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Attempt to access secrets with each token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify that access is granted/denied according to policies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Test edge cases like path traversal attempts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected behavior: Only authorized requests succeed, proper audit logging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LoadTestValidator provides performance and load testing validation.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LoadTestValidator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    baseURL     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    concurrency </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    duration    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidatePerformance executes load test and validates performance characteristics.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LoadTestValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidatePerformance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create multiple goroutines to simulate concurrent clients</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Execute secret read/write operations for specified duration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Measure latency percentiles (p50, p95, p99)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Track error rates and timeout conditions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify that performance meets acceptance criteria</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected behavior: &#x3C;100ms p99 latency, &#x3C;1% error rate under normal load</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Integration Testing Framework:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package integration provides end-to-end testing capabilities.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> integration</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/testcontainers/testcontainers-go</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/testcontainers/testcontainers-go/wait</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TestEnvironment manages the complete testing environment including dependencies.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TestEnvironment</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VaultContainer </span><span style=\"color:#B392F0\">testcontainers</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DBContainer    </span><span style=\"color:#B392F0\">testcontainers</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VaultURL       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DBURL          </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AdminToken     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetupIntegrationTest creates a complete test environment with all dependencies.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SetupIntegrationTest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestEnvironment</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Start PostgreSQL container for database backend testing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Start secret management server container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Wait for both services to be ready (health checks)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Initialize server with test configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Create admin token for test operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return configured test environment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use testcontainers to manage Docker containers for integration tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TestCompleteWorkflow validates end-to-end secret management operations.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestCompleteWorkflow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    env </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SetupIntegrationTest</span><span style=\"color:#E1E4E8\">(t)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> env.</span><span style=\"color:#B392F0\">Cleanup</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Authenticate with admin token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create policies for different access levels</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create application tokens with specific policies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Store static secrets using application token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Configure dynamic secret backend (database)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Generate dynamic credentials</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Use dynamic credentials to connect to database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Verify credential cleanup after lease expiration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected behavior: Complete workflow succeeds without errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TestFailoverScenario validates high availability and disaster recovery.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestFailoverScenario</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    env </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> SetupClusterEnvironment</span><span style=\"color:#E1E4E8\">(t) </span><span style=\"color:#6A737D\">// 3-node cluster</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> env.</span><span style=\"color:#B392F0\">Cleanup</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Store secrets on primary node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Kill primary node container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify that backup node becomes leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify that secrets remain accessible through new leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Restart failed node and verify it rejoins cluster</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected behavior: Transparent failover with minimal downtime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Debugging and Troubleshooting Guide:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Test Failure Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Steps</th>\n<th>Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Crypto tests fail with &quot;invalid authentication tag&quot;</td>\n<td>Wrong key used for decryption or corrupted ciphertext</td>\n<td>Check key versioning logic, verify nonce uniqueness</td>\n<td>Fix key lookup or nonce generation</td>\n</tr>\n<tr>\n<td>Timing tests show significant differences</td>\n<td>Non-constant-time comparison in token validation</td>\n<td>Profile token validation code, check for early returns</td>\n<td>Use <code>subtle.ConstantTimeCompare</code> for all secret comparisons</td>\n</tr>\n<tr>\n<td>Integration tests timeout</td>\n<td>Service not ready or network connectivity issues</td>\n<td>Check container logs, verify port binding</td>\n<td>Fix service startup or network configuration</td>\n</tr>\n<tr>\n<td>Load tests show degraded performance</td>\n<td>Resource exhaustion or inefficient algorithms</td>\n<td>Monitor CPU/memory usage, profile hot code paths</td>\n<td>Optimize algorithms or increase resource limits</td>\n</tr>\n<tr>\n<td>Dynamic secret tests fail</td>\n<td>Backend service not configured or credentials invalid</td>\n<td>Check backend service logs, verify connection strings</td>\n<td>Fix backend configuration or credentials</td>\n</tr>\n</tbody></table>\n<p>The comprehensive testing strategy ensures that our secret management system maintains security and reliability guarantees across all operational scenarios. The combination of security-focused testing, milestone validation, and integration testing provides confidence that the system will protect secrets effectively in production environments.</p>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section applies to all four milestones, providing diagnostic techniques and troubleshooting procedures essential for developing and maintaining a secret management system. Common implementation bugs span encrypted storage (Milestone 1), access control (Milestone 2), dynamic secrets (Milestone 3), and high availability (Milestone 4).</p>\n</blockquote>\n<p>Think of debugging a secret management system like diagnosing a security breach in a bank vault system. Just as bank security personnel have standardized procedures for investigating access failures, suspicious activities, and system malfunctions, secret management systems require systematic approaches to identify and resolve issues. The critical difference is that debugging must preserve security properties - you cannot simply &quot;dump all state&quot; to diagnose an issue if that would expose sensitive data.</p>\n<p>The challenge of debugging secret management systems lies in the intersection of security and observability. Traditional debugging techniques like memory dumps, detailed stack traces, and verbose logging can inadvertently expose the very secrets the system is designed to protect. This creates a unique constraint where diagnostic information must be comprehensive enough to identify problems but sanitized enough to maintain security boundaries.</p>\n<h3 id=\"common-implementation-bugs\">Common Implementation Bugs</h3>\n<p>Secret management systems exhibit predictable failure patterns due to the complexity of cryptographic operations, distributed consensus, and strict security requirements. Understanding these common bugs helps developers recognize symptoms quickly and apply targeted fixes rather than spending hours debugging cryptic failures.</p>\n<h4 id=\"encryption-and-key-management-bugs\">Encryption and Key Management Bugs</h4>\n<p>The most frequent bugs in secret management systems involve improper handling of cryptographic keys and encryption operations. These bugs are particularly dangerous because they often appear to work correctly during testing but fail catastrophically in production or compromise security without obvious symptoms.</p>\n<p>⚠️ <strong>Pitfall: Master Key in Memory Exposure</strong>\nDevelopers often leave the master key in memory after encryption operations or fail to zero memory after use. This creates a window where process memory dumps or swap files can expose the master key, compromising all encrypted secrets. The master key should be cleared from memory immediately after use and never stored in garbage-collected languages without explicit zeroing.</p>\n<table>\n<thead>\n<tr>\n<th>Bug Pattern</th>\n<th>Symptoms</th>\n<th>Root Cause</th>\n<th>Detection Method</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Uncleared master key</td>\n<td>No immediate symptoms; discovered during security audit</td>\n<td>Master key remains in process memory after operations</td>\n<td>Memory scanning tools; static analysis</td>\n<td>Implement <code>SecureMemory</code> zeroing; use defer statements</td>\n</tr>\n<tr>\n<td>Wrong key version</td>\n<td><code>DecryptSecret</code> fails with &quot;invalid key version&quot;</td>\n<td>Using incorrect <code>DataEncryptionKey</code> version for decryption</td>\n<td>Audit logs show version mismatches</td>\n<td>Verify <code>GetDEKForVersion</code> maps versions correctly</td>\n</tr>\n<tr>\n<td>Missing key rotation</td>\n<td>All new secrets fail encryption after rotation</td>\n<td>Old <code>DataEncryptionKey</code> marked inactive but no new key generated</td>\n<td>Check active DEK count in storage</td>\n<td>Implement proper <code>RotateDataEncryptionKey</code> workflow</td>\n</tr>\n<tr>\n<td>GCM nonce reuse</td>\n<td>Silent corruption; authentication failures</td>\n<td>Same nonce used with same key multiple times</td>\n<td>Cryptographic analysis; random nonce collisions</td>\n<td>Use counter-based nonces or larger random space</td>\n</tr>\n<tr>\n<td>Weak entropy source</td>\n<td>Predictable encryption keys</td>\n<td>Using <code>math/rand</code> instead of <code>crypto/rand</code></td>\n<td>Statistical analysis of generated keys</td>\n<td>Replace with cryptographically secure random source</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Improper Secret Versioning</strong>\nMany implementations fail to handle secret versioning correctly during key rotation. When <code>RotateDataEncryptionKey</code> is called, existing secrets must remain accessible with their original keys while new secrets use the updated key. Developers often assume all secrets use the current key, causing decryption failures for older versions.</p>\n<h4 id=\"authentication-and-authorization-bugs\">Authentication and Authorization Bugs</h4>\n<p>Authentication bugs in secret management systems often stem from improper token validation, timing vulnerabilities, or policy evaluation errors. These bugs are particularly critical because they can bypass the entire security model.</p>\n<p>⚠️ <strong>Pitfall: Timing Attack Vulnerabilities</strong>\nToken comparison operations that exit early on the first character mismatch create timing side-channels that allow attackers to brute-force valid tokens character by character. The <code>ValidateTokenConstantTime</code> function must compare the entire token regardless of where differences occur.</p>\n<table>\n<thead>\n<tr>\n<th>Bug Pattern</th>\n<th>Symptoms</th>\n<th>Root Cause</th>\n<th>Detection Method</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Variable-time comparison</td>\n<td>Successful token brute-force attacks</td>\n<td>Early exit in token comparison</td>\n<td>Timing analysis; statistical measurement</td>\n<td>Implement constant-time comparison</td>\n</tr>\n<tr>\n<td>Token cleanup failure</td>\n<td>Expired tokens still authenticate</td>\n<td>Token expiration not enforced</td>\n<td>Check token count growth over time</td>\n<td>Add background cleanup process</td>\n</tr>\n<tr>\n<td>Policy evaluation bypass</td>\n<td>Unauthorized access succeeds</td>\n<td>Incorrect path matching logic</td>\n<td>Audit failed access attempts</td>\n<td>Fix <code>matchesPath</code> wildcard handling</td>\n</tr>\n<tr>\n<td>Session fixation</td>\n<td>Single token works across different identities</td>\n<td>Token not bound to specific identity</td>\n<td>Cross-identity token usage detected</td>\n<td>Bind tokens to identity in creation</td>\n</tr>\n<tr>\n<td>Privilege escalation</td>\n<td>Users access restricted paths</td>\n<td>Policy inheritance bug</td>\n<td>Monitor policy evaluation results</td>\n<td>Review <code>AuthorizeRequest</code> logic</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Overpermissive Path Matching</strong>\nPath patterns like <code>secret/*</code> often match more than intended due to improper wildcard handling. Developers assume <code>*</code> matches only single path segments, but implementation bugs can cause it to match multiple segments, effectively granting broader access than intended.</p>\n<h4 id=\"dynamic-secret-lifecycle-bugs\">Dynamic Secret Lifecycle Bugs</h4>\n<p>Dynamic secret systems are particularly prone to bugs related to lease management, credential cleanup, and race conditions between generation and revocation processes.</p>\n<p>⚠️ <strong>Pitfall: Revocation Race Conditions</strong>\nWhen a lease expires, there&#39;s often a race condition between the lease reaper marking the lease as expired and the revocation worker actually cleaning up the credentials. During this window, the credentials may still be valid in the target system even though the vault considers them revoked.</p>\n<table>\n<thead>\n<tr>\n<th>Bug Pattern</th>\n<th>Symptoms</th>\n<th>Root Cause</th>\n<th>Detection Method</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Credential leak after expiry</td>\n<td>Database connections persist after lease expiry</td>\n<td>Revocation worker failing silently</td>\n<td>Monitor active connections vs issued leases</td>\n<td>Add revocation retry with alerts</td>\n</tr>\n<tr>\n<td>Lease reaper deadlock</td>\n<td>No leases ever expire; memory grows unbounded</td>\n<td>Lock ordering issue in lease processing</td>\n<td>Thread dumps; deadlock detection</td>\n<td>Consistent lock ordering; timeouts</td>\n</tr>\n<tr>\n<td>TTL calculation overflow</td>\n<td>Leases never expire or expire immediately</td>\n<td>Integer overflow in time calculations</td>\n<td>Check extreme TTL values</td>\n<td>Use time.Duration with bounds checking</td>\n</tr>\n<tr>\n<td>Backend connection exhaustion</td>\n<td>New credential generation fails</td>\n<td>Each request creates new database connection</td>\n<td>Monitor connection pool metrics</td>\n<td>Implement connection reuse</td>\n</tr>\n<tr>\n<td>Renewal window bug</td>\n<td>Clients cannot renew near-expiry leases</td>\n<td>Renewal rejected if remaining TTL too low</td>\n<td>Audit renewal rejection logs</td>\n<td>Adjust renewal time window logic</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Failed Revocation Handling</strong>\nMany implementations assume credential revocation always succeeds and fail to handle cases where the target system is unavailable or returns errors. Failed revocations should be retried with exponential backoff and eventually moved to a dead letter queue for manual intervention.</p>\n<h4 id=\"high-availability-and-consensus-bugs\">High Availability and Consensus Bugs</h4>\n<p>Distributed secret management systems introduce additional complexity around leader election, data replication, and split-brain prevention. These bugs often manifest as data inconsistencies or service unavailability.</p>\n<p>⚠️ <strong>Pitfall: Split-Brain Scenarios</strong>\nWhen network partitions occur, multiple nodes may believe they are the leader and accept write operations. This creates conflicting state that can be difficult to reconcile and may compromise security if different nodes grant different access to the same secrets.</p>\n<table>\n<thead>\n<tr>\n<th>Bug Pattern</th>\n<th>Symptoms</th>\n<th>Root Cause</th>\n<th>Detection Method</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Multiple active leaders</td>\n<td>Conflicting secret versions</td>\n<td>Network partition with inadequate quorum</td>\n<td>Monitor leadership claims across nodes</td>\n<td>Implement strict quorum requirements</td>\n</tr>\n<tr>\n<td>Sealed state bypass</td>\n<td>Operations succeed on sealed vault</td>\n<td>Seal state not checked consistently</td>\n<td>Audit operations on sealed nodes</td>\n<td>Add seal checks to all operations</td>\n</tr>\n<tr>\n<td>Share reconstruction failure</td>\n<td>Cannot unseal with valid shares</td>\n<td>Corrupted shares or incorrect reconstruction</td>\n<td>Verify share checksums</td>\n<td>Implement share validation</td>\n</tr>\n<tr>\n<td>Auto-unseal infinite loop</td>\n<td>Repeated unseal attempts without success</td>\n<td>KMS provider returning inconsistent results</td>\n<td>Monitor unseal attempt frequency</td>\n<td>Add circuit breaker pattern</td>\n</tr>\n<tr>\n<td>Consensus timeout issues</td>\n<td>Operations hang during cluster changes</td>\n<td>Raft timeouts too aggressive for network</td>\n<td>Monitor consensus operation latency</td>\n<td>Tune timeout values for environment</td>\n</tr>\n</tbody></table>\n<h3 id=\"diagnostic-techniques\">Diagnostic Techniques</h3>\n<p>Effective debugging of secret management systems requires specialized techniques that maintain security boundaries while providing sufficient observability. Traditional debugging approaches must be adapted to avoid exposing sensitive data while still providing actionable information.</p>\n<h4 id=\"structured-logging-and-audit-trails\">Structured Logging and Audit Trails</h4>\n<p>The foundation of secret management debugging is comprehensive audit logging that captures security-relevant events without exposing secret values. Every operation should generate audit events that can be analyzed to reconstruct the sequence of events leading to a problem.</p>\n<p><strong>Audit Event Analysis</strong> provides the primary diagnostic capability for secret management systems. The <code>AuditLogger</code> captures detailed information about every request, including authentication attempts, policy evaluations, and secret access patterns. Unlike traditional application logs, audit logs must be tamper-evident and cannot be disabled even during debugging.</p>\n<table>\n<thead>\n<tr>\n<th>Event Type</th>\n<th>Required Fields</th>\n<th>Diagnostic Value</th>\n<th>Privacy Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Authentication</td>\n<td><code>Identity</code>, <code>AuthMethod</code>, <code>SourceIP</code>, <code>Result</code></td>\n<td>Identify failed login patterns</td>\n<td>Hash sensitive identifiers</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td><code>Path</code>, <code>Operation</code>, <code>Policies</code>, <code>Result</code></td>\n<td>Debug policy evaluation failures</td>\n<td>Log pattern matches not actual paths</td>\n</tr>\n<tr>\n<td>Secret Access</td>\n<td><code>Path</code>, <code>Version</code>, <code>Operation</code>, <code>Result</code></td>\n<td>Track secret usage patterns</td>\n<td>Never log secret values</td>\n</tr>\n<tr>\n<td>Dynamic Secret Generation</td>\n<td><code>BackendPath</code>, <code>RoleName</code>, <code>TTL</code>, <code>LeaseID</code></td>\n<td>Debug credential lifecycle issues</td>\n<td>Log metadata not credentials</td>\n</tr>\n<tr>\n<td>System Events</td>\n<td><code>EventType</code>, <code>NodeID</code>, <code>Duration</code>, <code>Result</code></td>\n<td>Monitor system health</td>\n<td>Include performance metrics</td>\n</tr>\n</tbody></table>\n<p>The key insight for audit-based debugging is that security events form patterns that reveal the root cause without exposing sensitive data. For example, a series of authorization failures for the same path pattern might indicate a policy misconfiguration, while authentication failures followed by successful access suggest credential compromise.</p>\n<p><strong>Correlation Analysis</strong> across audit events helps identify complex issues that span multiple system components. The <code>RequestID</code> field allows tracing a single request through authentication, authorization, encryption, and storage operations. Time-based correlation can identify patterns like credential stuffing attacks or systematic enumeration attempts.</p>\n<h4 id=\"cryptographic-verification-and-validation\">Cryptographic Verification and Validation</h4>\n<p>Secret management systems require specialized diagnostic techniques for verifying cryptographic operations without exposing key material. These techniques focus on validating algorithm properties and detecting implementation errors.</p>\n<p><strong>Test Vector Validation</strong> uses known plaintext/ciphertext pairs to verify that encryption implementations produce expected results. The <code>CryptoTestVector</code> structure captures test cases from cryptographic standards that can be used to validate envelope encryption operations.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Test Vector Validation Process:\n1. Load standardized test vectors for AES-256-GCM operations\n2. Execute EncryptSecret with known plaintext and test vector key\n3. Compare produced ciphertext with expected test vector output\n4. Verify authentication tag matches expected value\n5. Test DecryptSecret with test vector ciphertext produces original plaintext\n6. Validate that modified ciphertext fails authentication</code></pre></div>\n\n<p><strong>Key Hierarchy Verification</strong> ensures that the envelope encryption key derivation process maintains security properties. This involves verifying that data encryption keys are properly derived from the master key and that key versions are tracked correctly.</p>\n<table>\n<thead>\n<tr>\n<th>Verification Check</th>\n<th>Method</th>\n<th>Expected Result</th>\n<th>Failure Indication</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DEK Uniqueness</td>\n<td>Generate multiple DEKs; compare</td>\n<td>All different</td>\n<td>Weak entropy or reused nonces</td>\n</tr>\n<tr>\n<td>Master Key Derivation</td>\n<td>Derive same key with same parameters</td>\n<td>Identical results</td>\n<td>Implementation inconsistency</td>\n</tr>\n<tr>\n<td>Key Version Monotonicity</td>\n<td>Check version sequence in storage</td>\n<td>Strictly increasing</td>\n<td>Version management bug</td>\n</tr>\n<tr>\n<td>Encryption Determinism</td>\n<td>Encrypt same data twice with different DEKs</td>\n<td>Different ciphertexts</td>\n<td>Proper randomization</td>\n</tr>\n<tr>\n<td>Authentication Integrity</td>\n<td>Modify ciphertext; attempt decryption</td>\n<td>Decryption failure</td>\n<td>Authentication working</td>\n</tr>\n</tbody></table>\n<h4 id=\"performance-and-resource-monitoring\">Performance and Resource Monitoring</h4>\n<p>Secret management systems exhibit specific performance characteristics that can indicate both functional and security issues. Monitoring these patterns helps identify problems before they impact service availability.</p>\n<p><strong>Operation Latency Analysis</strong> reveals performance bottlenecks and potential security issues. For example, unusually long authentication times might indicate brute-force attempts, while encryption operations taking variable time could suggest timing side-channels.</p>\n<p><strong>Resource Utilization Patterns</strong> help identify memory leaks, connection exhaustion, and other resource-related issues that are common in secret management systems due to the complexity of credential lifecycle management.</p>\n<table>\n<thead>\n<tr>\n<th>Metric</th>\n<th>Normal Range</th>\n<th>Warning Threshold</th>\n<th>Critical Issues</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Authentication Latency</td>\n<td>10-50ms</td>\n<td>&gt;100ms</td>\n<td>Timing attacks; database issues</td>\n</tr>\n<tr>\n<td>Encryption Operations/sec</td>\n<td>100-1000</td>\n<td>&lt;10</td>\n<td>Key management problems</td>\n</tr>\n<tr>\n<td>Active Lease Count</td>\n<td>Proportional to load</td>\n<td>Unbounded growth</td>\n<td>Revocation failures</td>\n</tr>\n<tr>\n<td>Memory Usage</td>\n<td>Stable with spikes</td>\n<td>Continuous growth</td>\n<td>Key material leaks</td>\n</tr>\n<tr>\n<td>Database Connections</td>\n<td>&lt;connection pool size</td>\n<td>Pool exhausted</td>\n<td>Dynamic secret backend issues</td>\n</tr>\n</tbody></table>\n<h3 id=\"symptom-cause-fix-reference\">Symptom-Cause-Fix Reference</h3>\n<p>This reference provides quick diagnosis for common symptoms observed in secret management systems. Each entry follows the pattern of observable symptom, most likely root cause, diagnostic steps, and recommended fix.</p>\n<h4 id=\"authentication-and-access-issues\">Authentication and Access Issues</h4>\n<p><strong>Symptom: &quot;Access denied&quot; for valid users with correct tokens</strong></p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Most Likely Cause</strong></td>\n<td>Policy path matching failure or token expiration</td>\n</tr>\n<tr>\n<td><strong>Diagnostic Steps</strong></td>\n<td>1. Check audit logs for authorization events 2. Verify token validity with <code>GetToken</code> 3. Test path pattern matching manually 4. Confirm policy assignment to token</td>\n</tr>\n<tr>\n<td><strong>Quick Fix</strong></td>\n<td>Update policy rules to include correct path patterns</td>\n</tr>\n<tr>\n<td><strong>Long-term Fix</strong></td>\n<td>Implement policy testing framework and path validation</td>\n</tr>\n</tbody></table>\n<p><strong>Symptom: Authentication succeeds but operations immediately fail</strong></p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Most Likely Cause</strong></td>\n<td>Vault is in sealed state or cluster leadership issues</td>\n</tr>\n<tr>\n<td><strong>Diagnostic Steps</strong></td>\n<td>1. Check <code>IsSealed()</code> status 2. Verify cluster leader election 3. Review unseal process logs 4. Test with administrative token</td>\n</tr>\n<tr>\n<td><strong>Quick Fix</strong></td>\n<td>Unseal vault with sufficient shares or resolve leadership</td>\n</tr>\n<tr>\n<td><strong>Long-term Fix</strong></td>\n<td>Implement auto-unseal and monitoring for seal state</td>\n</tr>\n</tbody></table>\n<h4 id=\"encryption-and-storage-failures\">Encryption and Storage Failures</h4>\n<p><strong>Symptom: &quot;Encryption failed&quot; errors for new secret creation</strong></p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Most Likely Cause</strong></td>\n<td>No active data encryption key or master key issues</td>\n</tr>\n<tr>\n<td><strong>Diagnostic Steps</strong></td>\n<td>1. Check active DEK count in storage 2. Verify master key accessibility 3. Test key generation manually 4. Review encryption engine logs</td>\n</tr>\n<tr>\n<td><strong>Quick Fix</strong></td>\n<td>Generate new DEK with <code>GenerateDataEncryptionKey</code></td>\n</tr>\n<tr>\n<td><strong>Long-term Fix</strong></td>\n<td>Implement automatic key rotation and monitoring</td>\n</tr>\n</tbody></table>\n<p><strong>Symptom: Existing secrets become unreadable after system restart</strong></p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Most Likely Cause</strong></td>\n<td>Master key lost or DEK version mapping corrupted</td>\n</tr>\n<tr>\n<td><strong>Diagnostic Steps</strong></td>\n<td>1. Verify master key reconstruction from shares 2. Check DEK version consistency 3. Test decryption with known good secret 4. Review backup integrity</td>\n</tr>\n<tr>\n<td><strong>Quick Fix</strong></td>\n<td>Restore master key from backup or re-unseal properly</td>\n</tr>\n<tr>\n<td><strong>Long-term Fix</strong></td>\n<td>Implement master key backup verification and DEK integrity checks</td>\n</tr>\n</tbody></table>\n<h4 id=\"dynamic-secret-lifecycle-problems\">Dynamic Secret Lifecycle Problems</h4>\n<p><strong>Symptom: Generated credentials don&#39;t work in target system</strong></p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Most Likely Cause</strong></td>\n<td>Backend role configuration error or credential template issue</td>\n</tr>\n<tr>\n<td><strong>Diagnostic Steps</strong></td>\n<td>1. Test credential generation manually 2. Verify backend connectivity 3. Check role creation statements 4. Validate credential format</td>\n</tr>\n<tr>\n<td><strong>Quick Fix</strong></td>\n<td>Update role configuration with correct statements</td>\n</tr>\n<tr>\n<td><strong>Long-term Fix</strong></td>\n<td>Implement backend connection testing and credential validation</td>\n</tr>\n</tbody></table>\n<p><strong>Symptom: Credentials work but never get revoked after expiry</strong></p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Most Likely Cause</strong></td>\n<td>Revocation worker failure or backend connection issues</td>\n</tr>\n<tr>\n<td><strong>Diagnostic Steps</strong></td>\n<td>1. Check revocation queue size 2. Verify backend connectivity 3. Review revocation worker logs 4. Test manual revocation</td>\n</tr>\n<tr>\n<td><strong>Quick Fix</strong></td>\n<td>Restart revocation workers and clear queue backlog</td>\n</tr>\n<tr>\n<td><strong>Long-term Fix</strong></td>\n<td>Implement revocation monitoring and retry mechanisms</td>\n</tr>\n</tbody></table>\n<h4 id=\"high-availability-and-cluster-issues\">High Availability and Cluster Issues</h4>\n<p><strong>Symptom: Operations succeed on one node but fail on others</strong></p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Most Likely Cause</strong></td>\n<td>Split-brain condition or replication lag</td>\n</tr>\n<tr>\n<td><strong>Diagnostic Steps</strong></td>\n<td>1. Check leadership status on all nodes 2. Verify Raft log consistency 3. Monitor replication lag 4. Test quorum requirements</td>\n</tr>\n<tr>\n<td><strong>Quick Fix</strong></td>\n<td>Force leader re-election and wait for convergence</td>\n</tr>\n<tr>\n<td><strong>Long-term Fix</strong></td>\n<td>Tune consensus timeouts and improve network reliability</td>\n</tr>\n</tbody></table>\n<p><strong>Symptom: Cannot unseal vault despite providing correct shares</strong></p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Most Likely Cause</strong></td>\n<td>Share corruption, wrong threshold, or reconstruction bug</td>\n</tr>\n<tr>\n<td><strong>Diagnostic Steps</strong></td>\n<td>1. Verify share checksums 2. Check threshold configuration 3. Test Shamir reconstruction manually 4. Review share generation logs</td>\n</tr>\n<tr>\n<td><strong>Quick Fix</strong></td>\n<td>Regenerate shares from master key backup</td>\n</tr>\n<tr>\n<td><strong>Long-term Fix</strong></td>\n<td>Implement share validation and backup verification</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The debugging infrastructure for a secret management system requires careful implementation to maintain security while providing comprehensive diagnostic capabilities. This guidance provides the essential components for building effective debugging tools.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Logging</td>\n<td>Standard log/slog with file rotation</td>\n<td>Structured logging with ELK stack</td>\n</tr>\n<tr>\n<td>Metrics</td>\n<td>Basic Prometheus metrics</td>\n<td>Full observability with Grafana</td>\n</tr>\n<tr>\n<td>Tracing</td>\n<td>HTTP request IDs</td>\n<td>Distributed tracing with Jaeger</td>\n</tr>\n<tr>\n<td>Health Checks</td>\n<td>Simple HTTP endpoints</td>\n<td>Comprehensive health monitoring</td>\n</tr>\n<tr>\n<td>Debugging Tools</td>\n<td>Built-in diagnostic commands</td>\n<td>Remote debugging with security boundaries</td>\n</tr>\n</tbody></table>\n<h4 id=\"file-structure\">File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>cmd/\n  vault-debug/              ← Debugging CLI tool\n    main.go\ninternal/\n  debug/                    ← Debugging infrastructure\n    audit.go                ← Audit log analysis\n    crypto.go               ← Cryptographic verification\n    health.go               ← System health monitoring\n    profiling.go            ← Performance analysis\n  monitoring/               ← Metrics and observability\n    metrics.go              ← Prometheus metrics\n    health.go               ← Health check endpoints\n  logging/                  ← Structured logging\n    audit.go                ← Audit logger implementation\n    sanitizer.go            ← Log sanitization</code></pre></div>\n\n<h4 id=\"audit-logger-implementation\">Audit Logger Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// NewAuditLogger creates tamper-evident audit logging with structured output</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewAuditLogger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">filename</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuditLogger</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Open log file with append mode and appropriate permissions (0600)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize sequence number from last log entry + 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Write startup marker with timestamp and process ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Set up log rotation based on size and retention policy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Initialize mutex for thread-safe concurrent logging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use O_APPEND|O_CREATE|O_WRONLY flags for file opening</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LogEvent writes audit event to tamper-evident log with security sanitization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">a </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuditLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">LogEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">event</span><span style=\"color:#B392F0\"> AuditEvent</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire mutex lock for thread-safe operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Increment and assign sequence number to event</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Sanitize event data to remove sensitive information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Marshal event to JSON with timestamp and checksum</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Write to file with immediate flush to ensure durability</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Release mutex lock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Never log actual secret values, only metadata and result status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"cryptographic-test-vector-validation\">Cryptographic Test Vector Validation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// LoadKnownVectors loads standardized test vectors for encryption validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> LoadKnownVectors</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">algorithm</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">CryptoTestVector</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read test vectors from embedded resources or external file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Parse vectors based on algorithm type (AES-GCM, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate vector format and required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return structured test cases for validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RunCryptographicValidation verifies encryption implementation against known vectors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> RunCryptographicValidation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">engine</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">vectors</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">CryptoTestVector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, vector </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> vectors {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Create test DEK with vector key material</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Encrypt vector plaintext using engine</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Compare result with expected ciphertext</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Decrypt ciphertext and verify original plaintext</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Test authentication by modifying ciphertext and expecting failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Hint: Use constant-time comparison for cryptographic results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"performance-monitoring-and-health-checks\">Performance Monitoring and Health Checks</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// SystemHealth provides comprehensive health monitoring for all vault components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SystemHealth</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    checks       </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">HealthCheck</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastResults  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">ComponentStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex        </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    checkInterval </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterCheck adds component health monitoring with automatic status tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SystemHealth</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterCheck</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">check</span><span style=\"color:#B392F0\"> HealthCheck</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Add check to registry with unique name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize last result status as unknown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Start background goroutine for periodic checking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Set up alerting thresholds for status changes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetOverallStatus aggregates individual component status into system-wide health</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SystemHealth</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetOverallStatus</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">ComponentStatus</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire read lock for thread-safe access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Iterate through all component statuses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Apply aggregation rules (any unhealthy = system unhealthy)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return overall status with degradation level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Critical components (storage, encryption) have higher weight</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"diagnostic-command-line-tools\">Diagnostic Command-Line Tools</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// VaultDebugTool provides safe diagnostic capabilities for production systems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse command-line arguments for diagnostic operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Connect to vault instance using administrative credentials</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Execute requested diagnostic with security boundaries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Output sanitized results without exposing sensitive data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Available commands: health, audit-analysis, key-status, lease-summary</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AnalyzeAuditLogs provides security-focused analysis of vault audit trails</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> AnalyzeAuditLogs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">logPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">timeRange</span><span style=\"color:#B392F0\"> TimeRange</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AnalysisReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read audit log entries within specified time range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Parse and validate log entry integrity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Identify patterns indicating security issues</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Generate report with actionable recommendations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Flag potential security incidents for investigation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Look for authentication failures, unusual access patterns, policy violations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After Milestone 1 (Encryption Engine):</strong></p>\n<ul>\n<li>Run <code>go test ./internal/debug/crypto.go</code> to verify cryptographic test vectors pass</li>\n<li>Execute <code>vault-debug key-status</code> to confirm DEK rotation works correctly</li>\n<li>Check audit logs contain encryption operation events without secret values</li>\n</ul>\n<p><strong>After Milestone 2 (Authentication):</strong></p>\n<ul>\n<li>Test <code>vault-debug auth-analysis</code> to identify authentication patterns</li>\n<li>Verify constant-time token comparison with timing analysis tools</li>\n<li>Confirm policy evaluation audit events capture authorization decisions</li>\n</ul>\n<p><strong>After Milestone 3 (Dynamic Secrets):</strong></p>\n<ul>\n<li>Monitor lease metrics to ensure revocation processes work correctly</li>\n<li>Use <code>vault-debug lease-summary</code> to verify lease lifecycle tracking</li>\n<li>Test credential cleanup with backend connectivity failures</li>\n</ul>\n<p><strong>After Milestone 4 (High Availability):</strong></p>\n<ul>\n<li>Validate cluster health monitoring across all nodes</li>\n<li>Test split-brain detection and prevention mechanisms</li>\n<li>Verify auto-unseal monitoring and failure alerting works correctly</li>\n</ul>\n<h4 id=\"common-debugging-scenarios\">Common Debugging Scenarios</h4>\n<p><strong>Scenario: Memory Usage Growing Unboundedly</strong></p>\n<ol>\n<li>Use <code>pprof</code> to capture heap profiles during operation</li>\n<li>Check for unreleased cryptographic key material in memory</li>\n<li>Verify lease cleanup processes are running correctly</li>\n<li>Look for goroutine leaks in background workers</li>\n</ol>\n<p><strong>Scenario: Authentication Latency Spikes</strong></p>\n<ol>\n<li>Enable detailed timing logs for authentication operations</li>\n<li>Check database connection pool utilization</li>\n<li>Monitor for brute-force attack patterns in audit logs</li>\n<li>Verify constant-time operations aren&#39;t introducing delays</li>\n</ol>\n<p><strong>Scenario: Cluster Consensus Failures</strong></p>\n<ol>\n<li>Check network connectivity between cluster nodes</li>\n<li>Verify Raft log consistency across all nodes</li>\n<li>Monitor leadership election frequency and causes</li>\n<li>Test quorum requirements under various failure scenarios</li>\n</ol>\n<p>The debugging infrastructure must balance comprehensive observability with strict security requirements, ensuring that diagnostic capabilities never compromise the secrets they&#39;re designed to protect.</p>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section applies to the completed system after all four milestones, providing guidance for scaling and extending the secret management system beyond the core implementation.</p>\n</blockquote>\n<p>Building a secret management system is like constructing a skyscraper foundation — the initial structure must be robust enough to support future expansion, but you can&#39;t anticipate every possible addition. After implementing the core secret management capabilities across all four milestones, organizations typically discover new requirements that push the system&#39;s boundaries. This section explores strategic extensions that maintain the security model while addressing enterprise scalability, operational complexity, and evolving infrastructure needs.</p>\n<p>The extensions fall into three categories that address different growth pressures. <strong>Scalability improvements</strong> handle increased load and geographic distribution. <strong>Additional secret backends</strong> support new infrastructure components and security requirements. <strong>Enterprise features</strong> address organizational complexity with multi-tenancy, compliance reporting, and sophisticated authentication methods. Each extension builds on the solid foundation established in the core milestones while introducing new architectural challenges.</p>\n<h3 id=\"scalability-improvements\">Scalability Improvements</h3>\n<p>Think of scaling a secret management system like expanding a secure bank vault operation from a single location to a global network. The core security principles remain unchanged, but you need new mechanisms for coordination, caching, and performance optimization. Unlike typical web applications where eventual consistency is acceptable, secret management requires strong consistency for security policies while optimizing for read-heavy workloads.</p>\n<h4 id=\"horizontal-scaling-architecture\">Horizontal Scaling Architecture</h4>\n<p>The current system uses a single-leader Raft cluster that handles both reads and writes on the leader node. This creates a performance bottleneck as organizations grow to thousands of applications requesting secrets. <strong>Read replicas</strong> provide the first scaling improvement by allowing read operations against follower nodes while maintaining consistency guarantees.</p>\n<blockquote>\n<p><strong>Decision: Read-Only Replica Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: The Raft leader becomes overwhelmed by read requests while writes remain low volume</li>\n<li><strong>Options Considered</strong>: Read replicas, read-through caching, client-side caching</li>\n<li><strong>Decision</strong>: Implement read replicas with linearizable read guarantees</li>\n<li><strong>Rationale</strong>: Maintains strong consistency while distributing read load across multiple nodes</li>\n<li><strong>Consequences</strong>: Enables horizontal read scaling but requires careful lease token validation</li>\n</ul>\n</blockquote>\n<p>Read replicas must handle several consistency challenges that don&#39;t exist in typical databases. <strong>Token validation</strong> requires checking that tokens haven&#39;t been revoked, which means replicas need up-to-date token state. <strong>Policy evaluation</strong> must use current policies, not stale versions that might grant excessive access. The solution involves a <strong>token validation cache</strong> with short TTLs and a <strong>policy version vector</strong> that tracks policy updates across replicas.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Purpose</th>\n<th>Consistency Model</th>\n<th>Cache TTL</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Token Validation Cache</td>\n<td>Verify token existence and expiration</td>\n<td>Eventually consistent with invalidation</td>\n<td>30 seconds</td>\n</tr>\n<tr>\n<td>Policy Version Vector</td>\n<td>Track policy updates across replicas</td>\n<td>Strongly consistent</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>Secret Content Cache</td>\n<td>Cache encrypted secret data</td>\n<td>Read-your-writes consistent</td>\n<td>5 minutes</td>\n</tr>\n<tr>\n<td>Lease Index Cache</td>\n<td>Track active leases for validation</td>\n<td>Eventually consistent</td>\n<td>1 minute</td>\n</tr>\n</tbody></table>\n<h4 id=\"geographic-distribution\">Geographic Distribution</h4>\n<p>Organizations with global infrastructure need secret management systems that provide low latency across regions while maintaining security guarantees. <strong>Regional clusters</strong> create independent Raft clusters in each geographic region, connected through <strong>cross-region replication</strong> for disaster recovery and policy synchronization.</p>\n<p>The challenge is determining what data requires global consistency versus regional autonomy. <strong>Security policies</strong> must be globally consistent to prevent privilege escalation through region-shopping. <strong>Audit logs</strong> require global aggregation for compliance reporting. However, <strong>secret content</strong> can be region-specific, and <strong>dynamic secrets</strong> can be generated locally to minimize latency.</p>\n<table>\n<thead>\n<tr>\n<th>Data Type</th>\n<th>Replication Strategy</th>\n<th>Consistency Level</th>\n<th>Cross-Region Sync</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Security Policies</td>\n<td>Synchronous multi-region</td>\n<td>Strong consistency</td>\n<td>Real-time</td>\n</tr>\n<tr>\n<td>Master Keys</td>\n<td>Manual key ceremony</td>\n<td>No replication</td>\n<td>Offline process</td>\n</tr>\n<tr>\n<td>Secret Content</td>\n<td>Regional with backup</td>\n<td>Regional consistency</td>\n<td>Encrypted backup</td>\n</tr>\n<tr>\n<td>Audit Logs</td>\n<td>Asynchronous aggregation</td>\n<td>Eventually consistent</td>\n<td>Batched</td>\n</tr>\n<tr>\n<td>Dynamic Leases</td>\n<td>Regional generation</td>\n<td>Regional consistency</td>\n<td>Metadata only</td>\n</tr>\n</tbody></table>\n<p><strong>Cross-region authentication</strong> requires special handling because tokens issued in one region must be validated globally. The solution involves <strong>token attestation</strong> where each region cryptographically signs token metadata, allowing other regions to validate tokens without direct communication.</p>\n<h4 id=\"performance-optimization\">Performance Optimization</h4>\n<p>As secret request volume grows, several optimization techniques become necessary. <strong>Connection pooling</strong> reduces the overhead of TLS handshakes for client connections. <strong>Bulk operations</strong> allow applications to request multiple secrets in a single API call. <strong>Compression</strong> reduces network overhead for large policy documents and audit logs.</p>\n<p>The most impactful optimization is <strong>intelligent caching</strong> at multiple layers. <strong>Client-side caching</strong> with short TTLs reduces server load while maintaining security. <strong>Server-side caching</strong> optimizes expensive operations like policy evaluation and encryption key retrieval. <strong>Negative caching</strong> prevents repeated requests for non-existent secrets.</p>\n<blockquote>\n<p><strong>Critical Insight</strong>: Unlike web application caching, secret management caching must be <strong>security-first</strong>. A cache miss is preferable to serving stale data that might grant unauthorized access. All caches must include cryptographic checksums and expiration enforcement.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Cache Layer</th>\n<th>Cache Duration</th>\n<th>Security Control</th>\n<th>Invalidation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Client Secret Cache</td>\n<td>5 minutes</td>\n<td>Client-enforced TTL</td>\n<td>TTL expiration only</td>\n</tr>\n<tr>\n<td>Client Policy Cache</td>\n<td>1 minute</td>\n<td>Checksum validation</td>\n<td>Server push invalidation</td>\n</tr>\n<tr>\n<td>Server Query Cache</td>\n<td>30 seconds</td>\n<td>Encrypted cache keys</td>\n<td>Write-through invalidation</td>\n</tr>\n<tr>\n<td>Encryption Key Cache</td>\n<td>1 hour</td>\n<td>Hardware security module</td>\n<td>Key rotation invalidation</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Cache Coherence Attacks</strong>\nAttackers may attempt to exploit cache inconsistencies to access secrets using revoked tokens. Always validate tokens against authoritative sources for write operations, even if caches indicate the token is valid. Implement cache invalidation patterns that err on the side of denying access.</p>\n<h3 id=\"additional-secret-backends\">Additional Secret Backends</h3>\n<p>The dynamic secret engine provides extensibility for new credential types beyond the basic database backend implemented in Milestone 3. Think of secret backends like specialized vending machines — each one understands how to generate, manage, and revoke a specific type of credential while following the same lease-based lifecycle.</p>\n<h4 id=\"cloud-provider-integration\">Cloud Provider Integration</h4>\n<p>Modern applications increasingly rely on cloud services that require API credentials with fine-grained permissions. <strong>Cloud provider backends</strong> generate time-limited IAM credentials that applications can use to access cloud resources without storing long-lived access keys.</p>\n<p><strong>AWS IAM backend</strong> integration requires several components. The secret management system needs an <strong>IAM service account</strong> with permissions to create and delete temporary credentials. <strong>Role assumption</strong> allows generating credentials for specific AWS roles based on the requesting application&#39;s identity. <strong>Policy templates</strong> define the permissions granted to generated credentials.</p>\n<table>\n<thead>\n<tr>\n<th>AWS Backend Component</th>\n<th>Purpose</th>\n<th>Configuration</th>\n<th>Security Model</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Service Account</td>\n<td>Bootstrap credentials for AWS API</td>\n<td>Static long-lived key</td>\n<td>Rotated monthly</td>\n</tr>\n<tr>\n<td>Role Templates</td>\n<td>Define assumable roles per application</td>\n<td>JSON policy documents</td>\n<td>Version controlled</td>\n</tr>\n<tr>\n<td>Session Manager</td>\n<td>Track and revoke active sessions</td>\n<td>In-memory session cache</td>\n<td>Automatic cleanup</td>\n</tr>\n<tr>\n<td>Permission Mapper</td>\n<td>Map vault policies to AWS permissions</td>\n<td>Path-based mapping rules</td>\n<td>Least privilege</td>\n</tr>\n</tbody></table>\n<p>The <strong>Azure Active Directory backend</strong> follows similar patterns but uses <strong>service principal</strong> credentials and <strong>OAuth 2.0 flows</strong>. <strong>Google Cloud IAM backend</strong> uses <strong>service account key generation</strong> with <strong>workload identity federation</strong> for enhanced security.</p>\n<p>⚠️ <strong>Pitfall: Cloud Credential Sprawl</strong>\nWithout proper lifecycle management, cloud backends can create thousands of orphaned credentials that never get revoked. Implement aggressive cleanup policies and monitor cloud provider APIs for credential usage patterns.</p>\n<h4 id=\"pki-and-certificate-management\">PKI and Certificate Management</h4>\n<p>Applications increasingly require <strong>X.509 certificates</strong> for mutual TLS authentication, code signing, and service mesh communication. A <strong>PKI backend</strong> transforms the secret management system into a <strong>certificate authority</strong> that can issue, renew, and revoke certificates based on requesting application identity.</p>\n<p>The PKI backend requires careful <strong>root certificate management</strong>. The <strong>root CA private key</strong> must be stored separately from the secret management system, potentially in <strong>hardware security modules</strong>. <strong>Intermediate CA certificates</strong> can be stored within the system and used for day-to-day certificate issuance.</p>\n<table>\n<thead>\n<tr>\n<th>Certificate Type</th>\n<th>Issuing Authority</th>\n<th>Validity Period</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Service Certificates</td>\n<td>Intermediate CA</td>\n<td>24 hours</td>\n<td>Service-to-service mTLS</td>\n</tr>\n<tr>\n<td>Client Certificates</td>\n<td>Intermediate CA</td>\n<td>7 days</td>\n<td>Application authentication</td>\n</tr>\n<tr>\n<td>Code Signing</td>\n<td>Dedicated signing CA</td>\n<td>1 hour</td>\n<td>Container image signing</td>\n</tr>\n<tr>\n<td>Web Certificates</td>\n<td>Public CA integration</td>\n<td>90 days</td>\n<td>External web services</td>\n</tr>\n</tbody></table>\n<p><strong>Certificate revocation</strong> requires maintaining <strong>Certificate Revocation Lists (CRLs)</strong> or implementing <strong>Online Certificate Status Protocol (OCSP)</strong> responders. The revocation system must coordinate with the lease management system to ensure certificates are revoked when their associated leases expire.</p>\n<h4 id=\"ssh-certificate-authority\">SSH Certificate Authority</h4>\n<p><strong>SSH certificate authentication</strong> provides an alternative to managing SSH keys across large server fleets. The <strong>SSH CA backend</strong> generates <strong>user certificates</strong> and <strong>host certificates</strong> that are trusted by SSH servers without requiring key distribution.</p>\n<p><strong>User certificates</strong> contain the requesting user&#39;s identity and authorized commands. <strong>Host certificates</strong> prove server identity and prevent man-in-the-middle attacks. Both certificate types include <strong>principals</strong> that define what users or hosts the certificate represents.</p>\n<table>\n<thead>\n<tr>\n<th>SSH Certificate Component</th>\n<th>Purpose</th>\n<th>Source</th>\n<th>Validation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Certificate Public Key</td>\n<td>Identity being certified</td>\n<td>Generated per request</td>\n<td>Cryptographic signature</td>\n</tr>\n<tr>\n<td>Principals List</td>\n<td>Authorized identities</td>\n<td>Policy-driven mapping</td>\n<td>Path-based rules</td>\n</tr>\n<tr>\n<td>Critical Options</td>\n<td>Restrictions on usage</td>\n<td>Backend configuration</td>\n<td>Force-commands, source IP</td>\n</tr>\n<tr>\n<td>Extensions</td>\n<td>Additional permissions</td>\n<td>Default template</td>\n<td>Agent forwarding, X11</td>\n</tr>\n</tbody></table>\n<h3 id=\"enterprise-features\">Enterprise Features</h3>\n<p>Enterprise environments introduce organizational complexity that requires additional security and operational capabilities. Think of enterprise features like upgrading from a personal safe to a bank vault system — you need compartmentalization, audit trails, and administrative controls that weren&#39;t necessary for simpler use cases.</p>\n<h4 id=\"multi-tenancy-implementation\">Multi-Tenancy Implementation</h4>\n<p><strong>Multi-tenancy</strong> allows multiple organizations or business units to share the same secret management infrastructure while maintaining complete isolation. Each <strong>tenant</strong> operates as if they have a dedicated system, with separate encryption keys, policies, and audit logs.</p>\n<p>The <strong>tenant isolation model</strong> uses <strong>path-based segregation</strong> where each tenant&#39;s secrets exist under a unique path prefix. <strong>Encryption isolation</strong> ensures tenants use separate data encryption keys, preventing cross-tenant data access even if path-based isolation fails. <strong>Policy isolation</strong> prevents tenants from accessing each other&#39;s policies or creating policies that affect other tenants.</p>\n<table>\n<thead>\n<tr>\n<th>Isolation Layer</th>\n<th>Implementation</th>\n<th>Security Guarantee</th>\n<th>Failure Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Path Isolation</td>\n<td>URL prefix enforcement</td>\n<td>Prevents cross-tenant path access</td>\n<td>Single tenant affected</td>\n</tr>\n<tr>\n<td>Encryption Isolation</td>\n<td>Tenant-specific DEKs</td>\n<td>Cryptographic separation</td>\n<td>No cross-tenant data leakage</td>\n</tr>\n<tr>\n<td>Policy Isolation</td>\n<td>Tenant namespace scoping</td>\n<td>Administrative separation</td>\n<td>No privilege escalation</td>\n</tr>\n<tr>\n<td>Audit Isolation</td>\n<td>Separate log streams</td>\n<td>Compliance separation</td>\n<td>No information disclosure</td>\n</tr>\n</tbody></table>\n<p><strong>Tenant management</strong> requires administrative APIs for creating tenants, configuring tenant-specific policies, and managing tenant lifecycles. <strong>Tenant authentication</strong> can integrate with existing <strong>identity providers</strong> using <strong>SAML</strong> or <strong>OpenID Connect</strong> federation.</p>\n<blockquote>\n<p><strong>Decision: Tenant Isolation Model</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to support multiple organizations with different security requirements</li>\n<li><strong>Options Considered</strong>: Path-based isolation, separate clusters per tenant, virtualized instances</li>\n<li><strong>Decision</strong>: Combine path-based isolation with encryption key separation</li>\n<li><strong>Rationale</strong>: Provides strong security guarantees while maintaining operational efficiency</li>\n<li><strong>Consequences</strong>: Requires careful policy engine design to prevent tenant boundary violations</li>\n</ul>\n</blockquote>\n<h4 id=\"compliance-and-reporting\">Compliance and Reporting</h4>\n<p>Enterprise environments must demonstrate compliance with regulations like <strong>SOX</strong>, <strong>PCI DSS</strong>, <strong>HIPAA</strong>, and <strong>GDPR</strong>. <strong>Compliance reporting</strong> transforms raw audit logs into structured reports that demonstrate security controls and data handling practices.</p>\n<p><strong>Audit log enrichment</strong> adds contextual information to basic access logs. <strong>User identity resolution</strong> maps authentication tokens back to human users for accountability. <strong>Data classification</strong> tags secrets with sensitivity levels and tracks access patterns. <strong>Retention policies</strong> ensure audit logs are preserved for required periods while respecting data minimization requirements.</p>\n<table>\n<thead>\n<tr>\n<th>Compliance Requirement</th>\n<th>Implementation</th>\n<th>Data Collected</th>\n<th>Report Format</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Access Tracking</td>\n<td>Enhanced audit logs</td>\n<td>User, resource, time, result</td>\n<td>JSON with schema validation</td>\n</tr>\n<tr>\n<td>Data Retention</td>\n<td>Automated log archival</td>\n<td>All secret operations</td>\n<td>Tamper-evident storage</td>\n</tr>\n<tr>\n<td>Change Management</td>\n<td>Policy versioning</td>\n<td>All configuration changes</td>\n<td>Diff-based reports</td>\n</tr>\n<tr>\n<td>Incident Response</td>\n<td>Security event correlation</td>\n<td>Failed access patterns</td>\n<td>Real-time alerting</td>\n</tr>\n</tbody></table>\n<p><strong>Compliance dashboards</strong> provide real-time visibility into security posture. <strong>Anomaly detection</strong> identifies unusual access patterns that might indicate compromise. <strong>Automated reporting</strong> generates periodic compliance summaries without manual intervention.</p>\n<h4 id=\"advanced-authentication-methods\">Advanced Authentication Methods</h4>\n<p>Enterprise environments often require <strong>federation</strong> with existing identity systems and <strong>risk-based authentication</strong> that adapts security requirements based on request context. <strong>SAML integration</strong> allows using enterprise identity providers for authentication. <strong>OpenID Connect</strong> provides more modern federation capabilities with <strong>JSON Web Token</strong> based identity assertion.</p>\n<p><strong>Risk-based authentication</strong> evaluates request context to determine required authentication strength. <strong>Device fingerprinting</strong> tracks client characteristics to detect unusual access patterns. <strong>Geolocation analysis</strong> flags access attempts from unexpected locations. <strong>Behavioral analysis</strong> learns normal access patterns and detects deviations.</p>\n<table>\n<thead>\n<tr>\n<th>Authentication Factor</th>\n<th>Risk Level</th>\n<th>Additional Requirements</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>API Token</td>\n<td>Low</td>\n<td>None</td>\n<td>Automated applications</td>\n</tr>\n<tr>\n<td>mTLS Certificate</td>\n<td>Medium</td>\n<td>Certificate validation</td>\n<td>Service authentication</td>\n</tr>\n<tr>\n<td>SAML Assertion</td>\n<td>Medium</td>\n<td>Identity provider verification</td>\n<td>Human users</td>\n</tr>\n<tr>\n<td>MFA + Biometrics</td>\n<td>High</td>\n<td>Multi-factor verification</td>\n<td>Administrative access</td>\n</tr>\n</tbody></table>\n<p><strong>Adaptive policies</strong> adjust security requirements based on calculated risk scores. <strong>Step-up authentication</strong> prompts for additional verification when accessing high-value secrets. <strong>Session management</strong> tracks authentication sessions and enforces re-authentication for sensitive operations.</p>\n<p>⚠️ <strong>Pitfall: Authentication Bypass</strong>\nComplex authentication flows create opportunities for bypass attacks. Always validate that required authentication factors were actually verified, not just claimed. Implement defense in depth with multiple validation layers.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The scalability and enterprise features described in this section represent significant extensions to the core secret management system. Each extension should be approached incrementally, with careful attention to maintaining the security model established in the core milestones.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Read Replicas</td>\n<td>HTTP proxy with Raft follower reads</td>\n<td>Custom replication protocol with consistency guarantees</td>\n</tr>\n<tr>\n<td>Cross-Region Sync</td>\n<td>Database replication with encryption</td>\n<td>Custom consensus protocol with conflict resolution</td>\n</tr>\n<tr>\n<td>PKI Backend</td>\n<td>Go crypto/x509 with file-based CA</td>\n<td>Hardware Security Module integration</td>\n</tr>\n<tr>\n<td>Multi-Tenancy</td>\n<td>Path prefix enforcement</td>\n<td>Container-based isolation with separate processes</td>\n</tr>\n<tr>\n<td>Compliance Reporting</td>\n<td>Structured JSON logs with external analysis</td>\n<td>Real-time stream processing with compliance dashboard</td>\n</tr>\n</tbody></table>\n<h4 id=\"file-structure-extensions\">File Structure Extensions</h4>\n<p>The extension features require new modules that integrate with the existing codebase:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/\n  scaling/\n    replicas/          ← read replica management\n      replica_manager.go\n      consistency_checker.go\n    caching/           ← multi-layer caching\n      client_cache.go\n      server_cache.go\n    geographic/        ← cross-region support\n      region_manager.go\n      cross_region_sync.go\n      \n  backends/\n    cloud/             ← cloud provider backends\n      aws_iam.go\n      azure_ad.go\n      gcp_iam.go\n    pki/               ← certificate authority\n      ca_manager.go\n      cert_issuer.go\n    ssh/               ← SSH certificate authority\n      ssh_ca.go\n      user_certs.go\n      \n  enterprise/\n    tenancy/           ← multi-tenant support\n      tenant_manager.go\n      isolation_enforcer.go\n    compliance/        ← compliance reporting\n      audit_enricher.go\n      report_generator.go\n    federation/        ← advanced authentication\n      saml_handler.go\n      risk_analyzer.go</code></pre></div>\n\n<h4 id=\"scaling-infrastructure-starter-code\">Scaling Infrastructure Starter Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ReplicaManager handles read-only replicas for horizontal scaling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ReplicaManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    replicas    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReplicaNode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    healthCheck </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReplicaHealthChecker</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    loadBalancer </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReadLoadBalancer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    consistency </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConsistencyChecker</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReplicaNode represents a read-only follower</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ReplicaNode</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NodeID      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Endpoint    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastContact </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsHealthy   </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ReadLoad    </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RouteReadRequest distributes read requests across healthy replicas</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReplicaManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RouteReadRequest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ReadRequest</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReadResponse</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if request requires strong consistency (recent writes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Select healthy replica with lowest load</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate replica has required policy/token state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Execute read request with consistency checks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update replica health and load metrics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ConsistencyChecker ensures read replicas have current security state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ConsistencyChecker</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tokenVersions  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">  // Track token state versions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    policyVersions </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">  // Track policy state versions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxStaleness   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#6A737D\">     // Maximum acceptable staleness</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateReplicaConsistency checks if replica can safely serve read</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConsistencyChecker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateReplicaConsistency</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">replica</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ReplicaNode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ReadRequest</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check token version on replica vs leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check policy version for requested path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify staleness within acceptable bounds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return error if replica too stale for security</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"cloud-backend-skeleton\">Cloud Backend Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// AWSIAMBackend generates temporary AWS credentials</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AWSIAMBackend</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">iam</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">IAM</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sts        </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sts</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">STS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rolePrefix </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    accountID  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    templates  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IAMRoleTemplate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IAMRoleTemplate defines AWS role configuration for secret generation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IAMRoleTemplate</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RoleName        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PolicyDocument  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SessionDuration </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExternalID      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TrustPolicy     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateCredentials creates temporary AWS credentials for application</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">aws </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AWSIAMBackend</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateCredentials</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roleName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ttl</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up role template for requested role</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Assume role with STS to get temporary credentials</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return credentials in standard format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return revocation data (session info for cleanup)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RevokeCredentials removes AWS session and credentials</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">aws </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AWSIAMBackend</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RevokeCredentials</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">revocationData</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract session info from revocation data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call STS to invalidate session</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle case where session already expired</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"multi-tenancy-core-logic\">Multi-Tenancy Core Logic</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// TenantManager enforces isolation between organizational tenants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TenantManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tenants       </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TenantConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pathEnforcer  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PathIsolationEnforcer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    keyManager    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TenantKeyManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    auditSplitter </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TenantAuditSplitter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TenantConfig defines tenant isolation parameters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TenantConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TenantID        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PathPrefix      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EncryptionKeyID </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PolicyNamespace </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AuditStreamID   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt       </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AdminContacts   []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EnforceTenantIsolation validates request stays within tenant boundaries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TenantManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">EnforceTenantIsolation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tenantID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">requestPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">operation</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up tenant configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify request path starts with tenant prefix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check operation is allowed for tenant</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Log tenant boundary enforcement in audit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetTenantEncryptionKey returns tenant-specific DEK</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TenantManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetTenantEncryptionKey</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tenantID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">keyVersion</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate tenant ID and key version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Retrieve tenant-specific master key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Decrypt and return tenant DEK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Ensure cross-tenant key isolation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing scaling extensions:</p>\n<ul>\n<li><strong>Performance Test</strong>: Verify read replicas handle 10x read load increase with &lt; 100ms latency</li>\n<li><strong>Consistency Test</strong>: Confirm security policy changes propagate to replicas within 1 second</li>\n<li><strong>Geographic Test</strong>: Validate cross-region secret replication with encrypted transport</li>\n</ul>\n<p>After implementing cloud backends:</p>\n<ul>\n<li><strong>AWS Integration</strong>: Generate and revoke AWS IAM credentials successfully</li>\n<li><strong>Certificate Generation</strong>: Issue and validate X.509 certificates for mTLS</li>\n<li><strong>SSH Access</strong>: Authenticate to test servers using generated SSH certificates</li>\n</ul>\n<p>After implementing enterprise features:</p>\n<ul>\n<li><strong>Tenant Isolation</strong>: Verify tenant A cannot access tenant B&#39;s secrets under any conditions</li>\n<li><strong>Compliance Export</strong>: Generate compliance report covering all audit requirements</li>\n<li><strong>Federation Test</strong>: Authenticate users through SAML and validate policy enforcement</li>\n</ul>\n<h4 id=\"common-implementation-challenges\">Common Implementation Challenges</h4>\n<p>⚠️ <strong>Scaling Challenge: Cache Invalidation Races</strong>\nWhen policies change, cache invalidation messages may arrive out of order, causing replicas to temporarily allow unauthorized access. Implement version vectors that ensure caches never regress to older policy versions.</p>\n<p>⚠️ <strong>Backend Challenge: Credential Cleanup Failures</strong>\nCloud providers may be temporarily unavailable during credential revocation, leaving orphaned credentials. Implement exponential backoff retry with dead letter queues for failed revocations that require manual cleanup.</p>\n<p>⚠️ <strong>Enterprise Challenge: Tenant Boundary Violations</strong>\nComplex policy rules may inadvertently allow cross-tenant access. Implement mandatory tenant ID validation at the storage layer as a final enforcement mechanism, regardless of policy evaluation results.</p>\n<p>The extensions described in this section transform the basic secret management system into an enterprise-grade platform capable of supporting large-scale, globally distributed infrastructure. Each extension maintains the core security principles while addressing real-world operational requirements that emerge as organizations scale their secret management practices.</p>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides essential terminology and definitions that apply across all four milestones, serving as a reference for understanding the complex concepts, architectural patterns, and security mechanisms implemented throughout the secret management system.</p>\n</blockquote>\n<p>The secret management domain combines cryptography, distributed systems, authentication protocols, and security engineering concepts that may be unfamiliar to developers new to this space. This glossary provides precise definitions for technical terms, explains domain-specific concepts with clear examples, and clarifies the specific meaning of terms within the context of our secret management system.</p>\n<p>Think of this glossary as a technical dictionary that transforms abstract security concepts into concrete understanding. Just as a foreign language dictionary helps you understand individual words before reading literature, this glossary helps you understand individual concepts before diving into system implementation. Each definition includes not just what something is, but why it matters and how it fits into the larger security architecture.</p>\n<h3 id=\"core-security-concepts\">Core Security Concepts</h3>\n<p>The foundation of any secret management system rests on fundamental security principles that guide every design decision. These concepts form the mental framework for understanding why the system is built the way it is.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example/Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Zero-trust system</strong></td>\n<td>Security model requiring authentication and authorization for every request, assuming no inherent trust based on network location or previous access</td>\n<td>Our secret management system validates every API request with a token, even from internal services</td>\n</tr>\n<tr>\n<td><strong>Defense in depth</strong></td>\n<td>Multiple security layers protecting against various attack vectors, ensuring that compromise of one layer doesn&#39;t compromise the entire system</td>\n<td>Combines envelope encryption, access policies, audit logging, and network TLS</td>\n</tr>\n<tr>\n<td><strong>Assume breach</strong></td>\n<td>Security principle of designing for compromised components, building systems that remain secure even when individual parts are attacked</td>\n<td>Dynamic secrets expire automatically even if the credential database is compromised</td>\n</tr>\n<tr>\n<td><strong>Blast radius containment</strong></td>\n<td>Limiting impact of compromise to specific subset of credentials or operations</td>\n<td>Each tenant&#39;s secrets encrypted with different keys; compromise affects only that tenant</td>\n</tr>\n<tr>\n<td><strong>Secret sprawl</strong></td>\n<td>Scattered secrets across infrastructure creating security vulnerabilities through inconsistent storage, access control, and rotation practices</td>\n<td>Database passwords hardcoded in config files across hundreds of microservices</td>\n</tr>\n<tr>\n<td><strong>System charter</strong></td>\n<td>Contract defining system scope and limitations, establishing what the system will and will not do</td>\n<td>Our system manages application secrets but explicitly excludes user passwords and PKI certificates</td>\n</tr>\n</tbody></table>\n<h3 id=\"cryptographic-concepts\">Cryptographic Concepts</h3>\n<p>Secret management systems rely heavily on cryptographic primitives and patterns. Understanding these concepts is essential for implementing secure storage and key management.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example/Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Envelope encryption</strong></td>\n<td>Multi-layer encryption with master key protecting data keys, enabling key rotation without re-encrypting all data</td>\n<td>Master key encrypts DEKs, DEKs encrypt individual secrets; rotate DEK without touching master key</td>\n</tr>\n<tr>\n<td><strong>Nested safe system</strong></td>\n<td>Mental model for envelope encryption with multiple security layers, like safes within safes</td>\n<td>Bank vault (master key) contains safety deposit boxes (DEKs) containing valuables (secrets)</td>\n</tr>\n<tr>\n<td><strong>Data encryption keys</strong></td>\n<td>DEKs that actually encrypt secrets, protected by master key, enabling efficient key rotation and access control</td>\n<td>Each secret encrypted with unique DEK; compromise of one DEK affects only that secret</td>\n</tr>\n<tr>\n<td><strong>Key rotation isolation</strong></td>\n<td>Ability to rotate keys independently without affecting other keys or requiring system downtime</td>\n<td>Rotate DEK for tenant A without affecting tenant B&#39;s secrets or requiring system restart</td>\n</tr>\n<tr>\n<td><strong>Version immutability</strong></td>\n<td>Principle that secret versions cannot be changed once created, ensuring audit trail and preventing tampering</td>\n<td>Secret version 3 remains unchanged even when version 4 is created; enables rollback and compliance</td>\n</tr>\n<tr>\n<td><strong>Lazy re-encryption</strong></td>\n<td>Background process to migrate old versions to new keys without blocking operations</td>\n<td>Old secret versions gradually re-encrypted with new DEK during normal access patterns</td>\n</tr>\n<tr>\n<td><strong>Constant-time comparison</strong></td>\n<td>Cryptographic comparison that takes same time regardless of input to prevent timing attacks</td>\n<td>Token validation uses constant-time comparison to prevent attackers from guessing tokens</td>\n</tr>\n</tbody></table>\n<h3 id=\"authentication-and-authorization\">Authentication and Authorization</h3>\n<p>Access control in secret management systems requires sophisticated identity and permission models that can scale across different authentication methods and organizational structures.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example/Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Bearer token authentication</strong></td>\n<td>Authentication method using cryptographically signed tokens carried in HTTP headers</td>\n<td><code>X-Vault-Token: hvs.CAESIF...</code> header authenticates API requests</td>\n</tr>\n<tr>\n<td><strong>Corporate badge system</strong></td>\n<td>Mental model for token-based access control, where tokens work like employee badges granting building access</td>\n<td>Token contains policies like badge contains access levels; both can be revoked centrally</td>\n</tr>\n<tr>\n<td><strong>Path-based access control</strong></td>\n<td>ACL system using hierarchical paths with wildcard patterns to grant fine-grained permissions</td>\n<td>Policy allows <code>secret/app-*/database/*</code> but denies <code>secret/app-*/api-keys/*</code></td>\n</tr>\n<tr>\n<td><strong>Wildcard pattern matching</strong></td>\n<td>Flexible path matching using * for single segments and ** for recursive matching</td>\n<td><code>secret/*/database</code> matches <code>secret/app1/database</code> but not <code>secret/app1/cache/database</code></td>\n</tr>\n<tr>\n<td><strong>Default deny</strong></td>\n<td>Security model where access is denied unless explicitly allowed by policy</td>\n<td>User can only access paths explicitly granted in their token&#39;s policies</td>\n</tr>\n<tr>\n<td><strong>Policy inheritance</strong></td>\n<td>Mechanism where identities inherit policies from groups and roles</td>\n<td>User inherits developer group policies plus individual role-specific policies</td>\n</tr>\n<tr>\n<td><strong>Tamper-evident logging</strong></td>\n<td>Audit logging designed to detect modification or deletion of log entries</td>\n<td>Each audit entry includes hash of previous entry; broken chain indicates tampering</td>\n</tr>\n<tr>\n<td><strong>Mutual TLS authentication</strong></td>\n<td>Bidirectional certificate-based authentication between client and server</td>\n<td>Both client and server present certificates; validates identity cryptographically</td>\n</tr>\n</tbody></table>\n<h3 id=\"dynamic-secret-management\">Dynamic Secret Management</h3>\n<p>Dynamic secrets represent a paradigm shift from static credentials to just-in-time credential generation with automatic lifecycle management.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example/Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Credential vending machine</strong></td>\n<td>System that generates fresh credentials on demand rather than storing pre-created credentials</td>\n<td>Request database access, receive unique username/password valid for 1 hour</td>\n</tr>\n<tr>\n<td><strong>Dynamic secrets</strong></td>\n<td>Short-lived credentials generated on demand with automatic expiration and cleanup</td>\n<td>Database credentials created when requested, automatically deleted after TTL expires</td>\n</tr>\n<tr>\n<td><strong>Just-in-time generation</strong></td>\n<td>Creating credentials only when requested not stored in advance</td>\n<td>No pre-created database users; new user created for each credential request</td>\n</tr>\n<tr>\n<td><strong>Lease-based tracking</strong></td>\n<td>Time-limited credential lifecycle management with explicit expiration and renewal capabilities</td>\n<td>Each credential has lease ID, expiration time, and renewal count</td>\n</tr>\n<tr>\n<td><strong>Automatic cleanup</strong></td>\n<td>System responsibility for revoking credentials when leases expire without requiring manual intervention</td>\n<td>Expired database users automatically dropped from database by revocation engine</td>\n</tr>\n<tr>\n<td><strong>Backend plugin</strong></td>\n<td>Service-specific implementation of credential generation and management for different systems</td>\n<td>PostgreSQL backend knows how to CREATE USER, AWS backend knows IAM API calls</td>\n</tr>\n<tr>\n<td><strong>Revocation engine</strong></td>\n<td>Cleanup system that removes expired credentials from target systems using service-specific protocols</td>\n<td>Executes DROP USER for database credentials, DeleteAccessKey for AWS credentials</td>\n</tr>\n<tr>\n<td><strong>Lease reaper</strong></td>\n<td>Background process that finds and processes expired leases on configurable intervals</td>\n<td>Runs every 30 seconds, finds leases expired in last batch, queues for revocation</td>\n</tr>\n<tr>\n<td><strong>Exponential backoff</strong></td>\n<td>Retry strategy with increasing delays between attempts to handle temporary failures gracefully</td>\n<td>First retry after 1s, then 2s, 4s, 8s, up to maximum delay</td>\n</tr>\n<tr>\n<td><strong>Dead letter queue</strong></td>\n<td>Storage for revocation requests that failed maximum retry attempts requiring manual intervention</td>\n<td>Failed AWS credential deletions stored for operator review and manual cleanup</td>\n</tr>\n<tr>\n<td><strong>Priority revocation</strong></td>\n<td>Expedited credential cleanup for security incidents bypassing normal revocation queues</td>\n<td>Compromised service account credentials revoked immediately, not queued</td>\n</tr>\n</tbody></table>\n<h3 id=\"distributed-systems-and-high-availability\">Distributed Systems and High Availability</h3>\n<p>Secret management systems must remain available and consistent across multiple nodes while handling network partitions and node failures gracefully.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example/Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Shamir&#39;s secret sharing</strong></td>\n<td>Cryptographic threshold scheme splitting secrets into shares requiring minimum number to reconstruct</td>\n<td>Master key split into 5 shares, requiring any 3 to reconstruct and unseal system</td>\n</tr>\n<tr>\n<td><strong>Threshold scheme</strong></td>\n<td>Requires minimum number of shares to reconstruct secret, providing security against partial compromise</td>\n<td>3-of-5 threshold means compromise of 2 shares doesn&#39;t compromise master key</td>\n</tr>\n<tr>\n<td><strong>Polynomial interpolation</strong></td>\n<td>Mathematical technique for reconstructing polynomial from points used in Shamir&#39;s secret sharing</td>\n<td>Secret encoded as y-intercept of polynomial; shares are points used for reconstruction</td>\n</tr>\n<tr>\n<td><strong>Sealed state</strong></td>\n<td>Secure mode where master key absent and operations blocked until sufficient shares provided</td>\n<td>Server starts sealed; all secret operations return 503 until unsealing completes</td>\n</tr>\n<tr>\n<td><strong>Unsealing</strong></td>\n<td>Process of reconstructing master key and enabling operations by collecting threshold shares</td>\n<td>Operators provide 3 of 5 key shares; system reconstructs master key and enables operations</td>\n</tr>\n<tr>\n<td><strong>Leader election</strong></td>\n<td>Distributed consensus process selecting single coordinator node to prevent split-brain scenarios</td>\n<td>Raft algorithm ensures exactly one node accepts writes; others forward to leader</td>\n</tr>\n<tr>\n<td><strong>Raft consensus</strong></td>\n<td>Algorithm ensuring strong consistency across cluster nodes using leader-follower replication</td>\n<td>Leader accepts writes, replicates to majority before committing; handles leader failure</td>\n</tr>\n<tr>\n<td><strong>Auto-unseal</strong></td>\n<td>Automated unsealing using external key management service instead of manual share collection</td>\n<td>AWS KMS encrypts master key; system auto-unseals using KMS on startup</td>\n</tr>\n<tr>\n<td><strong>Key encryption key</strong></td>\n<td>External key used to encrypt/decrypt the master key in auto-unseal configurations</td>\n<td>AWS KMS key encrypts vault master key; stored encrypted master key in configuration</td>\n</tr>\n<tr>\n<td><strong>Split-brain scenarios</strong></td>\n<td>Dangerous state where multiple nodes accept conflicting writes due to network partition</td>\n<td>Two data centers lose connectivity; both elect leaders and accept conflicting secret updates</td>\n</tr>\n</tbody></table>\n<h3 id=\"request-processing-and-error-handling\">Request Processing and Error Handling</h3>\n<p>Processing secret management requests requires sophisticated pipeline architecture with comprehensive error handling and graceful degradation capabilities.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example/Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Request processing pipeline</strong></td>\n<td>Multi-stage request validation, authentication, and authorization flow with audit logging</td>\n<td>Parse → Authenticate → Authorize → Execute → Audit → Response</td>\n</tr>\n<tr>\n<td><strong>Circuit breaker</strong></td>\n<td>Pattern preventing cascading failures by stopping requests to failed services</td>\n<td>Stop sending lease revocations to failed database after 5 consecutive failures</td>\n</tr>\n<tr>\n<td><strong>Audit event generation</strong></td>\n<td>Comprehensive logging of security-relevant operations for compliance and forensics</td>\n<td>Every secret access logged with identity, timestamp, result, and request details</td>\n</tr>\n<tr>\n<td><strong>Graceful degradation</strong></td>\n<td>Reducing functionality while maintaining core security guarantees during failures</td>\n<td>Database backend failure disables dynamic secrets but static secrets remain available</td>\n</tr>\n<tr>\n<td><strong>Read-only mode</strong></td>\n<td>Degraded operational state allowing secret retrieval but blocking write operations</td>\n<td>Storage failure triggers read-only mode; secrets accessible but new secrets rejected</td>\n</tr>\n<tr>\n<td><strong>Disaster recovery</strong></td>\n<td>Procedures for restoring service after catastrophic failures using backups and redundancy</td>\n<td>Restore from encrypted backup when primary cluster completely destroyed</td>\n</tr>\n<tr>\n<td><strong>Emergency security procedures</strong></td>\n<td>Final defense mechanisms when normal security controls may be insufficient</td>\n<td>Emergency seal command immediately blocks all operations and clears memory</td>\n</tr>\n<tr>\n<td><strong>Fail-safe approach</strong></td>\n<td>Prioritizing data integrity over availability during ambiguous failure conditions</td>\n<td>Unknown error during secret write results in failure rather than potential corruption</td>\n</tr>\n<tr>\n<td><strong>Backup separation</strong></td>\n<td>Storing encrypted data and decryption keys using different systems and procedures</td>\n<td>Encrypted secrets backed up to S3; key shares stored in different security deposit boxes</td>\n</tr>\n</tbody></table>\n<h3 id=\"testing-and-security-validation\">Testing and Security Validation</h3>\n<p>Secret management systems require specialized testing approaches to validate both functional correctness and security properties under various conditions.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example/Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Timing side-channel</strong></td>\n<td>Information leakage through execution time differences revealing secret information</td>\n<td>Token validation time varies by input length, allowing attackers to guess valid tokens</td>\n</tr>\n<tr>\n<td><strong>Property-based testing</strong></td>\n<td>Testing approach using randomized inputs to verify algorithmic properties hold universally</td>\n<td>Test that encrypt(decrypt(x)) == x for thousands of random inputs</td>\n</tr>\n<tr>\n<td><strong>Penetration testing</strong></td>\n<td>Security testing simulating real-world attack scenarios against deployed systems</td>\n<td>Attempt privilege escalation, token theft, timing attacks against running system</td>\n</tr>\n<tr>\n<td><strong>Chaos testing</strong></td>\n<td>Testing system behavior under random failure conditions to validate resilience</td>\n<td>Randomly kill nodes, corrupt network packets, fill disk space during operations</td>\n</tr>\n<tr>\n<td><strong>Load testing</strong></td>\n<td>Performance testing under realistic traffic patterns to validate scalability</td>\n<td>1000 concurrent clients requesting dynamic secrets every second for 10 minutes</td>\n</tr>\n<tr>\n<td><strong>Integration testing</strong></td>\n<td>Testing complete workflows across all system components end-to-end</td>\n<td>Create secret, generate policy, authenticate user, retrieve secret, verify audit log</td>\n</tr>\n</tbody></table>\n<h3 id=\"scalability-and-enterprise-features\">Scalability and Enterprise Features</h3>\n<p>Production secret management systems must handle enterprise-scale requirements including multi-tenancy, geographic distribution, and regulatory compliance.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example/Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Read replicas</strong></td>\n<td>Follower nodes handling read-only requests for scaling without compromising consistency</td>\n<td>Secret reads distributed across 3 replicas; writes processed by single leader</td>\n</tr>\n<tr>\n<td><strong>Geographic distribution</strong></td>\n<td>Regional clusters with cross-region replication for disaster recovery and latency</td>\n<td>Primary cluster in us-east-1; replica cluster in eu-west-1 for European customers</td>\n</tr>\n<tr>\n<td><strong>Multi-tenancy</strong></td>\n<td>Organizational isolation within shared infrastructure using cryptographic and path separation</td>\n<td>Each customer&#39;s secrets encrypted with tenant-specific keys and isolated paths</td>\n</tr>\n<tr>\n<td><strong>Compliance reporting</strong></td>\n<td>Structured audit reports for regulatory requirements like SOX, GDPR, HIPAA</td>\n<td>Monthly access reports showing who accessed which secrets when for audit review</td>\n</tr>\n<tr>\n<td><strong>Federation</strong></td>\n<td>Integration with external identity providers for authentication and authorization</td>\n<td>Authenticate users against corporate Active Directory; map AD groups to vault policies</td>\n</tr>\n<tr>\n<td><strong>Risk-based authentication</strong></td>\n<td>Adaptive security based on request context like location, time, device, behavior</td>\n<td>Unusual access patterns trigger additional authentication challenges</td>\n</tr>\n<tr>\n<td><strong>Tenant isolation</strong></td>\n<td>Cryptographic and administrative separation between organizations sharing infrastructure</td>\n<td>Customer A cannot access customer B&#39;s secrets even with system administrator privileges</td>\n</tr>\n<tr>\n<td><strong>Path-based segregation</strong></td>\n<td>Tenant separation using URL prefix enforcement with cryptographic boundaries</td>\n<td>Tenant A limited to <code>/secret/tenant-a/*</code> paths with separate encryption keys</td>\n</tr>\n</tbody></table>\n<h3 id=\"system-operations-and-maintenance\">System Operations and Maintenance</h3>\n<p>Operating a secret management system requires understanding maintenance procedures, monitoring approaches, and operational best practices.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example/Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Lease renewal</strong></td>\n<td>Extending credential lifetime before expiration for ongoing operations</td>\n<td>Application renews database credentials every hour to maintain continuous access</td>\n</tr>\n<tr>\n<td><strong>Key rotation</strong></td>\n<td>Periodic replacement of encryption keys to limit blast radius of compromise</td>\n<td>Master key rotated annually; data encryption keys rotated monthly</td>\n</tr>\n<tr>\n<td><strong>Seal recovery</strong></td>\n<td>Emergency procedures for reconstructing master key when normal unsealing fails</td>\n<td>Use backup key shares stored in different locations to recover sealed system</td>\n</tr>\n<tr>\n<td><strong>Health monitoring</strong></td>\n<td>Continuous validation of system components and dependencies</td>\n<td>Monitor encryption engine, storage backend, cluster consensus, lease reaper</td>\n</tr>\n<tr>\n<td><strong>Performance tuning</strong></td>\n<td>Optimizing system configuration for throughput, latency, and resource utilization</td>\n<td>Adjust lease reaper batch size, revocation worker count, token cache TTL</td>\n</tr>\n<tr>\n<td><strong>Backup validation</strong></td>\n<td>Regular testing of backup and restore procedures to ensure disaster recovery capability</td>\n<td>Monthly restore test using previous week&#39;s backup to validate recovery procedures</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Secret management systems involve complex terminology that can be overwhelming for developers new to the security domain. This implementation guidance provides practical approaches for managing this complexity during development.</p>\n<h4 id=\"technology-recommendations-for-documentation\">Technology Recommendations for Documentation</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Code Documentation</td>\n<td>Inline comments with examples</td>\n<td>Comprehensive API documentation with OpenAPI/Swagger</td>\n</tr>\n<tr>\n<td>Architecture Documentation</td>\n<td>Markdown files with diagrams</td>\n<td>Interactive documentation with PlantUML diagrams</td>\n</tr>\n<tr>\n<td>Troubleshooting Guides</td>\n<td>Text-based symptom/solution tables</td>\n<td>Searchable knowledge base with categorized issues</td>\n</tr>\n<tr>\n<td>Glossary Management</td>\n<td>Static markdown glossary</td>\n<td>Searchable glossary with cross-references and examples</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-documentation-structure\">Recommended Documentation Structure</h4>\n<p>Organize terminology and documentation to support both development and operations teams:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>docs/\n  glossary.md                    ← this comprehensive glossary\n  concepts/                      ← detailed concept explanations\n    envelope-encryption.md       ← deep dive into encryption patterns\n    dynamic-secrets.md          ← credential lifecycle management\n    access-control.md           ← authentication and authorization\n    high-availability.md        ← clustering and consensus\n  troubleshooting/              ← operational guidance\n    common-errors.md            ← frequent issues and solutions\n    diagnostic-procedures.md    ← step-by-step problem diagnosis\n    performance-tuning.md       ← optimization recommendations\n  api/                          ← API documentation\n    authentication.md           ← auth method documentation\n    secret-engines.md           ← backend-specific APIs</code></pre></div>\n\n<h4 id=\"terminology-management-code\">Terminology Management Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// TerminologyValidator helps ensure consistent terminology usage across the codebase</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TerminologyValidator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    preferredTerms </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    deprecatedTerms </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewTerminologyValidator creates a validator with standard secret management terms</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewTerminologyValidator</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TerminologyValidator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">TerminologyValidator</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        preferredTerms: </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"envelope encryption\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Multi-layer encryption with master key protecting data keys\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"dynamic secrets\"</span><span style=\"color:#E1E4E8\">:     </span><span style=\"color:#9ECBFF\">\"Short-lived credentials generated on demand\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"zero-trust\"</span><span style=\"color:#E1E4E8\">:         </span><span style=\"color:#9ECBFF\">\"Security model requiring authentication for every request\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"secret sprawl\"</span><span style=\"color:#E1E4E8\">:      </span><span style=\"color:#9ECBFF\">\"Scattered secrets creating security vulnerabilities\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        deprecatedTerms: </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"secret management\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Use 'secret storage' or 'credential management' for clarity\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"encryption\"</span><span style=\"color:#E1E4E8\">:        </span><span style=\"color:#9ECBFF\">\"Specify 'envelope encryption' or 'field-level encryption'\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"authentication\"</span><span style=\"color:#E1E4E8\">:    </span><span style=\"color:#9ECBFF\">\"Specify 'bearer token' or 'mutual TLS authentication'\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateDocumentation checks documentation for consistent terminology usage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tv </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TerminologyValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateDocumentation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">content</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#B392F0\">TerminologyIssue</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement documentation parsing and terminology validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check for deprecated terms and suggest preferred alternatives  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify technical terms are defined before first usage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Flag inconsistent usage of the same concept across documents</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"glossary-integration-utilities\">Glossary Integration Utilities</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// GlossaryLookup provides runtime access to terminology definitions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> GlossaryLookup</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    definitions </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Definition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    examples    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    crossRefs   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Definition</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Term        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Definition  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Context     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Examples    []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SeeAlso     []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Category    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LoadGlossary parses the markdown glossary into structured data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> LoadGlossary</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">glossaryPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GlossaryLookup</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Parse markdown glossary tables into structured definitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Extract cross-references and examples</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Build category indexes for related terms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate all cross-references resolve to valid terms</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Define returns the definition for a technical term</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">gl </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GlossaryLookup</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Define</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">term</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Definition</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return definition with examples and cross-references</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Handle case-insensitive lookup and common variations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Track usage statistics for documentation improvement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Definition</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint-terminology-consistency\">Milestone Checkpoint: Terminology Consistency</h4>\n<p>After implementing each milestone, validate terminology consistency:</p>\n<p><strong>Milestone 1 - Encryption Terms:</strong></p>\n<ul>\n<li>Run: <code>grep -r &quot;encryption&quot; internal/ | validate-terminology.sh</code></li>\n<li>Expected: All references use &quot;envelope encryption&quot; when describing the key hierarchy</li>\n<li>Signs of issues: Generic &quot;encryption&quot; terms without specifying the pattern</li>\n</ul>\n<p><strong>Milestone 2 - Authentication Terms:</strong></p>\n<ul>\n<li>Run: <code>grep -r &quot;auth&quot; internal/ | validate-terminology.sh</code> </li>\n<li>Expected: Specific terms like &quot;bearer token authentication&quot; and &quot;mutual TLS&quot;</li>\n<li>Signs of issues: Vague &quot;authentication&quot; without specifying the method</li>\n</ul>\n<p><strong>Milestone 3 - Dynamic Secret Terms:</strong></p>\n<ul>\n<li>Run: <code>grep -r &quot;credential&quot; internal/ | validate-terminology.sh</code></li>\n<li>Expected: &quot;Dynamic secrets&quot; and &quot;lease-based tracking&quot; terminology</li>\n<li>Signs of issues: &quot;Temporary credentials&quot; or &quot;short-lived tokens&quot; instead</li>\n</ul>\n<p><strong>Milestone 4 - Consensus Terms:</strong></p>\n<ul>\n<li>Run: <code>grep -r &quot;cluster&quot; internal/ | validate-terminology.sh</code></li>\n<li>Expected: &quot;Raft consensus&quot; and &quot;leader election&quot; terminology</li>\n<li>Signs of issues: Generic &quot;replication&quot; without specifying consensus algorithm</li>\n</ul>\n<h4 id=\"debugging-terminology-issues\">Debugging Terminology Issues</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Inconsistent API documentation</td>\n<td>Mixed terminology across endpoints</td>\n<td>Search codebase for term variations</td>\n<td>Establish style guide with preferred terms</td>\n</tr>\n<tr>\n<td>Confusing error messages</td>\n<td>Technical jargon without context</td>\n<td>Review error messages with non-experts</td>\n<td>Add glossary references to error docs</td>\n</tr>\n<tr>\n<td>Unclear troubleshooting guides</td>\n<td>Assumed knowledge of domain terms</td>\n<td>Test guides with junior developers</td>\n<td>Define terms inline or reference glossary</td>\n</tr>\n<tr>\n<td>Complex architecture docs</td>\n<td>Too many undefined acronyms</td>\n<td>Count undefined terms per page</td>\n<td>Maintain acronym list and spell out on first use</td>\n</tr>\n</tbody></table>\n","toc":[{"level":1,"text":"Secret Management System: Design Document","id":"secret-management-system-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"The Bank Vault Analogy","id":"the-bank-vault-analogy"},{"level":3,"text":"The Secret Sprawl Problem","id":"the-secret-sprawl-problem"},{"level":3,"text":"Current Approaches Comparison","id":"current-approaches-comparison"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Functional Goals","id":"functional-goals"},{"level":4,"text":"Secret Storage and Retrieval","id":"secret-storage-and-retrieval"},{"level":4,"text":"Access Control and Authentication","id":"access-control-and-authentication"},{"level":4,"text":"Dynamic Secret Generation","id":"dynamic-secret-generation"},{"level":4,"text":"High Availability and Disaster Recovery","id":"high-availability-and-disaster-recovery"},{"level":3,"text":"Non-Functional Goals","id":"non-functional-goals"},{"level":4,"text":"Security Properties","id":"security-properties"},{"level":4,"text":"Performance and Scalability","id":"performance-and-scalability"},{"level":4,"text":"Operational Simplicity","id":"operational-simplicity"},{"level":3,"text":"Explicit Non-Goals","id":"explicit-non-goals"},{"level":4,"text":"Enterprise Features (Out of Scope)","id":"enterprise-features-out-of-scope"},{"level":4,"text":"Advanced Cryptographic Features","id":"advanced-cryptographic-features"},{"level":4,"text":"Performance Optimization (Deferred)","id":"performance-optimization-deferred"},{"level":4,"text":"Cloud-Specific Features","id":"cloud-specific-features"},{"level":3,"text":"Success Criteria and Validation","id":"success-criteria-and-validation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Goal Validation Checklist","id":"goal-validation-checklist"},{"level":4,"text":"Common Implementation Pitfalls","id":"common-implementation-pitfalls"},{"level":4,"text":"File Structure for Goal-Driven Development","id":"file-structure-for-goal-driven-development"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Overview","id":"component-overview"},{"level":3,"text":"Security Boundaries","id":"security-boundaries"},{"level":3,"text":"Deployment Topology","id":"deployment-topology"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Secret Storage Model","id":"secret-storage-model"},{"level":4,"text":"Mental Model: The Nested Safe System","id":"mental-model-the-nested-safe-system"},{"level":4,"text":"Secret Entity Structure","id":"secret-entity-structure"},{"level":4,"text":"Secret Version Structure","id":"secret-version-structure"},{"level":4,"text":"Data Encryption Key Structure","id":"data-encryption-key-structure"},{"level":3,"text":"Access Control Model","id":"access-control-model"},{"level":4,"text":"Mental Model: The Corporate Badge System","id":"mental-model-the-corporate-badge-system"},{"level":4,"text":"Policy Structure","id":"policy-structure"},{"level":4,"text":"Policy Rule Structure","id":"policy-rule-structure"},{"level":4,"text":"Token Structure","id":"token-structure"},{"level":4,"text":"Identity Structure","id":"identity-structure"},{"level":3,"text":"Dynamic Secret Model","id":"dynamic-secret-model"},{"level":4,"text":"Mental Model: The Credential Vending Machine","id":"mental-model-the-credential-vending-machine"},{"level":4,"text":"Lease Structure","id":"lease-structure"},{"level":4,"text":"Secret Backend Configuration","id":"secret-backend-configuration"},{"level":4,"text":"Backend Role Configuration","id":"backend-role-configuration"},{"level":4,"text":"Lease Tracking and Revocation","id":"lease-tracking-and-revocation"},{"level":4,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Data Structure Definitions","id":"core-data-structure-definitions"},{"level":4,"text":"Storage Interface Implementation","id":"storage-interface-implementation"},{"level":4,"text":"Envelope Encryption Helper","id":"envelope-encryption-helper"},{"level":4,"text":"Database Migration Example","id":"database-migration-example"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Encryption Engine Design","id":"encryption-engine-design"},{"level":3,"text":"Envelope Encryption Mental Model","id":"envelope-encryption-mental-model"},{"level":3,"text":"Key Hierarchy and Rotation","id":"key-hierarchy-and-rotation"},{"level":3,"text":"Encrypt/Decrypt Operations","id":"encryptdecrypt-operations"},{"level":3,"text":"Secret Versioning","id":"secret-versioning"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Authentication and Policy Engine","id":"authentication-and-policy-engine"},{"level":3,"text":"Authentication Methods","id":"authentication-methods"},{"level":3,"text":"Policy Definition Language","id":"policy-definition-language"},{"level":3,"text":"Authorization Flow","id":"authorization-flow"},{"level":3,"text":"Audit Logging","id":"audit-logging"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Authentication Infrastructure (Complete Implementation)","id":"authentication-infrastructure-complete-implementation"},{"level":4,"text":"Core Authentication Engine (Skeleton Implementation)","id":"core-authentication-engine-skeleton-implementation"},{"level":4,"text":"Path Matching Utility (Complete Implementation)","id":"path-matching-utility-complete-implementation"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Dynamic Secret Engine","id":"dynamic-secret-engine"},{"level":3,"text":"Dynamic Secret Mental Model: Understanding just-in-time credential generation","id":"dynamic-secret-mental-model-understanding-just-in-time-credential-generation"},{"level":3,"text":"Secret Backend Plugins: Database and cloud provider credential generation","id":"secret-backend-plugins-database-and-cloud-provider-credential-generation"},{"level":3,"text":"Lease Management: TTL tracking, renewal, and automatic revocation","id":"lease-management-ttl-tracking-renewal-and-automatic-revocation"},{"level":3,"text":"Revocation Engine: Cleanup of expired credentials across backends","id":"revocation-engine-cleanup-of-expired-credentials-across-backends"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Unsealing and High Availability","id":"unsealing-and-high-availability"},{"level":3,"text":"Shamir&#39;s Secret Sharing: Splitting Master Key into Shares for Security","id":"shamir39s-secret-sharing-splitting-master-key-into-shares-for-security"},{"level":3,"text":"Seal and Unseal Operations: System Startup and Key Reconstruction Process","id":"seal-and-unseal-operations-system-startup-and-key-reconstruction-process"},{"level":3,"text":"High Availability and Consensus: Leader Election and Data Replication Strategies","id":"high-availability-and-consensus-leader-election-and-data-replication-strategies"},{"level":3,"text":"Auto-Unseal Integration: Cloud KMS Integration for Automated Unsealing","id":"auto-unseal-integration-cloud-kms-integration-for-automated-unsealing"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"REST API Design","id":"rest-api-design"},{"level":4,"text":"API Endpoint Structure","id":"api-endpoint-structure"},{"level":4,"text":"Request and Response Format Standards","id":"request-and-response-format-standards"},{"level":4,"text":"Authentication Header Requirements","id":"authentication-header-requirements"},{"level":3,"text":"Request Processing Pipeline","id":"request-processing-pipeline"},{"level":4,"text":"Stage 1: Request Parsing and Validation","id":"stage-1-request-parsing-and-validation"},{"level":4,"text":"Stage 2: Authentication and Identity Resolution","id":"stage-2-authentication-and-identity-resolution"},{"level":4,"text":"Stage 3: Authorization and Policy Evaluation","id":"stage-3-authorization-and-policy-evaluation"},{"level":4,"text":"Stage 4: Secret Operations and Business Logic","id":"stage-4-secret-operations-and-business-logic"},{"level":3,"text":"Background Processes","id":"background-processes"},{"level":4,"text":"Lease Management and Revocation Engine","id":"lease-management-and-revocation-engine"},{"level":4,"text":"Token Maintenance and Cleanup","id":"token-maintenance-and-cleanup"},{"level":4,"text":"Encryption Key Rotation and Migration","id":"encryption-key-rotation-and-migration"},{"level":4,"text":"Health Monitoring and Alerting","id":"health-monitoring-and-alerting"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"File Structure Organization","id":"file-structure-organization"},{"level":4,"text":"Core HTTP Server Infrastructure","id":"core-http-server-infrastructure"},{"level":4,"text":"Request Processing Pipeline Implementation","id":"request-processing-pipeline-implementation"},{"level":4,"text":"Background Process Infrastructure","id":"background-process-infrastructure"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"System Failure Modes","id":"system-failure-modes"},{"level":4,"text":"Network Partitions and Communication Failures","id":"network-partitions-and-communication-failures"},{"level":4,"text":"Storage System Failures","id":"storage-system-failures"},{"level":4,"text":"Encryption Key Corruption and Loss","id":"encryption-key-corruption-and-loss"},{"level":4,"text":"Service Dependencies and External Systems","id":"service-dependencies-and-external-systems"},{"level":3,"text":"Recovery Strategies","id":"recovery-strategies"},{"level":4,"text":"Backup and Restore Procedures","id":"backup-and-restore-procedures"},{"level":4,"text":"Disaster Recovery Procedures","id":"disaster-recovery-procedures"},{"level":4,"text":"Data Consistency and Integrity Validation","id":"data-consistency-and-integrity-validation"},{"level":3,"text":"Graceful Degradation","id":"graceful-degradation"},{"level":4,"text":"Read-Only Mode Operation","id":"read-only-mode-operation"},{"level":4,"text":"Reduced Functionality Scenarios","id":"reduced-functionality-scenarios"},{"level":4,"text":"Emergency Security Procedures","id":"emergency-security-procedures"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"File Structure for Error Handling","id":"file-structure-for-error-handling"},{"level":4,"text":"Core Error Handling Infrastructure","id":"core-error-handling-infrastructure"},{"level":4,"text":"Health Check and Status Monitoring","id":"health-check-and-status-monitoring"},{"level":4,"text":"Backup and Recovery Implementation","id":"backup-and-recovery-implementation"},{"level":4,"text":"Graceful Degradation Implementation","id":"graceful-degradation-implementation"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Common Debugging Scenarios","id":"common-debugging-scenarios"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Security Testing","id":"security-testing"},{"level":3,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":3,"text":"Integration Testing","id":"integration-testing"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Common Implementation Bugs","id":"common-implementation-bugs"},{"level":4,"text":"Encryption and Key Management Bugs","id":"encryption-and-key-management-bugs"},{"level":4,"text":"Authentication and Authorization Bugs","id":"authentication-and-authorization-bugs"},{"level":4,"text":"Dynamic Secret Lifecycle Bugs","id":"dynamic-secret-lifecycle-bugs"},{"level":4,"text":"High Availability and Consensus Bugs","id":"high-availability-and-consensus-bugs"},{"level":3,"text":"Diagnostic Techniques","id":"diagnostic-techniques"},{"level":4,"text":"Structured Logging and Audit Trails","id":"structured-logging-and-audit-trails"},{"level":4,"text":"Cryptographic Verification and Validation","id":"cryptographic-verification-and-validation"},{"level":4,"text":"Performance and Resource Monitoring","id":"performance-and-resource-monitoring"},{"level":3,"text":"Symptom-Cause-Fix Reference","id":"symptom-cause-fix-reference"},{"level":4,"text":"Authentication and Access Issues","id":"authentication-and-access-issues"},{"level":4,"text":"Encryption and Storage Failures","id":"encryption-and-storage-failures"},{"level":4,"text":"Dynamic Secret Lifecycle Problems","id":"dynamic-secret-lifecycle-problems"},{"level":4,"text":"High Availability and Cluster Issues","id":"high-availability-and-cluster-issues"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"File Structure","id":"file-structure"},{"level":4,"text":"Audit Logger Implementation","id":"audit-logger-implementation"},{"level":4,"text":"Cryptographic Test Vector Validation","id":"cryptographic-test-vector-validation"},{"level":4,"text":"Performance Monitoring and Health Checks","id":"performance-monitoring-and-health-checks"},{"level":4,"text":"Diagnostic Command-Line Tools","id":"diagnostic-command-line-tools"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Common Debugging Scenarios","id":"common-debugging-scenarios"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Scalability Improvements","id":"scalability-improvements"},{"level":4,"text":"Horizontal Scaling Architecture","id":"horizontal-scaling-architecture"},{"level":4,"text":"Geographic Distribution","id":"geographic-distribution"},{"level":4,"text":"Performance Optimization","id":"performance-optimization"},{"level":3,"text":"Additional Secret Backends","id":"additional-secret-backends"},{"level":4,"text":"Cloud Provider Integration","id":"cloud-provider-integration"},{"level":4,"text":"PKI and Certificate Management","id":"pki-and-certificate-management"},{"level":4,"text":"SSH Certificate Authority","id":"ssh-certificate-authority"},{"level":3,"text":"Enterprise Features","id":"enterprise-features"},{"level":4,"text":"Multi-Tenancy Implementation","id":"multi-tenancy-implementation"},{"level":4,"text":"Compliance and Reporting","id":"compliance-and-reporting"},{"level":4,"text":"Advanced Authentication Methods","id":"advanced-authentication-methods"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"File Structure Extensions","id":"file-structure-extensions"},{"level":4,"text":"Scaling Infrastructure Starter Code","id":"scaling-infrastructure-starter-code"},{"level":4,"text":"Cloud Backend Skeleton","id":"cloud-backend-skeleton"},{"level":4,"text":"Multi-Tenancy Core Logic","id":"multi-tenancy-core-logic"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Common Implementation Challenges","id":"common-implementation-challenges"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Core Security Concepts","id":"core-security-concepts"},{"level":3,"text":"Cryptographic Concepts","id":"cryptographic-concepts"},{"level":3,"text":"Authentication and Authorization","id":"authentication-and-authorization"},{"level":3,"text":"Dynamic Secret Management","id":"dynamic-secret-management"},{"level":3,"text":"Distributed Systems and High Availability","id":"distributed-systems-and-high-availability"},{"level":3,"text":"Request Processing and Error Handling","id":"request-processing-and-error-handling"},{"level":3,"text":"Testing and Security Validation","id":"testing-and-security-validation"},{"level":3,"text":"Scalability and Enterprise Features","id":"scalability-and-enterprise-features"},{"level":3,"text":"System Operations and Maintenance","id":"system-operations-and-maintenance"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations for Documentation","id":"technology-recommendations-for-documentation"},{"level":4,"text":"Recommended Documentation Structure","id":"recommended-documentation-structure"},{"level":4,"text":"Terminology Management Code","id":"terminology-management-code"},{"level":4,"text":"Glossary Integration Utilities","id":"glossary-integration-utilities"},{"level":4,"text":"Milestone Checkpoint: Terminology Consistency","id":"milestone-checkpoint-terminology-consistency"},{"level":4,"text":"Debugging Terminology Issues","id":"debugging-terminology-issues"}],"title":"Secret Management System: Design Document","markdown":"# Secret Management System: Design Document\n\n\n## Overview\n\nA distributed secret management system inspired by HashiCorp Vault that provides secure storage, dynamic secret generation, and fine-grained access control for applications. The key architectural challenge is building a zero-trust security model that encrypts secrets at rest, enforces path-based policies, and maintains high availability while requiring human operators to unseal the system.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** This section provides the foundational context that applies to all milestones, establishing why we need a centralized secret management system and the security challenges it addresses.\n\n### The Bank Vault Analogy\n\nThink of a modern bank's security system as the perfect mental model for understanding secret management. A bank doesn't just throw cash into a filing cabinet and call it secure. Instead, it employs multiple layers of protection: a massive steel vault with time locks, individual safety deposit boxes within that vault, armed guards who verify your identity before granting access, detailed logs of who accessed what and when, and multiple keys or combinations required to open the main vault (no single person can access everything alone).\n\nYour application's secrets—database passwords, API keys, encryption keys, certificates—are just as valuable as the cash in that bank vault. A compromised database password can expose millions of customer records. A leaked API key can rack up thousands of dollars in cloud costs or grant access to sensitive services. An exposed encryption key can render all your \"secure\" data readable by attackers.\n\nJust as banks evolved from simple lockboxes to sophisticated multi-layered security systems, application secret management has evolved from simple configuration files to centralized secret management systems. The bank vault analogy maps perfectly to our secret management system:\n\n- **The Steel Vault** → Our encryption engine with envelope encryption\n- **Individual Safety Deposit Boxes** → Path-based secret storage with fine-grained access control\n- **Bank Guards and ID Verification** → Authentication and authorization engines\n- **Access Logs and Cameras** → Comprehensive audit logging\n- **Multiple Keys Required** → Shamir's secret sharing for unsealing the system\n- **Branch Locations** → High availability with multiple nodes\n\nThe critical insight here is that security isn't just about encryption—it's about creating a **zero-trust system** where every request must be authenticated, authorized, logged, and encrypted, just like every bank transaction.\n\n### The Secret Sprawl Problem\n\nIn most organizations, secrets proliferate like weeds across the infrastructure landscape, creating what security professionals call \"secret sprawl.\" This scattered approach creates numerous attack vectors and operational nightmares.\n\nConsider a typical web application stack: the frontend needs API keys for third-party services, the backend needs database credentials and encryption keys, the deployment pipeline needs cloud provider credentials, monitoring systems need service account tokens, and backup scripts need storage access keys. Without centralized management, these secrets end up everywhere:\n\n**Configuration Files** become secret repositories by accident. Developers embed database URLs with passwords directly into `config.yaml` files, then check them into version control. Even after rotating the password, it remains in git history forever. The `application.properties` file becomes a treasure trove of sensitive data that gets copied to every deployment environment.\n\n**Environment Variables** seem safer initially, but they leak in process listings, crash dumps, and container orchestration logs. When a developer runs `env | grep DATABASE_PASSWORD` on a production server for debugging, that password appears in shell history. Container platforms often log environment variables during deployment, creating permanent records of sensitive data.\n\n**Hardcoded Secrets** represent the worst-case scenario—passwords embedded directly in source code. These spread through copy-paste programming, appear in multiple repositories, and become nearly impossible to rotate without coordinating changes across dozens of codebases simultaneously.\n\nThe fundamental problems with secret sprawl include:\n\n| Problem | Impact | Concrete Example |\n|---------|--------|------------------|\n| **No Centralized Rotation** | A single compromised secret requires manual updates across dozens of systems | Database password leak requires updating 15 microservices, 3 batch jobs, and 5 monitoring scripts individually |\n| **Unclear Access Patterns** | No visibility into which applications access which secrets | Security team can't determine blast radius when API key is found in public GitHub repo |\n| **Long-Lived Secrets** | Static passwords remain valid for months or years | Production database password hasn't changed in 2 years; compromise goes undetected for months |\n| **Inconsistent Security** | Each team implements their own secret handling with varying security levels | Team A encrypts secrets with AES-256; Team B stores them in plain text |\n| **Audit Gaps** | No comprehensive logging of secret access | Compliance audit fails because company can't prove who accessed customer encryption keys |\n| **Emergency Response Delays** | Incident response requires hunting secrets across multiple systems | After data breach, team spends 6 hours finding all systems that need new credentials |\n\n**The Operational Nightmare** manifests during incidents. Imagine your cloud provider notifies you that your S3 access keys were found in a public code repository. In a sprawled environment, you must:\n\n1. Identify every application, script, and service using those keys\n2. Generate new credentials in the cloud provider console\n3. Update configuration files across multiple repositories\n4. Deploy updated configurations to staging and production environments\n5. Verify that all systems are working with new credentials\n6. Monitor logs to ensure no systems are still using old credentials\n\nThis process can take hours or days, during which your systems remain vulnerable. With centralized secret management, this same scenario becomes: update the secret in one location, and all authorized applications automatically receive the new credentials within minutes.\n\n### Current Approaches Comparison\n\nOrganizations today employ various strategies for secret management, each with distinct trade-offs that influence security posture, operational complexity, and developer experience.\n\n> **Decision: Secret Management Strategy Selection**\n> - **Context**: Applications need secure access to databases, APIs, and other services requiring authentication, but must balance security, operational overhead, and development velocity\n> - **Options Considered**: Environment variables, configuration files, cloud secret services, dedicated secret management systems\n> - **Decision**: Implement a dedicated secret management system with centralized storage, encryption, and access control\n> - **Rationale**: Provides strongest security guarantees while enabling automated secret rotation and comprehensive audit trails\n> - **Consequences**: Requires additional infrastructure but eliminates secret sprawl and enables sophisticated security policies\n\n| Approach | Security Level | Operational Overhead | Developer Experience | Use Cases |\n|----------|---------------|----------------------|---------------------|-----------|\n| **Environment Variables** | Low-Medium | Low | Excellent | Development environments, simple deployments |\n| **Configuration Files** | Low | Medium | Good | Traditional applications, legacy systems |\n| **Cloud Secret Services** | High | Medium | Good | Cloud-native applications, single-provider environments |\n| **Dedicated Secret Management** | Very High | High | Medium | Enterprise environments, multi-cloud, compliance requirements |\n\n**Environment Variables** represent the simplest approach, leveraging the operating system's built-in capability to pass configuration to processes. Developers appreciate the simplicity—`os.Getenv(\"DATABASE_PASSWORD\")` works identically across languages and platforms. However, environment variables appear in process lists (`ps aux` shows them to any user), get logged by container orchestration systems, and persist in shell history. They work well for development environments where security threats are minimal, but create significant risks in production.\n\nThe environmental variable approach breaks down with secret rotation. Changing a database password requires updating environment variables across every deployment, then restarting all affected services. During the transition window, some services use old credentials while others use new ones, creating authentication failures and service disruptions.\n\n**Configuration Files** offer more structure and can support encryption at rest. A `secrets.yaml` file can contain all application secrets in one location, potentially encrypted with a master key. This approach enables version control of secret configurations (with encrypted values) and supports complex secret hierarchies with nested structures.\n\nHowever, configuration files introduce key distribution problems—how do applications securely obtain the master key to decrypt the configuration file? The key often ends up in environment variables or hardcoded, recreating the original problem. Additionally, updating configuration files requires application restarts, preventing dynamic secret rotation.\n\n**Cloud Secret Services** like AWS Secrets Manager, Azure Key Vault, or Google Secret Manager provide professionally managed secret storage with strong encryption, automated rotation capabilities, and comprehensive audit logging. These services integrate seamlessly with cloud-native applications and handle the operational complexity of secret management.\n\nThe primary limitations of cloud secret services include vendor lock-in (applications become tightly coupled to specific cloud providers), limited customization options, and challenges in multi-cloud environments. Organizations using multiple cloud providers must integrate with different secret APIs, each with unique authentication models and feature sets.\n\n**Dedicated Secret Management Systems** like HashiCorp Vault provide the highest level of security and flexibility. These systems implement sophisticated encryption schemes, support multiple authentication methods, enable dynamic secret generation, and offer granular access control policies. They operate independently of cloud providers, supporting multi-cloud and hybrid environments.\n\nThe trade-off involves operational complexity—dedicated secret management systems require specialized knowledge to deploy, configure, and maintain. They introduce additional infrastructure dependencies and require careful attention to high availability and disaster recovery.\n\n> The fundamental insight driving our architectural decisions is that **security and convenience exist in constant tension**. The most secure approach (air-gapped systems with manual key management) proves unusable for modern application development. The most convenient approach (hardcoded secrets) creates catastrophic security vulnerabilities. Our secret management system aims to find the optimal balance point.\n\n**Dynamic vs Static Secret Models** represent a critical architectural distinction. Traditional approaches treat secrets as static configuration—passwords that change infrequently and must be distributed to applications. Dynamic secret systems generate unique, short-lived credentials on-demand for each application or session.\n\nConsider database access patterns: static approaches use shared database credentials across all application instances. If those credentials leak, every application instance is compromised, and rotation requires coordinating updates across the entire fleet. Dynamic approaches generate unique database users for each application instance, with automatic expiration after configurable time periods. Credential leaks affect only single instances, and rotation happens automatically without coordination.\n\n| Secret Model | Credential Sharing | Rotation Complexity | Blast Radius | Audit Granularity |\n|--------------|-------------------|-------------------|--------------|-------------------|\n| **Static** | Multiple applications share same credentials | High - requires coordination | High - affects all users | Low - can't distinguish application instances |\n| **Dynamic** | Each application gets unique credentials | Low - automatic with TTL | Low - affects single application | High - individual application tracking |\n\nThe mental model for dynamic secrets resembles a hotel key card system. Instead of giving every guest the same master key, hotels generate unique key cards for each guest's stay, programmed to work only for specific rooms during specific dates. When a guest checks out, their key card automatically becomes invalid. If a key card is lost or stolen, it affects only that guest's access, not the entire hotel's security.\n\n**Implementation Complexity Considerations** influence the architectural approach significantly. Simple secret management implementations can start with encrypted configuration files and basic environment variable injection. However, this approach doesn't scale to enterprise requirements for audit logging, fine-grained access control, or dynamic secret generation.\n\nOur architectural decision prioritizes **security depth over implementation simplicity**. While this increases initial development complexity, it provides a foundation for sophisticated security policies, comprehensive audit trails, and automated secret lifecycle management that prove essential for production environments and compliance requirements.\n\nThe subsequent sections detail how our secret management system addresses each challenge identified in this problem statement, building from basic encrypted storage through sophisticated high-availability clustering with automated failover and recovery capabilities.\n\n### Implementation Guidance\n\n**A. Technology Recommendations Table:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **HTTP Server** | `net/http` with JSON | `gRPC` with Protocol Buffers |\n| **Storage Backend** | Local filesystem with `os.File` | `etcd` or `consul` for distributed storage |\n| **Encryption** | `crypto/aes` with `crypto/rand` | Hardware Security Modules (HSMs) |\n| **Authentication** | Simple bearer tokens | `x/crypto/bcrypt` + JWT with `github.com/golang-jwt/jwt` |\n| **Logging** | Standard library `log` | Structured logging with `github.com/sirupsen/logrus` |\n| **Configuration** | JSON files with `encoding/json` | YAML with `gopkg.in/yaml.v3` |\n\n**B. Recommended File/Module Structure**\n\nOrganize your secret management system with clear separation of concerns from the beginning:\n\n```\nsecret-manager/\n├── cmd/\n│   └── secret-server/\n│       └── main.go                 ← Entry point and server startup\n├── internal/\n│   ├── config/\n│   │   ├── config.go              ← Configuration loading and validation\n│   │   └── config_test.go\n│   ├── storage/\n│   │   ├── storage.go             ← Storage interface definition\n│   │   ├── file_storage.go        ← Filesystem storage implementation\n│   │   └── storage_test.go\n│   ├── crypto/\n│   │   ├── envelope.go            ← Envelope encryption implementation\n│   │   ├── keys.go                ← Key generation and management\n│   │   └── crypto_test.go\n│   ├── auth/\n│   │   ├── authenticator.go       ← Authentication interface\n│   │   ├── token_auth.go          ← Token-based authentication\n│   │   └── auth_test.go\n│   ├── policy/\n│   │   ├── evaluator.go           ← Policy evaluation engine\n│   │   ├── policy.go              ← Policy data structures\n│   │   └── policy_test.go\n│   └── server/\n│       ├── server.go              ← HTTP server and routing\n│       ├── handlers.go            ← HTTP request handlers\n│       └── server_test.go\n├── pkg/\n│   └── client/\n│       ├── client.go              ← Client library for applications\n│       └── client_test.go\n├── configs/\n│   ├── server.yaml                ← Server configuration template\n│   └── policies.yaml             ← Example policy configurations\n└── scripts/\n    ├── setup.sh                  ← Development environment setup\n    └── generate-certs.sh         ← TLS certificate generation\n```\n\n**C. Infrastructure Starter Code**\n\nHere's a complete configuration management system to handle server settings and policy loading:\n\n```go\n// internal/config/config.go\npackage config\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"time\"\n)\n\n// ServerConfig holds all configuration for the secret management server\ntype ServerConfig struct {\n    Server struct {\n        Address     string        `json:\"address\"`\n        Port        int           `json:\"port\"`\n        TLSCertFile string        `json:\"tls_cert_file\"`\n        TLSKeyFile  string        `json:\"tls_key_file\"`\n        ReadTimeout time.Duration `json:\"read_timeout\"`\n    } `json:\"server\"`\n    \n    Storage struct {\n        Type string `json:\"type\"` // \"file\", \"etcd\", \"consul\"\n        Path string `json:\"path\"` // For file storage\n        URL  string `json:\"url\"`  // For distributed storage\n    } `json:\"storage\"`\n    \n    Encryption struct {\n        MasterKeyFile string `json:\"master_key_file\"`\n        Algorithm     string `json:\"algorithm\"` // \"aes-256-gcm\"\n    } `json:\"encryption\"`\n    \n    Auth struct {\n        Methods []string `json:\"methods\"` // [\"token\", \"mtls\"]\n        TokenTTL time.Duration `json:\"token_ttl\"`\n    } `json:\"auth\"`\n}\n\n// LoadConfig reads configuration from the specified file path\nfunc LoadConfig(configPath string) (*ServerConfig, error) {\n    file, err := os.Open(configPath)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to open config file: %w\", err)\n    }\n    defer file.Close()\n    \n    var config ServerConfig\n    decoder := json.NewDecoder(file)\n    if err := decoder.Decode(&config); err != nil {\n        return nil, fmt.Errorf(\"failed to parse config file: %w\", err)\n    }\n    \n    if err := config.validate(); err != nil {\n        return nil, fmt.Errorf(\"invalid configuration: %w\", err)\n    }\n    \n    return &config, nil\n}\n\n// validate ensures all required configuration fields are present and valid\nfunc (c *ServerConfig) validate() error {\n    if c.Server.Address == \"\" {\n        c.Server.Address = \"localhost\"\n    }\n    if c.Server.Port == 0 {\n        c.Server.Port = 8443\n    }\n    if c.Server.ReadTimeout == 0 {\n        c.Server.ReadTimeout = 30 * time.Second\n    }\n    \n    if c.Storage.Type == \"\" {\n        c.Storage.Type = \"file\"\n    }\n    if c.Storage.Type == \"file\" && c.Storage.Path == \"\" {\n        c.Storage.Path = \"./data\"\n    }\n    \n    if c.Encryption.Algorithm == \"\" {\n        c.Encryption.Algorithm = \"aes-256-gcm\"\n    }\n    \n    if len(c.Auth.Methods) == 0 {\n        c.Auth.Methods = []string{\"token\"}\n    }\n    if c.Auth.TokenTTL == 0 {\n        c.Auth.TokenTTL = 24 * time.Hour\n    }\n    \n    return nil\n}\n```\n\nComplete HTTP server foundation with security headers and logging:\n\n```go\n// internal/server/server.go\npackage server\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"net/http\"\n    \"time\"\n    \n    \"secret-manager/internal/config\"\n)\n\n// SecretServer handles HTTP requests for the secret management system\ntype SecretServer struct {\n    config *config.ServerConfig\n    server *http.Server\n    // TODO: Add encryption engine, auth engine, storage backend\n}\n\n// NewSecretServer creates a new secret management server\nfunc NewSecretServer(cfg *config.ServerConfig) *SecretServer {\n    mux := http.NewServeMux()\n    \n    server := &http.Server{\n        Addr:         fmt.Sprintf(\"%s:%d\", cfg.Server.Address, cfg.Server.Port),\n        Handler:      securityMiddleware(loggingMiddleware(mux)),\n        ReadTimeout:  cfg.Server.ReadTimeout,\n        WriteTimeout: cfg.Server.ReadTimeout,\n        IdleTimeout:  cfg.Server.ReadTimeout * 2,\n    }\n    \n    s := &SecretServer{\n        config: cfg,\n        server: server,\n    }\n    \n    s.setupRoutes(mux)\n    return s\n}\n\n// setupRoutes configures all HTTP endpoints\nfunc (s *SecretServer) setupRoutes(mux *http.ServeMux) {\n    // Health check endpoint\n    mux.HandleFunc(\"/v1/health\", s.handleHealth)\n    \n    // Secret management endpoints (to be implemented in later milestones)\n    mux.HandleFunc(\"/v1/secret/\", s.handleSecret)\n    mux.HandleFunc(\"/v1/auth/\", s.handleAuth)\n    mux.HandleFunc(\"/v1/policy/\", s.handlePolicy)\n}\n\n// Start begins serving HTTP requests\nfunc (s *SecretServer) Start() error {\n    fmt.Printf(\"Secret server starting on %s\\n\", s.server.Addr)\n    \n    if s.config.Server.TLSCertFile != \"\" && s.config.Server.TLSKeyFile != \"\" {\n        return s.server.ListenAndServeTLS(s.config.Server.TLSCertFile, s.config.Server.TLSKeyFile)\n    }\n    \n    return s.server.ListenAndServe()\n}\n\n// Shutdown gracefully stops the server\nfunc (s *SecretServer) Shutdown(ctx context.Context) error {\n    return s.server.Shutdown(ctx)\n}\n\n// Security middleware adds essential security headers\nfunc securityMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n        w.Header().Set(\"X-Frame-Options\", \"DENY\")\n        w.Header().Set(\"X-XSS-Protection\", \"1; mode=block\")\n        w.Header().Set(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\")\n        \n        next.ServeHTTP(w, r)\n    })\n}\n\n// Logging middleware logs all requests for audit purposes\nfunc loggingMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n        \n        next.ServeHTTP(w, r)\n        \n        fmt.Printf(\"[%s] %s %s %s %v\\n\",\n            time.Now().Format(time.RFC3339),\n            r.Method,\n            r.URL.Path,\n            r.RemoteAddr,\n            time.Since(start))\n    })\n}\n```\n\n**D. Core Logic Skeleton Code**\n\nThe main server initialization logic that you'll expand throughout the milestones:\n\n```go\n// cmd/secret-server/main.go\npackage main\n\nimport (\n    \"context\"\n    \"flag\"\n    \"fmt\"\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n    \"time\"\n    \n    \"secret-manager/internal/config\"\n    \"secret-manager/internal/server\"\n)\n\nfunc main() {\n    configPath := flag.String(\"config\", \"configs/server.json\", \"Path to configuration file\")\n    flag.Parse()\n    \n    // TODO 1: Load and validate configuration from file\n    cfg, err := config.LoadConfig(*configPath)\n    if err != nil {\n        fmt.Printf(\"Failed to load configuration: %v\\n\", err)\n        os.Exit(1)\n    }\n    \n    // TODO 2: Initialize storage backend based on configuration\n    // This will be implemented in Milestone 1\n    \n    // TODO 3: Initialize encryption engine with master key\n    // This will be implemented in Milestone 1\n    \n    // TODO 4: Initialize authentication and policy engines\n    // This will be implemented in Milestone 2\n    \n    // TODO 5: Initialize dynamic secret engines\n    // This will be implemented in Milestone 3\n    \n    // TODO 6: Check if vault is sealed and require unsealing\n    // This will be implemented in Milestone 4\n    \n    secretServer := server.NewSecretServer(cfg)\n    \n    // Start server in background goroutine\n    go func() {\n        if err := secretServer.Start(); err != nil {\n            fmt.Printf(\"Server failed: %v\\n\", err)\n            os.Exit(1)\n        }\n    }()\n    \n    // Wait for shutdown signal\n    sigChan := make(chan os.Signal, 1)\n    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n    <-sigChan\n    \n    fmt.Println(\"Shutting down server...\")\n    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n    defer cancel()\n    \n    if err := secretServer.Shutdown(ctx); err != nil {\n        fmt.Printf(\"Forced shutdown: %v\\n\", err)\n        os.Exit(1)\n    }\n    \n    fmt.Println(\"Server stopped gracefully\")\n}\n```\n\n**E. Language-Specific Hints**\n\n- **Configuration Management**: Use `encoding/json` for simple setups or `gopkg.in/yaml.v3` for more complex configurations with comments and multi-line strings\n- **HTTP Security**: Always use TLS in production; the `crypto/tls` package provides excellent defaults with `tls.Config{MinVersion: tls.VersionTLS12}`\n- **Error Handling**: Wrap errors with context using `fmt.Errorf(\"operation failed: %w\", err)` to maintain error chains\n- **Graceful Shutdown**: Use `context.WithTimeout()` for server shutdown to ensure connections close properly\n- **File Operations**: Use `os.OpenFile()` with specific permissions (0600 for secret files) and always `defer file.Close()`\n- **Memory Security**: Use `crypto/rand` for all random number generation; never use `math/rand` for security-sensitive operations\n\n**F. Milestone Checkpoint**\n\nAfter implementing the foundational components described in this section, you should achieve these verification points:\n\n**Basic Server Startup:**\n```bash\ngo run cmd/secret-server/main.go -config configs/server.json\n```\nExpected output:\n```\nSecret server starting on localhost:8443\n[2024-01-01T12:00:00Z] GET /v1/health 127.0.0.1:54321 2.1ms\n```\n\n**Health Check Verification:**\n```bash\ncurl -k https://localhost:8443/v1/health\n```\nExpected response:\n```json\n{\"status\": \"ok\", \"version\": \"1.0.0\", \"timestamp\": \"2024-01-01T12:00:00Z\"}\n```\n\n**Configuration Validation:**\nCreate a test configuration file with invalid settings to verify error handling works correctly. The server should refuse to start with clear error messages.\n\n**Security Headers Verification:**\n```bash\ncurl -I -k https://localhost:8443/v1/health\n```\nVerify response includes security headers:\n```\nX-Content-Type-Options: nosniff\nX-Frame-Options: DENY\nStrict-Transport-Security: max-age=31536000; includeSubDomains\n```\n\n**Signs of Problems and Diagnostics:**\n- **Server won't start**: Check configuration file syntax with `json.Valid()` or a JSON validator\n- **TLS errors**: Verify certificate files exist and have correct permissions (readable by server process)\n- **Port binding failures**: Ensure no other process is using the configured port with `netstat -tlnp | grep :8443`\n- **Configuration not loading**: Add debug logging to see exactly which configuration values are being loaded\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** This section establishes the foundation for all milestones by defining system scope and success criteria that guide implementation decisions.\n\nBefore diving into the technical architecture, we must clearly establish what this secret management system will and will not do. Think of this as the **system charter** — a contract between the development team and stakeholders that prevents scope creep while ensuring we build something genuinely useful. Just as a bank vault has specific purposes (storing valuables, controlling access) and explicit limitations (not a safety deposit box for oversized items), our secret management system must have clear boundaries.\n\nThe goals we define here directly influence every architectural decision throughout the project. They determine which security models we implement, what performance characteristics we optimize for, and which features we deliberately exclude to maintain focus and simplicity.\n\n### Functional Goals\n\nThese are the **core capabilities** our secret management system must deliver to be considered successful. Each functional goal maps to specific milestones and acceptance criteria, ensuring our implementation stays focused on essential features.\n\n#### Secret Storage and Retrieval\n\nThe system must provide **secure, versioned storage** for sensitive data with strong encryption guarantees. Think of this as building a digital safe deposit box where each secret has its own compartment, complete history, and tamper-evident seals.\n\n| Capability | Description | Acceptance Criteria |\n|------------|-------------|-------------------|\n| Encrypted Storage | All secrets encrypted at rest using AES-256-GCM | No plaintext secrets in storage backend |\n| Secret Versioning | Maintain complete history of secret value changes | Retrieve any previous version by ID |\n| Key Rotation | Replace encryption keys without service interruption | All secrets re-encrypted with new keys |\n| Atomic Operations | Secret updates succeed completely or fail completely | No partial writes during failures |\n\nThe **envelope encryption** model forms the security foundation here. The master key encrypts data encryption keys, which in turn encrypt individual secrets. This creates multiple security layers — even if storage is compromised, secrets remain protected by the master key hierarchy.\n\n> **Decision: Envelope Encryption Architecture**\n> - **Context**: Secrets need encryption at rest, but managing individual keys per secret creates complexity\n> - **Options Considered**: \n>   1. Single master key encrypts all secrets directly\n>   2. Envelope encryption with master key protecting data keys\n>   3. Per-secret encryption keys stored separately\n> - **Decision**: Envelope encryption with hierarchical key structure\n> - **Rationale**: Provides key rotation without re-encrypting all data, isolates key management from data encryption, enables fine-grained access control\n> - **Consequences**: Adds complexity but enables secure key rotation and better security isolation\n\n#### Access Control and Authentication\n\nThe system must implement **zero-trust authentication** and **path-based authorization** to ensure only authorized clients can access specific secrets. Consider this like a bank's security model — every person must identify themselves, and their identity determines which safe deposit boxes they can access.\n\n| Authentication Method | Use Case | Security Properties |\n|----------------------|----------|-------------------|\n| Token-based | Service-to-service communication | Revocable, time-limited, auditable |\n| Mutual TLS | High-security environments | Certificate-based identity, network encryption |\n| AppRole | CI/CD and automated systems | Role-based with secret delivery separation |\n\nThe **policy evaluation engine** implements path-based access control using glob patterns. For example, a policy might grant the `web-service` role access to `secrets/production/web/*` but deny access to `secrets/production/database/*`. This fine-grained control ensures secrets follow the principle of least privilege.\n\n> **Decision: Path-Based Access Control**\n> - **Context**: Need flexible authorization that scales with organizational structure\n> - **Options Considered**:\n>   1. Role-based access control with fixed permission sets\n>   2. Path-based ACLs with pattern matching\n>   3. Attribute-based access control with complex rules\n> - **Decision**: Path-based ACLs with glob pattern support\n> - **Rationale**: Maps naturally to secret organization, easy to understand and audit, performant evaluation\n> - **Consequences**: Enables intuitive permission models but requires careful pattern design to avoid overly broad access\n\n#### Dynamic Secret Generation\n\nThe system must generate **short-lived credentials** on demand for external systems like databases and cloud providers. Think of this as a **credential vending machine** — insert a valid request token, receive fresh credentials that automatically expire.\n\n| Backend Type | Generated Credential | Lifecycle Management |\n|-------------|-------------------|-------------------|\n| Database | Username/password with limited privileges | Auto-revocation on lease expiry |\n| Cloud Provider | API keys with scoped permissions | Cleanup via provider APIs |\n| SSH | Certificate-based access | Certificate expiration handling |\n\nThe **lease management system** tracks every generated credential with time-to-live (TTL) limits. Background processes automatically revoke expired credentials, preventing credential accumulation in external systems. This solves the credential rotation problem by making credentials inherently temporary.\n\n#### High Availability and Disaster Recovery\n\nThe system must operate reliably in distributed environments with **automatic failover** and **data durability** guarantees. Picture this as building multiple bank branches that stay synchronized — if one location fails, others continue serving customers with complete access to their accounts.\n\n| Availability Feature | Implementation | Recovery Time |\n|---------------------|----------------|---------------|\n| Leader Election | Raft consensus algorithm | < 30 seconds failover |\n| Data Replication | Write-ahead logging with quorum | Zero data loss with majority |\n| Backup and Restore | Encrypted backup snapshots | Point-in-time recovery |\n| Auto-unseal | Cloud KMS integration | Automatic startup after restart |\n\n### Non-Functional Goals\n\nThese **quality attributes** define how well the system performs its functional capabilities. Non-functional goals often drive architectural decisions more than functional requirements — they determine whether we choose simplicity or performance, consistency or availability.\n\n#### Security Properties\n\nThe system must maintain **defense in depth** with multiple security layers protecting against various attack vectors. Security isn't a feature we add later — it's a foundational property that influences every design decision.\n\n| Security Property | Target | Measurement |\n|------------------|--------|-------------|\n| Encryption at Rest | AES-256-GCM for all stored data | No plaintext secrets in storage |\n| Encryption in Transit | TLS 1.3 for all client communication | Certificate validation required |\n| Authentication | Multi-factor verification | Token + certificate validation |\n| Audit Logging | Complete access trail | Every secret operation logged |\n| Memory Protection | Clear sensitive data after use | Zero sensitive data in memory dumps |\n\n> The critical security principle here is **assume breach** — design as if attackers will eventually access the storage backend, network traffic, or even application memory. Every protection layer should remain effective even if other layers are compromised.\n\n#### Performance and Scalability\n\nThe system must handle production workloads with **predictable latency** and **horizontal scaling** capabilities. Performance goals must be realistic — we're not building a high-frequency trading system, but we need consistent response times for application startup and credential rotation.\n\n| Performance Metric | Target | Rationale |\n|-------------------|--------|-----------|\n| Secret Retrieval Latency | < 100ms P95 | Acceptable for application startup |\n| Dynamic Secret Generation | < 500ms P95 | Database connection establishment time |\n| Throughput | 1000 requests/second/node | Supports moderate application load |\n| Storage Efficiency | < 10KB overhead per secret | Reasonable metadata storage cost |\n\n#### Operational Simplicity\n\nThe system must be **operationally manageable** with clear deployment procedures, monitoring capabilities, and troubleshooting guides. Complex systems that work perfectly in development often fail in production due to operational complexity.\n\n| Operational Aspect | Requirement | Benefit |\n|-------------------|-------------|---------|\n| Single Binary Deployment | No external runtime dependencies | Simplified installation and updates |\n| Configuration Management | File-based with validation | Version control and audit trails |\n| Health Check Endpoints | HTTP endpoints for load balancers | Automated health monitoring |\n| Structured Logging | JSON format with correlation IDs | Centralized log aggregation |\n| Metrics Export | Prometheus-compatible metrics | Performance monitoring and alerting |\n\n### Explicit Non-Goals\n\nThese are **intentional limitations** we accept to maintain focus and avoid over-engineering. Explicitly stating what we won't build is as important as defining what we will build — it prevents feature creep and keeps the implementation manageable.\n\n#### Enterprise Features (Out of Scope)\n\nWe deliberately exclude enterprise-grade features that add significant complexity without providing core value for the learning objectives.\n\n| Excluded Feature | Rationale | Alternative |\n|-----------------|-----------|-------------|\n| Multi-tenancy | Adds namespace isolation complexity | Deploy separate instances per tenant |\n| LDAP/Active Directory | Complex integration with legacy systems | Focus on token and certificate auth |\n| Hardware Security Modules | Requires specialized hardware | Use cloud KMS for production |\n| GUI/Web Interface | Frontend development outside scope | CLI and REST API provide full functionality |\n| Plugin Architecture | Dynamic loading adds security and complexity | Built-in backends only |\n\n> **Decision: No Plugin Architecture**\n> - **Context**: Extensibility through plugins versus built-in secret backends\n> - **Options Considered**:\n>   1. Dynamic plugin loading with shared libraries\n>   2. Compile-time plugin registration\n>   3. Fixed set of built-in backends\n> - **Decision**: Built-in backends only (database, cloud providers)\n> - **Rationale**: Avoids security risks of dynamic code loading, reduces operational complexity, sufficient for learning objectives\n> - **Consequences**: Less extensible but more secure and simpler to operate\n\n#### Advanced Cryptographic Features\n\nWe focus on proven, standard cryptographic primitives rather than implementing cutting-edge or specialized crypto features.\n\n| Excluded Crypto Feature | Rationale | Standard Alternative |\n|------------------------|-----------|-------------------|\n| Zero-Knowledge Proofs | Complex math, limited practical benefit | Standard authentication tokens |\n| Homomorphic Encryption | Academic complexity, performance issues | Decrypt for processing |\n| Custom Cipher Implementations | High risk of implementation bugs | Standard library AES-GCM |\n| Post-Quantum Cryptography | Standards still evolving | Current NIST recommendations |\n\n#### Performance Optimization (Deferred)\n\nWe prioritize correctness and security over extreme performance optimization. A working, secure system is more valuable than a fast, broken one.\n\n| Optimization Not Implemented | Rationale | Acceptable Trade-off |\n|------------------------------|-----------|-------------------|\n| Connection Pooling | Adds complexity to backend implementations | Slight performance overhead acceptable |\n| Caching Layer | Cache invalidation and consistency challenges | Acceptable latency increase |\n| Horizontal Sharding | Distributed system complexity | Single cluster handles target load |\n| Async Processing | Complicates error handling and consistency | Synchronous operations simpler |\n\n#### Cloud-Specific Features\n\nWe build a cloud-agnostic system rather than optimizing for specific cloud provider features.\n\n| Cloud Feature | Exclusion Reason | Generic Alternative |\n|--------------|------------------|-------------------|\n| AWS IAM Integration | Vendor lock-in, complex permission mapping | Generic token authentication |\n| GCP Service Accounts | Platform-specific authentication flow | Mutual TLS certificates |\n| Azure Key Vault | Managed service, reduces learning value | Self-managed encryption |\n| Kubernetes Secrets | Platform coupling, different security model | HTTP API works with any orchestrator |\n\n> The philosophy here is **build once, deploy anywhere**. While cloud-native features provide operational benefits, they couple the system to specific platforms and reduce the educational value of implementing core secret management concepts.\n\n### Success Criteria and Validation\n\nTo ensure we meet our goals, we define **measurable success criteria** for each functional goal and **validation procedures** to verify achievement.\n\n| Goal Category | Success Metric | Validation Method |\n|--------------|---------------|------------------|\n| Security | All secrets encrypted with AES-256-GCM | Audit storage backend for plaintext |\n| Access Control | Policy violations return 403 Forbidden | Attempt unauthorized secret access |\n| Dynamic Secrets | Database credentials expire within TTL | Monitor external system user tables |\n| High Availability | < 30 second failover during leader failure | Kill leader node, measure recovery time |\n| Performance | Secret retrieval under 100ms P95 | Load testing with realistic workloads |\n\n### Implementation Guidance\n\nThis guidance helps translate our high-level goals into concrete development tasks and validation steps.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|----------------|\n| HTTP Server | `net/http` with middleware | `gin-gonic/gin` framework |\n| Configuration | `encoding/json` with structs | `spf13/viper` with validation |\n| Database Backend | `database/sql` with SQLite | PostgreSQL with connection pooling |\n| Testing Framework | Standard `testing` package | `stretchr/testify` with assertions |\n| Logging | Standard `log/slog` package | `uber-go/zap` structured logging |\n\n#### Goal Validation Checklist\n\nUse this checklist after each milestone to verify you're meeting the established goals:\n\n**Milestone 1 Validation (Encrypted Storage):**\n```bash\n# Verify encryption at rest\ngo test ./internal/encryption -v\n# Check no plaintext in storage\nstrings vault.db | grep -v \"expected_metadata\" | head -20\n# Should show only encrypted binary data, no readable secrets\n```\n\n**Milestone 2 Validation (Access Control):**\n```bash\n# Test unauthorized access returns 403\ncurl -k https://localhost:8443/v1/secrets/test\n# Should return: {\"error\": \"missing or invalid token\"}\n\n# Test policy enforcement\ncurl -k -H \"X-Vault-Token: invalid\" https://localhost:8443/v1/secrets/test  \n# Should return: {\"error\": \"permission denied\"}\n```\n\n**Milestone 3 Validation (Dynamic Secrets):**\n```bash\n# Generate database credentials\ncurl -k -H \"X-Vault-Token: $ROOT_TOKEN\" \\\n  https://localhost:8443/v1/database/creds/my-role\n# Should return: {\"username\": \"v-root-my-role-XYZ\", \"password\": \"...\", \"lease_id\": \"...\"}\n\n# Verify TTL enforcement (wait for expiration)\n# Check that generated user is removed from database\n```\n\n**Milestone 4 Validation (High Availability):**\n```bash\n# Test unsealing with key shares\n./vault operator unseal $SHARE_1\n./vault operator unseal $SHARE_2  \n./vault operator unseal $SHARE_3\n# Should transition from sealed to active state\n\n# Test failover (requires multi-node setup)\n# Kill leader, verify standby promotion within 30 seconds\n```\n\n#### Common Implementation Pitfalls\n\n⚠️ **Pitfall: Scope Creep During Development**\nIt's tempting to add \"just one more feature\" when you see how easy it would be to implement. Resist this urge — every additional feature adds complexity, testing overhead, and potential security vulnerabilities. Stick to the defined functional goals and defer enhancements until the core system is solid.\n\n⚠️ **Pitfall: Premature Performance Optimization**  \nDon't implement caching, connection pooling, or async processing until you've measured actual performance problems. These optimizations add complexity that makes debugging harder and often introduce subtle bugs. Build a correct, simple system first, then optimize specific bottlenecks with measurement data.\n\n⚠️ **Pitfall: Security Theater vs. Real Security**\nAvoid implementing security features that look impressive but don't address real threats. For example, custom encryption algorithms or complex authentication schemes often introduce vulnerabilities. Focus on proven security practices: standard crypto libraries, defense in depth, and comprehensive audit logging.\n\n⚠️ **Pitfall: Ignoring Operational Requirements**\nA system that works perfectly on your laptop but requires complex deployment procedures will fail in production. Design for operations from the beginning: single binary deployment, clear configuration, health checks, and structured logging. These aren't \"nice to have\" features — they're essential for any production system.\n\n#### File Structure for Goal-Driven Development\n\nOrganize your code to reflect the functional goals, making it easy to work on one capability at a time:\n\n```\nvault-system/\n├── cmd/vault/main.go              ← Single binary entry point\n├── internal/\n│   ├── server/                    ← HTTP server and routing (Goal: API access)\n│   │   ├── server.go\n│   │   └── handlers.go\n│   ├── encryption/                ← Encryption engine (Goal: Secure storage)\n│   │   ├── envelope.go\n│   │   └── rotation.go\n│   ├── auth/                      ← Authentication system (Goal: Access control)\n│   │   ├── tokens.go\n│   │   └── policies.go\n│   ├── dynamic/                   ← Dynamic secrets (Goal: Credential generation)\n│   │   ├── database.go\n│   │   └── leases.go\n│   ├── unsealing/                 ← HA and unsealing (Goal: Availability)\n│   │   ├── shamir.go\n│   │   └── consensus.go\n│   └── storage/                   ← Storage backends\n│       └── backend.go\n├── configs/                       ← Configuration examples\n│   └── vault.json\n└── docs/                         ← Goal validation procedures\n    └── testing.md\n```\n\nThis structure makes it clear which code relates to which functional goal, enabling focused development and easier validation of individual capabilities.\n\n\n## High-Level Architecture\n\n> **Milestone(s):** This section provides the architectural foundation for all four milestones, establishing the component structure and security boundaries that will guide implementation across encrypted storage (Milestone 1), access control (Milestone 2), dynamic secrets (Milestone 3), and high availability (Milestone 4).\n\nThe high-level architecture of our secret management system follows a **defense in depth** security model, where multiple layers of protection work together to create a **zero-trust system**. Think of it like a modern bank: the vault has multiple independent security systems (cameras, motion sensors, time locks, armed guards), and each system can detect different types of threats. If one system fails, the others continue protecting the assets.\n\nOur secret management system employs the same principle with four distinct subsystems, each responsible for a specific aspect of security. The encryption engine ensures that even if someone gains access to the storage, they cannot read the secrets. The authentication and authorization engine ensures that only verified identities with proper permissions can access secrets. The dynamic secret engine minimizes exposure by generating short-lived credentials. The unsealing mechanism ensures that the system cannot operate without human authorization, preventing automated attacks.\n\n### Component Overview\n\nThe secret management system is built around four main subsystems that work together to provide comprehensive secret protection. Each subsystem has clear responsibilities and operates with minimal trust assumptions about the others.\n\n**The Four Core Subsystems:**\n\n| Subsystem | Primary Responsibility | Security Purpose | Data Owned |\n|-----------|----------------------|------------------|------------|\n| API Server | HTTP request handling and routing | Entry point validation and protocol termination | Request/response formatting, TLS certificates |\n| Encryption Engine | Secret encryption, decryption, and key management | Confidentiality and integrity of stored data | Master keys, data encryption keys, encrypted secrets |\n| Authentication & Authorization Engine | Identity verification and policy enforcement | Access control and audit trail | Policies, tokens, identity mappings, audit logs |\n| Storage Backend | Persistent data storage and retrieval | Durability and consistency of encrypted data | Raw encrypted data, metadata, configuration |\n\nThink of these subsystems like the departments in a secure facility. The **API Server** is like the front desk—it receives all requests, verifies that visitors are following proper protocols, and routes them to the appropriate department. It doesn't make security decisions but ensures that all communication follows established procedures.\n\nThe **Encryption Engine** is like the vault mechanism itself—it knows how to lock and unlock the safes, manages the combination codes, and ensures that anything stored is properly secured. It never decides who can access what, but it guarantees that unauthorized access is impossible even if someone breaks into the storage room.\n\nThe **Authentication & Authorization Engine** is like the security department—it maintains the list of authorized personnel, checks credentials, and decides whether each person should have access to specific areas. It creates audit trails but doesn't handle the actual storage or encryption of assets.\n\nThe **Storage Backend** is like the physical infrastructure—the walls, floors, and filing systems that hold everything. It provides reliable storage but doesn't understand what it's storing or who should access it.\n\n> **Design Insight**: This separation follows the principle of **single responsibility** at the subsystem level. Each component can be secured, tested, and potentially replaced independently. For example, we could swap from a local file storage backend to a distributed database without changing the encryption or authorization logic.\n\n**Detailed Component Responsibilities:**\n\nThe **API Server** subsystem handles all external communication and protocol concerns. It terminates TLS connections, parses HTTP requests, validates request formats, and serializes responses. This component implements rate limiting, request logging, and connection management. It routes authenticated requests to appropriate internal subsystems but never accesses secret data directly. The API server also handles the system's sealed/unsealed state, rejecting most operations when the system is sealed.\n\nThe **Encryption Engine** subsystem manages all cryptographic operations using **envelope encryption**. It maintains the master key hierarchy, generates and rotates data encryption keys, and performs AES-256-GCM encryption/decryption operations. This component handles secret versioning, allowing multiple versions of the same secret path to coexist during key rotation. It also manages secure memory operations, ensuring that plaintext secrets and encryption keys are properly zeroed after use.\n\nThe **Authentication & Authorization Engine** subsystem implements a complete identity and access management system. It supports multiple authentication methods (tokens, mutual TLS, AppRole), maintains policy definitions with path-based access control, and evaluates authorization requests. This component generates and validates access tokens, maintains session state, and produces comprehensive audit logs. It implements the policy evaluation engine that matches requests against defined rules.\n\nThe **Storage Backend** subsystem provides persistent, reliable storage for all system data. It stores encrypted secrets, policy definitions, token metadata, and system configuration. This component handles atomic operations, consistency guarantees, and backup/restore functionality. It implements key-value storage with support for transactions and range queries needed by higher-level components.\n\n> **Decision: Component Communication Model**\n> - **Context**: The four subsystems need to communicate reliably while maintaining security boundaries and enabling independent testing.\n> - **Options Considered**: \n>   1. Direct function calls within a monolithic process\n>   2. Message passing through internal channels\n>   3. Internal API calls over localhost HTTP\n> - **Decision**: Direct function calls with well-defined interfaces\n> - **Rationale**: Function calls provide the lowest latency and highest reliability for internal communication. They enable atomic operations across subsystems and simplify error handling. Interface-based design still allows for independent testing through mocking.\n> - **Consequences**: All subsystems must run in the same process, but we gain performance and transactional consistency. Future scaling would require refactoring to a distributed model.\n\n| Communication Option | Latency | Reliability | Testability | Complexity | Chosen? |\n|---------------------|---------|-------------|-------------|------------|---------|\n| Direct function calls | Lowest | Highest | Good (mockable interfaces) | Low | ✓ |\n| Message passing | Medium | Good | Excellent | Medium | ✗ |\n| Internal HTTP | Highest | Medium | Excellent | High | ✗ |\n\n### Security Boundaries\n\nThe secret management system implements multiple security boundaries to create **defense in depth**. Think of these boundaries like the security zones in a government facility—each zone has different clearance requirements, and moving between zones requires additional verification. Even if an attacker compromises one zone, they still cannot access resources in higher-security zones.\n\n**Trust Zones and Privilege Separation:**\n\n| Trust Zone | Components | Data Access | Privilege Level | Threat Model |\n|------------|------------|-------------|-----------------|---------------|\n| External Zone | Client applications, operators | None (encrypted requests only) | No privileges | Untrusted network, compromised clients |\n| API Boundary | API Server, TLS termination | Request metadata, routing info | Limited (protocol handling) | Network attacks, protocol exploits |\n| Application Zone | Auth Engine, API routing | Policies, tokens, encrypted secrets | Medium (business logic) | Logic bugs, injection attacks |\n| Cryptographic Zone | Encryption Engine | Plaintext secrets, encryption keys | Highest (key material) | Memory dumps, side-channel attacks |\n| Storage Zone | Storage Backend | Raw encrypted data only | Low (persistence only) | Storage compromise, backup theft |\n\nThe **External Zone** represents completely untrusted territory. Client applications, even those with valid credentials, operate in this zone. All communication crosses the network and is assumed to be observable by attackers. Clients receive only encrypted responses and must prove their identity for every request.\n\nThe **API Boundary** is the first line of defense within the system. The API Server component operates here, handling TLS termination and basic request validation. This component can see request metadata and routing information but never accesses plaintext secrets. It implements rate limiting and basic attack detection, protecting the inner zones from malicious or malformed requests.\n\nThe **Application Zone** contains the business logic components: the Authentication & Authorization Engine and API request routing. Components in this zone can access policy information, token metadata, and encrypted secret data, but they cannot decrypt secrets without coordinating with the Cryptographic Zone. This separation ensures that authorization bugs cannot directly expose plaintext secret data.\n\nThe **Cryptographic Zone** represents the highest privilege level within the system. Only the Encryption Engine operates here, and it has access to master keys and can produce plaintext secrets. This component uses secure memory handling, implements constant-time operations where appropriate, and minimizes the lifetime of plaintext data in memory.\n\nThe **Storage Zone** operates with intentionally limited privileges. The Storage Backend can persist and retrieve data but cannot interpret the encrypted contents. This ensures that storage compromise or backup theft cannot directly expose secret values—the attacker would also need access to the encryption keys from the Cryptographic Zone.\n\n**Inter-Zone Communication Security:**\n\nCommunication between zones follows strict protocols designed to minimize privilege escalation risks. The API Server validates all external requests before forwarding them to internal components. The Authentication Engine verifies identity and authorization before allowing any secret access. The Encryption Engine only decrypts secrets after receiving valid authorization tokens from the Authentication Engine.\n\n> **Critical Security Principle**: **Assume breach** at every boundary. Each zone assumes that external zones may be compromised and implements defenses accordingly. The Encryption Engine assumes that API requests might be forged, so it requires cryptographically signed authorization tokens. The Storage Backend assumes that application logic might be compromised, so it never stores plaintext data.\n\n**Memory Protection and Data Handling:**\n\nWithin each zone, components implement appropriate data protection measures. The Cryptographic Zone uses secure memory allocation and explicit zeroing of sensitive data. The Application Zone implements constant-time comparison for token validation to prevent timing attacks. The Storage Zone ensures that temporary buffers used for I/O operations are cleared after use.\n\n| Security Boundary | Protection Mechanism | Attack Prevention | Recovery Method |\n|-------------------|---------------------|-------------------|-----------------|\n| Network boundary | Mutual TLS, certificate validation | Man-in-the-middle, eavesdropping | Certificate rotation, connection retry |\n| Process boundary | Memory isolation, secure allocation | Memory dumps, cross-process access | Process restart, memory encryption |\n| Component boundary | Interface contracts, input validation | Injection, privilege escalation | Component isolation, audit logging |\n| Storage boundary | Encryption at rest, access controls | Storage compromise, backup theft | Key rotation, encrypted backups |\n\n### Deployment Topology\n\nThe secret management system supports multiple deployment topologies to balance security, availability, and operational requirements. The architecture accommodates everything from single-node development environments to highly available production clusters with geographic distribution.\n\n**Single Node Deployment:**\n\nFor development and small-scale production environments, all four subsystems run within a single process on one machine. Think of this like a small bank branch where one building contains the vault, teller windows, security office, and records storage. Everything is co-located, which simplifies operations but creates a single point of failure.\n\n| Component | Process Location | Data Storage | Network Access |\n|-----------|------------------|--------------|----------------|\n| API Server | Main process (port 8443) | None (stateless) | External clients |\n| Encryption Engine | Main process (in-memory) | Local file system | Internal only |\n| Auth & Policy Engine | Main process (in-memory) | Local file system | Internal only |\n| Storage Backend | Main process (file I/O) | Local disk (encrypted) | Internal only |\n\nThe single-node deployment stores the master key on local disk, protected by file system permissions and encryption. Secret data, policies, and audit logs are stored as encrypted files in a configurable directory structure. This topology provides the simplest operational model but requires careful backup procedures since all system state exists on one machine.\n\n**High Availability Cluster Deployment:**\n\nFor production environments requiring high availability, the system can operate as a cluster with multiple nodes. This resembles a banking network where multiple branches can serve customers, but they coordinate through a central system to maintain consistency. One node acts as the active leader while others remain on standby, ready to take over if the leader fails.\n\n| Node Role | Active Components | Data Replication | Client Access |\n|-----------|------------------|------------------|---------------|\n| Leader | All four subsystems | Writes to storage, replicates to followers | Serves all requests |\n| Follower | Storage Backend, limited API Server | Receives replicated data | Read-only operations (optional) |\n| Standby | All subsystems (inactive) | Maintains current state | No client access |\n\nThe high availability deployment uses a **consensus protocol** to coordinate between nodes and ensure that only one leader is active at a time. This prevents **split-brain scenarios** where multiple nodes might accept conflicting write operations. The leader performs all cryptographic operations and policy decisions, while follower nodes maintain synchronized copies of the encrypted data.\n\n> **Decision: Leader-Follower vs Active-Active Architecture**\n> - **Context**: High availability requires coordination between multiple nodes, but secret management has strict consistency requirements.\n> - **Options Considered**:\n>   1. Active-active with conflict resolution\n>   2. Leader-follower with automatic failover\n>   3. Manual failover with cold standby\n> - **Decision**: Leader-follower with automatic failover\n> - **Rationale**: Secret management requires strict consistency—conflicting policy changes or overlapping dynamic secret generation could create security vulnerabilities. Leader-follower ensures linearizable operations while still providing automatic recovery.\n> - **Consequences**: Write operations are limited to leader capacity, but we maintain consistency guarantees and enable automated failover.\n\n**Network Architecture and Client Routing:**\n\nClients connect to the cluster through a **load balancer** or **service discovery mechanism** that routes requests to the current leader. The load balancer performs health checks to detect leader changes and automatically redirects traffic during failover events. Follower nodes can optionally serve read-only requests for policies and audit logs, reducing load on the leader.\n\n| Traffic Type | Routing Strategy | Consistency Level | Failover Behavior |\n|--------------|------------------|-------------------|-------------------|\n| Secret read/write | Leader only | Strict consistency | Redirect to new leader |\n| Policy evaluation | Leader preferred, follower acceptable | Eventually consistent | Best-effort routing |\n| Audit log queries | Any node | Eventually consistent | Round-robin distribution |\n| Health checks | All nodes | Local state | Per-node response |\n\nThe network topology implements **defense in depth** at the infrastructure level. All inter-node communication uses mutual TLS with node-specific certificates. Client connections require valid certificates and are rate-limited per identity. Network segmentation isolates the secret management cluster from other systems, with firewall rules allowing only necessary ports.\n\n**Data Distribution and Replication:**\n\nThe cluster maintains **strong consistency** for critical data while allowing **eventual consistency** for less sensitive information. Secret data, policies, and encryption keys are replicated synchronously to ensure that failover doesn't lose recent changes. Audit logs and configuration data can be replicated asynchronously to improve write performance.\n\n| Data Type | Replication Mode | Consistency Requirement | Storage Location |\n|-----------|------------------|-------------------------|------------------|\n| Secrets (encrypted) | Synchronous | Strong consistency | Leader + all followers |\n| Encryption keys | Synchronous | Strong consistency | Leader + all followers |\n| Policies | Synchronous | Strong consistency | Leader + all followers |\n| Tokens/sessions | Synchronous | Strong consistency | Leader + all followers |\n| Audit logs | Asynchronous | Eventually consistent | All nodes + external system |\n| Configuration | Asynchronous | Eventually consistent | All nodes |\n\n**Disaster Recovery and Backup Strategy:**\n\nThe deployment topology supports multiple levels of backup and recovery. Regular **encrypted backups** capture the complete system state, including all secrets, policies, and configuration. These backups are encrypted with separate keys and stored in geographically distributed locations. For critical environments, **cross-region replication** maintains live copies of the data in multiple data centers.\n\nThe **unsealing process** is designed to work with the distributed topology. Shamir's secret sharing key shares are distributed among multiple operators across different locations. During disaster recovery, operators can unseal a restored cluster without requiring access to the original master key material, since the key is reconstructed from the distributed shares.\n\n> **Operational Insight**: The deployment topology directly impacts the unsealing workflow. In a single-node deployment, all key shares might be held by operators in one location. In a distributed deployment, key shares should be distributed geographically to ensure that natural disasters or regional outages don't prevent unsealing operations.\n\n**Scaling Characteristics and Resource Requirements:**\n\nDifferent deployment topologies have distinct scaling characteristics and resource requirements. The single-node deployment scales vertically by adding CPU and memory to handle more concurrent requests. The cluster deployment scales primarily through read replicas, since write operations are constrained by the leader's capacity and the consensus protocol overhead.\n\n| Deployment Type | CPU Utilization | Memory Requirements | Storage I/O | Network Bandwidth |\n|-----------------|-----------------|---------------------|-------------|-------------------|\n| Single node | Moderate (all operations) | High (in-memory caching) | High (all writes local) | Low (no replication) |\n| HA leader | High (all write operations) | High (in-memory state) | High (writes + replication) | High (replication traffic) |\n| HA follower | Low (replication only) | Medium (replicated state) | Medium (replicated writes) | Medium (replication inbound) |\n\n### Implementation Guidance\n\nThe high-level architecture maps to a modular Go codebase that separates concerns while enabling efficient communication between subsystems. Each subsystem is implemented as a separate package with well-defined interfaces, making the system testable and maintainable.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|------------------|\n| HTTP Server | net/http with gorilla/mux routing | Custom HTTP/2 server with connection pooling |\n| Storage Backend | Local JSON files with file locking | Distributed key-value store (etcd, Consul) |\n| Cryptography | Go crypto/aes and crypto/rand | Hardware security module (HSM) integration |\n| Clustering | Single node with file persistence | Raft consensus with distributed storage |\n| TLS/Authentication | Go crypto/tls with static certificates | Dynamic certificate management with rotation |\n| Configuration | YAML files with validation | Dynamic configuration with hot reloading |\n\n**Recommended File Structure:**\n\nThe codebase follows Go's standard project layout with clear separation between public APIs, internal implementation, and supporting tools:\n\n```\nsecret-vault/\n├── cmd/\n│   ├── server/\n│   │   └── main.go              ← Server entry point, configuration loading\n│   └── cli/\n│       └── main.go              ← Client CLI tool for operators\n├── internal/\n│   ├── server/\n│   │   ├── server.go            ← SecretServer implementation\n│   │   └── config.go            ← ServerConfig and LoadConfig\n│   ├── api/\n│   │   ├── handlers.go          ← HTTP request handlers\n│   │   ├── middleware.go        ← Authentication, logging middleware\n│   │   └── routes.go            ← Route definitions and registration\n│   ├── encryption/\n│   │   ├── engine.go            ← Envelope encryption implementation\n│   │   ├── keys.go              ← Key generation and rotation\n│   │   └── versioning.go        ← Secret version management\n│   ├── auth/\n│   │   ├── engine.go            ← Authentication and authorization\n│   │   ├── policies.go          ← Policy definition and evaluation\n│   │   ├── tokens.go            ← Token generation and validation\n│   │   └── audit.go             ← Audit logging\n│   ├── storage/\n│   │   ├── backend.go           ← Storage interface definition\n│   │   ├── file.go              ← File-based storage implementation\n│   │   └── memory.go            ← In-memory storage for testing\n│   ├── dynamic/\n│   │   ├── engine.go            ← Dynamic secret generation\n│   │   ├── database.go          ← Database credential backend\n│   │   └── leases.go            ← Lease management and TTL tracking\n│   └── unseal/\n│       ├── shamir.go            ← Shamir's secret sharing\n│       ├── seal.go              ← Seal/unseal operations\n│       └── ha.go                ← High availability and consensus\n├── pkg/\n│   └── client/\n│       └── client.go            ← Go client library for applications\n├── configs/\n│   ├── dev.yaml                 ← Development configuration\n│   └── prod.yaml               ← Production configuration template\n└── scripts/\n    ├── generate-certs.sh        ← TLS certificate generation\n    └── init-cluster.sh          ← Cluster initialization\n```\n\n**Core Configuration Structure:**\n\nThe system configuration uses a hierarchical structure that maps to the component architecture:\n\n```go\n// ServerConfig holds all configuration for the secret management server\ntype ServerConfig struct {\n    Server     ServerSettings     `yaml:\"server\"`\n    Storage    StorageSettings    `yaml:\"storage\"`\n    Encryption EncryptionSettings `yaml:\"encryption\"`\n    Auth       AuthSettings       `yaml:\"auth\"`\n    Cluster    ClusterSettings    `yaml:\"cluster\"`\n}\n\ntype ServerSettings struct {\n    Port         int           `yaml:\"port\"`\n    TLSCertPath  string        `yaml:\"tls_cert_path\"`\n    TLSKeyPath   string        `yaml:\"tls_key_path\"`\n    ReadTimeout  time.Duration `yaml:\"read_timeout\"`\n    WriteTimeout time.Duration `yaml:\"write_timeout\"`\n}\n\ntype StorageSettings struct {\n    Backend   string            `yaml:\"backend\"`  // \"file\", \"memory\", \"etcd\"\n    Config    map[string]string `yaml:\"config\"`   // Backend-specific settings\n    BackupDir string            `yaml:\"backup_dir\"`\n}\n\ntype EncryptionSettings struct {\n    KeySize      int    `yaml:\"key_size\"`      // 256 for AES-256\n    MasterKeyPath string `yaml:\"master_key_path\"`\n    AutoRotate   bool   `yaml:\"auto_rotate\"`\n}\n\ntype AuthSettings struct {\n    Methods      []string      `yaml:\"methods\"`       // [\"token\", \"mtls\", \"approle\"]\n    TokenTTL     time.Duration `yaml:\"token_ttl\"`\n    PolicyDir    string        `yaml:\"policy_dir\"`\n    AuditLogPath string        `yaml:\"audit_log_path\"`\n}\n\ntype ClusterSettings struct {\n    Enabled     bool     `yaml:\"enabled\"`\n    NodeID      string   `yaml:\"node_id\"`\n    Peers       []string `yaml:\"peers\"`\n    DataDir     string   `yaml:\"data_dir\"`\n    BindAddress string   `yaml:\"bind_address\"`\n}\n```\n\n**Main Server Implementation Skeleton:**\n\n```go\n// SecretServer represents the main secret management server with all subsystems\ntype SecretServer struct {\n    config      ServerConfig\n    httpServer  *http.Server\n    \n    // Core subsystems - each implemented as a separate component\n    storage     storage.Backend\n    encryption  *encryption.Engine\n    auth        *auth.Engine\n    dynamic     *dynamic.Engine\n    unseal      *unseal.Manager\n    \n    // Server state\n    isSealed    bool\n    sealMutex   sync.RWMutex\n}\n\n// LoadConfig reads and validates configuration from the specified file path\nfunc LoadConfig(configPath string) (ServerConfig, error) {\n    // TODO 1: Read YAML file from configPath\n    // TODO 2: Parse YAML into ServerConfig struct\n    // TODO 3: Validate all required fields are present\n    // TODO 4: Apply default values for optional fields (DEFAULT_PORT, DEFAULT_TIMEOUT)\n    // TODO 5: Validate that certificate files exist if TLS is enabled\n    // TODO 6: Return validated configuration or descriptive error\n}\n\n// NewSecretServer creates a new server instance with the provided configuration\nfunc NewSecretServer(cfg ServerConfig) (*SecretServer, error) {\n    // TODO 1: Initialize storage backend based on cfg.Storage.Backend\n    // TODO 2: Create encryption engine with master key from cfg.Encryption\n    // TODO 3: Initialize auth engine with policy directory from cfg.Auth\n    // TODO 4: Create dynamic secret engine for credential generation\n    // TODO 5: Initialize unseal manager for Shamir's secret sharing\n    // TODO 6: Create HTTP server with TLS configuration\n    // TODO 7: Register HTTP routes connecting to subsystem handlers\n    // TODO 8: Return configured SecretServer instance\n    //\n    // Hint: Server starts in sealed state - unseal operation required before serving secrets\n}\n\n// Start begins serving HTTP requests on the configured port\nfunc (s *SecretServer) Start() error {\n    // TODO 1: Verify server is properly configured (all subsystems initialized)\n    // TODO 2: Start background processes (lease renewal, audit log rotation)\n    // TODO 3: Begin listening on configured port with TLS\n    // TODO 4: Log startup message with server version and configuration summary\n    //\n    // Note: Server will reject secret operations until unsealed, but health checks work\n}\n\n// Shutdown gracefully stops the server and cleans up resources\nfunc (s *SecretServer) Shutdown(ctx context.Context) error {\n    // TODO 1: Stop accepting new HTTP connections\n    // TODO 2: Wait for existing requests to complete (up to context deadline)\n    // TODO 3: Stop background processes (lease management, audit logging)\n    // TODO 4: Seal the server (clear encryption keys from memory)\n    // TODO 5: Close storage backend and flush any pending writes\n    // TODO 6: Return any errors encountered during shutdown\n}\n```\n\n**Subsystem Interface Definitions:**\n\nEach subsystem exposes a clean interface that abstracts its internal complexity:\n\n```go\n// Storage backend interface - abstracts persistence mechanism\ntype Backend interface {\n    Get(ctx context.Context, key string) ([]byte, error)\n    Put(ctx context.Context, key string, value []byte) error\n    Delete(ctx context.Context, key string) error\n    List(ctx context.Context, prefix string) ([]string, error)\n    Transaction(ctx context.Context, ops []Operation) error\n}\n\n// Encryption engine interface - handles all cryptographic operations\ntype Engine interface {\n    Encrypt(ctx context.Context, plaintext []byte, path string) (*EncryptedData, error)\n    Decrypt(ctx context.Context, encrypted *EncryptedData) ([]byte, error)\n    RotateKeys(ctx context.Context) error\n    GetKeyVersion(ctx context.Context) (int, error)\n}\n\n// Authentication engine interface - identity and access control\ntype Engine interface {\n    Authenticate(ctx context.Context, credentials interface{}) (*Identity, error)\n    Authorize(ctx context.Context, identity *Identity, action string, path string) error\n    CreateToken(ctx context.Context, identity *Identity, ttl time.Duration) (string, error)\n    ValidateToken(ctx context.Context, token string) (*Identity, error)\n}\n```\n\n**Constants and Defaults:**\n\n```go\nconst (\n    DEFAULT_PORT    = 8443                  // HTTPS port for secret management\n    DEFAULT_TIMEOUT = 30 * time.Second      // HTTP request timeout\n    \n    // Encryption constants\n    AES_KEY_SIZE = 32  // 256 bits for AES-256\n    GCM_NONCE_SIZE = 12  // 96 bits for AES-GCM\n    \n    // Authentication constants\n    TOKEN_HEADER = \"X-Vault-Token\"\n    DEFAULT_TOKEN_TTL = 1 * time.Hour\n    \n    // Storage constants\n    SECRET_PREFIX = \"secret/\"\n    POLICY_PREFIX = \"policy/\"\n    TOKEN_PREFIX = \"token/\"\n)\n```\n\n**Milestone Checkpoints:**\n\nAfter implementing the basic server structure, verify these behaviors:\n\n1. **Configuration Loading**: Run `go run cmd/server/main.go -config configs/dev.yaml` - server should start and log configuration summary\n2. **TLS Endpoint**: Test with `curl -k https://localhost:8443/v1/sys/health` - should return sealed status\n3. **Component Integration**: Check logs for successful initialization of all four subsystems\n4. **Graceful Shutdown**: Send SIGTERM and verify clean shutdown with resource cleanup\n\n**Language-Specific Implementation Hints:**\n\n- Use `sync.RWMutex` for the sealed state - multiple readers can check seal status concurrently, but unsealing requires exclusive write access\n- Implement `context.Context` support throughout for request timeouts and cancellation\n- Use `crypto/rand.Reader` for all random number generation - never use `math/rand` for cryptographic operations  \n- Store sensitive data in `[]byte` slices and explicitly zero them with `for i := range data { data[i] = 0 }` after use\n- Use `encoding/yaml` for configuration parsing with struct tags for validation\n- Implement proper error wrapping with `fmt.Errorf(\"operation failed: %w\", err)` for error context\n\n![System Architecture Overview](./diagrams/system-architecture.svg)\n\n![High Availability Cluster Topology](./diagrams/ha-cluster-topology.svg)\n\n\n## Data Model\n\n> **Milestone(s):** This section establishes the core data structures that are implemented across all milestones, with specific focus on encrypted storage (Milestone 1), access control structures (Milestone 2), and dynamic secret management (Milestone 3).\n\nThe data model forms the foundational layer of our secret management system, defining how secrets, policies, tokens, and leases are structured, stored, and related to each other. Think of the data model as the **blueprint for a multi-vault bank** - it specifies not just how individual safety deposit boxes (secrets) are constructed, but also how access cards (tokens), security policies, and time-limited access passes (leases) work together to create a comprehensive security system.\n\nUnderstanding this data model is crucial because every component of our system - from the encryption engine to the authentication system to the dynamic secret generators - operates on these core data structures. The model must balance security requirements (encrypted storage, access control) with operational needs (versioning, auditing, high availability) while maintaining the flexibility to support different types of secrets and backends.\n\n![Data Model Relationships](./diagrams/data-model-relationships.svg)\n\n### Secret Storage Model\n\nThe secret storage model defines how secrets are versioned, encrypted, and persisted in our system. This model must address the fundamental challenge of **envelope encryption** while supporting secret versioning for operational safety and key rotation scenarios.\n\n#### Mental Model: The Nested Safe System\n\nThink of our secret storage like a **high-security bank with nested safes**. The bank has a master vault (master key) that protects individual safety deposit boxes (data encryption keys), and each safety deposit box contains multiple versions of a customer's valuables (secret versions). When a customer wants to access their valuables, the bank uses its master key to open the safety deposit box, retrieves the individual container key (data encryption key), and then uses that key to unlock the specific version of the valuables they need.\n\nThis nested approach means that even if someone gains access to the encrypted safety deposit box contents, they still can't read the valuables without the master vault key. Similarly, if the master key needs to be changed (key rotation), the bank can re-encrypt all the safety deposit box keys without touching each individual valuable.\n\n#### Secret Entity Structure\n\nThe `Secret` entity represents a logical secret path with all its versions and metadata. Each secret acts as a container for multiple encrypted versions, supporting both operational rollbacks and zero-downtime key rotation.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `Path` | `string` | Unique secret identifier (e.g., \"database/prod/password\") |\n| `Versions` | `[]SecretVersion` | Ordered list of secret versions, newest first |\n| `CurrentVersion` | `int` | Version number of the active secret value |\n| `MaxVersions` | `int` | Maximum versions to retain (older versions auto-pruned) |\n| `CreatedAt` | `time.Time` | Timestamp when secret was first created |\n| `UpdatedAt` | `time.Time` | Timestamp of most recent version addition |\n| `CreatedBy` | `string` | Identity that created this secret path |\n| `DeletedAt` | `*time.Time` | Soft deletion timestamp (nil if not deleted) |\n| `Metadata` | `map[string]string` | User-defined key-value pairs for secret categorization |\n| `CASRequired` | `bool` | Whether check-and-set is required for updates |\n\nThe secret path follows a hierarchical naming convention similar to file systems, enabling policy engines to apply path-based access controls using wildcard patterns. The versioning system ensures that secret updates never overwrite existing values immediately, providing safety during deployment rollbacks and key rotation operations.\n\n#### Secret Version Structure\n\nEach `SecretVersion` represents a specific encrypted value of a secret at a point in time, along with all metadata necessary for decryption and audit trails.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `Version` | `int` | Monotonically increasing version number |\n| `EncryptedValue` | `[]byte` | Secret value encrypted with data encryption key |\n| `KeyVersion` | `int` | Version of data encryption key used for this secret |\n| `Algorithm` | `string` | Encryption algorithm (typically \"AES-256-GCM\") |\n| `Nonce` | `[]byte` | Cryptographic nonce used for authenticated encryption |\n| `AuthData` | `[]byte` | Additional authenticated data (secret path + version) |\n| `CreatedAt` | `time.Time` | Timestamp when this version was created |\n| `CreatedBy` | `string` | Identity that created this version |\n| `TTL` | `time.Duration` | Time-to-live for this version (zero means no expiration) |\n| `Checksum` | `[]byte` | SHA-256 hash of plaintext for integrity verification |\n\nThe `AuthData` field contains the secret path and version number, providing cryptographic binding between the encrypted value and its identity. This prevents attackers from copying encrypted values between different secret paths or versions. The checksum enables integrity verification after decryption without storing plaintext.\n\n#### Data Encryption Key Structure\n\nThe `DataEncryptionKey` (DEK) represents the keys used to encrypt individual secrets, which are themselves encrypted by the master key in our envelope encryption scheme.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `Version` | `int` | Unique version number for this key |\n| `EncryptedKey` | `[]byte` | The DEK encrypted with current master key |\n| `Algorithm` | `string` | DEK algorithm (typically \"AES-256\") |\n| `MasterKeyVersion` | `int` | Version of master key used to encrypt this DEK |\n| `CreatedAt` | `time.Time` | Timestamp when this key version was generated |\n| `Status` | `string` | Key lifecycle status (active, rotating, deprecated) |\n| `UsageCount` | `int64` | Number of secrets encrypted with this key (for rotation triggers) |\n\nThe key versioning system enables gradual key rotation without service disruption. During rotation, new secrets use the latest key version while existing secrets continue using their original keys until they are naturally updated or explicitly re-encrypted.\n\n> **Decision: Envelope Encryption with Versioned Data Keys**\n> - **Context**: Secrets must be encrypted at rest, and we need to support key rotation without re-encrypting every secret simultaneously\n> - **Options Considered**: \n>   1. Single master key encrypts all secrets directly\n>   2. Envelope encryption with versioned data encryption keys\n>   3. Per-secret random keys encrypted with master key\n> - **Decision**: Envelope encryption with versioned data encryption keys\n> - **Rationale**: Enables gradual key rotation, limits master key exposure, and provides operational flexibility for key management. Per-secret keys would create too much key management overhead, while single master key rotation would require atomic re-encryption of all secrets.\n> - **Consequences**: Adds complexity with key versioning but enables zero-downtime key rotation and better security isolation.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Direct master key encryption | Simple implementation, fewer keys to manage | Key rotation requires re-encrypting all secrets atomically | No |\n| Envelope encryption with versioned DEKs | Gradual rotation, operational flexibility, limited master key exposure | More complex key management, additional storage overhead | **Yes** |\n| Per-secret random keys | Maximum isolation, simple rotation per secret | Excessive key storage, complex key lifecycle management | No |\n\n### Access Control Model\n\nThe access control model defines how identities are authenticated, policies are structured, and authorization decisions are made. This model implements a **path-based access control** system that combines the flexibility of wildcard matching with the security of explicit policy definitions.\n\n#### Mental Model: The Corporate Badge System\n\nThink of our access control like a **modern corporate badge system**. Employees carry access cards (tokens) that identify who they are and which security groups they belong to. The building has policy rules (policies) that specify which badge types can access which areas - for example, \"Engineering badges can access floors 3-5\" or \"Facilities badges can access all floors but only during business hours.\" When someone tries to enter a secured area (access a secret), the card reader (authorization engine) checks their badge against the area's policy rules to make an access decision.\n\nJust as corporate policies use patterns (\"all Engineering areas\" rather than listing every room), our system uses path patterns to efficiently specify access rules across hierarchical secret namespaces.\n\n#### Policy Structure\n\nThe `Policy` entity defines access permissions for secret paths, supporting wildcard patterns and fine-grained capability controls.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `Name` | `string` | Unique policy identifier (e.g., \"database-admin-policy\") |\n| `Rules` | `[]PolicyRule` | List of path-based access rules |\n| `Description` | `string` | Human-readable policy purpose description |\n| `CreatedAt` | `time.Time` | Policy creation timestamp |\n| `UpdatedAt` | `time.Time` | Policy last modification timestamp |\n| `CreatedBy` | `string` | Identity that created this policy |\n| `Version` | `int` | Policy version for audit and rollback purposes |\n\n#### Policy Rule Structure\n\nEach `PolicyRule` specifies capabilities (permissions) for a specific path pattern, enabling fine-grained access control across the secret hierarchy.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `Path` | `string` | Secret path pattern with wildcard support (e.g., \"database/prod/*\") |\n| `Capabilities` | `[]string` | Allowed operations: \"read\", \"write\", \"delete\", \"list\" |\n| `RequiredParameters` | `map[string][]string` | Required request parameters and allowed values |\n| `AllowedParameters` | `map[string][]string` | Optional parameters and their allowed values |\n| `DeniedParameters` | `map[string][]string` | Explicitly forbidden parameters |\n| `MaxTTL` | `time.Duration` | Maximum TTL for secrets created/read under this path |\n| `MinWrappingTTL` | `time.Duration` | Minimum TTL for response wrapping (if supported) |\n\nThe path patterns support glob-style wildcards where `*` matches any characters within a path segment and `**` matches across multiple path segments. The capability system provides standard CRUD operations plus special operations like \"list\" for path enumeration.\n\n#### Token Structure\n\nThe `Token` entity represents authentication credentials issued to identities, carrying policy attachments and usage constraints.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `ID` | `string` | Unique token identifier (cryptographically random) |\n| `Accessor` | `string` | Non-sensitive token reference for audit logs |\n| `Policies` | `[]string` | List of policy names attached to this token |\n| `TokenType` | `string` | Token type: \"service\" (long-lived) or \"batch\" (lightweight) |\n| `CreatedAt` | `time.Time` | Token issuance timestamp |\n| `ExpiresAt` | `*time.Time` | Token expiration (nil for non-expiring service tokens) |\n| `LastUsedAt` | `*time.Time` | Timestamp of most recent token usage |\n| `UsageCount` | `int64` | Number of times token has been used |\n| `MaxUses` | `int` | Maximum number of uses (0 = unlimited) |\n| `Renewable` | `bool` | Whether token TTL can be extended |\n| `ParentToken` | `string` | Token that created this token (for hierarchical revocation) |\n| `DisplayName` | `string` | Human-readable token description |\n| `Metadata` | `map[string]string` | Additional token metadata for audit purposes |\n| `BoundCIDRs` | `[]string` | IP address ranges from which token can be used |\n\nThe token hierarchy supports parent-child relationships, enabling revocation of all child tokens when a parent token is revoked. The accessor field provides a way to reference tokens in audit logs without exposing the actual token value.\n\n#### Identity Structure\n\nThe `Identity` entity represents authenticated principals (users, services, applications) that can be assigned policies and issued tokens.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `ID` | `string` | Unique identity identifier |\n| `Name` | `string` | Human-readable identity name |\n| `Type` | `string` | Identity type: \"user\", \"service\", \"role\" |\n| `AuthMethod` | `string` | Authentication method used: \"token\", \"tls-cert\", \"approle\" |\n| `Policies` | `[]string` | Direct policy attachments for this identity |\n| `Groups` | `[]string` | Group memberships (groups have their own policies) |\n| `CreatedAt` | `time.Time` | Identity creation timestamp |\n| `LastAuthAt` | `*time.Time` | Most recent successful authentication |\n| `AuthCount` | `int64` | Total number of successful authentications |\n| `Metadata` | `map[string]string` | Identity-specific metadata (department, team, etc.) |\n| `Disabled` | `bool` | Whether identity is currently disabled |\n\n> **Decision: Path-Based Access Control with Wildcard Patterns**\n> - **Context**: Need flexible access control that scales across hierarchical secret namespaces without requiring individual rules for every secret path\n> - **Options Considered**:\n>   1. Per-secret explicit permissions (each secret lists authorized identities)\n>   2. Role-based access control with predefined roles\n>   3. Path-based policies with wildcard pattern matching\n> - **Decision**: Path-based policies with wildcard pattern matching\n> - **Rationale**: Provides operational scalability (one policy rule covers many secrets), aligns with hierarchical secret organization, and offers flexibility for dynamic secret paths. RBAC alone would be too rigid for diverse secret access patterns.\n> - **Consequences**: Requires careful policy design to avoid over-broad permissions, and wildcard matching adds complexity to authorization evaluation.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Per-secret explicit permissions | Maximum security granularity | Doesn't scale, management overhead | No |\n| Role-based access control | Simple to understand, common pattern | Too rigid for diverse access needs | No |\n| Path-based wildcard policies | Scales well, flexible, intuitive | Risk of over-broad patterns | **Yes** |\n\n### Dynamic Secret Model\n\nThe dynamic secret model defines how time-limited credentials are generated, tracked, and revoked across different backend systems. This model addresses the challenge of **just-in-time credential provisioning** while maintaining strong lifecycle management and cleanup guarantees.\n\n#### Mental Model: The Credential Vending Machine\n\nThink of dynamic secrets like a **sophisticated vending machine for credentials**. When you need database access, you insert your token (authentication), select the type of access you need (role specification), and the machine generates a fresh set of credentials just for you with an expiration time clearly printed on them (lease). The machine keeps a record of what it dispensed and when it expires (lease tracking), and it has a cleanup crew (revocation engine) that goes around collecting expired credentials and deactivating them in the backend systems.\n\nUnlike static secrets that are like owning a key to a building, dynamic secrets are like getting a temporary visitor badge that automatically expires and gets deactivated - you get exactly the access you need for exactly the time you need it, and the system ensures cleanup happens automatically.\n\n#### Lease Structure\n\nThe `Lease` entity represents the lifecycle of a dynamically generated secret, tracking its validity period and enabling automatic revocation.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `ID` | `string` | Unique lease identifier (cryptographically random) |\n| `SecretType` | `string` | Type of secret: \"database\", \"aws-iam\", \"ssh-key\", etc. |\n| `BackendPath` | `string` | Secret backend that generated this lease (e.g., \"database/prod\") |\n| `RoleName` | `string` | Backend role used for credential generation |\n| `CreatedAt` | `time.Time` | Lease creation timestamp |\n| `ExpiresAt` | `time.Time` | Lease expiration timestamp (never nil for dynamic secrets) |\n| `RenewedAt` | `*time.Time` | Timestamp of most recent renewal |\n| `RenewalCount` | `int` | Number of times lease has been renewed |\n| `MaxTTL` | `time.Duration` | Maximum total lifetime regardless of renewals |\n| `Renewable` | `bool` | Whether this lease can have its TTL extended |\n| `TokenID` | `string` | Token that requested this lease (for audit and revocation) |\n| `RevocationData` | `map[string]interface{}` | Backend-specific data needed for credential cleanup |\n| `SecretData` | `map[string]interface{}` | The actual generated credentials (encrypted at rest) |\n| `Status` | `string` | Lease status: \"active\", \"renewed\", \"expired\", \"revoked\" |\n\nThe `RevocationData` field contains backend-specific information needed to clean up credentials - for database backends, this might include the username and connection parameters; for cloud providers, it might include the user ARN and access key ID.\n\n#### Secret Backend Configuration\n\nThe `SecretBackend` entity defines how dynamic secret engines connect to and manage credentials in external systems.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `Path` | `string` | Backend mount path (e.g., \"database/prod\", \"aws/dev\") |\n| `Type` | `string` | Backend type: \"database\", \"aws\", \"gcp\", \"ssh\", \"pki\" |\n| `Description` | `string` | Human-readable backend description |\n| `Config` | `map[string]interface{}` | Backend-specific configuration (connection strings, etc.) |\n| `DefaultTTL` | `time.Duration` | Default lease duration for secrets from this backend |\n| `MaxTTL` | `time.Duration` | Maximum allowed lease duration |\n| `Roles` | `map[string]BackendRole` | Named roles defining different credential types |\n| `CreatedAt` | `time.Time` | Backend creation timestamp |\n| `UpdatedAt` | `time.Time` | Backend last modification timestamp |\n\nThe backend configuration is encrypted at rest since it contains sensitive connection information like database connection strings, cloud API keys, and service account credentials.\n\n#### Backend Role Configuration\n\nThe `BackendRole` entity defines templates for generating specific types of credentials within a secret backend.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `Name` | `string` | Role name within the backend (e.g., \"readonly\", \"admin\") |\n| `CreationStatements` | `[]string` | Commands to create credentials (SQL, API calls, etc.) |\n| `RevocationStatements` | `[]string` | Commands to revoke/cleanup credentials |\n| `RenewStatements` | `[]string` | Commands to extend credential lifetime (if supported) |\n| `DefaultTTL` | `time.Duration` | Default lease duration for this role |\n| `MaxTTL` | `time.Duration` | Maximum lease duration for this role |\n| `RenewIncrement` | `time.Duration` | TTL increment when renewing leases |\n| `AllowedDomains` | `[]string` | Allowed domains/suffixes for generated usernames |\n| `RoleOptions` | `map[string]interface{}` | Backend-specific role configuration |\n\nFor database backends, the `CreationStatements` might contain SQL commands like `CREATE USER '{{username}}'@'%' IDENTIFIED BY '{{password}}'` where the template variables are replaced with generated values. The revocation statements would contain corresponding cleanup commands.\n\n#### Lease Tracking and Revocation\n\nThe lease management system maintains several tracking structures to enable efficient renewal and revocation operations.\n\nThe `LeaseIndex` provides efficient lookups for lease operations:\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `ByExpiration` | `map[time.Time][]string` | Lease IDs grouped by expiration time buckets |\n| `ByToken` | `map[string][]string` | Lease IDs associated with each token (for token revocation) |\n| `ByBackend` | `map[string][]string` | Lease IDs associated with each backend (for backend cleanup) |\n| `ActiveCount` | `int64` | Total number of active leases (for monitoring) |\n\nThe `RevocationQueue` manages asynchronous cleanup of expired or revoked credentials:\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `LeaseID` | `string` | Lease identifier to revoke |\n| `BackendPath` | `string` | Backend responsible for revocation |\n| `RevocationData` | `map[string]interface{}` | Data needed to clean up credentials |\n| `QueuedAt` | `time.Time` | When revocation was queued |\n| `AttemptCount` | `int` | Number of revocation attempts made |\n| `NextAttempt` | `time.Time` | When to retry revocation (for failed attempts) |\n| `Priority` | `int` | Revocation priority (expired vs. explicitly revoked) |\n\n> **Decision: Lease-Based Dynamic Secret Management**\n> - **Context**: Dynamic secrets need automatic expiration and cleanup without manual intervention, while supporting renewal for long-running operations\n> - **Options Considered**:\n>   1. TTL-based secrets with background cleanup scanning\n>   2. Lease-based tracking with explicit revocation queues\n>   3. Event-driven cleanup with external system notifications\n> - **Decision**: Lease-based tracking with explicit revocation queues\n> - **Rationale**: Provides predictable cleanup guarantees, supports complex renewal patterns, and enables audit trails for credential lifecycle. Background scanning alone cannot handle revocation failures reliably.\n> - **Consequences**: Adds complexity with lease tracking but ensures credential cleanup even when backend systems are temporarily unavailable.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| TTL-based with background scanning | Simple implementation, low storage overhead | No cleanup guarantees, difficult failure handling | No |\n| Lease-based with revocation queues | Reliable cleanup, audit trail, failure recovery | Higher storage overhead, more complex | **Yes** |\n| Event-driven external notifications | Minimal storage, real-time cleanup | Depends on external systems, no retry logic | No |\n\n#### Common Pitfalls\n\n⚠️ **Pitfall: Storing Revocation Data in Secret Data**\nMany implementations mistakenly store backend cleanup information alongside the generated credentials. This creates problems because the secret data is typically returned to clients, potentially exposing internal backend details like connection strings or service account names. The revocation data should be stored separately and never exposed in API responses.\n\n⚠️ **Pitfall: Not Encrypting Backend Configuration**\nBackend configurations contain highly sensitive information like database passwords and cloud API keys. Storing this configuration in plaintext makes it a high-value target for attackers. All backend configuration should be encrypted using the same envelope encryption system as regular secrets.\n\n⚠️ **Pitfall: Ignoring Lease Revocation Failures**\nWhen credential revocation fails (backend is down, network issues, etc.), many systems simply log the error and move on. This leaves orphaned credentials active in backend systems indefinitely. Implement retry logic with exponential backoff and alerting for repeatedly failed revocations.\n\n⚠️ **Pitfall: Unbounded Lease Renewal**\nWithout proper max TTL enforcement, clients can renew leases indefinitely, defeating the purpose of dynamic secrets. Always enforce a maximum total lifetime regardless of renewal count, and consider implementing renewal limits or decay factors.\n\n### Implementation Guidance\n\nThe data model implementation requires careful attention to encryption, serialization, and database schema design. The following guidance provides practical approaches for implementing these structures in Go.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Storage Backend | SQLite with GORM | PostgreSQL with custom queries |\n| Serialization | JSON with struct tags | Protocol Buffers with schema evolution |\n| Encryption Library | crypto/aes + crypto/cipher | github.com/hashicorp/go-kms-wrapping |\n| Key Derivation | crypto/pbkdf2 | golang.org/x/crypto/argon2 |\n| Time Handling | time.Time with UTC | Custom time with nanosecond precision |\n\n#### Recommended File Structure\n\n```\ninternal/\n  storage/\n    models/\n      secret.go          ← Secret and SecretVersion structs\n      policy.go          ← Policy, PolicyRule, Token, Identity structs  \n      lease.go           ← Lease, SecretBackend, BackendRole structs\n      encryption.go      ← DataEncryptionKey and crypto helpers\n    backends/\n      sqlite/\n        migrations/      ← Database schema migration files\n        sqlite.go        ← SQLite storage implementation\n      postgres/\n        postgres.go      ← PostgreSQL storage implementation (future)\n    storage.go           ← Storage interface definition\n  crypto/\n    envelope.go          ← Envelope encryption implementation\n    keys.go              ← Key generation and rotation\n```\n\n#### Core Data Structure Definitions\n\n```go\n// Package models provides the core data structures for secret management.\npackage models\n\nimport (\n\t\"time\"\n\t\"encoding/json\"\n)\n\n// Secret represents a versioned secret with metadata and access control.\ntype Secret struct {\n\tPath           string            `json:\"path\" gorm:\"primaryKey\"`\n\tVersions       []SecretVersion   `json:\"versions\" gorm:\"foreignKey:SecretPath\"`\n\tCurrentVersion int               `json:\"current_version\"`\n\tMaxVersions    int               `json:\"max_versions\" gorm:\"default:10\"`\n\tCreatedAt      time.Time         `json:\"created_at\"`\n\tUpdatedAt      time.Time         `json:\"updated_at\"`\n\tCreatedBy      string            `json:\"created_by\"`\n\tDeletedAt      *time.Time        `json:\"deleted_at,omitempty\"`\n\tMetadata       map[string]string `json:\"metadata\" gorm:\"serializer:json\"`\n\tCASRequired    bool              `json:\"cas_required\"`\n}\n\n// SecretVersion represents a specific encrypted version of a secret value.\ntype SecretVersion struct {\n\tSecretPath     string    `json:\"secret_path\" gorm:\"primaryKey\"`\n\tVersion        int       `json:\"version\" gorm:\"primaryKey\"`\n\tEncryptedValue []byte    `json:\"-\"` // Never serialize in JSON responses\n\tKeyVersion     int       `json:\"key_version\"`\n\tAlgorithm      string    `json:\"algorithm\"`\n\tNonce          []byte    `json:\"-\"` // Never serialize in JSON responses\n\tAuthData       []byte    `json:\"-\"` // Never serialize in JSON responses\n\tCreatedAt      time.Time `json:\"created_at\"`\n\tCreatedBy      string    `json:\"created_by\"`\n\tTTL            time.Duration `json:\"ttl\"`\n\tChecksum       []byte    `json:\"-\"` // Never serialize in JSON responses\n}\n\n// Policy represents access control rules for secret paths.\ntype Policy struct {\n\tName        string       `json:\"name\" gorm:\"primaryKey\"`\n\tRules       []PolicyRule `json:\"rules\" gorm:\"foreignKey:PolicyName\"`\n\tDescription string       `json:\"description\"`\n\tCreatedAt   time.Time    `json:\"created_at\"`\n\tUpdatedAt   time.Time    `json:\"updated_at\"`\n\tCreatedBy   string       `json:\"created_by\"`\n\tVersion     int          `json:\"version\"`\n}\n\n// PolicyRule defines capabilities for a specific path pattern.\ntype PolicyRule struct {\n\tID                 uint              `json:\"-\" gorm:\"primaryKey\"`\n\tPolicyName         string            `json:\"-\"`\n\tPath               string            `json:\"path\"`\n\tCapabilities       []string          `json:\"capabilities\" gorm:\"serializer:json\"`\n\tRequiredParameters map[string][]string `json:\"required_parameters\" gorm:\"serializer:json\"`\n\tAllowedParameters  map[string][]string `json:\"allowed_parameters\" gorm:\"serializer:json\"`\n\tDeniedParameters   map[string][]string `json:\"denied_parameters\" gorm:\"serializer:json\"`\n\tMaxTTL             time.Duration     `json:\"max_ttl\"`\n\tMinWrappingTTL     time.Duration     `json:\"min_wrapping_ttl\"`\n}\n\n// Token represents an authentication credential with policy attachments.\ntype Token struct {\n\tID           string            `json:\"id\" gorm:\"primaryKey\"`\n\tAccessor     string            `json:\"accessor\" gorm:\"uniqueIndex\"`\n\tPolicies     []string          `json:\"policies\" gorm:\"serializer:json\"`\n\tTokenType    string            `json:\"token_type\"`\n\tCreatedAt    time.Time         `json:\"created_at\"`\n\tExpiresAt    *time.Time        `json:\"expires_at,omitempty\"`\n\tLastUsedAt   *time.Time        `json:\"last_used_at,omitempty\"`\n\tUsageCount   int64             `json:\"usage_count\"`\n\tMaxUses      int               `json:\"max_uses\"`\n\tRenewable    bool              `json:\"renewable\"`\n\tParentToken  string            `json:\"parent_token\"`\n\tDisplayName  string            `json:\"display_name\"`\n\tMetadata     map[string]string `json:\"metadata\" gorm:\"serializer:json\"`\n\tBoundCIDRs   []string          `json:\"bound_cidrs\" gorm:\"serializer:json\"`\n}\n```\n\n#### Storage Interface Implementation\n\n```go\n// Package storage defines the interface for persisting secret management data.\npackage storage\n\nimport (\n\t\"context\"\n\t\"time\"\n\t\"your-project/internal/storage/models\"\n)\n\n// Backend defines the interface for secret storage operations.\ntype Backend interface {\n\t// Secret operations\n\tCreateSecret(ctx context.Context, secret *models.Secret) error\n\tGetSecret(ctx context.Context, path string) (*models.Secret, error)\n\tGetSecretVersion(ctx context.Context, path string, version int) (*models.SecretVersion, error)\n\tUpdateSecret(ctx context.Context, path string, version *models.SecretVersion) error\n\tDeleteSecret(ctx context.Context, path string) error\n\tListSecrets(ctx context.Context, pathPrefix string) ([]string, error)\n\t\n\t// Policy operations  \n\tCreatePolicy(ctx context.Context, policy *models.Policy) error\n\tGetPolicy(ctx context.Context, name string) (*models.Policy, error)\n\tUpdatePolicy(ctx context.Context, policy *models.Policy) error\n\tDeletePolicy(ctx context.Context, name string) error\n\tListPolicies(ctx context.Context) ([]string, error)\n\t\n\t// Token operations\n\tCreateToken(ctx context.Context, token *models.Token) error\n\tGetToken(ctx context.Context, id string) (*models.Token, error)\n\tUpdateToken(ctx context.Context, token *models.Token) error\n\tDeleteToken(ctx context.Context, id string) error\n\tDeleteTokensByParent(ctx context.Context, parentID string) error\n\t\n\t// Lease operations\n\tCreateLease(ctx context.Context, lease *models.Lease) error\n\tGetLease(ctx context.Context, id string) (*models.Lease, error)\n\tUpdateLease(ctx context.Context, lease *models.Lease) error\n\tDeleteLease(ctx context.Context, id string) error\n\tGetExpiredLeases(ctx context.Context, before time.Time) ([]*models.Lease, error)\n\tGetLeasesByToken(ctx context.Context, tokenID string) ([]*models.Lease, error)\n\t\n\t// Maintenance operations\n\tClose() error\n}\n\n// TODO: Implement SQLite backend with proper transaction handling\n// TODO: Add connection pooling and prepared statement caching\n// TODO: Implement database migration system for schema updates\n// TODO: Add metrics collection for storage operations\n// TODO: Implement backup and restore functionality\n```\n\n#### Envelope Encryption Helper\n\n```go\n// Package crypto provides envelope encryption for secret values.\npackage crypto\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"errors\"\n\t\"fmt\"\n)\n\nconst (\n\tAES_KEY_SIZE     = 32 // 256-bit keys for AES-256\n\tGCM_NONCE_SIZE   = 12 // 96-bit nonces for GCM\n)\n\n// DataEncryptionKey represents a key used to encrypt secret data.\ntype DataEncryptionKey struct {\n\tVersion          int       `json:\"version\"`\n\tEncryptedKey     []byte    `json:\"encrypted_key\"`\n\tAlgorithm        string    `json:\"algorithm\"`\n\tMasterKeyVersion int       `json:\"master_key_version\"`\n\tCreatedAt        time.Time `json:\"created_at\"`\n\tStatus           string    `json:\"status\"` // active, rotating, deprecated\n\tUsageCount       int64     `json:\"usage_count\"`\n}\n\n// EnvelopeEncryption handles the encryption and decryption of secrets using envelope encryption.\ntype EnvelopeEncryption struct {\n\tmasterKey []byte // Current master key (AES-256)\n\tkeyVersion int   // Current master key version\n}\n\n// TODO: Initialize envelope encryption with master key loaded from secure storage\n// TODO: Implement master key rotation with gradual DEK re-encryption\n// TODO: Add key derivation from password using Argon2 (for development/testing)\n// TODO: Integrate with cloud KMS for master key protection (auto-unseal)\n\n// EncryptSecret encrypts a plaintext secret using envelope encryption.\n// Returns encrypted data, nonce, and additional authenticated data.\nfunc (e *EnvelopeEncryption) EncryptSecret(plaintext []byte, path string, version int, dekVersion int) ([]byte, []byte, []byte, error) {\n\t// TODO 1: Generate or retrieve data encryption key for dekVersion\n\t// TODO 2: Generate random nonce for AES-GCM (12 bytes)\n\t// TODO 3: Create additional authenticated data from path + version\n\t// TODO 4: Create AES-GCM cipher with DEK\n\t// TODO 5: Encrypt plaintext with nonce and additional authenticated data\n\t// TODO 6: Return ciphertext, nonce, and auth data\n\treturn nil, nil, nil, errors.New(\"not implemented\")\n}\n\n// DecryptSecret decrypts an encrypted secret using envelope encryption.\nfunc (e *EnvelopeEncryption) DecryptSecret(ciphertext, nonce, authData []byte, dekVersion int) ([]byte, error) {\n\t// TODO 1: Retrieve and decrypt data encryption key for dekVersion\n\t// TODO 2: Create AES-GCM cipher with decrypted DEK\n\t// TODO 3: Decrypt ciphertext using nonce and auth data for verification\n\t// TODO 4: Verify checksum if provided (optional integrity check)\n\t// TODO 5: Securely zero DEK from memory after use\n\treturn nil, errors.New(\"not implemented\")\n}\n\n// GenerateDataEncryptionKey creates a new data encryption key encrypted with the master key.\nfunc (e *EnvelopeEncryption) GenerateDataEncryptionKey(version int) (*DataEncryptionKey, error) {\n\t// TODO 1: Generate random 256-bit key for AES-256 using crypto/rand\n\t// TODO 2: Encrypt the DEK with current master key using AES-GCM\n\t// TODO 3: Create DataEncryptionKey struct with metadata\n\t// TODO 4: Securely zero the plaintext DEK from memory\n\treturn nil, errors.New(\"not implemented\")\n}\n```\n\n#### Database Migration Example\n\n```sql\n-- Migration 001: Initial secret management schema\n-- File: internal/storage/backends/sqlite/migrations/001_initial.sql\n\n-- Secrets table with versioning support\nCREATE TABLE secrets (\n    path TEXT PRIMARY KEY,\n    current_version INTEGER NOT NULL DEFAULT 1,\n    max_versions INTEGER NOT NULL DEFAULT 10,\n    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by TEXT NOT NULL,\n    deleted_at DATETIME,\n    metadata TEXT, -- JSON encoded map[string]string\n    cas_required BOOLEAN NOT NULL DEFAULT FALSE\n);\n\n-- Secret versions table storing encrypted values\nCREATE TABLE secret_versions (\n    secret_path TEXT NOT NULL,\n    version INTEGER NOT NULL,\n    encrypted_value BLOB NOT NULL,\n    key_version INTEGER NOT NULL,\n    algorithm TEXT NOT NULL DEFAULT 'AES-256-GCM',\n    nonce BLOB NOT NULL,\n    auth_data BLOB NOT NULL,\n    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by TEXT NOT NULL,\n    ttl INTEGER DEFAULT 0, -- TTL in nanoseconds, 0 = no expiration\n    checksum BLOB NOT NULL,\n    PRIMARY KEY (secret_path, version),\n    FOREIGN KEY (secret_path) REFERENCES secrets(path) ON DELETE CASCADE\n);\n\n-- Policies table for access control rules\nCREATE TABLE policies (\n    name TEXT PRIMARY KEY,\n    description TEXT,\n    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by TEXT NOT NULL,\n    version INTEGER NOT NULL DEFAULT 1\n);\n\n-- Policy rules table for path-based permissions\nCREATE TABLE policy_rules (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    policy_name TEXT NOT NULL,\n    path TEXT NOT NULL,\n    capabilities TEXT NOT NULL, -- JSON encoded []string\n    required_parameters TEXT,   -- JSON encoded map[string][]string\n    allowed_parameters TEXT,    -- JSON encoded map[string][]string\n    denied_parameters TEXT,     -- JSON encoded map[string][]string\n    max_ttl INTEGER DEFAULT 0,  -- TTL in nanoseconds\n    min_wrapping_ttl INTEGER DEFAULT 0,\n    FOREIGN KEY (policy_name) REFERENCES policies(name) ON DELETE CASCADE\n);\n\n-- Indexes for efficient secret and policy lookups\nCREATE INDEX idx_secrets_path_prefix ON secrets(path);\nCREATE INDEX idx_secret_versions_created_at ON secret_versions(created_at);\nCREATE INDEX idx_policy_rules_path ON policy_rules(path);\nCREATE INDEX idx_policy_rules_policy ON policy_rules(policy_name);\n```\n\n#### Milestone Checkpoints\n\n**After implementing Secret Storage Model:**\n1. Run `go test ./internal/storage/...` - all storage interface tests should pass\n2. Create a test secret: `POST /v1/secret/test` with JSON body `{\"value\": \"test-secret\"}`  \n3. Retrieve the secret: `GET /v1/secret/test` should return the encrypted value decrypted\n4. Verify versioning: Update the same secret and confirm version increments\n5. Check encryption: Examine database directly - secret values should be encrypted blob data\n\n**After implementing Access Control Model:**\n1. Create a policy: `POST /v1/sys/policy/test-policy` with JSON policy rules\n2. Create a token: `POST /v1/auth/token/create` with the policy attached\n3. Test access: Use the token to access secrets matching the policy paths\n4. Test denial: Verify requests outside policy paths return 403 Forbidden\n5. Check audit logs: Confirm all access attempts are logged with token accessor\n\n**After implementing Dynamic Secret Model:**\n1. Configure a database backend: `POST /v1/database/config/test-db` with connection details\n2. Create a role: `POST /v1/database/roles/readonly` with SQL creation statements  \n3. Request credentials: `GET /v1/database/creds/readonly` should return username/password\n4. Verify TTL: Wait for lease expiration and confirm credentials are revoked\n5. Test renewal: Renew lease before expiration and verify extended lifetime\n\n\n## Encryption Engine Design\n\n> **Milestone(s):** This section implements Milestone 1 (Encrypted Secret Storage), focusing on envelope encryption with master keys and data encryption keys, secret versioning, and key rotation mechanisms.\n\nThe encryption engine forms the security heart of our secret management system, implementing a **nested safe system** that protects secrets through multiple layers of encryption. Like a bank that stores valuables in individual safety deposit boxes within a master vault, our system uses envelope encryption to create defense in depth against various attack vectors.\n\n![Envelope Encryption Flow](./diagrams/envelope-encryption-flow.svg)\n\nThe encryption engine must solve several challenging problems simultaneously: protecting secrets at rest while maintaining performance, enabling key rotation without system downtime, supporting secret versioning for backward compatibility, and handling the cryptographic complexity of envelope encryption. Each of these requirements introduces technical constraints that shape our architectural decisions.\n\n### Envelope Encryption Mental Model\n\n**Envelope encryption** operates like a **nested safe system** where you have a master safe containing many smaller safes, each with their own keys. In a physical bank, the master vault key never leaves the secure control room, while individual deposit box keys are generated on demand and can be rotated regularly without touching the master vault.\n\nIn our digital implementation, the **master key** acts like the bank's master vault key - it never directly encrypts user secrets but instead protects a collection of **data encryption keys (DEKs)**. Each DEK is like an individual safety deposit box key that actually encrypts the secrets. When a client stores a secret, we generate a fresh DEK, use it to encrypt the secret, then encrypt the DEK itself with the master key before storing both pieces.\n\nThis separation provides several critical security properties. First, **key rotation isolation** - we can rotate DEKs regularly without touching the master key, and we can rotate the master key by re-encrypting all DEKs without re-encrypting every secret. Second, **blast radius containment** - if a single DEK is compromised, it only affects secrets encrypted with that specific key. Third, **performance optimization** - the expensive master key operations happen infrequently, while the bulk encryption work uses faster symmetric DEKs.\n\nThe envelope structure creates multiple failure points that an attacker must compromise. Even if they gain access to the encrypted secrets and encrypted DEKs in storage, they still need the master key to decrypt the DEKs. Even if they compromise the master key, they must still perform the multi-step decryption process for each secret individually.\n\n> **Critical Security Insight**: The master key should never directly touch user data. This principle ensures that master key compromise requires additional steps to access secrets, buying time for detection and response.\n\n### Key Hierarchy and Rotation\n\nOur encryption system implements a **three-tier key hierarchy** that balances security, performance, and operational flexibility. At the top sits the **master key** - a 256-bit AES key that serves as the root of trust for the entire system. The master key encrypts **data encryption keys (DEKs)**, which are also 256-bit AES keys generated for each encryption operation or time period. Finally, **secret-specific nonces** ensure that identical secrets produce different ciphertext even when encrypted with the same DEK.\n\n| Key Type | Size | Lifetime | Purpose | Rotation Frequency |\n|----------|------|----------|---------|-------------------|\n| Master Key | 256-bit AES | System lifetime | Encrypts DEKs | Yearly or on compromise |\n| Data Encryption Key | 256-bit AES | Configurable (default 30 days) | Encrypts secrets | Monthly or on compromise |\n| Nonce | 96-bit random | Per-operation | Ensures ciphertext uniqueness | Every encryption |\n\nThe **master key lifecycle** follows strict operational procedures. During system initialization, we generate the master key using a cryptographically secure random number generator and immediately split it using Shamir's secret sharing (covered in the unsealing section). The master key remains in memory only while the system is unsealed, and we clear it from memory during system shutdown or sealing operations.\n\n**Data encryption key management** implements a more dynamic lifecycle. We maintain a **DEK rotation schedule** where new DEKs are generated automatically based on time intervals or usage counts. Each DEK has a version number and lifecycle status: `active` for new encryptions, `retired` for decryption-only, and `revoked` for compromised keys. The system maintains multiple DEK versions simultaneously to support decryption of older secrets while using only the latest active DEK for new encryptions.\n\n> **Decision: Time-Based DEK Rotation**\n> - **Context**: We need to determine when to generate new data encryption keys - time-based, usage-based, or administrative triggers\n> - **Options Considered**: \n>   1. Fixed time intervals (daily/weekly/monthly)\n>   2. Usage count thresholds (encrypt N secrets then rotate)\n>   3. Hybrid approach with maximum time and usage limits\n> - **Decision**: Hybrid approach with 30-day maximum lifetime and 10,000 encryption maximum\n> - **Rationale**: Time limits prevent indefinite key usage, usage limits prevent single key from encrypting too much data, hybrid provides flexibility for both high and low volume environments\n> - **Consequences**: Requires tracking both time and usage metrics, provides defense against both long-term cryptanalysis and high-volume attacks\n\n| Rotation Trigger | Threshold | Action Taken | Backward Compatibility |\n|-----------------|-----------|--------------|----------------------|\n| Time Limit | 30 days since creation | Generate new active DEK, mark current as retired | Retired DEKs remain available for decryption |\n| Usage Limit | 10,000 encryptions | Generate new active DEK, mark current as retired | All previous versions remain accessible |\n| Compromise Detection | Administrative command | Immediately revoke DEK, generate replacement | Revoked DEK blocked, secrets must be re-encrypted |\n| Master Key Rotation | Administrative command | Re-encrypt all DEKs with new master key | Transparent to secret access, versions preserved |\n\n**Key rotation algorithms** implement careful state management to prevent data loss during transitions. The rotation process follows these steps:\n\n1. **Pre-rotation validation** - verify the current active DEK exists and system is in healthy state\n2. **New DEK generation** - create new 256-bit key using secure random generator and assign next version number\n3. **Master key encryption** - encrypt the new DEK with current master key and store encrypted version\n4. **Atomic state transition** - update the active DEK pointer and mark previous DEK as retired in a single transaction\n5. **Background cleanup** - optionally re-encrypt old secrets with new DEK based on policy configuration\n6. **Audit logging** - record rotation event with timestamps, versions, and triggering conditions\n\nThe rotation process must handle **concurrent operations gracefully**. During rotation, in-flight encrypt operations complete with the DEK they started with, while new encrypt operations wait for rotation completion before proceeding with the new DEK. Decrypt operations are unaffected since they specify the exact DEK version needed.\n\n### Encrypt/Decrypt Operations\n\nThe **envelope encryption algorithm** implements a carefully orchestrated sequence that ensures both security and performance. Each encryption operation must produce ciphertext that can be decrypted later, track all necessary metadata for the decryption process, and maintain compatibility with secret versioning and key rotation.\n\n**Secret Encryption Process:**\n\n1. **Input validation and preprocessing** - verify the secret path is valid, check secret length limits, and normalize the plaintext data for encryption\n2. **DEK selection** - identify the current active data encryption key version and retrieve the decrypted DEK from secure memory cache\n3. **Nonce generation** - create a 96-bit cryptographically random nonce using the system's secure random number generator\n4. **Associated data preparation** - construct authenticated additional data including secret path, version number, timestamp, and DEK version\n5. **AES-GCM encryption** - encrypt the plaintext secret using AES-256-GCM with the selected DEK, nonce, and associated data\n6. **Metadata packaging** - bundle the ciphertext, nonce, associated data, DEK version, and algorithm identifier for storage\n7. **Storage preparation** - serialize the complete encryption package and compute integrity checksums for corruption detection\n\nThe encryption operation produces a `SecretVersion` structure that contains all information needed for future decryption. The ciphertext itself is opaque, but the metadata provides versioning, integrity checking, and key identification without revealing the secret content.\n\n| Encryption Output Field | Source | Purpose | Security Properties |\n|-------------------------|--------|---------|-------------------|\n| `EncryptedValue` | AES-GCM ciphertext | Encrypted secret data | Confidentiality via AES-256 |\n| `Nonce` | Secure random generator | GCM initialization vector | Prevents ciphertext reuse |\n| `AuthData` | Path + version + timestamp | Authenticated context | Prevents ciphertext substitution |\n| `KeyVersion` | Current active DEK | Identifies decryption key | Supports key rotation |\n| `Algorithm` | Fixed \"AES-256-GCM\" | Crypto algorithm identifier | Enables future algorithm migration |\n| `Checksum` | SHA-256 of complete package | Corruption detection | Integrity verification |\n\n**Secret Decryption Process:**\n\n1. **Metadata extraction** - parse the stored `SecretVersion` to extract DEK version, nonce, associated data, and algorithm identifier\n2. **DEK retrieval** - locate the specified DEK version, decrypt it with the master key if not cached, and verify the DEK is not revoked\n3. **Algorithm verification** - confirm the encryption algorithm is supported and matches expected security parameters\n4. **Associated data reconstruction** - rebuild the authenticated additional data using the same process as encryption\n5. **AES-GCM decryption** - decrypt the ciphertext using AES-256-GCM with the retrieved DEK, stored nonce, and reconstructed associated data\n6. **Integrity verification** - validate the authentication tag and verify the overall package checksum to detect corruption\n7. **Plaintext return** - return the decrypted secret data and clear sensitive values from memory\n\nThe decryption process must handle **version compatibility** across key rotations and system upgrades. Each `SecretVersion` is self-contained with all metadata needed for decryption, ensuring that secrets encrypted months ago can still be decrypted even after multiple key rotations.\n\n> **Critical Implementation Detail**: The associated data must be reconstructed identically during decryption. Any variation in path normalization, timestamp formatting, or version numbering will cause authentication failures that prevent decryption.\n\n**Performance optimization** strategies focus on the expensive cryptographic operations. The system maintains an **in-memory DEK cache** that keeps recently used decrypted DEKs available without requiring master key operations. The cache implements LRU eviction and automatic clearing when DEKs are rotated or revoked. Additionally, **batch operations** can reuse the same DEK for multiple secrets, reducing the per-secret encryption overhead.\n\n**Error handling** during encryption and decryption operations requires careful consideration of information disclosure. Decryption failures should not reveal whether the failure was due to wrong DEK version, corrupted ciphertext, or authentication failures, as this information could aid attackers. Instead, all decryption failures return a generic \"decryption failed\" error while logging detailed failure reasons for administrative debugging.\n\n| Operation | Success Indicators | Failure Modes | Error Response |\n|-----------|-------------------|----------------|----------------|\n| Encrypt | Valid ciphertext + metadata | DEK unavailable, RNG failure, storage error | Specific error for debugging |\n| Decrypt | Valid plaintext | Wrong DEK, corrupt data, auth failure | Generic \"decryption failed\" |\n| DEK Retrieve | DEK in memory or successfully decrypted | Master key unavailable, corrupted DEK | Internal error, retry logic |\n| Nonce Generation | 96 bits of entropy | RNG failure, insufficient entropy | System error, operation blocked |\n\n### Secret Versioning\n\n**Secret versioning** implements a sophisticated system for maintaining historical secret values while supporting key rotation and data migration. Like a document version control system, each secret maintains multiple timestamped versions that can be retrieved independently while sharing common metadata and access policies.\n\nThe versioning system must solve several complex challenges. **Version immutability** ensures that once a secret version is created, its encrypted content cannot be changed - only new versions can be added. **Key rotation compatibility** allows old versions encrypted with rotated keys to remain accessible. **Storage efficiency** prevents unlimited version accumulation from consuming excessive storage. **Access control consistency** ensures that policy changes apply uniformly across all versions of a secret.\n\nEach secret is represented by a `Secret` structure that acts as a container for multiple `SecretVersion` entries. The secret container maintains metadata that applies to all versions: creation timestamp, access policies, maximum version limits, and soft deletion status. Individual versions contain the encrypted data, encryption metadata, and version-specific attributes like TTL and creator identity.\n\n| Secret Container Field | Purpose | Version Scope | Mutability |\n|------------------------|---------|---------------|------------|\n| `Path` | Unique secret identifier | All versions | Immutable after creation |\n| `CurrentVersion` | Latest version number | Container-level | Incremented on updates |\n| `MaxVersions` | Version retention limit | Container-level | Configurable policy |\n| `CreatedAt` | Initial secret creation | Container-level | Immutable |\n| `UpdatedAt` | Last version addition | Container-level | Updated on new versions |\n| `DeletedAt` | Soft deletion timestamp | All versions | Set once, prevents new versions |\n| `Metadata` | User-defined key-value pairs | All versions | Mutable via policy |\n\nThe **version lifecycle** follows a strict progression from creation through active use to eventual cleanup. New versions receive sequential numbers starting from 1, ensuring a total ordering of all changes to the secret. The system maintains a **current version pointer** that identifies the latest version returned for unqualified read operations, while allowing explicit access to any historical version by number.\n\n**Version creation process** implements atomic operations that prevent partial updates and ensure consistency:\n\n1. **Concurrency control** - acquire write lock on the secret path to prevent concurrent version creation\n2. **Validation checks** - verify the secret exists, is not soft-deleted, and has not reached the maximum version limit\n3. **Version number assignment** - increment the current version counter and assign the new number atomically\n4. **Encryption operation** - encrypt the new secret value using current active DEK and create `SecretVersion` structure\n5. **Storage transaction** - store the new version and update container metadata in a single atomic operation\n6. **Index updates** - update secondary indexes for version lookup and ensure audit log entries are created\n7. **Cleanup trigger** - if versions exceed the maximum limit, schedule background cleanup of oldest versions\n\n> **Decision: Sequential Version Numbering vs UUID-Based Versions**\n> - **Context**: Need to uniquely identify secret versions while supporting efficient lookup and ordering\n> - **Options Considered**:\n>   1. Sequential integers (1, 2, 3, ...)\n>   2. UUID-based version identifiers\n>   3. Timestamp-based version numbers\n> - **Decision**: Sequential integers with atomic increment\n> - **Rationale**: Provides natural ordering, enables efficient \"latest N versions\" queries, simplifies client usage patterns, and avoids clock synchronization issues in distributed deployments\n> - **Consequences**: Requires atomic counter management, reveals version creation frequency, but provides predictable and efficient access patterns\n\n**Key rotation impact on versioning** requires careful coordination between the encryption engine and version management. When DEKs are rotated, existing secret versions remain encrypted with their original keys, creating a dependency between version lifetime and key lifetime. The system must ensure that DEK versions remain available for decryption as long as any secret version depends on them.\n\nThe system implements **lazy re-encryption** policies that allow administrators to migrate old secret versions to new keys without impacting system availability. Background processes can iterate through old versions, decrypt them with their original keys, and re-encrypt with current keys while preserving version numbers and metadata.\n\n| Re-encryption Policy | Trigger Conditions | Process | Version Impact |\n|----------------------|-------------------|---------|----------------|\n| Immediate | DEK compromise detected | Re-encrypt all affected versions synchronously | Version numbers preserved, new encryption metadata |\n| Background Lazy | DEK reaches retirement age | Queue versions for background re-encryption | Transparent to clients, gradual migration |\n| On-Access | Version accessed after DEK retirement | Re-encrypt during read operation if policy allows | Single version updated on demand |\n| Manual | Administrative command | Re-encrypt specified secret or version range | Controlled timing, batch operations |\n\n**Version cleanup and retention** policies prevent unlimited storage growth while preserving important historical data. The system supports multiple retention strategies that can be combined based on organizational requirements.\n\nDefault retention keeps the most recent 10 versions of each secret, automatically cleaning up older versions when new ones are created. **Time-based retention** deletes versions older than a specified age, while **usage-based retention** preserves frequently accessed versions regardless of age. **Compliance retention** can mark specific versions as immutable for regulatory requirements.\n\nThe cleanup process implements **safe deletion** that ensures versions are not removed while they might be needed for decryption or audit purposes. Before deleting a version, the system verifies that no active leases reference it, no pending operations depend on it, and the retention policy explicitly allows its removal.\n\n⚠️ **Pitfall: Version Cleanup During Key Rotation**\nDeleting secret versions before their associated DEKs can create permanent data loss. If a secret version is deleted but its DEK is retained for other versions, there's no issue. However, if the DEK is deleted while secret versions still reference it, those versions become permanently undecryptable. The system must maintain reference counts from secret versions to DEK versions and prevent DEK deletion while references exist.\n\n**Version access patterns** support both specific version retrieval and version-relative access. Clients can request version 5 of a secret explicitly, ask for the current version (default behavior), or use relative references like \"previous version\" or \"version from 24 hours ago\". The system translates these relative references into specific version numbers before processing the request.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Master Key in Swap Space**\nStoring the master key in regular memory variables allows the operating system to page that memory to disk swap files, where it persists after the process exits. An attacker with disk access could extract the master key from swap space. Use memory locking syscalls (`mlock` on Unix systems) to prevent sensitive memory pages from being swapped to disk, and explicitly zero memory before freeing it.\n\n⚠️ **Pitfall: DEK Version Race Conditions**\nWhen rotating DEKs, concurrent encryption operations might start with one DEK version but complete with metadata pointing to a different version, creating decryption failures. Always capture the DEK version at the start of the encryption operation and use that same version throughout the entire process. Implement proper locking to ensure version transitions are atomic from the perspective of concurrent operations.\n\n⚠️ **Pitfall: Nonce Reuse Attacks**\nReusing the same nonce with the same DEK completely breaks AES-GCM security, allowing attackers to recover plaintext or forge authenticated data. This can happen if the random number generator fails, if system clocks reset during nonce generation, or if DEK rotation doesn't properly coordinate with nonce generation. Always use a cryptographically secure random number generator for nonce creation, and consider including timestamp or counter components in nonce generation for additional protection.\n\n⚠️ **Pitfall: Associated Data Inconsistency**\nAES-GCM associated data must be identical between encryption and decryption, but subtle differences in path normalization, timestamp formatting, or metadata serialization can cause authentication failures. For example, storing paths as `/secret/app/db` during encryption but reconstructing as `secret/app/db` during decryption will fail authentication. Establish strict canonicalization rules for all associated data components and implement comprehensive test cases covering various input formats.\n\n⚠️ **Pitfall: Version Number Overflow**\nUsing fixed-size integers for version numbers can cause overflow after many updates, potentially wrapping around to previously used version numbers and causing conflicts. While 64-bit integers provide enormous capacity (9 quintillion versions), consider the implications of long-lived secrets in high-update environments. Implement monitoring for version number consumption and establish procedures for secret migration before overflow occurs.\n\n⚠️ **Pitfall: Incomplete Cleanup on Errors**\nIf encryption operations fail partway through (e.g., after generating the DEK but before storing the encrypted secret), sensitive data may remain in memory or temporary storage. Similarly, failed decryption operations might leave partially decrypted data accessible. Implement comprehensive cleanup using `defer` statements or similar mechanisms to ensure sensitive data is zeroed from memory regardless of operation outcome.\n\n### Implementation Guidance\n\nThis implementation guidance provides the foundational encryption engine that handles envelope encryption, key management, and secret versioning. The core learning challenge is implementing the envelope encryption algorithm correctly while managing the complexity of key rotation and version compatibility.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Encryption | Go crypto/aes + crypto/cipher (GCM) | Hardware security modules (HSM) |\n| Key Storage | Encrypted files with proper permissions | Cloud KMS integration (AWS KMS, GCP KMS) |\n| Random Generation | crypto/rand.Reader | Hardware entropy sources |\n| Memory Security | Manual zeroing with explicit loops | Memory protection libraries |\n| Key Derivation | crypto/pbkdf2 for password-based keys | Argon2 with tuned parameters |\n\n**Recommended File Structure:**\n\n```\ninternal/encryption/\n  engine.go              ← main encryption engine\n  envelope.go            ← envelope encryption implementation\n  keys.go                ← DEK management and rotation\n  versioning.go          ← secret versioning logic\n  engine_test.go         ← comprehensive test suite\n  testdata/\n    test_secrets.json    ← test vectors for crypto operations\ninternal/storage/\n  backend.go             ← storage interface\n  memory.go              ← in-memory backend for development\ncmd/vault/\n  main.go                ← server entry point\n```\n\n**Infrastructure Starter Code (Complete and Ready to Use):**\n\n```go\n// internal/encryption/crypto_utils.go\npackage encryption\n\nimport (\n    \"crypto/rand\"\n    \"crypto/sha256\"\n    \"crypto/subtle\"\n    \"fmt\"\n    \"io\"\n)\n\n// SecureRandom provides cryptographically secure random bytes\ntype SecureRandom struct {\n    source io.Reader\n}\n\nfunc NewSecureRandom() *SecureRandom {\n    return &SecureRandom{source: rand.Reader}\n}\n\nfunc (sr *SecureRandom) GenerateKey(size int) ([]byte, error) {\n    key := make([]byte, size)\n    if _, err := io.ReadFull(sr.source, key); err != nil {\n        return nil, fmt.Errorf(\"failed to generate random key: %w\", err)\n    }\n    return key, nil\n}\n\nfunc (sr *SecureRandom) GenerateNonce(size int) ([]byte, error) {\n    nonce := make([]byte, size)\n    if _, err := io.ReadFull(sr.source, nonce); err != nil {\n        return nil, fmt.Errorf(\"failed to generate random nonce: %w\", err)\n    }\n    return nonce, nil\n}\n\n// SecureMemory provides utilities for secure memory handling\ntype SecureMemory struct{}\n\nfunc (sm *SecureMemory) Zero(data []byte) {\n    for i := range data {\n        data[i] = 0\n    }\n}\n\nfunc (sm *SecureMemory) Compare(a, b []byte) bool {\n    return subtle.ConstantTimeCompare(a, b) == 1\n}\n\nfunc (sm *SecureMemory) ComputeChecksum(data []byte) []byte {\n    hash := sha256.Sum256(data)\n    return hash[:]\n}\n\n// KeyDerivation provides password-based key derivation\ntype KeyDerivation struct {\n    iterations int\n    saltSize   int\n}\n\nfunc NewKeyDerivation() *KeyDerivation {\n    return &KeyDerivation{\n        iterations: 480000, // OWASP recommended minimum\n        saltSize:   32,     // 256 bits\n    }\n}\n\nfunc (kd *KeyDerivation) DeriveKey(password []byte, salt []byte, keySize int) []byte {\n    // Implementation would use golang.org/x/crypto/pbkdf2\n    // This is a placeholder - implement PBKDF2 derivation\n    return make([]byte, keySize) // TODO: Implement PBKDF2\n}\n```\n\n**Core Logic Skeleton (Students Implement These):**\n\n```go\n// internal/encryption/engine.go\npackage encryption\n\nimport (\n    \"context\"\n    \"crypto/aes\"\n    \"crypto/cipher\"\n    \"encoding/json\"\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n// Engine manages envelope encryption for the secret management system\ntype Engine struct {\n    masterKey      []byte\n    keyVersion     int\n    dekCache       map[int]*DataEncryptionKey\n    currentDEK     *DataEncryptionKey\n    mutex          sync.RWMutex\n    random         *SecureRandom\n    memory         *SecureMemory\n    rotationPolicy RotationPolicy\n}\n\ntype RotationPolicy struct {\n    MaxAge        time.Duration\n    MaxUsageCount int64\n    AutoRotate    bool\n}\n\n// NewEngine creates a new encryption engine with the specified master key\nfunc NewEngine(masterKey []byte, policy RotationPolicy) (*Engine, error) {\n    if len(masterKey) != AES_KEY_SIZE {\n        return nil, fmt.Errorf(\"master key must be %d bytes\", AES_KEY_SIZE)\n    }\n    \n    // TODO 1: Initialize the engine with copied master key (don't store reference)\n    // TODO 2: Create secure random and memory utilities\n    // TODO 3: Initialize DEK cache and generate initial DEK\n    // TODO 4: Set up rotation policy and start background rotation if enabled\n    // Hint: Use copy() to safely copy the master key into engine memory\n    \n    return nil, fmt.Errorf(\"not implemented\")\n}\n\n// EncryptSecret encrypts a secret using envelope encryption\nfunc (e *Engine) EncryptSecret(plaintext []byte, secretPath string, version int) (*SecretVersion, error) {\n    // TODO 1: Validate input parameters (non-nil plaintext, valid path)\n    // TODO 2: Acquire read lock and get current active DEK\n    // TODO 3: Generate cryptographically secure nonce using e.random\n    // TODO 4: Construct associated data (path + version + timestamp + DEK version)\n    // TODO 5: Create AES-GCM cipher using DEK and encrypt with associated data\n    // TODO 6: Increment DEK usage count and check if rotation is needed\n    // TODO 7: Create SecretVersion with all encryption metadata and checksum\n    // Hint: Use json.Marshal for consistent associated data serialization\n    \n    return nil, fmt.Errorf(\"not implemented\")\n}\n\n// DecryptSecret decrypts a secret using envelope encryption\nfunc (e *Engine) DecryptSecret(secretVersion *SecretVersion) ([]byte, error) {\n    // TODO 1: Validate secret version has required fields (EncryptedValue, KeyVersion, Nonce)\n    // TODO 2: Retrieve the DEK for the specified version (check cache first)\n    // TODO 3: Verify the encryption algorithm matches what we support\n    // TODO 4: Reconstruct associated data using same process as encryption\n    // TODO 5: Create AES-GCM cipher and decrypt with associated data verification\n    // TODO 6: Verify overall package checksum to detect corruption\n    // TODO 7: Return plaintext and zero sensitive intermediate values\n    // Hint: Authentication failures should return generic errors, not specific causes\n    \n    return nil, fmt.Errorf(\"not implemented\")\n}\n\n// GenerateDataEncryptionKey creates a new DEK encrypted with the master key\nfunc (e *Engine) GenerateDataEncryptionKey(version int) (*DataEncryptionKey, error) {\n    // TODO 1: Generate new 256-bit random key using secure random generator\n    // TODO 2: Create AES cipher using master key for DEK encryption\n    // TODO 3: Generate nonce for master key encryption of DEK\n    // TODO 4: Encrypt the new DEK using AES-GCM with master key\n    // TODO 5: Create DataEncryptionKey struct with encrypted DEK and metadata\n    // TODO 6: Set status to \"active\" and initialize usage counter\n    // TODO 7: Zero the plaintext DEK from memory before returning\n    // Hint: Store creation timestamp for rotation policy decisions\n    \n    return nil, fmt.Errorf(\"not implemented\")\n}\n\n// RotateDataEncryptionKey creates new DEK and marks current as retired\nfunc (e *Engine) RotateDataEncryptionKey() error {\n    // TODO 1: Acquire write lock to prevent concurrent rotation\n    // TODO 2: Generate new DEK with incremented version number\n    // TODO 3: Add new DEK to cache and update current DEK pointer\n    // TODO 4: Mark previous DEK as \"retired\" but keep in cache\n    // TODO 5: Log rotation event with timestamps and version numbers\n    // TODO 6: Optionally trigger background re-encryption of old secrets\n    // TODO 7: Update rotation metrics and schedule next rotation\n    // Hint: Use atomic operations for DEK pointer updates\n    \n    return fmt.Errorf(\"not implemented\")\n}\n\n// GetDEKForVersion retrieves and decrypts DEK for specified version\nfunc (e *Engine) GetDEKForVersion(version int) ([]byte, error) {\n    // TODO 1: Check DEK cache for requested version\n    // TODO 2: If not cached, verify DEK exists and is not revoked\n    // TODO 3: Create AES-GCM cipher using master key\n    // TODO 4: Decrypt the stored encrypted DEK\n    // TODO 5: Add decrypted DEK to cache with LRU eviction\n    // TODO 6: Return decrypted DEK (caller must zero when done)\n    // Hint: Implement cache eviction when cache size exceeds limit\n    \n    return nil, fmt.Errorf(\"not implemented\")\n}\n\n// Shutdown securely cleans up the encryption engine\nfunc (e *Engine) Shutdown() error {\n    // TODO 1: Acquire write lock to prevent new operations\n    // TODO 2: Zero master key from memory\n    // TODO 3: Zero all cached DEKs from memory\n    // TODO 4: Clear DEK cache and reset pointers\n    // TODO 5: Stop any background rotation processes\n    // TODO 6: Log shutdown event for audit trail\n    // Hint: Use e.memory.Zero() to securely clear byte slices\n    \n    return nil\n}\n```\n\n**Language-Specific Hints:**\n\n- Use `crypto/aes` and `crypto/cipher` packages for AES-GCM implementation\n- Always check `cipher.NewGCM()` errors - some AES implementations don't support GCM\n- Use `defer` statements to ensure sensitive memory is zeroed even on early returns\n- The `sync.RWMutex` allows multiple concurrent decryptions but exclusive encryption\n- Use `encoding/json.Marshal` for consistent associated data serialization\n- Check random number generation errors - they indicate serious system problems\n- Use `copy()` to safely duplicate byte slices containing sensitive data\n\n**Milestone Checkpoint:**\n\nAfter implementing the encryption engine, verify the following behavior:\n\n1. **Basic Encryption Test**:\n   ```bash\n   go test ./internal/encryption/ -run TestBasicEncryption -v\n   ```\n   Expected: Encrypt and decrypt a simple secret successfully\n\n2. **Key Rotation Test**:\n   ```bash\n   go test ./internal/encryption/ -run TestKeyRotation -v\n   ```\n   Expected: Rotate DEK and decrypt old secrets with retired key\n\n3. **Version Management Test**:\n   ```bash\n   go test ./internal/encryption/ -run TestVersioning -v\n   ```\n   Expected: Create multiple secret versions and retrieve specific versions\n\n4. **Manual Testing**:\n   ```go\n   // Create test program in cmd/test-encryption/\n   engine, _ := NewEngine(masterKey, policy)\n   secretVersion, _ := engine.EncryptSecret([]byte(\"test-secret\"), \"/app/db\", 1)\n   plaintext, _ := engine.DecryptSecret(secretVersion)\n   // plaintext should equal []byte(\"test-secret\")\n   ```\n\n**Debugging Tips:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| \"cipher: message authentication failed\" | Associated data mismatch between encrypt/decrypt | Log associated data on both operations | Ensure identical path/version/timestamp formatting |\n| \"DEK not found for version X\" | Key rotation deleted DEK while secrets still reference it | Check DEK cache contents and version references | Implement reference counting for DEK cleanup |\n| Memory corruption or segfaults | Not zeroing sensitive data after use | Run with race detector: `go test -race` | Add defer statements to zero byte slices |\n| Slow encryption performance | Regenerating DEKs on every operation | Profile with `go test -cpuprofile=cpu.prof` | Implement DEK caching and reuse |\n| Nonce collision errors | Weak random number generator or clock issues | Test RNG quality with statistical tests | Use crypto/rand.Reader and verify system entropy |\n\n\n## Authentication and Policy Engine\n\n> **Milestone(s):** This section implements Milestone 2 (Access Policies & Authentication), focusing on path-based ACLs, multiple authentication methods, policy evaluation, and comprehensive audit logging.\n\nThink of authentication and authorization like a corporate badge system combined with a sophisticated building access control system. When you arrive at work, you first prove your identity by swiping your badge (authentication), then the system checks which floors, rooms, and resources your role allows you to access (authorization). The security desk maintains logs of every badge swipe and access attempt (audit logging). Our secret management system works similarly — clients must first prove their identity through tokens or certificates, then the system evaluates whether their assigned policies grant access to the requested secret path.\n\nThe authentication and policy engine serves as the **gatekeeper** for our secret management system, implementing a zero-trust security model where every request must be authenticated and authorized before accessing any secrets. This engine consists of four interconnected subsystems: authentication methods that verify client identity, a policy definition language that specifies access rules, an authorization engine that evaluates requests against policies, and comprehensive audit logging that tracks every access attempt for security monitoring.\n\n### Authentication Methods\n\nThe authentication subsystem implements multiple methods for clients to prove their identity, similar to how a high-security facility might accept both employee badges and visitor certificates. Each authentication method produces a verified identity that the authorization engine can evaluate against policies.\n\n**Token-Based Authentication** serves as our primary authentication method, functioning like a corporate access card that employees carry. When a client successfully authenticates through any method, the system issues a **bearer token** — a cryptographically signed identifier that proves the client's authenticated identity without requiring them to re-authenticate for subsequent requests.\n\nThe token structure contains essential identity and authorization information:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `ID` | `string` | Unique token identifier for lookups and revocation |\n| `Accessor` | `string` | Public handle for token management without exposing ID |\n| `Policies` | `[]string` | List of policy names attached to this token |\n| `TokenType` | `string` | Either \"service\" for long-lived or \"batch\" for short-lived |\n| `CreatedAt` | `time.Time` | Token creation timestamp for audit trails |\n| `ExpiresAt` | `*time.Time` | Optional expiration time (nil for non-expiring tokens) |\n| `LastUsedAt` | `*time.Time` | Most recent usage timestamp for activity monitoring |\n| `UsageCount` | `int64` | Number of times token has been used |\n| `MaxUses` | `int` | Maximum allowed uses before token expires (0 for unlimited) |\n| `Renewable` | `bool` | Whether token can have its TTL extended |\n| `ParentToken` | `string` | Token that created this token (for hierarchical revocation) |\n| `DisplayName` | `string` | Human-readable identifier for audit logs |\n| `Metadata` | `map[string]string` | Additional context about token creation |\n| `BoundCIDRs` | `[]string` | IP address restrictions for token usage |\n\n> **Decision: Bearer Token Authentication**\n> - **Context**: Clients need to authenticate repeatedly for secret access, but re-authentication for every request creates performance bottlenecks and user experience problems\n> - **Options Considered**: HTTP Basic Auth, JWT tokens, custom bearer tokens\n> - **Decision**: Custom bearer tokens with server-side state\n> - **Rationale**: Unlike stateless JWTs, server-side tokens allow immediate revocation and detailed usage tracking. Basic Auth would require credential transmission on every request\n> - **Consequences**: Enables immediate token revocation and comprehensive audit trails, but requires server-side token storage and lookup overhead\n\n**Mutual TLS (mTLS) Authentication** provides our strongest authentication method, similar to how diplomatic facilities require both photo identification and biometric verification. In mTLS, both the client and server present X.509 certificates to each other, creating a cryptographically verified bidirectional trust relationship.\n\nThe mTLS authentication flow operates through these steps:\n1. Client initiates TLS connection to the secret management server\n2. Server presents its certificate to prove server identity\n3. Server requests client certificate as part of TLS handshake\n4. Client presents its certificate signed by a trusted Certificate Authority\n5. Server validates client certificate chain, expiration, and revocation status\n6. Server extracts identity information from certificate Common Name or Subject Alternative Names\n7. Server issues a bearer token bound to the certificate identity for subsequent API calls\n\nThe identity structure captures authenticated client information regardless of authentication method:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `ID` | `string` | Unique identity identifier across all auth methods |\n| `Name` | `string` | Human-readable name (certificate CN, username, etc.) |\n| `Type` | `string` | Identity type: \"certificate\", \"user\", \"service\", etc. |\n| `AuthMethod` | `string` | Which authentication method verified this identity |\n| `Policies` | `[]string` | Default policies assigned to this identity |\n| `Groups` | `[]string` | Group memberships for policy inheritance |\n| `CreatedAt` | `time.Time` | When identity was first registered |\n| `LastAuthAt` | `*time.Time` | Most recent authentication timestamp |\n| `AuthCount` | `int64` | Total number of authentication attempts |\n| `Metadata` | `map[string]string` | Auth-method-specific context (certificate fingerprint, etc.) |\n| `Disabled` | `bool` | Whether identity is administratively disabled |\n\n> The critical security insight here is that authentication only establishes **who** the client is, not **what** they can access. The authentication engine's job ends once it produces a verified identity — the authorization engine handles all access control decisions based on that identity.\n\n**AppRole Authentication** provides a specialized method designed for applications and services rather than human users. Think of AppRole like a combination of an application ID and a temporary access code — the application proves it knows both pieces of information to authenticate.\n\nAppRole authentication uses two credentials:\n- **Role ID**: A public identifier that specifies which application role the client claims\n- **Secret ID**: A private, time-limited credential that proves the client is authorized to assume that role\n\nThis two-factor approach prevents common application security mistakes where developers embed long-lived credentials directly in application code. The Role ID can be embedded in configuration files or environment variables, while the Secret ID must be delivered through a separate, secure channel (such as a deployment system or init container).\n\n⚠️ **Pitfall: Secret ID Distribution**\nMany developers try to solve the Secret ID distribution problem by embedding both Role ID and Secret ID in the same configuration file or environment variables. This defeats the security purpose of AppRole authentication. The Secret ID must be delivered through a separate mechanism — ideally one that provides it just-in-time during application startup and doesn't persist it to disk.\n\n### Policy Definition Language\n\nThe policy definition language provides a declarative way to specify **what** authenticated identities can access, using a path-based access control model similar to filesystem permissions but designed specifically for hierarchical secret storage.\n\n**Path-Based Access Control** treats secrets like files in a directory tree, where policies specify access rules for path patterns. Think of this like building security where your badge might grant access to \"all rooms on floor 3\" or \"any conference room\" rather than having to list every specific room individually.\n\nA policy consists of one or more rules, where each rule specifies:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Name` | `string` | Unique policy identifier for assignment to tokens/identities |\n| `Rules` | `[]PolicyRule` | Ordered list of access rules evaluated sequentially |\n| `Description` | `string` | Human-readable policy purpose documentation |\n| `CreatedAt` | `time.Time` | Policy creation timestamp for audit trails |\n| `UpdatedAt` | `time.Time` | Most recent policy modification timestamp |\n| `CreatedBy` | `string` | Identity that created this policy |\n| `Version` | `int` | Policy version number for change tracking |\n\nEach policy rule defines fine-grained access controls for specific path patterns:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Path` | `string` | Secret path pattern with wildcards (* for segment, ** for recursive) |\n| `Capabilities` | `[]string` | Allowed operations: \"read\", \"create\", \"update\", \"delete\", \"list\" |\n| `RequiredParameters` | `map[string][]string` | Request parameters that MUST be present with allowed values |\n| `AllowedParameters` | `map[string][]string` | Request parameters that MAY be present with allowed values |\n| `DeniedParameters` | `map[string][]string` | Request parameters that explicitly DENY access |\n| `MaxTTL` | `time.Duration` | Maximum TTL for dynamic secrets generated under this path |\n| `MinWrappingTTL` | `time.Duration` | Minimum TTL for secret wrapping responses |\n\n**Wildcard Pattern Matching** enables flexible path-based access control without requiring explicit rules for every possible secret path. The system supports two wildcard types:\n\n- **Single Segment Wildcard (`*`)**: Matches exactly one path segment\n- **Recursive Wildcard (`**`)**: Matches zero or more path segments at any depth\n\nExamples of wildcard pattern matching:\n- `secret/team-alpha/*` matches `secret/team-alpha/database` but NOT `secret/team-alpha/env/prod`\n- `secret/team-alpha/**` matches both `secret/team-alpha/database` AND `secret/team-alpha/env/prod`\n- `secret/*/database` matches `secret/team-alpha/database` and `secret/team-beta/database`\n- `secret/**/credentials` matches `secret/app1/credentials`, `secret/team/app1/credentials`, etc.\n\n> **Decision: Path-Based Access Control with Wildcards**\n> - **Context**: Applications need flexible access control that doesn't require updating policies every time new secrets are added, while maintaining security through least-privilege principles\n> - **Options Considered**: Explicit path lists, regex patterns, glob-style wildcards\n> - **Decision**: Glob-style wildcards with single (*) and recursive (**) patterns\n> - **Rationale**: Glob patterns provide intuitive syntax familiar to developers while being more predictable than regex. Explicit lists don't scale for dynamic environments\n> - **Consequences**: Enables scalable access control policies but requires careful wildcard design to prevent overly broad access grants\n\n**Capability-Based Operations** define what actions an identity can perform on matched secret paths. The system implements five core capabilities:\n\n| Capability | Description | Required For |\n|------------|-------------|--------------|\n| `read` | Retrieve secret values and metadata | `GET /v1/secret/data/path` |\n| `create` | Create new secrets at non-existing paths | `POST /v1/secret/data/path` (new paths only) |\n| `update` | Modify existing secrets or create new versions | `POST /v1/secret/data/path` (existing paths) |\n| `delete` | Soft-delete secrets and versions | `DELETE /v1/secret/data/path` |\n| `list` | Enumerate secret paths under a prefix | `LIST /v1/secret/metadata/path` |\n\n⚠️ **Pitfall: Overly Broad Wildcard Patterns**\nA common mistake is using patterns like `secret/**` with `[\"read\", \"create\", \"update\", \"delete\"]` capabilities, which grants unlimited access to all secrets. This defeats the purpose of access control. Instead, design policies with narrow wildcard patterns that match the minimum necessary paths for each application's requirements.\n\n**Parameter-Based Constraints** provide fine-grained control over request parameters, enabling policies to restrict not just what paths can be accessed, but how they can be accessed. This is particularly important for dynamic secrets where policy might allow database access but restrict which database roles can be requested.\n\nExample policy rule with parameter constraints:\n```\nPath: secret/database/**\nCapabilities: [\"read\"]\nRequiredParameters: \n  environment: [\"staging\", \"production\"]\nAllowedParameters:\n  role: [\"readonly\", \"readwrite\"] \n  ttl: [\"1h\", \"8h\", \"24h\"]\nDeniedParameters:\n  role: [\"admin\", \"superuser\"]\n```\n\nThis rule ensures that database secret requests must specify a valid environment, can optionally specify allowed roles and TTL values, but explicitly denies access to administrative database roles.\n\n### Authorization Flow\n\nThe authorization engine evaluates every authenticated request against the requester's assigned policies to make allow/deny decisions. Think of this like a security guard consulting multiple access lists to determine if an employee's badge grants access to a specific resource at a specific time.\n\n**Request Evaluation Pipeline** processes every secret access request through a structured sequence of authorization checks:\n\n1. **Request Parsing**: Extract the secret path, HTTP method, and request parameters from the incoming API call\n2. **Identity Resolution**: Look up the authenticated identity associated with the request token\n3. **Policy Collection**: Gather all policies assigned directly to the identity or inherited through group membership\n4. **Rule Matching**: For each policy, find rules where the secret path matches the rule's path pattern\n5. **Capability Checking**: Verify the requested operation (read/create/update/delete/list) is included in matching rule capabilities\n6. **Parameter Validation**: Check request parameters against rule constraints (required/allowed/denied parameters)\n7. **Decision Aggregation**: Combine results from all matching rules to produce final allow/deny decision\n8. **Audit Logging**: Record the authorization decision with full context for security monitoring\n\n> The authorization engine implements **default deny** behavior — if no policy rule explicitly allows an operation, the request is denied. This ensures that new secrets and paths are protected by default until policies explicitly grant access.\n\n**Policy Evaluation Algorithm** determines access by finding the most permissive rule that matches the request path. The algorithm processes rules in the order they appear in policies, allowing more specific rules to override general patterns:\n\n1. Initialize decision as DENY and collect empty capability set\n2. For each policy assigned to the requesting identity:\n   a. For each rule in the policy (in order):\n      i. Check if request path matches rule path pattern using wildcard matching\n      ii. If path matches, check if requested operation is in rule capabilities\n      iii. If operation is allowed, validate all parameter constraints\n      iv. If all checks pass, update decision to ALLOW for this operation\n3. Return final decision based on whether any rule explicitly allowed the operation\n\n**Path Matching Implementation** uses efficient prefix matching with wildcard support to minimize evaluation overhead for policies with hundreds of rules. The matching algorithm handles both single-segment (`*`) and recursive (`**`) wildcards:\n\n1. Split both rule path pattern and request path into segments using \"/\" delimiter\n2. Initialize pattern index and path index to 0\n3. While both indices are within their respective arrays:\n   a. If pattern segment is \"*\", advance both indices by 1 (exact segment match)\n   b. If pattern segment is \"**\", find next non-wildcard pattern segment and skip path segments until match found\n   c. If pattern segment is literal, compare with path segment for exact match\n   d. If segments don't match, rule doesn't apply to this path\n4. Rule matches if both pattern and path are fully consumed or pattern ends with \"**\"\n\n⚠️ **Pitfall: Policy Rule Ordering**\nThe order of rules within a policy matters because the engine evaluates them sequentially and stops at the first matching rule. A common mistake is placing broad wildcard patterns before more specific rules, causing the specific rules to never be evaluated. Always order rules from most specific to least specific within each policy.\n\n**Token Policy Inheritance** allows tokens to inherit policies from multiple sources, providing flexible authorization models for different organizational structures. When evaluating a request, the authorization engine considers policies from:\n\n1. **Direct Token Policies**: Policies explicitly assigned when the token was created\n2. **Identity Policies**: Default policies assigned to the authenticated identity\n3. **Group Policies**: Policies inherited through group membership hierarchies\n\nThe final authorization decision considers the union of all applicable policies — if any inherited policy grants access, the operation is allowed.\n\n### Audit Logging\n\nComprehensive audit logging provides the security monitoring and compliance foundation for the secret management system. Think of audit logs like security camera recordings that capture every interaction with the vault, enabling forensic analysis of security incidents and demonstrating compliance with access control policies.\n\n**Audit Event Structure** captures complete context for every interaction with the secret management system, ensuring security teams can reconstruct the full timeline of any security event:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Timestamp` | `time.Time` | Precise event occurrence time in UTC |\n| `RequestID` | `string` | Unique identifier correlating related log entries |\n| `EventType` | `string` | Category: \"auth\", \"secret\", \"policy\", \"admin\" |\n| `Operation` | `string` | Specific action: \"login\", \"read\", \"create\", \"delete\", etc. |\n| `Path` | `string` | Secret or resource path being accessed |\n| `Identity` | `string` | Authenticated identity performing the operation |\n| `TokenID` | `string` | Token accessor (not ID) for privacy |\n| `AuthMethod` | `string` | Authentication method used (\"token\", \"tls-cert\", \"approle\") |\n| `SourceIP` | `string` | Client IP address for network-based analysis |\n| `UserAgent` | `string` | Client application identifier |\n| `RequestMetadata` | `map[string]interface{}` | Additional request context and parameters |\n| `Result` | `string` | Operation outcome: \"success\", \"denied\", \"error\" |\n| `ErrorCode` | `string` | Specific error code for failed operations |\n| `ResponseMetadata` | `map[string]interface{}` | Non-sensitive response context |\n| `Duration` | `time.Duration` | Request processing time for performance analysis |\n\n**Security Event Categories** organize audit events into logical groups that align with common security monitoring and incident response workflows:\n\n| Event Type | Operations | Security Purpose |\n|------------|-------------|------------------|\n| `auth` | login, logout, token-create, token-revoke | Track identity authentication and session management |\n| `secret` | read, create, update, delete, list | Monitor access to sensitive data and detect unauthorized attempts |\n| `policy` | policy-create, policy-update, policy-delete | Audit changes to access control rules |\n| `admin` | unseal, seal, leader-election, backup | Track administrative operations affecting system security |\n| `dynamic` | lease-create, lease-renew, lease-revoke | Monitor dynamic secret lifecycle for credential management |\n\n**Tamper-Evident Logging** ensures audit logs cannot be modified or deleted by attackers who compromise the secret management system. The logging subsystem implements several protection mechanisms:\n\n- **Append-Only Storage**: Audit logs are written to append-only files or storage systems that prevent modification of existing entries\n- **Remote Syslog**: Critical events are immediately forwarded to external log collection systems outside the secret management infrastructure\n- **Log Signing**: Each audit entry includes a cryptographic signature that can detect tampering\n- **Sequence Numbering**: Monotonic sequence numbers enable detection of missing log entries\n\n> **Decision: Structured JSON Audit Logging**\n> - **Context**: Security teams need to correlate secret management events with other security data sources and must parse logs programmatically for threat detection\n> - **Options Considered**: Plain text logs, structured JSON, binary format\n> - **Decision**: Structured JSON with standardized field names\n> - **Rationale**: JSON provides schema evolution and integrates easily with SIEM systems, log aggregators, and analysis tools. Plain text is hard to parse; binary format lacks tooling support\n> - **Consequences**: Enables automated security analysis and correlation but requires more storage space than compact binary formats\n\n**Privacy and Compliance Considerations** balance comprehensive security monitoring with protection of sensitive information. The audit logging system carefully excludes certain data from logs to prevent credential exposure:\n\nNever Logged:\n- Actual secret values or encrypted content\n- Full token IDs (only public accessors are logged)\n- Sensitive request parameters like passwords or private keys\n- Client certificate private keys or token secrets\n\nAlways Logged:\n- Secret paths and metadata (but not values)\n- Authentication outcomes and identity information\n- Authorization decisions and policy evaluations\n- Error conditions and security violations\n- Timing and performance metrics\n\n⚠️ **Pitfall: Logging Sensitive Data**\nA common security vulnerability is accidentally logging sensitive information in request parameters or error messages. For example, logging `password=secret123` or including secret values in error responses. The audit system must sanitize all logged data to include only non-sensitive context needed for security monitoring.\n\n**Performance and Scalability Considerations** ensure audit logging doesn't become a bottleneck for secret management operations. The logging subsystem implements several optimizations:\n\n- **Asynchronous Logging**: Audit events are queued and written asynchronously to prevent blocking secret operations\n- **Batch Writing**: Multiple audit events are written together to reduce I/O overhead\n- **Log Rotation**: Automatic rotation and compression of log files to manage storage growth\n- **Sampling**: Non-critical events may be sampled at high request volumes to prevent log flooding\n\nThe audit logging system provides configurable log levels to balance detail with performance:\n\n| Log Level | Events Included | Use Case |\n|-----------|-----------------|----------|\n| `minimal` | Authentication, authorization failures, administrative operations | Compliance and basic security monitoring |\n| `standard` | All secret operations, policy changes, error conditions | Comprehensive security analysis |\n| `verbose` | Request/response timing, debug information, performance metrics | Troubleshooting and performance optimization |\n\n![Data Model Relationships](./diagrams/data-model-relationships.svg)\n\n![Authentication and Authorization Sequence](./diagrams/authentication-sequence.svg)\n\n![Request Processing Pipeline](./diagrams/request-processing-pipeline.svg)\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Token Storage Without Expiration**\nMany implementations create tokens without expiration dates and never clean up the token storage table. This leads to unbounded growth of the token database and potential memory exhaustion. Always implement token TTL with automatic cleanup processes, and consider using short-lived tokens with renewal mechanisms rather than long-lived tokens.\n\n⚠️ **Pitfall: Timing Attack Vulnerabilities**\nWhen validating tokens or comparing credentials, using standard string comparison functions can leak timing information that allows attackers to gradually guess valid tokens. Always use constant-time comparison functions (like `crypto/subtle.ConstantTimeCompare` in Go) when validating authentication credentials.\n\n⚠️ **Pitfall: Policy Rule Conflicts**\nWhen multiple policies apply to the same identity, conflicting rules can create security vulnerabilities. For example, one policy might grant `read` access to `secret/**` while another denies access to `secret/admin/*`. The authorization engine must have clear precedence rules — typically \"most specific rule wins\" or \"explicit deny overrides allow\" — and these rules must be consistently applied.\n\n⚠️ **Pitfall: Insufficient Request Context**\nAuthentication engines often fail to capture sufficient context about the request environment, making forensic analysis difficult. Always log the complete request context including source IP, user agent, request parameters (sanitized), and timing information. This context is critical for detecting credential theft and analyzing security incidents.\n\n⚠️ **Pitfall: Group Policy Infinite Recursion**\nWhen implementing group-based policy inheritance, circular group memberships can cause infinite recursion during policy evaluation. Always implement cycle detection in group membership resolution, and consider limiting inheritance depth to prevent deep recursive chains that impact performance.\n\n### Implementation Guidance\n\nThis subsection provides concrete implementation guidance for building the authentication and policy engine in Go, with a focus on security best practices and production-ready patterns.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| HTTP Authentication | Header parsing with `net/http` | JWT middleware with `github.com/golang-jwt/jwt` |\n| TLS Certificate Handling | `crypto/x509` and `crypto/tls` | `github.com/cloudflare/cfssl` for CA operations |\n| Token Storage | In-memory map with `sync.RWMutex` | Redis with TTL support |\n| Policy Evaluation | String matching with `path/filepath` | Compiled regex patterns with `regexp` |\n| Audit Logging | JSON lines to file with `encoding/json` | Structured logging with `github.com/sirupsen/logrus` |\n| Password Hashing | `golang.org/x/crypto/argon2` | `golang.org/x/crypto/scrypt` for compatibility |\n\n#### Recommended File Structure\n\n```\ninternal/auth/\n  engine.go              ← main auth engine and policy evaluation\n  engine_test.go         ← auth engine tests\n  token.go               ← token creation, validation, and management\n  token_test.go          ← token handling tests\n  policy.go              ← policy parsing and rule evaluation\n  policy_test.go         ← policy evaluation tests\n  audit.go               ← audit logging and event capture\n  audit_test.go          ← audit logging tests\n  types.go               ← shared data structures (Token, Policy, Identity, etc.)\n  \ninternal/auth/methods/\n  token.go               ← bearer token authentication\n  mtls.go                ← mutual TLS authentication\n  approle.go             ← AppRole authentication method\n  \ncmd/auth-test/\n  main.go                ← standalone auth testing utility\n```\n\n#### Authentication Infrastructure (Complete Implementation)\n\n```go\n// internal/auth/types.go\npackage auth\n\nimport (\n    \"time\"\n)\n\n// Token represents an authentication token with policies and metadata\ntype Token struct {\n    ID           string            `json:\"id\"`\n    Accessor     string            `json:\"accessor\"`\n    Policies     []string          `json:\"policies\"`\n    TokenType    string            `json:\"token_type\"`\n    CreatedAt    time.Time         `json:\"created_at\"`\n    ExpiresAt    *time.Time        `json:\"expires_at,omitempty\"`\n    LastUsedAt   *time.Time        `json:\"last_used_at,omitempty\"`\n    UsageCount   int64             `json:\"usage_count\"`\n    MaxUses      int               `json:\"max_uses\"`\n    Renewable    bool              `json:\"renewable\"`\n    ParentToken  string            `json:\"parent_token\"`\n    DisplayName  string            `json:\"display_name\"`\n    Metadata     map[string]string `json:\"metadata\"`\n    BoundCIDRs   []string          `json:\"bound_cidrs\"`\n}\n\n// Policy represents an access control policy with rules\ntype Policy struct {\n    Name        string       `json:\"name\"`\n    Rules       []PolicyRule `json:\"rules\"`\n    Description string       `json:\"description\"`\n    CreatedAt   time.Time    `json:\"created_at\"`\n    UpdatedAt   time.Time    `json:\"updated_at\"`\n    CreatedBy   string       `json:\"created_by\"`\n    Version     int          `json:\"version\"`\n}\n\n// PolicyRule defines access control for a specific path pattern\ntype PolicyRule struct {\n    Path                string              `json:\"path\"`\n    Capabilities        []string            `json:\"capabilities\"`\n    RequiredParameters  map[string][]string `json:\"required_parameters,omitempty\"`\n    AllowedParameters   map[string][]string `json:\"allowed_parameters,omitempty\"`\n    DeniedParameters    map[string][]string `json:\"denied_parameters,omitempty\"`\n    MaxTTL              time.Duration       `json:\"max_ttl,omitempty\"`\n    MinWrappingTTL      time.Duration       `json:\"min_wrapping_ttl,omitempty\"`\n}\n\n// Identity represents an authenticated principal\ntype Identity struct {\n    ID          string            `json:\"id\"`\n    Name        string            `json:\"name\"`\n    Type        string            `json:\"type\"`\n    AuthMethod  string            `json:\"auth_method\"`\n    Policies    []string          `json:\"policies\"`\n    Groups      []string          `json:\"groups\"`\n    CreatedAt   time.Time         `json:\"created_at\"`\n    LastAuthAt  *time.Time        `json:\"last_auth_at,omitempty\"`\n    AuthCount   int64             `json:\"auth_count\"`\n    Metadata    map[string]string `json:\"metadata\"`\n    Disabled    bool              `json:\"disabled\"`\n}\n\n// AuditEvent represents a security event for logging\ntype AuditEvent struct {\n    Timestamp        time.Time              `json:\"timestamp\"`\n    RequestID        string                 `json:\"request_id\"`\n    EventType        string                 `json:\"event_type\"`\n    Operation        string                 `json:\"operation\"`\n    Path             string                 `json:\"path\"`\n    Identity         string                 `json:\"identity\"`\n    TokenID          string                 `json:\"token_id\"`\n    AuthMethod       string                 `json:\"auth_method\"`\n    SourceIP         string                 `json:\"source_ip\"`\n    UserAgent        string                 `json:\"user_agent\"`\n    RequestMetadata  map[string]interface{} `json:\"request_metadata\"`\n    Result           string                 `json:\"result\"`\n    ErrorCode        string                 `json:\"error_code\"`\n    ResponseMetadata map[string]interface{} `json:\"response_metadata\"`\n    Duration         time.Duration          `json:\"duration\"`\n}\n\n// Constants for authentication and authorization\nconst (\n    TOKEN_HEADER     = \"X-Vault-Token\"\n    DEFAULT_TOKEN_TTL = time.Hour\n    \n    // Event types\n    EVENT_AUTH   = \"auth\"\n    EVENT_SECRET = \"secret\"\n    EVENT_POLICY = \"policy\"\n    EVENT_ADMIN  = \"admin\"\n    \n    // Results\n    RESULT_SUCCESS = \"success\"\n    RESULT_DENIED  = \"denied\"\n    RESULT_ERROR   = \"error\"\n)\n```\n\n```go\n// internal/auth/audit.go\npackage auth\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"sync\"\n    \"time\"\n)\n\n// AuditLogger provides tamper-evident audit logging\ntype AuditLogger struct {\n    file       *os.File\n    mutex      sync.Mutex\n    sequenceNum int64\n}\n\n// NewAuditLogger creates a new audit logger writing to the specified file\nfunc NewAuditLogger(filename string) (*AuditLogger, error) {\n    file, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to open audit log file: %w\", err)\n    }\n    \n    return &AuditLogger{\n        file:        file,\n        sequenceNum: 0,\n    }, nil\n}\n\n// LogEvent writes an audit event to the log file\nfunc (a *AuditLogger) LogEvent(event AuditEvent) error {\n    a.mutex.Lock()\n    defer a.mutex.Unlock()\n    \n    a.sequenceNum++\n    \n    // Add sequence number for tamper detection\n    logEntry := struct {\n        Sequence int64      `json:\"sequence\"`\n        Event    AuditEvent `json:\"event\"`\n    }{\n        Sequence: a.sequenceNum,\n        Event:    event,\n    }\n    \n    data, err := json.Marshal(logEntry)\n    if err != nil {\n        return fmt.Errorf(\"failed to marshal audit event: %w\", err)\n    }\n    \n    _, err = a.file.Write(append(data, '\\n'))\n    if err != nil {\n        return fmt.Errorf(\"failed to write audit event: %w\", err)\n    }\n    \n    // Force write to disk for tamper evidence\n    return a.file.Sync()\n}\n\n// Close closes the audit log file\nfunc (a *AuditLogger) Close() error {\n    return a.file.Close()\n}\n```\n\n#### Core Authentication Engine (Skeleton Implementation)\n\n```go\n// internal/auth/engine.go\npackage auth\n\nimport (\n    \"context\"\n    \"crypto/rand\"\n    \"crypto/subtle\"\n    \"encoding/hex\"\n    \"fmt\"\n    \"net/http\"\n    \"strings\"\n    \"sync\"\n    \"time\"\n)\n\n// Engine handles authentication, authorization, and audit logging\ntype Engine struct {\n    tokens       map[string]*Token\n    policies     map[string]*Policy\n    identities   map[string]*Identity\n    tokenMutex   sync.RWMutex\n    policyMutex  sync.RWMutex\n    auditLogger  *AuditLogger\n}\n\n// NewEngine creates a new authentication engine\nfunc NewEngine(auditLogPath string) (*Engine, error) {\n    auditLogger, err := NewAuditLogger(auditLogPath)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create audit logger: %w\", err)\n    }\n    \n    return &Engine{\n        tokens:      make(map[string]*Token),\n        policies:    make(map[string]*Policy),\n        identities:  make(map[string]*Identity),\n        auditLogger: auditLogger,\n    }, nil\n}\n\n// AuthenticateRequest extracts and validates authentication from HTTP request\nfunc (e *Engine) AuthenticateRequest(r *http.Request) (*Identity, *Token, error) {\n    // TODO 1: Extract token from X-Vault-Token header\n    // TODO 2: Validate token exists and is not expired\n    // TODO 3: Update token last_used_at and usage_count\n    // TODO 4: Look up identity associated with token\n    // TODO 5: Check if identity is disabled\n    // TODO 6: Validate source IP against token bound_cidrs if configured\n    // TODO 7: Return authenticated identity and token\n    // Hint: Use constant-time comparison for token validation to prevent timing attacks\n    panic(\"implement me\")\n}\n\n// AuthorizeRequest evaluates whether identity can perform operation on path\nfunc (e *Engine) AuthorizeRequest(identity *Identity, operation, path string, params map[string][]string) (bool, error) {\n    // TODO 1: Collect all policies assigned to identity (direct + inherited)\n    // TODO 2: For each policy, evaluate rules in order\n    // TODO 3: For each rule, check if path matches rule.Path pattern\n    // TODO 4: If path matches, check if operation is in rule.Capabilities\n    // TODO 5: Validate request parameters against rule constraints\n    // TODO 6: Return true if any rule explicitly allows, false otherwise\n    // Hint: Implement path wildcard matching with * and ** support\n    panic(\"implement me\")\n}\n\n// CreateToken generates a new authentication token for an identity\nfunc (e *Engine) CreateToken(ctx context.Context, request CreateTokenRequest) (*Token, error) {\n    // TODO 1: Generate cryptographically secure random token ID and accessor\n    // TODO 2: Validate requested policies exist and identity has permission\n    // TODO 3: Calculate expiration time based on TTL and max TTL limits\n    // TODO 4: Create token struct with all metadata\n    // TODO 5: Store token in token map\n    // TODO 6: Log token creation event to audit log\n    // Hint: Use crypto/rand for token generation, 32+ bytes recommended\n    panic(\"implement me\")\n}\n\n// CreatePolicy creates or updates an access control policy\nfunc (e *Engine) CreatePolicy(ctx context.Context, policy *Policy) error {\n    // TODO 1: Validate policy name and rule syntax\n    // TODO 2: Check for path pattern conflicts with existing policies  \n    // TODO 3: Validate capability names are recognized\n    // TODO 4: Store policy in policy map with version increment\n    // TODO 5: Log policy creation/update to audit log\n    // Hint: Validate wildcard patterns don't create security holes\n    panic(\"implement me\")\n}\n\n// ValidateTokenConstantTime performs constant-time token comparison\nfunc (e *Engine) ValidateTokenConstantTime(provided, stored string) bool {\n    return subtle.ConstantTimeCompare([]byte(provided), []byte(stored)) == 1\n}\n\n// matchesPath checks if a request path matches a policy rule path pattern\nfunc (e *Engine) matchesPath(pattern, path string) bool {\n    // TODO 1: Split both pattern and path by \"/\" delimiter\n    // TODO 2: Handle single segment wildcard (*) matching\n    // TODO 3: Handle recursive wildcard (**) matching  \n    // TODO 4: Handle literal segment matching\n    // TODO 5: Return true if pattern fully matches path\n    // Hint: Recursive wildcard matching requires backtracking logic\n    panic(\"implement me\")\n}\n\n// generateSecureToken creates a cryptographically random token\nfunc (e *Engine) generateSecureToken() (string, error) {\n    bytes := make([]byte, 32)\n    _, err := rand.Read(bytes)\n    if err != nil {\n        return \"\", err\n    }\n    return hex.EncodeToString(bytes), nil\n}\n\ntype CreateTokenRequest struct {\n    Policies    []string\n    TTL         time.Duration\n    Renewable   bool\n    DisplayName string\n    Metadata    map[string]string\n}\n```\n\n#### Path Matching Utility (Complete Implementation)\n\n```go\n// internal/auth/pathmatch.go\npackage auth\n\nimport (\n    \"strings\"\n)\n\n// PathMatcher provides efficient wildcard path matching for policies\ntype PathMatcher struct{}\n\n// NewPathMatcher creates a new path matching utility\nfunc NewPathMatcher() *PathMatcher {\n    return &PathMatcher{}\n}\n\n// Match checks if a path matches a pattern with wildcards\nfunc (pm *PathMatcher) Match(pattern, path string) bool {\n    return pm.matchSegments(\n        strings.Split(pattern, \"/\"),\n        strings.Split(path, \"/\"),\n        0, 0,\n    )\n}\n\n// matchSegments recursively matches pattern segments against path segments\nfunc (pm *PathMatcher) matchSegments(pattern, path []string, patternIdx, pathIdx int) bool {\n    // If we've consumed both pattern and path, it's a match\n    if patternIdx >= len(pattern) && pathIdx >= len(path) {\n        return true\n    }\n    \n    // If pattern is exhausted but path remains, no match\n    if patternIdx >= len(pattern) {\n        return false\n    }\n    \n    // If path is exhausted but pattern has non-recursive wildcards, no match\n    if pathIdx >= len(path) {\n        // Check if remaining pattern segments are all recursive wildcards\n        for i := patternIdx; i < len(pattern); i++ {\n            if pattern[i] != \"**\" {\n                return false\n            }\n        }\n        return true\n    }\n    \n    currentPattern := pattern[patternIdx]\n    \n    switch currentPattern {\n    case \"*\":\n        // Single segment wildcard - match exactly one path segment\n        return pm.matchSegments(pattern, path, patternIdx+1, pathIdx+1)\n        \n    case \"**\":\n        // Recursive wildcard - try matching zero or more segments\n        // First try consuming no path segments (** matches zero)\n        if pm.matchSegments(pattern, path, patternIdx+1, pathIdx) {\n            return true\n        }\n        // Then try consuming one path segment and continuing\n        return pm.matchSegments(pattern, path, patternIdx, pathIdx+1)\n        \n    default:\n        // Literal segment - must match exactly\n        if currentPattern == path[pathIdx] {\n            return pm.matchSegments(pattern, path, patternIdx+1, pathIdx+1)\n        }\n        return false\n    }\n}\n```\n\n#### Milestone Checkpoints\n\n**Authentication Checkpoint:**\nAfter implementing token authentication, test with:\n```bash\n# Start your auth engine\ngo run cmd/auth-test/main.go\n\n# Test token creation\ncurl -X POST http://localhost:8080/v1/auth/token/create \\\n  -H \"X-Vault-Token: root-token\" \\\n  -d '{\"policies\": [\"default\"], \"ttl\": \"1h\"}'\n\n# Expected: JSON response with token ID and accessor\n# Verify: Token appears in audit log with creation event\n```\n\n**Policy Evaluation Checkpoint:**\nTest path-based access control:\n```bash\n# Create a policy\ncurl -X POST http://localhost:8080/v1/sys/policy/test-policy \\\n  -H \"X-Vault-Token: root-token\" \\\n  -d '{\"policy\": \"path \\\"secret/app/*\\\" { capabilities = [\\\"read\\\"] }\"}'\n\n# Test authorized access\ncurl -H \"X-Vault-Token: <your-token>\" \\\n  http://localhost:8080/v1/secret/app/database\n\n# Test unauthorized access (should return 403)\ncurl -H \"X-Vault-Token: <your-token>\" \\\n  http://localhost:8080/v1/secret/admin/keys\n\n# Expected: First request succeeds, second returns 403 Forbidden\n# Verify: Both attempts appear in audit log with correct results\n```\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|----------------|-----|\n| All requests return 401 Unauthorized | Token lookup failing or tokens not being stored | Check if tokens map contains expected tokens, verify token header extraction | Ensure CreateToken actually stores in tokens map and AuthenticateRequest correctly extracts header |\n| Wildcard policies don't match expected paths | Path matching algorithm incorrect | Add debug logging to matchSegments function showing pattern/path at each step | Test path matching in isolation with unit tests for edge cases |\n| Policy evaluation is slow | Linear search through all policies for each request | Profile policy evaluation with timing measurements | Implement policy indexing by path prefix for faster lookup |\n| Audit logs missing events | Events not being logged or file write failures | Check audit log file permissions and disk space | Ensure every authorization decision calls LogEvent, check file.Sync() errors |\n| Token cleanup not working | Expired tokens accumulating in memory | Check token expiration logic and cleanup goroutine | Implement background cleanup that removes expired tokens from map |\n\n\n## Dynamic Secret Engine\n\n> **Milestone(s):** This section implements Milestone 3 (Dynamic Secrets), focusing on on-demand credential generation, lease management, TTL tracking, and automatic revocation across multiple secret backends.\n\nThe dynamic secret engine represents a fundamental shift from traditional static secret management to a **credential vending machine** model. Instead of storing long-lived passwords and API keys that accumulate risk over time, this system generates fresh credentials on demand with built-in expiration dates. Think of it like a parking meter that issues time-limited tickets - you get exactly what you need for exactly how long you need it, and the system automatically cleans up when time expires.\n\n### Dynamic Secret Mental Model: Understanding just-in-time credential generation\n\nBefore diving into implementation details, it's crucial to understand the mental model that underpins dynamic secret generation. Traditional secret management is like a safety deposit box - you store valuable items (passwords, keys) in a secure location and retrieve them when needed. The problem is that these items never change and accumulate risk the longer they exist.\n\n**Dynamic secrets work more like a hotel key card system.** When you check in, the hotel doesn't give you a master key that works forever. Instead, they program a temporary card that works only for your room and only during your stay. The card is worthless before check-in and automatically stops working at checkout. If someone finds your lost card a week later, it's just plastic.\n\nThis mental model extends to database credentials, cloud provider access keys, and API tokens. Instead of creating a shared database user \"app_user\" that every application instance uses, the dynamic secret engine creates unique database users like \"vault-db-app-20241201-142735\" that exist only long enough to serve a specific request or session. When the lease expires, that database user is automatically deleted.\n\nThe **credential vending machine** analogy captures another important aspect - the system doesn't pre-generate credentials and store them. Instead, it has the blueprints (role configurations) and generates fresh credentials at request time. This eliminates the storage risk entirely - there's no static credential to steal from the vault's storage backend.\n\n> **Key Insight**: Dynamic secrets shift the security model from \"protect stored credentials\" to \"minimize credential lifetime.\" A compromise can only access resources during the narrow window when credentials are active.\n\nThe dynamic secret engine operates on three core principles:\n\n1. **Just-in-time generation**: Credentials are created only when requested, not stored in advance\n2. **Lease-based tracking**: Every credential has an explicit expiration time and unique lease ID\n3. **Automatic cleanup**: The system takes responsibility for revoking credentials when leases expire\n\nThis creates a **blast radius containment** effect. If an application is compromised, the attacker gains access to credentials that automatically expire. If the breach is detected within the lease duration, administrators can revoke specific leases immediately rather than rotating shared credentials across all applications.\n\n### Secret Backend Plugins: Database and cloud provider credential generation\n\nThe dynamic secret engine uses a plugin architecture where each **secret backend** implements the specific logic for generating, managing, and revoking credentials for a particular service type. This design provides extensibility while maintaining consistent lease management across all credential types.\n\n> **Decision: Plugin Architecture for Secret Backends**\n> - **Context**: Different services (databases, cloud providers, SSH) have completely different credential models and APIs for user management\n> - **Options Considered**: Monolithic engine with hardcoded backends, plugin system with standardized interfaces, service-specific engines\n> - **Decision**: Plugin system with standardized `SecretBackend` interface\n> - **Rationale**: Enables extensibility without core engine changes, allows third-party backends, maintains consistent lease semantics across credential types\n> - **Consequences**: Slightly more complex than monolithic approach, but enables supporting new services without modifying core vault code\n\nEach secret backend plugin implements a standardized interface that abstracts the credential lifecycle:\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `GenerateCredentials` | `ctx context.Context`, `roleName string`, `ttl time.Duration` | `map[string]interface{}`, `map[string]interface{}`, `error` | Creates new credentials and returns both the credentials data and revocation metadata |\n| `RevokeCredentials` | `ctx context.Context`, `revocationData map[string]interface{}` | `error` | Removes or disables the credentials using stored revocation metadata |\n| `RenewCredentials` | `ctx context.Context`, `revocationData map[string]interface{}`, `increment time.Duration` | `error` | Extends credential lifetime if backend supports renewal |\n| `ValidateRole` | `ctx context.Context`, `roleName string`, `roleConfig map[string]interface{}` | `error` | Validates that role configuration is correct for this backend type |\n\nThe **database secret backend** serves as the primary example of dynamic credential generation. When configured with connection details and appropriate privileges, it can generate unique database users with specific permissions and automatic cleanup:\n\n**Database Backend Role Configuration:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Name` | `string` | Unique identifier for this role within the backend |\n| `CreationStatements` | `[]string` | SQL statements to execute when creating new database user |\n| `RevocationStatements` | `[]string` | SQL statements to execute when cleaning up expired user |\n| `RenewStatements` | `[]string` | SQL statements to execute when extending user lifetime (optional) |\n| `DefaultTTL` | `time.Duration` | Default lease duration if client doesn't specify |\n| `MaxTTL` | `time.Duration` | Maximum lease duration regardless of client request |\n| `RenewIncrement` | `time.Duration` | How much time to add during lease renewal |\n| `AllowedDomains` | `[]string` | Domain restrictions for cloud provider backends |\n| `RoleOptions` | `map[string]interface{}` | Backend-specific configuration options |\n\nWhen a client requests database credentials through the \"database/creds/readonly\" endpoint, the database backend executes the following sequence:\n\n1. **Generate unique username**: Create a cryptographically unique username like \"vault-readonly-20241201-142735-abc123\" to avoid collisions\n2. **Execute creation statements**: Run the configured SQL statements, substituting the generated username and a random password\n3. **Test connectivity**: Attempt to authenticate with the new credentials to verify creation succeeded\n4. **Return credential data**: Provide the username and password to the client\n5. **Store revocation metadata**: Save the username and any cleanup information needed for later revocation\n\n**Database Backend Credential Generation Example:**\n\nFor a role configured with creation statement:\n```sql\nCREATE USER '{{name}}'@'%' IDENTIFIED BY '{{password}}';\nGRANT SELECT ON myapp.* TO '{{name}}'@'%';\n```\n\nThe backend generates:\n- Username: \"vault-readonly-20241201-142735-abc123\"  \n- Password: 32-character random string\n- Executes: `CREATE USER 'vault-readonly-20241201-142735-abc123'@'%' IDENTIFIED BY 'xK9mP...';`\n- Executes: `GRANT SELECT ON myapp.* TO 'vault-readonly-20241201-142735-abc123'@'%';`\n\nThe **cloud provider secret backend** follows similar patterns but generates API keys, access tokens, or service account credentials instead of database users. For AWS, this might involve creating temporary IAM users with specific policies. For Google Cloud, it could generate service account keys with defined roles.\n\n> **Decision: Template-Based Statement Configuration**\n> - **Context**: Different databases and versions have varying syntax for user management commands\n> - **Options Considered**: Hardcoded statements per database type, template system with variable substitution, database-specific plugins\n> - **Decision**: Template system with `{{name}}` and `{{password}}` variable substitution\n> - **Rationale**: Provides flexibility for administrators to customize statements for their specific database configuration and security requirements\n> - **Consequences**: Requires careful template validation to prevent SQL injection, but enables supporting any database with user management capabilities\n\n**Secret Backend Plugin Architecture:**\n\n| Component | Responsibility | Key Data |\n|-----------|---------------|----------|\n| `SecretBackend` | Manages credential lifecycle for specific service type | Backend configuration, role definitions, connection details |\n| `BackendRole` | Defines credential template and permissions | Creation/revocation statements, TTL limits, role options |\n| `CredentialPlugin` | Implements service-specific credential generation | Service client connections, API credentials, user management logic |\n\nEach backend maintains its own connection pool to the target service to avoid connection overhead during credential generation. The database backend, for example, maintains persistent connections to configured database instances and reuses them across credential requests.\n\n⚠️ **Pitfall: Connection Pool Resource Leaks**\nMany implementations create a new database connection for each credential request, leading to connection exhaustion under load. The database backend should maintain a connection pool and reuse connections across credential operations. Similarly, cloud provider backends should reuse HTTP clients and authenticate once rather than per request.\n\n⚠️ **Pitfall: Insufficient Backend Privileges**\nBackends need elevated privileges to create and delete users, which creates a **privilege escalation** risk if the vault itself is compromised. The backend service account should have only the minimum privileges needed for user lifecycle management. For databases, this means `CREATE USER`, `DROP USER`, and `GRANT` privileges but not data access. For cloud providers, it means user management permissions but not resource access.\n\n### Lease Management: TTL tracking, renewal, and automatic revocation\n\nThe lease management system serves as the **control plane** for all dynamic credentials, tracking their lifecycle from creation through expiration or explicit revocation. Think of it as an **automated parking enforcement system** - it tracks when each parking meter expires and automatically issues tickets (revokes credentials) for expired spots.\n\nEvery dynamic credential request creates a **lease** that encapsulates the credential's lifecycle metadata:\n\n**Lease Data Structure:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `ID` | `string` | Globally unique lease identifier (UUID) |\n| `SecretType` | `string` | Type of secret (database, aws, gcp) for routing to correct backend |\n| `BackendPath` | `string` | Which secret backend instance generated this lease |\n| `RoleName` | `string` | Role used for credential generation (affects permissions) |\n| `CreatedAt` | `time.Time` | When the lease was initially created |\n| `ExpiresAt` | `time.Time` | When the lease expires and credentials become invalid |\n| `RenewedAt` | `*time.Time` | Last renewal timestamp (nil if never renewed) |\n| `RenewalCount` | `int` | How many times this lease has been renewed |\n| `MaxTTL` | `time.Duration` | Maximum lifetime regardless of renewals |\n| `Renewable` | `bool` | Whether this lease can be extended before expiration |\n| `TokenID` | `string` | Authentication token that created this lease (for audit) |\n| `RevocationData` | `map[string]interface{}` | Backend-specific data needed for credential cleanup |\n| `SecretData` | `map[string]interface{}` | Credential information returned to client (may be empty for security) |\n| `Status` | `string` | Current lease state (active, expired, revoked) |\n\nThe lease management system operates through several coordinated processes:\n\n**Lease Creation Process:**\n1. **Validate request**: Ensure client has permission for the requested backend path and role\n2. **Generate lease ID**: Create globally unique identifier for tracking this credential lifecycle\n3. **Calculate expiration**: Determine lease duration based on client request, role defaults, and maximum limits\n4. **Invoke backend**: Call the appropriate secret backend to generate actual credentials\n5. **Store lease record**: Persist lease metadata for tracking and future revocation\n6. **Index by expiration**: Add lease to expiration index for efficient cleanup scanning\n7. **Return credentials**: Provide credential data and lease ID to client\n\n> **Decision: Separate Credential Data from Revocation Data**\n> - **Context**: Backends need different information for credential generation vs. cleanup, and storing credentials increases attack surface\n> - **Options Considered**: Store complete credentials in lease, store only revocation data, store both separately\n> - **Decision**: Store revocation data in lease, return credentials to client without persisting\n> - **Rationale**: Minimizes stored secrets (credentials exist only during client session), while preserving cleanup capability through revocation metadata\n> - **Consequences**: Clients must store credentials themselves, but vault storage doesn't contain usable credentials\n\n**Lease Renewal Process:**\nRenewable leases can be extended before expiration to avoid credential cycling for long-running processes. The renewal process implements several safety checks:\n\n1. **Validate lease existence**: Ensure the lease ID exists and is currently active\n2. **Check renewable flag**: Verify that this lease type supports renewal\n3. **Enforce maximum TTL**: Ensure renewed lease won't exceed the configured maximum lifetime\n4. **Calculate new expiration**: Add the requested increment (bounded by role configuration)\n5. **Update lease record**: Modify expiration time, renewal count, and last renewed timestamp\n6. **Update expiration index**: Move lease to new expiration time bucket for cleanup tracking\n7. **Invoke backend renewal**: Allow backend to extend underlying credentials if needed\n\n**Lease Expiration Tracking:**\n\nThe lease management system maintains an **expiration index** that groups leases by expiration time for efficient batch processing:\n\n**LeaseIndex Data Structure:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `ByExpiration` | `map[time.Time][]string` | Groups lease IDs by expiration timestamp for batch processing |\n| `ByToken` | `map[string][]string` | Groups leases by creating token for bulk revocation |\n| `ByBackend` | `map[string][]string` | Groups leases by backend path for backend-specific operations |\n| `ActiveCount` | `int64` | Running count of active leases for monitoring |\n\nThe expiration index enables the **lease reaper** process to efficiently find expired leases without scanning the entire lease database:\n\n**Lease Reaper Algorithm:**\n1. **Scan expiration index**: Find all lease buckets with expiration times before current time\n2. **Batch expired leases**: Collect lease IDs from expired buckets (typically 100-1000 per batch)\n3. **Load lease details**: Retrieve full lease records for the expired lease IDs\n4. **Group by backend**: Organize leases by backend type for efficient revocation\n5. **Revoke credentials**: Call backend revocation methods with stored revocation data\n6. **Update lease status**: Mark leases as revoked in storage\n7. **Update indexes**: Remove revoked leases from all index structures\n8. **Log revocation**: Record successful revocation in audit log for compliance\n\n> **Key Insight**: The lease reaper runs as a background process every 30-60 seconds, but lease expiration times are honored by the authorization system immediately. This means expired credentials are denied access even if revocation hasn't completed yet.\n\n⚠️ **Pitfall: Lease Reaper Failure Handling**\nIf the lease reaper process crashes or becomes unable to revoke credentials, expired leases accumulate and credentials remain active past their intended lifetime. The system should implement **revocation retry logic** with exponential backoff and **alerting** when revocation fails repeatedly. Additionally, the authorization system should reject requests using expired leases regardless of backend credential status.\n\n**Lease Renewal Limits:**\n\n| Scenario | Original TTL | Max TTL | Renewal Request | Result | Rationale |\n|----------|-------------|---------|-----------------|--------|-----------|\n| Normal renewal | 1 hour | 8 hours | +1 hour after 30 minutes | New expiration: 1.5 hours from creation | Within limits |\n| Excessive renewal | 1 hour | 8 hours | +24 hours after 30 minutes | New expiration: 8 hours from creation | Capped at max TTL |\n| Expired lease | 1 hour | 8 hours | +1 hour after 2 hours | Error: lease expired | Cannot renew expired leases |\n| Max TTL reached | 8 hours | 8 hours | +1 hour after 7 hours | Error: would exceed max TTL | Prevent infinite extension |\n\n### Revocation Engine: Cleanup of expired credentials across backends\n\nThe revocation engine serves as the **cleanup crew** for the dynamic secret system, ensuring that expired or compromised credentials are properly removed from target systems. Unlike lease management which tracks metadata, the revocation engine actually interacts with external systems to disable database users, delete cloud IAM keys, and clean up other credential artifacts.\n\nThink of the revocation engine as a **building security system that automatically deactivates keycards**. When an employee leaves or a keycard expires, the system doesn't just mark it as inactive in the database - it actively tells all door readers that the keycard should no longer grant access.\n\n**Revocation Engine Architecture:**\n\nThe revocation engine operates through a **queue-based system** that provides reliability, retry logic, and priority handling for credential cleanup operations:\n\n**RevocationQueue Data Structure:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `LeaseID` | `string` | Unique identifier of the lease being revoked |\n| `BackendPath` | `string` | Which secret backend should handle this revocation |\n| `RevocationData` | `map[string]interface{}` | Backend-specific data needed for credential cleanup |\n| `QueuedAt` | `time.Time` | When this revocation was first queued |\n| `AttemptCount` | `int` | How many revocation attempts have been made |\n| `NextAttempt` | `time.Time` | When to try revocation again (for failed attempts) |\n| `Priority` | `int` | Revocation priority (1=immediate, 2=normal, 3=cleanup) |\n\nThe revocation engine processes this queue continuously, handling both **automatic expiration** and **explicit revocation** requests:\n\n**Revocation Processing Algorithm:**\n1. **Dequeue revocation requests**: Pull revocation requests from queue, ordered by priority and next attempt time\n2. **Load backend configuration**: Retrieve the appropriate secret backend for this revocation\n3. **Execute revocation**: Call backend-specific revocation method with stored revocation data\n4. **Handle success**: Remove revocation request from queue and update lease status\n5. **Handle failure**: Increment attempt count, calculate next retry time with exponential backoff\n6. **Re-queue failed attempts**: Put failed revocations back in queue with updated retry timestamp\n7. **Alert on persistent failures**: Send alerts if revocation fails repeatedly (typically after 5-10 attempts)\n\n> **Decision: Asynchronous Revocation with Retry Queue**\n> - **Context**: Credential revocation involves network calls to external systems that may be temporarily unavailable\n> - **Options Considered**: Synchronous revocation blocking lease expiration, fire-and-forget async revocation, queue-based async revocation with retries\n> - **Decision**: Queue-based asynchronous revocation with exponential backoff retry\n> - **Rationale**: Provides reliability without blocking lease expiration, handles transient network failures gracefully, enables monitoring and alerting for persistent failures\n> - **Consequences**: Adds complexity but ensures credentials are eventually revoked even if target systems are temporarily unreachable\n\n**Backend-Specific Revocation Strategies:**\n\nDifferent types of credentials require different revocation approaches, each with unique failure modes and recovery strategies:\n\n| Backend Type | Revocation Method | Failure Scenarios | Recovery Strategy |\n|--------------|------------------|-------------------|-------------------|\n| Database | `DROP USER` statement | Connection timeout, database offline, user doesn't exist | Retry with connection pool, verify user absence |\n| AWS IAM | Delete user API call | API rate limits, permission denied, user already deleted | Retry with backoff, ignore \"user not found\" errors |\n| Cloud KMS | Disable service account key | Network partition, quota exceeded, key already disabled | Retry different region, ignore \"already disabled\" |\n| SSH Certificate | Revocation list update | Certificate authority offline, signing key unavailable | Queue for CA recovery, maintain revocation list |\n\n**Database Credential Revocation Example:**\n\nWhen revoking database credentials, the database backend executes the configured revocation statements with proper error handling:\n\n**Database Revocation Process:**\n1. **Extract username**: Get database username from revocation data (e.g., \"vault-readonly-20241201-142735-abc123\")\n2. **Terminate active sessions**: Kill any active database sessions for this user to prevent continued access\n3. **Execute revocation statements**: Run configured SQL statements, typically `DROP USER '{{name}}'@'%'`\n4. **Verify deletion**: Query user tables to confirm the user no longer exists\n5. **Handle cleanup errors**: If user doesn't exist, treat as successful (idempotent operation)\n6. **Log revocation result**: Record success or failure details for audit and debugging\n\n⚠️ **Pitfall: Revocation Statement Dependencies**\nDatabase revocation statements must handle dependencies correctly. For example, MySQL requires dropping user privileges before dropping the user itself. The revocation statements should be ordered to handle these dependencies: `REVOKE ALL PRIVILEGES ON *.* FROM '{{name}}'@'%'; DROP USER '{{name}}'@'%';`\n\n**Revocation Failure Handling:**\n\nThe revocation engine implements **exponential backoff** to handle transient failures without overwhelming external systems:\n\n**Retry Schedule:**\n- Attempt 1: Immediate\n- Attempt 2: 1 minute delay  \n- Attempt 3: 2 minute delay\n- Attempt 4: 4 minute delay\n- Attempt 5: 8 minute delay\n- Attempt 6+: 16 minute delay (maximum)\n\nAfter 10 consecutive failures, the revocation request is moved to a **dead letter queue** for manual intervention, and an alert is generated for the operations team.\n\n**Emergency Revocation:**\n\nFor security incidents, the revocation engine supports **priority revocation** that bypasses normal queue ordering:\n\n**Revocation Priority Levels:**\n1. **Immediate (Priority 1)**: Security incident response, suspected compromise - processed within seconds\n2. **Normal (Priority 2)**: Regular lease expiration - processed within 1-2 minutes  \n3. **Cleanup (Priority 3)**: Background cleanup, orphaned resources - processed during off-peak hours\n\nPriority 1 revocations also trigger **parallel revocation** across multiple backend instances and regions to ensure rapid credential invalidation.\n\n**Bulk Revocation Operations:**\n\nThe revocation engine supports bulk operations for scenarios like token revocation (revoking all leases created by a specific token) or backend rotation (revoking all credentials from a compromised backend):\n\n**Bulk Revocation Algorithm:**\n1. **Identify affected leases**: Query lease index by token ID, backend path, or other criteria\n2. **Queue all revocations**: Add revocation requests for all identified leases\n3. **Process with concurrency limits**: Revoke credentials in parallel but respect backend rate limits\n4. **Track completion**: Monitor bulk revocation progress and report completion status\n5. **Handle partial failures**: Continue bulk operation even if individual revocations fail\n\nThis enables rapid response to security incidents where entire token families or backend instances need immediate revocation.\n\n![Dynamic Secret Lifecycle](./diagrams/dynamic-secret-lifecycle.svg)\n\n### Implementation Guidance\n\nThe dynamic secret engine requires careful coordination between lease management, backend plugins, and revocation processing. This implementation guidance provides complete infrastructure code and detailed skeletons for the core learning components.\n\n**A. Technology Recommendations Table:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Lease Storage | In-memory map with periodic disk sync | Embedded database (BadgerDB) with transactions |\n| Revocation Queue | Go channels with worker goroutines | Persistent queue (Redis/database-backed) |\n| Backend Plugins | Direct interface implementation | Plugin system with RPC/gRPC |\n| Time Management | Standard `time.Time` with tickers | Hierarchical timing wheels for efficiency |\n| Credential Generation | Standard `crypto/rand` for passwords | HSM integration for key material |\n\n**B. Recommended File/Module Structure:**\n\n```\ninternal/dynamic/\n  engine.go              ← main dynamic engine\n  engine_test.go         ← engine tests\n  lease.go              ← lease management\n  lease_index.go        ← lease indexing and expiration tracking\n  revocation.go         ← revocation engine and queue\n  backends/\n    interface.go        ← SecretBackend interface definition\n    database/\n      database.go       ← database credential backend\n      mysql.go          ← MySQL-specific implementation\n      postgres.go       ← PostgreSQL-specific implementation\n    aws/\n      aws.go           ← AWS IAM backend\n    registry.go        ← backend plugin registry\n  internal/\n    credential_generator.go ← secure password/key generation\n    retry.go               ← exponential backoff utilities\n```\n\n**C. Infrastructure Starter Code:**\n\n**Credential Generator (complete implementation):**\n\n```go\n// internal/dynamic/internal/credential_generator.go\npackage internal\n\nimport (\n    \"crypto/rand\"\n    \"fmt\"\n    \"math/big\"\n    \"strings\"\n    \"time\"\n)\n\nconst (\n    // Character sets for password generation\n    PasswordChars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n    UsernameChars = \"abcdefghijklmnopqrstuvwxyz0123456789\"\n    DefaultPasswordLength = 32\n    DefaultUsernameLength = 20\n)\n\n// CredentialGenerator provides secure random credential generation\ntype CredentialGenerator struct{}\n\n// GeneratePassword creates a cryptographically secure random password\nfunc (g *CredentialGenerator) GeneratePassword(length int) (string, error) {\n    if length <= 0 {\n        length = DefaultPasswordLength\n    }\n    \n    password := make([]byte, length)\n    for i := range password {\n        charIndex, err := rand.Int(rand.Reader, big.NewInt(int64(len(PasswordChars))))\n        if err != nil {\n            return \"\", fmt.Errorf(\"failed to generate random character: %w\", err)\n        }\n        password[i] = PasswordChars[charIndex.Int64()]\n    }\n    \n    return string(password), nil\n}\n\n// GenerateUsername creates a unique username with timestamp and random suffix\nfunc (g *CredentialGenerator) GenerateUsername(prefix string) (string, error) {\n    timestamp := time.Now().Format(\"20060102-150405\")\n    \n    // Generate random suffix\n    suffix := make([]byte, 6)\n    for i := range suffix {\n        charIndex, err := rand.Int(rand.Reader, big.NewInt(int64(len(UsernameChars))))\n        if err != nil {\n            return \"\", fmt.Errorf(\"failed to generate random suffix: %w\", err)\n        }\n        suffix[i] = UsernameChars[charIndex.Int64()]\n    }\n    \n    // Format: vault-prefix-20241201-142735-abc123\n    username := fmt.Sprintf(\"vault-%s-%s-%s\", prefix, timestamp, string(suffix))\n    \n    // Ensure username doesn't exceed common database limits (32-64 chars)\n    if len(username) > 32 {\n        // Truncate prefix if needed\n        maxPrefix := 32 - len(timestamp) - len(suffix) - len(\"vault--\")\n        if len(prefix) > maxPrefix && maxPrefix > 0 {\n            prefix = prefix[:maxPrefix]\n            username = fmt.Sprintf(\"vault-%s-%s-%s\", prefix, timestamp, string(suffix))\n        }\n    }\n    \n    return username, nil\n}\n\n// SubstituteTemplate replaces {{name}} and {{password}} in template strings\nfunc (g *CredentialGenerator) SubstituteTemplate(template, name, password string) string {\n    result := strings.ReplaceAll(template, \"{{name}}\", name)\n    result = strings.ReplaceAll(result, \"{{password}}\", password)\n    return result\n}\n```\n\n**Retry Logic (complete implementation):**\n\n```go\n// internal/dynamic/internal/retry.go\npackage internal\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"math\"\n    \"time\"\n)\n\n// RetryConfig defines exponential backoff parameters\ntype RetryConfig struct {\n    InitialDelay time.Duration\n    MaxDelay     time.Duration\n    Multiplier   float64\n    MaxAttempts  int\n}\n\n// DefaultRetryConfig provides sensible defaults for revocation retries\nvar DefaultRetryConfig = RetryConfig{\n    InitialDelay: 1 * time.Minute,\n    MaxDelay:     16 * time.Minute,\n    Multiplier:   2.0,\n    MaxAttempts:  10,\n}\n\n// CalculateDelay computes next retry delay using exponential backoff\nfunc (c RetryConfig) CalculateDelay(attemptNumber int) time.Duration {\n    if attemptNumber <= 1 {\n        return 0 // First attempt is immediate\n    }\n    \n    delay := float64(c.InitialDelay) * math.Pow(c.Multiplier, float64(attemptNumber-2))\n    if time.Duration(delay) > c.MaxDelay {\n        delay = float64(c.MaxDelay)\n    }\n    \n    return time.Duration(delay)\n}\n\n// ShouldRetry determines if another attempt should be made\nfunc (c RetryConfig) ShouldRetry(attemptNumber int) bool {\n    return attemptNumber < c.MaxAttempts\n}\n\n// RetryOperation executes operation with exponential backoff\nfunc RetryOperation(ctx context.Context, config RetryConfig, operation func() error) error {\n    var lastErr error\n    \n    for attempt := 1; attempt <= config.MaxAttempts; attempt++ {\n        if attempt > 1 {\n            delay := config.CalculateDelay(attempt)\n            select {\n            case <-time.After(delay):\n                // Continue to retry\n            case <-ctx.Done():\n                return fmt.Errorf(\"retry cancelled: %w\", ctx.Err())\n            }\n        }\n        \n        if err := operation(); err != nil {\n            lastErr = err\n            if !config.ShouldRetry(attempt) {\n                break\n            }\n            continue\n        }\n        \n        return nil // Success\n    }\n    \n    return fmt.Errorf(\"operation failed after %d attempts: %w\", config.MaxAttempts, lastErr)\n}\n```\n\n**D. Core Logic Skeleton Code:**\n\n**Dynamic Engine (core implementation skeleton):**\n\n```go\n// internal/dynamic/engine.go\npackage dynamic\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"sync\"\n    \"time\"\n    \n    \"your-project/internal/dynamic/backends\"\n    \"your-project/internal/dynamic/internal\"\n)\n\n// Engine manages dynamic secret generation and lease tracking\ntype Engine struct {\n    backends     map[string]backends.SecretBackend\n    leases       map[string]*Lease\n    leaseIndex   *LeaseIndex\n    revocationQueue chan *RevocationQueue\n    credGen      *internal.CredentialGenerator\n    \n    // Synchronization\n    leaseMutex   sync.RWMutex\n    \n    // Background workers\n    reaperTicker *time.Ticker\n    stopChan     chan struct{}\n}\n\n// NewEngine creates a new dynamic secret engine\nfunc NewEngine() *Engine {\n    return &Engine{\n        backends:        make(map[string]backends.SecretBackend),\n        leases:          make(map[string]*Lease),\n        leaseIndex:      NewLeaseIndex(),\n        revocationQueue: make(chan *RevocationQueue, 1000),\n        credGen:         &internal.CredentialGenerator{},\n        stopChan:        make(chan struct{}),\n    }\n}\n\n// RegisterBackend adds a secret backend at the specified path\nfunc (e *Engine) RegisterBackend(path string, backend backends.SecretBackend) error {\n    // TODO 1: Validate that path is not already registered\n    // TODO 2: Store backend in backends map\n    // TODO 3: Initialize backend if it has an Init method\n    // Hint: Use path as key in backends map\n    return nil\n}\n\n// GenerateSecret creates new dynamic credentials with lease tracking\nfunc (e *Engine) GenerateSecret(ctx context.Context, backendPath, roleName string, ttl time.Duration, tokenID string) (*Lease, map[string]interface{}, error) {\n    // TODO 1: Look up backend by backendPath in backends map\n    // TODO 2: Generate unique lease ID using crypto/rand or UUID library\n    // TODO 3: Calculate lease expiration time (created + ttl)\n    // TODO 4: Call backend.GenerateCredentials(ctx, roleName, ttl)\n    // TODO 5: Create Lease struct with all required fields\n    // TODO 6: Store lease in leases map with leaseMutex write lock\n    // TODO 7: Add lease to expiration index for reaper processing\n    // TODO 8: Return lease and credentials (credentials are not stored)\n    // Hint: backend.GenerateCredentials returns (credentials, revocationData, error)\n    return nil, nil, nil\n}\n\n// RenewLease extends an existing lease if renewable\nfunc (e *Engine) RenewLease(ctx context.Context, leaseID string, increment time.Duration) (*Lease, error) {\n    // TODO 1: Acquire read lock and look up lease by ID\n    // TODO 2: Validate lease exists and is currently active\n    // TODO 3: Check if lease.Renewable is true\n    // TODO 4: Calculate new expiration (current + increment)\n    // TODO 5: Ensure new expiration doesn't exceed lease.MaxTTL from creation time\n    // TODO 6: Upgrade to write lock and update lease expiration fields\n    // TODO 7: Update lease index with new expiration time\n    // TODO 8: Call backend.RenewCredentials if backend supports it\n    // Hint: New expiration = min(current + increment, created + maxTTL)\n    return nil, nil\n}\n\n// RevokeLease immediately revokes a lease and queues credential cleanup\nfunc (e *Engine) RevokeLease(ctx context.Context, leaseID string) error {\n    // TODO 1: Look up lease and validate it exists\n    // TODO 2: Update lease status to \"revoked\"\n    // TODO 3: Remove lease from expiration index\n    // TODO 4: Create RevocationQueue entry with priority 1 (immediate)\n    // TODO 5: Send revocation request to revocation queue channel\n    // TODO 6: Return success immediately (async revocation)\n    // Hint: Don't wait for actual credential cleanup - queue it\n    return nil\n}\n\n// startLeaseReaper begins background process to clean up expired leases\nfunc (e *Engine) startLeaseReaper() {\n    // TODO 1: Create ticker that runs every 30 seconds\n    // TODO 2: Start goroutine that selects on ticker and stopChan\n    // TODO 3: On each tick, call e.processExpiredLeases()\n    // TODO 4: Store ticker in e.reaperTicker for cleanup\n    // Hint: Use time.NewTicker(30 * time.Second)\n}\n\n// processExpiredLeases finds expired leases and queues them for revocation\nfunc (e *Engine) processExpiredLeases() {\n    // TODO 1: Get current time and find all leases expired before now\n    // TODO 2: Use lease index to efficiently find expired lease IDs\n    // TODO 3: For each expired lease, create RevocationQueue entry\n    // TODO 4: Queue revocation requests (priority 2 for normal expiration)\n    // TODO 5: Update lease status to \"expired\" \n    // TODO 6: Remove from expiration index\n    // Hint: Process in batches of 100-500 to avoid memory spikes\n}\n\n// startRevocationWorkers begins background workers to process revocation queue\nfunc (e *Engine) startRevocationWorkers(numWorkers int) {\n    // TODO 1: Start numWorkers goroutines\n    // TODO 2: Each worker should select on revocationQueue and stopChan\n    // TODO 3: For each revocation request, call e.processRevocation()\n    // TODO 4: Handle panics in worker goroutines with recovery\n    // Hint: Use worker pool pattern with shared revocation queue\n}\n\n// processRevocation executes actual credential cleanup with retry logic\nfunc (e *Engine) processRevocation(revReq *RevocationQueue) {\n    // TODO 1: Look up backend by revReq.BackendPath\n    // TODO 2: Call backend.RevokeCredentials with revReq.RevocationData\n    // TODO 3: If successful, mark revocation complete and return\n    // TODO 4: If failed, increment revReq.AttemptCount\n    // TODO 5: Calculate next retry time using exponential backoff\n    // TODO 6: If under max attempts, re-queue for retry\n    // TODO 7: If max attempts exceeded, move to dead letter queue and alert\n    // Hint: Use internal.DefaultRetryConfig for backoff calculation\n}\n```\n\n**Lease Index (core data structure skeleton):**\n\n```go\n// internal/dynamic/lease_index.go\npackage dynamic\n\nimport (\n    \"sync\"\n    \"time\"\n)\n\n// LeaseIndex provides efficient lookup of leases by various criteria\ntype LeaseIndex struct {\n    ByExpiration map[time.Time][]string\n    ByToken      map[string][]string\n    ByBackend    map[string][]string\n    ActiveCount  int64\n    \n    mutex sync.RWMutex\n}\n\n// NewLeaseIndex creates an empty lease index\nfunc NewLeaseIndex() *LeaseIndex {\n    return &LeaseIndex{\n        ByExpiration: make(map[time.Time][]string),\n        ByToken:      make(map[string][]string),\n        ByBackend:    make(map[string][]string),\n        ActiveCount:  0,\n    }\n}\n\n// AddLease indexes a new lease by all relevant criteria\nfunc (idx *LeaseIndex) AddLease(lease *Lease) {\n    // TODO 1: Acquire write lock\n    // TODO 2: Add lease.ID to ByExpiration[lease.ExpiresAt] slice\n    // TODO 3: Add lease.ID to ByToken[lease.TokenID] slice  \n    // TODO 4: Add lease.ID to ByBackend[lease.BackendPath] slice\n    // TODO 5: Increment ActiveCount\n    // Hint: Initialize slices if map key doesn't exist yet\n}\n\n// RemoveLease removes a lease from all indexes\nfunc (idx *LeaseIndex) RemoveLease(lease *Lease) {\n    // TODO 1: Acquire write lock\n    // TODO 2: Remove lease.ID from ByExpiration[lease.ExpiresAt] slice\n    // TODO 3: Remove lease.ID from ByToken[lease.TokenID] slice\n    // TODO 4: Remove lease.ID from ByBackend[lease.BackendPath] slice\n    // TODO 5: Decrement ActiveCount\n    // TODO 6: Clean up empty slices/map entries to prevent memory leaks\n    // Hint: Use slice filtering to remove specific lease ID\n}\n\n// GetExpiredLeases returns all lease IDs that expired before the given time\nfunc (idx *LeaseIndex) GetExpiredLeases(before time.Time) []string {\n    // TODO 1: Acquire read lock\n    // TODO 2: Iterate through ByExpiration map keys (expiration times)\n    // TODO 3: Collect lease ID slices where expiration time <= before\n    // TODO 4: Flatten collected slices into single lease ID slice\n    // TODO 5: Return deduplicated list of expired lease IDs\n    // Hint: Use make([]string, 0, estimatedSize) for efficiency\n    return nil\n}\n\n// GetLeasesByToken returns all lease IDs created by the specified token\nfunc (idx *LeaseIndex) GetLeasesByToken(tokenID string) []string {\n    // TODO 1: Acquire read lock  \n    // TODO 2: Look up tokenID in ByToken map\n    // TODO 3: Return copy of lease ID slice (don't return internal slice)\n    // TODO 4: Return empty slice if token not found\n    // Hint: Use append([]string(nil), slice...) to copy slice\n    return nil\n}\n```\n\n**E. Language-Specific Hints:**\n\n- Use `sync.RWMutex` for lease storage to allow concurrent reads while protecting writes\n- Use `crypto/rand` for secure lease ID generation: `uuid.NewRandom()` or similar\n- Use `time.NewTicker()` for periodic lease reaper execution\n- Use channel-based worker pools for revocation processing: `make(chan *RevocationQueue, bufferSize)`\n- Use `context.Context` throughout for cancellation and timeouts\n- Use `database/sql` with connection pooling for database backends\n- Store sensitive data like database passwords in `SecretData` map, not as struct fields\n- Use `json` tags on structs for configuration serialization\n\n**F. Milestone Checkpoint:**\n\nAfter implementing the dynamic secret engine:\n\n**What to run:**\n```bash\ngo test ./internal/dynamic/...\ngo run cmd/server/main.go &\ncurl -H \"X-Vault-Token: $TOKEN\" -X POST http://localhost:8443/v1/database/config/mydb \\\n  -d '{\"connection_url\": \"user:pass@tcp(localhost:3306)/\", \"allowed_roles\": [\"readonly\"]}'\ncurl -H \"X-Vault-Token: $TOKEN\" -X POST http://localhost:8443/v1/database/roles/readonly \\\n  -d '{\"creation_statements\": [\"CREATE USER {{name}} IDENTIFIED BY {{password}}\", \"GRANT SELECT ON myapp.* TO {{name}}\"], \"default_ttl\": \"1h\", \"max_ttl\": \"24h\"}'\ncurl -H \"X-Vault-Token: $TOKEN\" -X GET http://localhost:8443/v1/database/creds/readonly\n```\n\n**Expected output:**\n```json\n{\n  \"lease_id\": \"database/creds/readonly/abc123-def456-789012\",\n  \"renewable\": true,\n  \"lease_duration\": 3600,\n  \"data\": {\n    \"username\": \"vault-readonly-20241201-142735-xyz789\",\n    \"password\": \"A1b2C3d4E5f6G7h8I9j0K1l2M3n4O5p6\"\n  }\n}\n```\n\n**What to verify:**\n- Database should contain new user with generated username\n- Lease should appear in lease index and be tracked for expiration\n- After lease TTL expires, database user should be automatically removed\n- Lease renewal should extend expiration time without creating new user\n\n**Signs something is wrong:**\n- Credentials returned but no database user created → Check backend connection and privileges\n- User created but not removed after expiration → Check lease reaper and revocation queue processing\n- Lease renewal fails → Verify MaxTTL calculation and lease status checks\n- High memory usage → Check for lease index cleanup and slice memory leaks\n\n\n## Unsealing and High Availability\n\n> **Milestone(s):** This section implements Milestone 4 (Unsealing & High Availability), focusing on Shamir's secret sharing for master key protection, seal/unseal operations, distributed consensus for high availability, and cloud KMS integration for automated unsealing.\n\nThe final milestone transforms our secret management system from a single-node service into a production-ready, highly available cluster that can operate even when some nodes fail. Think of this transformation like converting a personal safe in your home office into a bank's vault system with multiple security officers, where several officers must work together to open the vault, but the bank remains operational even if some officers are unavailable.\n\nThis milestone introduces two critical capabilities that work together to provide enterprise-grade security and availability. First, **Shamir's secret sharing** protects the master key by splitting it into multiple shares, ensuring that no single person or compromised system can access all secrets. Second, **high availability clustering** ensures the secret management service remains accessible even during node failures, network partitions, or maintenance windows.\n\nThe unsealing mechanism addresses a fundamental security principle: the master key should never exist in plaintext on persistent storage, and the system should start in a \"sealed\" state that requires human intervention or trusted external systems to become operational. This provides protection against scenarios like stolen hard drives, compromised backups, or unauthorized system restarts.\n\nThe high availability features transform our system from a single point of failure into a distributed service that can tolerate node failures while maintaining consistency. This is critical for production environments where secret management downtime can cascade into application outages across an entire infrastructure.\n\n### Shamir's Secret Sharing: Splitting Master Key into Shares for Security\n\nShamir's secret sharing provides the cryptographic foundation for protecting our master key through a threshold scheme that distributes trust across multiple parties. Think of it like a safety deposit box that requires multiple keys held by different bank officers - no single officer can access the contents alone, but any sufficient subset of officers working together can open the box.\n\nThe mathematical elegance of Shamir's scheme lies in polynomial interpolation over finite fields. To protect a secret with a threshold of `t` shares from a total of `n` shares, we construct a random polynomial of degree `t-1` where the secret is the y-intercept (constant term). Each share represents a point on this polynomial, and any `t` points are sufficient to reconstruct the original polynomial and recover the secret. Fewer than `t` points reveal no information about the secret due to the randomness of the higher-order coefficients.\n\n> **Decision: Shamir's Secret Sharing for Master Key Protection**\n> - **Context**: Master key must be protected against single-point-of-compromise while remaining accessible for legitimate operations\n> - **Options Considered**: \n>   - Store encrypted master key with password\n>   - Hardware Security Module (HSM) only\n>   - Shamir's secret sharing with configurable threshold\n> - **Decision**: Implement Shamir's secret sharing with 5 shares and 3-of-5 threshold as default\n> - **Rationale**: Provides cryptographically sound distribution of trust, tolerates loss of 2 shares, requires collaboration of multiple operators, and works without specialized hardware\n> - **Consequences**: Enables true zero-trust master key storage but requires coordination of multiple operators during unsealing operations\n\n| Shamir Parameter | Type | Description | Default Value |\n|------------------|------|-------------|---------------|\n| Total Shares | int | Total number of key shares generated during initialization | 5 |\n| Threshold | int | Minimum number of shares required to reconstruct master key | 3 |\n| Share Length | int | Length of each share in bytes | 33 (1 byte x-coordinate + 32 bytes y-coordinate) |\n| Prime Field | big.Int | Prime number defining the finite field for polynomial arithmetic | 2^256 - 189 |\n| Share Format | string | Encoding format for human-readable shares | Base64 with checksums |\n\nThe share generation process follows these mathematical steps during system initialization:\n\n1. **Generate Random Coefficients**: Create `threshold - 1` random coefficients for polynomial of degree `threshold - 1`, ensuring the constant term equals the master key\n2. **Evaluate Polynomial**: For each share `i` from 1 to `total_shares`, evaluate the polynomial `P(i)` to get the y-coordinate of share `i`\n3. **Encode Shares**: Format each share as `(x=i, y=P(i))` pair with checksums and base64 encoding for human handling\n4. **Verify Reconstruction**: Test that any `threshold` subset of shares correctly reconstructs the original master key\n5. **Secure Distribution**: Present shares to operators through secure channels, ensuring no single operator receives multiple shares\n\nThe reconstruction process reverses this during unsealing operations:\n\n1. **Collect Threshold Shares**: Gather at least `threshold` valid shares from operators through authenticated input channels\n2. **Parse and Validate**: Decode base64 shares, verify checksums, and extract `(x, y)` coordinate pairs for each share\n3. **Lagrange Interpolation**: Use Lagrange interpolation formula to reconstruct polynomial coefficients from the provided points\n4. **Extract Secret**: Evaluate reconstructed polynomial at x=0 to recover the master key (constant term)\n5. **Validate Reconstruction**: Verify reconstructed key matches expected format and can decrypt a test data encryption key\n\nThe `ShamirManager` handles the cryptographic operations while maintaining security invariants:\n\n| ShamirManager Method | Parameters | Returns | Description |\n|---------------------|------------|---------|-------------|\n| GenerateShares | masterKey []byte, threshold int, totalShares int | ([]Share, error) | Splits master key into shares using polynomial over finite field |\n| ReconstructSecret | shares []Share | ([]byte, error) | Reconstructs master key from threshold number of valid shares |\n| ValidateShare | share Share | bool | Verifies share format, checksum, and coordinate validity |\n| SecureInput | prompt string | (Share, error) | Collects share from operator with secure terminal input (no echo) |\n| FormatShare | x int, y []byte | string | Encodes coordinate pair as base64 string with checksum |\n| ParseShare | shareData string | (Share, error) | Decodes and validates share from base64 string representation |\n\nShare security depends on several critical implementation details. Each share must include a cryptographic checksum to prevent typos or corruption during manual entry. The finite field arithmetic must use constant-time operations to prevent timing attacks during reconstruction. Share storage locations should be physically and logically separated - storing all shares on the same backup system defeats the security purpose.\n\n> The critical security insight is that Shamir's scheme provides information-theoretic security: even with unlimited computational power, fewer than threshold shares reveal zero information about the secret. This is stronger than computational security based on hard mathematical problems.\n\n**Common Pitfalls in Shamir Implementation:**\n\n⚠️ **Pitfall: Storing Multiple Shares Together**\nMany implementations defeat Shamir's security by storing multiple shares in the same location (backup system, configuration management, etc.). This creates a single point of compromise that can gather enough shares to reconstruct the master key. Instead, ensure shares are distributed to different operators, stored in separate physical locations, and never aggregated in any single system or backup.\n\n⚠️ **Pitfall: Insufficient Randomness in Polynomial Coefficients**\nUsing weak random number generation for polynomial coefficients can make the scheme vulnerable to attacks. The coefficients must be cryptographically random and uniformly distributed over the finite field. Use `/dev/urandom` or equivalent cryptographic RNG, never `math/rand` or similar pseudo-random generators.\n\n⚠️ **Pitfall: Polynomial Degree Mismatch**\nA polynomial of degree `t-1` requires exactly `t` points for unique reconstruction. Using degree `t` requires `t+1` points, which changes the threshold unexpectedly. Ensure the polynomial degree equals `threshold - 1` and that exactly `threshold` shares are required for reconstruction.\n\n⚠️ **Pitfall: Memory Persistence of Reconstructed Key**\nAfter reconstructing the master key from shares, the key must be cleared from memory when no longer needed. Go's garbage collector cannot guarantee memory clearing, so use explicit zeroing of byte slices and consider using `mlock()` to prevent swapping to disk during reconstruction operations.\n\n### Seal and Unseal Operations: System Startup and Key Reconstruction Process\n\nThe seal and unseal mechanism implements a security state machine that protects the system's cryptographic capabilities when not in active use. Think of this like a bank vault that automatically locks itself during non-business hours and requires multiple officers to unlock it each morning - the vault provides maximum security by default and only becomes accessible through deliberate, authenticated actions.\n\n![Unseal Process Flow](./diagrams/unseal-process-flow.svg)\n\nWhen sealed, our secret management system enters a hardened state where all cryptographic operations are disabled, the master key is absent from memory, and only basic administrative operations remain available. This provides defense against a wide range of attack scenarios: memory dumps cannot reveal the master key, compromised processes cannot access secrets, and even insider threats require coordination with multiple other operators.\n\nThe unsealing process transforms the system from this secure but non-functional state into full operational capability by reconstructing the master key from operator-provided shares and loading the cryptographic engines. This state transition must be carefully orchestrated to maintain security properties while providing operational convenience.\n\n> **Decision: Sealed-by-Default Security Model**\n> - **Context**: System must protect secrets even when storage, memory, or processes are compromised\n> - **Options Considered**:\n>   - Always-available model with encrypted master key\n>   - Manual seal/unseal with Shamir's shares\n>   - Automatic unseal with external key management service\n> - **Decision**: Implement sealed-by-default with both manual and automatic unseal options\n> - **Rationale**: Provides maximum security against storage compromise, memory extraction, and unauthorized restarts while allowing operational flexibility\n> - **Consequences**: Requires operator intervention after restarts but provides strongest security posture and compliance benefits\n\nThe `UnsealManager` coordinates the state transitions and maintains security invariants:\n\n| UnsealManager Field | Type | Description |\n|-------------------|------|-------------|\n| isSealed | bool | Current seal state - true blocks all secret operations |\n| sealMutex | sync.RWMutex | Protects state transitions and concurrent operation checks |\n| masterKey | []byte | Reconstructed master key (nil when sealed) |\n| shamirConfig | ShamirConfig | Threshold and total share configuration from initialization |\n| collectedShares | map[int]Share | Shares collected during current unseal attempt |\n| autoUnsealConfig | *AutoUnsealConfig | Configuration for cloud KMS auto-unseal (optional) |\n| sealTime | time.Time | Timestamp when system was last sealed |\n| unsealProgress | UnsealProgress | Tracks share collection progress for monitoring |\n\nThe seal operation immediately transitions the system to a secure state through these steps:\n\n1. **Acquire Write Lock**: Take exclusive lock on seal mutex to prevent concurrent operations during state transition\n2. **Stop Secret Operations**: Set sealed flag to true, causing all secret API endpoints to return \"sealed\" errors immediately  \n3. **Clear Cryptographic Material**: Zero the master key byte slice in memory and set pointer to nil\n4. **Shutdown Engines**: Stop encryption, authentication, and dynamic secret engines, clearing any cached keys or credentials\n5. **Persist Seal State**: Write seal state marker to storage to maintain sealed state across restarts\n6. **Log Security Event**: Record seal operation in audit log with timestamp, operator identity, and reason\n\nThe unseal operation reverses this process but requires careful validation at each step:\n\n1. **Validate Unseal Preconditions**: Check that system is currently sealed, required shares have been collected, and no conflicting operations are in progress\n2. **Reconstruct Master Key**: Use Shamir's reconstruction algorithm on collected shares to recover the master key, validating mathematical consistency  \n3. **Verify Master Key**: Test reconstructed key by attempting to decrypt a known data encryption key, ensuring the reconstruction was successful\n4. **Initialize Engines**: Start encryption engine with reconstructed master key, load data encryption keys, and prepare cryptographic operations\n5. **Clear Collected Shares**: Zero share data from memory to prevent future reconstruction attempts using same shares\n6. **Update System State**: Set sealed flag to false and remove seal state marker from persistent storage\n7. **Log Security Event**: Record successful unseal in audit log with participating operator count and timestamp\n\n| Unseal State | Description | Allowed Operations | Next States |\n|--------------|-------------|-------------------|-------------|\n| Sealed | No master key in memory, all secret operations blocked | Health checks, unseal share submission, status queries | Unsealing, AutoUnsealing |\n| Unsealing | Collecting shares for manual unseal | Share submission, unseal status, cancel unseal | Sealed, Active |\n| AutoUnsealing | Attempting automatic unseal with external KMS | Status queries, health checks | Sealed, Active |  \n| Active | Master key available, all operations functional | All secret operations, seal command | Sealed |\n\nThe share collection process during unsealing provides feedback to operators while maintaining security:\n\n| UnsealProgress Field | Type | Description |\n|---------------------|------|-------------|\n| SharesRequired | int | Total number of shares needed (threshold value) |\n| SharesCollected | int | Number of valid shares received so far |\n| SharesRemaining | int | Additional shares needed to complete unsealing |\n| CollectedShareIDs | []int | X-coordinates of shares collected (not the share values) |\n| LastShareTime | time.Time | When most recent share was submitted |\n| UnsealStartTime | time.Time | When first share collection began |\n\nThe unseal API provides a stateful interface for operators to submit shares incrementally:\n\n```\nPOST /sys/unseal\n{\n  \"share\": \"base64-encoded-share-with-checksum\",\n  \"reset\": false  // optional: reset collected shares and start over\n}\n\nResponse:\n{\n  \"sealed\": true/false,\n  \"progress\": {\n    \"shares_required\": 3,\n    \"shares_collected\": 1, \n    \"shares_remaining\": 2\n  },\n  \"unseal_time\": \"2024-01-15T10:30:45Z\" // only present when unsealed\n}\n```\n\n**Error Handling During Unseal Operations:**\n\nThe unseal process must handle various failure scenarios gracefully while maintaining security properties:\n\n| Failure Mode | Detection Method | Recovery Action | Security Impact |\n|--------------|------------------|-----------------|-----------------|\n| Invalid Share Format | Base64 decode failure, checksum mismatch | Reject share, maintain collection state | None - invalid input ignored |\n| Duplicate Share | X-coordinate matches previously collected share | Reject duplicate, continue collection | None - prevents operator confusion |\n| Insufficient Shares | Reconstruction attempted with < threshold shares | Return error, maintain collection state | None - mathematical impossibility |  \n| Reconstruction Failure | Lagrange interpolation produces invalid key | Clear all shares, return to sealed state | High - indicates tampering or corruption |\n| Key Validation Failure | Reconstructed key cannot decrypt test DEK | Clear shares, seal system, alert | High - indicates key corruption or attack |\n\n> The unsealing process represents a critical security boundary. Once shares are collected and the master key is reconstructed, the system transitions from maximum security (sealed) to operational capability (unsealed). This transition must be atomic and auditable.\n\n**Common Pitfalls in Seal/Unseal Implementation:**\n\n⚠️ **Pitfall: Race Conditions During State Transitions**\nConcurrent seal and unseal operations, or secret requests during state transitions, can lead to inconsistent state or security vulnerabilities. Always use proper locking (read locks for checking state, write locks for changing state) and ensure all secret operations check the sealed state under lock protection.\n\n⚠️ **Pitfall: Persistent Share Storage** \nSome implementations cache collected shares to disk \"for convenience\" during multi-step unseal operations. This completely undermines Shamir's security by creating a single point where multiple shares can be compromised. Shares must only exist in memory during the unseal process and be immediately zeroed afterward.\n\n⚠️ **Pitfall: Insufficient Master Key Validation**\nAfter reconstructing the master key from shares, some implementations skip validation and assume the reconstruction was correct. This can lead to accepting corrupted or malicious keys. Always validate the reconstructed key by testing it against known encrypted data before transitioning to unsealed state.\n\n⚠️ **Pitfall: Seal State Inconsistency**\nThe seal state must be consistent across memory flags, persistent storage markers, and actual cryptographic engine state. Inconsistencies can lead to security bypasses or operational failures. Ensure all seal/unseal operations update all state locations atomically and include recovery logic for partial state updates.\n\n### High Availability and Consensus: Leader Election and Data Replication Strategies\n\nHigh availability transforms our secret management system from a single-node service into a distributed cluster that continues operating despite node failures, network partitions, and maintenance activities. Think of this like a hospital emergency room with multiple doctors on duty - if one doctor becomes unavailable, the others continue providing care without interruption, and there's a clear protocol for who takes charge during critical situations.\n\nThe fundamental challenge in distributed secret management lies in maintaining strong consistency while providing high availability. Unlike eventual consistency systems where temporary disagreement is acceptable, secret management requires that all nodes have identical views of policies, secrets, and leases. A policy change that allows access on one node but not another could create security vulnerabilities or operational confusion.\n\nOur approach implements a **leader-follower architecture** with **Raft consensus** to ensure linearizable consistency across all cluster operations. One node serves as the elected leader and handles all write operations, while follower nodes can serve read requests and automatically promote to leader if the current leader fails. This provides both consistency guarantees and fault tolerance.\n\n> **Decision: Raft Consensus for Cluster Coordination**\n> - **Context**: Need strong consistency for security policies while providing high availability and partition tolerance\n> - **Options Considered**:\n>   - Multi-master with conflict resolution (eventual consistency)\n>   - Paxos-based consensus with separate coordination service\n>   - Raft consensus integrated into secret management nodes\n> - **Decision**: Implement Raft consensus directly within secret management nodes\n> - **Rationale**: Raft provides understandable strong consistency, integrates well with our existing architecture, and avoids external dependencies for coordination\n> - **Consequences**: Enables strongly consistent cluster operations but requires majority of nodes to be available for write operations\n\nThe `ClusterManager` handles all distributed coordination and maintains cluster membership:\n\n| ClusterManager Field | Type | Description |\n|---------------------|------|-------------|\n| nodeID | string | Unique identifier for this cluster node |\n| raftNode | *raft.Raft | Raft consensus implementation handling leader election and log replication |\n| transport | raft.Transport | Network transport for inter-node Raft messages |\n| logStore | raft.LogStore | Persistent storage for Raft log entries |\n| stableStore | raft.StableStore | Persistent storage for Raft metadata (current term, voted for) |\n| snapshotter | raft.SnapshotStore | Handles creation and restoration of cluster state snapshots |\n| peerSet | []string | Current cluster membership configuration |\n| leadershipChan | chan bool | Notifies when this node gains or loses leadership |\n| isLeader | bool | Current leadership status of this node |\n| lastContact | time.Time | Timestamp of last successful contact with cluster leader |\n\nThe Raft implementation manages three distinct roles that nodes can occupy:\n\n| Node Role | Responsibilities | Message Handling | State Transitions |\n|-----------|------------------|------------------|-------------------|\n| Leader | Processes all write requests, sends heartbeats, replicates log entries | Accepts client requests, sends AppendEntries to followers | Can become follower on higher term or loss of majority |\n| Follower | Serves read requests, forwards writes to leader, participates in elections | Responds to AppendEntries and RequestVote messages | Can become candidate on leader timeout |\n| Candidate | Requests votes during leader election | Sends RequestVote, counts responses | Becomes leader with majority votes or follower with higher term |\n\n**Leader Election Process:**\n\nThe leader election algorithm ensures exactly one leader exists at any time while handling various failure scenarios:\n\n1. **Detect Leader Failure**: Followers monitor heartbeat messages from leader, starting election timer if no contact within election timeout (150-300ms randomized)\n2. **Become Candidate**: Node increments term number, votes for itself, transitions to candidate role, and resets election timer with random component  \n3. **Request Votes**: Send RequestVote messages to all other cluster members containing candidate term, node ID, and last log entry information\n4. **Evaluate Vote Responses**: Collect votes from other nodes, checking that response term matches request term and vote is granted\n5. **Achieve Majority**: If candidate receives votes from majority of nodes (including self), transition to leader role and begin sending heartbeats\n6. **Handle Split Vote**: If no candidate achieves majority before timeout, increment term and restart election with new randomized timeout\n\n**Data Replication and Log Management:**\n\nAll cluster state changes flow through the Raft log to ensure consistent ordering and durability across nodes:\n\n| Raft Log Entry Field | Type | Description |\n|--------------------|------|-------------|\n| Index | uint64 | Sequential position in the Raft log (monotonically increasing) |\n| Term | uint64 | Leader term when entry was created (for detecting stale leaders) |\n| Type | LogEntryType | Type of operation (SecretCreate, PolicyUpdate, TokenRevoke, etc.) |\n| Data | []byte | Serialized operation data containing all information needed to apply change |\n| Timestamp | time.Time | When leader created this log entry |\n| ClientID | string | Identifier of client that initiated this operation (for deduplication) |\n| Checksum | []byte | Integrity check for log entry corruption detection |\n\nThe log replication process ensures all nodes maintain identical state:\n\n1. **Receive Client Request**: Leader validates request, assigns unique log index, and creates log entry with current term\n2. **Append to Local Log**: Leader writes entry to local Raft log with fsync for durability before proceeding\n3. **Replicate to Followers**: Send AppendEntries messages containing new log entry to all follower nodes\n4. **Wait for Majority**: Leader waits for successful acknowledgments from majority of cluster (including self) before committing\n5. **Apply to State Machine**: Once majority confirms, leader applies operation to local state machine and marks entry as committed\n6. **Notify Client**: Return success response to client only after operation is committed and applied\n7. **Propagate Commit**: Next AppendEntries messages inform followers that entry is committed, triggering application to their state machines\n\n**Snapshot Management for Log Compaction:**\n\nRaft logs grow continuously and must be periodically compacted to prevent unbounded storage growth:\n\n| Snapshot Component | Description | Contents |\n|-------------------|-------------|----------|\n| State Machine Image | Complete secret management state at specific log index | All secrets, policies, tokens, leases, and dynamic secret backends |\n| Last Included Index | Log index of last entry included in snapshot | Used to determine which log entries can be safely deleted |\n| Last Included Term | Term of last entry included in snapshot | Required for maintaining Raft invariants during snapshot installation |\n| Cluster Configuration | Membership and peer information | Node IDs and addresses for cluster reconfiguration |\n| Encryption Context | Current key versions and rotation state | Necessary for continuing encryption operations after restore |\n\n**High Availability Deployment Topology:**\n\nA production cluster typically consists of 3 or 5 nodes deployed across multiple failure domains:\n\n| Cluster Size | Fault Tolerance | Split-Brain Protection | Performance Characteristics |\n|--------------|-----------------|------------------------|----------------------------|\n| 3 nodes | 1 node failure | Requires 2/3 majority | Good performance, minimal resource usage |\n| 5 nodes | 2 node failures | Requires 3/5 majority | Higher fault tolerance, more replication overhead |\n| 7+ nodes | 3+ node failures | Requires (n/2)+1 majority | Maximum fault tolerance, significant replication cost |\n\nThe cluster handles read and write operations differently to balance consistency and availability:\n\n| Operation Type | Leader Behavior | Follower Behavior | Consistency Guarantee |\n|----------------|-----------------|-------------------|----------------------|\n| Write Operations | Process locally, replicate via Raft, respond after majority commit | Forward to leader, return leader response | Linearizable (strongest) |\n| Read Operations | Serve immediately from local state | Serve from local state with staleness bounds | Eventually consistent by default |\n| Consistent Reads | Process locally after confirming leadership | Forward to leader for consistency guarantee | Linearizable when requested |\n\n**Network Partition Handling:**\n\nNetwork partitions represent one of the most challenging failure modes for distributed systems:\n\n| Partition Scenario | Majority Partition Behavior | Minority Partition Behavior | Recovery Process |\n|-------------------|---------------------------|----------------------------|------------------|\n| Clean Split | Continue serving requests normally | Enter read-only mode, reject writes | Rejoin cluster, sync from majority |\n| Flapping Network | May experience leadership churn | Cannot form stable quorum | Use jitter and backoff in elections |\n| Isolated Leader | Step down if cannot contact majority | Elect new leader from remaining nodes | Former leader rejoins as follower |\n\n> The key insight for partition tolerance is that Raft chooses consistency over availability - a minority partition becomes read-only rather than risk split-brain scenarios that could compromise security policies.\n\n**Common Pitfalls in High Availability Implementation:**\n\n⚠️ **Pitfall: Split-Brain Scenarios**\nAllowing multiple nodes to accept write operations simultaneously can lead to conflicting policies, duplicated secrets, or security vulnerabilities. Always ensure only the elected Raft leader processes writes, and that leadership changes require majority consensus. Use fencing mechanisms to prevent former leaders from processing requests after losing leadership.\n\n⚠️ **Pitfall: Unbounded Log Growth** \nRaft logs grow continuously and can consume all available disk space if not properly managed. Implement regular snapshotting with configurable thresholds (e.g., every 10,000 entries or 100MB), and ensure old log entries are safely deleted after successful snapshot creation.\n\n⚠️ **Pitfall: Clock Synchronization Dependencies**\nWhile Raft doesn't require synchronized clocks for correctness, significant clock skew can cause operational issues like incorrect lease expiration or audit log ordering. Use NTP or similar time synchronization, and design timeout values to be robust against reasonable clock drift (±100ms typically).\n\n⚠️ **Pitfall: Inadequate Failure Detection**\nSetting heartbeat intervals too long delays failure detection and increases unavailability windows, while too short intervals create unnecessary network traffic and false positives. Use randomized election timeouts (150-300ms) and heartbeat intervals around 50ms for good balance between responsiveness and stability.\n\n### Auto-Unseal Integration: Cloud KMS Integration for Automated Unsealing\n\nAuto-unseal integration addresses the operational challenge of manual unsealing in production environments while maintaining security properties through external key management services. Think of this like a bank vault that can automatically unlock using a secure communication channel with the bank's central security office - it provides operational convenience without compromising the fundamental security model of keeping the master key protected.\n\nTraditional manual unsealing requires human operators to input Shamir shares after every system restart, which creates operational burden and potential availability issues. Auto-unseal solves this by encrypting the master key with a key encryption key (KEK) managed by an external, highly available key management service. The system can then automatically retrieve and use the KEK to decrypt its master key during startup, eliminating the need for human intervention while maintaining the security property that the master key is never stored in plaintext.\n\nThe critical security insight is that auto-unseal shifts the trust boundary rather than eliminating it - instead of trusting human operators with Shamir shares, we trust the external KMS provider with the key encryption key. This trade-off makes sense in cloud environments where the KMS provider offers hardware security modules, audit logging, and fine-grained access controls that may exceed what we can achieve with manual processes.\n\n> **Decision: Hybrid Manual and Auto-Unseal Support**\n> - **Context**: Production environments need automated recovery while maintaining option for air-gapped or manual control scenarios  \n> - **Options Considered**:\n>   - Manual Shamir shares only (maximum security, operational burden)\n>   - Auto-unseal only (operational convenience, external dependencies)\n>   - Hybrid approach supporting both methods\n> - **Decision**: Implement both manual and auto-unseal with configuration-driven selection\n> - **Rationale**: Provides flexibility for different deployment scenarios, allows migration between methods, and maintains compatibility with security requirements that mandate manual control\n> - **Consequences**: Increases implementation complexity but provides maximum deployment flexibility and migration paths\n\nThe `AutoUnsealManager` handles integration with external key management services:\n\n| AutoUnsealManager Field | Type | Description |\n|------------------------|------|-------------|\n| provider | KMSProvider | Interface to specific KMS service (AWS KMS, Azure KeyVault, etc.) |\n| keyID | string | External KMS key identifier for master key encryption |\n| encryptedMasterKey | []byte | Master key encrypted with KMS key, stored locally |\n| authConfig | KMSAuthConfig | Authentication configuration for KMS service access |\n| retryConfig | RetryConfig | Backoff and timeout settings for KMS operations |\n| healthChecker | *KMSHealthChecker | Monitors KMS service availability and key accessibility |\n| lastUnsealTime | time.Time | Timestamp of most recent successful auto-unseal |\n| failureCount | int64 | Count of consecutive auto-unseal failures for alerting |\n\n**Key Management Service Provider Interface:**\n\nThe KMS provider abstraction allows integration with multiple external key management services:\n\n| KMSProvider Method | Parameters | Returns | Description |\n|-------------------|------------|---------|-------------|\n| Encrypt | plaintext []byte, keyID string | ([]byte, error) | Encrypts data using specified KMS key |\n| Decrypt | ciphertext []byte, keyID string | ([]byte, error) | Decrypts data using specified KMS key |\n| GenerateDataKey | keyID string, keySize int | (plaintext []byte, encrypted []byte, error) | Generates new data encryption key |\n| DescribeKey | keyID string | (*KeyMetadata, error) | Retrieves key information and access policies |\n| ListKeys | maxResults int | ([]string, error) | Lists available keys for key discovery |\n| HealthCheck | keyID string | error | Verifies key exists and is accessible |\n\n**AWS KMS Integration Implementation:**\n\nAWS KMS represents the most common auto-unseal scenario and demonstrates the integration pattern:\n\n| AWS KMS Configuration | Type | Description | Example Value |\n|----------------------|------|-------------|---------------|\n| Region | string | AWS region containing the KMS key | us-west-2 |\n| KeyID | string | KMS key identifier (ARN, alias, or key ID) | alias/vault-unseal-key |\n| AccessKeyID | string | AWS access key for API authentication | AKIAIOSFODNN7EXAMPLE |\n| SecretAccessKey | string | AWS secret key (should use IAM roles instead) | wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY |\n| SessionToken | string | AWS session token for temporary credentials | Optional for STS credentials |\n| Endpoint | string | Custom KMS endpoint for testing or regions | https://kms.us-west-2.amazonaws.com |\n\nThe AWS KMS provider implements the interface using the AWS SDK:\n\n```go\ntype AWSKMSProvider struct {\n    client   *kms.KMS\n    region   string\n    keyID    string\n    retries  int\n    timeout  time.Duration\n}\n```\n\n**Auto-Unseal Process Flow:**\n\nThe automated unsealing process combines local cryptographic operations with external KMS calls:\n\n1. **Initialize KMS Client**: Configure authentication credentials, endpoint URLs, and retry policies for the external KMS service\n2. **Retrieve Encrypted Master Key**: Load the locally stored encrypted master key from persistent storage (created during initial seal with auto-unseal)\n3. **Authenticate with KMS**: Present credentials to KMS service and verify access to the configured key encryption key\n4. **Decrypt Master Key**: Call KMS decrypt operation with encrypted master key, receiving plaintext master key in response\n5. **Validate Decrypted Key**: Verify decrypted master key has correct format and can successfully decrypt a test data encryption key\n6. **Initialize Cryptographic Engines**: Start encryption, authentication, and dynamic secret engines using the decrypted master key\n7. **Clear Temporary Data**: Zero the plaintext master key from local variables while leaving it in the encryption engine\n8. **Update System State**: Transition from sealed to unsealed state and begin serving secret management requests\n\n**Failure Handling and Degradation:**\n\nAuto-unseal operations can fail due to network issues, authentication problems, or KMS service outages:\n\n| Failure Type | Symptoms | Recovery Strategy | Fallback Options |\n|--------------|----------|------------------|------------------|\n| Network Connectivity | Timeout errors, connection refused | Exponential backoff retry with circuit breaker | Manual unseal if operators available |\n| Authentication Failure | 401/403 errors from KMS service | Credential refresh, IAM role validation | Alternative credentials or manual unseal |\n| Key Not Found | 404 errors, key disabled/deleted | Alert operators, check key status | Restore from backup or manual unseal |\n| Rate Limiting | 429 errors, quota exceeded | Implement backoff and jitter | Queue unseal requests or manual unseal |\n| KMS Service Outage | 500+ errors, service unavailable | Extended retry with exponential backoff | Manual unseal to maintain availability |\n\nThe retry mechanism implements exponential backoff with jitter to avoid thundering herd problems:\n\n| Retry Attempt | Base Delay | Jitter Range | Max Delay | Total Elapsed |\n|---------------|------------|--------------|-----------|---------------|\n| 1 | 1 second | ±200ms | 1.2s | 1.2s |\n| 2 | 2 seconds | ±400ms | 2.4s | 3.6s |  \n| 3 | 4 seconds | ±800ms | 4.8s | 8.4s |\n| 4 | 8 seconds | ±1.6s | 9.6s | 18s |\n| 5+ | 30 seconds | ±6s | 36s | 54s+ |\n\n**Security Considerations for Auto-Unseal:**\n\nAuto-unseal introduces new attack vectors that must be carefully managed:\n\n| Security Risk | Description | Mitigation Strategy |\n|---------------|-------------|-------------------|\n| KMS Key Compromise | External KMS key is compromised or misused | Use KMS key policies, audit logging, key rotation |\n| Credential Exposure | AWS keys or similar credentials leaked | Use IAM roles, temporary credentials, credential rotation |\n| Network Interception | KMS API calls intercepted or modified | Use TLS, certificate pinning, request signing |\n| Replay Attacks | Old decrypt requests replayed to bypass controls | Use nonces, timestamps, and request uniqueness |\n| Privilege Escalation | Overly broad KMS permissions exploited | Principle of least privilege, specific key access only |\n\nThe KMS key policy should restrict access to only the secret management service:\n\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\"AWS\": \"arn:aws:iam::ACCOUNT:role/vault-unseal-role\"},\n      \"Action\": [\"kms:Decrypt\", \"kms:DescribeKey\"],\n      \"Resource\": \"*\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"kms:ViaService\": \"kms.REGION.amazonaws.com\"\n        }\n      }\n    }\n  ]\n}\n```\n\n**Monitoring and Observability:**\n\nAuto-unseal operations require comprehensive monitoring to detect failures and security issues:\n\n| Metric Category | Key Metrics | Alerting Thresholds |\n|-----------------|-------------|-------------------|\n| Success Rate | Successful unseals / Total attempts | < 95% success rate |\n| Latency | Time from unseal start to completion | > 30 seconds |\n| Error Patterns | KMS error types and frequencies | > 5 auth failures/hour |\n| Credential Health | Time until credential expiration | < 24 hours remaining |\n| Key Accessibility | KMS key describe success rate | Any failures |\n\n**Common Pitfalls in Auto-Unseal Implementation:**\n\n⚠️ **Pitfall: Storing KMS Credentials in Configuration**\nHard-coding AWS access keys or similar credentials in configuration files creates a security vulnerability that defeats the purpose of external key management. Always use IAM roles, instance profiles, or other credential-less authentication methods when possible.\n\n⚠️ **Pitfall: Insufficient KMS Error Handling**\nKMS services can return various error types (throttling, authentication, key not found) that require different handling strategies. Implement specific retry logic for retriable errors while immediately failing for authentication issues that require operator intervention.\n\n⚠️ **Pitfall: Missing Fallback to Manual Unseal**\nIf auto-unseal fails and no manual unseal option is available, the system becomes completely inaccessible until the external dependency is resolved. Always maintain the ability to collect Shamir shares manually as a fallback recovery mechanism.\n\n⚠️ **Pitfall: Overly Broad KMS Permissions**  \nGranting broad KMS permissions like `kms:*` or access to all keys increases the blast radius if credentials are compromised. Use fine-grained permissions that allow access only to the specific key needed for unsealing operations.\n\n### Implementation Guidance\n\nThe unsealing and high availability components represent the most complex part of our secret management system, involving distributed systems concepts, cryptographic operations, and external service integration. This implementation guidance provides the foundation and structure needed to build these components incrementally.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Shamir's Secret Sharing | Custom implementation with math/big | Hashicorp go-shamir library |\n| Raft Consensus | Hashicorp raft library | etcd raft implementation |\n| KMS Integration | AWS SDK with simple retry | Multi-cloud abstraction layer |\n| Network Transport | HTTP/1.1 with connection pooling | gRPC with load balancing |\n| State Storage | BoltDB embedded database | Distributed storage backend |\n\n**Recommended File Structure:**\n\n```\ninternal/\n  unseal/\n    shamir.go              ← Shamir's secret sharing implementation\n    shamir_test.go         ← Cryptographic correctness tests\n    manager.go             ← Seal/unseal state machine\n    manager_test.go        ← State transition tests\n  cluster/\n    raft.go                ← Raft consensus integration\n    raft_test.go           ← Leader election and replication tests\n    transport.go           ← Network transport for Raft messages\n    snapshot.go            ← State machine snapshot handling\n  kms/\n    interface.go           ← KMS provider interface definition\n    aws.go                 ← AWS KMS implementation\n    azure.go               ← Azure Key Vault implementation\n    mock.go                ← Mock provider for testing\n    autounseal.go          ← Auto-unseal coordinator\n  server/\n    cluster_server.go      ← HTTP handlers for cluster operations\n    unseal_handlers.go     ← API endpoints for seal/unseal\ncmd/\n  vault-server/\n    main.go                ← Entry point with cluster startup\nconfig/\n  cluster-example.yaml    ← Example cluster configuration\n```\n\n**Shamir's Secret Sharing Foundation:**\n\n```go\npackage unseal\n\nimport (\n    \"crypto/rand\"\n    \"errors\"\n    \"fmt\"\n    \"math/big\"\n)\n\n// ShamirConfig defines parameters for secret sharing\ntype ShamirConfig struct {\n    Threshold   int    // Minimum shares required for reconstruction\n    TotalShares int    // Total number of shares to generate\n    PrimeField  *big.Int // Prime number defining finite field\n}\n\n// Share represents a single Shamir share with coordinates\ntype Share struct {\n    X        int    // X-coordinate (share number)\n    Y        []byte // Y-coordinate (share value)\n    Checksum []byte // Integrity check for the share\n}\n\n// ShamirManager handles secret sharing operations\ntype ShamirManager struct {\n    config ShamirConfig\n}\n\n// NewShamirManager creates a new manager with given configuration\nfunc NewShamirManager(threshold, totalShares int) (*ShamirManager, error) {\n    // TODO 1: Validate threshold <= totalShares and both > 0\n    // TODO 2: Generate or load appropriate prime field for arithmetic\n    // TODO 3: Initialize ShamirManager with validated configuration\n    // Hint: Use a 256-bit prime like 2^256 - 189 for the field\n}\n\n// GenerateShares splits secret into threshold shares\nfunc (sm *ShamirManager) GenerateShares(secret []byte) ([]Share, error) {\n    // TODO 1: Convert secret bytes to big integer for polynomial arithmetic\n    // TODO 2: Generate threshold-1 random coefficients for polynomial\n    // TODO 3: Evaluate polynomial at x=1,2,...,totalShares to create shares  \n    // TODO 4: Add checksums to each share for integrity validation\n    // TODO 5: Test reconstruction with threshold shares before returning\n    // Hint: Polynomial is P(x) = secret + c1*x + c2*x^2 + ... + c(t-1)*x^(t-1)\n}\n\n// ReconstructSecret rebuilds secret from threshold shares\nfunc (sm *ShamirManager) ReconstructSecret(shares []Share) ([]byte, error) {\n    // TODO 1: Validate we have at least threshold shares\n    // TODO 2: Verify checksums on all provided shares\n    // TODO 3: Use Lagrange interpolation to reconstruct polynomial coefficients\n    // TODO 4: Evaluate polynomial at x=0 to get secret (constant term)\n    // TODO 5: Convert big integer result back to byte slice\n    // Hint: Lagrange formula: sum over i of (y_i * product over j≠i of (0-x_j)/(x_i-x_j))\n}\n```\n\n**Seal/Unseal State Machine:**\n\n```go\npackage unseal\n\nimport (\n    \"sync\"\n    \"time\"\n)\n\n// UnsealManager coordinates system seal/unseal operations\ntype UnsealManager struct {\n    isSealed        bool\n    sealMutex       sync.RWMutex\n    masterKey       []byte\n    shamirManager   *ShamirManager\n    collectedShares map[int]Share\n    autoUnseal      *AutoUnsealManager\n    \n    // State tracking\n    sealTime        time.Time\n    unsealProgress  UnsealProgress\n}\n\n// UnsealProgress tracks share collection during unsealing\ntype UnsealProgress struct {\n    SharesRequired   int       `json:\"shares_required\"`\n    SharesCollected  int       `json:\"shares_collected\"`  \n    SharesRemaining  int       `json:\"shares_remaining\"`\n    CollectedShareIDs []int    `json:\"collected_share_ids\"`\n    LastShareTime    time.Time `json:\"last_share_time\"`\n    UnsealStartTime  time.Time `json:\"unseal_start_time\"`\n}\n\n// NewUnsealManager creates manager with given Shamir configuration\nfunc NewUnsealManager(threshold, totalShares int) (*UnsealManager, error) {\n    // TODO 1: Create ShamirManager with provided parameters\n    // TODO 2: Initialize UnsealManager in sealed state\n    // TODO 3: Set up empty share collection map\n    // TODO 4: Initialize progress tracking structures\n}\n\n// Seal immediately transitions system to sealed state\nfunc (um *UnsealManager) Seal() error {\n    // TODO 1: Acquire write lock to prevent concurrent operations\n    // TODO 2: Set sealed flag to true to block secret operations\n    // TODO 3: Zero and nil the master key to clear from memory\n    // TODO 4: Clear any collected shares from memory\n    // TODO 5: Record seal time and log security event\n    // Hint: Use explicit zeroing like for i := range um.masterKey { um.masterKey[i] = 0 }\n}\n\n// SubmitShare adds a share to the unsealing process\nfunc (um *UnsealManager) SubmitShare(shareData string) (*UnsealProgress, error) {\n    // TODO 1: Parse and validate the provided share data\n    // TODO 2: Check if share X-coordinate is already collected (reject duplicates)\n    // TODO 3: Add share to collection and update progress tracking\n    // TODO 4: If threshold reached, attempt reconstruction and unsealing\n    // TODO 5: Return current progress status regardless of completion\n    // Hint: Always return progress to show operator current state\n}\n\n// IsSealed returns current seal status (thread-safe)\nfunc (um *UnsealManager) IsSealed() bool {\n    // TODO 1: Acquire read lock to safely check state\n    // TODO 2: Return current sealed flag value\n    // Hint: Use RLock/RUnlock for concurrent read access\n}\n```\n\n**Raft Cluster Integration:**\n\n```go\npackage cluster\n\nimport (\n    \"time\"\n    \"github.com/hashicorp/raft\"\n)\n\n// ClusterManager handles distributed consensus and replication\ntype ClusterManager struct {\n    nodeID      string\n    raftNode    *raft.Raft\n    transport   raft.Transport\n    logStore    raft.LogStore\n    stableStore raft.StableStore\n    snapshots   raft.SnapshotStore\n    \n    // Leadership tracking\n    isLeader       bool\n    leadershipChan chan bool\n    lastContact    time.Time\n}\n\n// ClusterConfig defines cluster membership and networking\ntype ClusterConfig struct {\n    NodeID      string   `yaml:\"node_id\"`\n    BindAddress string   `yaml:\"bind_address\"`\n    DataDir     string   `yaml:\"data_dir\"`\n    Peers       []string `yaml:\"peers\"`\n    \n    // Raft timing parameters\n    HeartbeatTimeout   time.Duration `yaml:\"heartbeat_timeout\"`\n    ElectionTimeout    time.Duration `yaml:\"election_timeout\"`\n    CommitTimeout      time.Duration `yaml:\"commit_timeout\"`\n    LeaderLeaseTimeout time.Duration `yaml:\"leader_lease_timeout\"`\n}\n\n// NewClusterManager initializes Raft consensus for the node\nfunc NewClusterManager(config ClusterConfig) (*ClusterManager, error) {\n    // TODO 1: Create BoltDB stores for Raft log and stable storage\n    // TODO 2: Set up TCP transport for inter-node communication\n    // TODO 3: Configure Raft timing parameters from config\n    // TODO 4: Initialize Raft node with stores and transport\n    // TODO 5: Set up leadership change notification channel\n    // Hint: Use raft.Config with reasonable defaults for timing parameters\n}\n\n// Start begins Raft consensus participation\nfunc (cm *ClusterManager) Start() error {\n    // TODO 1: Bootstrap cluster if this is the first node\n    // TODO 2: Join existing cluster if peers are configured\n    // TODO 3: Start leadership monitoring goroutine\n    // TODO 4: Begin accepting client requests based on leadership status\n    // Hint: Check if stable store is empty to determine bootstrap vs join\n}\n\n// Apply submits operation to Raft for consensus and replication\nfunc (cm *ClusterManager) Apply(operation []byte, timeout time.Duration) error {\n    // TODO 1: Check if this node is current leader\n    // TODO 2: Create Raft log entry with operation data\n    // TODO 3: Submit to Raft and wait for majority commitment\n    // TODO 4: Return error if operation fails consensus or times out\n    // Hint: Only leaders can accept write operations in Raft\n}\n\n// IsLeader returns current leadership status\nfunc (cm *ClusterManager) IsLeader() bool {\n    // TODO 1: Return cached leadership status\n    // TODO 2: Consider checking Raft state for authoritative answer\n    // Hint: Cache leadership to avoid expensive Raft state checks\n}\n```\n\n**Auto-Unseal with AWS KMS:**\n\n```go\npackage kms\n\nimport (\n    \"context\"\n    \"time\"\n    \"github.com/aws/aws-sdk-go/service/kms\"\n)\n\n// KMSProvider defines interface for key management services\ntype KMSProvider interface {\n    Encrypt(ctx context.Context, plaintext []byte, keyID string) ([]byte, error)\n    Decrypt(ctx context.Context, ciphertext []byte, keyID string) ([]byte, error)\n    HealthCheck(ctx context.Context, keyID string) error\n}\n\n// AWSKMSProvider implements KMS interface for AWS\ntype AWSKMSProvider struct {\n    client  *kms.KMS\n    region  string\n    keyID   string\n    retries int\n    timeout time.Duration\n}\n\n// AutoUnsealManager coordinates automatic unsealing with external KMS\ntype AutoUnsealManager struct {\n    provider           KMSProvider\n    keyID              string\n    encryptedMasterKey []byte\n    retryConfig        RetryConfig\n    healthChecker      *KMSHealthChecker\n    \n    // Monitoring\n    lastUnsealTime time.Time\n    failureCount   int64\n}\n\n// NewAWSKMSProvider creates AWS KMS client with configuration  \nfunc NewAWSKMSProvider(region, keyID string) (*AWSKMSProvider, error) {\n    // TODO 1: Create AWS session with region and credentials\n    // TODO 2: Initialize KMS client with session\n    // TODO 3: Configure retry behavior and timeouts\n    // TODO 4: Validate key exists and is accessible\n    // Hint: Use AWS SDK v1 for simpler credential handling\n}\n\n// Encrypt encrypts data using AWS KMS key\nfunc (aws *AWSKMSProvider) Encrypt(ctx context.Context, plaintext []byte, keyID string) ([]byte, error) {\n    // TODO 1: Create KMS encrypt request with data and key ID\n    // TODO 2: Call KMS encrypt API with context for cancellation\n    // TODO 3: Handle AWS-specific errors (throttling, auth, etc.)\n    // TODO 4: Return ciphertext blob from KMS response\n    // Hint: AWS returns base64-encoded ciphertext that includes metadata\n}\n\n// Decrypt decrypts data using AWS KMS  \nfunc (aws *AWSKMSProvider) Decrypt(ctx context.Context, ciphertext []byte, keyID string) ([]byte, error) {\n    // TODO 1: Create KMS decrypt request with ciphertext blob\n    // TODO 2: Call KMS decrypt API (key ID embedded in ciphertext)\n    // TODO 3: Implement exponential backoff for retriable errors\n    // TODO 4: Return plaintext from successful decrypt response\n    // Hint: KMS ciphertext includes key ID, so explicit keyID parameter not needed\n}\n\n// AttemptAutoUnseal tries to unseal using KMS-encrypted master key\nfunc (am *AutoUnsealManager) AttemptAutoUnseal(ctx context.Context) error {\n    // TODO 1: Load encrypted master key from local storage\n    // TODO 2: Call KMS provider decrypt with retry logic\n    // TODO 3: Validate decrypted key format and test against known DEK\n    // TODO 4: Initialize encryption engines with recovered master key\n    // TODO 5: Clear plaintext key from local variables after use\n    // Hint: Implement circuit breaker pattern for repeated KMS failures\n}\n```\n\n**Milestone Checkpoint for Unsealing and High Availability:**\n\nAfter implementing this milestone, your system should demonstrate the following capabilities:\n\n1. **Shamir Share Generation**: Run `./vault-server generate-shares -threshold=3 -total=5` to create master key shares\n2. **Manual Unsealing**: Start server in sealed mode, submit shares via API until threshold reached and system unseals\n3. **Cluster Formation**: Start multiple nodes that discover each other and elect a leader for write operations\n4. **Auto-Unseal**: Configure AWS KMS integration and verify automatic unsealing after restart\n5. **Failure Recovery**: Stop leader node and verify follower promotion maintains service availability\n\n**Expected test outcomes:**\n```bash\n# Test Shamir correctness\ngo test ./internal/unseal -run TestShamirReconstruction\n# Should pass with various threshold combinations\n\n# Test seal/unseal state machine  \ngo test ./internal/unseal -run TestSealUnsealCycle\n# Should handle concurrent operations correctly\n\n# Test cluster consensus\ngo test ./internal/cluster -run TestLeaderElection  \n# Should elect leader and replicate operations\n\n# Test auto-unseal integration\ngo test ./internal/kms -run TestAutoUnseal\n# Should unseal using mocked KMS responses\n```\n\n**Debugging Tips:**\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---------|--------------|-----------|-----|\n| Shares don't reconstruct original key | Polynomial degree mismatch or field arithmetic error | Check that polynomial degree = threshold-1, verify field operations | Use consistent prime field, validate coefficient generation |\n| System hangs during unseal | Deadlock in seal mutex or blocking KMS call | Check goroutine stacks, verify lock ordering | Use context timeouts, avoid nested locking |\n| Cluster nodes can't find each other | Network configuration or Raft transport issues | Check bind addresses, firewall rules, DNS resolution | Verify peer addresses match actual network interfaces |\n| Frequent leadership changes | Network instability or timing parameter issues | Monitor Raft logs for election triggers, check network latency | Increase election timeout, improve network stability |\n| Auto-unseal fails intermittently | KMS service throttling or credential expiration | Check AWS CloudTrail logs, monitor KMS API responses | Implement exponential backoff, refresh credentials |\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** This section spans all four milestones, demonstrating how the components developed in each milestone interact to process requests. It shows authentication and authorization flows (Milestone 2), secret encryption/decryption operations (Milestone 1), dynamic secret generation (Milestone 3), and how the system operates in sealed/unsealed states (Milestone 4).\n\nThink of the secret management system as a sophisticated corporate bank with multiple security checkpoints, automated vaults, and background maintenance systems. When a client makes a withdrawal request (secret retrieval), their identity gets verified at the front desk (authentication), their access permissions get checked against the account rules (authorization), the secure vault gets unlocked with the right keys (encryption), and background systems handle account maintenance like expiring temporary accounts (lease management). This section maps out all these interaction flows and background processes.\n\nThe secret management system operates through three primary interaction patterns: synchronous request/response flows that handle client operations, asynchronous background processes that maintain system health, and internal component communication that coordinates distributed operations. Each pattern has distinct characteristics, error handling requirements, and performance considerations that shape the overall system behavior.\n\n### REST API Design\n\nThe REST API serves as the primary interface between clients and the secret management system, following a path-based URL structure that mirrors the internal policy hierarchy. The API design philosophy emphasizes consistency, security, and discoverability while maintaining compatibility with HashiCorp Vault's client ecosystem.\n\n#### API Endpoint Structure\n\nThe API follows a hierarchical path structure where each segment represents a different system concern. Think of the URL structure like a filing system in a corporate office - the first folder indicates the department (auth, secret, sys), the second folder indicates the specific service or mount point, and subsequent folders represent the actual resources being accessed. This hierarchy enables both human operators and automated tools to understand access patterns and implement appropriate security policies.\n\n| Endpoint Category | Path Pattern | Purpose | Authentication Required |\n|------------------|-------------|---------|----------------------|\n| Authentication | `/v1/auth/{method}/{operation}` | Login and token operations | Partial (method-specific) |\n| Secret Operations | `/v1/secret/{path}` | Static secret CRUD operations | Yes (bearer token) |\n| Dynamic Secrets | `/v1/{backend}/{operation}` | Dynamic credential generation | Yes (bearer token) |\n| System Operations | `/v1/sys/{operation}` | Administrative and status operations | Yes (elevated privileges) |\n| Health/Status | `/v1/sys/health` | System status and readiness checks | No |\n\nThe authentication endpoints handle the initial identity verification process, accepting different credential types based on the configured authentication methods. Secret operation endpoints manage static secrets with full CRUD capabilities, supporting both key-value operations and metadata management. Dynamic secret endpoints are mounted at configurable paths and provide credential generation specific to each backend type. System operation endpoints handle administrative tasks like policy management, unsealing, and configuration.\n\n#### Request and Response Format Standards\n\nAll API interactions use JSON for request and response bodies, with consistent error handling and metadata structure across all endpoints. The response format follows a standardized envelope that provides both the requested data and contextual information needed for client decision-making.\n\n**Standard Response Envelope:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `request_id` | string | Unique identifier for request tracking and audit correlation |\n| `lease_id` | string | Lease identifier for renewable/revocable responses (dynamic secrets) |\n| `renewable` | boolean | Whether this response can be renewed before expiration |\n| `lease_duration` | integer | Seconds until this response expires (0 for non-expiring) |\n| `data` | object | The actual response payload specific to the operation |\n| `warnings` | array | Non-fatal issues that clients should be aware of |\n| `auth` | object | Authentication information for login responses |\n| `wrap_info` | object | Response wrapping metadata for secure token delivery |\n\n**Error Response Format:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `errors` | array | Human-readable error messages for debugging |\n| `error_type` | string | Machine-readable error category for client handling |\n| `request_id` | string | Request identifier for correlation with audit logs |\n\n> **Design Insight**: The response envelope pattern provides clients with all necessary information to handle credential lifecycle management without requiring additional API calls. The lease metadata enables clients to proactively renew credentials before expiration, while the request ID enables correlation between client operations and server audit logs for security investigations.\n\n#### Authentication Header Requirements\n\nThe API uses bearer token authentication carried in HTTP headers, following OAuth 2.0 conventions while supporting Vault-specific token features. Think of the authentication header like an electronic keycard that employees use to access different areas of a corporate building - the card identifies the person and contains access permissions that are checked at each secured door.\n\n| Header Name | Format | Purpose | Required When |\n|-------------|--------|---------|---------------|\n| `X-Vault-Token` | Bearer token string | Primary authentication credential | All authenticated requests |\n| `X-Vault-Namespace` | Namespace path | Multi-tenancy isolation (future extension) | Multi-tenant deployments |\n| `X-Vault-Request-ID` | UUID string | Client-provided request correlation | Optional (server generates if missing) |\n| `X-Vault-Wrap-TTL` | Duration string | Response wrapping TTL request | When requesting wrapped responses |\n\n**Token Types and Behavior:**\n\n| Token Type | Characteristics | Use Case |\n|------------|----------------|----------|\n| Service | Long-lived, renewable, bound to policies | Application authentication |\n| Batch | Short-lived, encrypted, lightweight | High-throughput scenarios |\n| Orphan | No parent relationship, manual lifecycle | Root access and emergency recovery |\n\n> **Decision: Bearer Token Authentication**\n> - **Context**: Need to balance security with client implementation simplicity across diverse application environments\n> - **Options Considered**: \n>   - HTTP Basic Auth with username/password\n>   - JWT tokens with embedded claims\n>   - Bearer tokens with server-side validation\n> - **Decision**: Bearer tokens with server-side state and validation\n> - **Rationale**: Provides immediate revocation capability, supports fine-grained policy evaluation, and enables audit logging with full context\n> - **Consequences**: Requires server-side token storage and validation, but enables precise access control and immediate security response\n\n### Request Processing Pipeline\n\nThe request processing pipeline transforms incoming HTTP requests through multiple security and business logic stages before generating responses. Think of this pipeline like airport security screening - each checkpoint validates different aspects of the passenger (request) and their credentials, with the ability to reject the request at any stage if security requirements aren't met.\n\nThe pipeline operates as a series of filters, where each stage can either pass the request to the next stage, return an error response, or modify the request context for downstream processing. This design enables consistent security policy enforcement while maintaining performance through early rejection of invalid requests.\n\n#### Stage 1: Request Parsing and Validation\n\nThe initial stage handles HTTP-level parsing and basic request validation before any security processing begins. This stage protects the system from malformed requests and provides early feedback for client debugging.\n\n**Request Parsing Process:**\n\n1. **HTTP Method and Path Extraction**: The server extracts the HTTP method and URL path, validating that the method is supported for the requested endpoint. Unsupported methods return HTTP 405 Method Not Allowed with an Allow header indicating supported methods.\n\n2. **Header Validation**: All required headers are validated for presence and format correctness. The `Content-Type` header must be `application/json` for request bodies, and the `Accept` header should include `application/json` for response formatting.\n\n3. **Body Size and Format Validation**: Request bodies are limited to prevent memory exhaustion attacks. JSON parsing occurs with strict validation - malformed JSON immediately returns HTTP 400 Bad Request with parsing error details.\n\n4. **Path Parameter Extraction**: URL path segments are parsed and validated according to the endpoint's parameter requirements. Special characters are URL-decoded and validated against allowed character sets to prevent injection attacks.\n\n5. **Query Parameter Processing**: Query parameters are parsed and validated according to endpoint specifications. Parameters like `version` for secret operations and `ttl` for dynamic secrets undergo type and range validation.\n\n**Request Validation Table:**\n\n| Validation Type | Check Performed | Error Response | Recovery Action |\n|----------------|----------------|----------------|-----------------|\n| Content-Type | Must be application/json for POST/PUT | 415 Unsupported Media Type | Client must set correct header |\n| Body Size | Must be under 1MB limit | 413 Payload Too Large | Client must reduce request size |\n| JSON Syntax | Must parse as valid JSON | 400 Bad Request with parse error | Client must fix JSON formatting |\n| Required Fields | Must contain all mandatory fields | 400 Bad Request with missing fields | Client must include required data |\n| Field Types | Must match expected data types | 400 Bad Request with type errors | Client must correct data types |\n\n#### Stage 2: Authentication and Identity Resolution\n\nThe authentication stage verifies client identity and resolves the authenticated entity to internal identity structures. This stage implements the bearer token authentication model while supporting extensibility for additional authentication methods.\n\n**Authentication Process Flow:**\n\n1. **Token Extraction**: The `X-Vault-Token` header is extracted and validated for proper format. Missing tokens result in HTTP 401 Unauthorized for protected endpoints, while malformed tokens return HTTP 400 Bad Request with format guidance.\n\n2. **Token Lookup and Validation**: The token is looked up in the token store using constant-time comparison to prevent timing attacks. Invalid or expired tokens immediately return HTTP 403 Forbidden with appropriate error details.\n\n3. **Token Metadata Resolution**: Valid tokens have their associated metadata loaded, including policies, TTL information, usage constraints, and parent token relationships. This metadata drives subsequent authorization decisions.\n\n4. **Identity Construction**: An `Identity` object is constructed containing all relevant information about the authenticated entity, including resolved policies from direct assignment and group membership.\n\n5. **Usage Tracking and Limits**: Token usage is recorded for audit purposes and usage limits are enforced. Tokens that exceed their maximum usage count are immediately revoked.\n\n**Authentication Methods Comparison:**\n\n| Method | Token Format | Validation Approach | Performance | Security Level |\n|--------|-------------|-------------------|-------------|----------------|\n| Token | Random string | Server-side lookup | Fast (memory/cache) | High (immediate revocation) |\n| JWT | Signed JSON | Cryptographic validation | Faster (no lookup) | Medium (revocation lag) |\n| mTLS | X.509 Certificate | Certificate chain validation | Moderate | Very High (crypto proof) |\n\n> **Decision: Server-Side Token Validation**\n> - **Context**: Need immediate token revocation capability for security incidents while maintaining high request throughput\n> - **Options Considered**:\n>   - JWT tokens with embedded claims and expiration\n>   - Server-side token store with fast lookup\n>   - Hybrid approach with cached validation\n> - **Decision**: Server-side token store with memory caching\n> - **Rationale**: Enables immediate revocation for security response, supports complex usage tracking, and provides full audit context\n> - **Consequences**: Requires server-side state management but provides superior security control and immediate policy updates\n\n#### Stage 3: Authorization and Policy Evaluation\n\nThe authorization stage determines whether the authenticated identity has permission to perform the requested operation on the specified resource path. This implements the path-based access control system with wildcard matching and parameter validation.\n\n**Policy Evaluation Algorithm:**\n\n1. **Path Normalization**: The requested path is normalized by removing trailing slashes, resolving relative references, and converting to canonical form. This prevents authorization bypass through path manipulation.\n\n2. **Policy Collection**: All policies associated with the authenticated identity are collected, including directly assigned policies and policies inherited through group membership. Policy collection follows a breadth-first pattern to ensure complete coverage.\n\n3. **Rule Matching**: Each policy rule is evaluated against the normalized request path using wildcard matching. Rules are processed in order of specificity, with more specific patterns taking precedence over general patterns.\n\n4. **Capability Verification**: The requested operation is checked against the capabilities granted by matching policy rules. Operations must be explicitly allowed - the system implements default deny with explicit allow semantics.\n\n5. **Parameter Validation**: Request parameters are validated against policy constraints including allowed values, required parameters, and denied parameters. This provides fine-grained control over operation characteristics.\n\n6. **TTL and Constraint Application**: Maximum TTL limits and other constraints from matching policies are applied to the request context. These constraints are enforced during secret operations and lease generation.\n\n**Policy Rule Evaluation Table:**\n\n| Rule Type | Pattern Example | Matches | Grants | Constraints Applied |\n|-----------|----------------|---------|--------|-------------------|\n| Exact Path | `secret/myapp/db` | Exact path only | Specified capabilities | All policy constraints |\n| Single Wildcard | `secret/myapp/*` | Direct children only | Specified capabilities | All policy constraints |\n| Recursive Wildcard | `secret/myapp/**` | All descendants | Specified capabilities | All policy constraints |\n| Parameter Filter | `secret/+/config` | Paths with parameters | Conditional on parameters | Parameter-specific limits |\n\n> **Critical Security Insight**: The policy evaluation must be performed on every request, even for cached or frequently accessed secrets. Authorization state can change independently of authentication state through policy updates, token revocation, or identity modifications. Caching authorization decisions creates security vulnerabilities where access continues after permissions are revoked.\n\n#### Stage 4: Secret Operations and Business Logic\n\nThe final stage implements the actual business logic for secret operations, including encryption, decryption, lease management, and audit logging. This stage coordinates between multiple system components to fulfill the client request while maintaining security and consistency guarantees.\n\n**Secret Retrieval Process:**\n\n1. **Path Resolution**: The secret path is resolved to determine the storage backend and any path transformations required. Mount point processing handles backend-specific path mapping and parameter extraction.\n\n2. **Encryption Context Preparation**: For encrypted secrets, the encryption context is prepared including the data encryption key version, authentication data, and any path-specific encryption parameters.\n\n3. **Storage Operation**: The appropriate storage backend is invoked to retrieve the encrypted secret data. Storage errors are classified as temporary (retry) or permanent (fail immediately) based on error type.\n\n4. **Decryption and Data Processing**: Retrieved secrets undergo decryption using the envelope encryption system. Version resolution ensures the correct data encryption key is used for each secret version.\n\n5. **Response Preparation**: The decrypted secret data is formatted into the standard response envelope with appropriate metadata including version information, lease details, and renewal capabilities.\n\n6. **Audit Event Generation**: Comprehensive audit events are generated capturing the complete request context, operation outcome, and any security-relevant details for compliance and security monitoring.\n\n**Dynamic Secret Generation Process:**\n\n1. **Backend Resolution**: The dynamic secret request is routed to the appropriate secret backend based on the mount point. Backend-specific role and configuration validation occurs at this stage.\n\n2. **Credential Generation**: The secret backend generates new credentials according to the role configuration. This may involve database user creation, cloud IAM role assumption, or certificate generation.\n\n3. **Lease Creation and Tracking**: A lease is created to track the generated credentials including expiration time, renewal capabilities, and revocation data needed for cleanup.\n\n4. **Credential Delivery**: Generated credentials are packaged into the response with lease metadata. Sensitive credential data is never logged or stored in plaintext.\n\n5. **Background Lease Registration**: The lease is registered with the lease management system for tracking expiration and enabling background revocation processing.\n\n### Background Processes\n\nThe secret management system operates several critical background processes that maintain security, performance, and operational health independently of client request processing. Think of these background processes like the maintenance staff in a corporate building - they work behind the scenes to ensure security systems function properly, expired access badges are deactivated, and facility operations continue smoothly without disrupting daily business operations.\n\nThese processes implement the \"defense in depth\" principle by providing multiple independent layers of security enforcement and system maintenance. Each process operates on its own schedule with appropriate error handling and retry logic to ensure system reliability even during partial failures.\n\n#### Lease Management and Revocation Engine\n\nThe lease management system tracks all dynamic secrets throughout their lifecycle and ensures proper cleanup when credentials expire or are explicitly revoked. This system prevents credential accumulation that could create security vulnerabilities or resource exhaustion in target systems.\n\n**Lease Tracking Data Structure:**\n\n| Component | Purpose | Update Frequency | Persistence Requirements |\n|-----------|---------|-----------------|------------------------|\n| Lease Index by Expiration | Fast lookup of expired leases | Real-time on creation/renewal | Memory with periodic snapshots |\n| Lease Index by Token | Token revocation support | Real-time on creation | Memory with write-through |\n| Lease Index by Backend | Backend-specific operations | Real-time on creation | Memory with write-through |\n| Revocation Queue | Retry failed revocations | As needed for failures | Persistent storage required |\n\n**Lease Reaper Process:**\n\nThe lease reaper operates as a continuous background process that identifies expired leases and initiates their revocation. Think of the lease reaper like a security guard who regularly patrols the building to check for expired access badges and deactivate them to prevent unauthorized access.\n\n1. **Expiration Scanning**: Every 30 seconds, the reaper queries the lease index for leases that have expired within the last scan interval. The query includes a small buffer (5 seconds) to account for clock skew and processing delays.\n\n2. **Batch Processing**: Expired leases are processed in batches to optimize backend operations and reduce system load. Batch size is configurable but defaults to 100 leases to balance throughput and memory usage.\n\n3. **Revocation Queuing**: Each expired lease is queued for revocation with appropriate priority based on the credential type and security sensitivity. High-priority credentials (root database users, admin cloud roles) are processed immediately.\n\n4. **Progress Tracking**: The reaper maintains state about its last successful scan to ensure no leases are missed during system restarts or failures. This state is persisted to storage and recovered on startup.\n\n5. **Error Handling**: Failed revocation attempts are logged and retried according to exponential backoff policies. Persistent failures are escalated to dead letter queues for manual investigation.\n\n**Revocation Worker Process:**\n\nMultiple revocation workers operate concurrently to process the revocation queue and perform actual credential cleanup in target systems. The number of workers is configurable based on expected load and backend capacity.\n\n1. **Queue Processing**: Workers continuously poll the revocation queue for pending items, using priority ordering to ensure high-priority revocations are processed first. Queue polling includes exponential backoff to reduce system load during idle periods.\n\n2. **Backend Invocation**: For each revocation item, the appropriate secret backend is invoked with the stored revocation data. Backends implement credential-specific cleanup logic such as database user deletion or cloud IAM role revocation.\n\n3. **Retry Logic with Circuit Breaker**: Failed revocation attempts are retried according to configurable policies with exponential backoff. Circuit breaker patterns prevent cascade failures when backends are experiencing issues.\n\n4. **Success Confirmation**: Successfully revoked credentials are removed from all tracking indexes and their lease records are marked as revoked for audit purposes. Success confirmation may include verification queries to ensure cleanup completion.\n\n5. **Failure Escalation**: Revocation attempts that exceed maximum retry counts are moved to dead letter queues with detailed error information for operator investigation. These failures generate alert notifications for immediate attention.\n\n**Revocation Retry Configuration:**\n\n| Attempt | Delay | Total Time | Action |\n|---------|-------|------------|--------|\n| 1 | Immediate | 0s | Direct revocation attempt |\n| 2 | 30 seconds | 30s | First retry with backend health check |\n| 3 | 2 minutes | 2m 30s | Second retry with extended timeout |\n| 4 | 8 minutes | 10m 30s | Third retry with debug logging |\n| 5 | 32 minutes | 42m 30s | Final retry with operator notification |\n| Failed | Dead letter | N/A | Manual intervention required |\n\n> **Decision: Separate Lease Reaper and Revocation Workers**\n> - **Context**: Need to balance timely credential revocation with system stability under varying load conditions\n> - **Options Considered**:\n>   - Single-threaded process handling both detection and revocation\n>   - Multi-threaded process with shared queue\n>   - Separate processes with persistent queue\n> - **Decision**: Separate processes communicating through persistent queue\n> - **Rationale**: Enables independent scaling, fault isolation, and priority handling while maintaining processing guarantees\n> - **Consequences**: Requires additional coordination and queue management but provides superior reliability and performance characteristics\n\n#### Token Maintenance and Cleanup\n\nThe token maintenance system handles token lifecycle management including expiration, usage limit enforcement, and orphaned token cleanup. This system prevents token accumulation and enforces security policies related to token usage patterns.\n\n**Token Expiration Processing:**\n\n1. **Expiration Detection**: A background process scans the token store every minute to identify tokens that have exceeded their TTL. The scan uses indexed queries to minimize performance impact on active token operations.\n\n2. **Grace Period Handling**: Expired tokens enter a short grace period (30 seconds) during which they are marked as expired but not immediately deleted. This prevents race conditions where in-flight requests fail due to token expiration timing.\n\n3. **Revocation Cascade**: When parent tokens are revoked, all child tokens are automatically revoked in a cascading pattern. The revocation process maintains referential integrity and prevents orphaned authentication state.\n\n4. **Audit Event Generation**: Token revocation events are logged with comprehensive context including revocation reason, token metadata, and any associated leases that require cleanup.\n\n**Token Usage Limit Enforcement:**\n\n1. **Usage Tracking**: Every token authentication increments the token's usage counter in a thread-safe manner. Usage tracking includes protection against race conditions that could allow usage limit bypasses.\n\n2. **Limit Validation**: Before authentication succeeds, the token's usage count is compared against its maximum usage limit. Tokens that would exceed their limit are immediately revoked and the authentication fails.\n\n3. **Usage Pattern Analysis**: Token usage patterns are analyzed to detect anomalous behavior such as rapid usage spikes that might indicate credential compromise or client implementation errors.\n\n**Orphaned Token Cleanup:**\n\n1. **Parent Relationship Validation**: Tokens with parent relationships are validated to ensure their parent tokens still exist and are valid. Orphaned tokens from deleted parents are queued for cleanup.\n\n2. **Policy Reference Validation**: Tokens referencing policies that no longer exist are identified and either updated with replacement policies or revoked if no suitable replacement exists.\n\n3. **Identity Reference Validation**: Tokens associated with deleted or disabled identities are automatically revoked to prevent access after identity removal.\n\n#### Encryption Key Rotation and Migration\n\nThe encryption key management system handles periodic rotation of data encryption keys and migration of secrets to new key versions. This process maintains security by limiting the exposure time of any single encryption key while ensuring seamless access to historical secret versions.\n\n**Automatic Key Rotation Process:**\n\n1. **Rotation Schedule Evaluation**: The key rotation scheduler evaluates configured rotation policies including maximum key age, maximum usage count, and external rotation triggers. Rotation policies can be configured per mount point or globally.\n\n2. **New Key Generation**: When rotation is triggered, a new data encryption key is generated using cryptographically secure random number generation. The new key is encrypted with the current master key and stored in the key store.\n\n3. **Key Version Management**: The new key is assigned the next sequential version number and marked as the active key for new encryptions. Previous key versions remain available for decryption but are no longer used for new operations.\n\n4. **Migration Planning**: The rotation process identifies existing secrets encrypted with old key versions and creates a migration plan. Migration is prioritized based on secret access frequency and age of the encryption key.\n\n**Background Secret Re-encryption:**\n\n1. **Migration Queue Processing**: A background process continuously works through the migration queue, re-encrypting secrets with the current data encryption key version. Processing rate is throttled to avoid impacting operational performance.\n\n2. **Version Preservation**: During re-encryption, all secret versions are preserved with their original metadata. Only the encryption key version and encrypted data are updated while maintaining version history.\n\n3. **Atomic Updates**: Secret re-encryption is performed atomically to prevent data corruption. The original secret version is preserved until the new version is successfully written and verified.\n\n4. **Progress Tracking**: Migration progress is tracked per mount point and globally to provide operational visibility into key rotation status. Progress information is exposed through monitoring APIs.\n\n5. **Verification and Rollback**: Re-encrypted secrets undergo verification by attempting decryption with the new key version. Failed verifications trigger automatic rollback to the previous version and error reporting.\n\n**Key Retirement and Cleanup:**\n\n1. **Usage Monitoring**: Old key versions are monitored for usage patterns. Keys that are no longer actively used for decryption operations become candidates for retirement.\n\n2. **Retirement Timeline**: Keys follow a configured retirement timeline where they progress from active to deprecated to retired status. Each status change has configurable time delays to ensure operational safety.\n\n3. **Final Cleanup**: Retired keys that are no longer referenced by any secrets are securely deleted from the key store. Key deletion includes secure memory wiping and audit event generation.\n\n> **Security Principle**: Key rotation operates on the principle of \"blast radius containment\" - limiting the amount of data encrypted with any single key version reduces the impact of potential key compromise while maintaining backward compatibility for legitimate access.\n\n#### Health Monitoring and Alerting\n\nThe health monitoring system continuously evaluates system components and operational metrics to detect degraded performance, security issues, or impending failures. This system provides early warning of problems and enables proactive operational response.\n\n**Component Health Checks:**\n\n| Component | Health Metrics | Check Frequency | Alert Thresholds |\n|-----------|---------------|----------------|------------------|\n| Storage Backend | Response time, error rate, connection count | 30 seconds | >500ms response, >5% errors |\n| Encryption Engine | Key availability, encryption/decryption performance | 60 seconds | Key lookup failures, >100ms operations |\n| Authentication Engine | Token validation performance, policy evaluation time | 30 seconds | >50ms validation, >10% failures |\n| Dynamic Secret Backends | Credential generation success rate, cleanup success | 2 minutes | >10% generation failures, >5% cleanup failures |\n| Lease Management | Revocation queue depth, processing rate | 60 seconds | >1000 queued items, <90% success rate |\n\n**Operational Metrics Collection:**\n\n1. **Request Processing Metrics**: Comprehensive timing and success rate metrics for all API endpoints, categorized by operation type, authentication method, and client identity. Metrics include percentile distributions for performance analysis.\n\n2. **Security Event Metrics**: Aggregated counts of authentication failures, authorization denials, and other security-relevant events. These metrics enable detection of potential attacks or misconfigurations.\n\n3. **Resource Usage Metrics**: Memory usage, storage consumption, network utilization, and other resource metrics that indicate system capacity and potential scaling needs.\n\n4. **Background Process Metrics**: Performance and health metrics for all background processes including lease reapers, token cleanup, and key rotation processes.\n\n**Alert Generation and Escalation:**\n\n1. **Threshold-Based Alerts**: Automated alerts are generated when metrics exceed configured thresholds. Alert severity is determined by the magnitude of threshold exceedance and the criticality of the affected component.\n\n2. **Trend-Based Alerts**: Statistical analysis of metric trends identifies gradual degradation that might not trigger threshold alerts but indicates developing issues requiring attention.\n\n3. **Correlation Analysis**: Multiple related metrics are analyzed together to distinguish between transient issues and systematic problems. Correlation reduces alert noise while improving detection accuracy.\n\n4. **Escalation Policies**: Alerts follow configured escalation policies with increasing severity and notification scope based on alert duration and system impact.\n\n### Implementation Guidance\n\nThe interactions and data flow components require careful attention to HTTP server implementation, middleware processing, and background task management. The following guidance provides a foundation for building these interaction patterns with appropriate error handling and performance characteristics.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|--------------|-----------------|\n| HTTP Server | Go net/http with gorilla/mux | Go with gin-gonic or fiber frameworks |\n| JSON Processing | Go encoding/json | Go with easyjson for performance |\n| Background Jobs | Go goroutines with sync primitives | Go with machinery or asynq job queues |\n| Metrics Collection | Go expvar with custom collectors | Prometheus client library |\n| Request Logging | Go log/slog with structured output | Structured logging with logrus or zap |\n| HTTP Middleware | Custom middleware functions | Go middleware libraries (negroni, alice) |\n\n#### File Structure Organization\n\n```\ninternal/server/\n  server.go                 ← HTTP server setup and configuration\n  middleware.go             ← Authentication, authorization, logging middleware\n  handlers.go               ← HTTP request handlers for each endpoint\n  response.go               ← Standard response formatting utilities\n  validation.go             ← Request validation helpers\n\ninternal/api/\n  auth.go                   ← Authentication endpoint handlers\n  secrets.go                ← Secret operation endpoint handlers  \n  dynamic.go                ← Dynamic secret endpoint handlers\n  system.go                 ← System administration endpoint handlers\n\ninternal/background/\n  lease_reaper.go           ← Lease expiration detection and cleanup\n  token_cleaner.go          ← Token lifecycle maintenance\n  key_rotator.go            ← Encryption key rotation management\n  health_monitor.go         ← System health checking and alerting\n\ninternal/pipeline/\n  request.go                ← Request processing pipeline stages\n  context.go                ← Request context and metadata handling\n  audit.go                  ← Audit event generation and logging\n```\n\n#### Core HTTP Server Infrastructure\n\nThis complete HTTP server foundation handles basic server setup, graceful shutdown, and middleware composition. Use this as your starting point and add endpoint-specific handlers.\n\n```go\npackage server\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"log/slog\"\n    \"net/http\"\n    \"time\"\n    \n    \"github.com/gorilla/mux\"\n)\n\n// Complete HTTP server with middleware pipeline and graceful shutdown\ntype SecretServer struct {\n    config     ServerConfig\n    httpServer *http.Server\n    storage    Backend\n    encryption *Engine  \n    auth       *Engine\n    dynamic    *Engine\n    unseal     *UnsealManager\n    isSealed   bool\n    sealMutex  sync.RWMutex\n    logger     *slog.Logger\n}\n\n// NewSecretServer creates a fully configured HTTP server with all middleware\nfunc NewSecretServer(cfg ServerConfig) (*SecretServer, error) {\n    server := &SecretServer{\n        config: cfg,\n        logger: slog.New(slog.NewJSONHandler(os.Stdout, nil)),\n    }\n    \n    // Initialize all engines based on configuration\n    if err := server.initializeEngines(); err != nil {\n        return nil, fmt.Errorf(\"failed to initialize engines: %w\", err)\n    }\n    \n    // Setup HTTP router with all endpoints and middleware\n    router := server.setupRouter()\n    \n    server.httpServer = &http.Server{\n        Addr:         fmt.Sprintf(\":%d\", cfg.Server.Port),\n        Handler:      router,\n        ReadTimeout:  cfg.Server.ReadTimeout,\n        WriteTimeout: cfg.Server.WriteTimeout,\n        TLSConfig:    server.buildTLSConfig(),\n    }\n    \n    return server, nil\n}\n\n// Start begins HTTP server operation with TLS\nfunc (s *SecretServer) Start() error {\n    s.logger.Info(\"Starting secret management server\", \n        \"port\", s.config.Server.Port,\n        \"tls\", s.config.Server.TLSCertPath != \"\")\n    \n    // Start background processes\n    go s.startBackgroundProcesses()\n    \n    // Start HTTP server with TLS\n    if s.config.Server.TLSCertPath != \"\" {\n        return s.httpServer.ListenAndServeTLS(\n            s.config.Server.TLSCertPath,\n            s.config.Server.TLSKeyPath,\n        )\n    }\n    return s.httpServer.ListenAndServe()\n}\n\n// Shutdown gracefully stops the server and background processes\nfunc (s *SecretServer) Shutdown(ctx context.Context) error {\n    s.logger.Info(\"Shutting down secret management server\")\n    \n    // Stop background processes first\n    s.stopBackgroundProcesses()\n    \n    // Gracefully shutdown HTTP server\n    return s.httpServer.Shutdown(ctx)\n}\n\n// setupRouter configures all HTTP routes and middleware pipeline\nfunc (s *SecretServer) setupRouter() http.Handler {\n    router := mux.NewRouter()\n    \n    // Apply middleware in correct order (outermost first)\n    router.Use(s.loggingMiddleware)\n    router.Use(s.corsMiddleware) \n    router.Use(s.sealCheckMiddleware)\n    \n    // API v1 routes\n    v1 := router.PathPrefix(\"/v1\").Subrouter()\n    \n    // Public endpoints (no authentication)\n    v1.HandleFunc(\"/sys/health\", s.handleHealth).Methods(\"GET\")\n    v1.HandleFunc(\"/sys/seal-status\", s.handleSealStatus).Methods(\"GET\")\n    \n    // Authentication endpoints (partial auth required)\n    auth := v1.PathPrefix(\"/auth\").Subrouter()\n    auth.HandleFunc(\"/token/create\", s.handleCreateToken).Methods(\"POST\")\n    auth.HandleFunc(\"/token/lookup-self\", s.handleTokenLookup).Methods(\"GET\")\n    \n    // Protected endpoints (full authentication required)\n    protected := v1.NewRoute().Subrouter()\n    protected.Use(s.authenticationMiddleware)\n    protected.Use(s.authorizationMiddleware)\n    \n    // Secret operations\n    protected.HandleFunc(\"/secret/{path:.*}\", s.handleSecretGet).Methods(\"GET\")\n    protected.HandleFunc(\"/secret/{path:.*}\", s.handleSecretPut).Methods(\"POST\", \"PUT\")\n    protected.HandleFunc(\"/secret/{path:.*}\", s.handleSecretDelete).Methods(\"DELETE\")\n    \n    // Dynamic secret operations  \n    protected.HandleFunc(\"/database/creds/{role}\", s.handleDynamicSecret).Methods(\"GET\")\n    protected.HandleFunc(\"/aws/creds/{role}\", s.handleDynamicSecret).Methods(\"GET\")\n    \n    // System administration\n    protected.HandleFunc(\"/sys/policy/{name}\", s.handlePolicyOperations).Methods(\"GET\", \"POST\", \"DELETE\")\n    \n    return router\n}\n```\n\n#### Request Processing Pipeline Implementation\n\nThe request processing pipeline handles the multi-stage validation, authentication, and authorization flow. Each stage can terminate the request early or enrich the request context for subsequent stages.\n\n```go\npackage pipeline\n\n// RequestContext carries all information through the processing pipeline\ntype RequestContext struct {\n    RequestID    string\n    StartTime    time.Time\n    Identity     *Identity\n    Token        *Token\n    Operation    string\n    Path         string\n    Parameters   map[string][]string\n    ClientIP     string\n    UserAgent    string\n    Authorized   bool\n    AuditEvents  []AuditEvent\n}\n\n// ProcessingStage represents a single stage in the request pipeline\ntype ProcessingStage func(ctx context.Context, reqCtx *RequestContext, r *http.Request) error\n\n// RequestProcessor coordinates the multi-stage request processing pipeline\ntype RequestProcessor struct {\n    stages []ProcessingStage\n    audit  *AuditLogger\n    logger *slog.Logger\n}\n\n// NewRequestProcessor creates a processor with all standard stages configured\nfunc NewRequestProcessor(audit *AuditLogger) *RequestProcessor {\n    processor := &RequestProcessor{\n        audit:  audit,\n        logger: slog.New(slog.NewJSONHandler(os.Stdout, nil)),\n    }\n    \n    // Configure standard processing stages in order\n    processor.stages = []ProcessingStage{\n        processor.parseAndValidateStage,\n        processor.authenticateStage, \n        processor.authorizeStage,\n        processor.auditStage,\n    }\n    \n    return processor\n}\n\n// ProcessRequest executes all pipeline stages and returns processing result\nfunc (p *RequestProcessor) ProcessRequest(ctx context.Context, r *http.Request) (*RequestContext, error) {\n    reqCtx := &RequestContext{\n        RequestID: generateRequestID(),\n        StartTime: time.Now(),\n        ClientIP:  extractClientIP(r),\n        UserAgent: r.UserAgent(),\n    }\n    \n    // Execute each processing stage in sequence\n    for i, stage := range p.stages {\n        if err := stage(ctx, reqCtx, r); err != nil {\n            // Log pipeline failure with stage information\n            p.logger.Error(\"Request processing failed\",\n                \"request_id\", reqCtx.RequestID,\n                \"stage\", i,\n                \"error\", err,\n                \"duration\", time.Since(reqCtx.StartTime))\n            \n            // Generate failure audit event\n            p.auditFailure(reqCtx, err)\n            return reqCtx, err\n        }\n    }\n    \n    return reqCtx, nil\n}\n\n// parseAndValidateStage handles HTTP parsing and basic request validation\nfunc (p *RequestProcessor) parseAndValidateStage(ctx context.Context, reqCtx *RequestContext, r *http.Request) error {\n    // TODO 1: Extract HTTP method and validate against allowed methods for endpoint\n    // TODO 2: Parse URL path and extract path parameters using mux.Vars(r)\n    // TODO 3: Validate Content-Type header for requests with body (POST/PUT)\n    // TODO 4: Parse and validate JSON request body with size limits\n    // TODO 5: Extract query parameters and validate types/ranges\n    // TODO 6: Store parsed operation and path in RequestContext\n    // Hint: Use r.Body with io.LimitReader to prevent memory exhaustion\n    return nil\n}\n\n// authenticateStage verifies client identity and resolves authentication\nfunc (p *RequestProcessor) authenticateStage(ctx context.Context, reqCtx *RequestContext, r *http.Request) error {\n    // TODO 1: Extract X-Vault-Token header from request\n    // TODO 2: Validate token format and handle missing tokens for public endpoints  \n    // TODO 3: Look up token in token store using constant-time comparison\n    // TODO 4: Validate token expiration and usage limits\n    // TODO 5: Load token metadata including policies and identity information\n    // TODO 6: Construct Identity object with resolved policies and groups\n    // TODO 7: Update token usage count and last used timestamp\n    // Hint: Use ValidateTokenConstantTime to prevent timing attacks\n    return nil\n}\n\n// authorizeStage evaluates policies and determines access permissions\nfunc (p *RequestProcessor) authorizeStage(ctx context.Context, reqCtx *RequestContext, r *http.Request) error {\n    // TODO 1: Skip authorization for public endpoints (health, seal-status)\n    // TODO 2: Collect all policies associated with authenticated identity\n    // TODO 3: Evaluate each policy rule against normalized request path\n    // TODO 4: Check requested operation against capabilities in matching rules\n    // TODO 5: Validate request parameters against policy constraints\n    // TODO 6: Apply maximum TTL and other policy constraints to request\n    // TODO 7: Set Authorized flag in RequestContext based on evaluation result\n    // Hint: Use PathMatcher.Match for wildcard pattern evaluation\n    return nil\n}\n\n// auditStage generates audit events for all request processing\nfunc (p *RequestProcessor) auditStage(ctx context.Context, reqCtx *RequestContext, r *http.Request) error {\n    // TODO 1: Create AuditEvent with comprehensive request information\n    // TODO 2: Include authentication and authorization results\n    // TODO 3: Add timing information and request metadata\n    // TODO 4: Determine audit event type based on operation category\n    // TODO 5: Write audit event to configured audit log\n    // Hint: Generate audit events even for failed requests for security monitoring\n    return nil\n}\n```\n\n#### Background Process Infrastructure\n\nBackground processes require careful lifecycle management, error handling, and coordination. This infrastructure provides the foundation for lease management, token cleanup, and health monitoring.\n\n```go\npackage background\n\n// BackgroundManager coordinates all background processes with lifecycle management\ntype BackgroundManager struct {\n    processes []BackgroundProcess\n    stopChan  chan struct{}\n    wg        sync.WaitGroup\n    logger    *slog.Logger\n}\n\n// BackgroundProcess defines the interface for all background processes\ntype BackgroundProcess interface {\n    Name() string\n    Start(stopChan <-chan struct{}) error\n    HealthCheck() error\n}\n\n// LeaseReaper handles expired lease detection and revocation queuing\ntype LeaseReaper struct {\n    engine     *Engine\n    storage    Backend\n    interval   time.Duration\n    batchSize  int\n    lastScan   time.Time\n    logger     *slog.Logger\n}\n\n// NewLeaseReaper creates a lease reaper with configured scan interval\nfunc NewLeaseReaper(engine *Engine, storage Backend) *LeaseReaper {\n    return &LeaseReaper{\n        engine:    engine,\n        storage:   storage,\n        interval:  30 * time.Second,\n        batchSize: 100,\n        logger:    slog.New(slog.NewJSONHandler(os.Stdout, nil)),\n    }\n}\n\n// Start begins the lease reaper background process\nfunc (lr *LeaseReaper) Start(stopChan <-chan struct{}) error {\n    ticker := time.NewTicker(lr.interval)\n    defer ticker.Stop()\n    \n    lr.logger.Info(\"Starting lease reaper\", \"interval\", lr.interval)\n    \n    for {\n        select {\n        case <-stopChan:\n            lr.logger.Info(\"Stopping lease reaper\")\n            return nil\n            \n        case <-ticker.C:\n            if err := lr.processExpiredLeases(); err != nil {\n                lr.logger.Error(\"Lease reaper processing failed\", \"error\", err)\n                // Continue processing - don't stop on errors\n            }\n        }\n    }\n}\n\n// processExpiredLeases finds and queues expired leases for revocation\nfunc (lr *LeaseReaper) processExpiredLeases() error {\n    // TODO 1: Query storage for leases expired since last scan time\n    // TODO 2: Process expired leases in batches to manage memory usage\n    // TODO 3: For each expired lease, create revocation queue entry\n    // TODO 4: Queue revocation requests with appropriate priority\n    // TODO 5: Update last scan time to current time\n    // TODO 6: Log processing statistics (leases found, queued, errors)\n    // Hint: Include small buffer time to account for clock skew\n    return nil\n}\n\n// RevocationWorker processes the revocation queue and performs credential cleanup\ntype RevocationWorker struct {\n    workerID     int\n    engine       *Engine\n    retryConfig  RetryConfig\n    queue        chan *RevocationQueue\n    stopChan     chan struct{}\n    logger       *slog.Logger\n}\n\n// NewRevocationWorker creates a worker that processes revocation requests\nfunc NewRevocationWorker(workerID int, engine *Engine, queue chan *RevocationQueue) *RevocationWorker {\n    return &RevocationWorker{\n        workerID: workerID,\n        engine:   engine,\n        retryConfig: RetryConfig{\n            InitialDelay: 30 * time.Second,\n            MaxDelay:     30 * time.Minute,\n            Multiplier:   2.0,\n            MaxAttempts:  5,\n        },\n        queue:  queue,\n        logger: slog.New(slog.NewJSONHandler(os.Stdout, nil)),\n    }\n}\n\n// Start begins processing revocation requests from the queue\nfunc (rw *RevocationWorker) Start(stopChan <-chan struct{}) error {\n    rw.stopChan = stopChan\n    rw.logger.Info(\"Starting revocation worker\", \"worker_id\", rw.workerID)\n    \n    for {\n        select {\n        case <-stopChan:\n            rw.logger.Info(\"Stopping revocation worker\", \"worker_id\", rw.workerID)\n            return nil\n            \n        case revReq := <-rw.queue:\n            if err := rw.processRevocation(revReq); err != nil {\n                rw.logger.Error(\"Revocation processing failed\",\n                    \"worker_id\", rw.workerID,\n                    \"lease_id\", revReq.LeaseID,\n                    \"error\", err)\n            }\n        }\n    }\n}\n\n// processRevocation handles a single revocation request with retry logic\nfunc (rw *RevocationWorker) processRevocation(revReq *RevocationQueue) error {\n    // TODO 1: Look up secret backend for the lease being revoked\n    // TODO 2: Attempt credential revocation using backend-specific logic\n    // TODO 3: Handle revocation success by removing lease from indexes\n    // TODO 4: Handle revocation failure with exponential backoff retry\n    // TODO 5: Move persistently failing revocations to dead letter queue\n    // TODO 6: Update revocation statistics and monitoring metrics\n    // Hint: Use circuit breaker pattern to prevent cascade failures\n    return nil\n}\n```\n\n#### Milestone Checkpoints\n\nAfter implementing the interactions and data flow components, verify the system behavior with these checkpoints:\n\n**Authentication Pipeline Verification:**\n```bash\n# Test valid token authentication\ncurl -H \"X-Vault-Token: valid-token-here\" https://localhost:8443/v1/secret/test\n\n# Expected: HTTP 200 with secret data or HTTP 404 if secret doesn't exist\n# Signs of problems: HTTP 401 (auth failure), HTTP 500 (server error)\n\n# Test invalid token handling  \ncurl -H \"X-Vault-Token: invalid-token\" https://localhost:8443/v1/secret/test\n\n# Expected: HTTP 403 Forbidden with error message\n# Signs of problems: HTTP 500 (auth system failure), HTTP 200 (security bypass)\n```\n\n**Authorization Policy Verification:**\n```bash\n# Test path-based policy enforcement\ncurl -H \"X-Vault-Token: limited-token\" https://localhost:8443/v1/secret/forbidden/path\n\n# Expected: HTTP 403 Forbidden with policy denial message\n# Signs of problems: HTTP 200 (policy bypass), HTTP 500 (policy evaluation failure)\n\n# Verify policy wildcard matching\ncurl -H \"X-Vault-Token: wildcard-token\" https://localhost:8443/v1/secret/allowed/subpath\n\n# Expected: HTTP 200 or 404 based on secret existence\n# Signs of problems: HTTP 403 (wildcard not working), HTTP 500 (pattern matching failure)\n```\n\n**Background Process Verification:**\n```bash\n# Check background process health\ncurl https://localhost:8443/v1/sys/health\n\n# Expected: JSON with background process status information\n# Look for: lease_reaper_status: \"healthy\", revocation_workers: \"active\"\n# Signs of problems: process_status: \"failed\", high error counts\n\n# Monitor lease cleanup\n# Create dynamic secret, wait for expiration, verify cleanup\n# Check logs for: \"lease expired and queued for revocation\"\n# Check target system for: credential actually removed\n```\n\n**Common Implementation Issues:**\n\n⚠️ **Pitfall: Missing Request Context Propagation**\nForgetting to pass the request context through all pipeline stages causes loss of audit information and makes debugging impossible. Each stage must receive and can modify the RequestContext object, and all audit events must reference the same request ID for correlation.\n\n⚠️ **Pitfall: Blocking Background Processes**\nBackground processes that don't properly handle the stop channel can prevent graceful shutdown and cause resource leaks. Always use select statements with the stop channel and ensure goroutines terminate cleanly when requested.\n\n⚠️ **Pitfall: Inconsistent Error Response Format**\nHTTP endpoints that return different error formats make client implementation difficult and break compatibility with Vault clients. Use a consistent error response structure across all endpoints with appropriate HTTP status codes.\n\n⚠️ **Pitfall: Missing Constant-Time Token Comparison**\nUsing standard string comparison for token validation enables timing attacks where attackers can determine valid token prefixes by measuring response times. Always use constant-time comparison functions for any security-sensitive string comparisons.\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** This section applies to all four milestones, with particular emphasis on Milestone 4 (High Availability) for cluster-related failures. Error handling strategies are built progressively through each milestone.\n\nA robust secret management system must operate reliably even when components fail, networks partition, or external systems become unavailable. Think of this as designing a bank vault system that continues to protect assets and serve authorized customers even during earthquakes, power outages, or attempted break-ins. The system must gracefully degrade functionality while maintaining its core security guarantees, never compromising secrets even in catastrophic failure scenarios.\n\nThis section examines the primary failure modes that can affect a secret management system, the detection and recovery strategies for each failure type, and how the system maintains partial functionality when full operation is impossible. The key insight is that security requirements never relax during failures - if anything, the system must become more conservative and protective when operating in degraded states.\n\n### System Failure Modes\n\nUnderstanding potential failure modes is critical for building resilient secret management systems. Each failure mode requires specific detection mechanisms, recovery procedures, and fallback strategies. The system must be designed with the principle of \"assume breach\" - any component can fail at any time, and the system must continue to protect secrets.\n\n#### Network Partitions and Communication Failures\n\nNetwork partitions represent one of the most challenging failure modes for distributed secret management systems. Unlike simple network outages where nodes are clearly unavailable, partitions create split-brain scenarios where subsets of nodes can communicate internally but cannot reach other subsets. This is analogous to a bank having multiple branches that can operate independently but cannot communicate with headquarters - each branch must decide whether to continue serving customers or temporarily halt operations.\n\n| Failure Scenario | Symptoms | Detection Method | Immediate Response |\n|------------------|----------|------------------|-------------------|\n| Network partition between cluster nodes | Raft consensus timeouts, leader election failures | Heartbeat monitoring, consensus operation failures | Transition non-leader nodes to read-only mode |\n| Client-to-server network issues | HTTP request timeouts, connection refused errors | Client-side timeout detection, load balancer health checks | Client retry with exponential backoff, circuit breaker activation |\n| Storage backend network failures | Database connection timeouts, cloud storage API errors | Backend health check failures, operation timeouts | Switch to cached data, enable read-only mode |\n| KMS provider network issues | Auto-unseal failures, key operation timeouts | KMS health check timeouts, encryption operation failures | Manual unseal fallback, defer key operations |\n\nThe system implements several strategies to handle network-related failures. For cluster communication, the Raft consensus protocol provides built-in partition tolerance by requiring a majority quorum for write operations. When a partition occurs, only the subset containing a majority of nodes can continue accepting write requests, while minority partitions automatically transition to read-only mode. This prevents the dangerous split-brain scenario where multiple subsets accept conflicting writes.\n\n> **Design Insight: Conservative Degradation**\n> \n> When facing ambiguous failure conditions, the system always chooses the more restrictive option. A node that cannot confirm it's part of the majority partition will refuse write operations rather than risk creating inconsistency. This \"fail-safe\" approach prioritizes data integrity over availability.\n\nClient-facing network failures require careful retry logic to avoid overwhelming a recovering system. The system implements exponential backoff with jitter to spread retry attempts over time. Circuit breaker patterns prevent cascading failures by temporarily halting requests to unresponsive backends, allowing them time to recover.\n\n**Decision: Network Partition Handling Strategy**\n- **Context**: Network partitions can create split-brain scenarios where multiple nodes accept conflicting writes, leading to data inconsistency\n- **Options Considered**: \n  - Allow all nodes to continue operations independently\n  - Require strict majority quorum for any operations\n  - Implement Byzantine fault tolerance with complex consensus\n- **Decision**: Raft consensus with majority quorum requirement and read-only degradation for minority partitions\n- **Rationale**: Raft provides proven partition tolerance with simpler implementation than Byzantine consensus, while majority quorum prevents split-brain scenarios without complex coordination\n- **Consequences**: Enables consistent behavior during partitions but requires majority of nodes for write availability, increasing minimum cluster size requirements\n\n#### Storage System Failures\n\nStorage failures can range from temporary connectivity issues to permanent data corruption. The secret management system must handle these failures without exposing unencrypted secrets or losing critical metadata. Think of this as a library system where individual books might become damaged, entire shelves might become inaccessible, or the card catalog might become corrupted - the library must continue operating while protecting its collection.\n\n| Storage Failure Type | Detection Signals | Data at Risk | Recovery Strategy |\n|---------------------|-------------------|---------------|-------------------|\n| Disk corruption | Checksum validation failures, read errors | Individual secret versions | Restore from backup, mark corrupted versions as unavailable |\n| Database connection loss | Connection timeouts, SQL errors | All persisted data temporarily inaccessible | Retry with exponential backoff, switch to cached data |\n| Storage backend crash | Health check failures, persistent connection errors | All stored secrets and metadata | Failover to backup storage, restore from replicated data |\n| Encryption key corruption | Decryption failures, key validation errors | Secrets encrypted with corrupted key | Key recovery from shares, re-encryption with new key |\n| Transaction log corruption | WAL read errors, sequence validation failures | Recent writes may be lost | Replay from last good checkpoint, rebuild from snapshots |\n\nThe system implements multiple layers of protection against storage failures. At the data level, all secrets include cryptographic checksums to detect corruption. The envelope encryption design isolates failures - if a data encryption key becomes corrupted, only secrets encrypted with that specific key are affected, while other secrets remain accessible.\n\nFor database connectivity issues, the system maintains read-through caches for frequently accessed secrets and policies. This allows continued read operations during temporary storage outages. Write operations are queued with persistent storage to ensure no requests are lost during brief connectivity issues.\n\nThe most critical storage failure involves corruption of the master key or key shares. The system addresses this through redundant storage of encrypted key shares across multiple locations and automated integrity checking. If key corruption is detected, the system can reconstruct the master key from remaining shares and re-encrypt affected data.\n\n> **Critical Security Principle: Fail Closed**\n> \n> When storage integrity cannot be verified, the system denies access rather than potentially serving corrupted or malicious data. A corrupted secret is treated the same as a missing secret - the request fails rather than returning potentially compromised data.\n\n#### Encryption Key Corruption and Loss\n\nKey management failures represent catastrophic scenarios for a secret management system. Unlike other data that can be restored from backups, encryption keys are unique - losing the master key means permanently losing access to all encrypted secrets. This is analogous to losing the combination to a bank vault - even if the vault and its contents are physically intact, they become inaccessible.\n\n| Key Failure Scenario | Probability | Impact Severity | Detection Method | Recovery Options |\n|---------------------|-------------|-----------------|------------------|------------------|\n| Master key corruption in memory | Low | High | Decryption operation failures | Reconstruct from Shamir shares |\n| Single key share corruption | Medium | Low | Share validation during reconstruction | Use remaining shares, regenerate corrupted share |\n| Multiple key share corruption | Low | Critical | Insufficient shares for reconstruction | Restore shares from secure backup, emergency key escrow |\n| KMS provider key deletion | Low | Critical | Auto-unseal failures, KMS API errors | Manual unseal with backup shares, key recovery procedures |\n| Data encryption key corruption | Medium | Medium | Secret decryption failures for specific key version | Re-encrypt affected secrets with new DEK |\n\nThe Shamir's secret sharing implementation provides redundancy for master key protection. The system can tolerate corruption of up to `threshold - 1` shares while maintaining full functionality. When share corruption is detected, the system can regenerate new shares from the reconstructed master key and distribute them to replace corrupted copies.\n\nFor data encryption keys, the system maintains a key derivation tree that allows regeneration of corrupted DEKs from the master key and cryptographic parameters. This ensures that temporary DEK corruption doesn't result in permanent secret loss, though it may require re-encryption operations.\n\nThe most sophisticated protection involves integration with hardware security modules (HSMs) or cloud key management services for key escrow. These external systems provide independent key recovery mechanisms when all local shares become unavailable.\n\n**Decision: Key Recovery Strategy Design**\n- **Context**: Encryption key loss or corruption could result in permanent data loss, requiring robust recovery mechanisms\n- **Options Considered**:\n  - Rely solely on Shamir shares for all key recovery\n  - Implement key escrow with trusted third party\n  - Use deterministic key derivation from user passwords\n- **Decision**: Combination of Shamir shares for primary recovery with optional KMS escrow for disaster scenarios\n- **Rationale**: Shamir shares provide offline recovery without external dependencies, while KMS escrow offers additional protection for catastrophic local failures without introducing routine external dependencies\n- **Consequences**: Enables robust key recovery with multiple fallback options but increases operational complexity and introduces potential external dependencies for disaster recovery\n\n#### Service Dependencies and External Systems\n\nSecret management systems rely on numerous external services for full functionality. Database backends, cloud KMS providers, network time services, and certificate authorities can all experience outages or degraded performance. The system must continue protecting secrets and serving authorized requests even when these dependencies become unavailable.\n\n| Dependency Type | Failure Impact | Degraded Functionality | Fallback Strategy |\n|----------------|----------------|------------------------|-------------------|\n| Database backend | Cannot persist new secrets or leases | Read from cache, reject writes | Local storage, backup database |\n| Cloud KMS provider | Auto-unseal unavailable, cannot encrypt new DEKs | Manual unseal required, read-only mode | Cached DEKs, manual key management |\n| Time service (NTP) | Token expiration checks unreliable, lease management affected | Conservative expiration handling | Local clock with skew tolerance |\n| Certificate Authority | Cannot issue new client certificates, mTLS validation issues | Token authentication only, cached certificate validation | Cached CA certificates, extended validity periods |\n| Dynamic secret backends | Cannot generate new credentials, revocation may fail | Static secret access only | Cached credentials, manual cleanup |\n\nThe system implements graceful degradation for each dependency type. When the database backend becomes unavailable, the system continues serving read requests from in-memory caches while queuing write operations for later processing. This maintains availability for secret retrieval operations while ensuring write requests aren't lost.\n\nCloud KMS failures affect auto-unseal capabilities but don't prevent normal operations once the system is unsealed. The system falls back to manual unsealing procedures and can continue operating with locally managed encryption keys. New DEK generation may be deferred until KMS connectivity is restored.\n\nDynamic secret backend failures have the most complex implications, as they affect both credential generation and revocation. The system implements queue-based revocation with persistent retry logic to ensure credentials are eventually cleaned up even if backends are temporarily unavailable.\n\n### Recovery Strategies\n\nEffective recovery strategies ensure the secret management system can restore full functionality after failures while maintaining security guarantees throughout the recovery process. Recovery procedures must be thoroughly documented, regularly tested, and executable under stress conditions. Think of these as emergency procedures for a nuclear power plant - they must be simple enough to execute correctly during crisis situations while maintaining all safety protocols.\n\n#### Backup and Restore Procedures\n\nComprehensive backup strategies protect against both data loss and complete system failures. The secret management system requires specialized backup procedures due to the sensitive nature of the data and the complex relationships between encrypted secrets, encryption keys, and access control metadata.\n\n| Backup Component | Backup Frequency | Encryption Requirements | Restoration Priority |\n|------------------|------------------|-------------------------|---------------------|\n| Encrypted secret data | Hourly incremental, daily full | Separate encryption from operational keys | High - core system functionality |\n| Shamir key shares | Immediate after generation, stored offline | Hardware security modules or air-gapped systems | Critical - required for any secret access |\n| Access policies and tokens | Daily full, immediate for policy changes | Standard encryption, integrity protection | Medium - affects authorization |\n| Audit logs | Continuous streaming, hourly checkpoints | Write-once storage, tamper-evident sealing | Low - forensics and compliance |\n| System configuration | After each change, weekly full | Configuration-specific encryption | Medium - system restoration |\n\nThe backup strategy implements the principle of \"separation of concerns\" - secrets and keys are backed up using different procedures, storage locations, and encryption methods. This ensures that compromise of a backup system doesn't provide access to both encrypted data and the keys needed to decrypt it.\n\nSecret data backups include all encrypted content with full version history but exclude encryption keys. These backups can be stored in standard backup systems since the data remains encrypted. The backup process verifies data integrity through cryptographic checksums and maintains metadata about backup consistency points.\n\nKey share backups require the highest security measures. Shamir shares are distributed across multiple secure locations, with each location storing only a subset of shares insufficient for key reconstruction. Physical security measures include safe deposit boxes, HSMs, or geographically distributed key escrow services.\n\n> **Security Principle: Backup Separation**\n> \n> No single backup system or location contains both encrypted secrets and the keys needed to decrypt them. Even if an attacker compromises backup infrastructure, they cannot access secret content without also compromising separate key storage systems.\n\nRestoration procedures follow carefully orchestrated sequences to ensure security throughout the recovery process. The system must be unsealed before secret restoration can begin, requiring collection of sufficient key shares. Once unsealed, data restoration proceeds in dependency order: storage backend, encryption keys, secret data, access policies, and finally audit log replay.\n\n**Decision: Backup Strategy Architecture**\n- **Context**: Secret management systems require specialized backup procedures due to encryption key separation and security requirements\n- **Options Considered**:\n  - Traditional database backups with encrypted tablespace\n  - Application-level export with separate key and data streams\n  - Continuous replication with encrypted transport\n- **Decision**: Application-level export with cryptographically separated key and data backup streams\n- **Rationale**: Provides maximum control over encryption boundaries, enables independent key and data recovery procedures, and supports cross-platform restoration without database dependencies\n- **Consequences**: Enables flexible disaster recovery options with strong security isolation but requires custom backup tooling and more complex restoration procedures\n\n#### Disaster Recovery Procedures\n\nDisaster recovery goes beyond simple backup restoration to address scenarios where entire data centers, regions, or operational teams become unavailable. The procedures must be executable by skeleton staff with minimal specialized knowledge while maintaining all security protocols.\n\n| Disaster Scenario | Recovery Time Objective | Recovery Point Objective | Required Resources | Automation Level |\n|-------------------|-------------------------|--------------------------|-------------------|------------------|\n| Single server failure | 5 minutes | 0 data loss | Standby server, current backups | Fully automated |\n| Data center outage | 30 minutes | 1 hour data loss | Alternate data center, recent backups | Semi-automated |\n| Regional disaster | 4 hours | 4 hours data loss | Geographically distributed backups, emergency team | Manual with automation tools |\n| Complete system compromise | 24 hours | 24 hours data loss | Clean environment, offline backups, new hardware | Fully manual |\n| Key personnel unavailable | 8 hours | 1 hour data loss | Cross-trained staff, documented procedures | Manual with guidance |\n\nEach disaster scenario has specific recovery procedures optimized for the expected conditions. Single server failures leverage automated failover with standby systems that continuously replicate data. The standby promotion process includes unsealing procedures and health verification before accepting production traffic.\n\nData center outages require coordination between backup data centers and restoration of service at alternate locations. The procedures include network reconfiguration, DNS updates, and verification that all security boundaries remain intact during the transition.\n\nRegional disasters invoke the most comprehensive recovery procedures, potentially requiring reconstruction of the entire system infrastructure. These procedures emphasize security verification at each step, ensuring that restored systems haven't been compromised during the recovery process.\n\nThe most critical disaster scenario involves complete system compromise, where attackers may have accessed both operational systems and backup infrastructure. Recovery procedures assume that all online systems are potentially compromised and require building new infrastructure from verified offline backups.\n\n> **Operational Principle: Recovery Rehearsal**\n> \n> Disaster recovery procedures are practiced quarterly with rotating team members to ensure knowledge transfer and procedure validation. Each rehearsal identifies process improvements and updates documentation to reflect current system state.\n\nRecovery procedures include specific verification steps to confirm system integrity after restoration. These include cryptographic verification of restored data, access control validation, and security boundary testing. The system doesn't return to full operation until all verification procedures complete successfully.\n\n#### Data Consistency and Integrity Validation\n\nAfter any failure and recovery event, the system must verify that all data remains consistent and uncorrupted. This process goes beyond simple backup restoration to include cryptographic verification, cross-reference validation, and security boundary testing.\n\n| Validation Type | Verification Method | Expected Duration | Failure Response |\n|----------------|-------------------|------------------|------------------|\n| Cryptographic integrity | SHA-256 checksums for all secret versions | 10 minutes per 10k secrets | Mark corrupted secrets as unavailable, restore from backup |\n| Encryption key validation | Decrypt sample secrets with all key versions | 5 minutes per key version | Regenerate corrupted keys, re-encrypt affected secrets |\n| Access policy consistency | Policy rule parsing and conflict detection | 2 minutes per 100 policies | Restore policy from backup, audit recent changes |\n| Audit log continuity | Sequence number validation and timestamp verification | 1 minute per day of logs | Investigate gap causes, restore missing log segments |\n| Dynamic secret lease validity | Backend connectivity and credential verification | 30 seconds per active lease | Revoke unverifiable leases, regenerate credentials |\n\nThe validation process follows a systematic approach that verifies each system component independently before testing integrated functionality. Cryptographic verification confirms that all secrets can be successfully decrypted and that their content matches expected checksums. This catches both corruption and malicious tampering.\n\nEncryption key validation involves attempting to decrypt sample secrets using each available key version. Failed decryptions indicate key corruption and trigger key recovery procedures. The system maintains a small set of test secrets specifically for this validation process.\n\nAccess policy validation parses all policy definitions to ensure they contain valid syntax and don't create security vulnerabilities such as overly broad wildcard permissions. The system also checks for policy conflicts that might create ambiguous authorization decisions.\n\n**Decision: Post-Recovery Validation Strategy**\n- **Context**: After system recovery, comprehensive validation must confirm data integrity and security without disrupting restored service\n- **Options Considered**:\n  - Background validation with immediate service restoration\n  - Complete validation before service restoration\n  - Incremental validation with gradual service enablement\n- **Decision**: Incremental validation with gradual service enablement, starting with read-only access\n- **Rationale**: Balances service availability with security verification, allows early detection of validation failures without full service disruption, provides ability to halt service expansion if issues are discovered\n- **Consequences**: Enables faster partial service restoration with controlled risk exposure but requires more complex service state management during recovery periods\n\n### Graceful Degradation\n\nWhen the secret management system cannot operate at full capacity due to failures or resource constraints, it must gracefully reduce functionality while maintaining its core security guarantees. Think of this as a hospital operating on emergency power - certain services may be suspended, but life-critical functions continue with uncompromised safety standards.\n\n#### Read-Only Mode Operation\n\nRead-only mode represents the most common degraded operation state, typically triggered by storage backend failures, cluster partition scenarios, or planned maintenance. In this mode, the system continues serving existing secrets to authorized clients while refusing all operations that would modify system state.\n\n| Operation Type | Read-Only Behavior | Error Response | Client Impact |\n|----------------|-------------------|----------------|---------------|\n| Secret retrieval | Full functionality maintained | None - normal operation | No impact on existing secret access |\n| Secret creation/update | Rejected with explicit error | HTTP 503 Service Unavailable | Applications must retry or use cached values |\n| Dynamic secret generation | Rejected for new requests | HTTP 503 Service Unavailable | Applications must use existing credentials longer |\n| Policy changes | Rejected with explicit error | HTTP 503 Service Unavailable | Administrative operations deferred |\n| Token creation | Rejected for new requests | HTTP 503 Service Unavailable | Authentication uses existing tokens only |\n| Lease renewal | Allowed if cached locally | Partial functionality | Existing leases continue, new leases unavailable |\n\nThe transition to read-only mode is triggered automatically when the system detects conditions that make write operations unsafe or impossible. Common triggers include loss of majority quorum in a clustered deployment, storage backend connectivity issues, or explicit administrative commands during maintenance windows.\n\nDuring read-only mode, the system maintains full audit logging for all operations, including failed write attempts. This ensures complete visibility into system access patterns and helps identify when normal operations can safely resume. The audit system operates from local buffers and queues entries for later persistence when write access is restored.\n\nCritical to read-only mode operation is the handling of dynamic secrets and lease renewals. Existing leases can be renewed using cached policy information, preventing premature expiration of active credentials. However, new dynamic secret generation is suspended since it requires write access to create lease records and configure backend credentials.\n\n> **Operational Principle: Transparent Degradation**\n> \n> Clients experience read-only mode as increased latency for write operations rather than service unavailability. The system returns explicit error codes and retry guidance, allowing well-designed clients to implement appropriate fallback behavior.\n\nThe system provides detailed status information during read-only mode, including the specific failure conditions that triggered degradation and estimated time until full service restoration. This information helps operations teams prioritize recovery efforts and helps client applications make informed decisions about retry strategies.\n\n#### Reduced Functionality Scenarios\n\nBeyond simple read-only mode, the system may need to operate with various subsystems disabled or degraded. Each reduced functionality scenario maintains a specific subset of capabilities while clearly documenting what operations are unavailable and why.\n\n| Degraded Subsystem | Available Functionality | Unavailable Functionality | Typical Causes |\n|-------------------|------------------------|---------------------------|----------------|\n| Dynamic secret engine | Static secret access, policy evaluation | New credential generation, lease renewals | Backend connectivity issues, credential store failures |\n| Authentication engine | Token validation from cache | New token creation, policy updates | Auth database unavailable, policy store corruption |\n| Encryption engine | Decrypt cached DEKs | Key rotation, new DEK generation | KMS unavailable, master key access issues |\n| Audit logging | Operation execution continues | Compliance reporting, log analysis | Log storage full, audit database unavailable |\n| Cluster consensus | Local node operations | Multi-node coordination, leadership changes | Network partitions, node failures |\n\nDynamic secret engine degradation significantly impacts applications that rely on just-in-time credential generation. The system extends existing lease expiration times where possible and provides clear guidance about when normal credential generation will resume. Applications must implement fallback mechanisms for extended use of existing credentials.\n\nAuthentication engine degradation affects new user onboarding and policy changes but allows continued operation for existing authenticated clients. Token validation continues using cached policy information, though policy updates are deferred until full functionality is restored.\n\nEncryption engine degradation prevents key rotation activities and new secret encryption but allows continued access to existing secrets using cached decryption keys. This scenario often occurs during KMS provider outages and can be sustained for extended periods without impacting secret retrieval operations.\n\n**Decision: Degraded Mode Granularity**\n- **Context**: Different system components can fail independently, requiring fine-grained control over which functionality remains available during partial failures\n- **Options Considered**:\n  - Binary availability (full service or complete shutdown)\n  - Component-level degradation (individual subsystems can be disabled)\n  - Operation-level degradation (specific operations can be disabled independently)\n- **Decision**: Component-level degradation with clear capability boundaries between subsystems\n- **Rationale**: Provides meaningful partial functionality without excessive complexity, maps naturally to system architecture, allows operations teams to understand and manage degraded states effectively\n- **Consequences**: Enables continued service during partial failures with predictable behavior but requires careful dependency management and clear error reporting to clients\n\n#### Emergency Security Procedures\n\nWhen the system detects potential security breaches or operating conditions that might compromise secret safety, it implements emergency security procedures that prioritize data protection over service availability. These procedures represent the system's final defense mechanisms when normal security controls may be insufficient.\n\n| Security Event | Detection Triggers | Emergency Response | Service Impact |\n|----------------|-------------------|-------------------|----------------|\n| Potential key compromise | Multiple decryption failures, unusual key access patterns | Immediate key rotation, revoke all tokens | Temporary service disruption during key replacement |\n| Unauthorized access patterns | Failed authentication spikes, unusual geographic access | Rate limiting, IP blocking, enhanced audit logging | Legitimate users may experience delays |\n| Storage integrity issues | Checksum failures, unexpected data modifications | Read-only mode, enhanced validation | Write operations suspended |\n| Time synchronization loss | Clock skew detection, NTP failure | Conservative token validation, extended grace periods | Some authentication requests may fail |\n| Administrative account compromise | Unusual admin activity, policy changes outside change windows | Require additional authentication, suspend admin operations | Administrative functions temporarily restricted |\n\nThe most critical emergency procedure involves suspected master key compromise. The system immediately initiates emergency key rotation procedures, generates new master keys from fresh entropy sources, and begins re-encrypting all stored secrets. During this process, service availability may be completely suspended to prevent access using potentially compromised keys.\n\nSuspected authentication system compromise triggers comprehensive token revocation and enhanced authentication requirements. All active tokens are invalidated, and new authentication requires additional verification steps such as out-of-band confirmation or multi-factor authentication.\n\nStorage integrity emergencies place the system in a protective mode where all write operations are suspended and read operations include enhanced validation. The system maintains detailed forensic logs of all access attempts during integrity emergencies to support later investigation.\n\n> **Security Principle: Emergency Conservatism**\n> \n> During emergency security procedures, the system errs on the side of denying legitimate access rather than potentially allowing unauthorized access. Service availability is secondary to maintaining the confidentiality and integrity of stored secrets.\n\nEmergency procedures include automatic notification mechanisms to alert security teams and system administrators. These notifications include detailed context about the triggering conditions and recommended manual intervention steps. The system maintains emergency contact lists and escalation procedures for different types of security events.\n\nRecovery from emergency security procedures requires explicit administrative action after investigation confirms the system is safe to return to normal operation. This prevents the system from automatically resuming normal operations if the emergency conditions recur or if manual intervention is needed to address underlying security issues.\n\n### Implementation Guidance\n\nThis section provides practical implementation guidance for building robust error handling and recovery capabilities into the secret management system. The focus is on creating production-ready error handling that maintains security guarantees even during failure conditions.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Error Handling Framework | Standard library error wrapping (Go: `fmt.Errorf`, Python: `raise from`) | Structured error library (`github.com/pkg/errors`, `structlog`) |\n| Health Check System | HTTP endpoint with basic service status | Comprehensive health monitoring (`go-health`, `healthcheck`) |\n| Circuit Breaker | Simple timeout and retry logic | Production circuit breaker (`hystrix-go`, `circuit-breaker`) |\n| Backup System | File-based backups with cron scheduling | Enterprise backup solution (Velero, Restic with encryption) |\n| Monitoring and Alerting | Log file monitoring with grep | Full observability stack (Prometheus, Grafana, AlertManager) |\n| Graceful Shutdown | Signal handling with context cancellation | Graceful shutdown library (`graceful`, `shutdown-manager`) |\n\n#### File Structure for Error Handling\n\n```\ninternal/\n  errors/\n    errors.go              ← Custom error types and utilities\n    codes.go              ← Error classification and HTTP status mapping\n    recovery.go           ← Recovery procedure implementations\n  health/\n    checker.go            ← Health check implementations\n    status.go             ← System status tracking\n  backup/\n    backup.go             ← Backup coordination and scheduling\n    restore.go            ← Restoration procedures\n    validation.go         ← Post-recovery validation\n  graceful/\n    shutdown.go           ← Graceful degradation implementation\n    readonly.go           ← Read-only mode coordination\n```\n\n#### Core Error Handling Infrastructure\n\n```go\npackage errors\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"time\"\n)\n\n// ErrorCode represents different categories of errors for appropriate handling\ntype ErrorCode string\n\nconst (\n    ErrCodeStorageFailure    ErrorCode = \"STORAGE_FAILURE\"\n    ErrCodeEncryptionFailure ErrorCode = \"ENCRYPTION_FAILURE\"\n    ErrCodeNetworkFailure    ErrorCode = \"NETWORK_FAILURE\"\n    ErrCodeKeyCorruption     ErrorCode = \"KEY_CORRUPTION\"\n    ErrCodeAuthFailure       ErrorCode = \"AUTH_FAILURE\"\n    ErrCodeReadOnlyMode      ErrorCode = \"READ_ONLY_MODE\"\n)\n\n// SecretManagementError provides structured error information for proper handling\ntype SecretManagementError struct {\n    Code        ErrorCode\n    Message     string\n    Cause       error\n    Timestamp   time.Time\n    Context     map[string]interface{}\n    Recoverable bool\n    RetryAfter  time.Duration\n}\n\nfunc (e *SecretManagementError) Error() string {\n    return fmt.Sprintf(\"[%s] %s: %v\", e.Code, e.Message, e.Cause)\n}\n\n// NewStorageError creates an error for storage-related failures\nfunc NewStorageError(message string, cause error, recoverable bool) *SecretManagementError {\n    // TODO 1: Create SecretManagementError with ErrCodeStorageFailure\n    // TODO 2: Set appropriate retry delay based on error type\n    // TODO 3: Include storage-specific context information\n    // TODO 4: Determine if error is recoverable based on cause\n}\n\n// NewEncryptionError creates an error for encryption-related failures  \nfunc NewEncryptionError(message string, cause error) *SecretManagementError {\n    // TODO 1: Create SecretManagementError with ErrCodeEncryptionFailure\n    // TODO 2: Mark as non-recoverable (encryption errors are usually permanent)\n    // TODO 3: Include key version and algorithm context\n    // TODO 4: Set timestamp for audit trail\n}\n\n// ToHTTPStatus maps error codes to appropriate HTTP status codes\nfunc (e *SecretManagementError) ToHTTPStatus() int {\n    // TODO 1: Map ErrCodeStorageFailure to 503 Service Unavailable\n    // TODO 2: Map ErrCodeEncryptionFailure to 500 Internal Server Error\n    // TODO 3: Map ErrCodeAuthFailure to 401 Unauthorized or 403 Forbidden\n    // TODO 4: Map ErrCodeReadOnlyMode to 503 Service Unavailable\n    // TODO 5: Default to 500 for unmapped error codes\n}\n```\n\n#### Health Check and Status Monitoring\n\n```go\npackage health\n\nimport (\n    \"context\"\n    \"sync\"\n    \"time\"\n)\n\n// ComponentStatus represents the health status of a system component\ntype ComponentStatus string\n\nconst (\n    StatusHealthy   ComponentStatus = \"healthy\"\n    StatusDegraded  ComponentStatus = \"degraded\" \n    StatusUnhealthy ComponentStatus = \"unhealthy\"\n    StatusUnknown   ComponentStatus = \"unknown\"\n)\n\n// HealthCheck defines the interface for component health checking\ntype HealthCheck interface {\n    Name() string\n    Check(ctx context.Context) (ComponentStatus, error)\n    Timeout() time.Duration\n}\n\n// SystemHealth tracks the overall health of the secret management system\ntype SystemHealth struct {\n    checks      map[string]HealthCheck\n    lastResults map[string]ComponentStatus\n    mutex       sync.RWMutex\n    checkInterval time.Duration\n}\n\nfunc NewSystemHealth(checkInterval time.Duration) *SystemHealth {\n    return &SystemHealth{\n        checks:        make(map[string]HealthCheck),\n        lastResults:   make(map[string]ComponentStatus),\n        checkInterval: checkInterval,\n    }\n}\n\n// RegisterCheck adds a health check for a system component\nfunc (h *SystemHealth) RegisterCheck(check HealthCheck) {\n    // TODO 1: Add check to checks map using check.Name() as key\n    // TODO 2: Initialize status as StatusUnknown\n    // TODO 3: Consider thread safety for concurrent registration\n}\n\n// StartMonitoring begins continuous health checking for all components\nfunc (h *SystemHealth) StartMonitoring(ctx context.Context) {\n    // TODO 1: Create ticker for periodic health checks\n    // TODO 2: Run health checks for all registered components\n    // TODO 3: Update lastResults with current status\n    // TODO 4: Log status changes and health degradation\n    // TODO 5: Handle context cancellation for clean shutdown\n}\n\n// GetOverallStatus determines system-wide health based on component statuses\nfunc (h *SystemHealth) GetOverallStatus() ComponentStatus {\n    // TODO 1: Read all component statuses with appropriate locking\n    // TODO 2: Return StatusUnhealthy if any critical component is unhealthy\n    // TODO 3: Return StatusDegraded if any component is degraded\n    // TODO 4: Return StatusHealthy only if all components are healthy\n}\n\n// StorageHealthCheck implements health checking for storage backends\ntype StorageHealthCheck struct {\n    storage Backend\n    timeout time.Duration\n}\n\nfunc (s *StorageHealthCheck) Check(ctx context.Context) (ComponentStatus, error) {\n    // TODO 1: Create context with timeout for storage operation\n    // TODO 2: Attempt simple read operation (like reading a health check key)\n    // TODO 3: Measure response time and compare to thresholds\n    // TODO 4: Return StatusHealthy for fast responses, StatusDegraded for slow responses\n    // TODO 5: Return StatusUnhealthy for failed operations\n}\n```\n\n#### Backup and Recovery Implementation\n\n```go\npackage backup\n\nimport (\n    \"context\"\n    \"crypto/sha256\"\n    \"io\"\n    \"time\"\n)\n\n// BackupMetadata contains information about a backup for restoration\ntype BackupMetadata struct {\n    Timestamp     time.Time\n    BackupID      string\n    Components    []string\n    Checksum      []byte\n    EncryptionKey string\n    Consistency   ConsistencyLevel\n}\n\ntype ConsistencyLevel int\n\nconst (\n    ConsistencyEventual ConsistencyLevel = iota\n    ConsistencyStrong\n    ConsistencySnapshot\n)\n\n// BackupManager coordinates backup and restore operations across system components\ntype BackupManager struct {\n    storage        Backend\n    encryptionKey  []byte\n    backupLocation string\n    retentionDays  int\n}\n\nfunc NewBackupManager(storage Backend, encryptionKey []byte, location string) *BackupManager {\n    return &BackupManager{\n        storage:        storage,\n        encryptionKey:  encryptionKey,\n        backupLocation: location,\n        retentionDays:  90, // Default retention\n    }\n}\n\n// CreateBackup performs a full system backup with consistency guarantees\nfunc (b *BackupManager) CreateBackup(ctx context.Context, components []string) (*BackupMetadata, error) {\n    // TODO 1: Generate unique backup ID with timestamp\n    // TODO 2: Create backup directory structure\n    // TODO 3: For each component, call component-specific backup procedure\n    // TODO 4: Calculate checksums for all backup files\n    // TODO 5: Encrypt backup data using provided encryption key\n    // TODO 6: Create and store backup metadata\n    // TODO 7: Verify backup integrity before returning\n    // Hint: Use consistent snapshot timestamp across all components\n}\n\n// RestoreFromBackup restores system state from a specific backup\nfunc (b *BackupManager) RestoreFromBackup(ctx context.Context, backupID string) error {\n    // TODO 1: Load and validate backup metadata\n    // TODO 2: Verify backup integrity using stored checksums\n    // TODO 3: Decrypt backup data using stored encryption key\n    // TODO 4: Stop all write operations (enter read-only mode)\n    // TODO 5: Restore components in dependency order\n    // TODO 6: Validate restored data consistency\n    // TODO 7: Restart services and exit read-only mode\n    // Hint: Implement rollback capability if restoration fails\n}\n\n// ValidateBackupIntegrity checks that a backup can be successfully restored\nfunc (b *BackupManager) ValidateBackupIntegrity(ctx context.Context, backupID string) error {\n    // TODO 1: Load backup metadata and verify structure\n    // TODO 2: Calculate checksums for all backup files\n    // TODO 3: Compare calculated checksums with stored checksums\n    // TODO 4: Attempt to decrypt a sample of backup data\n    // TODO 5: Verify component-specific validation (e.g., secret decryption)\n    // TODO 6: Return detailed error information for any validation failures\n}\n\n// CleanupExpiredBackups removes backups older than retention policy\nfunc (b *BackupManager) CleanupExpiredBackups(ctx context.Context) error {\n    // TODO 1: List all available backups with timestamps\n    // TODO 2: Identify backups older than retention period\n    // TODO 3: For each expired backup, verify it's safe to delete\n    // TODO 4: Remove backup files and metadata\n    // TODO 5: Update backup indexes and cleanup empty directories\n    // Hint: Keep minimum number of backups regardless of age\n}\n```\n\n#### Graceful Degradation Implementation\n\n```go\npackage graceful\n\nimport (\n    \"context\"\n    \"sync/atomic\"\n    \"time\"\n)\n\n// DegradationLevel represents the current operational mode of the system\ntype DegradationLevel int32\n\nconst (\n    FullOperation DegradationLevel = iota\n    ReadOnlyMode\n    EmergencyMode\n    MaintenanceMode\n)\n\n// GracefulDegradation manages system operation during failure conditions\ntype GracefulDegradation struct {\n    currentLevel     int32 // atomic access to DegradationLevel\n    emergencyTrigger chan struct{}\n    statusCallbacks  []func(DegradationLevel)\n    healthChecker    *SystemHealth\n}\n\nfunc NewGracefulDegradation(healthChecker *SystemHealth) *GracefulDegradation {\n    return &GracefulDegradation{\n        currentLevel:     int32(FullOperation),\n        emergencyTrigger: make(chan struct{}, 1),\n        healthChecker:    healthChecker,\n    }\n}\n\n// GetCurrentLevel returns the current degradation level thread-safely\nfunc (g *GracefulDegradation) GetCurrentLevel() DegradationLevel {\n    return DegradationLevel(atomic.LoadInt32(&g.currentLevel))\n}\n\n// SetDegradationLevel changes the operational mode and notifies all listeners\nfunc (g *GracefulDegradation) SetDegradationLevel(level DegradationLevel, reason string) {\n    // TODO 1: Use atomic operation to set new degradation level\n    // TODO 2: Log degradation level change with timestamp and reason\n    // TODO 3: Call all registered status change callbacks\n    // TODO 4: Update system metrics and monitoring\n    // TODO 5: Send notifications to operations team for significant changes\n}\n\n// MonitorSystemHealth continuously monitors health and adjusts degradation level\nfunc (g *GracefulDegradation) MonitorSystemHealth(ctx context.Context) {\n    ticker := time.NewTicker(30 * time.Second)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case <-ctx.Done():\n            return\n        case <-ticker.C:\n            // TODO 1: Get overall system health from health checker\n            // TODO 2: Evaluate if current degradation level is appropriate\n            // TODO 3: If storage is unhealthy, move to read-only mode\n            // TODO 4: If critical components fail, move to emergency mode\n            // TODO 5: If health improves, consider restoring higher service level\n        case <-g.emergencyTrigger:\n            // TODO 1: Immediately set EmergencyMode degradation level\n            // TODO 2: Log emergency trigger with full context\n            // TODO 3: Send high-priority alerts to operations team\n        }\n    }\n}\n\n// IsOperationAllowed checks if a specific operation is permitted at current degradation level\nfunc (g *GracefulDegradation) IsOperationAllowed(operation string) bool {\n    currentLevel := g.GetCurrentLevel()\n    \n    switch currentLevel {\n    case FullOperation:\n        return true\n    case ReadOnlyMode:\n        // TODO 1: Allow secret retrieval operations\n        // TODO 2: Allow policy evaluation operations  \n        // TODO 3: Block secret creation/update operations\n        // TODO 4: Block dynamic secret generation\n        // TODO 5: Allow lease renewals but not new lease creation\n    case EmergencyMode:\n        // TODO 1: Allow only essential read operations\n        // TODO 2: Block all write operations\n        // TODO 3: Block all administrative operations\n        // TODO 4: Allow health check operations\n    case MaintenanceMode:\n        // TODO 1: Block all client operations\n        // TODO 2: Allow administrative and maintenance operations\n        // TODO 3: Allow backup and restore operations\n    default:\n        return false\n    }\n}\n\n// TriggerEmergency immediately places system in emergency mode\nfunc (g *GracefulDegradation) TriggerEmergency(reason string) {\n    // TODO 1: Log emergency trigger with full context and reason\n    // TODO 2: Send signal to emergency trigger channel (non-blocking)\n    // TODO 3: Generate audit event for emergency mode activation\n    // TODO 4: Update monitoring metrics for emergency state\n}\n```\n\n#### Milestone Checkpoints\n\n**After Milestone 1 (Encryption Engine):**\n- Verify error handling for key corruption by corrupting a DEK file and confirming graceful failure\n- Test backup and restore of encrypted secrets with key rotation\n- Confirm system fails safely when master key is unavailable\n\n**After Milestone 2 (Authentication Engine):**\n- Test graceful degradation when auth database becomes unavailable\n- Verify token validation continues using cached policies in read-only mode\n- Confirm audit logging continues during authentication failures\n\n**After Milestone 3 (Dynamic Secrets):**\n- Test behavior when backend databases become unavailable\n- Verify lease extension during degraded mode\n- Confirm revocation queue persistence across system restarts\n\n**After Milestone 4 (High Availability):**\n- Test cluster behavior during network partitions\n- Verify automatic failover and read-only mode for minority partitions\n- Test backup and restore procedures across clustered deployment\n\n#### Common Debugging Scenarios\n\n| Symptom | Likely Cause | Diagnostic Steps | Resolution |\n|---------|--------------|------------------|------------|\n| System stuck in read-only mode | Storage backend connectivity issues | Check storage health endpoints, verify network connectivity | Restore storage connectivity, manually exit read-only mode |\n| Backup restoration fails | Encryption key mismatch or corruption | Verify key shares, test key reconstruction | Restore keys from separate backup, regenerate corrupted keys |\n| Health checks failing intermittently | Network timeouts or resource exhaustion | Monitor resource usage, check network latency | Adjust health check timeouts, scale resources |\n| Emergency mode triggered unexpectedly | Security monitoring false positives | Review audit logs for trigger events | Tune security monitoring thresholds, add exception rules |\n| Graceful shutdown hangs | Background processes not responding to context cancellation | Check goroutine dumps, identify blocking operations | Add timeout enforcement, improve context handling |\n\n\n## Testing Strategy\n\n> **Milestone(s):** This section spans all four milestones, with specific testing approaches for each: security testing for encrypted storage (Milestone 1), access control validation (Milestone 2), dynamic secret lifecycle testing (Milestone 3), and cluster consensus testing (Milestone 4).\n\nTesting a secret management system requires a fundamentally different approach than testing typical applications. Think of it like testing a bank vault system — you're not just verifying that the safe opens when given the correct combination, but also that it absolutely refuses to open for any incorrect combination, that the steel walls resist drilling attempts, that the alarm system triggers under all threat scenarios, and that the backup power systems work during emergencies. In secret management, a single security failure can compromise an entire organization's infrastructure, making comprehensive testing not just important but absolutely critical.\n\nThe testing strategy for our secret management system operates on three complementary levels. **Security testing** forms the foundation, continuously verifying that our cryptographic implementations, access controls, and audit mechanisms work correctly under both normal and adversarial conditions. **Milestone checkpoints** provide structured validation points as we build each component, ensuring that fundamental behaviors work correctly before adding complexity. **Integration testing** validates the complete system workflows, testing how all components interact to deliver secure secret management capabilities to real applications.\n\nThis multi-layered approach reflects the **defense in depth** principle — if one testing layer misses a vulnerability, the other layers should catch it. We test not just the happy path where everything works correctly, but also the adversarial scenarios where attackers attempt to exploit weaknesses, the chaos scenarios where infrastructure fails unpredictably, and the operational scenarios where human operators make mistakes under pressure.\n\n### Security Testing\n\nSecurity testing for a secret management system goes far beyond checking that basic encryption works. Think of it like testing a corporate security system — you need to verify not just that authorized employees can enter the building, but that unauthorized individuals cannot gain access even with sophisticated attack techniques, that security cameras capture all relevant events, and that alarm systems function correctly during emergencies.\n\n**Encryption verification** forms the cornerstone of our security testing approach. We must validate that our envelope encryption implementation provides the security properties we claim, that key rotation works without exposing plaintext secrets, and that our cryptographic implementations resist known attacks.\n\nThe encryption testing matrix covers multiple dimensions of verification:\n\n| Test Category | Security Property | Validation Method | Failure Impact |\n|--------------|------------------|------------------|----------------|\n| Ciphertext Analysis | Semantic Security | Statistical randomness tests on encrypted output | Reveals information about plaintext secrets |\n| Key Isolation | Key Independence | Decrypt with wrong DEK version, verify failure | Cross-version secret exposure |\n| Nonce Uniqueness | Replay Resistance | Detect nonce reuse across encryptions | Authentication bypass via replay |\n| Authentication Tag | Tamper Detection | Modify ciphertext, verify decryption failure | Undetected data corruption |\n| Key Derivation | Brute Force Resistance | Time password cracking attempts | Weak master key compromise |\n| Memory Protection | Information Leakage | Scan memory dumps for plaintext keys | Key extraction from memory |\n\n**Cryptographic validation** requires testing our encryption engine against known attack vectors and edge cases. We implement test cases that attempt to exploit common vulnerabilities in envelope encryption systems, such as key confusion attacks where attackers trick the system into using the wrong decryption key, or padding oracle attacks that reveal information through error messages.\n\nThe key rotation security tests deserve particular attention. During key rotation, we temporarily have both old and new encryption keys in memory, creating a window where compromise of either key could affect system security. Our tests simulate various failure scenarios during rotation — such as power loss, network partitions, or process crashes — and verify that the system maintains security guarantees in all cases.\n\n> **Decision: Continuous Cryptographic Testing**\n> - **Context**: Cryptographic bugs can be subtle and may not manifest in functional testing, but can completely compromise security\n> - **Options Considered**: Manual periodic reviews, automated test suite with crypto vectors, formal verification\n> - **Decision**: Comprehensive automated test suite with known crypto test vectors plus property-based testing\n> - **Rationale**: Automated testing catches regressions immediately, known vectors validate against published standards, property-based testing finds edge cases\n> - **Consequences**: Higher confidence in crypto implementation, but requires significant test infrastructure investment\n\n**Access control validation** tests our authentication and authorization mechanisms under both normal and adversarial conditions. This includes testing for **constant-time comparison** vulnerabilities, where timing differences in token validation could allow attackers to guess valid tokens, and policy bypass attempts where malformed requests might circumvent access controls.\n\nOur access control test scenarios include:\n\n| Attack Vector | Test Method | Expected Outcome | Security Concern |\n|--------------|-------------|------------------|------------------|\n| Token Guessing | Brute force token validation with timing analysis | Constant response time regardless of token validity | Timing side-channel reveals valid token patterns |\n| Path Traversal | Request secrets with manipulated paths (../, //) | Access denied for all unauthorized paths | Directory traversal bypasses path-based ACLs |\n| Policy Confusion | Submit requests with conflicting policy claims | Deny access when policies conflict | Ambiguous policies might default to allow |\n| Token Replay | Reuse expired or revoked tokens | Reject all invalid tokens consistently | Stale tokens continue to grant access |\n| Privilege Escalation | Attempt to access admin endpoints with user tokens | Enforce role separation strictly | Users gain administrative privileges |\n| Session Fixation | Predict or control token generation | Cryptographically random, unpredictable tokens | Attackers can guess or control user tokens |\n\nThe **audit logging security tests** verify that our tamper-evident logging correctly captures all security-relevant events and resists attempts to modify or delete audit records. We test scenarios where attackers gain partial system access and attempt to cover their tracks by modifying log files.\n\n**Penetration testing** simulates real-world attack scenarios against our deployed secret management system. These tests assume that attackers have gained some level of system access — perhaps through compromised application credentials or network position — and attempt to escalate their access to retrieve secrets they shouldn't have.\n\nCommon penetration testing scenarios include:\n\n1. **Compromise Recovery Testing**: Simulate discovery of a leaked token and verify that token revocation prevents further access\n2. **Insider Threat Simulation**: Test system behavior when legitimate users attempt to access secrets outside their authorized scope\n3. **Network Attack Simulation**: Test TLS configuration and certificate validation under man-in-the-middle attacks\n4. **Side-Channel Analysis**: Monitor system resource usage patterns to detect information leakage through CPU, memory, or network timing\n5. **Social Engineering Simulation**: Test operational procedures for responding to requests for emergency access or system recovery\n\n**Chaos security testing** introduces failures during security-critical operations to verify that our system maintains security properties even under adverse conditions. For example, we might simulate power loss during key rotation, network partitions during authentication, or storage corruption during secret updates.\n\nThe key insight from chaos security testing is that security vulnerabilities often emerge not from normal operation, but from the complex interactions between security mechanisms and failure recovery procedures. A system might correctly encrypt secrets during normal operation, but accidentally write plaintext to logs during error recovery.\n\n### Milestone Checkpoints\n\nEach milestone introduces new security-critical functionality that must be thoroughly validated before proceeding to the next phase. Think of these checkpoints like security clearance levels — you can't proceed to more sensitive information until you've proven that the current level is completely secure.\n\n**Milestone 1 Checkpoint: Encrypted Secret Storage**\n\nThe first milestone establishes the foundation of our security model through envelope encryption. The checkpoint validation must verify that secrets are never stored in plaintext and that our key management procedures work correctly.\n\nCritical validation points for Milestone 1:\n\n| Validation Category | Test Description | Success Criteria | Failure Symptoms |\n|--------------------|------------------|------------------|------------------|\n| Envelope Encryption | Store secret, examine storage backend directly | No plaintext visible in stored data | Secrets readable without decryption |\n| Key Rotation | Rotate DEK, verify old and new versions decrypt correctly | Both versions accessible, no downtime | Secret access failures or plaintext exposure |\n| Secret Versioning | Create multiple versions, verify independent retrieval | Each version returns correct value | Version confusion or data corruption |\n| Master Key Protection | Examine memory dumps and storage for key material | Keys only in memory when actively used | Persistent key storage or memory leaks |\n| Recovery Testing | Restart system, verify access to existing secrets | All secrets accessible after restart | Data loss or corruption after restart |\n| Storage Backend Independence | Switch storage backends, verify secret accessibility | Seamless backend migration | Backend-specific secret corruption |\n\nThe envelope encryption validation requires careful testing of the key hierarchy. We must verify that the master key never appears in persistent storage except when encrypted by external systems (for auto-unseal scenarios), that data encryption keys are properly versioned and rotated independently, and that secret values remain accessible across key rotation events.\n\n**Performance baseline testing** establishes acceptable latency and throughput characteristics for the encryption engine. Secret management systems often become bottlenecks in application deployment pipelines, so understanding performance characteristics helps with capacity planning.\n\nKey performance metrics for Milestone 1:\n\n- **Encryption latency**: Time from secret submission to storage confirmation\n- **Decryption latency**: Time from secret request to plaintext delivery  \n- **Key rotation duration**: End-to-end time for DEK rotation with large secret volumes\n- **Memory usage patterns**: Peak memory consumption during encryption operations\n- **Storage amplification**: Ratio of encrypted storage size to plaintext size\n\n**Milestone 2 Checkpoint: Access Policies & Authentication**\n\nThe second milestone introduces authentication and authorization capabilities that protect the encrypted secrets created in Milestone 1. The validation must verify that only properly authenticated and authorized requests can access secrets.\n\nAuthentication validation focuses on ensuring that our token-based and mTLS authentication mechanisms correctly identify clients and resist common attacks:\n\n| Authentication Test | Attack Simulation | Validation Method | Security Property |\n|--------------------|-------------------|-------------------|-------------------|\n| Token Validation | Submit requests with forged tokens | Reject all invalid tokens with constant timing | Cryptographic token integrity |\n| Token Expiration | Use expired tokens after TTL | Access denied for expired credentials | Temporal access control |\n| mTLS Certificate | Present invalid or expired client certificates | Reject connections with invalid certificates | Certificate-based identity |\n| Replay Attack | Reuse intercepted authentication tokens | Detect and reject replayed tokens | Replay resistance |\n| Timing Analysis | Measure token validation response times | Constant time regardless of token validity | Side-channel resistance |\n| Concurrent Sessions | Multiple simultaneous sessions with same token | Proper session isolation and tracking | Session security |\n\nAuthorization validation ensures that our path-based policy engine correctly enforces access controls even with complex policy rules and edge cases:\n\n| Authorization Test | Policy Scenario | Request Pattern | Expected Outcome |\n|-------------------|-----------------|-----------------|------------------|\n| Exact Path Match | Policy allows `secret/app/db` | Request `secret/app/db` | Access granted |\n| Wildcard Matching | Policy allows `secret/app/*` | Request `secret/app/api-key` | Access granted |\n| Path Traversal | Policy allows `secret/app/*` | Request `secret/app/../admin/key` | Access denied |\n| Nested Wildcards | Policy allows `secret/**` | Request `secret/deep/nested/path` | Access granted according to recursive pattern |\n| Policy Conflicts | Multiple policies with different permissions | Requests matching overlapping policies | Secure default (deny) when ambiguous |\n| Missing Policies | No policy covers requested path | Any request to uncovered path | Default deny behavior |\n\n**Audit logging validation** ensures that all security-relevant events are properly captured and that the audit trail provides sufficient information for security investigations:\n\n- **Event completeness**: All authentication attempts, authorization decisions, and secret access events logged\n- **Event integrity**: Audit records resist tampering and provide cryptographic integrity guarantees\n- **Event correlation**: Related events (authentication → authorization → secret access) can be traced through request IDs\n- **Performance impact**: Audit logging doesn't significantly degrade system performance\n- **Storage management**: Audit logs rotate properly and don't exhaust available storage\n\n**Milestone 3 Checkpoint: Dynamic Secrets**\n\nThe third milestone adds dynamic secret generation capabilities, introducing time-based security properties through lease management. Validation must verify that credentials are properly generated, tracked, and revoked.\n\nDynamic secret generation testing focuses on the credential lifecycle and backend integration:\n\n| Backend Type | Generation Test | Revocation Test | Renewal Test |\n|-------------|----------------|-----------------|--------------|\n| Database | Create unique user with limited privileges | Remove user and verify access denied | Extend user TTL and verify continued access |\n| AWS IAM | Generate temporary access keys with scoped permissions | Delete IAM user and verify API calls fail | Renew access keys before expiration |\n| SSH | Generate signed certificate with time limits | Verify certificate invalid after TTL | Issue renewed certificate with extended validity |\n| PKI | Issue client certificate with usage constraints | Revoke certificate via CRL | Renew certificate with same subject but new validity period |\n\n**Lease management validation** ensures that the time-based security model works correctly:\n\n- **TTL enforcement**: Credentials become invalid exactly when leases expire\n- **Renewal mechanics**: Renewable leases extend correctly, non-renewable leases reject renewal attempts  \n- **Revocation timeliness**: Explicit revocation requests disable credentials within acceptable time bounds\n- **Cleanup completeness**: Revocation removes all traces of credentials from target systems\n- **Failure recovery**: Failed revocation attempts retry with exponential backoff until successful\n\nThe **lease reaper testing** validates the background processes that maintain system security by cleaning up expired credentials:\n\n1. Create multiple dynamic secrets with different TTLs\n2. Wait for natural expiration of some credentials\n3. Verify that expired credentials no longer grant access to target systems\n4. Confirm that lease records are properly cleaned from internal storage\n5. Test reaper behavior during system restart and recovery scenarios\n\n**Milestone 4 Checkpoint: Unsealing & High Availability**\n\nThe final milestone introduces distributed operation and master key protection through Shamir's secret sharing. Validation must verify that the cluster maintains security and availability guarantees under various failure scenarios.\n\n**Shamir's secret sharing validation** ensures that our threshold scheme correctly protects the master key:\n\n| Share Configuration | Test Scenario | Validation Method | Security Property |\n|-------------------|---------------|-------------------|-------------------|\n| 3-of-5 threshold | Reconstruct with exactly 3 shares | Successfully unseal system | Minimum threshold suffices |\n| 2-of-5 attempt | Attempt reconstruction with only 2 shares | Reconstruction fails completely | Insufficient shares provide no information |\n| Share corruption | Modify one share before reconstruction | Detect corruption and reject invalid share | Share integrity validation |\n| Share ordering | Present shares in different orders | Reconstruction produces identical results | Order independence |\n| Share storage | Examine individual share contents | Shares reveal no information about master key | Information-theoretic security |\n| Recovery procedure | Simulate loss of shares, regenerate master key | Complete system recovery with new shares | Disaster recovery capabilities |\n\n**High availability validation** tests the distributed consensus mechanisms and leader election procedures:\n\n- **Leader election**: Single leader emerges after cluster startup, leadership transfers correctly during failures\n- **Split-brain prevention**: Network partitions don't result in multiple active leaders accepting conflicting writes\n- **Data consistency**: All nodes converge to identical state after network partition recovery\n- **Client failover**: Clients automatically redirect to new leader after failover events\n- **Performance impact**: Consensus overhead doesn't significantly degrade operation latency\n\n**Auto-unseal integration testing** validates the cloud KMS integration for automated system startup:\n\n1. Configure auto-unseal with mock KMS provider\n2. Seal the system and verify it requires external key to operate\n3. Test auto-unseal during normal startup procedures\n4. Simulate KMS failures during unseal attempts\n5. Verify fallback to manual unseal when auto-unseal unavailable\n6. Test key rotation scenarios with external KMS keys\n\n### Integration Testing\n\nIntegration testing validates that all components work together correctly to provide secure secret management capabilities to real applications. Think of this as testing the entire bank vault system — not just the individual components like the safe, alarm system, and access controls, but how they all work together to protect valuable assets under realistic conditions.\n\n**End-to-end workflow testing** simulates complete application interactions with our secret management system, from initial authentication through secret retrieval and dynamic credential generation. These tests use realistic application patterns and data volumes to surface integration issues that might not appear in unit tests.\n\nPrimary integration test workflows include:\n\n| Workflow | Description | Components Tested | Failure Modes |\n|----------|-------------|-------------------|---------------|\n| Application Bootstrap | App authenticates and retrieves configuration secrets | Auth engine, encryption engine, policy evaluation | Auth failures prevent app startup |\n| Database Connection | App requests dynamic DB credentials for data access | Dynamic secret engine, lease management, DB backend | Connection failures or credential conflicts |\n| Secret Rotation | Background process rotates static secrets used by apps | Encryption engine, versioning, client notification | App service disruption during rotation |\n| Emergency Access | Operator manually accesses secrets during incident response | Unsealing, emergency policies, audit logging | Security versus availability trade-offs |\n| Cluster Failover | Primary node fails, backup takes over without service disruption | HA cluster, leader election, data replication | Client connection disruption or data loss |\n| Backup and Recovery | Complete system restore from encrypted backups | All components, unsealing, data verification | Incomplete recovery or data corruption |\n\n**Backend plugin testing** validates the integration between our dynamic secret engine and external systems that provide credentials. Each backend type has different integration patterns and failure modes that require specific testing approaches.\n\nDatabase backend integration testing covers multiple database platforms and credential patterns:\n\n- **PostgreSQL integration**: Test user creation, privilege assignment, connection validation, and cleanup procedures\n- **MySQL integration**: Validate account creation with proper grants, password policies, and revocation procedures  \n- **MongoDB integration**: Test role-based access control, database-specific permissions, and user removal\n- **Connection pooling**: Verify that credential generation doesn't overwhelm database connection limits\n- **Schema permissions**: Test that generated users receive only necessary privileges for their intended use case\n\nCloud provider backend testing validates integration with major cloud platforms:\n\n- **AWS IAM integration**: Test temporary access key generation, policy attachment, and key revocation\n- **Azure AD integration**: Validate service principal creation, role assignment, and cleanup procedures\n- **Google Cloud IAM integration**: Test service account key generation, project-level permissions, and key deletion\n- **Resource isolation**: Verify that generated credentials can't access resources outside intended scope\n\n**Load testing** evaluates system behavior under realistic traffic patterns and helps identify performance bottlenecks or resource exhaustion issues. Secret management systems often experience bursty traffic patterns — for example, during application deployment windows when many services simultaneously request credentials.\n\nLoad testing scenarios include:\n\n| Scenario | Traffic Pattern | Duration | Success Criteria |\n|----------|----------------|----------|------------------|\n| Steady State | Constant rate of secret requests | 8 hours | < 100ms p99 latency, no errors |\n| Deployment Burst | 10x normal traffic for short periods | 30 minutes | Graceful degradation, no failures |\n| Key Rotation | Background key rotation during normal traffic | 2 hours | No client impact, consistent latency |\n| Dynamic Secret Storm | Many simultaneous dynamic credential requests | 15 minutes | Backend rate limiting, queue management |\n| Cluster Recovery | Traffic resumes after planned failover | 1 hour | Automatic client reconnection, no data loss |\n| Memory Pressure | Sustained high memory usage scenarios | 4 hours | No memory leaks, graceful resource management |\n\n**Security integration testing** validates that our security mechanisms work correctly when multiple components interact under realistic conditions. This includes testing for emergent security vulnerabilities that might arise from component interactions.\n\nCross-component security scenarios:\n\n- **Token lifecycle across components**: Verify that token expiration in auth engine immediately affects access in all other components\n- **Audit trail completeness**: Confirm that operations involving multiple components generate complete audit trails\n- **Error message information leakage**: Ensure that error responses don't reveal sensitive information about system internal state\n- **Resource exhaustion attacks**: Test system behavior when attackers attempt to exhaust resources across multiple components\n- **Privilege boundary enforcement**: Verify that compromise of one component doesn't automatically compromise others\n\n**Monitoring and observability testing** validates that our system provides sufficient visibility for operations teams to maintain security and availability. This includes testing that metrics, logs, and health checks correctly reflect system state and can support effective incident response.\n\nObservability validation points:\n\n- **Health check accuracy**: Health endpoints correctly reflect component status and dependency health\n- **Metric completeness**: Prometheus metrics cover all critical operations and performance characteristics  \n- **Log correlation**: Related events across components can be traced through correlation IDs\n- **Alert threshold accuracy**: Alert conditions trigger at appropriate times without excessive false positives\n- **Dashboard effectiveness**: Operational dashboards provide actionable information during incidents\n\nThe integration testing phase also validates our **graceful degradation** capabilities — how the system behaves when some components fail but others remain operational. For example, if the dynamic secret engine fails, the system should continue serving static secrets while clearly indicating the reduced functionality.\n\n### Implementation Guidance\n\nThe testing strategy implementation provides comprehensive validation for all aspects of our secret management system. This implementation focuses on Go testing frameworks and tools that provide robust security testing capabilities.\n\n**Technology Recommendations:**\n\n| Testing Category | Simple Option | Advanced Option |\n|------------------|---------------|-----------------|\n| Unit Testing | Go standard testing package | Testify framework with assertions |\n| Security Testing | Manual crypto test vectors | Rapid property-based testing |\n| Integration Testing | HTTP client tests against local server | Testcontainers with real databases |\n| Load Testing | Basic goroutine-based load generation | Vegeta or k6 load testing tools |\n| Penetration Testing | Manual security reviews | OWASP ZAP automated scanning |\n| Chaos Testing | Manual failure injection | Chaos Monkey or Litmus chaos engineering |\n\n**Recommended Testing File Structure:**\n```\nproject-root/\n  cmd/\n    server/\n      main_test.go              ← integration tests\n  internal/\n    encryption/\n      engine.go\n      engine_test.go            ← unit tests\n      engine_security_test.go   ← security-specific tests\n    auth/\n      engine.go  \n      engine_test.go\n      engine_integration_test.go ← cross-component tests\n    dynamic/\n      engine.go\n      engine_test.go\n      backends/\n        database_test.go        ← backend-specific tests\n  test/\n    security/\n      crypto_vectors_test.go    ← known answer tests\n      penetration_test.go       ← security scanning tests\n    integration/\n      workflows_test.go         ← end-to-end scenarios\n      load_test.go             ← performance testing\n    testdata/\n      policies/               ← test policy files\n      certificates/           ← test TLS certificates\n      vectors/               ← crypto test vectors\n  docker-compose.test.yml     ← test environment setup\n```\n\n**Security Testing Infrastructure:**\n\n```go\n// Package security provides comprehensive security testing utilities\n// for the secret management system.\npackage security\n\nimport (\n    \"crypto/rand\"\n    \"crypto/subtle\"\n    \"testing\"\n    \"time\"\n)\n\n// CryptoTestVector represents a known-answer test for cryptographic operations.\ntype CryptoTestVector struct {\n    Name       string\n    Plaintext  []byte\n    Key        []byte\n    Nonce      []byte\n    Expected   []byte\n    ShouldFail bool\n}\n\n// LoadKnownVectors loads standardized crypto test vectors from NIST or other sources.\nfunc LoadKnownVectors(algorithm string) ([]CryptoTestVector, error) {\n    // TODO 1: Read test vectors from testdata/vectors/ directory\n    // TODO 2: Parse vector format (usually hex-encoded values)\n    // TODO 3: Return structured test cases for the specified algorithm\n    // TODO 4: Include both positive (should succeed) and negative (should fail) cases\n}\n\n// TimingAttackTest validates constant-time operations by measuring execution times.\ntype TimingAttackTest struct {\n    ValidInput   string\n    InvalidInput string\n    Operation    func(string) bool\n    Iterations   int\n    Tolerance    time.Duration\n}\n\n// RunTimingAnalysis executes timing attack tests to detect side-channel vulnerabilities.\nfunc (t *TimingAttackTest) RunTimingAnalysis(test *testing.T) {\n    // TODO 1: Execute operation with valid input multiple times, measure duration\n    // TODO 2: Execute operation with invalid input multiple times, measure duration  \n    // TODO 3: Calculate statistical significance of timing differences\n    // TODO 4: Fail test if timing difference exceeds tolerance threshold\n    // Hint: Use runtime.GC() before timing measurements for consistency\n}\n\n// PropertyTest defines properties that should hold for cryptographic operations.\ntype PropertyTest func(input []byte) bool\n\n// RunPropertyBasedTests executes randomized property testing for crypto operations.\nfunc RunPropertyBasedTests(t *testing.T, property PropertyTest, iterations int) {\n    for i := 0; i < iterations; i++ {\n        // TODO 1: Generate random input of varying lengths\n        // TODO 2: Execute property test function\n        // TODO 3: Report failure with specific input that violated property\n        // TODO 4: Use crypto/rand for cryptographically secure randomness\n    }\n}\n\n// PenetrationTestSuite coordinates security testing against running system.\ntype PenetrationTestSuite struct {\n    BaseURL    string\n    TestToken  string\n    AdminToken string\n    Client     *http.Client\n}\n\n// TestAuthenticationBypass attempts various authentication bypass techniques.\nfunc (p *PenetrationTestSuite) TestAuthenticationBypass(t *testing.T) {\n    testCases := []struct {\n        name        string\n        headers     map[string]string\n        expectError bool\n    }{\n        // TODO: Add test cases for:\n        // - Missing authentication headers\n        // - Malformed tokens\n        // - Expired tokens\n        // - Tokens with invalid signatures\n        // - SQL injection in token fields\n        // - Directory traversal in token claims\n    }\n    \n    // TODO 1: Iterate through test cases\n    // TODO 2: Make HTTP requests with crafted headers\n    // TODO 3: Verify that unauthorized requests are rejected\n    // TODO 4: Check that error responses don't leak sensitive information\n}\n```\n\n**Milestone Checkpoint Implementation:**\n\n```go\n// Package checkpoint provides milestone validation utilities.\npackage checkpoint\n\nimport (\n    \"context\"\n    \"testing\"\n    \"time\"\n    \n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/require\"\n)\n\n// Milestone1Validator validates encrypted secret storage functionality.\ntype Milestone1Validator struct {\n    server   *SecretServer\n    storage  Backend\n    testData map[string]string\n}\n\n// ValidateEnvelopeEncryption verifies that secrets are properly encrypted at rest.\nfunc (m *Milestone1Validator) ValidateEnvelopeEncryption(t *testing.T) {\n    ctx := context.Background()\n    testSecret := \"super-secret-password\"\n    \n    // TODO 1: Store a secret through the API\n    // TODO 2: Examine the storage backend directly for the encrypted data\n    // TODO 3: Verify that plaintext secret does not appear in storage\n    // TODO 4: Verify that encrypted data includes proper authentication tags\n    // TODO 5: Attempt to decrypt with wrong key and verify it fails\n    \n    // Expected behavior: No plaintext visible in storage, proper encryption metadata\n}\n\n// ValidateKeyRotation tests key rotation without affecting secret accessibility.\nfunc (m *Milestone1Validator) ValidateKeyRotation(t *testing.T) {\n    ctx := context.Background()\n    \n    // TODO 1: Create several test secrets\n    // TODO 2: Trigger key rotation operation\n    // TODO 3: Verify all existing secrets remain accessible\n    // TODO 4: Create new secret and verify it uses new key version\n    // TODO 5: Verify that both old and new key versions work correctly\n    \n    // Expected behavior: Zero downtime rotation with version compatibility\n}\n\n// Milestone2Validator validates authentication and authorization functionality.\ntype Milestone2Validator struct {\n    server    *SecretServer\n    testPolicies map[string]*Policy\n    testTokens   map[string]*Token\n}\n\n// ValidateAccessControl tests policy enforcement and authentication.\nfunc (m *Milestone2Validator) ValidateAccessControl(t *testing.T) {\n    // TODO 1: Create test policies with different path permissions\n    // TODO 2: Create test tokens with different policy assignments\n    // TODO 3: Attempt to access secrets with each token\n    // TODO 4: Verify that access is granted/denied according to policies\n    // TODO 5: Test edge cases like path traversal attempts\n    \n    // Expected behavior: Only authorized requests succeed, proper audit logging\n}\n\n// LoadTestValidator provides performance and load testing validation.\ntype LoadTestValidator struct {\n    baseURL     string\n    concurrency int\n    duration    time.Duration\n}\n\n// ValidatePerformance executes load test and validates performance characteristics.\nfunc (l *LoadTestValidator) ValidatePerformance(t *testing.T) {\n    // TODO 1: Create multiple goroutines to simulate concurrent clients\n    // TODO 2: Execute secret read/write operations for specified duration\n    // TODO 3: Measure latency percentiles (p50, p95, p99)\n    // TODO 4: Track error rates and timeout conditions\n    // TODO 5: Verify that performance meets acceptance criteria\n    \n    // Expected behavior: <100ms p99 latency, <1% error rate under normal load\n}\n```\n\n**Integration Testing Framework:**\n\n```go\n// Package integration provides end-to-end testing capabilities.\npackage integration\n\nimport (\n    \"context\"\n    \"database/sql\"\n    \"testing\"\n    \n    \"github.com/testcontainers/testcontainers-go\"\n    \"github.com/testcontainers/testcontainers-go/wait\"\n)\n\n// TestEnvironment manages the complete testing environment including dependencies.\ntype TestEnvironment struct {\n    VaultContainer testcontainers.Container\n    DBContainer    testcontainers.Container\n    VaultURL       string\n    DBURL          string\n    AdminToken     string\n}\n\n// SetupIntegrationTest creates a complete test environment with all dependencies.\nfunc SetupIntegrationTest(t *testing.T) *TestEnvironment {\n    ctx := context.Background()\n    \n    // TODO 1: Start PostgreSQL container for database backend testing\n    // TODO 2: Start secret management server container\n    // TODO 3: Wait for both services to be ready (health checks)\n    // TODO 4: Initialize server with test configuration\n    // TODO 5: Create admin token for test operations\n    // TODO 6: Return configured test environment\n    \n    // Use testcontainers to manage Docker containers for integration tests\n}\n\n// TestCompleteWorkflow validates end-to-end secret management operations.\nfunc TestCompleteWorkflow(t *testing.T) {\n    env := SetupIntegrationTest(t)\n    defer env.Cleanup()\n    \n    // TODO 1: Authenticate with admin token\n    // TODO 2: Create policies for different access levels\n    // TODO 3: Create application tokens with specific policies\n    // TODO 4: Store static secrets using application token\n    // TODO 5: Configure dynamic secret backend (database)\n    // TODO 6: Generate dynamic credentials\n    // TODO 7: Use dynamic credentials to connect to database\n    // TODO 8: Verify credential cleanup after lease expiration\n    \n    // Expected behavior: Complete workflow succeeds without errors\n}\n\n// TestFailoverScenario validates high availability and disaster recovery.\nfunc TestFailoverScenario(t *testing.T) {\n    env := SetupClusterEnvironment(t) // 3-node cluster\n    defer env.Cleanup()\n    \n    // TODO 1: Store secrets on primary node\n    // TODO 2: Kill primary node container\n    // TODO 3: Verify that backup node becomes leader\n    // TODO 4: Verify that secrets remain accessible through new leader\n    // TODO 5: Restart failed node and verify it rejoins cluster\n    \n    // Expected behavior: Transparent failover with minimal downtime\n}\n```\n\n**Debugging and Troubleshooting Guide:**\n\n| Test Failure Symptom | Likely Cause | Diagnostic Steps | Resolution |\n|----------------------|---------------|------------------|------------|\n| Crypto tests fail with \"invalid authentication tag\" | Wrong key used for decryption or corrupted ciphertext | Check key versioning logic, verify nonce uniqueness | Fix key lookup or nonce generation |\n| Timing tests show significant differences | Non-constant-time comparison in token validation | Profile token validation code, check for early returns | Use `subtle.ConstantTimeCompare` for all secret comparisons |\n| Integration tests timeout | Service not ready or network connectivity issues | Check container logs, verify port binding | Fix service startup or network configuration |\n| Load tests show degraded performance | Resource exhaustion or inefficient algorithms | Monitor CPU/memory usage, profile hot code paths | Optimize algorithms or increase resource limits |\n| Dynamic secret tests fail | Backend service not configured or credentials invalid | Check backend service logs, verify connection strings | Fix backend configuration or credentials |\n\nThe comprehensive testing strategy ensures that our secret management system maintains security and reliability guarantees across all operational scenarios. The combination of security-focused testing, milestone validation, and integration testing provides confidence that the system will protect secrets effectively in production environments.\n\n\n## Debugging Guide\n\n> **Milestone(s):** This section applies to all four milestones, providing diagnostic techniques and troubleshooting procedures essential for developing and maintaining a secret management system. Common implementation bugs span encrypted storage (Milestone 1), access control (Milestone 2), dynamic secrets (Milestone 3), and high availability (Milestone 4).\n\nThink of debugging a secret management system like diagnosing a security breach in a bank vault system. Just as bank security personnel have standardized procedures for investigating access failures, suspicious activities, and system malfunctions, secret management systems require systematic approaches to identify and resolve issues. The critical difference is that debugging must preserve security properties - you cannot simply \"dump all state\" to diagnose an issue if that would expose sensitive data.\n\nThe challenge of debugging secret management systems lies in the intersection of security and observability. Traditional debugging techniques like memory dumps, detailed stack traces, and verbose logging can inadvertently expose the very secrets the system is designed to protect. This creates a unique constraint where diagnostic information must be comprehensive enough to identify problems but sanitized enough to maintain security boundaries.\n\n### Common Implementation Bugs\n\nSecret management systems exhibit predictable failure patterns due to the complexity of cryptographic operations, distributed consensus, and strict security requirements. Understanding these common bugs helps developers recognize symptoms quickly and apply targeted fixes rather than spending hours debugging cryptic failures.\n\n#### Encryption and Key Management Bugs\n\nThe most frequent bugs in secret management systems involve improper handling of cryptographic keys and encryption operations. These bugs are particularly dangerous because they often appear to work correctly during testing but fail catastrophically in production or compromise security without obvious symptoms.\n\n⚠️ **Pitfall: Master Key in Memory Exposure**\nDevelopers often leave the master key in memory after encryption operations or fail to zero memory after use. This creates a window where process memory dumps or swap files can expose the master key, compromising all encrypted secrets. The master key should be cleared from memory immediately after use and never stored in garbage-collected languages without explicit zeroing.\n\n| Bug Pattern | Symptoms | Root Cause | Detection Method | Fix |\n|-------------|----------|------------|------------------|-----|\n| Uncleared master key | No immediate symptoms; discovered during security audit | Master key remains in process memory after operations | Memory scanning tools; static analysis | Implement `SecureMemory` zeroing; use defer statements |\n| Wrong key version | `DecryptSecret` fails with \"invalid key version\" | Using incorrect `DataEncryptionKey` version for decryption | Audit logs show version mismatches | Verify `GetDEKForVersion` maps versions correctly |\n| Missing key rotation | All new secrets fail encryption after rotation | Old `DataEncryptionKey` marked inactive but no new key generated | Check active DEK count in storage | Implement proper `RotateDataEncryptionKey` workflow |\n| GCM nonce reuse | Silent corruption; authentication failures | Same nonce used with same key multiple times | Cryptographic analysis; random nonce collisions | Use counter-based nonces or larger random space |\n| Weak entropy source | Predictable encryption keys | Using `math/rand` instead of `crypto/rand` | Statistical analysis of generated keys | Replace with cryptographically secure random source |\n\n⚠️ **Pitfall: Improper Secret Versioning**\nMany implementations fail to handle secret versioning correctly during key rotation. When `RotateDataEncryptionKey` is called, existing secrets must remain accessible with their original keys while new secrets use the updated key. Developers often assume all secrets use the current key, causing decryption failures for older versions.\n\n#### Authentication and Authorization Bugs\n\nAuthentication bugs in secret management systems often stem from improper token validation, timing vulnerabilities, or policy evaluation errors. These bugs are particularly critical because they can bypass the entire security model.\n\n⚠️ **Pitfall: Timing Attack Vulnerabilities**\nToken comparison operations that exit early on the first character mismatch create timing side-channels that allow attackers to brute-force valid tokens character by character. The `ValidateTokenConstantTime` function must compare the entire token regardless of where differences occur.\n\n| Bug Pattern | Symptoms | Root Cause | Detection Method | Fix |\n|-------------|----------|------------|------------------|-----|\n| Variable-time comparison | Successful token brute-force attacks | Early exit in token comparison | Timing analysis; statistical measurement | Implement constant-time comparison |\n| Token cleanup failure | Expired tokens still authenticate | Token expiration not enforced | Check token count growth over time | Add background cleanup process |\n| Policy evaluation bypass | Unauthorized access succeeds | Incorrect path matching logic | Audit failed access attempts | Fix `matchesPath` wildcard handling |\n| Session fixation | Single token works across different identities | Token not bound to specific identity | Cross-identity token usage detected | Bind tokens to identity in creation |\n| Privilege escalation | Users access restricted paths | Policy inheritance bug | Monitor policy evaluation results | Review `AuthorizeRequest` logic |\n\n⚠️ **Pitfall: Overpermissive Path Matching**\nPath patterns like `secret/*` often match more than intended due to improper wildcard handling. Developers assume `*` matches only single path segments, but implementation bugs can cause it to match multiple segments, effectively granting broader access than intended.\n\n#### Dynamic Secret Lifecycle Bugs\n\nDynamic secret systems are particularly prone to bugs related to lease management, credential cleanup, and race conditions between generation and revocation processes.\n\n⚠️ **Pitfall: Revocation Race Conditions**\nWhen a lease expires, there's often a race condition between the lease reaper marking the lease as expired and the revocation worker actually cleaning up the credentials. During this window, the credentials may still be valid in the target system even though the vault considers them revoked.\n\n| Bug Pattern | Symptoms | Root Cause | Detection Method | Fix |\n|-------------|----------|------------|------------------|-----|\n| Credential leak after expiry | Database connections persist after lease expiry | Revocation worker failing silently | Monitor active connections vs issued leases | Add revocation retry with alerts |\n| Lease reaper deadlock | No leases ever expire; memory grows unbounded | Lock ordering issue in lease processing | Thread dumps; deadlock detection | Consistent lock ordering; timeouts |\n| TTL calculation overflow | Leases never expire or expire immediately | Integer overflow in time calculations | Check extreme TTL values | Use time.Duration with bounds checking |\n| Backend connection exhaustion | New credential generation fails | Each request creates new database connection | Monitor connection pool metrics | Implement connection reuse |\n| Renewal window bug | Clients cannot renew near-expiry leases | Renewal rejected if remaining TTL too low | Audit renewal rejection logs | Adjust renewal time window logic |\n\n⚠️ **Pitfall: Failed Revocation Handling**\nMany implementations assume credential revocation always succeeds and fail to handle cases where the target system is unavailable or returns errors. Failed revocations should be retried with exponential backoff and eventually moved to a dead letter queue for manual intervention.\n\n#### High Availability and Consensus Bugs\n\nDistributed secret management systems introduce additional complexity around leader election, data replication, and split-brain prevention. These bugs often manifest as data inconsistencies or service unavailability.\n\n⚠️ **Pitfall: Split-Brain Scenarios**\nWhen network partitions occur, multiple nodes may believe they are the leader and accept write operations. This creates conflicting state that can be difficult to reconcile and may compromise security if different nodes grant different access to the same secrets.\n\n| Bug Pattern | Symptoms | Root Cause | Detection Method | Fix |\n|-------------|----------|------------|------------------|-----|\n| Multiple active leaders | Conflicting secret versions | Network partition with inadequate quorum | Monitor leadership claims across nodes | Implement strict quorum requirements |\n| Sealed state bypass | Operations succeed on sealed vault | Seal state not checked consistently | Audit operations on sealed nodes | Add seal checks to all operations |\n| Share reconstruction failure | Cannot unseal with valid shares | Corrupted shares or incorrect reconstruction | Verify share checksums | Implement share validation |\n| Auto-unseal infinite loop | Repeated unseal attempts without success | KMS provider returning inconsistent results | Monitor unseal attempt frequency | Add circuit breaker pattern |\n| Consensus timeout issues | Operations hang during cluster changes | Raft timeouts too aggressive for network | Monitor consensus operation latency | Tune timeout values for environment |\n\n### Diagnostic Techniques\n\nEffective debugging of secret management systems requires specialized techniques that maintain security boundaries while providing sufficient observability. Traditional debugging approaches must be adapted to avoid exposing sensitive data while still providing actionable information.\n\n#### Structured Logging and Audit Trails\n\nThe foundation of secret management debugging is comprehensive audit logging that captures security-relevant events without exposing secret values. Every operation should generate audit events that can be analyzed to reconstruct the sequence of events leading to a problem.\n\n**Audit Event Analysis** provides the primary diagnostic capability for secret management systems. The `AuditLogger` captures detailed information about every request, including authentication attempts, policy evaluations, and secret access patterns. Unlike traditional application logs, audit logs must be tamper-evident and cannot be disabled even during debugging.\n\n| Event Type | Required Fields | Diagnostic Value | Privacy Considerations |\n|------------|-----------------|------------------|----------------------|\n| Authentication | `Identity`, `AuthMethod`, `SourceIP`, `Result` | Identify failed login patterns | Hash sensitive identifiers |\n| Authorization | `Path`, `Operation`, `Policies`, `Result` | Debug policy evaluation failures | Log pattern matches not actual paths |\n| Secret Access | `Path`, `Version`, `Operation`, `Result` | Track secret usage patterns | Never log secret values |\n| Dynamic Secret Generation | `BackendPath`, `RoleName`, `TTL`, `LeaseID` | Debug credential lifecycle issues | Log metadata not credentials |\n| System Events | `EventType`, `NodeID`, `Duration`, `Result` | Monitor system health | Include performance metrics |\n\nThe key insight for audit-based debugging is that security events form patterns that reveal the root cause without exposing sensitive data. For example, a series of authorization failures for the same path pattern might indicate a policy misconfiguration, while authentication failures followed by successful access suggest credential compromise.\n\n**Correlation Analysis** across audit events helps identify complex issues that span multiple system components. The `RequestID` field allows tracing a single request through authentication, authorization, encryption, and storage operations. Time-based correlation can identify patterns like credential stuffing attacks or systematic enumeration attempts.\n\n#### Cryptographic Verification and Validation\n\nSecret management systems require specialized diagnostic techniques for verifying cryptographic operations without exposing key material. These techniques focus on validating algorithm properties and detecting implementation errors.\n\n**Test Vector Validation** uses known plaintext/ciphertext pairs to verify that encryption implementations produce expected results. The `CryptoTestVector` structure captures test cases from cryptographic standards that can be used to validate envelope encryption operations.\n\n```\nTest Vector Validation Process:\n1. Load standardized test vectors for AES-256-GCM operations\n2. Execute EncryptSecret with known plaintext and test vector key\n3. Compare produced ciphertext with expected test vector output\n4. Verify authentication tag matches expected value\n5. Test DecryptSecret with test vector ciphertext produces original plaintext\n6. Validate that modified ciphertext fails authentication\n```\n\n**Key Hierarchy Verification** ensures that the envelope encryption key derivation process maintains security properties. This involves verifying that data encryption keys are properly derived from the master key and that key versions are tracked correctly.\n\n| Verification Check | Method | Expected Result | Failure Indication |\n|-------------------|--------|-----------------|-------------------|\n| DEK Uniqueness | Generate multiple DEKs; compare | All different | Weak entropy or reused nonces |\n| Master Key Derivation | Derive same key with same parameters | Identical results | Implementation inconsistency |\n| Key Version Monotonicity | Check version sequence in storage | Strictly increasing | Version management bug |\n| Encryption Determinism | Encrypt same data twice with different DEKs | Different ciphertexts | Proper randomization |\n| Authentication Integrity | Modify ciphertext; attempt decryption | Decryption failure | Authentication working |\n\n#### Performance and Resource Monitoring\n\nSecret management systems exhibit specific performance characteristics that can indicate both functional and security issues. Monitoring these patterns helps identify problems before they impact service availability.\n\n**Operation Latency Analysis** reveals performance bottlenecks and potential security issues. For example, unusually long authentication times might indicate brute-force attempts, while encryption operations taking variable time could suggest timing side-channels.\n\n**Resource Utilization Patterns** help identify memory leaks, connection exhaustion, and other resource-related issues that are common in secret management systems due to the complexity of credential lifecycle management.\n\n| Metric | Normal Range | Warning Threshold | Critical Issues |\n|--------|--------------|-------------------|-----------------|\n| Authentication Latency | 10-50ms | >100ms | Timing attacks; database issues |\n| Encryption Operations/sec | 100-1000 | <10 | Key management problems |\n| Active Lease Count | Proportional to load | Unbounded growth | Revocation failures |\n| Memory Usage | Stable with spikes | Continuous growth | Key material leaks |\n| Database Connections | <connection pool size | Pool exhausted | Dynamic secret backend issues |\n\n### Symptom-Cause-Fix Reference\n\nThis reference provides quick diagnosis for common symptoms observed in secret management systems. Each entry follows the pattern of observable symptom, most likely root cause, diagnostic steps, and recommended fix.\n\n#### Authentication and Access Issues\n\n**Symptom: \"Access denied\" for valid users with correct tokens**\n\n| Aspect | Details |\n|--------|---------|\n| **Most Likely Cause** | Policy path matching failure or token expiration |\n| **Diagnostic Steps** | 1. Check audit logs for authorization events 2. Verify token validity with `GetToken` 3. Test path pattern matching manually 4. Confirm policy assignment to token |\n| **Quick Fix** | Update policy rules to include correct path patterns |\n| **Long-term Fix** | Implement policy testing framework and path validation |\n\n**Symptom: Authentication succeeds but operations immediately fail**\n\n| Aspect | Details |\n|--------|---------|\n| **Most Likely Cause** | Vault is in sealed state or cluster leadership issues |\n| **Diagnostic Steps** | 1. Check `IsSealed()` status 2. Verify cluster leader election 3. Review unseal process logs 4. Test with administrative token |\n| **Quick Fix** | Unseal vault with sufficient shares or resolve leadership |\n| **Long-term Fix** | Implement auto-unseal and monitoring for seal state |\n\n#### Encryption and Storage Failures\n\n**Symptom: \"Encryption failed\" errors for new secret creation**\n\n| Aspect | Details |\n|--------|---------|\n| **Most Likely Cause** | No active data encryption key or master key issues |\n| **Diagnostic Steps** | 1. Check active DEK count in storage 2. Verify master key accessibility 3. Test key generation manually 4. Review encryption engine logs |\n| **Quick Fix** | Generate new DEK with `GenerateDataEncryptionKey` |\n| **Long-term Fix** | Implement automatic key rotation and monitoring |\n\n**Symptom: Existing secrets become unreadable after system restart**\n\n| Aspect | Details |\n|--------|---------|\n| **Most Likely Cause** | Master key lost or DEK version mapping corrupted |\n| **Diagnostic Steps** | 1. Verify master key reconstruction from shares 2. Check DEK version consistency 3. Test decryption with known good secret 4. Review backup integrity |\n| **Quick Fix** | Restore master key from backup or re-unseal properly |\n| **Long-term Fix** | Implement master key backup verification and DEK integrity checks |\n\n#### Dynamic Secret Lifecycle Problems\n\n**Symptom: Generated credentials don't work in target system**\n\n| Aspect | Details |\n|--------|---------|\n| **Most Likely Cause** | Backend role configuration error or credential template issue |\n| **Diagnostic Steps** | 1. Test credential generation manually 2. Verify backend connectivity 3. Check role creation statements 4. Validate credential format |\n| **Quick Fix** | Update role configuration with correct statements |\n| **Long-term Fix** | Implement backend connection testing and credential validation |\n\n**Symptom: Credentials work but never get revoked after expiry**\n\n| Aspect | Details |\n|--------|---------|\n| **Most Likely Cause** | Revocation worker failure or backend connection issues |\n| **Diagnostic Steps** | 1. Check revocation queue size 2. Verify backend connectivity 3. Review revocation worker logs 4. Test manual revocation |\n| **Quick Fix** | Restart revocation workers and clear queue backlog |\n| **Long-term Fix** | Implement revocation monitoring and retry mechanisms |\n\n#### High Availability and Cluster Issues\n\n**Symptom: Operations succeed on one node but fail on others**\n\n| Aspect | Details |\n|--------|---------|\n| **Most Likely Cause** | Split-brain condition or replication lag |\n| **Diagnostic Steps** | 1. Check leadership status on all nodes 2. Verify Raft log consistency 3. Monitor replication lag 4. Test quorum requirements |\n| **Quick Fix** | Force leader re-election and wait for convergence |\n| **Long-term Fix** | Tune consensus timeouts and improve network reliability |\n\n**Symptom: Cannot unseal vault despite providing correct shares**\n\n| Aspect | Details |\n|--------|---------|\n| **Most Likely Cause** | Share corruption, wrong threshold, or reconstruction bug |\n| **Diagnostic Steps** | 1. Verify share checksums 2. Check threshold configuration 3. Test Shamir reconstruction manually 4. Review share generation logs |\n| **Quick Fix** | Regenerate shares from master key backup |\n| **Long-term Fix** | Implement share validation and backup verification |\n\n### Implementation Guidance\n\nThe debugging infrastructure for a secret management system requires careful implementation to maintain security while providing comprehensive diagnostic capabilities. This guidance provides the essential components for building effective debugging tools.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|------------------|\n| Logging | Standard log/slog with file rotation | Structured logging with ELK stack |\n| Metrics | Basic Prometheus metrics | Full observability with Grafana |\n| Tracing | HTTP request IDs | Distributed tracing with Jaeger |\n| Health Checks | Simple HTTP endpoints | Comprehensive health monitoring |\n| Debugging Tools | Built-in diagnostic commands | Remote debugging with security boundaries |\n\n#### File Structure\n\n```\ncmd/\n  vault-debug/              ← Debugging CLI tool\n    main.go\ninternal/\n  debug/                    ← Debugging infrastructure\n    audit.go                ← Audit log analysis\n    crypto.go               ← Cryptographic verification\n    health.go               ← System health monitoring\n    profiling.go            ← Performance analysis\n  monitoring/               ← Metrics and observability\n    metrics.go              ← Prometheus metrics\n    health.go               ← Health check endpoints\n  logging/                  ← Structured logging\n    audit.go                ← Audit logger implementation\n    sanitizer.go            ← Log sanitization\n```\n\n#### Audit Logger Implementation\n\n```go\n// NewAuditLogger creates tamper-evident audit logging with structured output\nfunc NewAuditLogger(filename string) (*AuditLogger, error) {\n    // TODO 1: Open log file with append mode and appropriate permissions (0600)\n    // TODO 2: Initialize sequence number from last log entry + 1\n    // TODO 3: Write startup marker with timestamp and process ID\n    // TODO 4: Set up log rotation based on size and retention policy\n    // TODO 5: Initialize mutex for thread-safe concurrent logging\n    // Hint: Use O_APPEND|O_CREATE|O_WRONLY flags for file opening\n}\n\n// LogEvent writes audit event to tamper-evident log with security sanitization\nfunc (a *AuditLogger) LogEvent(event AuditEvent) error {\n    // TODO 1: Acquire mutex lock for thread-safe operation\n    // TODO 2: Increment and assign sequence number to event\n    // TODO 3: Sanitize event data to remove sensitive information\n    // TODO 4: Marshal event to JSON with timestamp and checksum\n    // TODO 5: Write to file with immediate flush to ensure durability\n    // TODO 6: Release mutex lock\n    // Hint: Never log actual secret values, only metadata and result status\n}\n```\n\n#### Cryptographic Test Vector Validation\n\n```go\n// LoadKnownVectors loads standardized test vectors for encryption validation\nfunc LoadKnownVectors(algorithm string) ([]CryptoTestVector, error) {\n    // TODO 1: Read test vectors from embedded resources or external file\n    // TODO 2: Parse vectors based on algorithm type (AES-GCM, etc.)\n    // TODO 3: Validate vector format and required fields\n    // TODO 4: Return structured test cases for validation\n}\n\n// RunCryptographicValidation verifies encryption implementation against known vectors\nfunc RunCryptographicValidation(engine *Engine, vectors []CryptoTestVector) error {\n    for _, vector := range vectors {\n        // TODO 1: Create test DEK with vector key material\n        // TODO 2: Encrypt vector plaintext using engine\n        // TODO 3: Compare result with expected ciphertext\n        // TODO 4: Decrypt ciphertext and verify original plaintext\n        // TODO 5: Test authentication by modifying ciphertext and expecting failure\n        // Hint: Use constant-time comparison for cryptographic results\n    }\n}\n```\n\n#### Performance Monitoring and Health Checks\n\n```go\n// SystemHealth provides comprehensive health monitoring for all vault components\ntype SystemHealth struct {\n    checks       map[string]HealthCheck\n    lastResults  map[string]ComponentStatus\n    mutex        sync.RWMutex\n    checkInterval time.Duration\n}\n\n// RegisterCheck adds component health monitoring with automatic status tracking\nfunc (h *SystemHealth) RegisterCheck(check HealthCheck) {\n    // TODO 1: Add check to registry with unique name\n    // TODO 2: Initialize last result status as unknown\n    // TODO 3: Start background goroutine for periodic checking\n    // TODO 4: Set up alerting thresholds for status changes\n}\n\n// GetOverallStatus aggregates individual component status into system-wide health\nfunc (h *SystemHealth) GetOverallStatus() ComponentStatus {\n    // TODO 1: Acquire read lock for thread-safe access\n    // TODO 2: Iterate through all component statuses\n    // TODO 3: Apply aggregation rules (any unhealthy = system unhealthy)\n    // TODO 4: Return overall status with degradation level\n    // Hint: Critical components (storage, encryption) have higher weight\n}\n```\n\n#### Diagnostic Command-Line Tools\n\n```go\n// VaultDebugTool provides safe diagnostic capabilities for production systems\nfunc main() {\n    // TODO 1: Parse command-line arguments for diagnostic operation\n    // TODO 2: Connect to vault instance using administrative credentials\n    // TODO 3: Execute requested diagnostic with security boundaries\n    // TODO 4: Output sanitized results without exposing sensitive data\n    // Available commands: health, audit-analysis, key-status, lease-summary\n}\n\n// AnalyzeAuditLogs provides security-focused analysis of vault audit trails\nfunc AnalyzeAuditLogs(logPath string, timeRange TimeRange) (*AnalysisReport, error) {\n    // TODO 1: Read audit log entries within specified time range\n    // TODO 2: Parse and validate log entry integrity\n    // TODO 3: Identify patterns indicating security issues\n    // TODO 4: Generate report with actionable recommendations\n    // TODO 5: Flag potential security incidents for investigation\n    // Hint: Look for authentication failures, unusual access patterns, policy violations\n}\n```\n\n#### Milestone Checkpoints\n\n**After Milestone 1 (Encryption Engine):**\n- Run `go test ./internal/debug/crypto.go` to verify cryptographic test vectors pass\n- Execute `vault-debug key-status` to confirm DEK rotation works correctly\n- Check audit logs contain encryption operation events without secret values\n\n**After Milestone 2 (Authentication):**\n- Test `vault-debug auth-analysis` to identify authentication patterns\n- Verify constant-time token comparison with timing analysis tools\n- Confirm policy evaluation audit events capture authorization decisions\n\n**After Milestone 3 (Dynamic Secrets):**\n- Monitor lease metrics to ensure revocation processes work correctly\n- Use `vault-debug lease-summary` to verify lease lifecycle tracking\n- Test credential cleanup with backend connectivity failures\n\n**After Milestone 4 (High Availability):**\n- Validate cluster health monitoring across all nodes\n- Test split-brain detection and prevention mechanisms\n- Verify auto-unseal monitoring and failure alerting works correctly\n\n#### Common Debugging Scenarios\n\n**Scenario: Memory Usage Growing Unboundedly**\n1. Use `pprof` to capture heap profiles during operation\n2. Check for unreleased cryptographic key material in memory\n3. Verify lease cleanup processes are running correctly\n4. Look for goroutine leaks in background workers\n\n**Scenario: Authentication Latency Spikes**\n1. Enable detailed timing logs for authentication operations\n2. Check database connection pool utilization\n3. Monitor for brute-force attack patterns in audit logs\n4. Verify constant-time operations aren't introducing delays\n\n**Scenario: Cluster Consensus Failures**\n1. Check network connectivity between cluster nodes\n2. Verify Raft log consistency across all nodes\n3. Monitor leadership election frequency and causes\n4. Test quorum requirements under various failure scenarios\n\nThe debugging infrastructure must balance comprehensive observability with strict security requirements, ensuring that diagnostic capabilities never compromise the secrets they're designed to protect.\n\n\n## Future Extensions\n\n> **Milestone(s):** This section applies to the completed system after all four milestones, providing guidance for scaling and extending the secret management system beyond the core implementation.\n\nBuilding a secret management system is like constructing a skyscraper foundation — the initial structure must be robust enough to support future expansion, but you can't anticipate every possible addition. After implementing the core secret management capabilities across all four milestones, organizations typically discover new requirements that push the system's boundaries. This section explores strategic extensions that maintain the security model while addressing enterprise scalability, operational complexity, and evolving infrastructure needs.\n\nThe extensions fall into three categories that address different growth pressures. **Scalability improvements** handle increased load and geographic distribution. **Additional secret backends** support new infrastructure components and security requirements. **Enterprise features** address organizational complexity with multi-tenancy, compliance reporting, and sophisticated authentication methods. Each extension builds on the solid foundation established in the core milestones while introducing new architectural challenges.\n\n### Scalability Improvements\n\nThink of scaling a secret management system like expanding a secure bank vault operation from a single location to a global network. The core security principles remain unchanged, but you need new mechanisms for coordination, caching, and performance optimization. Unlike typical web applications where eventual consistency is acceptable, secret management requires strong consistency for security policies while optimizing for read-heavy workloads.\n\n#### Horizontal Scaling Architecture\n\nThe current system uses a single-leader Raft cluster that handles both reads and writes on the leader node. This creates a performance bottleneck as organizations grow to thousands of applications requesting secrets. **Read replicas** provide the first scaling improvement by allowing read operations against follower nodes while maintaining consistency guarantees.\n\n> **Decision: Read-Only Replica Architecture**\n> - **Context**: The Raft leader becomes overwhelmed by read requests while writes remain low volume\n> - **Options Considered**: Read replicas, read-through caching, client-side caching\n> - **Decision**: Implement read replicas with linearizable read guarantees\n> - **Rationale**: Maintains strong consistency while distributing read load across multiple nodes\n> - **Consequences**: Enables horizontal read scaling but requires careful lease token validation\n\nRead replicas must handle several consistency challenges that don't exist in typical databases. **Token validation** requires checking that tokens haven't been revoked, which means replicas need up-to-date token state. **Policy evaluation** must use current policies, not stale versions that might grant excessive access. The solution involves a **token validation cache** with short TTLs and a **policy version vector** that tracks policy updates across replicas.\n\n| Component | Purpose | Consistency Model | Cache TTL |\n|-----------|---------|-------------------|-----------|\n| Token Validation Cache | Verify token existence and expiration | Eventually consistent with invalidation | 30 seconds |\n| Policy Version Vector | Track policy updates across replicas | Strongly consistent | N/A |\n| Secret Content Cache | Cache encrypted secret data | Read-your-writes consistent | 5 minutes |\n| Lease Index Cache | Track active leases for validation | Eventually consistent | 1 minute |\n\n#### Geographic Distribution\n\nOrganizations with global infrastructure need secret management systems that provide low latency across regions while maintaining security guarantees. **Regional clusters** create independent Raft clusters in each geographic region, connected through **cross-region replication** for disaster recovery and policy synchronization.\n\nThe challenge is determining what data requires global consistency versus regional autonomy. **Security policies** must be globally consistent to prevent privilege escalation through region-shopping. **Audit logs** require global aggregation for compliance reporting. However, **secret content** can be region-specific, and **dynamic secrets** can be generated locally to minimize latency.\n\n| Data Type | Replication Strategy | Consistency Level | Cross-Region Sync |\n|-----------|---------------------|-------------------|------------------|\n| Security Policies | Synchronous multi-region | Strong consistency | Real-time |\n| Master Keys | Manual key ceremony | No replication | Offline process |\n| Secret Content | Regional with backup | Regional consistency | Encrypted backup |\n| Audit Logs | Asynchronous aggregation | Eventually consistent | Batched |\n| Dynamic Leases | Regional generation | Regional consistency | Metadata only |\n\n**Cross-region authentication** requires special handling because tokens issued in one region must be validated globally. The solution involves **token attestation** where each region cryptographically signs token metadata, allowing other regions to validate tokens without direct communication.\n\n#### Performance Optimization\n\nAs secret request volume grows, several optimization techniques become necessary. **Connection pooling** reduces the overhead of TLS handshakes for client connections. **Bulk operations** allow applications to request multiple secrets in a single API call. **Compression** reduces network overhead for large policy documents and audit logs.\n\nThe most impactful optimization is **intelligent caching** at multiple layers. **Client-side caching** with short TTLs reduces server load while maintaining security. **Server-side caching** optimizes expensive operations like policy evaluation and encryption key retrieval. **Negative caching** prevents repeated requests for non-existent secrets.\n\n> **Critical Insight**: Unlike web application caching, secret management caching must be **security-first**. A cache miss is preferable to serving stale data that might grant unauthorized access. All caches must include cryptographic checksums and expiration enforcement.\n\n| Cache Layer | Cache Duration | Security Control | Invalidation Method |\n|-------------|----------------|------------------|-------------------|\n| Client Secret Cache | 5 minutes | Client-enforced TTL | TTL expiration only |\n| Client Policy Cache | 1 minute | Checksum validation | Server push invalidation |\n| Server Query Cache | 30 seconds | Encrypted cache keys | Write-through invalidation |\n| Encryption Key Cache | 1 hour | Hardware security module | Key rotation invalidation |\n\n⚠️ **Pitfall: Cache Coherence Attacks**\nAttackers may attempt to exploit cache inconsistencies to access secrets using revoked tokens. Always validate tokens against authoritative sources for write operations, even if caches indicate the token is valid. Implement cache invalidation patterns that err on the side of denying access.\n\n### Additional Secret Backends\n\nThe dynamic secret engine provides extensibility for new credential types beyond the basic database backend implemented in Milestone 3. Think of secret backends like specialized vending machines — each one understands how to generate, manage, and revoke a specific type of credential while following the same lease-based lifecycle.\n\n#### Cloud Provider Integration\n\nModern applications increasingly rely on cloud services that require API credentials with fine-grained permissions. **Cloud provider backends** generate time-limited IAM credentials that applications can use to access cloud resources without storing long-lived access keys.\n\n**AWS IAM backend** integration requires several components. The secret management system needs an **IAM service account** with permissions to create and delete temporary credentials. **Role assumption** allows generating credentials for specific AWS roles based on the requesting application's identity. **Policy templates** define the permissions granted to generated credentials.\n\n| AWS Backend Component | Purpose | Configuration | Security Model |\n|----------------------|---------|---------------|----------------|\n| Service Account | Bootstrap credentials for AWS API | Static long-lived key | Rotated monthly |\n| Role Templates | Define assumable roles per application | JSON policy documents | Version controlled |\n| Session Manager | Track and revoke active sessions | In-memory session cache | Automatic cleanup |\n| Permission Mapper | Map vault policies to AWS permissions | Path-based mapping rules | Least privilege |\n\nThe **Azure Active Directory backend** follows similar patterns but uses **service principal** credentials and **OAuth 2.0 flows**. **Google Cloud IAM backend** uses **service account key generation** with **workload identity federation** for enhanced security.\n\n⚠️ **Pitfall: Cloud Credential Sprawl**\nWithout proper lifecycle management, cloud backends can create thousands of orphaned credentials that never get revoked. Implement aggressive cleanup policies and monitor cloud provider APIs for credential usage patterns.\n\n#### PKI and Certificate Management\n\nApplications increasingly require **X.509 certificates** for mutual TLS authentication, code signing, and service mesh communication. A **PKI backend** transforms the secret management system into a **certificate authority** that can issue, renew, and revoke certificates based on requesting application identity.\n\nThe PKI backend requires careful **root certificate management**. The **root CA private key** must be stored separately from the secret management system, potentially in **hardware security modules**. **Intermediate CA certificates** can be stored within the system and used for day-to-day certificate issuance.\n\n| Certificate Type | Issuing Authority | Validity Period | Use Case |\n|------------------|------------------|-----------------|----------|\n| Service Certificates | Intermediate CA | 24 hours | Service-to-service mTLS |\n| Client Certificates | Intermediate CA | 7 days | Application authentication |\n| Code Signing | Dedicated signing CA | 1 hour | Container image signing |\n| Web Certificates | Public CA integration | 90 days | External web services |\n\n**Certificate revocation** requires maintaining **Certificate Revocation Lists (CRLs)** or implementing **Online Certificate Status Protocol (OCSP)** responders. The revocation system must coordinate with the lease management system to ensure certificates are revoked when their associated leases expire.\n\n#### SSH Certificate Authority\n\n**SSH certificate authentication** provides an alternative to managing SSH keys across large server fleets. The **SSH CA backend** generates **user certificates** and **host certificates** that are trusted by SSH servers without requiring key distribution.\n\n**User certificates** contain the requesting user's identity and authorized commands. **Host certificates** prove server identity and prevent man-in-the-middle attacks. Both certificate types include **principals** that define what users or hosts the certificate represents.\n\n| SSH Certificate Component | Purpose | Source | Validation |\n|---------------------------|---------|--------|------------|\n| Certificate Public Key | Identity being certified | Generated per request | Cryptographic signature |\n| Principals List | Authorized identities | Policy-driven mapping | Path-based rules |\n| Critical Options | Restrictions on usage | Backend configuration | Force-commands, source IP |\n| Extensions | Additional permissions | Default template | Agent forwarding, X11 |\n\n### Enterprise Features\n\nEnterprise environments introduce organizational complexity that requires additional security and operational capabilities. Think of enterprise features like upgrading from a personal safe to a bank vault system — you need compartmentalization, audit trails, and administrative controls that weren't necessary for simpler use cases.\n\n#### Multi-Tenancy Implementation\n\n**Multi-tenancy** allows multiple organizations or business units to share the same secret management infrastructure while maintaining complete isolation. Each **tenant** operates as if they have a dedicated system, with separate encryption keys, policies, and audit logs.\n\nThe **tenant isolation model** uses **path-based segregation** where each tenant's secrets exist under a unique path prefix. **Encryption isolation** ensures tenants use separate data encryption keys, preventing cross-tenant data access even if path-based isolation fails. **Policy isolation** prevents tenants from accessing each other's policies or creating policies that affect other tenants.\n\n| Isolation Layer | Implementation | Security Guarantee | Failure Impact |\n|----------------|----------------|-------------------|----------------|\n| Path Isolation | URL prefix enforcement | Prevents cross-tenant path access | Single tenant affected |\n| Encryption Isolation | Tenant-specific DEKs | Cryptographic separation | No cross-tenant data leakage |\n| Policy Isolation | Tenant namespace scoping | Administrative separation | No privilege escalation |\n| Audit Isolation | Separate log streams | Compliance separation | No information disclosure |\n\n**Tenant management** requires administrative APIs for creating tenants, configuring tenant-specific policies, and managing tenant lifecycles. **Tenant authentication** can integrate with existing **identity providers** using **SAML** or **OpenID Connect** federation.\n\n> **Decision: Tenant Isolation Model**\n> - **Context**: Need to support multiple organizations with different security requirements\n> - **Options Considered**: Path-based isolation, separate clusters per tenant, virtualized instances\n> - **Decision**: Combine path-based isolation with encryption key separation\n> - **Rationale**: Provides strong security guarantees while maintaining operational efficiency\n> - **Consequences**: Requires careful policy engine design to prevent tenant boundary violations\n\n#### Compliance and Reporting\n\nEnterprise environments must demonstrate compliance with regulations like **SOX**, **PCI DSS**, **HIPAA**, and **GDPR**. **Compliance reporting** transforms raw audit logs into structured reports that demonstrate security controls and data handling practices.\n\n**Audit log enrichment** adds contextual information to basic access logs. **User identity resolution** maps authentication tokens back to human users for accountability. **Data classification** tags secrets with sensitivity levels and tracks access patterns. **Retention policies** ensure audit logs are preserved for required periods while respecting data minimization requirements.\n\n| Compliance Requirement | Implementation | Data Collected | Report Format |\n|------------------------|----------------|----------------|---------------|\n| Access Tracking | Enhanced audit logs | User, resource, time, result | JSON with schema validation |\n| Data Retention | Automated log archival | All secret operations | Tamper-evident storage |\n| Change Management | Policy versioning | All configuration changes | Diff-based reports |\n| Incident Response | Security event correlation | Failed access patterns | Real-time alerting |\n\n**Compliance dashboards** provide real-time visibility into security posture. **Anomaly detection** identifies unusual access patterns that might indicate compromise. **Automated reporting** generates periodic compliance summaries without manual intervention.\n\n#### Advanced Authentication Methods\n\nEnterprise environments often require **federation** with existing identity systems and **risk-based authentication** that adapts security requirements based on request context. **SAML integration** allows using enterprise identity providers for authentication. **OpenID Connect** provides more modern federation capabilities with **JSON Web Token** based identity assertion.\n\n**Risk-based authentication** evaluates request context to determine required authentication strength. **Device fingerprinting** tracks client characteristics to detect unusual access patterns. **Geolocation analysis** flags access attempts from unexpected locations. **Behavioral analysis** learns normal access patterns and detects deviations.\n\n| Authentication Factor | Risk Level | Additional Requirements | Use Case |\n|----------------------|------------|------------------------|----------|\n| API Token | Low | None | Automated applications |\n| mTLS Certificate | Medium | Certificate validation | Service authentication |\n| SAML Assertion | Medium | Identity provider verification | Human users |\n| MFA + Biometrics | High | Multi-factor verification | Administrative access |\n\n**Adaptive policies** adjust security requirements based on calculated risk scores. **Step-up authentication** prompts for additional verification when accessing high-value secrets. **Session management** tracks authentication sessions and enforces re-authentication for sensitive operations.\n\n⚠️ **Pitfall: Authentication Bypass**\nComplex authentication flows create opportunities for bypass attacks. Always validate that required authentication factors were actually verified, not just claimed. Implement defense in depth with multiple validation layers.\n\n### Implementation Guidance\n\nThe scalability and enterprise features described in this section represent significant extensions to the core secret management system. Each extension should be approached incrementally, with careful attention to maintaining the security model established in the core milestones.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Read Replicas | HTTP proxy with Raft follower reads | Custom replication protocol with consistency guarantees |\n| Cross-Region Sync | Database replication with encryption | Custom consensus protocol with conflict resolution |\n| PKI Backend | Go crypto/x509 with file-based CA | Hardware Security Module integration |\n| Multi-Tenancy | Path prefix enforcement | Container-based isolation with separate processes |\n| Compliance Reporting | Structured JSON logs with external analysis | Real-time stream processing with compliance dashboard |\n\n#### File Structure Extensions\n\nThe extension features require new modules that integrate with the existing codebase:\n\n```\ninternal/\n  scaling/\n    replicas/          ← read replica management\n      replica_manager.go\n      consistency_checker.go\n    caching/           ← multi-layer caching\n      client_cache.go\n      server_cache.go\n    geographic/        ← cross-region support\n      region_manager.go\n      cross_region_sync.go\n      \n  backends/\n    cloud/             ← cloud provider backends\n      aws_iam.go\n      azure_ad.go\n      gcp_iam.go\n    pki/               ← certificate authority\n      ca_manager.go\n      cert_issuer.go\n    ssh/               ← SSH certificate authority\n      ssh_ca.go\n      user_certs.go\n      \n  enterprise/\n    tenancy/           ← multi-tenant support\n      tenant_manager.go\n      isolation_enforcer.go\n    compliance/        ← compliance reporting\n      audit_enricher.go\n      report_generator.go\n    federation/        ← advanced authentication\n      saml_handler.go\n      risk_analyzer.go\n```\n\n#### Scaling Infrastructure Starter Code\n\n```go\n// ReplicaManager handles read-only replicas for horizontal scaling\ntype ReplicaManager struct {\n    replicas    map[string]*ReplicaNode\n    healthCheck *ReplicaHealthChecker\n    loadBalancer *ReadLoadBalancer\n    consistency *ConsistencyChecker\n}\n\n// ReplicaNode represents a read-only follower\ntype ReplicaNode struct {\n    NodeID      string\n    Endpoint    string\n    LastContact time.Time\n    IsHealthy   bool\n    ReadLoad    int64\n}\n\n// RouteReadRequest distributes read requests across healthy replicas\nfunc (rm *ReplicaManager) RouteReadRequest(ctx context.Context, req *ReadRequest) (*ReadResponse, error) {\n    // TODO 1: Check if request requires strong consistency (recent writes)\n    // TODO 2: Select healthy replica with lowest load\n    // TODO 3: Validate replica has required policy/token state\n    // TODO 4: Execute read request with consistency checks\n    // TODO 5: Update replica health and load metrics\n}\n\n// ConsistencyChecker ensures read replicas have current security state\ntype ConsistencyChecker struct {\n    tokenVersions  map[string]int64  // Track token state versions\n    policyVersions map[string]int64  // Track policy state versions\n    maxStaleness   time.Duration     // Maximum acceptable staleness\n}\n\n// ValidateReplicaConsistency checks if replica can safely serve read\nfunc (cc *ConsistencyChecker) ValidateReplicaConsistency(ctx context.Context, replica *ReplicaNode, req *ReadRequest) error {\n    // TODO 1: Check token version on replica vs leader\n    // TODO 2: Check policy version for requested path\n    // TODO 3: Verify staleness within acceptable bounds\n    // TODO 4: Return error if replica too stale for security\n}\n```\n\n#### Cloud Backend Skeleton\n\n```go\n// AWSIAMBackend generates temporary AWS credentials\ntype AWSIAMBackend struct {\n    client     *iam.IAM\n    sts        *sts.STS\n    rolePrefix string\n    accountID  string\n    templates  map[string]*IAMRoleTemplate\n}\n\n// IAMRoleTemplate defines AWS role configuration for secret generation\ntype IAMRoleTemplate struct {\n    RoleName        string\n    PolicyDocument  string\n    SessionDuration time.Duration\n    ExternalID      string\n    TrustPolicy     string\n}\n\n// GenerateCredentials creates temporary AWS credentials for application\nfunc (aws *AWSIAMBackend) GenerateCredentials(ctx context.Context, roleName string, ttl time.Duration) (map[string]interface{}, map[string]interface{}, error) {\n    // TODO 1: Look up role template for requested role\n    // TODO 2: Assume role with STS to get temporary credentials\n    // TODO 3: Return credentials in standard format\n    // TODO 4: Return revocation data (session info for cleanup)\n}\n\n// RevokeCredentials removes AWS session and credentials\nfunc (aws *AWSIAMBackend) RevokeCredentials(ctx context.Context, revocationData map[string]interface{}) error {\n    // TODO 1: Extract session info from revocation data\n    // TODO 2: Call STS to invalidate session\n    // TODO 3: Handle case where session already expired\n}\n```\n\n#### Multi-Tenancy Core Logic\n\n```go\n// TenantManager enforces isolation between organizational tenants\ntype TenantManager struct {\n    tenants       map[string]*TenantConfig\n    pathEnforcer  *PathIsolationEnforcer\n    keyManager    *TenantKeyManager\n    auditSplitter *TenantAuditSplitter\n}\n\n// TenantConfig defines tenant isolation parameters\ntype TenantConfig struct {\n    TenantID        string\n    PathPrefix      string\n    EncryptionKeyID string\n    PolicyNamespace string\n    AuditStreamID   string\n    CreatedAt       time.Time\n    AdminContacts   []string\n}\n\n// EnforceTenantIsolation validates request stays within tenant boundaries\nfunc (tm *TenantManager) EnforceTenantIsolation(ctx context.Context, tenantID string, requestPath string, operation string) error {\n    // TODO 1: Look up tenant configuration\n    // TODO 2: Verify request path starts with tenant prefix\n    // TODO 3: Check operation is allowed for tenant\n    // TODO 4: Log tenant boundary enforcement in audit\n}\n\n// GetTenantEncryptionKey returns tenant-specific DEK\nfunc (tm *TenantManager) GetTenantEncryptionKey(ctx context.Context, tenantID string, keyVersion int) ([]byte, error) {\n    // TODO 1: Validate tenant ID and key version\n    // TODO 2: Retrieve tenant-specific master key\n    // TODO 3: Decrypt and return tenant DEK\n    // TODO 4: Ensure cross-tenant key isolation\n}\n```\n\n#### Milestone Checkpoints\n\nAfter implementing scaling extensions:\n- **Performance Test**: Verify read replicas handle 10x read load increase with < 100ms latency\n- **Consistency Test**: Confirm security policy changes propagate to replicas within 1 second\n- **Geographic Test**: Validate cross-region secret replication with encrypted transport\n\nAfter implementing cloud backends:\n- **AWS Integration**: Generate and revoke AWS IAM credentials successfully\n- **Certificate Generation**: Issue and validate X.509 certificates for mTLS\n- **SSH Access**: Authenticate to test servers using generated SSH certificates\n\nAfter implementing enterprise features:\n- **Tenant Isolation**: Verify tenant A cannot access tenant B's secrets under any conditions\n- **Compliance Export**: Generate compliance report covering all audit requirements\n- **Federation Test**: Authenticate users through SAML and validate policy enforcement\n\n#### Common Implementation Challenges\n\n⚠️ **Scaling Challenge: Cache Invalidation Races**\nWhen policies change, cache invalidation messages may arrive out of order, causing replicas to temporarily allow unauthorized access. Implement version vectors that ensure caches never regress to older policy versions.\n\n⚠️ **Backend Challenge: Credential Cleanup Failures**\nCloud providers may be temporarily unavailable during credential revocation, leaving orphaned credentials. Implement exponential backoff retry with dead letter queues for failed revocations that require manual cleanup.\n\n⚠️ **Enterprise Challenge: Tenant Boundary Violations**\nComplex policy rules may inadvertently allow cross-tenant access. Implement mandatory tenant ID validation at the storage layer as a final enforcement mechanism, regardless of policy evaluation results.\n\nThe extensions described in this section transform the basic secret management system into an enterprise-grade platform capable of supporting large-scale, globally distributed infrastructure. Each extension maintains the core security principles while addressing real-world operational requirements that emerge as organizations scale their secret management practices.\n\n\n## Glossary\n\n> **Milestone(s):** This section provides essential terminology and definitions that apply across all four milestones, serving as a reference for understanding the complex concepts, architectural patterns, and security mechanisms implemented throughout the secret management system.\n\nThe secret management domain combines cryptography, distributed systems, authentication protocols, and security engineering concepts that may be unfamiliar to developers new to this space. This glossary provides precise definitions for technical terms, explains domain-specific concepts with clear examples, and clarifies the specific meaning of terms within the context of our secret management system.\n\nThink of this glossary as a technical dictionary that transforms abstract security concepts into concrete understanding. Just as a foreign language dictionary helps you understand individual words before reading literature, this glossary helps you understand individual concepts before diving into system implementation. Each definition includes not just what something is, but why it matters and how it fits into the larger security architecture.\n\n### Core Security Concepts\n\nThe foundation of any secret management system rests on fundamental security principles that guide every design decision. These concepts form the mental framework for understanding why the system is built the way it is.\n\n| Term | Definition | Example/Context |\n|------|------------|-----------------|\n| **Zero-trust system** | Security model requiring authentication and authorization for every request, assuming no inherent trust based on network location or previous access | Our secret management system validates every API request with a token, even from internal services |\n| **Defense in depth** | Multiple security layers protecting against various attack vectors, ensuring that compromise of one layer doesn't compromise the entire system | Combines envelope encryption, access policies, audit logging, and network TLS |\n| **Assume breach** | Security principle of designing for compromised components, building systems that remain secure even when individual parts are attacked | Dynamic secrets expire automatically even if the credential database is compromised |\n| **Blast radius containment** | Limiting impact of compromise to specific subset of credentials or operations | Each tenant's secrets encrypted with different keys; compromise affects only that tenant |\n| **Secret sprawl** | Scattered secrets across infrastructure creating security vulnerabilities through inconsistent storage, access control, and rotation practices | Database passwords hardcoded in config files across hundreds of microservices |\n| **System charter** | Contract defining system scope and limitations, establishing what the system will and will not do | Our system manages application secrets but explicitly excludes user passwords and PKI certificates |\n\n### Cryptographic Concepts\n\nSecret management systems rely heavily on cryptographic primitives and patterns. Understanding these concepts is essential for implementing secure storage and key management.\n\n| Term | Definition | Example/Context |\n|------|------------|-----------------|\n| **Envelope encryption** | Multi-layer encryption with master key protecting data keys, enabling key rotation without re-encrypting all data | Master key encrypts DEKs, DEKs encrypt individual secrets; rotate DEK without touching master key |\n| **Nested safe system** | Mental model for envelope encryption with multiple security layers, like safes within safes | Bank vault (master key) contains safety deposit boxes (DEKs) containing valuables (secrets) |\n| **Data encryption keys** | DEKs that actually encrypt secrets, protected by master key, enabling efficient key rotation and access control | Each secret encrypted with unique DEK; compromise of one DEK affects only that secret |\n| **Key rotation isolation** | Ability to rotate keys independently without affecting other keys or requiring system downtime | Rotate DEK for tenant A without affecting tenant B's secrets or requiring system restart |\n| **Version immutability** | Principle that secret versions cannot be changed once created, ensuring audit trail and preventing tampering | Secret version 3 remains unchanged even when version 4 is created; enables rollback and compliance |\n| **Lazy re-encryption** | Background process to migrate old versions to new keys without blocking operations | Old secret versions gradually re-encrypted with new DEK during normal access patterns |\n| **Constant-time comparison** | Cryptographic comparison that takes same time regardless of input to prevent timing attacks | Token validation uses constant-time comparison to prevent attackers from guessing tokens |\n\n### Authentication and Authorization\n\nAccess control in secret management systems requires sophisticated identity and permission models that can scale across different authentication methods and organizational structures.\n\n| Term | Definition | Example/Context |\n|------|------------|-----------------|\n| **Bearer token authentication** | Authentication method using cryptographically signed tokens carried in HTTP headers | `X-Vault-Token: hvs.CAESIF...` header authenticates API requests |\n| **Corporate badge system** | Mental model for token-based access control, where tokens work like employee badges granting building access | Token contains policies like badge contains access levels; both can be revoked centrally |\n| **Path-based access control** | ACL system using hierarchical paths with wildcard patterns to grant fine-grained permissions | Policy allows `secret/app-*/database/*` but denies `secret/app-*/api-keys/*` |\n| **Wildcard pattern matching** | Flexible path matching using * for single segments and ** for recursive matching | `secret/*/database` matches `secret/app1/database` but not `secret/app1/cache/database` |\n| **Default deny** | Security model where access is denied unless explicitly allowed by policy | User can only access paths explicitly granted in their token's policies |\n| **Policy inheritance** | Mechanism where identities inherit policies from groups and roles | User inherits developer group policies plus individual role-specific policies |\n| **Tamper-evident logging** | Audit logging designed to detect modification or deletion of log entries | Each audit entry includes hash of previous entry; broken chain indicates tampering |\n| **Mutual TLS authentication** | Bidirectional certificate-based authentication between client and server | Both client and server present certificates; validates identity cryptographically |\n\n### Dynamic Secret Management\n\nDynamic secrets represent a paradigm shift from static credentials to just-in-time credential generation with automatic lifecycle management.\n\n| Term | Definition | Example/Context |\n|------|------------|-----------------|\n| **Credential vending machine** | System that generates fresh credentials on demand rather than storing pre-created credentials | Request database access, receive unique username/password valid for 1 hour |\n| **Dynamic secrets** | Short-lived credentials generated on demand with automatic expiration and cleanup | Database credentials created when requested, automatically deleted after TTL expires |\n| **Just-in-time generation** | Creating credentials only when requested not stored in advance | No pre-created database users; new user created for each credential request |\n| **Lease-based tracking** | Time-limited credential lifecycle management with explicit expiration and renewal capabilities | Each credential has lease ID, expiration time, and renewal count |\n| **Automatic cleanup** | System responsibility for revoking credentials when leases expire without requiring manual intervention | Expired database users automatically dropped from database by revocation engine |\n| **Backend plugin** | Service-specific implementation of credential generation and management for different systems | PostgreSQL backend knows how to CREATE USER, AWS backend knows IAM API calls |\n| **Revocation engine** | Cleanup system that removes expired credentials from target systems using service-specific protocols | Executes DROP USER for database credentials, DeleteAccessKey for AWS credentials |\n| **Lease reaper** | Background process that finds and processes expired leases on configurable intervals | Runs every 30 seconds, finds leases expired in last batch, queues for revocation |\n| **Exponential backoff** | Retry strategy with increasing delays between attempts to handle temporary failures gracefully | First retry after 1s, then 2s, 4s, 8s, up to maximum delay |\n| **Dead letter queue** | Storage for revocation requests that failed maximum retry attempts requiring manual intervention | Failed AWS credential deletions stored for operator review and manual cleanup |\n| **Priority revocation** | Expedited credential cleanup for security incidents bypassing normal revocation queues | Compromised service account credentials revoked immediately, not queued |\n\n### Distributed Systems and High Availability\n\nSecret management systems must remain available and consistent across multiple nodes while handling network partitions and node failures gracefully.\n\n| Term | Definition | Example/Context |\n|------|------------|-----------------|\n| **Shamir's secret sharing** | Cryptographic threshold scheme splitting secrets into shares requiring minimum number to reconstruct | Master key split into 5 shares, requiring any 3 to reconstruct and unseal system |\n| **Threshold scheme** | Requires minimum number of shares to reconstruct secret, providing security against partial compromise | 3-of-5 threshold means compromise of 2 shares doesn't compromise master key |\n| **Polynomial interpolation** | Mathematical technique for reconstructing polynomial from points used in Shamir's secret sharing | Secret encoded as y-intercept of polynomial; shares are points used for reconstruction |\n| **Sealed state** | Secure mode where master key absent and operations blocked until sufficient shares provided | Server starts sealed; all secret operations return 503 until unsealing completes |\n| **Unsealing** | Process of reconstructing master key and enabling operations by collecting threshold shares | Operators provide 3 of 5 key shares; system reconstructs master key and enables operations |\n| **Leader election** | Distributed consensus process selecting single coordinator node to prevent split-brain scenarios | Raft algorithm ensures exactly one node accepts writes; others forward to leader |\n| **Raft consensus** | Algorithm ensuring strong consistency across cluster nodes using leader-follower replication | Leader accepts writes, replicates to majority before committing; handles leader failure |\n| **Auto-unseal** | Automated unsealing using external key management service instead of manual share collection | AWS KMS encrypts master key; system auto-unseals using KMS on startup |\n| **Key encryption key** | External key used to encrypt/decrypt the master key in auto-unseal configurations | AWS KMS key encrypts vault master key; stored encrypted master key in configuration |\n| **Split-brain scenarios** | Dangerous state where multiple nodes accept conflicting writes due to network partition | Two data centers lose connectivity; both elect leaders and accept conflicting secret updates |\n\n### Request Processing and Error Handling\n\nProcessing secret management requests requires sophisticated pipeline architecture with comprehensive error handling and graceful degradation capabilities.\n\n| Term | Definition | Example/Context |\n|------|------------|-----------------|\n| **Request processing pipeline** | Multi-stage request validation, authentication, and authorization flow with audit logging | Parse → Authenticate → Authorize → Execute → Audit → Response |\n| **Circuit breaker** | Pattern preventing cascading failures by stopping requests to failed services | Stop sending lease revocations to failed database after 5 consecutive failures |\n| **Audit event generation** | Comprehensive logging of security-relevant operations for compliance and forensics | Every secret access logged with identity, timestamp, result, and request details |\n| **Graceful degradation** | Reducing functionality while maintaining core security guarantees during failures | Database backend failure disables dynamic secrets but static secrets remain available |\n| **Read-only mode** | Degraded operational state allowing secret retrieval but blocking write operations | Storage failure triggers read-only mode; secrets accessible but new secrets rejected |\n| **Disaster recovery** | Procedures for restoring service after catastrophic failures using backups and redundancy | Restore from encrypted backup when primary cluster completely destroyed |\n| **Emergency security procedures** | Final defense mechanisms when normal security controls may be insufficient | Emergency seal command immediately blocks all operations and clears memory |\n| **Fail-safe approach** | Prioritizing data integrity over availability during ambiguous failure conditions | Unknown error during secret write results in failure rather than potential corruption |\n| **Backup separation** | Storing encrypted data and decryption keys using different systems and procedures | Encrypted secrets backed up to S3; key shares stored in different security deposit boxes |\n\n### Testing and Security Validation\n\nSecret management systems require specialized testing approaches to validate both functional correctness and security properties under various conditions.\n\n| Term | Definition | Example/Context |\n|------|------------|-----------------|\n| **Timing side-channel** | Information leakage through execution time differences revealing secret information | Token validation time varies by input length, allowing attackers to guess valid tokens |\n| **Property-based testing** | Testing approach using randomized inputs to verify algorithmic properties hold universally | Test that encrypt(decrypt(x)) == x for thousands of random inputs |\n| **Penetration testing** | Security testing simulating real-world attack scenarios against deployed systems | Attempt privilege escalation, token theft, timing attacks against running system |\n| **Chaos testing** | Testing system behavior under random failure conditions to validate resilience | Randomly kill nodes, corrupt network packets, fill disk space during operations |\n| **Load testing** | Performance testing under realistic traffic patterns to validate scalability | 1000 concurrent clients requesting dynamic secrets every second for 10 minutes |\n| **Integration testing** | Testing complete workflows across all system components end-to-end | Create secret, generate policy, authenticate user, retrieve secret, verify audit log |\n\n### Scalability and Enterprise Features\n\nProduction secret management systems must handle enterprise-scale requirements including multi-tenancy, geographic distribution, and regulatory compliance.\n\n| Term | Definition | Example/Context |\n|------|------------|-----------------|\n| **Read replicas** | Follower nodes handling read-only requests for scaling without compromising consistency | Secret reads distributed across 3 replicas; writes processed by single leader |\n| **Geographic distribution** | Regional clusters with cross-region replication for disaster recovery and latency | Primary cluster in us-east-1; replica cluster in eu-west-1 for European customers |\n| **Multi-tenancy** | Organizational isolation within shared infrastructure using cryptographic and path separation | Each customer's secrets encrypted with tenant-specific keys and isolated paths |\n| **Compliance reporting** | Structured audit reports for regulatory requirements like SOX, GDPR, HIPAA | Monthly access reports showing who accessed which secrets when for audit review |\n| **Federation** | Integration with external identity providers for authentication and authorization | Authenticate users against corporate Active Directory; map AD groups to vault policies |\n| **Risk-based authentication** | Adaptive security based on request context like location, time, device, behavior | Unusual access patterns trigger additional authentication challenges |\n| **Tenant isolation** | Cryptographic and administrative separation between organizations sharing infrastructure | Customer A cannot access customer B's secrets even with system administrator privileges |\n| **Path-based segregation** | Tenant separation using URL prefix enforcement with cryptographic boundaries | Tenant A limited to `/secret/tenant-a/*` paths with separate encryption keys |\n\n### System Operations and Maintenance\n\nOperating a secret management system requires understanding maintenance procedures, monitoring approaches, and operational best practices.\n\n| Term | Definition | Example/Context |\n|------|------------|-----------------|\n| **Lease renewal** | Extending credential lifetime before expiration for ongoing operations | Application renews database credentials every hour to maintain continuous access |\n| **Key rotation** | Periodic replacement of encryption keys to limit blast radius of compromise | Master key rotated annually; data encryption keys rotated monthly |\n| **Seal recovery** | Emergency procedures for reconstructing master key when normal unsealing fails | Use backup key shares stored in different locations to recover sealed system |\n| **Health monitoring** | Continuous validation of system components and dependencies | Monitor encryption engine, storage backend, cluster consensus, lease reaper |\n| **Performance tuning** | Optimizing system configuration for throughput, latency, and resource utilization | Adjust lease reaper batch size, revocation worker count, token cache TTL |\n| **Backup validation** | Regular testing of backup and restore procedures to ensure disaster recovery capability | Monthly restore test using previous week's backup to validate recovery procedures |\n\n### Implementation Guidance\n\nSecret management systems involve complex terminology that can be overwhelming for developers new to the security domain. This implementation guidance provides practical approaches for managing this complexity during development.\n\n#### Technology Recommendations for Documentation\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Code Documentation | Inline comments with examples | Comprehensive API documentation with OpenAPI/Swagger |\n| Architecture Documentation | Markdown files with diagrams | Interactive documentation with PlantUML diagrams |\n| Troubleshooting Guides | Text-based symptom/solution tables | Searchable knowledge base with categorized issues |\n| Glossary Management | Static markdown glossary | Searchable glossary with cross-references and examples |\n\n#### Recommended Documentation Structure\n\nOrganize terminology and documentation to support both development and operations teams:\n\n```\ndocs/\n  glossary.md                    ← this comprehensive glossary\n  concepts/                      ← detailed concept explanations\n    envelope-encryption.md       ← deep dive into encryption patterns\n    dynamic-secrets.md          ← credential lifecycle management\n    access-control.md           ← authentication and authorization\n    high-availability.md        ← clustering and consensus\n  troubleshooting/              ← operational guidance\n    common-errors.md            ← frequent issues and solutions\n    diagnostic-procedures.md    ← step-by-step problem diagnosis\n    performance-tuning.md       ← optimization recommendations\n  api/                          ← API documentation\n    authentication.md           ← auth method documentation\n    secret-engines.md           ← backend-specific APIs\n```\n\n#### Terminology Management Code\n\n```go\n// TerminologyValidator helps ensure consistent terminology usage across the codebase\ntype TerminologyValidator struct {\n    preferredTerms map[string]string\n    deprecatedTerms map[string]string\n}\n\n// NewTerminologyValidator creates a validator with standard secret management terms\nfunc NewTerminologyValidator() *TerminologyValidator {\n    return &TerminologyValidator{\n        preferredTerms: map[string]string{\n            \"envelope encryption\": \"Multi-layer encryption with master key protecting data keys\",\n            \"dynamic secrets\":     \"Short-lived credentials generated on demand\",\n            \"zero-trust\":         \"Security model requiring authentication for every request\",\n            \"secret sprawl\":      \"Scattered secrets creating security vulnerabilities\",\n        },\n        deprecatedTerms: map[string]string{\n            \"secret management\": \"Use 'secret storage' or 'credential management' for clarity\",\n            \"encryption\":        \"Specify 'envelope encryption' or 'field-level encryption'\",\n            \"authentication\":    \"Specify 'bearer token' or 'mutual TLS authentication'\",\n        },\n    }\n}\n\n// ValidateDocumentation checks documentation for consistent terminology usage\nfunc (tv *TerminologyValidator) ValidateDocumentation(content string) []TerminologyIssue {\n    // TODO: Implement documentation parsing and terminology validation\n    // TODO: Check for deprecated terms and suggest preferred alternatives  \n    // TODO: Verify technical terms are defined before first usage\n    // TODO: Flag inconsistent usage of the same concept across documents\n    return nil\n}\n```\n\n#### Glossary Integration Utilities\n\n```go\n// GlossaryLookup provides runtime access to terminology definitions\ntype GlossaryLookup struct {\n    definitions map[string]Definition\n    examples    map[string][]string\n    crossRefs   map[string][]string\n}\n\ntype Definition struct {\n    Term        string\n    Definition  string\n    Context     string\n    Examples    []string\n    SeeAlso     []string\n    Category    string\n}\n\n// LoadGlossary parses the markdown glossary into structured data\nfunc LoadGlossary(glossaryPath string) (*GlossaryLookup, error) {\n    // TODO: Parse markdown glossary tables into structured definitions\n    // TODO: Extract cross-references and examples\n    // TODO: Build category indexes for related terms\n    // TODO: Validate all cross-references resolve to valid terms\n    return nil, nil\n}\n\n// Define returns the definition for a technical term\nfunc (gl *GlossaryLookup) Define(term string) (Definition, bool) {\n    // TODO: Return definition with examples and cross-references\n    // TODO: Handle case-insensitive lookup and common variations\n    // TODO: Track usage statistics for documentation improvement\n    return Definition{}, false\n}\n```\n\n#### Milestone Checkpoint: Terminology Consistency\n\nAfter implementing each milestone, validate terminology consistency:\n\n**Milestone 1 - Encryption Terms:**\n- Run: `grep -r \"encryption\" internal/ | validate-terminology.sh`\n- Expected: All references use \"envelope encryption\" when describing the key hierarchy\n- Signs of issues: Generic \"encryption\" terms without specifying the pattern\n\n**Milestone 2 - Authentication Terms:**\n- Run: `grep -r \"auth\" internal/ | validate-terminology.sh` \n- Expected: Specific terms like \"bearer token authentication\" and \"mutual TLS\"\n- Signs of issues: Vague \"authentication\" without specifying the method\n\n**Milestone 3 - Dynamic Secret Terms:**\n- Run: `grep -r \"credential\" internal/ | validate-terminology.sh`\n- Expected: \"Dynamic secrets\" and \"lease-based tracking\" terminology\n- Signs of issues: \"Temporary credentials\" or \"short-lived tokens\" instead\n\n**Milestone 4 - Consensus Terms:**\n- Run: `grep -r \"cluster\" internal/ | validate-terminology.sh`\n- Expected: \"Raft consensus\" and \"leader election\" terminology\n- Signs of issues: Generic \"replication\" without specifying consensus algorithm\n\n#### Debugging Terminology Issues\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|-------------|------------------|-----|\n| Inconsistent API documentation | Mixed terminology across endpoints | Search codebase for term variations | Establish style guide with preferred terms |\n| Confusing error messages | Technical jargon without context | Review error messages with non-experts | Add glossary references to error docs |\n| Unclear troubleshooting guides | Assumed knowledge of domain terms | Test guides with junior developers | Define terms inline or reference glossary |\n| Complex architecture docs | Too many undefined acronyms | Count undefined terms per page | Maintain acronym list and spell out on first use |\n"}