{"html":"<h1 id=\"simd-optimization-library\">SIMD Optimization Library</h1>\n<p>A high-performance SIMD (Single Instruction, Multiple Data) optimization library implementing SSE/AVX intrinsics for critical operations including string search, memory copy, and checksum computation. The library provides portable abstractions over x86 vector extensions with automatic CPU feature detection and runtime dispatching for optimal performance across different processors.</p>\n<div id=\"ms-0\"></div>\n\n<h1 id=\"foundation-amp-cpu-detection-the-negotiator\">Foundation &amp; CPU Detection: The Negotiator</h1>\n<h2 id=\"1-the-epiphany-the-smart-universal-charger\">1. The Epiphany: The Smart Universal Charger</h2>\n<p>Imagine you are designing a &quot;Universal Power Charger&quot; for electronics.</p>\n<ul>\n<li>If you plug in a modern laptop, the charger detects it and pumps <strong>100 Watts</strong> for rapid charging.</li>\n<li>If you plug in a 10-year-old flip phone, the charger detects it and gently sends <strong>5 Watts</strong>.</li>\n</ul>\n<p>If you force 100 Watts (Advanced Vector Instructions) into the flip phone (an older CPU), you don&#39;t just get slow charging—you fry the device (the program crashes with an &quot;Illegal Instruction&quot;).</p>\n<p><strong>This is your Foundation Layer.</strong> Before we process a single byte of data, we must negotiate with the hardware. We ask the CPU: <em>&quot;Who are you, and how much power can you handle?&quot;</em></p>\n<h2 id=\"2-technical-rationale\">2. Technical Rationale</h2>\n<p>Modern x86 processors are a family. While they all speak the same basic language (x86-64), newer generations have &quot;superpowers&quot; called <strong>SIMD (Single Instruction, Multiple Data)</strong> extensions.</p>\n<ul>\n<li><strong>Scalar (The Old Way):</strong> Processing data one piece at a time. Safe, runs everywhere, but slow.</li>\n<li><strong>SIMD (The New Way):</strong> Processing 16, 32, or 64 bytes at once. Extremely fast, but requires specific hardware support (SSE, AVX, AVX-512).</li>\n</ul>\n<p>We cannot ship different binaries for different computers. Instead, we build a <strong>Fat Binary</strong>—a single program containing multiple versions of the same algorithm. The Foundation Layer decides which version to run at the exact moment the program starts.</p>\n<blockquote>\n<p><strong>Quick Breakdown: ISA (Instruction Set Architecture)</strong>\nThink of the ISA as the vocabulary of the CPU.</p>\n<ul>\n<li><strong>x86-64:</strong> The basic grammar (English).</li>\n<li><strong>SSE4.2:</strong> A vocabulary expansion for string processing (Legal English).</li>\n<li><strong>AVX2:</strong> A vocabulary expansion for massive math operations (Scientific English).\nIf you speak &quot;Scientific English&quot; to a toddler (older CPU), they won&#39;t understand.</li>\n</ul>\n</blockquote>\n<h2 id=\"3-internal-mechanics-the-cpuid-instruction\">3. Internal Mechanics: The CPUID Instruction</h2>\n<p>How do we ask the CPU what it supports? We use the <code>CPUID</code> instruction.</p>\n<p>When you execute <code>CPUID</code>, the processor pauses and fills four specific <strong>Registers</strong> (EAX, EBX, ECX, EDX) with a bitmap of its capabilities.</p>\n<blockquote>\n<p><strong>Quick Breakdown: Registers &amp; Bits</strong></p>\n<ul>\n<li><strong>Register:</strong> A tiny, ultra-fast storage slot directly inside the CPU brain.</li>\n<li><strong>Bitmap:</strong> Imagine a row of 32 light switches. Switch #5 might mean &quot;I support AVX2.&quot; Switch #28 might mean &quot;I support Hyperthreading.&quot; We read the switches to know the features.</li>\n</ul>\n</blockquote>\n<h3 id=\"the-protocol\">The Protocol</h3>\n<ol>\n<li><strong>Leaf Selection:</strong> We put a number into the <code>EAX</code> register (the &quot;Leaf&quot;) to tell the CPU what <em>category</em> of info we want.<ul>\n<li><code>EAX = 1</code>: Standard Features (SSE, SSE2).</li>\n<li><code>EAX = 7</code>: Extended Features (AVX2, AVX-512).</li>\n</ul>\n</li>\n<li><strong>Execution:</strong> We run the <code>cpuid</code> command.</li>\n<li><strong>Reading:</strong> We look at the output registers (ECX, EBX, etc.) and check if specific bits are set to <code>1</code>.</li>\n</ol>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-001.svg\" alt=\"Library Architecture Overview\"></p>\n<p><em>This satellite view shows how our Detection Layer sits at the top, directing traffic to either the Scalar (slow/safe) or SIMD (fast/risky) implementations.</em></p>\n<hr>\n<h2 id=\"4-the-microscope-effect-parsing-the-bits\">4. The Microscope Effect: Parsing the Bits</h2>\n<p>Let&#39;s zoom into the actual bitwise operation. To detect <strong>AVX2</strong>, we can&#39;t just look for &quot;AVX2&quot;. We have to verify a chain of dependencies.</p>\n<p><strong>The Dependency Chain:</strong></p>\n<ol>\n<li>Does the CPU support <code>CPUID</code>? (Yes, unless it&#39;s from the 90s).</li>\n<li><strong>Leaf 1, ECX Register, Bit 28 (AVX):</strong> Does it have the basic AVX unit?</li>\n<li><strong>OS Support (XGETBV):</strong> The hardware might support AVX, but does the Operating System? The OS needs to save/restore the larger YMM registers during context switches. If we skip this check, the program will crash on context switch.</li>\n<li><strong>Leaf 7, EBX Register, Bit 5 (AVX2):</strong> Finally, does it support the AVX2 instruction set?</li>\n</ol>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-003.svg\" alt=\"CPUID Subleaf Enumeration\"></p>\n<p><em>A microscopic view of the CPUID enumeration. Notice how we target specific bits within the 32-bit registers.</em></p>\n<h2 id=\"5-the-debugging-lab\">5. The Debugging Lab</h2>\n<p>When implementing CPU detection, here is where things break:</p>\n<h3 id=\"a-the-quotillegal-instructionquot-sigill-crash\">A. The &quot;Illegal Instruction&quot; (SIGILL) Crash</h3>\n<ul>\n<li><strong>Symptom:</strong> Your program crashes instantly with code <code>0xC000001D</code> (Windows) or <code>SIGILL</code> (Linux).</li>\n<li><strong>Cause:</strong> You successfully detected AVX2, but you compiled your code <em>without</em> the <code>-mavx2</code> flag (or equivalent). The compiler generated scalar code, but you tried to inline raw assembly or intrinsics that the compiler didn&#39;t know how to encode properly.</li>\n<li><strong>Fix:</strong> Ensure your build system (CMake/Make) isolates SIMD code into separate translation units with the correct flags, or uses specific function attributes.</li>\n</ul>\n<h3 id=\"b-the-quotit-works-on-my-machinequot-error\">B. The &quot;It works on my machine&quot; Error</h3>\n<ul>\n<li><strong>Symptom:</strong> It runs fine on your dev box but crashes on the CI/CD server.</li>\n<li><strong>Cause:</strong> You hardcoded checks or relied on <code>__builtin_cpu_supports</code> (GCC specific) without fallback logic.</li>\n<li><strong>Fix:</strong> Always write a &quot;Scalar Fallback&quot; path—plain C++ code that does the same job, just slower.</li>\n</ul>\n<h3 id=\"c-the-os-trap\">C. The OS Trap</h3>\n<ul>\n<li><strong>Symptom:</strong> Random crashes during heavy load.</li>\n<li><strong>Cause:</strong> You checked the CPU hardware bit for AVX but forgot to check <code>XGETBV</code> (OS support). The OS didn&#39;t save your vector registers when switching threads, corrupting your data.</li>\n<li><strong>Fix:</strong> Always verify <code>OSXSAVE</code> bit before checking AVX features.</li>\n</ul>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-002.svg\" alt=\"CPU Feature Detection Flow\"></p>\n<p><em>The correct flow: Check CPUID → Check OS Support → Initialize Function Pointers.</em></p>\n<h2 id=\"6-code-scaffold\">6. Code Scaffold</h2>\n<p>Your task is to build the <code>CpuId</code> class. This is a singleton that runs once at startup.</p>\n<p><strong>Requirements:</strong></p>\n<ol>\n<li>Use <code>__cpuid</code> (MSVC) or <code>__cpuid_count</code> (GCC/Clang) intrinsics.</li>\n<li>Implement methods to check for SSE4.2 and AVX2.</li>\n<li>Implement the OS support check (<code>_xgetbv</code>).</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iostream></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Platform specific includes for intrinsics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> _MSC_VER</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;intrin.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cpuid.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;x86intrin.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CpuFeatureDetector</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The \"Map\" of our hardware</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#B392F0\"> Features</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> has_sse2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> has_sse42 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> has_avx </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> has_avx2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> os_saves_ymm </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Critical for AVX/AVX2 usage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CpuFeatureDetector</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        detect_features</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#B392F0\"> Features</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\"> get_features</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> features_;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> print_status</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"CPU Detection Report:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"  SSE2: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (features_.has_sse2 </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"YES\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"NO\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"  SSE4.2: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (features_.has_sse42 </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"YES\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"NO\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"  OS YMM Save: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (features_.os_saves_ymm </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"YES\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"NO\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"  AVX2: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (features_.has_avx2 </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"YES\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"NO\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">private:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Features features_;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> detect_features</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Registers storage: EAX, EBX, ECX, EDX</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> info[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 1. Check Standard Features (Leaf 1)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cpuid</span><span style=\"color:#E1E4E8\">(info, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Bit 26 of EDX is SSE2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        features_.has_sse2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (info[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 26</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Bit 20 of ECX is SSE4.2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        features_.has_sse42 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (info[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Bit 28 of ECX is AVX</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        features_.has_avx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (info[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 28</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 2. Check OS Support for AVX (OSXSAVE)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Bit 27 of ECX in Leaf 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> has_osxsave </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (info[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 27</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (has_osxsave </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> features_.has_avx) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Check if XCR0 (Extended Control Register) saves YMM registers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // We read XCR0 using _xgetbv(0)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> xcr0 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _xgetbv</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Check if bit 1 (XMM state) and bit 2 (YMM state) are set</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            features_.os_saves_ymm </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (xcr0 </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 3. Check Extended Features (Leaf 7) if AVX is supported by OS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (features_.os_saves_ymm) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            cpuid</span><span style=\"color:#E1E4E8\">(info, </span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Bit 5 of EBX is AVX2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            features_.has_avx2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (info[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Portable wrapper for CPUID instruction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> cpuid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> info</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> leaf</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> _MSC_VER</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        __cpuid</span><span style=\"color:#E1E4E8\">(info, leaf);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // GCC/Clang specific: leaf, subleaf (0 for now)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        __cpuid_count</span><span style=\"color:#E1E4E8\">(leaf, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, info[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], info[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], info[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">], info[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- Usage Example ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CpuFeatureDetector detector;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    detector.</span><span style=\"color:#B392F0\">print_status</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (detector.</span><span style=\"color:#B392F0\">get_features</span><span style=\"color:#E1E4E8\">().has_avx2) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Selecting AVX2 Optimized Path (The Jet Plane)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Selecting Scalar Fallback Path (The Propeller Plane)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<div id=\"ms-1\"></div>\n\n<h1 id=\"sse2-amp-sse42-the-assembly-line\">SSE2 &amp; SSE4.2: The Assembly Line</h1>\n<h2 id=\"1-the-epiphany-the-bucket-brigade-vs-the-forklift\">1. The Epiphany: The Bucket Brigade vs. The Forklift</h2>\n<p>Imagine a warehouse (Memory) full of boxes (Bytes). You need to find a specific red box (a character) or move a pile of boxes to a new truck (Copy).</p>\n<ul>\n<li><strong>The Scalar Way (C++ <code>char*</code>)</strong>: You are a single worker. You pick up <strong>one box</strong>, look at it, put it down. Pick up the next box. It takes 16 trips to check 16 boxes.</li>\n<li><strong>The SIMD Way (SSE2)</strong>: You drive a forklift. You scoop up a pallet of <strong>16 boxes</strong> at once. You look at the whole pallet instantly. If the red box isn&#39;t there, you dump the whole pallet and grab the next 16.</li>\n</ul>\n<p><strong>SIMD</strong> stands for <strong>Single Instruction, Multiple Data</strong>. One command from the CPU acts on 16 bytes of data simultaneously. This isn&#39;t just twice as fast; it&#39;s often 10-20x faster because we eliminate the overhead of the loop logic for every single byte.</p>\n<h2 id=\"2-technical-rationale\">2. Technical Rationale</h2>\n<p>Standard C++ <code>strlen</code> or <code>memcpy</code> are often optimized, but generic compilers must be conservative. By writing manual intrinsics, we unlock raw performance for our specific data patterns.</p>\n<ul>\n<li><strong>SSE2 (Streaming SIMD Extensions 2)</strong>: The baseline. Every x86-64 CPU supports this. It gives us <strong>128-bit registers (XMM)</strong> holding 16 bytes.</li>\n<li><strong>SSE4.2</strong>: The &quot;String Specialist&quot;. It adds specific instructions (like <code>PCMPISTRI</code>) designed explicitly to handle C-style null-terminated strings, which are notoriously hard to vectorize because you don&#39;t know the length ahead of time.</li>\n</ul>\n<h2 id=\"3-internal-mechanics-the-128-bit-engine\">3. Internal Mechanics: The 128-bit Engine</h2>\n<p>To write this code, we bypass standard C++ variables and speak directly to the <strong>XMM Registers</strong>.</p>\n<h3 id=\"the-data-type-__m128i\">The Data Type: <code>__m128i</code></h3>\n<p>This is a &quot;Black Box&quot; type. It represents 128 bits (16 bytes) in a vector register. You cannot access <code>variable[0]</code> directly; you must use <strong>Intrinsics</strong> (functions starting with <code>_mm_</code>) to manipulate it.</p>\n<h3 id=\"the-operation-parallel-comparison\">The Operation: Parallel Comparison</h3>\n<p>Let&#39;s look at <code>strlen</code> (finding the null terminator <code>\\0</code>).</p>\n<ol>\n<li><strong>Load</strong>: <code>_mm_loadu_si128</code> pulls 16 bytes from memory into a register.</li>\n<li><strong>Compare</strong>: <code>_mm_cmpeq_epi8</code> compares our 16 bytes against a register of all zeros.<ul>\n<li><em>Scalar</em>: Returns <code>true</code>/<code>false</code>.</li>\n<li><em>SIMD</em>: Returns <strong>0xFF</strong> (all 1s) for a match, or <strong>0x00</strong> for no match, <em>for every byte position</em>.</li>\n</ul>\n</li>\n<li><strong>Squash</strong>: <code>_mm_movemask_epi8</code> takes the most significant bit of each byte result and compresses them into a standard 16-bit integer (C++ <code>int</code>).<ul>\n<li>If the result is <code>0</code>, no nulls were found.</li>\n<li>If the result is <code>0x0008</code> (binary <code>0000 0000 0000 1000</code>), the null is at index 3.</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-006.svg\" alt=\"SSE2 Character Scan Algorithm\"></p>\n<p><em>Visualizing the SSE2 Scan: We load 16 chars, compare them all to &#39;A&#39; (or \\0) in one cycle, and extract a bitmask representing the matches.</em></p>\n<h3 id=\"the-advanced-tool-sse42-_mm_cmpistri\">The Advanced Tool: SSE4.2 <code>_mm_cmpistri</code></h3>\n<p>For more complex tasks, like &quot;Find the first occurrence of any character from set &#39;ABC&#39;&quot;, SSE2 is tedious. SSE4.2 gives us <code>PCMPISTRI</code> (Packed Compare Implicit Length String, Return Index).</p>\n<ul>\n<li>It automatically handles null termination (stops if it sees a zero).</li>\n<li>It compares ranges or sets.</li>\n<li>It returns the index directly.</li>\n</ul>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-007.svg\" alt=\"SSE4.2 String Search (PCMPISTRI)\"></p>\n<p><em>Microscope view of SSE4.2. Notice how the hardware handles the loop logic and null checks internally, returning just an index.</em></p>\n<h2 id=\"4-the-debugging-lab\">4. The Debugging Lab</h2>\n<p>SIMD programming is like juggling chainsaws. It&#39;s powerful, but mistakes are fatal.</p>\n<h3 id=\"a-the-alignment-trap-segfaults\">A. The Alignment Trap (Segfaults)</h3>\n<ul>\n<li><strong>The Crash:</strong> <code>Segmentation fault</code> on a load instruction.</li>\n<li><strong>The Cause:</strong> You used <code>_mm_load_si128</code> (Aligned Load) on a memory address like <code>0x1003</code>.</li>\n<li><strong>The Fix:</strong> Aligned loads require addresses ending in <code>0</code> (divisible by 16). Unless you are 100% sure of your memory allocation, <strong>always use <code>_mm_loadu_si128</code></strong> (Unaligned Load). Modern CPUs handle unaligned loads with almost zero penalty.</li>\n</ul>\n<h3 id=\"b-the-page-boundary-over-read\">B. The Page Boundary Over-read</h3>\n<ul>\n<li><strong>The Fear:</strong> &quot;If my string is 3 bytes long, but I load 16 bytes, am I reading garbage?&quot;</li>\n<li><strong>The Reality:</strong> Yes, you are reading 13 bytes of garbage.</li>\n<li><strong>The Danger:</strong> If those 3 bytes are at the very end of a <strong>Memory Page</strong> (a 4KB chunk managed by the OS), and the <em>next</em> page is not allocated to your process, reading into it causes a Segfault.</li>\n<li><strong>The Fix:</strong> Safe SIMD implementations align the pointer <em>down</em> to the nearest 16-byte boundary and mask off the bytes that precede the string start.</li>\n</ul>\n<h3 id=\"c-the-quotghostquot-bytes\">C. The &quot;Ghost&quot; Bytes</h3>\n<ul>\n<li><strong>The Bug:</strong> Your <code>strlen</code> returns 5, but the string is length 4.</li>\n<li><strong>The Cause:</strong> You loaded garbage bytes after the null terminator. One of those garbage bytes happened to be the character you were searching for (e.g., if searching for &#39;X&#39; and &#39;X&#39; exists in the unallocated memory after the string).</li>\n<li><strong>The Fix:</strong> Logic order matters. In <code>strlen</code>, we look for the <em>first</em> zero. In <code>strchr</code> (find char), we must stop searching if we hit the target char <em>OR</em> the null terminator.</li>\n</ul>\n<h2 id=\"5-code-scaffold\">5. Code Scaffold</h2>\n<p>We will implement a safe <code>strlen</code> using SSE2. This is the &quot;Hello World&quot; of SIMD.</p>\n<p><strong>Your Task:</strong></p>\n<ol>\n<li>Align the pointer to 16 bytes to avoid page boundary crashes.</li>\n<li>Load data using <code>_mm_load_si128</code>.</li>\n<li>Compare against Zero.</li>\n<li>If a zero is found, calculate the exact length using <code>_tzcnt_u32</code> (Count Trailing Zeros).</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;emmintrin.h></span><span style=\"color:#6A737D\"> // SSE2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;nmmintrin.h></span><span style=\"color:#6A737D\"> // SSE4.2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstddef></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;immintrin.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper to count trailing zeros (compiler abstraction)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> count_trailing_zeros</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> x</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> _MSC_VER</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    _BitScanForward</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">result, x);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> __builtin_ctz</span><span style=\"color:#E1E4E8\">(x);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SimdCore</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SSE2 Optimized String Length</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#B392F0\"> fast_strlen</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> str</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> str;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        __m128i zero_chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_setzero_si128</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 1. Handle Unaligned Start</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // We cannot just load 16 bytes if we are at the edge of a page.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Strategy: Align pointer DOWN, load, and ignore bytes before 'str'.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uintptr_t</span><span style=\"color:#E1E4E8\"> address </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> reinterpret_cast&#x3C;uintptr_t></span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uintptr_t</span><span style=\"color:#E1E4E8\"> alignment_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> address </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 15</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // address % 16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (alignment_offset </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Align pointer down to previous 16-byte boundary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> aligned_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> alignment_offset;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m128i chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_load_si128</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;const</span><span style=\"color:#E1E4E8\"> __m128i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(aligned_ptr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Compare with zero</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m128i cmp </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_cmpeq_epi8</span><span style=\"color:#E1E4E8\">(chunk, zero_chunk);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> mask </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_movemask_epi8</span><span style=\"color:#E1E4E8\">(cmp);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Shift mask to ignore the bytes before our actual string start</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            mask </span><span style=\"color:#F97583\">>>=</span><span style=\"color:#E1E4E8\"> alignment_offset;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (mask </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Found null in the first chunk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#B392F0\"> count_trailing_zeros</span><span style=\"color:#E1E4E8\">(mask);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Move ptr to next aligned boundary</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> aligned_ptr </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 2. Main Loop (Aligned 16-byte chunks)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m128i chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_load_si128</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;const</span><span style=\"color:#E1E4E8\"> __m128i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(ptr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m128i cmp </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_cmpeq_epi8</span><span style=\"color:#E1E4E8\">(chunk, zero_chunk);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> mask </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_movemask_epi8</span><span style=\"color:#E1E4E8\">(cmp);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (mask </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Found the terminator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Add the distance traveled so far + index within this chunk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> str) </span><span style=\"color:#F97583\">+</span><span style=\"color:#B392F0\"> count_trailing_zeros</span><span style=\"color:#E1E4E8\">(mask);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SSE4.2 Optimized Character Search (Bonus)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns index of first occurrence of 'ch', or -1 if not found.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> intptr_t</span><span style=\"color:#B392F0\"> fast_strchr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> ch</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> __SSE4_2__</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Fill a register with the character we want (e.g., 'A' -> 'AAAAAAAAAAAAAAAA')</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        __m128i target </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_set1_epi8</span><span style=\"color:#E1E4E8\">(ch);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> str;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // NOTE: For simplicity, this snippet assumes unaligned load is safe </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // (not crossing page boundary). Production code needs the alignment fix above.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m128i chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_loadu_si128</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;const</span><span style=\"color:#E1E4E8\"> __m128i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(ptr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Find 'ch' OR '\\0' (end of string)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // _mm_cmpistri returns the index of the match</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // _SIDD_CMP_EQUAL_EACH: Compare bytes for equality</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // _SIDD_MASKED_NEGATIVE_POLARITY: Invert result? No, we want matches.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Actually, for strchr, standard SSE2 manual approach is often faster </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // than cmpistri due to latency, but cmpistri is great for complex sets.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Let's stick to the SSE2 manual approach for clarity on the mechanics:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m128i zero_chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_setzero_si128</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m128i match_char </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_cmpeq_epi8</span><span style=\"color:#E1E4E8\">(chunk, target);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m128i match_zero </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_cmpeq_epi8</span><span style=\"color:#E1E4E8\">(chunk, zero_chunk);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Combine: We care if we found the Char OR the Zero</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m128i combined </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_or_si128</span><span style=\"color:#E1E4E8\">(match_char, match_zero);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> mask </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_movemask_epi8</span><span style=\"color:#E1E4E8\">(combined);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (mask </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                uint32_t</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> count_trailing_zeros</span><span style=\"color:#E1E4E8\">(mask);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Check if the match was the Char or the Null Terminator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (ptr[idx] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ch) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> str) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> idx;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Found null terminator before char</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Fallback for non-SSE4.2 systems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">; </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<div id=\"ms-2\"></div>\n\n<h1 id=\"avx-amp-avx2-the-heavy-machinery\">AVX &amp; AVX2: The Heavy Machinery</h1>\n<h2 id=\"1-the-epiphany-the-delivery-truck-vs-the-semi-trailer\">1. The Epiphany: The Delivery Truck vs. The Semi-Trailer</h2>\n<p>In the previous section, we upgraded from a single worker to a <strong>Delivery Truck (SSE)</strong> that could move 16 bytes at once.</p>\n<p>Now, we are upgrading to a <strong>Semi-Trailer (AVX/AVX2)</strong>.</p>\n<ul>\n<li><strong>Capacity</strong>: It carries <strong>32 bytes</strong> (256 bits) in a single trip.</li>\n<li><strong>Efficiency</strong>: It doesn&#39;t just carry more; it has a smarter engine. In the old truck (SSE), if you wanted to add Box A to Box B, you had to overwrite Box A. In the Semi-Trailer (AVX), you can take Box A and Box B, add them, and put the result in a <em>new</em> Box C, leaving A untouched.</li>\n</ul>\n<p><strong>The Distinction:</strong></p>\n<ul>\n<li><strong>AVX (Advanced Vector Extensions)</strong>: Great for Math (Floating Point). Think scientific calculations.</li>\n<li><strong>AVX2</strong>: The expansion that matters for Systems Programming. It brings 256-bit power to <strong>Integers</strong>. Since text, pointers, and network packets are integers, AVX2 is our weapon of choice.</li>\n</ul>\n<h2 id=\"2-technical-rationale\">2. Technical Rationale</h2>\n<p>Why bother with AVX2 if SSE is &quot;fast enough&quot;?</p>\n<ol>\n<li><strong>Throughput</strong>: Processing 32 bytes per cycle effectively doubles your memory bandwidth utilization for cached data.</li>\n<li><strong>Non-Destructive Syntax</strong>: AVX introduces 3-operand instructions (<code>Dest = Src1 + Src2</code>). SSE was 2-operand (<code>Dest = Dest + Src</code>). This allows the compiler (and you) to write code with fewer &quot;register shuffling&quot; instructions, reducing CPU overhead.</li>\n</ol>\n<h2 id=\"3-internal-mechanics-the-ymm-registers\">3. Internal Mechanics: The YMM Registers</h2>\n<p>To use AVX, we interact with the <strong>YMM Registers</strong>.</p>\n<ul>\n<li><strong>Size</strong>: 256 bits (32 Bytes).</li>\n<li><strong>Naming</strong>: <code>YMM0</code> through <code>YMM15</code>.</li>\n<li><strong>The Nesting Doll Architecture</strong>: The YMM registers are not new hardware sitting next to the old stuff. They <em>enclose</em> the old stuff.<ul>\n<li>The lower 128 bits of <code>YMM0</code> <strong>ARE</strong> <code>XMM0</code>.</li>\n<li>If you write to <code>XMM0</code>, you are modifying the bottom half of <code>YMM0</code>.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-005.svg\" alt=\"Vector Register Mapping\"></p>\n<p><em>Microscopic view showing XMM/YMM register allocation. Notice how YMM extends XMM. Writing to YMM zeroes out the upper bits of the future, while writing to XMM interacts with the lower bits.</em></p>\n<h3 id=\"the-data-type-__m256i\">The Data Type: <code>__m256i</code></h3>\n<p>Just like <code>__m128i</code>, this is a black box.</p>\n<ul>\n<li><code>__m256</code> = 8 floats (AVX).</li>\n<li><code>__m256i</code> = 32 chars, or 8 integers, or 4 <code>long long</code>s (AVX2).</li>\n</ul>\n<h3 id=\"the-instruction-set\">The Instruction Set</h3>\n<p>The intrinsic functions follow a pattern:</p>\n<ul>\n<li><code>_mm256_load_si256</code>: Load 32 bytes (Must be 32-byte aligned).</li>\n<li><code>_mm256_loadu_si256</code>: Load 32 bytes (Unaligned - safe for most pointers).</li>\n<li><code>_mm256_add_epi32</code>: Add integers.</li>\n</ul>\n<h2 id=\"4-the-debugging-lab\">4. The Debugging Lab</h2>\n<p>Upgrading to AVX introduces new categories of bugs.</p>\n<h3 id=\"a-the-quotstate-transitionquot-stall-the-avx-sse-penalty\">A. The &quot;State Transition&quot; Stall (The AVX-SSE Penalty)</h3>\n<ul>\n<li><strong>The Issue:</strong> The CPU tries to be energy efficient. If you are running old SSE code, it turns off the power to the upper 128 bits of the YMM registers.</li>\n<li><strong>The Trap:</strong> If you suddenly execute an AVX instruction, the CPU has to &quot;wake up&quot; the upper half. This costs hundreds of CPU cycles. Worse, if you switch <em>back</em> to SSE without cleaning up, the CPU might merge the states inefficiently.</li>\n<li><strong>The Fix:</strong> If you mix SSE and AVX code, use the intrinsic <code>_mm256_zeroupper()</code> at the boundary. This tells the CPU &quot;I&#39;m done with the top half, you can power it down.&quot;</li>\n</ul>\n<h3 id=\"b-the-32-byte-alignment-crash\">B. The 32-Byte Alignment Crash</h3>\n<ul>\n<li><strong>The Symptom:</strong> Instant Segfault on <code>_mm256_load_si256</code>.</li>\n<li><strong>The Cause:</strong> SSE required 16-byte alignment (addresses ending in <code>0</code>). AVX requires <strong>32-byte alignment</strong> (addresses ending in <code>00</code> hex, divisible by 32). <code>malloc</code> in C++ does not guarantee 32-byte alignment.</li>\n<li><strong>The Fix:</strong> Use <code>aligned_alloc</code> (C++17) or <code>_mm_malloc</code>, or stick to <code>_mm256_loadu_si256</code> (unaligned load) which is very fast on modern CPUs.</li>\n</ul>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-012.svg\" alt=\"Aligned 256-bit Copy Loop\"></p>\n<p><em>Microscopic view of an aligned AVX copy loop. Notice the strict 32-byte blocks. If the memory address starts at offset 0x08, the aligned load will crash.</em></p>\n<h2 id=\"5-code-scaffold\">5. Code Scaffold</h2>\n<p>Your task is to implement a <strong>High-Performance Buffer XOR</strong>. This is a common operation in cryptography and checksumming. We will take two arrays of data, XOR them together, and store the result, processing 32 bytes at a time.</p>\n<p><strong>Requirements:</strong></p>\n<ol>\n<li>Check for AVX2 support (using your previous detection class).</li>\n<li>Process the &quot;Bulk&quot; using AVX2 intrinsics.</li>\n<li>Process the &quot;Tail&quot; (leftover bytes &lt; 32) using a standard loop.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;immintrin.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iostream></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> VectorMath</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Computes: dest[i] = src1[i] ^ src2[i]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Optimized with AVX2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> xor_buffers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#FFAB70\"> dest</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> uint8_t*</span><span style=\"color:#FFAB70\"> src1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> uint8_t*</span><span style=\"color:#FFAB70\"> src2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> len</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 1. The AVX2 Fast Path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // We can process 32 bytes (256 bits) per iteration.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // We stop when we have fewer than 32 bytes left.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> avx_limit </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> len </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (len </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Quick Breakdown:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // _mm256_loadu_si256: Load 32 bytes from memory (Unaligned is safe).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // _mm256_xor_si256:   Perform bitwise XOR on all 256 bits at once.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // _mm256_storeu_si256: Store result back to memory.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> avx_limit; i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Load 32 bytes from Source 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m256i v1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm256_loadu_si256</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;const</span><span style=\"color:#E1E4E8\"> __m256i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(src1 </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Load 32 bytes from Source 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m256i v2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm256_loadu_si256</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;const</span><span style=\"color:#E1E4E8\"> __m256i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(src2 </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // The operation: Dest = Src1 XOR Src2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m256i result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm256_xor_si256</span><span style=\"color:#E1E4E8\">(v1, v2);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Store the result</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            _mm256_storeu_si256</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;</span><span style=\"color:#E1E4E8\">__m256i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(dest </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i), result);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 2. The Cleanup Transition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Good practice when leaving AVX code if we might jump to legacy SSE code elsewhere.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Clears the upper 128 bits of YMM registers.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        _mm256_zeroupper</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 3. The Scalar Tail (Cleanup)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Handle the remaining 0 to 31 bytes one by one.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> len; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            dest[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> src1[i] </span><span style=\"color:#F97583\">^</span><span style=\"color:#E1E4E8\"> src2[i];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- Test Harness ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\"> SIZE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> buffer_a[SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> buffer_b[SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> result[SIZE];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize with dummy data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> SIZE; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buffer_a[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        buffer_b[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FF</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Invert mask</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Running AVX2 XOR Operation...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    VectorMath</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">xor_buffers</span><span style=\"color:#E1E4E8\">(result, buffer_a, buffer_b, SIZE);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Verify Index 0: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)buffer_a[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \" ^ \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)buffer_b[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">              &#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \" = \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)result[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Verify Index 35 (Tail): \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)buffer_a[</span><span style=\"color:#79B8FF\">35</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \" ^ \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)buffer_b[</span><span style=\"color:#79B8FF\">35</span><span style=\"color:#E1E4E8\">] </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">              &#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \" = \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)result[</span><span style=\"color:#79B8FF\">35</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<div id=\"ms-3\"></div>\n\n<h1 id=\"string-search-primitives-the-needle-in-the-haystack\">String Search Primitives: The Needle in the Haystack</h1>\n<h2 id=\"1-the-epiphany-the-stencil-vs-the-magnifying-glass\">1. The Epiphany: The Stencil vs. The Magnifying Glass</h2>\n<p>Imagine you are looking for specific letters—say, all the vowels—in a page of text.</p>\n<ul>\n<li><strong>The Scalar Way (The Magnifying Glass):</strong> You move your magnifying glass over the first letter. Is it an &#39;A&#39;? No. Is it an &#39;E&#39;? No. Is it an &#39;I&#39;? No. Move to the next letter. Repeat.</li>\n<li><strong>The SIMD Way (The Stencil):</strong> You take a plastic stencil that has holes cut out for A, E, I, O, and U. You slap this stencil over a whole sentence at once. Instantly, you see exactly where the vowels are through the holes.</li>\n</ul>\n<p>In this section, we aren&#39;t just comparing byte-for-byte. We are using <strong>SSE4.2</strong>, an instruction set that essentially adds a programmable &quot;Search Engine&quot; directly into the CPU silicon.</p>\n<h2 id=\"2-technical-rationale-the-quotswiss-army-knifequot-instruction\">2. Technical Rationale: The &quot;Swiss Army Knife&quot; Instruction</h2>\n<p>Standard SIMD (SSE2) is great for &quot;Are these 16 bytes equal to those 16 bytes?&quot;</p>\n<p>But string searching is messier.</p>\n<ol>\n<li>We might look for <em>any</em> character from a set (e.g., &quot;Find the first whitespace or comma&quot;).</li>\n<li>We might look for a range (e.g., &quot;Find the first number 0-9&quot;).</li>\n<li>We might look for a substring (e.g., &quot;Find &#39;HTTP&#39;&quot;).</li>\n<li>We have to stop if we hit a Null Terminator (<code>\\0</code>).</li>\n</ol>\n<p>Doing this with basic math instructions is a nightmare of bit-twiddling. Enter <strong>SSE4.2</strong> and the instruction <code>PCMPISTRI</code> (Packed Compare Implicit Length String, Return Index). It is the most complex instruction in the x86 non-crypto instruction set.</p>\n<h2 id=\"3-internal-mechanics-the-programmable-engine\">3. Internal Mechanics: The Programmable Engine</h2>\n<p>We are going to use the intrinsic <code>_mm_cmpistri</code>. This function doesn&#39;t just do one thing; it changes its behavior based on a <strong>Control Byte</strong> (a configuration number) you pass to it.</p>\n<h3 id=\"the-inputs\">The Inputs</h3>\n<ol>\n<li><strong>Needle (<code>__m128i</code>)</strong>: The characters you are looking for (up to 16).</li>\n<li><strong>Haystack (<code>__m128i</code>)</strong>: The chunk of text you are searching through (16 bytes).</li>\n<li><strong>Control Byte (<code>const int</code>)</strong>: The mode selector.</li>\n</ol>\n<h3 id=\"the-modes-the-control-byte\">The Modes (The Control Byte)</h3>\n<p>The Control Byte tells the CPU how to compare the Needle and the Haystack.</p>\n<ul>\n<li><strong>Equal Any (<code>_SIDD_CMP_EQUAL_ANY</code>)</strong>: &quot;Is the character at <code>Haystack[i]</code> present <em>anywhere</em> in <code>Needle</code>?&quot;<ul>\n<li><em>Use Case:</em> <code>strpbrk</code> (Find first of set). Good for finding delimiters.</li>\n</ul>\n</li>\n<li><strong>Equal Each (<code>_SIDD_CMP_EQUAL_EACH</code>)</strong>: &quot;Does <code>Haystack</code> match <code>Needle</code> perfectly?&quot;<ul>\n<li><em>Use Case:</em> <code>strcmp</code> (String equality).</li>\n</ul>\n</li>\n<li><strong>Ranges (<code>_SIDD_CMP_RANGES</code>)</strong>: &quot;Is <code>Haystack[i]</code> inside the range defined by <code>Needle</code>?&quot;<ul>\n<li><em>Use Case:</em> Finding all digits (Needle = &#39;0&#39;, &#39;9&#39;).</li>\n</ul>\n</li>\n<li><strong>Equal Ordered (<code>_SIDD_CMP_EQUAL_ORDERED</code>)</strong>: &quot;Does the substring <code>Needle</code> start at <code>Haystack[i]</code>?&quot;<ul>\n<li><em>Use Case:</em> <code>strstr</code> (Substring search).</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"the-output\">The Output</h3>\n<p>The instruction returns the <strong>Index</strong> (0-15) of the first match. If no match is found, it usually returns 16.</p>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-007.svg\" alt=\"SSE4.2 String Search (PCMPISTRI)\"></p>\n<p><em>Microscopic view of SSE4.2 PCMPISTRI. The CPU loads the needle and haystack, applies the logic defined by the Control Byte (Mode), handles the null-check automatically, and spits out the index of the winner.</em></p>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-010.svg\" alt=\"Character Class Search\"></p>\n<p><em>Visualizing &quot;Equal Any&quot; mode. We load the delimiter set (spaces, commas) into the Needle register. The CPU checks all 16 Haystack bytes against the entire Needle set simultaneously.</em></p>\n<h2 id=\"4-the-debugging-lab\">4. The Debugging Lab</h2>\n<h3 id=\"a-the-latency-trap\">A. The Latency Trap</h3>\n<ul>\n<li><strong>The Myth:</strong> &quot;One SIMD instruction is always faster than 5 scalar instructions.&quot;</li>\n<li><strong>The Reality:</strong> <code>PCMPISTRI</code> is a heavy instruction. It takes ~11 CPU cycles to execute. A simple scalar <code>CMP</code> takes &lt; 1 cycle.</li>\n<li><strong>The Lesson:</strong> If you are only looking for <strong>one</strong> character (e.g., just &#39;A&#39;), don&#39;t use this heavy machinery. Use the simpler SSE2 <code>_mm_cmpeq_epi8</code> method from the previous section. Use <code>PCMPISTRI</code> when the logic is complex (sets, ranges, substrings).</li>\n</ul>\n<h3 id=\"b-the-quotimplicitquot-vs-quotexplicitquot-length\">B. The &quot;Implicit&quot; vs &quot;Explicit&quot; Length</h3>\n<ul>\n<li><strong>The Confusion:</strong> There are two versions: <code>_mm_cmpistri</code> (Implicit) and <code>_mm_cmpestri</code> (Explicit).</li>\n<li><strong>Implicit (<code>i</code>)</strong>: Scans for the Null Terminator (<code>\\0</code>) automatically. Use this for C-style strings (<code>char*</code>).</li>\n<li><strong>Explicit (<code>e</code>)</strong>: You must tell it the length of the string. Use this for <code>std::string_view</code> or known buffers.</li>\n<li><strong>The Bug:</strong> Using Implicit mode on a buffer that <em>isn&#39;t</em> a null-terminated string. The CPU might stop searching prematurely if it hits a random <code>0</code> byte in your binary data.</li>\n</ul>\n<h2 id=\"5-code-scaffold\">5. Code Scaffold</h2>\n<p>We will implement a <strong>Delimiter Finder</strong>. This function scans a string and returns the index of the first occurrence of <em>any</em> character in a &quot;Needle&quot; set (e.g., find the first space, comma, or period).</p>\n<p><strong>Your Task:</strong></p>\n<ol>\n<li>Load the &quot;Set&quot; of characters (Needle) into a register.</li>\n<li>Loop through the string 16 bytes at a time.</li>\n<li>Use <code>_mm_cmpistri</code> with <code>_SIDD_CMP_EQUAL_ANY</code> mode.</li>\n<li>Handle the return index.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;nmmintrin.h></span><span style=\"color:#6A737D\"> // SSE4.2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;immintrin.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iostream></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> StringScanner</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Finds the first occurrence of ANY character in 'accept_set' within 'str'.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Equivalent to C's strpbrk, but returns an index.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> intptr_t</span><span style=\"color:#B392F0\"> find_first_of</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> accept_set</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">str </span><span style=\"color:#F97583\">||</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">accept_set) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 1. Prepare the Needle (The Set)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // We load the accept_set into a register. </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // NOTE: For this scaffold, we assume accept_set is short (&#x3C; 16 chars).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // In production, if the set is > 16, you'd need a different strategy (Lookup Table).</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        __m128i needle </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_loadu_si128</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;const</span><span style=\"color:#E1E4E8\"> __m128i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(accept_set));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> str;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 2. The Loop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Load 16 bytes of the Haystack (Unsafe load - see previous section for alignment fixes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m128i chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_loadu_si128</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;const</span><span style=\"color:#E1E4E8\"> __m128i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(ptr));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // 3. The Heavy Machinery: _mm_cmpistri</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // _SIDD_UBYTE_OPS: We are comparing Bytes (Chars)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // _SIDD_CMP_EQUAL_ANY: Match if Haystack[i] equals ANY char in Needle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // _SIDD_LEAST_SIGNIFICANT: Return the smallest index found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            const</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> mode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> _SIDD_UBYTE_OPS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> _SIDD_CMP_EQUAL_ANY </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> _SIDD_LEAST_SIGNIFICANT;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_cmpistri</span><span style=\"color:#E1E4E8\">(needle, chunk, mode);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // 4. Check for Termination</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // The instruction sets flags. We can check the \"Zero Flag\" (ZF) and \"Carry Flag\" (CF).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // However, the intrinsic returns the index directly.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Case A: Found a match?</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (idx </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Wait! Did we find a match, or did we hit the end of the string (Null Terminator)?</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // In Implicit mode, if the string ends, the index points to the null.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // We need to verify if the char at idx is actually in our set.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // For simplicity in this scaffold, let's trust the index but double-check manually</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // to distinguish between \"Found Terminator\" and \"Found Match\".</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (ptr[idx] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // End of string, nothing found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> str) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> idx;</span><span style=\"color:#6A737D\"> // Found it!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Case B: No match in this chunk.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // But did the string end in this chunk?</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // _mm_cmpistri handles nulls. If a null was found but no match, </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // the index would be the position of the null (which is &#x3C; 16).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // If idx == 16, it means \"Processed all 16 bytes, valid data, no match\".</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (idx </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Check if we hit the null terminator implicitly.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // The intrinsic sets the Zero Flag (ZF) if the null terminator was seen in needle,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // and Carry Flag (CF) if null terminator seen in haystack.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Accessing flags from C++ is tricky without assembly. </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Easier check:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                __m128i zero </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_setzero_si128</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                int</span><span style=\"color:#E1E4E8\"> null_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_cmpistri</span><span style=\"color:#E1E4E8\">(zero, chunk, _SIDD_UBYTE_OPS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> _SIDD_CMP_EQUAL_EACH);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (null_idx </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // String ended in this block, no match found earlier.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- Test Harness ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> text </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Hello, world! This is SIMD.\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> delimiters </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"!.\"</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Looking for punctuation</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Text: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> text </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Looking for: [\"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> delimiters </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    intptr_t</span><span style=\"color:#E1E4E8\"> index </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> StringScanner</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">find_first_of</span><span style=\"color:#E1E4E8\">(text, delimiters);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (index </span><span style=\"color:#F97583\">!=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Found delimiter '\"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> text[index] </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"' at index \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> index </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> No delimiters found.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<div id=\"ms-4\"></div>\n\n<h1 id=\"memory-copy-engine-moving-mountains-with-tweezers-vs-dump-trucks\">Memory Copy Engine: Moving Mountains with Tweezers vs. Dump Trucks</h1>\n<h2 id=\"1-the-epiphany-the-logistics-manager\">1. The Epiphany: The Logistics Manager</h2>\n<p>Imagine you are a logistics manager responsible for moving items from Warehouse A to Warehouse B. You have three vehicles: a bicycle courier, a moving van, and a freight train.</p>\n<ul>\n<li><strong>The Scalar Loop (The Bicycle):</strong> If you need to move a single letter, you give it to the cyclist. It’s fast to start, agile, and finishes immediately.</li>\n<li><strong>The SIMD Loop (The Moving Van):</strong> If you need to move the contents of a studio apartment, the bicycle is useless. You load up the van (128/256 bits at a time). It takes a moment to park and open the doors (overhead), but it moves volume fast.</li>\n<li><strong>The Non-Temporal Store (The Freight Train):</strong> If you are moving a whole factory, even the van is too slow. You load a train. Crucially, the train bypasses the local city traffic (CPU Cache) entirely so it doesn&#39;t cause a gridlock for everyone else.</li>\n</ul>\n<p>A naive <code>memcpy</code> uses the bicycle for everything. A system programmer builds a dispatcher that checks the weight of the cargo and selects the perfect vehicle.</p>\n<h2 id=\"2-technical-rationale\">2. Technical Rationale</h2>\n<p>Why can&#39;t we just use <code>std::memcpy</code>? usually, you can! But understanding <em>how</em> it works allows you to write specialized copy routines for high-performance structures (like ring buffers or network packets) where the overhead of the standard library function call might be too high, or you need specific behavior (like bypassing cache).</p>\n<ol>\n<li><strong>Branch Prediction Overhead:</strong> For tiny copies (e.g., 8 bytes), the cost of the CPU deciding <em>which</em> loop to run is higher than the copy itself.</li>\n<li><strong>Alignment Penalties:</strong> Writing 32 bytes to an address ending in <code>0x01</code> is slower than writing to <code>0x00</code>.</li>\n<li><strong>Cache Pollution:</strong> Copying 1GB of data typically wipes out your L1/L2/L3 caches. The moment the copy finishes, your CPU stalls because the code instructions it needs were evicted to make room for the data you just copied.</li>\n</ol>\n<h2 id=\"3-internal-mechanics-the-decision-tree\">3. Internal Mechanics: The Decision Tree</h2>\n<p>High-performance memory copying is a game of thresholds.</p>\n<h3 id=\"tier-1-the-tiny-path-lt-16-bytes\">Tier 1: The Tiny Path (&lt; 16 Bytes)</h3>\n<p><strong>Mechanism:</strong> General Purpose Registers (GPR).\nWe don&#39;t touch SSE/AVX here. We treat the data as <code>uint64_t</code> or <code>uint8_t</code>.</p>\n<ul>\n<li><strong>Method:</strong> A &quot;Jump Table&quot; or unrolled switch.</li>\n<li><strong>Why:</strong> Setting up AVX registers takes cycles. Loading a standard 64-bit integer into a standard register (<code>RAX</code>) is instantaneous.</li>\n</ul>\n<h3 id=\"tier-2-the-simd-path-16-bytes-to-4kb\">Tier 2: The SIMD Path (16 Bytes to ~4KB)</h3>\n<p><strong>Mechanism:</strong> <code>XMM</code> (128-bit) or <code>YMM</code> (256-bit) Registers.\nThis is the &quot;Moving Van.&quot;</p>\n<ul>\n<li><strong>The Loop:</strong> Load 32 bytes $\\to$ Store 32 bytes.</li>\n<li><strong>Prefetching:</strong> We might tell the CPU &quot;Hey, I&#39;m going to need the next cache line soon,&quot; so it fetches memory from RAM to L1 cache while we process the current chunk.</li>\n</ul>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-011.svg\" alt=\"Memcpy Size Thresholds\"></p>\n<p><em>The Strategic Map. The code branches based on size. Note how the strategies shift from GPR (General Purpose Registers) to XMM/YMM, and finally to Non-Temporal strategies.</em></p>\n<h3 id=\"tier-3-the-huge-path-gt-4kb-cache-size\">Tier 3: The Huge Path (&gt; 4KB / Cache Size)</h3>\n<p><strong>Mechanism:</strong> Non-Temporal Stores (<code>MOVNT</code>).\nWhen data is larger than the CPU cache, bringing it <em>into</em> the cache is wasteful because we will overwrite it before we read it again.</p>\n<ul>\n<li><strong>The Bypass:</strong> We use intrinsics like <code>_mm256_stream_si256</code>. This writes data <strong>directly to RAM</strong>, skipping the cache hierarchy.</li>\n</ul>\n<p>{{DIAGRAM:diag-014}}\n<em>Microscopic view of the &quot;Freight Train.&quot; Standard stores go through L1 -&gt; L2 -&gt; L3 -&gt; RAM. Non-temporal stores (Streaming Stores) bypass the cache, preventing &quot;cache pollution.&quot;</em></p>\n<h2 id=\"4-the-debugging-lab\">4. The Debugging Lab</h2>\n<h3 id=\"a-the-overlap-catastrophe-memcpy-vs-memmove\">A. The Overlap Catastrophe (<code>memcpy</code> vs <code>memmove</code>)</h3>\n<ul>\n<li><strong>The Scenario:</strong> You want to shift an array to the right by 1 byte. <code>src</code> is index 0, <code>dest</code> is index 1.</li>\n<li><strong>The Bug:</strong> <code>memcpy</code> is designed for <em>disjoint</em> memory. If you copy byte 0 to byte 1, you might overwrite the original byte 1 before you have a chance to copy it.</li>\n<li><strong>The Fix:</strong> Always ask: &quot;Can these pointers overlap?&quot; If yes, copy <strong>backwards</strong> (tail to head) or use <code>memmove</code>.</li>\n</ul>\n<h3 id=\"b-the-unaligned-crash\">B. The Unaligned Crash</h3>\n<ul>\n<li><strong>The Scenario:</strong> You cast a <code>char*</code> to <code>__m256i*</code> to use AVX load instructions.</li>\n<li><strong>The Bug:</strong> If the pointer address isn&#39;t divisible by 32, <code>_mm256_load_si256</code> will Segfault.</li>\n<li><strong>The Fix:</strong> Use <code>_mm256_loadu_si256</code> (the &#39;u&#39; stands for Unaligned). Modern Intel/AMD CPUs handle unaligned loads with almost zero penalty.</li>\n</ul>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-013.svg\" alt=\"Unaligned Copy Handling\"></p>\n<p><em>Handling alignment. Notice how we might handle the &quot;Head&quot; (the few bytes before the first 32-byte boundary) using scalar code, then blast through the &quot;Body&quot; with AVX, and finish the &quot;Tail&quot; with scalar.</em></p>\n<h2 id=\"5-code-scaffold\">5. Code Scaffold</h2>\n<p>We will build a <strong>Smart Copy Engine</strong> that implements a simplified version of the Tier 1 and Tier 2 strategies.</p>\n<p><strong>Your Task:</strong></p>\n<ol>\n<li>Handle tiny copies with a switch statement (fastest dispatch).</li>\n<li>Handle medium copies with an AVX2 loop.</li>\n<li>Handle the &quot;Tail&quot; (leftover bytes) gracefully.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;immintrin.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstring></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iostream></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MemoryEngine</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> smart_copy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> dest</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#FFAB70\"> src</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint8_t*</span><span style=\"color:#E1E4E8\"> d </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> static_cast&#x3C;uint8_t*></span><span style=\"color:#E1E4E8\">(dest);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> uint8_t*</span><span style=\"color:#E1E4E8\"> s </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> static_cast&#x3C;const</span><span style=\"color:#F97583\"> uint8_t*></span><span style=\"color:#E1E4E8\">(src);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // --- TIER 1: The Tiny Path (&#x3C; 32 Bytes) ---</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Quick Breakdown:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // We avoid the overhead of setting up vector loops.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // We treat small copies as simple integer assignments.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (count </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (count </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Copy 16 bytes, then copy the LAST 16 bytes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // It's okay if they overlap! It's safer/faster than a loop.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                __m128i head </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_loadu_si128</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;const</span><span style=\"color:#E1E4E8\"> __m128i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(s));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                __m128i tail </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_loadu_si128</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;const</span><span style=\"color:#E1E4E8\"> __m128i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(s </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                _mm_storeu_si128</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;</span><span style=\"color:#E1E4E8\">__m128i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(d), head);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                _mm_storeu_si128</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;</span><span style=\"color:#E1E4E8\">__m128i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(d </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">), tail);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Fallback for very small strings</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            while</span><span style=\"color:#E1E4E8\"> (count</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">d</span><span style=\"color:#F97583\">++</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">s</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // --- TIER 2: The AVX Path (>= 32 Bytes) ---</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> avx_limit </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (count </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 1. Bulk Copy (The Moving Van)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Process 32 bytes per cycle.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> avx_limit; i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Load 256 bits (Unsafe/Unaligned load)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m256i chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm256_loadu_si256</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;const</span><span style=\"color:#E1E4E8\"> __m256i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(s </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Store 256 bits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // In a 'Huge' tier (> 1MB), we would use _mm256_stream_si256 here</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            _mm256_storeu_si256</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;</span><span style=\"color:#E1E4E8\">__m256i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(d </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i), chunk);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 2. Transition Cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Standard practice when mixing AVX with potentially legacy code later</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        _mm256_zeroupper</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 3. The Tail</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // We have 0 to 31 bytes left. </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // We could loop byte-by-byte, but there's a trick:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Just copy the LAST 32 bytes of the source to the LAST 32 bytes of dest.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // It overlaps with what we just wrote, but who cares? It's correct data.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> count) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            size_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m256i tail_chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm256_loadu_si256</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;const</span><span style=\"color:#E1E4E8\"> __m256i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(s </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> offset));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            _mm256_storeu_si256</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;</span><span style=\"color:#E1E4E8\">__m256i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(d </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> offset), tail_chunk);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            _mm256_zeroupper</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- Test Harness ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\"> SIZE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\"> source[SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\"> destination[SIZE];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Setup Data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> SIZE; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) source[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\">)(i </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 255</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">memset</span><span style=\"color:#E1E4E8\">(destination, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, SIZE);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Running Smart Copy...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    MemoryEngine</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">smart_copy</span><span style=\"color:#E1E4E8\">(destination, source, SIZE);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> match </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> SIZE; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (source[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> destination[i]) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            match </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"Mismatch at index \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (match) </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Success: 1024 bytes copied perfectly.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<div id=\"ms-5\"></div>\n\n<h1 id=\"checksum-core-the-digital-fingerprint-factory\">Checksum Core: The Digital Fingerprint Factory</h1>\n<h2 id=\"1-the-epiphany-the-origami-master\">1. The Epiphany: The Origami Master</h2>\n<p>Imagine you have a strip of paper 10 miles long (a large file), and you need to verify that not a single fiber of that paper has been torn or stained.</p>\n<ul>\n<li><strong>The Scalar Approach:</strong> You walk down the 10-mile strip, examining one inch at a time, keeping a running tally in your head. It takes forever.</li>\n<li><strong>The SIMD Approach (Folding):</strong> You don&#39;t walk. You grab the strip at the 1-mile mark, the 2-mile mark, and the 3-mile mark. You fold the paper over onto itself. You crunch 128 inches of paper into a single layer simultaneously. You keep folding this massive strip until it fits into a tiny square in your pocket.</li>\n</ul>\n<p>That tiny square is your <strong>Checksum</strong>. If even one inch of the 10-mile strip was different, the folds wouldn&#39;t line up, and your final square would look different.</p>\n<h2 id=\"2-technical-rationale\">2. Technical Rationale</h2>\n<p>Why do we need complex instructions for a simple sum?</p>\n<ol>\n<li><strong>Data Integrity:</strong> Network packets and SSDs rely on CRC (Cyclic Redundancy Check) to ensure data wasn&#39;t corrupted in transit.</li>\n<li><strong>The &quot;Carry&quot; Problem:</strong> Normal math handles &quot;carries&quot; (e.g., $15 + 15 = 30$). CRC math acts like a zipper—it doesn&#39;t want carries; it wants XORs. Standard CPU multiplication is useless here because it propagates carries.</li>\n<li><strong>The Solution:</strong> Intel introduced <strong>PCLMULQDQ</strong> (Carry-Less Multiplication Quadword). It allows the CPU to perform the complex polynomial math required for CRCs on 128 bits at a time, effectively &quot;folding&quot; memory blocks at RAM speeds.</li>\n</ol>\n<h2 id=\"3-internal-mechanics-the-fold-and-the-crush\">3. Internal Mechanics: The Fold and The Crush</h2>\n<p>We are building a pipeline that ingests data and reduces it.</p>\n<h3 id=\"phase-1-the-selector\">Phase 1: The Selector</h3>\n<p>First, we check what tools we have. Do we have the specialized hardware (PCLMULQDQ) or do we use a fast general-purpose hash (like xxHash)?</p>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-015.svg\" alt=\"Checksum Algorithm Selector\"></p>\n<p><em>The Dispatcher. The system checks CPUID features. If PCLMULQDQ is present, it routes to the hardware CRC path. Otherwise, it falls back to scalar lookup tables.</em></p>\n<h3 id=\"phase-2-the-fold-pclmulqdq\">Phase 2: The Fold (PCLMULQDQ)</h3>\n<p><strong>Quick Breakdown:</strong> <code>_mm_clmulepi64_si128</code></p>\n<ul>\n<li><strong>Carry-Less:</strong> Think of this as &quot;XOR Multiplication.&quot; It multiplies numbers but drops the &quot;carry&quot; bit logic used in standard arithmetic. This is exactly how binary polynomials behave in Galois Fields (GF(2)).</li>\n<li><strong>Folding:</strong> We load 128 bits. We multiply the top half by a magic constant (the polynomial) and XOR the result with the next block of data. This &quot;folds&quot; the old data into the new data.</li>\n</ul>\n<p>{{DIAGRAM:diag-016}}\n<em>Microscopic view of CRC32C. Notice the &quot;Barrett Reduction.&quot; We don&#39;t just sum numbers; we continuously multiply and XOR to keep the &quot;Remainder&quot; within the bounds of the 32-bit register.</em></p>\n<h3 id=\"phase-3-the-horizontal-sum-the-crush\">Phase 3: The Horizontal Sum (The Crush)</h3>\n<p>Once we have processed the whole file, we often end up with a 128-bit vector (<code>__m128i</code>) containing partial sums in different &quot;lanes.&quot; We need to crush this down to a single integer.</p>\n<ul>\n<li><strong>Horizontal Add (<code>PHADD</code>):</strong> Adds adjacent elements within the <em>same</em> register.</li>\n<li><strong>Extraction:</strong> Finally, we move the bottom 32/64 bits from the vector register to a general-purpose register (<code>RAX</code>) to return the result.</li>\n</ul>\n<p>{{DIAGRAM:diag-018}}\n<em>Visualizing the Horizontal Reduction. We start with 4 separate sums in one register. We shuffle and add them until a single scalar value remains.</em></p>\n<h2 id=\"4-the-debugging-lab\">4. The Debugging Lab</h2>\n<h3 id=\"a-the-quotreflectedquot-nightmare\">A. The &quot;Reflected&quot; Nightmare</h3>\n<ul>\n<li><strong>The Myth:</strong> &quot;Bits are bits. $1$ is $1$.&quot;</li>\n<li><strong>The Reality:</strong> CRC algorithms often process bits &quot;backwards&quot; (Least Significant Bit first).</li>\n<li><strong>The Bug:</strong> You implement the math perfectly, but your checksum doesn&#39;t match the standard implementation (like <code>gzip</code> or <code>ethernet</code>).</li>\n<li><strong>The Fix:</strong> You might need to reverse the bits of your input bytes or your final result. This is called &quot;Reflection.&quot;</li>\n</ul>\n<h3 id=\"b-the-buffer-over-read\">B. The Buffer Over-read</h3>\n<ul>\n<li><strong>The Scenario:</strong> You are folding 128 bits (16 bytes) at a time. Your file is 20 bytes long.</li>\n<li><strong>The Bug:</strong> You process the first 16 bytes. You try to load the next 16 bytes, but only 4 bytes remain valid. You segfault or read garbage memory.</li>\n<li><strong>The Fix:</strong> Similiar to <code>memcpy</code>, you must have a &quot;cleanup&quot; loop. Process the bulk with SIMD, then switch to a byte-by-byte scalar loop for the last few bytes.</li>\n</ul>\n<h2 id=\"5-code-scaffold\">5. Code Scaffold</h2>\n<p>We will implement a <strong>Horizontal XOR Reduction</strong>. This is the simplest form of a checksum (Parity Check). It demonstrates how to &quot;crush&quot; a 128-bit vector into a single integer.</p>\n<p><strong>Your Task:</strong></p>\n<ol>\n<li>Load data into a vector.</li>\n<li>Use <code>_mm_xor_si128</code> to combine data (The simplified &quot;Fold&quot;).</li>\n<li>Implement the &quot;Horizontal Reduction&quot; to get the final scalar.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;immintrin.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstdint></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iostream></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;numeric></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParityChecksum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculates a 32-bit XOR checksum of a large buffer.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This isn't CRC32, but it teaches the \"Fold and Crush\" mechanics.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> calculate_xor32</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> uint32_t*</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Accumulator: Starts at zero</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        __m128i v_acc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_setzero_si128</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 1. The SIMD Loop (Process 4 integers at a time)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (; i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#F97583\"> &#x3C;=</span><span style=\"color:#E1E4E8\"> count; i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Load 128 bits (4 x 32-bit integers)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            __m128i v_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_loadu_si128</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">reinterpret_cast&#x3C;const</span><span style=\"color:#E1E4E8\"> __m128i</span><span style=\"color:#F97583\">*></span><span style=\"color:#E1E4E8\">(data </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // The \"Fold\": Simple XOR in this case</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            v_acc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_xor_si128</span><span style=\"color:#E1E4E8\">(v_acc, v_data);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // At this point, v_acc contains [ A, B, C, D ]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // We need to calculate A ^ B ^ C ^ D</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 2. The Horizontal Reduction (The Crush)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Copy high 64-bits to low 64-bits and XOR</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // v_acc: [ A, B, C, D ]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // high:  [ -, -, A, B ]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // res1:  [ ?, ?, A^C, B^D ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        __m128i v_high </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_unpackhi_epi64</span><span style=\"color:#E1E4E8\">(v_acc, v_acc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        v_acc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_xor_si128</span><span style=\"color:#E1E4E8\">(v_acc, v_high);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Now we have two 32-bit values in the bottom 64 bits: (A^C) and (B^D)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // We need to XOR those two together.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Shuffle the second 32-bit integer to the first slot</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 0b11100101 -> Shuffle control (Standard shuffle trick)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        __m128i v_shuffle </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_shuffle_epi32</span><span style=\"color:#E1E4E8\">(v_acc, </span><span style=\"color:#B392F0\">_MM_SHUFFLE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        v_acc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_xor_si128</span><span style=\"color:#E1E4E8\">(v_acc, v_shuffle);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 3. Extract the Scalar</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm_cvtsi128_si32</span><span style=\"color:#E1E4E8\">(v_acc);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 4. Handle the Tail (Scalar cleanup)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> count; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">^=</span><span style=\"color:#E1E4E8\"> data[i];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- Test Harness ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create a vector of numbers: 0, 1, 2... 10</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;uint32_t></span><span style=\"color:#E1E4E8\"> numbers;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\">11</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) numbers.</span><span style=\"color:#B392F0\">push_back</span><span style=\"color:#E1E4E8\">(i);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected Result: 0^1^2^3...^10</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> expected </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> n : numbers) expected </span><span style=\"color:#F97583\">^=</span><span style=\"color:#E1E4E8\"> n;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SIMD Result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> calculated </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ParityChecksum</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">calculate_xor32</span><span style=\"color:#E1E4E8\">(numbers.</span><span style=\"color:#B392F0\">data</span><span style=\"color:#E1E4E8\">(), numbers.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Expected XOR: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> expected </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> SIMD XOR:     \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> calculated </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (expected </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> calculated) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Success: Horizontal reduction matches.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Failure: Check algorithm logic.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<div id=\"ms-6\"></div>\n\n<h1 id=\"runtime-dispatch-the-chameleon-architecture\">Runtime Dispatch: The Chameleon Architecture</h1>\n<h2 id=\"1-the-epiphany-the-universal-socket-wrench\">1. The Epiphany: The Universal Socket Wrench</h2>\n<p>Imagine you are a mechanic (the Compiler) sending a toolkit (your Program) to a garage (the User&#39;s Computer). You have no idea what kind of bolts (CPU Architecture) that garage uses.</p>\n<ul>\n<li><strong>The Static Build:</strong> You send only a metric wrench. If the garage uses imperial bolts, the tool is useless (Crash/Illegal Instruction).</li>\n<li><strong>The Lowest Common Denominator:</strong> You send a pair of pliers. It works on everything, but it strips the bolts and takes 10 hours to finish a 10-minute job (Scalar/Slow).</li>\n<li><strong>The Runtime Dispatch (The Chameleon):</strong> You send a box containing <em>every</em> type of wrench—Metric, Imperial, Torx. When the mechanic opens the box, a smart sensor scans the bolt, selects the perfect wrench, and snaps it onto the handle.</li>\n</ul>\n<p>In Systems Programming, we don&#39;t know if the user has a 2012 laptop or a 2024 Server. <strong>Runtime Dispatch</strong> allows our binary to contain code for <em>all</em> of them and switch to the best one instantly.</p>\n<h2 id=\"2-technical-rationale\">2. Technical Rationale</h2>\n<p>Why not just compile with <code>-march=native</code>?</p>\n<ol>\n<li><strong>Portability:</strong> If you compile specifically for your machine, that binary will crash on your grandmother&#39;s laptop (Illegal Instruction: <code>SIGILL</code>).</li>\n<li><strong>Performance:</strong> If you compile for &quot;generic&quot; x64, you leave 4x to 8x performance gains on the table by ignoring AVX2 or AVX-512 features.</li>\n<li><strong>The Goal:</strong> Write one binary that runs safely everywhere but runs <em>fast</em> on modern hardware.</li>\n</ol>\n<h2 id=\"3-internal-mechanics-the-hot-swap\">3. Internal Mechanics: The Hot-Swap</h2>\n<p>How do we switch code while the program is running? We use <strong>Function Pointers</strong>.</p>\n<h3 id=\"the-quotlazyquot-resolver\">The &quot;Lazy&quot; Resolver</h3>\n<p>We don&#39;t want to check <code>CPUID</code> every time we call a function (that&#39;s too slow). We want to check it <strong>once</strong>, the first time the function is called.</p>\n<ol>\n<li><strong>The Setup:</strong> We create a global function pointer called <code>my_memcpy</code>. Initially, it points to a setup function called <code>resolve_memcpy</code>.</li>\n<li><strong>The First Call:</strong> The user calls <code>my_memcpy</code>. The CPU jumps to <code>resolve_memcpy</code>.</li>\n<li><strong>The Decision:</strong> <code>resolve_memcpy</code> asks the CPU: &quot;Do you have AVX2?&quot;</li>\n<li><strong>The Hot-Patch:</strong><ul>\n<li>If Yes: It updates the global <code>my_memcpy</code> pointer to point to <code>memcpy_avx2</code>.</li>\n<li>If No: It updates the pointer to <code>memcpy_scalar</code>.</li>\n</ul>\n</li>\n<li><strong>The Execution:</strong> It runs the chosen function immediately so the user doesn&#39;t notice.</li>\n<li><strong>The Future:</strong> The <em>next</em> time the user calls <code>my_memcpy</code>, the pointer already points to the optimized version. The <code>resolve</code> function is never called again.</li>\n</ol>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-004.svg\" alt=\"Runtime Dispatch Architecture\"></p>\n<p><em>The Dispatch Flow. Note the transition from Initialization (Red) to Optimized Path (Green). The &quot;Resolver&quot; modifies the Function Table in memory, permanently altering the program&#39;s behavior for the rest of its life.</em></p>\n<h2 id=\"4-the-debugging-lab\">4. The Debugging Lab</h2>\n<h3 id=\"a-the-quotthread-racequot-condition\">A. The &quot;Thread Race&quot; Condition</h3>\n<ul>\n<li><strong>The Scenario:</strong> Two threads call <code>my_memcpy</code> at the exact same time on startup.</li>\n<li><strong>The Bug:</strong> Thread A enters the resolver. Thread B enters the resolver. Thread A updates the pointer. Thread B updates the pointer again.</li>\n<li><strong>The Fix:</strong> In this specific case, it&#39;s usually benign (they both write the same address). However, strictly speaking, you should use <code>std::call_once</code> or atomic operations to ensure the transition is thread-safe.</li>\n</ul>\n<h3 id=\"b-the-os-lie\">B. The OS Lie</h3>\n<ul>\n<li><strong>The Scenario:</strong> <code>CPUID</code> says &quot;AVX Supported!&quot; but the program crashes with <code>SIGILL</code> anyway.</li>\n<li><strong>The Reason:</strong> The CPU hardware supports it, but the Operating System (Kernel) has disabled it, or doesn&#39;t support saving the massive AVX registers during context switches.</li>\n<li><strong>The Fix:</strong> A proper dispatcher checks both the CPU features <em>and</em> the OS capabilities (via <code>XGETBV</code> instruction) to ensure the registers are actually usable.</li>\n</ul>\n<h2 id=\"5-code-scaffold\">5. Code Scaffold</h2>\n<p>We will build a <strong>Self-Optimizing Maths Function</strong>. It will calculate the dot product of two arrays.</p>\n<p><strong>Your Task:</strong></p>\n<ol>\n<li>Define the function pointer type.</li>\n<li>Implement a &quot;Safe&quot; version (Scalar) and a &quot;Fast&quot; version (AVX2 stub).</li>\n<li>Implement the &quot;Resolver&quot; that rewires the connection.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iostream></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;immintrin.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 1. Define the Interface</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is the \"Handle\" of our socket wrench.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> float</span><span style=\"color:#E1E4E8\"> (*dot_product_t)(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- Implementation A: The Safe Fallback (Scalar) ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">float</span><span style=\"color:#B392F0\"> dot_product_scalar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> n</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> sum </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> n; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sum </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> a[i] </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> b[i];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> sum;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- Implementation B: The Speedster (AVX2) ---</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Quick Breakdown:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// _mm256_fmadd_ps: Fused Multiply-Add. (a * b) + c in one step.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">float</span><span style=\"color:#B392F0\"> dot_product_avx2</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> n</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    __m256 v_sum </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm256_setzero_ps</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Process 8 floats at a time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (; i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#F97583\"> &#x3C;=</span><span style=\"color:#E1E4E8\"> n; i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        __m256 va </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm256_loadu_ps</span><span style=\"color:#E1E4E8\">(a </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        __m256 vb </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm256_loadu_ps</span><span style=\"color:#E1E4E8\">(b </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        v_sum </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _mm256_fmadd_ps</span><span style=\"color:#E1E4E8\">(va, vb, v_sum);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Horizontal reduction (Crush 8 floats to 1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (Simplified for brevity - typically involves shuffles)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> temp[</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    _mm256_storeu_ps</span><span style=\"color:#E1E4E8\">(temp, v_sum);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> final_sum </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> j</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">; j</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) final_sum </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> temp[j];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Tail cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> n; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        final_sum </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> a[i] </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> b[i];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> final_sum;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- The Dispatcher Mechanics ---</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Forward declaration of the pointer</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">dot_product_t</span><span style=\"color:#E1E4E8\"> dot_product_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The Resolver Function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">float</span><span style=\"color:#B392F0\"> resolve_dot_product</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> n</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"[System] Resolving CPU features...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Detection Logic (Mocked for this example)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // In reality, you check __builtin_cpu_supports(\"avx2\")</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> has_avx2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Let's pretend we have it</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (has_avx2) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"[System] AVX2 Detected. Hot-patching to Fast Path.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dot_product_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">dot_product_avx2;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"[System] Old CPU Detected. Fallback to Scalar Path.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dot_product_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">dot_product_scalar;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Execute the chosen function for THIS call</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> dot_product_ptr</span><span style=\"color:#E1E4E8\">(a, b, n);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize the pointer to the Resolver</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is the \"Magic\" - the first call goes to the resolver.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">dot_product_t</span><span style=\"color:#E1E4E8\"> dot_product_dispatch </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [](</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> n</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#F97583\">float</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> resolve_dot_product</span><span style=\"color:#E1E4E8\">(a, b, n);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Global wrapper for ease of use</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">float</span><span style=\"color:#B392F0\"> compute_dot_product</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">float</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> v1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">float</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> v2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We update the GLOBAL pointer if it hasn't been set</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (dot_product_ptr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // First run logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> dot_product_dispatch</span><span style=\"color:#E1E4E8\">(v1.</span><span style=\"color:#B392F0\">data</span><span style=\"color:#E1E4E8\">(), v2.</span><span style=\"color:#B392F0\">data</span><span style=\"color:#E1E4E8\">(), v1.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Fast path for all subsequent runs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> dot_product_ptr</span><span style=\"color:#E1E4E8\">(v1.</span><span style=\"color:#B392F0\">data</span><span style=\"color:#E1E4E8\">(), v2.</span><span style=\"color:#B392F0\">data</span><span style=\"color:#E1E4E8\">(), v1.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;float></span><span style=\"color:#B392F0\"> v1</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;float></span><span style=\"color:#B392F0\"> v2</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Call #1:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> res1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> compute_dot_product</span><span style=\"color:#E1E4E8\">(v1, v2);</span><span style=\"color:#6A737D\"> // Triggers resolver</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"Result: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> res1 </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Call #2:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> res2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> compute_dot_product</span><span style=\"color:#E1E4E8\">(v1, v2);</span><span style=\"color:#6A737D\"> // Goes straight to AVX2</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"Result: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> res2 </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<div id=\"ms-7\"></div>\n\n<h1 id=\"testing-amp-validation-the-crash-test-dummy-laboratory\">Testing &amp; Validation: The Crash Test Dummy Laboratory</h1>\n<h2 id=\"1-the-epiphany-the-off-road-test-track\">1. The Epiphany: The Off-Road Test Track</h2>\n<p>Imagine you have built a Ferrari (your optimized AVX2 function). It looks fast, and it drives beautifully on a perfectly smooth, straight highway (aligned memory, standard sizes).</p>\n<p>But the real world isn&#39;t a highway. It&#39;s full of potholes, icy patches, and sudden brick walls.</p>\n<ul>\n<li><strong>Standard Testing:</strong> Driving the Ferrari around the block once. &quot;It starts, so it works.&quot;</li>\n<li><strong>Systems Validation:</strong> Driving the Ferrari into a brick wall at 100mph to see if the airbag works. Driving it on ice (unaligned memory). Driving it with only a thimble of gas (0-byte length). Driving it right up to the edge of a cliff (Memory Page Boundaries).</li>\n</ul>\n<p>In SIMD programming, speed is useless without correctness. Because we are manipulating memory manually, a single off-by-one error doesn&#39;t just give the wrong answer—it crashes the entire application (Segmentation Fault).</p>\n<h2 id=\"2-technical-rationale\">2. Technical Rationale</h2>\n<p>Why do we need a &quot;Torture Chamber&quot; for our code?</p>\n<ol>\n<li><strong>The Oracle Problem:</strong> How do you know your complex AVX-512 Dot Product is correct? You don&#39;t calculate it by hand. You compare it against a &quot;Golden Standard&quot;—a slow, boring, scalar C++ implementation that you <em>know</em> is correct.</li>\n<li><strong>The Alignment Trap:</strong> Instructions like <code>vmovaps</code> (Move Aligned Packed Single) are faster but will crash instantly if the memory address isn&#39;t divisible by 16 or 32. Your test harness must deliberately feed unaligned addresses to ensure your fallback logic works.</li>\n<li><strong>The Page Boundary:</strong> The most dangerous bug in systems programming. Operating Systems manage memory in &quot;Pages&quot; (usually 4096 bytes). If your SIMD instruction tries to read 16 bytes, but only 4 bytes are left in the current page, and the <em>next</em> page belongs to another process, the OS kills your program instantly.</li>\n</ol>\n<h2 id=\"3-internal-mechanics-coverage-amp-the-guard\">3. Internal Mechanics: Coverage &amp; The Guard</h2>\n<p>To validate a system like this, we need a Matrix of Doom.</p>\n<h3 id=\"a-the-test-matrix\">A. The Test Matrix</h3>\n<p>We don&#39;t just test random inputs. We iterate through every dangerous combination.</p>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-019.svg\" alt=\"Test Matrix Coverage\"></p>\n<p><em>The Test Matrix Coverage. Notice the axes: Data Size (0 to Large), Alignment (0 to Cache Line), and CPU Generation. We must test the intersection of &quot;Unaligned Source&quot; + &quot;Aligned Destination&quot; + &quot;Tiny Size.&quot;</em></p>\n<h3 id=\"b-the-oracle-pattern\">B. The Oracle Pattern</h3>\n<p>Every test follows this structure:</p>\n<ol>\n<li><strong>Generate Random Data:</strong> Fill a buffer with garbage.</li>\n<li><strong>Run Scalar:</strong> Result A (The Truth).</li>\n<li><strong>Run SIMD:</strong> Result B (The Candidate).</li>\n<li><strong>Assert:</strong> <code>Result A == Result B</code>.</li>\n</ol>\n<h3 id=\"c-the-page-guard\">C. The Page Guard</h3>\n<p>To catch &quot;Over-reading,&quot; we use a trick. We allocate a buffer that ends <em>exactly</em> at a protected memory page.</p>\n<ul>\n<li><strong>Normal Alloc:</strong> <code>[ Data ... ] [ More Free Heap space ... ]</code> -&gt; Safe to over-read.</li>\n<li><strong>Guard Alloc:</strong> <code>[ Data ... ] [ PROT_NONE Page ]</code> -&gt; Over-reading triggers a crash immediately.\nThis forces bugs to show themselves during testing, rather than intermittently in production.</li>\n</ul>\n<h2 id=\"4-the-debugging-lab\">4. The Debugging Lab</h2>\n<h3 id=\"a-the-quotlucky-alignmentquot-false-positive\">A. The &quot;Lucky Alignment&quot; False Positive</h3>\n<ul>\n<li><strong>The Scenario:</strong> You write a function that requires aligned memory. You run your test: <code>char buffer[100];</code>. It passes.</li>\n<li><strong>The Bug:</strong> The compiler just happened to place <code>buffer</code> at address <code>0x...00</code> (aligned) by luck. In production, the user passes a pointer at <code>0x...01</code>, and the app explodes.</li>\n<li><strong>The Fix:</strong> Manually offset your pointers in your test. <code>test_func(buffer + 1, size)</code>.</li>\n</ul>\n<h3 id=\"b-the-dirty-registers\">B. The Dirty Registers</h3>\n<ul>\n<li><strong>The Scenario:</strong> Your function works fine in isolation but returns garbage when called after a graphics rendering function.</li>\n<li><strong>The Reason:</strong> You forgot to zero out your accumulator register (<code>_mm256_setzero_si256</code>) before starting your loop. You are adding your data to whatever garbage was left in the register by the previous function.</li>\n<li><strong>The Fix:</strong> Always initialize your vectors.</li>\n</ul>\n<h2 id=\"5-code-scaffold\">5. Code Scaffold</h2>\n<p>We will build a <strong>Torture Harness</strong>. It will verify a standard <code>memcpy</code> against our custom implementation, specifically hunting for alignment bugs.</p>\n<p><strong>Your Task:</strong></p>\n<ol>\n<li>Create an &quot;Oracle&quot; (standard <code>memcpy</code>).</li>\n<li>Create a loop that shifts the start pointer byte-by-byte (0 to 15) to test every alignment.</li>\n<li>Compare the results byte-for-byte.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iostream></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstring></span><span style=\"color:#6A737D\"> // For std::memcpy (The Oracle)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cassert></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- The Subject: Our \"Optimized\" Copy (Mocked) ---</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This mimics a function that might fail on unaligned data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> my_custom_copy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> dest</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#FFAB70\"> src</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> n</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // In a real scenario, this would be your AVX/SSE function.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Here, we just wrap memcpy, but imagine it has bugs!</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">memcpy</span><span style=\"color:#E1E4E8\">(dest, src, n); </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- The Oracle: Truth Source ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> reference_copy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> dest</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#FFAB70\"> src</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> n</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">memcpy</span><span style=\"color:#E1E4E8\">(dest, src, n);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TortureChamber</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Large buffer to play inside</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;uint8_t></span><span style=\"color:#E1E4E8\"> src_buffer;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;uint8_t></span><span style=\"color:#E1E4E8\"> dst_ref;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;uint8_t></span><span style=\"color:#E1E4E8\"> dst_test;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\"> MAX_SIZE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">public:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    TortureChamber</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        src_buffer.</span><span style=\"color:#B392F0\">resize</span><span style=\"color:#E1E4E8\">(MAX_SIZE </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dst_ref.</span><span style=\"color:#B392F0\">resize</span><span style=\"color:#E1E4E8\">(MAX_SIZE </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dst_test.</span><span style=\"color:#B392F0\">resize</span><span style=\"color:#E1E4E8\">(MAX_SIZE </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Fill source with random junk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\">src_buffer.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">(); i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) src_buffer[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t</span><span style=\"color:#E1E4E8\">)(i </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 255</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#B392F0\"> run_alignment_test</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"[Test] Starting Alignment Torture...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Loop 1: Change Size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; size </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 128</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">size) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Loop 2: Change Source Alignment (0 to 15)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> src_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; src_offset </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">src_offset) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Loop 3: Change Dest Alignment (0 to 15)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> dst_offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; dst_offset </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">dst_offset) {</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // Reset destinations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">fill</span><span style=\"color:#E1E4E8\">(dst_ref.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(), dst_ref.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">fill</span><span style=\"color:#E1E4E8\">(dst_test.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(), dst_test.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // Pointers to the \"dangerous\" offsets</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    uint8_t*</span><span style=\"color:#E1E4E8\"> p_src </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> src_buffer.</span><span style=\"color:#B392F0\">data</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> src_offset;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    uint8_t*</span><span style=\"color:#E1E4E8\"> p_ref </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dst_ref.</span><span style=\"color:#B392F0\">data</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> dst_offset;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    uint8_t*</span><span style=\"color:#E1E4E8\"> p_tst </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dst_test.</span><span style=\"color:#B392F0\">data</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> dst_offset;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // 1. Run Oracle</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    reference_copy</span><span style=\"color:#E1E4E8\">(p_ref, p_src, size);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // 2. Run Subject</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    my_custom_copy</span><span style=\"color:#E1E4E8\">(p_tst, p_src, size);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    // 3. Verify</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">memcmp</span><span style=\"color:#E1E4E8\">(p_ref, p_tst, size) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                        std</span><span style=\"color:#E1E4E8\">::cerr </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> FAILURE DETECTED!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                        std</span><span style=\"color:#E1E4E8\">::cerr </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"   Size: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                        std</span><span style=\"color:#E1E4E8\">::cerr </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"   Src Offset: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> src_offset </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                        std</span><span style=\"color:#E1E4E8\">::cerr </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"   Dst Offset: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> dst_offset </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                        std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Success: All alignment combinations verified.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TortureChamber lab;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lab.</span><span style=\"color:#B392F0\">run_alignment_test</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<div id=\"ms-8\"></div>\n\n<h1 id=\"benchmarking-suite-the-scientific-method\">Benchmarking Suite: The Scientific Method</h1>\n<h2 id=\"1-the-epiphany-the-wind-tunnel\">1. The Epiphany: The Wind Tunnel</h2>\n<p>Imagine you are an aerodynamic engineer. You claim your new spoiler design makes the car faster. You drive it around the block. &quot;Feels quicker,&quot; you say.</p>\n<p>This is not science; it&#39;s guessing. In the world of high-performance systems, &quot;feeling&quot; fast is irrelevant. The OS is like the weather—sometimes there&#39;s a headwind (background updates), sometimes a tailwind (CPU frequency scaling).</p>\n<p>To prove your AVX2 <code>memcpy</code> is actually faster than the Standard Library, you need a <strong>Wind Tunnel</strong>:</p>\n<ol>\n<li><strong>Isolation:</strong> No radio, no AC, no passengers (Shut down background tasks).</li>\n<li><strong>Repetition:</strong> You don&#39;t do one lap; you do 10,000 laps to average out the bumps.</li>\n<li><strong>The Control Group:</strong> You always race against a standard car (Baseline Implementation) to calculate the &quot;Speedup Factor.&quot;</li>\n</ol>\n<h2 id=\"2-technical-rationale\">2. Technical Rationale</h2>\n<p>Why can&#39;t we just use <code>time ./my_program</code>?</p>\n<ol>\n<li><strong>Resolution Limits:</strong> System clocks measure in microseconds. Your AVX instruction takes <em>nanoseconds</em>. One run is too fast to measure.</li>\n<li><strong>The Cold Start Problem:</strong> When a CPU first wakes up, it&#39;s groggy. It&#39;s in a low-power state, and its Caches (L1/L2) are empty. The first run is always deceptively slow.</li>\n<li><strong>Dead Code Elimination:</strong> The Compiler is smarter than you. If you write a loop that calculates a value but never <em>prints</em> or <em>uses</em> it, the compiler deletes the loop entirely. Your benchmark will report &quot;0 seconds,&quot; and you will feel like a genius until you realize the code never ran.</li>\n</ol>\n<h2 id=\"3-internal-mechanics-the-stopwatch-amp-the-black-hole\">3. Internal Mechanics: The Stopwatch &amp; The Black Hole</h2>\n<p>To build a trustworthy benchmark, we need three distinct phases.</p>\n<h3 id=\"phase-1-the-warmup-revving-the-engine\">Phase 1: The Warmup (Revving the Engine)</h3>\n<p>We run the function 1,000 times without measuring it. This forces the CPU to:</p>\n<ul>\n<li>Scale up its clock frequency (Turbo Boost).</li>\n<li>Load the data from RAM into the L1 Cache.</li>\n<li>Predict the branch patterns.</li>\n</ul>\n<h3 id=\"phase-2-the-iteration-the-laps\">Phase 2: The Iteration (The Laps)</h3>\n<p>We run the function 1,000,000 times inside a <code>while</code> loop. We measure the <em>total</em> time and divide by the count.</p>\n<h3 id=\"phase-3-the-black-hole-escaping-optimization\">Phase 3: The Black Hole (Escaping Optimization)</h3>\n<p>To stop the compiler from deleting our loop, we feed the result into a <code>volatile</code> variable or a &quot;Black Hole&quot; function. This tricks the compiler into thinking the result is critical, so it <em>must</em> execute the math.</p>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-020.svg\" alt=\"Benchmark Harness Architecture\"></p>\n<p><em>The Benchmark Pipeline. Note the &quot;Warmup&quot; phase (Red) which is discarded. Only the &quot;Steady State&quot; iterations (Green) are recorded. The Statistical Analysis block filters out outliers caused by OS interruptions.</em></p>\n<h3 id=\"quick-breakdown-stdchrono\">Quick Breakdown: <code>std::chrono</code></h3>\n<blockquote>\n<p><strong>High Resolution Clock:</strong> The C++ standard tool for measuring time intervals. It asks the OS for the most precise tick count available (usually nanoseconds).</p>\n</blockquote>\n<h2 id=\"4-the-debugging-lab\">4. The Debugging Lab</h2>\n<h3 id=\"a-the-quotzero-secondquot-miracle\">A. The &quot;Zero Second&quot; Miracle</h3>\n<ul>\n<li><strong>The Symptom:</strong> Your benchmark says your complex matrix multiplication took 0.00ns.</li>\n<li><strong>The Cause:</strong> <strong>Dead Code Elimination</strong>. You calculated the matrix but didn&#39;t return it. The compiler deleted your function call.</li>\n<li><strong>The Fix:</strong> Use <code>DoNotOptimize(result)</code>. In C++, reading/writing to a <code>volatile</code> memory address forces execution.</li>\n</ul>\n<h3 id=\"b-the-throttled-cpu\">B. The Throttled CPU</h3>\n<ul>\n<li><strong>The Symptom:</strong> Your results vary wildly. Run 1: 50ms. Run 2: 120ms.</li>\n<li><strong>The Cause:</strong> Thermal Throttling or Power Saving. Your laptop got hot, so the CPU slowed down. Or, your laptop was unplugged, so it&#39;s saving battery.</li>\n<li><strong>The Fix:</strong> Always benchmark on a plugged-in machine, ideally with &quot;High Performance&quot; power plan enabled.</li>\n</ul>\n<h2 id=\"5-code-scaffold\">5. Code Scaffold</h2>\n<p>We will build a <strong>Micro-Benchmark Runner</strong>. It will race a standard <code>std::accumulate</code> against a manual loop to see which is faster.</p>\n<p><strong>Your Task:</strong></p>\n<ol>\n<li>Implement the <code>escape</code> function (The Black Hole).</li>\n<li>Implement the <code>measure</code> function with a warmup phase.</li>\n<li>Calculate the relative speedup ($Time_{baseline} / Time_{optimized}$).</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iostream></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;vector></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;numeric></span><span style=\"color:#6A737D\"> // for std::accumulate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;chrono></span><span style=\"color:#6A737D\">  // for time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cmath></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- The Black Hole ---</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This prevents the compiler from optimizing away our loops.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// We tell the compiler: \"This value is modified externally, don't touch it.\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> T</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> do_not_optimize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">T</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    asm</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\"> : </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#9ECBFF\">+r</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">(value)); </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- The Subjects ---</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 1. The Baseline (Standard Library)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#B392F0\"> baseline_algo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">accumulate</span><span style=\"color:#E1E4E8\">(data.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(), data.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#F97583\">LL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 2. The Challenger (Manual Loop)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#B392F0\"> challenge_algo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> sum </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> x : data) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sum </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> x;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> sum;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- The Harness ---</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#B392F0\"> BenchResult</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::string name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> duration_ms;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">template</span><span style=\"color:#E1E4E8\"> &#x3C;</span><span style=\"color:#F97583\">typename</span><span style=\"color:#B392F0\"> Func</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">BenchResult</span><span style=\"color:#B392F0\"> run_benchmark</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">string</span><span style=\"color:#FFAB70\"> name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Func</span><span style=\"color:#FFAB70\"> func</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">vector</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">></span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    using</span><span style=\"color:#F97583\"> namespace</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">chrono</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> dummy_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. WARMUP (Rev the engine)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Run for a bit to fill cache and wake up CPU</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dummy_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> func</span><span style=\"color:#E1E4E8\">(data);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        do_not_optimize</span><span style=\"color:#E1E4E8\">(dummy_result);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. MEASURE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> iterations </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    auto</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> high_resolution_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> iterations; </span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">i) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dummy_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> func</span><span style=\"color:#E1E4E8\">(data);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // CRITICAL: Force the compiler to believe this result is used</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        do_not_optimize</span><span style=\"color:#E1E4E8\">(dummy_result);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    auto</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> high_resolution_clock</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. CALCULATE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    duration</span><span style=\"color:#F97583\">&#x3C;double</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::milli</span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> {name, ms.</span><span style=\"color:#B392F0\">count</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> iterations};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Setup Data (1 Million Integers)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::vector</span><span style=\"color:#F97583\">&#x3C;int></span><span style=\"color:#B392F0\"> data</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">fill</span><span style=\"color:#E1E4E8\">(data.</span><span style=\"color:#B392F0\">begin</span><span style=\"color:#E1E4E8\">(), data.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Benchmarking on \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> data.</span><span style=\"color:#B392F0\">size</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \" elements...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Run Races</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    auto</span><span style=\"color:#E1E4E8\"> res_base </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> run_benchmark</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"std::accumulate\"</span><span style=\"color:#E1E4E8\">, baseline_algo, data);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    auto</span><span style=\"color:#E1E4E8\"> res_opt  </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> run_benchmark</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Manual Loop\"</span><span style=\"color:#E1E4E8\">,     challenge_algo, data);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Report</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"------------------------------------------------</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> res_base.name </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \": \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> res_base.duration_ms </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \" ms/iter</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> res_opt.name  </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \": \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> res_opt.duration_ms  </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \" ms/iter</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"------------------------------------------------</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> speedup </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> res_base.duration_ms </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> res_opt.duration_ms;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Speedup Factor: \"</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> speedup </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \"x</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (speedup </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Winner: Manual Loop</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::cout </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#9ECBFF\"> \">> Winner: Standard Library (Compilers are smart!)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n<div id=\"ms-9\"></div>\n\n<h1 id=\"library-integration-the-public-face\">Library Integration: The Public Face</h1>\n<h2 id=\"1-the-epiphany-the-dashboard\">1. The Epiphany: The Dashboard</h2>\n<p>You have just spent weeks building a V12 engine (your AVX-512 optimized algorithms). It is powerful, complex, and dangerous.\nIf you hand this engine to a driver (a consumer developer) with a bundle of loose wires and say, &quot;Touch the red wire to the blue wire to inject fuel,&quot; they will crash.</p>\n<p>A Library API is the <strong>Car Dashboard</strong>.</p>\n<ul>\n<li><strong>The Steering Wheel:</strong> The public function <code>compute_dot_product()</code>. It’s clean, ergonomic, and doesn&#39;t scare the driver.</li>\n<li><strong>The Engine Cover:</strong> The internal files (<code>.cpp</code>). We hide the complex fuel injection timing (AVX registers, dispatch tables) underneath. The driver never sees them.</li>\n<li><strong>The Ignition:</strong> The initialization logic that automatically detects the CPU type. The driver just turns the key; they don&#39;t manually select &quot;Spark Plug Mode: Haswell&quot;.</li>\n</ul>\n<h2 id=\"2-technical-rationale\">2. Technical Rationale</h2>\n<p>Why do we spend time wrapping our code? Why not just give them the <code>.cpp</code> file?</p>\n<ol>\n<li><strong>Symbol Pollution:</strong> If you define a global function named <code>init()</code>, and the user also has a function named <code>init()</code>, the Linker will panic (Duplicate Symbol Error). We must wrap our code in <strong>Namespaces</strong>.</li>\n<li><strong>The &quot;Mangling&quot; Wall:</strong> C++ compilers change function names to include argument types (e.g., <code>_Z3addii</code> for <code>add(int, int)</code>). C compilers do not (<code>_add</code>). If a C program tries to call your C++ library, it won&#39;t find the name unless you use <code>extern &quot;C&quot;</code>.</li>\n<li><strong>ABI Stability (Binary Compatibility):</strong> If you change the size of a class in your library update, but the user doesn&#39;t recompile their application, their app will crash because it&#39;s looking for data at the wrong offsets. A clean API minimizes these breaking changes.</li>\n</ol>\n<h2 id=\"3-internal-mechanics-the-velvet-rope\">3. Internal Mechanics: The Velvet Rope</h2>\n<p>To create a professional library, we must control exactly what the outside world sees.</p>\n<h3 id=\"a-the-export-macro\">A. The Export Macro</h3>\n<p>Operating Systems hide symbols by default (or expose everything, depending on the compiler). We need a unified way to say &quot;This function is for the public.&quot;</p>\n<ul>\n<li><strong>Windows (DLL):</strong> Needs <code>__declspec(dllexport)</code> to share a function.</li>\n<li><strong>Linux (GCC/Clang):</strong> Needs <code>__attribute__((visibility(&quot;default&quot;)))</code>.</li>\n</ul>\n<h3 id=\"b-the-header-file-the-contract\">B. The Header File (The Contract)</h3>\n<p>This is the <em>only</em> file the user sees. It must contain:</p>\n<ol>\n<li><strong>Include Guards:</strong> <code>#ifndef LIB_H ...</code> to prevent infinite inclusion loops.</li>\n<li><strong>Extern &quot;C&quot;:</strong> To allow C and Python (via ctypes) to call your code.</li>\n<li><strong>Documentation:</strong> clear comments explaining inputs and outputs.</li>\n</ol>\n<p><img src=\"/api/project/simd-library/architecture-doc/asset?path=diagrams%2Fdiag-021.svg\" alt=\"Public API Surface\"></p>\n<p><em>The Public API Surface. Notice how the internal logic (AVX Dispatcher, Resolver) is completely hidden. The User Application links only against the &quot;Exported Symbols&quot; (The Dashboard).</em></p>\n<h3 id=\"c-the-dispatch-hiding\">C. The Dispatch Hiding</h3>\n<p>The user calls <code>fast_copy()</code>. Internally, we route this to <code>fast_copy_avx2()</code>. The user <em>never</em> sees the AVX2 version in the header. If they did, their compiler might try to compile AVX2 instructions on a machine that doesn&#39;t support them, causing a crash at compile-time or run-time.</p>\n<h2 id=\"4-the-debugging-lab\">4. The Debugging Lab</h2>\n<h3 id=\"a-the-quotundefined-referencequot-nightmare\">A. The &quot;Undefined Reference&quot; Nightmare</h3>\n<ul>\n<li><strong>The Symptom:</strong> You compile your library, then try to use it in a C application. The linker screams: <code>undefined reference to &#39;simd_add&#39;</code>.</li>\n<li><strong>The Cause:</strong> You wrote the library in C++ but forgot to wrap the declaration in <code>extern &quot;C&quot;</code>. The C++ compiler mangled the name to <code>_Z8simd_addv</code>, but the C linker is looking for <code>_simd_add</code>.</li>\n<li><strong>The Fix:</strong> Wrap public headers in the <code>extern &quot;C&quot; { ... }</code> block.</li>\n</ul>\n<h3 id=\"b-the-quotheader-hellquot\">B. The &quot;Header Hell&quot;</h3>\n<ul>\n<li><strong>The Symptom:</strong> Your library works fine, but when the user includes <code>&lt;windows.h&gt;</code> <em>before</em> your library, everything breaks.</li>\n<li><strong>The Cause:</strong> Macro collisions. <code>windows.h</code> often defines macros like <code>min</code> and <code>max</code>. If your header uses a variable named <code>max</code>, the preprocessor replaces it with garbage.</li>\n<li><strong>The Fix:</strong> Keep your public headers minimal. Don&#39;t include heavy system headers in your public API if you can avoid it. Use distinct naming (<code>simd_max</code> instead of <code>max</code>).</li>\n</ul>\n<h2 id=\"5-code-scaffold\">5. Code Scaffold</h2>\n<p>We will build the <strong>Final Integration Layer</strong>. This involves a portable header file and the implementation that bridges the public calls to our internal dispatcher.</p>\n<p><strong>Your Task:</strong></p>\n<ol>\n<li>Create the <code>SIMD_API</code> macro to handle Windows/Linux export differences.</li>\n<li>Wrap the API in a Namespace.</li>\n<li>Implement the &quot;Facade&quot; functions that forward calls to the dispatcher.</li>\n</ol>\n<h3 id=\"part-1-the-public-header-simd_libh\">Part 1: The Public Header (<code>simd_lib.h</code>)</h3>\n<p>This is what you give to the user.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> SIMD_LIB_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> SIMD_LIB_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;cstddef></span><span style=\"color:#6A737D\"> // for size_t</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- 1. Portability Macros ---</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// We need to handle Windows (DLL) vs Linux (Shared Object)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#if</span><span style=\"color:#F97583\"> defined</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">_WIN32</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> SIMD_LIBRARY_EXPORTS</span><span style=\"color:#6A737D\"> // Defined when building the library itself</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        #define</span><span style=\"color:#B392F0\"> SIMD_API</span><span style=\"color:#B392F0\"> __declspec</span><span style=\"color:#E1E4E8\">(dllexport)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        #define</span><span style=\"color:#B392F0\"> SIMD_API</span><span style=\"color:#B392F0\"> __declspec</span><span style=\"color:#E1E4E8\">(dllimport)</span><span style=\"color:#6A737D\"> // Defined when USING the library</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #define</span><span style=\"color:#B392F0\"> SIMD_API</span><span style=\"color:#B392F0\"> __attribute__</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#B392F0\">visibility</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"default\"</span><span style=\"color:#E1E4E8\">)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- 2. C Compatibility ---</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Allows this library to be used by C, C++, Python, Rust, etc.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> __cplusplus</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#9ECBFF\"> \"C\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@brief</span><span style=\"color:#6A737D\"> Computes the dot product of two arrays using the fastest available SIMD instruction set.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#6A737D\"> Pointer to the first array (float).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#6A737D\"> Pointer to the second array (float).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#FFAB70\"> n</span><span style=\"color:#6A737D\"> Number of elements.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@return</span><span style=\"color:#6A737D\"> float The sum of products.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SIMD_API </span><span style=\"color:#F97583\">float</span><span style=\"color:#B392F0\"> simd_dot_product</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#E1E4E8\"> a, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#E1E4E8\"> b, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> n);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@brief</span><span style=\"color:#6A737D\"> High-speed memory copy. Handles alignment automatically.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SIMD_API </span><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> simd_memcpy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> dest, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#E1E4E8\"> src, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> n);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@brief</span><span style=\"color:#6A737D\"> Initialize the library manually (Optional).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Detects CPU features. If not called, the first function call will trigger it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SIMD_API </span><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> simd_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> __cplusplus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // SIMD_LIB_H</span></span></code></pre></div>\n\n<h3 id=\"part-2-the-implementation-simd_libcpp\">Part 2: The Implementation (<code>simd_lib.cpp</code>)</h3>\n<p>This is compiled into your <code>.dll</code> or <code>.so</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">cpp</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"simd_lib.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;iostream></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;mutex></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- INTERNAL Declarations (Not visible to user) ---</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// These are the function pointer types defined in previous sections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> float</span><span style=\"color:#E1E4E8\"> (*dot_product_func)(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> void</span><span style=\"color:#E1E4E8\"> (*memcpy_func)(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Forward declare the resolvers (implemented in cpu_dispatch.cpp)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#B392F0\"> dot_product_func</span><span style=\"color:#B392F0\"> resolve_dot_product_impl</span><span style=\"color:#E1E4E8\">(); </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">extern</span><span style=\"color:#B392F0\"> memcpy_func</span><span style=\"color:#B392F0\"> resolve_memcpy_impl</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Global function pointers, initialized to null</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#E1E4E8\"> dot_product_func g_dot_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#E1E4E8\"> memcpy_func g_copy_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nullptr</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#B392F0\"> std</span><span style=\"color:#E1E4E8\">::once_flag g_init_flag;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- INTERNAL: The Lazy Initializer ---</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> perform_cpu_detection</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This connects the global pointers to the AVX/SSE implementations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    g_dot_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> resolve_dot_product_impl</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    g_copy_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> resolve_memcpy_impl</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // In a real app, you might log here: \"Detected AVX-512 Support\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// --- PUBLIC API Implementation ---</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SIMD_API </span><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> simd_init</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    std</span><span style=\"color:#E1E4E8\">::</span><span style=\"color:#B392F0\">call_once</span><span style=\"color:#E1E4E8\">(g_init_flag, perform_cpu_detection);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SIMD_API </span><span style=\"color:#F97583\">float</span><span style=\"color:#B392F0\"> simd_dot_product</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#E1E4E8\"> a, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> float*</span><span style=\"color:#E1E4E8\"> b, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> n) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Lazy Init: If pointer is null, run detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: We use double-checked locking optimization or std::call_once pattern in production</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For simplicity, we assume simd_init is fast or called once.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">g_dot_ptr) </span><span style=\"color:#B392F0\">simd_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Dispatch</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> g_dot_ptr</span><span style=\"color:#E1E4E8\">(a, b, n);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">SIMD_API </span><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> simd_memcpy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> dest, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#E1E4E8\"> src, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> n) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">g_copy_ptr) </span><span style=\"color:#B392F0\">simd_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    g_copy_ptr</span><span style=\"color:#E1E4E8\">(dest, src, n);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><a href=\"#satellite-map\">↑ Back to System Map</a></p>\n","toc":[{"level":1,"text":"SIMD Optimization Library","id":"simd-optimization-library"},{"level":1,"text":"Foundation &amp; CPU Detection: The Negotiator","id":"foundation-amp-cpu-detection-the-negotiator"},{"level":2,"text":"1. The Epiphany: The Smart Universal Charger","id":"1-the-epiphany-the-smart-universal-charger"},{"level":2,"text":"2. Technical Rationale","id":"2-technical-rationale"},{"level":2,"text":"3. Internal Mechanics: The CPUID Instruction","id":"3-internal-mechanics-the-cpuid-instruction"},{"level":3,"text":"The Protocol","id":"the-protocol"},{"level":2,"text":"4. The Microscope Effect: Parsing the Bits","id":"4-the-microscope-effect-parsing-the-bits"},{"level":2,"text":"5. The Debugging Lab","id":"5-the-debugging-lab"},{"level":3,"text":"A. The &quot;Illegal Instruction&quot; (SIGILL) Crash","id":"a-the-quotillegal-instructionquot-sigill-crash"},{"level":3,"text":"B. The &quot;It works on my machine&quot; Error","id":"b-the-quotit-works-on-my-machinequot-error"},{"level":3,"text":"C. The OS Trap","id":"c-the-os-trap"},{"level":2,"text":"6. Code Scaffold","id":"6-code-scaffold"},{"level":1,"text":"SSE2 &amp; SSE4.2: The Assembly Line","id":"sse2-amp-sse42-the-assembly-line"},{"level":2,"text":"1. The Epiphany: The Bucket Brigade vs. The Forklift","id":"1-the-epiphany-the-bucket-brigade-vs-the-forklift"},{"level":2,"text":"2. Technical Rationale","id":"2-technical-rationale"},{"level":2,"text":"3. Internal Mechanics: The 128-bit Engine","id":"3-internal-mechanics-the-128-bit-engine"},{"level":3,"text":"The Data Type: __m128i","id":"the-data-type-__m128i"},{"level":3,"text":"The Operation: Parallel Comparison","id":"the-operation-parallel-comparison"},{"level":3,"text":"The Advanced Tool: SSE4.2 _mm_cmpistri","id":"the-advanced-tool-sse42-_mm_cmpistri"},{"level":2,"text":"4. The Debugging Lab","id":"4-the-debugging-lab"},{"level":3,"text":"A. The Alignment Trap (Segfaults)","id":"a-the-alignment-trap-segfaults"},{"level":3,"text":"B. The Page Boundary Over-read","id":"b-the-page-boundary-over-read"},{"level":3,"text":"C. The &quot;Ghost&quot; Bytes","id":"c-the-quotghostquot-bytes"},{"level":2,"text":"5. Code Scaffold","id":"5-code-scaffold"},{"level":1,"text":"AVX &amp; AVX2: The Heavy Machinery","id":"avx-amp-avx2-the-heavy-machinery"},{"level":2,"text":"1. The Epiphany: The Delivery Truck vs. The Semi-Trailer","id":"1-the-epiphany-the-delivery-truck-vs-the-semi-trailer"},{"level":2,"text":"2. Technical Rationale","id":"2-technical-rationale"},{"level":2,"text":"3. Internal Mechanics: The YMM Registers","id":"3-internal-mechanics-the-ymm-registers"},{"level":3,"text":"The Data Type: __m256i","id":"the-data-type-__m256i"},{"level":3,"text":"The Instruction Set","id":"the-instruction-set"},{"level":2,"text":"4. The Debugging Lab","id":"4-the-debugging-lab"},{"level":3,"text":"A. The &quot;State Transition&quot; Stall (The AVX-SSE Penalty)","id":"a-the-quotstate-transitionquot-stall-the-avx-sse-penalty"},{"level":3,"text":"B. The 32-Byte Alignment Crash","id":"b-the-32-byte-alignment-crash"},{"level":2,"text":"5. Code Scaffold","id":"5-code-scaffold"},{"level":1,"text":"String Search Primitives: The Needle in the Haystack","id":"string-search-primitives-the-needle-in-the-haystack"},{"level":2,"text":"1. The Epiphany: The Stencil vs. The Magnifying Glass","id":"1-the-epiphany-the-stencil-vs-the-magnifying-glass"},{"level":2,"text":"2. Technical Rationale: The &quot;Swiss Army Knife&quot; Instruction","id":"2-technical-rationale-the-quotswiss-army-knifequot-instruction"},{"level":2,"text":"3. Internal Mechanics: The Programmable Engine","id":"3-internal-mechanics-the-programmable-engine"},{"level":3,"text":"The Inputs","id":"the-inputs"},{"level":3,"text":"The Modes (The Control Byte)","id":"the-modes-the-control-byte"},{"level":3,"text":"The Output","id":"the-output"},{"level":2,"text":"4. The Debugging Lab","id":"4-the-debugging-lab"},{"level":3,"text":"A. The Latency Trap","id":"a-the-latency-trap"},{"level":3,"text":"B. The &quot;Implicit&quot; vs &quot;Explicit&quot; Length","id":"b-the-quotimplicitquot-vs-quotexplicitquot-length"},{"level":2,"text":"5. Code Scaffold","id":"5-code-scaffold"},{"level":1,"text":"Memory Copy Engine: Moving Mountains with Tweezers vs. Dump Trucks","id":"memory-copy-engine-moving-mountains-with-tweezers-vs-dump-trucks"},{"level":2,"text":"1. The Epiphany: The Logistics Manager","id":"1-the-epiphany-the-logistics-manager"},{"level":2,"text":"2. Technical Rationale","id":"2-technical-rationale"},{"level":2,"text":"3. Internal Mechanics: The Decision Tree","id":"3-internal-mechanics-the-decision-tree"},{"level":3,"text":"Tier 1: The Tiny Path (&lt; 16 Bytes)","id":"tier-1-the-tiny-path-lt-16-bytes"},{"level":3,"text":"Tier 2: The SIMD Path (16 Bytes to ~4KB)","id":"tier-2-the-simd-path-16-bytes-to-4kb"},{"level":3,"text":"Tier 3: The Huge Path (&gt; 4KB / Cache Size)","id":"tier-3-the-huge-path-gt-4kb-cache-size"},{"level":2,"text":"4. The Debugging Lab","id":"4-the-debugging-lab"},{"level":3,"text":"A. The Overlap Catastrophe (memcpy vs memmove)","id":"a-the-overlap-catastrophe-memcpy-vs-memmove"},{"level":3,"text":"B. The Unaligned Crash","id":"b-the-unaligned-crash"},{"level":2,"text":"5. Code Scaffold","id":"5-code-scaffold"},{"level":1,"text":"Checksum Core: The Digital Fingerprint Factory","id":"checksum-core-the-digital-fingerprint-factory"},{"level":2,"text":"1. The Epiphany: The Origami Master","id":"1-the-epiphany-the-origami-master"},{"level":2,"text":"2. Technical Rationale","id":"2-technical-rationale"},{"level":2,"text":"3. Internal Mechanics: The Fold and The Crush","id":"3-internal-mechanics-the-fold-and-the-crush"},{"level":3,"text":"Phase 1: The Selector","id":"phase-1-the-selector"},{"level":3,"text":"Phase 2: The Fold (PCLMULQDQ)","id":"phase-2-the-fold-pclmulqdq"},{"level":3,"text":"Phase 3: The Horizontal Sum (The Crush)","id":"phase-3-the-horizontal-sum-the-crush"},{"level":2,"text":"4. The Debugging Lab","id":"4-the-debugging-lab"},{"level":3,"text":"A. The &quot;Reflected&quot; Nightmare","id":"a-the-quotreflectedquot-nightmare"},{"level":3,"text":"B. The Buffer Over-read","id":"b-the-buffer-over-read"},{"level":2,"text":"5. Code Scaffold","id":"5-code-scaffold"},{"level":1,"text":"Runtime Dispatch: The Chameleon Architecture","id":"runtime-dispatch-the-chameleon-architecture"},{"level":2,"text":"1. The Epiphany: The Universal Socket Wrench","id":"1-the-epiphany-the-universal-socket-wrench"},{"level":2,"text":"2. Technical Rationale","id":"2-technical-rationale"},{"level":2,"text":"3. Internal Mechanics: The Hot-Swap","id":"3-internal-mechanics-the-hot-swap"},{"level":3,"text":"The &quot;Lazy&quot; Resolver","id":"the-quotlazyquot-resolver"},{"level":2,"text":"4. The Debugging Lab","id":"4-the-debugging-lab"},{"level":3,"text":"A. The &quot;Thread Race&quot; Condition","id":"a-the-quotthread-racequot-condition"},{"level":3,"text":"B. The OS Lie","id":"b-the-os-lie"},{"level":2,"text":"5. Code Scaffold","id":"5-code-scaffold"},{"level":1,"text":"Testing &amp; Validation: The Crash Test Dummy Laboratory","id":"testing-amp-validation-the-crash-test-dummy-laboratory"},{"level":2,"text":"1. The Epiphany: The Off-Road Test Track","id":"1-the-epiphany-the-off-road-test-track"},{"level":2,"text":"2. Technical Rationale","id":"2-technical-rationale"},{"level":2,"text":"3. Internal Mechanics: Coverage &amp; The Guard","id":"3-internal-mechanics-coverage-amp-the-guard"},{"level":3,"text":"A. The Test Matrix","id":"a-the-test-matrix"},{"level":3,"text":"B. The Oracle Pattern","id":"b-the-oracle-pattern"},{"level":3,"text":"C. The Page Guard","id":"c-the-page-guard"},{"level":2,"text":"4. The Debugging Lab","id":"4-the-debugging-lab"},{"level":3,"text":"A. The &quot;Lucky Alignment&quot; False Positive","id":"a-the-quotlucky-alignmentquot-false-positive"},{"level":3,"text":"B. The Dirty Registers","id":"b-the-dirty-registers"},{"level":2,"text":"5. Code Scaffold","id":"5-code-scaffold"},{"level":1,"text":"Benchmarking Suite: The Scientific Method","id":"benchmarking-suite-the-scientific-method"},{"level":2,"text":"1. The Epiphany: The Wind Tunnel","id":"1-the-epiphany-the-wind-tunnel"},{"level":2,"text":"2. Technical Rationale","id":"2-technical-rationale"},{"level":2,"text":"3. Internal Mechanics: The Stopwatch &amp; The Black Hole","id":"3-internal-mechanics-the-stopwatch-amp-the-black-hole"},{"level":3,"text":"Phase 1: The Warmup (Revving the Engine)","id":"phase-1-the-warmup-revving-the-engine"},{"level":3,"text":"Phase 2: The Iteration (The Laps)","id":"phase-2-the-iteration-the-laps"},{"level":3,"text":"Phase 3: The Black Hole (Escaping Optimization)","id":"phase-3-the-black-hole-escaping-optimization"},{"level":3,"text":"Quick Breakdown: std::chrono","id":"quick-breakdown-stdchrono"},{"level":2,"text":"4. The Debugging Lab","id":"4-the-debugging-lab"},{"level":3,"text":"A. The &quot;Zero Second&quot; Miracle","id":"a-the-quotzero-secondquot-miracle"},{"level":3,"text":"B. The Throttled CPU","id":"b-the-throttled-cpu"},{"level":2,"text":"5. Code Scaffold","id":"5-code-scaffold"},{"level":1,"text":"Library Integration: The Public Face","id":"library-integration-the-public-face"},{"level":2,"text":"1. The Epiphany: The Dashboard","id":"1-the-epiphany-the-dashboard"},{"level":2,"text":"2. Technical Rationale","id":"2-technical-rationale"},{"level":2,"text":"3. Internal Mechanics: The Velvet Rope","id":"3-internal-mechanics-the-velvet-rope"},{"level":3,"text":"A. The Export Macro","id":"a-the-export-macro"},{"level":3,"text":"B. The Header File (The Contract)","id":"b-the-header-file-the-contract"},{"level":3,"text":"C. The Dispatch Hiding","id":"c-the-dispatch-hiding"},{"level":2,"text":"4. The Debugging Lab","id":"4-the-debugging-lab"},{"level":3,"text":"A. The &quot;Undefined Reference&quot; Nightmare","id":"a-the-quotundefined-referencequot-nightmare"},{"level":3,"text":"B. The &quot;Header Hell&quot;","id":"b-the-quotheader-hellquot"},{"level":2,"text":"5. Code Scaffold","id":"5-code-scaffold"},{"level":3,"text":"Part 1: The Public Header (simd_lib.h)","id":"part-1-the-public-header-simd_libh"},{"level":3,"text":"Part 2: The Implementation (simd_lib.cpp)","id":"part-2-the-implementation-simd_libcpp"}],"title":"SIMD Optimization Library","markdown":"# SIMD Optimization Library\n\nA high-performance SIMD (Single Instruction, Multiple Data) optimization library implementing SSE/AVX intrinsics for critical operations including string search, memory copy, and checksum computation. The library provides portable abstractions over x86 vector extensions with automatic CPU feature detection and runtime dispatching for optimal performance across different processors.\n\n\n\n<div id=\"ms-0\"></div>\n\n# Foundation & CPU Detection: The Negotiator\n\n## 1. The Epiphany: The Smart Universal Charger\nImagine you are designing a \"Universal Power Charger\" for electronics.\n*   If you plug in a modern laptop, the charger detects it and pumps **100 Watts** for rapid charging.\n*   If you plug in a 10-year-old flip phone, the charger detects it and gently sends **5 Watts**.\n\nIf you force 100 Watts (Advanced Vector Instructions) into the flip phone (an older CPU), you don't just get slow charging—you fry the device (the program crashes with an \"Illegal Instruction\").\n\n**This is your Foundation Layer.** Before we process a single byte of data, we must negotiate with the hardware. We ask the CPU: *\"Who are you, and how much power can you handle?\"*\n\n## 2. Technical Rationale\nModern x86 processors are a family. While they all speak the same basic language (x86-64), newer generations have \"superpowers\" called **SIMD (Single Instruction, Multiple Data)** extensions.\n\n*   **Scalar (The Old Way):** Processing data one piece at a time. Safe, runs everywhere, but slow.\n*   **SIMD (The New Way):** Processing 16, 32, or 64 bytes at once. Extremely fast, but requires specific hardware support (SSE, AVX, AVX-512).\n\nWe cannot ship different binaries for different computers. Instead, we build a **Fat Binary**—a single program containing multiple versions of the same algorithm. The Foundation Layer decides which version to run at the exact moment the program starts.\n\n> **Quick Breakdown: ISA (Instruction Set Architecture)**\n> Think of the ISA as the vocabulary of the CPU.\n> *   **x86-64:** The basic grammar (English).\n> *   **SSE4.2:** A vocabulary expansion for string processing (Legal English).\n> *   **AVX2:** A vocabulary expansion for massive math operations (Scientific English).\n> If you speak \"Scientific English\" to a toddler (older CPU), they won't understand.\n\n## 3. Internal Mechanics: The CPUID Instruction\nHow do we ask the CPU what it supports? We use the `CPUID` instruction.\n\nWhen you execute `CPUID`, the processor pauses and fills four specific **Registers** (EAX, EBX, ECX, EDX) with a bitmap of its capabilities.\n\n> **Quick Breakdown: Registers & Bits**\n> *   **Register:** A tiny, ultra-fast storage slot directly inside the CPU brain.\n> *   **Bitmap:** Imagine a row of 32 light switches. Switch #5 might mean \"I support AVX2.\" Switch #28 might mean \"I support Hyperthreading.\" We read the switches to know the features.\n\n### The Protocol\n1.  **Leaf Selection:** We put a number into the `EAX` register (the \"Leaf\") to tell the CPU what *category* of info we want.\n    *   `EAX = 1`: Standard Features (SSE, SSE2).\n    *   `EAX = 7`: Extended Features (AVX2, AVX-512).\n2.  **Execution:** We run the `cpuid` command.\n3.  **Reading:** We look at the output registers (ECX, EBX, etc.) and check if specific bits are set to `1`.\n\n\n![Library Architecture Overview](./diagrams/diag-001.svg)\n\n*This satellite view shows how our Detection Layer sits at the top, directing traffic to either the Scalar (slow/safe) or SIMD (fast/risky) implementations.*\n\n---\n\n## 4. The Microscope Effect: Parsing the Bits\nLet's zoom into the actual bitwise operation. To detect **AVX2**, we can't just look for \"AVX2\". We have to verify a chain of dependencies.\n\n**The Dependency Chain:**\n1.  Does the CPU support `CPUID`? (Yes, unless it's from the 90s).\n2.  **Leaf 1, ECX Register, Bit 28 (AVX):** Does it have the basic AVX unit?\n3.  **OS Support (XGETBV):** The hardware might support AVX, but does the Operating System? The OS needs to save/restore the larger YMM registers during context switches. If we skip this check, the program will crash on context switch.\n4.  **Leaf 7, EBX Register, Bit 5 (AVX2):** Finally, does it support the AVX2 instruction set?\n\n\n![CPUID Subleaf Enumeration](./diagrams/diag-003.svg)\n\n*A microscopic view of the CPUID enumeration. Notice how we target specific bits within the 32-bit registers.*\n\n## 5. The Debugging Lab\nWhen implementing CPU detection, here is where things break:\n\n### A. The \"Illegal Instruction\" (SIGILL) Crash\n*   **Symptom:** Your program crashes instantly with code `0xC000001D` (Windows) or `SIGILL` (Linux).\n*   **Cause:** You successfully detected AVX2, but you compiled your code *without* the `-mavx2` flag (or equivalent). The compiler generated scalar code, but you tried to inline raw assembly or intrinsics that the compiler didn't know how to encode properly.\n*   **Fix:** Ensure your build system (CMake/Make) isolates SIMD code into separate translation units with the correct flags, or uses specific function attributes.\n\n### B. The \"It works on my machine\" Error\n*   **Symptom:** It runs fine on your dev box but crashes on the CI/CD server.\n*   **Cause:** You hardcoded checks or relied on `__builtin_cpu_supports` (GCC specific) without fallback logic.\n*   **Fix:** Always write a \"Scalar Fallback\" path—plain C++ code that does the same job, just slower.\n\n### C. The OS Trap\n*   **Symptom:** Random crashes during heavy load.\n*   **Cause:** You checked the CPU hardware bit for AVX but forgot to check `XGETBV` (OS support). The OS didn't save your vector registers when switching threads, corrupting your data.\n*   **Fix:** Always verify `OSXSAVE` bit before checking AVX features.\n\n\n![CPU Feature Detection Flow](./diagrams/diag-002.svg)\n\n*The correct flow: Check CPUID → Check OS Support → Initialize Function Pointers.*\n\n## 6. Code Scaffold\nYour task is to build the `CpuId` class. This is a singleton that runs once at startup.\n\n**Requirements:**\n1.  Use `__cpuid` (MSVC) or `__cpuid_count` (GCC/Clang) intrinsics.\n2.  Implement methods to check for SSE4.2 and AVX2.\n3.  Implement the OS support check (`_xgetbv`).\n\n```cpp\n#include <cstdint>\n#include <iostream>\n#include <vector>\n#include <string>\n\n// Platform specific includes for intrinsics\n#ifdef _MSC_VER\n#include <intrin.h>\n#else\n#include <cpuid.h>\n#include <x86intrin.h>\n#endif\n\nclass CpuFeatureDetector {\npublic:\n    // The \"Map\" of our hardware\n    struct Features {\n        bool has_sse2 = false;\n        bool has_sse42 = false;\n        bool has_avx = false;\n        bool has_avx2 = false;\n        bool os_saves_ymm = false; // Critical for AVX/AVX2 usage\n    };\n\n    CpuFeatureDetector() {\n        detect_features();\n    }\n\n    const Features& get_features() const {\n        return features_;\n    }\n\n    void print_status() const {\n        std::cout << \"CPU Detection Report:\\n\";\n        std::cout << \"  SSE2: \" << (features_.has_sse2 ? \"YES\" : \"NO\") << \"\\n\";\n        std::cout << \"  SSE4.2: \" << (features_.has_sse42 ? \"YES\" : \"NO\") << \"\\n\";\n        std::cout << \"  OS YMM Save: \" << (features_.os_saves_ymm ? \"YES\" : \"NO\") << \"\\n\";\n        std::cout << \"  AVX2: \" << (features_.has_avx2 ? \"YES\" : \"NO\") << \"\\n\";\n    }\n\nprivate:\n    Features features_;\n\n    void detect_features() {\n        // Registers storage: EAX, EBX, ECX, EDX\n        int info[4];\n\n        // 1. Check Standard Features (Leaf 1)\n        cpuid(info, 1);\n        \n        // Bit 26 of EDX is SSE2\n        features_.has_sse2 = (info[3] & (1 << 26)) != 0;\n        \n        // Bit 20 of ECX is SSE4.2\n        features_.has_sse42 = (info[2] & (1 << 20)) != 0;\n        \n        // Bit 28 of ECX is AVX\n        features_.has_avx = (info[2] & (1 << 28)) != 0;\n\n        // 2. Check OS Support for AVX (OSXSAVE)\n        // Bit 27 of ECX in Leaf 1\n        bool has_osxsave = (info[2] & (1 << 27)) != 0;\n\n        if (has_osxsave && features_.has_avx) {\n            // Check if XCR0 (Extended Control Register) saves YMM registers\n            // We read XCR0 using _xgetbv(0)\n            unsigned long long xcr0 = _xgetbv(0);\n            \n            // Check if bit 1 (XMM state) and bit 2 (YMM state) are set\n            features_.os_saves_ymm = (xcr0 & 0x6) == 0x6;\n        }\n\n        // 3. Check Extended Features (Leaf 7) if AVX is supported by OS\n        if (features_.os_saves_ymm) {\n            cpuid(info, 7);\n            // Bit 5 of EBX is AVX2\n            features_.has_avx2 = (info[1] & (1 << 5)) != 0;\n        }\n    }\n\n    // Portable wrapper for CPUID instruction\n    void cpuid(int info[4], int leaf) {\n#ifdef _MSC_VER\n        __cpuid(info, leaf);\n#else\n        // GCC/Clang specific: leaf, subleaf (0 for now)\n        __cpuid_count(leaf, 0, info[0], info[1], info[2], info[3]);\n#endif\n    }\n};\n\n// --- Usage Example ---\nint main() {\n    CpuFeatureDetector detector;\n    detector.print_status();\n\n    if (detector.get_features().has_avx2) {\n        std::cout << \">> Selecting AVX2 Optimized Path (The Jet Plane)\\n\";\n    } else {\n        std::cout << \">> Selecting Scalar Fallback Path (The Propeller Plane)\\n\";\n    }\n\n    return 0;\n}\n```\n\n[↑ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-1\"></div>\n\n# SSE2 & SSE4.2: The Assembly Line\n\n## 1. The Epiphany: The Bucket Brigade vs. The Forklift\nImagine a warehouse (Memory) full of boxes (Bytes). You need to find a specific red box (a character) or move a pile of boxes to a new truck (Copy).\n\n*   **The Scalar Way (C++ `char*`)**: You are a single worker. You pick up **one box**, look at it, put it down. Pick up the next box. It takes 16 trips to check 16 boxes.\n*   **The SIMD Way (SSE2)**: You drive a forklift. You scoop up a pallet of **16 boxes** at once. You look at the whole pallet instantly. If the red box isn't there, you dump the whole pallet and grab the next 16.\n\n**SIMD** stands for **Single Instruction, Multiple Data**. One command from the CPU acts on 16 bytes of data simultaneously. This isn't just twice as fast; it's often 10-20x faster because we eliminate the overhead of the loop logic for every single byte.\n\n## 2. Technical Rationale\nStandard C++ `strlen` or `memcpy` are often optimized, but generic compilers must be conservative. By writing manual intrinsics, we unlock raw performance for our specific data patterns.\n\n*   **SSE2 (Streaming SIMD Extensions 2)**: The baseline. Every x86-64 CPU supports this. It gives us **128-bit registers (XMM)** holding 16 bytes.\n*   **SSE4.2**: The \"String Specialist\". It adds specific instructions (like `PCMPISTRI`) designed explicitly to handle C-style null-terminated strings, which are notoriously hard to vectorize because you don't know the length ahead of time.\n\n## 3. Internal Mechanics: The 128-bit Engine\n\nTo write this code, we bypass standard C++ variables and speak directly to the **XMM Registers**.\n\n### The Data Type: `__m128i`\nThis is a \"Black Box\" type. It represents 128 bits (16 bytes) in a vector register. You cannot access `variable[0]` directly; you must use **Intrinsics** (functions starting with `_mm_`) to manipulate it.\n\n### The Operation: Parallel Comparison\nLet's look at `strlen` (finding the null terminator `\\0`).\n\n1.  **Load**: `_mm_loadu_si128` pulls 16 bytes from memory into a register.\n2.  **Compare**: `_mm_cmpeq_epi8` compares our 16 bytes against a register of all zeros.\n    *   *Scalar*: Returns `true`/`false`.\n    *   *SIMD*: Returns **0xFF** (all 1s) for a match, or **0x00** for no match, *for every byte position*.\n3.  **Squash**: `_mm_movemask_epi8` takes the most significant bit of each byte result and compresses them into a standard 16-bit integer (C++ `int`).\n    *   If the result is `0`, no nulls were found.\n    *   If the result is `0x0008` (binary `0000 0000 0000 1000`), the null is at index 3.\n\n\n![SSE2 Character Scan Algorithm](./diagrams/diag-006.svg)\n\n*Visualizing the SSE2 Scan: We load 16 chars, compare them all to 'A' (or \\0) in one cycle, and extract a bitmask representing the matches.*\n\n### The Advanced Tool: SSE4.2 `_mm_cmpistri`\nFor more complex tasks, like \"Find the first occurrence of any character from set 'ABC'\", SSE2 is tedious. SSE4.2 gives us `PCMPISTRI` (Packed Compare Implicit Length String, Return Index).\n*   It automatically handles null termination (stops if it sees a zero).\n*   It compares ranges or sets.\n*   It returns the index directly.\n\n\n![SSE4.2 String Search (PCMPISTRI)](./diagrams/diag-007.svg)\n\n*Microscope view of SSE4.2. Notice how the hardware handles the loop logic and null checks internally, returning just an index.*\n\n## 4. The Debugging Lab\nSIMD programming is like juggling chainsaws. It's powerful, but mistakes are fatal.\n\n### A. The Alignment Trap (Segfaults)\n*   **The Crash:** `Segmentation fault` on a load instruction.\n*   **The Cause:** You used `_mm_load_si128` (Aligned Load) on a memory address like `0x1003`.\n*   **The Fix:** Aligned loads require addresses ending in `0` (divisible by 16). Unless you are 100% sure of your memory allocation, **always use `_mm_loadu_si128`** (Unaligned Load). Modern CPUs handle unaligned loads with almost zero penalty.\n\n### B. The Page Boundary Over-read\n*   **The Fear:** \"If my string is 3 bytes long, but I load 16 bytes, am I reading garbage?\"\n*   **The Reality:** Yes, you are reading 13 bytes of garbage.\n*   **The Danger:** If those 3 bytes are at the very end of a **Memory Page** (a 4KB chunk managed by the OS), and the *next* page is not allocated to your process, reading into it causes a Segfault.\n*   **The Fix:** Safe SIMD implementations align the pointer *down* to the nearest 16-byte boundary and mask off the bytes that precede the string start.\n\n### C. The \"Ghost\" Bytes\n*   **The Bug:** Your `strlen` returns 5, but the string is length 4.\n*   **The Cause:** You loaded garbage bytes after the null terminator. One of those garbage bytes happened to be the character you were searching for (e.g., if searching for 'X' and 'X' exists in the unallocated memory after the string).\n*   **The Fix:** Logic order matters. In `strlen`, we look for the *first* zero. In `strchr` (find char), we must stop searching if we hit the target char *OR* the null terminator.\n\n## 5. Code Scaffold\n\nWe will implement a safe `strlen` using SSE2. This is the \"Hello World\" of SIMD.\n\n**Your Task:**\n1.  Align the pointer to 16 bytes to avoid page boundary crashes.\n2.  Load data using `_mm_load_si128`.\n3.  Compare against Zero.\n4.  If a zero is found, calculate the exact length using `_tzcnt_u32` (Count Trailing Zeros).\n\n```cpp\n#include <emmintrin.h> // SSE2\n#include <nmmintrin.h> // SSE4.2\n#include <cstdint>\n#include <cstddef>\n#include <immintrin.h>\n\n// Helper to count trailing zeros (compiler abstraction)\ninline uint32_t count_trailing_zeros(uint32_t x) {\n#ifdef _MSC_VER\n    unsigned long result;\n    _BitScanForward(&result, x);\n    return result;\n#else\n    return __builtin_ctz(x);\n#endif\n}\n\nclass SimdCore {\npublic:\n    // SSE2 Optimized String Length\n    static size_t fast_strlen(const char* str) {\n        const char* ptr = str;\n        __m128i zero_chunk = _mm_setzero_si128();\n\n        // 1. Handle Unaligned Start\n        // We cannot just load 16 bytes if we are at the edge of a page.\n        // Strategy: Align pointer DOWN, load, and ignore bytes before 'str'.\n        uintptr_t address = reinterpret_cast<uintptr_t>(ptr);\n        uintptr_t alignment_offset = address & 15; // address % 16\n        \n        if (alignment_offset != 0) {\n            // Align pointer down to previous 16-byte boundary\n            const char* aligned_ptr = ptr - alignment_offset;\n            __m128i chunk = _mm_load_si128(reinterpret_cast<const __m128i*>(aligned_ptr));\n            \n            // Compare with zero\n            __m128i cmp = _mm_cmpeq_epi8(chunk, zero_chunk);\n            uint32_t mask = _mm_movemask_epi8(cmp);\n            \n            // Shift mask to ignore the bytes before our actual string start\n            mask >>= alignment_offset;\n\n            if (mask != 0) {\n                // Found null in the first chunk\n                return count_trailing_zeros(mask);\n            }\n            \n            // Move ptr to next aligned boundary\n            ptr = aligned_ptr + 16;\n        }\n\n        // 2. Main Loop (Aligned 16-byte chunks)\n        while (true) {\n            __m128i chunk = _mm_load_si128(reinterpret_cast<const __m128i*>(ptr));\n            __m128i cmp = _mm_cmpeq_epi8(chunk, zero_chunk);\n            uint32_t mask = _mm_movemask_epi8(cmp);\n\n            if (mask != 0) {\n                // Found the terminator\n                // Add the distance traveled so far + index within this chunk\n                return (ptr - str) + count_trailing_zeros(mask);\n            }\n\n            ptr += 16;\n        }\n    }\n\n    // SSE4.2 Optimized Character Search (Bonus)\n    // Returns index of first occurrence of 'ch', or -1 if not found.\n    static intptr_t fast_strchr(const char* str, char ch) {\n#ifdef __SSE4_2__\n        // Fill a register with the character we want (e.g., 'A' -> 'AAAAAAAAAAAAAAAA')\n        __m128i target = _mm_set1_epi8(ch);\n        const char* ptr = str;\n\n        // NOTE: For simplicity, this snippet assumes unaligned load is safe \n        // (not crossing page boundary). Production code needs the alignment fix above.\n        while (true) {\n            __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(ptr));\n            \n            // Find 'ch' OR '\\0' (end of string)\n            // _mm_cmpistri returns the index of the match\n            // _SIDD_CMP_EQUAL_EACH: Compare bytes for equality\n            // _SIDD_MASKED_NEGATIVE_POLARITY: Invert result? No, we want matches.\n            // Actually, for strchr, standard SSE2 manual approach is often faster \n            // than cmpistri due to latency, but cmpistri is great for complex sets.\n            \n            // Let's stick to the SSE2 manual approach for clarity on the mechanics:\n            __m128i zero_chunk = _mm_setzero_si128();\n            __m128i match_char = _mm_cmpeq_epi8(chunk, target);\n            __m128i match_zero = _mm_cmpeq_epi8(chunk, zero_chunk);\n            \n            // Combine: We care if we found the Char OR the Zero\n            __m128i combined = _mm_or_si128(match_char, match_zero);\n            uint32_t mask = _mm_movemask_epi8(combined);\n\n            if (mask != 0) {\n                uint32_t idx = count_trailing_zeros(mask);\n                // Check if the match was the Char or the Null Terminator\n                if (ptr[idx] == ch) {\n                    return (ptr - str) + idx;\n                } else {\n                    return -1; // Found null terminator before char\n                }\n            }\n            ptr += 16;\n        }\n#else\n        // Fallback for non-SSE4.2 systems\n        return -1; \n#endif\n    }\n};\n```\n\n[↑ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-2\"></div>\n\n# AVX & AVX2: The Heavy Machinery\n\n## 1. The Epiphany: The Delivery Truck vs. The Semi-Trailer\nIn the previous section, we upgraded from a single worker to a **Delivery Truck (SSE)** that could move 16 bytes at once.\n\nNow, we are upgrading to a **Semi-Trailer (AVX/AVX2)**.\n*   **Capacity**: It carries **32 bytes** (256 bits) in a single trip.\n*   **Efficiency**: It doesn't just carry more; it has a smarter engine. In the old truck (SSE), if you wanted to add Box A to Box B, you had to overwrite Box A. In the Semi-Trailer (AVX), you can take Box A and Box B, add them, and put the result in a *new* Box C, leaving A untouched.\n\n**The Distinction:**\n*   **AVX (Advanced Vector Extensions)**: Great for Math (Floating Point). Think scientific calculations.\n*   **AVX2**: The expansion that matters for Systems Programming. It brings 256-bit power to **Integers**. Since text, pointers, and network packets are integers, AVX2 is our weapon of choice.\n\n## 2. Technical Rationale\nWhy bother with AVX2 if SSE is \"fast enough\"?\n1.  **Throughput**: Processing 32 bytes per cycle effectively doubles your memory bandwidth utilization for cached data.\n2.  **Non-Destructive Syntax**: AVX introduces 3-operand instructions (`Dest = Src1 + Src2`). SSE was 2-operand (`Dest = Dest + Src`). This allows the compiler (and you) to write code with fewer \"register shuffling\" instructions, reducing CPU overhead.\n\n## 3. Internal Mechanics: The YMM Registers\n\nTo use AVX, we interact with the **YMM Registers**.\n\n*   **Size**: 256 bits (32 Bytes).\n*   **Naming**: `YMM0` through `YMM15`.\n*   **The Nesting Doll Architecture**: The YMM registers are not new hardware sitting next to the old stuff. They *enclose* the old stuff.\n    *   The lower 128 bits of `YMM0` **ARE** `XMM0`.\n    *   If you write to `XMM0`, you are modifying the bottom half of `YMM0`.\n\n\n![Vector Register Mapping](./diagrams/diag-005.svg)\n\n*Microscopic view showing XMM/YMM register allocation. Notice how YMM extends XMM. Writing to YMM zeroes out the upper bits of the future, while writing to XMM interacts with the lower bits.*\n\n### The Data Type: `__m256i`\nJust like `__m128i`, this is a black box.\n*   `__m256` = 8 floats (AVX).\n*   `__m256i` = 32 chars, or 8 integers, or 4 `long long`s (AVX2).\n\n### The Instruction Set\nThe intrinsic functions follow a pattern:\n*   `_mm256_load_si256`: Load 32 bytes (Must be 32-byte aligned).\n*   `_mm256_loadu_si256`: Load 32 bytes (Unaligned - safe for most pointers).\n*   `_mm256_add_epi32`: Add integers.\n\n## 4. The Debugging Lab\nUpgrading to AVX introduces new categories of bugs.\n\n### A. The \"State Transition\" Stall (The AVX-SSE Penalty)\n*   **The Issue:** The CPU tries to be energy efficient. If you are running old SSE code, it turns off the power to the upper 128 bits of the YMM registers.\n*   **The Trap:** If you suddenly execute an AVX instruction, the CPU has to \"wake up\" the upper half. This costs hundreds of CPU cycles. Worse, if you switch *back* to SSE without cleaning up, the CPU might merge the states inefficiently.\n*   **The Fix:** If you mix SSE and AVX code, use the intrinsic `_mm256_zeroupper()` at the boundary. This tells the CPU \"I'm done with the top half, you can power it down.\"\n\n### B. The 32-Byte Alignment Crash\n*   **The Symptom:** Instant Segfault on `_mm256_load_si256`.\n*   **The Cause:** SSE required 16-byte alignment (addresses ending in `0`). AVX requires **32-byte alignment** (addresses ending in `00` hex, divisible by 32). `malloc` in C++ does not guarantee 32-byte alignment.\n*   **The Fix:** Use `aligned_alloc` (C++17) or `_mm_malloc`, or stick to `_mm256_loadu_si256` (unaligned load) which is very fast on modern CPUs.\n\n\n![Aligned 256-bit Copy Loop](./diagrams/diag-012.svg)\n\n*Microscopic view of an aligned AVX copy loop. Notice the strict 32-byte blocks. If the memory address starts at offset 0x08, the aligned load will crash.*\n\n## 5. Code Scaffold\n\nYour task is to implement a **High-Performance Buffer XOR**. This is a common operation in cryptography and checksumming. We will take two arrays of data, XOR them together, and store the result, processing 32 bytes at a time.\n\n**Requirements:**\n1.  Check for AVX2 support (using your previous detection class).\n2.  Process the \"Bulk\" using AVX2 intrinsics.\n3.  Process the \"Tail\" (leftover bytes < 32) using a standard loop.\n\n```cpp\n#include <immintrin.h>\n#include <cstdint>\n#include <iostream>\n\nclass VectorMath {\npublic:\n    // Computes: dest[i] = src1[i] ^ src2[i]\n    // Optimized with AVX2\n    static void xor_buffers(uint8_t* dest, const uint8_t* src1, const uint8_t* src2, size_t len) {\n        size_t i = 0;\n\n        // 1. The AVX2 Fast Path\n        // We can process 32 bytes (256 bits) per iteration.\n        // We stop when we have fewer than 32 bytes left.\n        size_t avx_limit = len - (len % 32);\n\n        // Quick Breakdown:\n        // _mm256_loadu_si256: Load 32 bytes from memory (Unaligned is safe).\n        // _mm256_xor_si256:   Perform bitwise XOR on all 256 bits at once.\n        // _mm256_storeu_si256: Store result back to memory.\n        \n        for (; i < avx_limit; i += 32) {\n            // Load 32 bytes from Source 1\n            __m256i v1 = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(src1 + i));\n            \n            // Load 32 bytes from Source 2\n            __m256i v2 = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(src2 + i));\n            \n            // The operation: Dest = Src1 XOR Src2\n            __m256i result = _mm256_xor_si256(v1, v2);\n            \n            // Store the result\n            _mm256_storeu_si256(reinterpret_cast<__m256i*>(dest + i), result);\n        }\n\n        // 2. The Cleanup Transition\n        // Good practice when leaving AVX code if we might jump to legacy SSE code elsewhere.\n        // Clears the upper 128 bits of YMM registers.\n        _mm256_zeroupper();\n\n        // 3. The Scalar Tail (Cleanup)\n        // Handle the remaining 0 to 31 bytes one by one.\n        for (; i < len; ++i) {\n            dest[i] = src1[i] ^ src2[i];\n        }\n    }\n};\n\n// --- Test Harness ---\nint main() {\n    const size_t SIZE = 100;\n    uint8_t buffer_a[SIZE];\n    uint8_t buffer_b[SIZE];\n    uint8_t result[SIZE];\n\n    // Initialize with dummy data\n    for (int i = 0; i < SIZE; ++i) {\n        buffer_a[i] = i;\n        buffer_b[i] = 0xFF; // Invert mask\n    }\n\n    std::cout << \">> Running AVX2 XOR Operation...\\n\";\n    VectorMath::xor_buffers(result, buffer_a, buffer_b, SIZE);\n\n    std::cout << \">> Verify Index 0: \" << (int)buffer_a[0] << \" ^ \" << (int)buffer_b[0] \n              << \" = \" << (int)result[0] << \"\\n\";\n    \n    std::cout << \">> Verify Index 35 (Tail): \" << (int)buffer_a[35] << \" ^ \" << (int)buffer_b[35] \n              << \" = \" << (int)result[35] << \"\\n\";\n\n    return 0;\n}\n```\n\n[↑ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-3\"></div>\n\n# String Search Primitives: The Needle in the Haystack\n\n## 1. The Epiphany: The Stencil vs. The Magnifying Glass\n\nImagine you are looking for specific letters—say, all the vowels—in a page of text.\n\n*   **The Scalar Way (The Magnifying Glass):** You move your magnifying glass over the first letter. Is it an 'A'? No. Is it an 'E'? No. Is it an 'I'? No. Move to the next letter. Repeat.\n*   **The SIMD Way (The Stencil):** You take a plastic stencil that has holes cut out for A, E, I, O, and U. You slap this stencil over a whole sentence at once. Instantly, you see exactly where the vowels are through the holes.\n\nIn this section, we aren't just comparing byte-for-byte. We are using **SSE4.2**, an instruction set that essentially adds a programmable \"Search Engine\" directly into the CPU silicon.\n\n## 2. Technical Rationale: The \"Swiss Army Knife\" Instruction\nStandard SIMD (SSE2) is great for \"Are these 16 bytes equal to those 16 bytes?\"\n\nBut string searching is messier.\n1.  We might look for *any* character from a set (e.g., \"Find the first whitespace or comma\").\n2.  We might look for a range (e.g., \"Find the first number 0-9\").\n3.  We might look for a substring (e.g., \"Find 'HTTP'\").\n4.  We have to stop if we hit a Null Terminator (`\\0`).\n\nDoing this with basic math instructions is a nightmare of bit-twiddling. Enter **SSE4.2** and the instruction `PCMPISTRI` (Packed Compare Implicit Length String, Return Index). It is the most complex instruction in the x86 non-crypto instruction set.\n\n## 3. Internal Mechanics: The Programmable Engine\n\nWe are going to use the intrinsic `_mm_cmpistri`. This function doesn't just do one thing; it changes its behavior based on a **Control Byte** (a configuration number) you pass to it.\n\n### The Inputs\n1.  **Needle (`__m128i`)**: The characters you are looking for (up to 16).\n2.  **Haystack (`__m128i`)**: The chunk of text you are searching through (16 bytes).\n3.  **Control Byte (`const int`)**: The mode selector.\n\n### The Modes (The Control Byte)\nThe Control Byte tells the CPU how to compare the Needle and the Haystack.\n\n*   **Equal Any (`_SIDD_CMP_EQUAL_ANY`)**: \"Is the character at `Haystack[i]` present *anywhere* in `Needle`?\"\n    *   *Use Case:* `strpbrk` (Find first of set). Good for finding delimiters.\n*   **Equal Each (`_SIDD_CMP_EQUAL_EACH`)**: \"Does `Haystack` match `Needle` perfectly?\"\n    *   *Use Case:* `strcmp` (String equality).\n*   **Ranges (`_SIDD_CMP_RANGES`)**: \"Is `Haystack[i]` inside the range defined by `Needle`?\"\n    *   *Use Case:* Finding all digits (Needle = '0', '9').\n*   **Equal Ordered (`_SIDD_CMP_EQUAL_ORDERED`)**: \"Does the substring `Needle` start at `Haystack[i]`?\"\n    *   *Use Case:* `strstr` (Substring search).\n\n### The Output\nThe instruction returns the **Index** (0-15) of the first match. If no match is found, it usually returns 16.\n\n\n![SSE4.2 String Search (PCMPISTRI)](./diagrams/diag-007.svg)\n\n*Microscopic view of SSE4.2 PCMPISTRI. The CPU loads the needle and haystack, applies the logic defined by the Control Byte (Mode), handles the null-check automatically, and spits out the index of the winner.*\n\n\n![Character Class Search](./diagrams/diag-010.svg)\n\n*Visualizing \"Equal Any\" mode. We load the delimiter set (spaces, commas) into the Needle register. The CPU checks all 16 Haystack bytes against the entire Needle set simultaneously.*\n\n## 4. The Debugging Lab\n\n### A. The Latency Trap\n*   **The Myth:** \"One SIMD instruction is always faster than 5 scalar instructions.\"\n*   **The Reality:** `PCMPISTRI` is a heavy instruction. It takes ~11 CPU cycles to execute. A simple scalar `CMP` takes < 1 cycle.\n*   **The Lesson:** If you are only looking for **one** character (e.g., just 'A'), don't use this heavy machinery. Use the simpler SSE2 `_mm_cmpeq_epi8` method from the previous section. Use `PCMPISTRI` when the logic is complex (sets, ranges, substrings).\n\n### B. The \"Implicit\" vs \"Explicit\" Length\n*   **The Confusion:** There are two versions: `_mm_cmpistri` (Implicit) and `_mm_cmpestri` (Explicit).\n*   **Implicit (`i`)**: Scans for the Null Terminator (`\\0`) automatically. Use this for C-style strings (`char*`).\n*   **Explicit (`e`)**: You must tell it the length of the string. Use this for `std::string_view` or known buffers.\n*   **The Bug:** Using Implicit mode on a buffer that *isn't* a null-terminated string. The CPU might stop searching prematurely if it hits a random `0` byte in your binary data.\n\n## 5. Code Scaffold\n\nWe will implement a **Delimiter Finder**. This function scans a string and returns the index of the first occurrence of *any* character in a \"Needle\" set (e.g., find the first space, comma, or period).\n\n**Your Task:**\n1.  Load the \"Set\" of characters (Needle) into a register.\n2.  Loop through the string 16 bytes at a time.\n3.  Use `_mm_cmpistri` with `_SIDD_CMP_EQUAL_ANY` mode.\n4.  Handle the return index.\n\n```cpp\n#include <nmmintrin.h> // SSE4.2\n#include <immintrin.h>\n#include <cstdint>\n#include <iostream>\n\nclass StringScanner {\npublic:\n    // Finds the first occurrence of ANY character in 'accept_set' within 'str'.\n    // Equivalent to C's strpbrk, but returns an index.\n    static intptr_t find_first_of(const char* str, const char* accept_set) {\n        if (!str || !accept_set) return -1;\n\n        // 1. Prepare the Needle (The Set)\n        // We load the accept_set into a register. \n        // NOTE: For this scaffold, we assume accept_set is short (< 16 chars).\n        // In production, if the set is > 16, you'd need a different strategy (Lookup Table).\n        __m128i needle = _mm_loadu_si128(reinterpret_cast<const __m128i*>(accept_set));\n        \n        const char* ptr = str;\n\n        // 2. The Loop\n        while (true) {\n            // Load 16 bytes of the Haystack (Unsafe load - see previous section for alignment fixes)\n            __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(ptr));\n\n            // 3. The Heavy Machinery: _mm_cmpistri\n            // _SIDD_UBYTE_OPS: We are comparing Bytes (Chars)\n            // _SIDD_CMP_EQUAL_ANY: Match if Haystack[i] equals ANY char in Needle\n            // _SIDD_LEAST_SIGNIFICANT: Return the smallest index found\n            const int mode = _SIDD_UBYTE_OPS | _SIDD_CMP_EQUAL_ANY | _SIDD_LEAST_SIGNIFICANT;\n            \n            int idx = _mm_cmpistri(needle, chunk, mode);\n\n            // 4. Check for Termination\n            // The instruction sets flags. We can check the \"Zero Flag\" (ZF) and \"Carry Flag\" (CF).\n            // However, the intrinsic returns the index directly.\n            \n            // Case A: Found a match?\n            if (idx < 16) {\n                // Wait! Did we find a match, or did we hit the end of the string (Null Terminator)?\n                // In Implicit mode, if the string ends, the index points to the null.\n                // We need to verify if the char at idx is actually in our set.\n                \n                // For simplicity in this scaffold, let's trust the index but double-check manually\n                // to distinguish between \"Found Terminator\" and \"Found Match\".\n                if (ptr[idx] == '\\0') {\n                    return -1; // End of string, nothing found\n                }\n                \n                return (ptr - str) + idx; // Found it!\n            }\n\n            // Case B: No match in this chunk.\n            // But did the string end in this chunk?\n            // _mm_cmpistri handles nulls. If a null was found but no match, \n            // the index would be the position of the null (which is < 16).\n            // If idx == 16, it means \"Processed all 16 bytes, valid data, no match\".\n            if (idx == 16) {\n                // Check if we hit the null terminator implicitly.\n                // The intrinsic sets the Zero Flag (ZF) if the null terminator was seen in needle,\n                // and Carry Flag (CF) if null terminator seen in haystack.\n                // Accessing flags from C++ is tricky without assembly. \n                // Easier check:\n                __m128i zero = _mm_setzero_si128();\n                int null_idx = _mm_cmpistri(zero, chunk, _SIDD_UBYTE_OPS | _SIDD_CMP_EQUAL_EACH);\n                \n                if (null_idx < 16) {\n                    return -1; // String ended in this block, no match found earlier.\n                }\n            }\n\n            ptr += 16;\n        }\n    }\n};\n\n// --- Test Harness ---\nint main() {\n    const char* text = \"Hello, world! This is SIMD.\";\n    const char* delimiters = \"!.\"; // Looking for punctuation\n\n    std::cout << \">> Text: \" << text << \"\\n\";\n    std::cout << \">> Looking for: [\" << delimiters << \"]\\n\";\n\n    intptr_t index = StringScanner::find_first_of(text, delimiters);\n\n    if (index != -1) {\n        std::cout << \">> Found delimiter '\" << text[index] << \"' at index \" << index << \"\\n\";\n    } else {\n        std::cout << \">> No delimiters found.\\n\";\n    }\n\n    return 0;\n}\n```\n\n[↑ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-4\"></div>\n\n# Memory Copy Engine: Moving Mountains with Tweezers vs. Dump Trucks\n\n## 1. The Epiphany: The Logistics Manager\nImagine you are a logistics manager responsible for moving items from Warehouse A to Warehouse B. You have three vehicles: a bicycle courier, a moving van, and a freight train.\n\n*   **The Scalar Loop (The Bicycle):** If you need to move a single letter, you give it to the cyclist. It’s fast to start, agile, and finishes immediately.\n*   **The SIMD Loop (The Moving Van):** If you need to move the contents of a studio apartment, the bicycle is useless. You load up the van (128/256 bits at a time). It takes a moment to park and open the doors (overhead), but it moves volume fast.\n*   **The Non-Temporal Store (The Freight Train):** If you are moving a whole factory, even the van is too slow. You load a train. Crucially, the train bypasses the local city traffic (CPU Cache) entirely so it doesn't cause a gridlock for everyone else.\n\nA naive `memcpy` uses the bicycle for everything. A system programmer builds a dispatcher that checks the weight of the cargo and selects the perfect vehicle.\n\n## 2. Technical Rationale\nWhy can't we just use `std::memcpy`? usually, you can! But understanding *how* it works allows you to write specialized copy routines for high-performance structures (like ring buffers or network packets) where the overhead of the standard library function call might be too high, or you need specific behavior (like bypassing cache).\n\n1.  **Branch Prediction Overhead:** For tiny copies (e.g., 8 bytes), the cost of the CPU deciding *which* loop to run is higher than the copy itself.\n2.  **Alignment Penalties:** Writing 32 bytes to an address ending in `0x01` is slower than writing to `0x00`.\n3.  **Cache Pollution:** Copying 1GB of data typically wipes out your L1/L2/L3 caches. The moment the copy finishes, your CPU stalls because the code instructions it needs were evicted to make room for the data you just copied.\n\n## 3. Internal Mechanics: The Decision Tree\n\nHigh-performance memory copying is a game of thresholds.\n\n### Tier 1: The Tiny Path (< 16 Bytes)\n**Mechanism:** General Purpose Registers (GPR).\nWe don't touch SSE/AVX here. We treat the data as `uint64_t` or `uint8_t`.\n*   **Method:** A \"Jump Table\" or unrolled switch.\n*   **Why:** Setting up AVX registers takes cycles. Loading a standard 64-bit integer into a standard register (`RAX`) is instantaneous.\n\n### Tier 2: The SIMD Path (16 Bytes to ~4KB)\n**Mechanism:** `XMM` (128-bit) or `YMM` (256-bit) Registers.\nThis is the \"Moving Van.\"\n*   **The Loop:** Load 32 bytes $\\to$ Store 32 bytes.\n*   **Prefetching:** We might tell the CPU \"Hey, I'm going to need the next cache line soon,\" so it fetches memory from RAM to L1 cache while we process the current chunk.\n\n\n![Memcpy Size Thresholds](./diagrams/diag-011.svg)\n\n*The Strategic Map. The code branches based on size. Note how the strategies shift from GPR (General Purpose Registers) to XMM/YMM, and finally to Non-Temporal strategies.*\n\n### Tier 3: The Huge Path (> 4KB / Cache Size)\n**Mechanism:** Non-Temporal Stores (`MOVNT`).\nWhen data is larger than the CPU cache, bringing it *into* the cache is wasteful because we will overwrite it before we read it again.\n*   **The Bypass:** We use intrinsics like `_mm256_stream_si256`. This writes data **directly to RAM**, skipping the cache hierarchy.\n\n{{DIAGRAM:diag-014}}\n*Microscopic view of the \"Freight Train.\" Standard stores go through L1 -> L2 -> L3 -> RAM. Non-temporal stores (Streaming Stores) bypass the cache, preventing \"cache pollution.\"*\n\n## 4. The Debugging Lab\n\n### A. The Overlap Catastrophe (`memcpy` vs `memmove`)\n*   **The Scenario:** You want to shift an array to the right by 1 byte. `src` is index 0, `dest` is index 1.\n*   **The Bug:** `memcpy` is designed for *disjoint* memory. If you copy byte 0 to byte 1, you might overwrite the original byte 1 before you have a chance to copy it.\n*   **The Fix:** Always ask: \"Can these pointers overlap?\" If yes, copy **backwards** (tail to head) or use `memmove`.\n\n### B. The Unaligned Crash\n*   **The Scenario:** You cast a `char*` to `__m256i*` to use AVX load instructions.\n*   **The Bug:** If the pointer address isn't divisible by 32, `_mm256_load_si256` will Segfault.\n*   **The Fix:** Use `_mm256_loadu_si256` (the 'u' stands for Unaligned). Modern Intel/AMD CPUs handle unaligned loads with almost zero penalty.\n\n\n![Unaligned Copy Handling](./diagrams/diag-013.svg)\n\n*Handling alignment. Notice how we might handle the \"Head\" (the few bytes before the first 32-byte boundary) using scalar code, then blast through the \"Body\" with AVX, and finish the \"Tail\" with scalar.*\n\n## 5. Code Scaffold\n\nWe will build a **Smart Copy Engine** that implements a simplified version of the Tier 1 and Tier 2 strategies.\n\n**Your Task:**\n1.  Handle tiny copies with a switch statement (fastest dispatch).\n2.  Handle medium copies with an AVX2 loop.\n3.  Handle the \"Tail\" (leftover bytes) gracefully.\n\n```cpp\n#include <immintrin.h>\n#include <cstdint>\n#include <cstring>\n#include <iostream>\n\nclass MemoryEngine {\npublic:\n    static void smart_copy(void* dest, const void* src, size_t count) {\n        uint8_t* d = static_cast<uint8_t*>(dest);\n        const uint8_t* s = static_cast<const uint8_t*>(src);\n\n        // --- TIER 1: The Tiny Path (< 32 Bytes) ---\n        // Quick Breakdown:\n        // We avoid the overhead of setting up vector loops.\n        // We treat small copies as simple integer assignments.\n        if (count < 32) {\n            if (count >= 16) {\n                // Copy 16 bytes, then copy the LAST 16 bytes.\n                // It's okay if they overlap! It's safer/faster than a loop.\n                __m128i head = _mm_loadu_si128(reinterpret_cast<const __m128i*>(s));\n                __m128i tail = _mm_loadu_si128(reinterpret_cast<const __m128i*>(s + count - 16));\n                _mm_storeu_si128(reinterpret_cast<__m128i*>(d), head);\n                _mm_storeu_si128(reinterpret_cast<__m128i*>(d + count - 16), tail);\n                return;\n            }\n            // Fallback for very small strings\n            while (count--) *d++ = *s++;\n            return;\n        }\n\n        // --- TIER 2: The AVX Path (>= 32 Bytes) ---\n        \n        size_t i = 0;\n        size_t avx_limit = count - (count % 32);\n\n        // 1. Bulk Copy (The Moving Van)\n        // Process 32 bytes per cycle.\n        for (; i < avx_limit; i += 32) {\n            // Load 256 bits (Unsafe/Unaligned load)\n            __m256i chunk = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(s + i));\n            \n            // Store 256 bits\n            // In a 'Huge' tier (> 1MB), we would use _mm256_stream_si256 here\n            _mm256_storeu_si256(reinterpret_cast<__m256i*>(d + i), chunk);\n        }\n\n        // 2. Transition Cleanup\n        // Standard practice when mixing AVX with potentially legacy code later\n        _mm256_zeroupper();\n\n        // 3. The Tail\n        // We have 0 to 31 bytes left. \n        // We could loop byte-by-byte, but there's a trick:\n        // Just copy the LAST 32 bytes of the source to the LAST 32 bytes of dest.\n        // It overlaps with what we just wrote, but who cares? It's correct data.\n        if (i < count) {\n            size_t offset = count - 32;\n            __m256i tail_chunk = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(s + offset));\n            _mm256_storeu_si256(reinterpret_cast<__m256i*>(d + offset), tail_chunk);\n            _mm256_zeroupper();\n        }\n    }\n};\n\n// --- Test Harness ---\nint main() {\n    const size_t SIZE = 1024;\n    char source[SIZE];\n    char destination[SIZE];\n\n    // Setup Data\n    for (int i = 0; i < SIZE; ++i) source[i] = (char)(i % 255);\n    std::memset(destination, 0, SIZE);\n\n    std::cout << \">> Running Smart Copy...\\n\";\n    MemoryEngine::smart_copy(destination, source, SIZE);\n\n    // Verify\n    bool match = true;\n    for (int i = 0; i < SIZE; ++i) {\n        if (source[i] != destination[i]) {\n            match = false;\n            std::cout << \"Mismatch at index \" << i << \"\\n\";\n            break;\n        }\n    }\n\n    if (match) std::cout << \">> Success: 1024 bytes copied perfectly.\\n\";\n    return 0;\n}\n```\n\n[↑ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-5\"></div>\n\n# Checksum Core: The Digital Fingerprint Factory\n\n## 1. The Epiphany: The Origami Master\nImagine you have a strip of paper 10 miles long (a large file), and you need to verify that not a single fiber of that paper has been torn or stained.\n\n*   **The Scalar Approach:** You walk down the 10-mile strip, examining one inch at a time, keeping a running tally in your head. It takes forever.\n*   **The SIMD Approach (Folding):** You don't walk. You grab the strip at the 1-mile mark, the 2-mile mark, and the 3-mile mark. You fold the paper over onto itself. You crunch 128 inches of paper into a single layer simultaneously. You keep folding this massive strip until it fits into a tiny square in your pocket.\n\nThat tiny square is your **Checksum**. If even one inch of the 10-mile strip was different, the folds wouldn't line up, and your final square would look different.\n\n## 2. Technical Rationale\nWhy do we need complex instructions for a simple sum?\n1.  **Data Integrity:** Network packets and SSDs rely on CRC (Cyclic Redundancy Check) to ensure data wasn't corrupted in transit.\n2.  **The \"Carry\" Problem:** Normal math handles \"carries\" (e.g., $15 + 15 = 30$). CRC math acts like a zipper—it doesn't want carries; it wants XORs. Standard CPU multiplication is useless here because it propagates carries.\n3.  **The Solution:** Intel introduced **PCLMULQDQ** (Carry-Less Multiplication Quadword). It allows the CPU to perform the complex polynomial math required for CRCs on 128 bits at a time, effectively \"folding\" memory blocks at RAM speeds.\n\n## 3. Internal Mechanics: The Fold and The Crush\n\nWe are building a pipeline that ingests data and reduces it.\n\n### Phase 1: The Selector\nFirst, we check what tools we have. Do we have the specialized hardware (PCLMULQDQ) or do we use a fast general-purpose hash (like xxHash)?\n\n\n![Checksum Algorithm Selector](./diagrams/diag-015.svg)\n\n*The Dispatcher. The system checks CPUID features. If PCLMULQDQ is present, it routes to the hardware CRC path. Otherwise, it falls back to scalar lookup tables.*\n\n### Phase 2: The Fold (PCLMULQDQ)\n**Quick Breakdown:** `_mm_clmulepi64_si128`\n*   **Carry-Less:** Think of this as \"XOR Multiplication.\" It multiplies numbers but drops the \"carry\" bit logic used in standard arithmetic. This is exactly how binary polynomials behave in Galois Fields (GF(2)).\n*   **Folding:** We load 128 bits. We multiply the top half by a magic constant (the polynomial) and XOR the result with the next block of data. This \"folds\" the old data into the new data.\n\n{{DIAGRAM:diag-016}}\n*Microscopic view of CRC32C. Notice the \"Barrett Reduction.\" We don't just sum numbers; we continuously multiply and XOR to keep the \"Remainder\" within the bounds of the 32-bit register.*\n\n### Phase 3: The Horizontal Sum (The Crush)\nOnce we have processed the whole file, we often end up with a 128-bit vector (`__m128i`) containing partial sums in different \"lanes.\" We need to crush this down to a single integer.\n*   **Horizontal Add (`PHADD`):** Adds adjacent elements within the *same* register.\n*   **Extraction:** Finally, we move the bottom 32/64 bits from the vector register to a general-purpose register (`RAX`) to return the result.\n\n{{DIAGRAM:diag-018}}\n*Visualizing the Horizontal Reduction. We start with 4 separate sums in one register. We shuffle and add them until a single scalar value remains.*\n\n## 4. The Debugging Lab\n\n### A. The \"Reflected\" Nightmare\n*   **The Myth:** \"Bits are bits. $1$ is $1$.\"\n*   **The Reality:** CRC algorithms often process bits \"backwards\" (Least Significant Bit first).\n*   **The Bug:** You implement the math perfectly, but your checksum doesn't match the standard implementation (like `gzip` or `ethernet`).\n*   **The Fix:** You might need to reverse the bits of your input bytes or your final result. This is called \"Reflection.\"\n\n### B. The Buffer Over-read\n*   **The Scenario:** You are folding 128 bits (16 bytes) at a time. Your file is 20 bytes long.\n*   **The Bug:** You process the first 16 bytes. You try to load the next 16 bytes, but only 4 bytes remain valid. You segfault or read garbage memory.\n*   **The Fix:** Similiar to `memcpy`, you must have a \"cleanup\" loop. Process the bulk with SIMD, then switch to a byte-by-byte scalar loop for the last few bytes.\n\n## 5. Code Scaffold\n\nWe will implement a **Horizontal XOR Reduction**. This is the simplest form of a checksum (Parity Check). It demonstrates how to \"crush\" a 128-bit vector into a single integer.\n\n**Your Task:**\n1.  Load data into a vector.\n2.  Use `_mm_xor_si128` to combine data (The simplified \"Fold\").\n3.  Implement the \"Horizontal Reduction\" to get the final scalar.\n\n```cpp\n#include <immintrin.h>\n#include <cstdint>\n#include <iostream>\n#include <vector>\n#include <numeric>\n\nclass ParityChecksum {\npublic:\n    // Calculates a 32-bit XOR checksum of a large buffer.\n    // This isn't CRC32, but it teaches the \"Fold and Crush\" mechanics.\n    static uint32_t calculate_xor32(const uint32_t* data, size_t count) {\n        // Accumulator: Starts at zero\n        __m128i v_acc = _mm_setzero_si128();\n\n        size_t i = 0;\n        // 1. The SIMD Loop (Process 4 integers at a time)\n        for (; i + 4 <= count; i += 4) {\n            // Load 128 bits (4 x 32-bit integers)\n            __m128i v_data = _mm_loadu_si128(reinterpret_cast<const __m128i*>(data + i));\n            \n            // The \"Fold\": Simple XOR in this case\n            v_acc = _mm_xor_si128(v_acc, v_data);\n        }\n\n        // At this point, v_acc contains [ A, B, C, D ]\n        // We need to calculate A ^ B ^ C ^ D\n\n        // 2. The Horizontal Reduction (The Crush)\n        \n        // Copy high 64-bits to low 64-bits and XOR\n        // v_acc: [ A, B, C, D ]\n        // high:  [ -, -, A, B ]\n        // res1:  [ ?, ?, A^C, B^D ]\n        __m128i v_high = _mm_unpackhi_epi64(v_acc, v_acc);\n        v_acc = _mm_xor_si128(v_acc, v_high);\n\n        // Now we have two 32-bit values in the bottom 64 bits: (A^C) and (B^D)\n        // We need to XOR those two together.\n        \n        // Shuffle the second 32-bit integer to the first slot\n        // 0b11100101 -> Shuffle control (Standard shuffle trick)\n        __m128i v_shuffle = _mm_shuffle_epi32(v_acc, _MM_SHUFFLE(0, 0, 0, 1));\n        v_acc = _mm_xor_si128(v_acc, v_shuffle);\n\n        // 3. Extract the Scalar\n        uint32_t result = _mm_cvtsi128_si32(v_acc);\n\n        // 4. Handle the Tail (Scalar cleanup)\n        for (; i < count; ++i) {\n            result ^= data[i];\n        }\n\n        return result;\n    }\n};\n\n// --- Test Harness ---\nint main() {\n    // Create a vector of numbers: 0, 1, 2... 10\n    std::vector<uint32_t> numbers;\n    for(int i=0; i<11; i++) numbers.push_back(i);\n\n    // Expected Result: 0^1^2^3...^10\n    uint32_t expected = 0;\n    for(uint32_t n : numbers) expected ^= n;\n\n    // SIMD Result\n    uint32_t calculated = ParityChecksum::calculate_xor32(numbers.data(), numbers.size());\n\n    std::cout << \">> Expected XOR: \" << expected << \"\\n\";\n    std::cout << \">> SIMD XOR:     \" << calculated << \"\\n\";\n\n    if (expected == calculated) {\n        std::cout << \">> Success: Horizontal reduction matches.\\n\";\n    } else {\n        std::cout << \">> Failure: Check algorithm logic.\\n\";\n    }\n\n    return 0;\n}\n```\n\n[↑ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-6\"></div>\n\n# Runtime Dispatch: The Chameleon Architecture\n\n## 1. The Epiphany: The Universal Socket Wrench\nImagine you are a mechanic (the Compiler) sending a toolkit (your Program) to a garage (the User's Computer). You have no idea what kind of bolts (CPU Architecture) that garage uses.\n\n*   **The Static Build:** You send only a metric wrench. If the garage uses imperial bolts, the tool is useless (Crash/Illegal Instruction).\n*   **The Lowest Common Denominator:** You send a pair of pliers. It works on everything, but it strips the bolts and takes 10 hours to finish a 10-minute job (Scalar/Slow).\n*   **The Runtime Dispatch (The Chameleon):** You send a box containing *every* type of wrench—Metric, Imperial, Torx. When the mechanic opens the box, a smart sensor scans the bolt, selects the perfect wrench, and snaps it onto the handle.\n\nIn Systems Programming, we don't know if the user has a 2012 laptop or a 2024 Server. **Runtime Dispatch** allows our binary to contain code for *all* of them and switch to the best one instantly.\n\n## 2. Technical Rationale\nWhy not just compile with `-march=native`?\n1.  **Portability:** If you compile specifically for your machine, that binary will crash on your grandmother's laptop (Illegal Instruction: `SIGILL`).\n2.  **Performance:** If you compile for \"generic\" x64, you leave 4x to 8x performance gains on the table by ignoring AVX2 or AVX-512 features.\n3.  **The Goal:** Write one binary that runs safely everywhere but runs *fast* on modern hardware.\n\n## 3. Internal Mechanics: The Hot-Swap\n\nHow do we switch code while the program is running? We use **Function Pointers**.\n\n### The \"Lazy\" Resolver\nWe don't want to check `CPUID` every time we call a function (that's too slow). We want to check it **once**, the first time the function is called.\n\n1.  **The Setup:** We create a global function pointer called `my_memcpy`. Initially, it points to a setup function called `resolve_memcpy`.\n2.  **The First Call:** The user calls `my_memcpy`. The CPU jumps to `resolve_memcpy`.\n3.  **The Decision:** `resolve_memcpy` asks the CPU: \"Do you have AVX2?\"\n4.  **The Hot-Patch:**\n    *   If Yes: It updates the global `my_memcpy` pointer to point to `memcpy_avx2`.\n    *   If No: It updates the pointer to `memcpy_scalar`.\n5.  **The Execution:** It runs the chosen function immediately so the user doesn't notice.\n6.  **The Future:** The *next* time the user calls `my_memcpy`, the pointer already points to the optimized version. The `resolve` function is never called again.\n\n\n![Runtime Dispatch Architecture](./diagrams/diag-004.svg)\n\n*The Dispatch Flow. Note the transition from Initialization (Red) to Optimized Path (Green). The \"Resolver\" modifies the Function Table in memory, permanently altering the program's behavior for the rest of its life.*\n\n## 4. The Debugging Lab\n\n### A. The \"Thread Race\" Condition\n*   **The Scenario:** Two threads call `my_memcpy` at the exact same time on startup.\n*   **The Bug:** Thread A enters the resolver. Thread B enters the resolver. Thread A updates the pointer. Thread B updates the pointer again.\n*   **The Fix:** In this specific case, it's usually benign (they both write the same address). However, strictly speaking, you should use `std::call_once` or atomic operations to ensure the transition is thread-safe.\n\n### B. The OS Lie\n*   **The Scenario:** `CPUID` says \"AVX Supported!\" but the program crashes with `SIGILL` anyway.\n*   **The Reason:** The CPU hardware supports it, but the Operating System (Kernel) has disabled it, or doesn't support saving the massive AVX registers during context switches.\n*   **The Fix:** A proper dispatcher checks both the CPU features *and* the OS capabilities (via `XGETBV` instruction) to ensure the registers are actually usable.\n\n## 5. Code Scaffold\n\nWe will build a **Self-Optimizing Maths Function**. It will calculate the dot product of two arrays.\n\n**Your Task:**\n1.  Define the function pointer type.\n2.  Implement a \"Safe\" version (Scalar) and a \"Fast\" version (AVX2 stub).\n3.  Implement the \"Resolver\" that rewires the connection.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <immintrin.h>\n\n// 1. Define the Interface\n// This is the \"Handle\" of our socket wrench.\ntypedef float (*dot_product_t)(const float*, const float*, size_t);\n\n// --- Implementation A: The Safe Fallback (Scalar) ---\nfloat dot_product_scalar(const float* a, const float* b, size_t n) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < n; ++i) {\n        sum += a[i] * b[i];\n    }\n    return sum;\n}\n\n// --- Implementation B: The Speedster (AVX2) ---\n// Quick Breakdown:\n// _mm256_fmadd_ps: Fused Multiply-Add. (a * b) + c in one step.\nfloat dot_product_avx2(const float* a, const float* b, size_t n) {\n    __m256 v_sum = _mm256_setzero_ps();\n    size_t i = 0;\n    // Process 8 floats at a time\n    for (; i + 8 <= n; i += 8) {\n        __m256 va = _mm256_loadu_ps(a + i);\n        __m256 vb = _mm256_loadu_ps(b + i);\n        v_sum = _mm256_fmadd_ps(va, vb, v_sum);\n    }\n    \n    // Horizontal reduction (Crush 8 floats to 1)\n    // (Simplified for brevity - typically involves shuffles)\n    float temp[8];\n    _mm256_storeu_ps(temp, v_sum);\n    float final_sum = 0.0f;\n    for(int j=0; j<8; j++) final_sum += temp[j];\n\n    // Tail cleanup\n    for (; i < n; ++i) {\n        final_sum += a[i] * b[i];\n    }\n    return final_sum;\n}\n\n// --- The Dispatcher Mechanics ---\n\n// Forward declaration of the pointer\ndot_product_t dot_product_ptr = nullptr;\n\n// The Resolver Function\nfloat resolve_dot_product(const float* a, const float* b, size_t n) {\n    std::cout << \"[System] Resolving CPU features...\\n\";\n    \n    // 1. Detection Logic (Mocked for this example)\n    // In reality, you check __builtin_cpu_supports(\"avx2\")\n    bool has_avx2 = true; // Let's pretend we have it\n\n    if (has_avx2) {\n        std::cout << \"[System] AVX2 Detected. Hot-patching to Fast Path.\\n\";\n        dot_product_ptr = &dot_product_avx2;\n    } else {\n        std::cout << \"[System] Old CPU Detected. Fallback to Scalar Path.\\n\";\n        dot_product_ptr = &dot_product_scalar;\n    }\n\n    // 2. Execute the chosen function for THIS call\n    return dot_product_ptr(a, b, n);\n}\n\n// Initialize the pointer to the Resolver\n// This is the \"Magic\" - the first call goes to the resolver.\ndot_product_t dot_product_dispatch = [](const float* a, const float* b, size_t n) -> float {\n    return resolve_dot_product(a, b, n);\n};\n\n// Global wrapper for ease of use\nfloat compute_dot_product(const std::vector<float>& v1, const std::vector<float>& v2) {\n    // We update the GLOBAL pointer if it hasn't been set\n    if (dot_product_ptr == nullptr) {\n        // First run logic\n        return dot_product_dispatch(v1.data(), v2.data(), v1.size());\n    }\n    // Fast path for all subsequent runs\n    return dot_product_ptr(v1.data(), v2.data(), v1.size());\n}\n\nint main() {\n    std::vector<float> v1(100, 1.0f);\n    std::vector<float> v2(100, 2.0f);\n\n    std::cout << \">> Call #1:\\n\";\n    float res1 = compute_dot_product(v1, v2); // Triggers resolver\n    std::cout << \"Result: \" << res1 << \"\\n\\n\";\n\n    std::cout << \">> Call #2:\\n\";\n    float res2 = compute_dot_product(v1, v2); // Goes straight to AVX2\n    std::cout << \"Result: \" << res2 << \"\\n\";\n\n    return 0;\n}\n```\n\n[↑ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-7\"></div>\n\n# Testing & Validation: The Crash Test Dummy Laboratory\n\n## 1. The Epiphany: The Off-Road Test Track\nImagine you have built a Ferrari (your optimized AVX2 function). It looks fast, and it drives beautifully on a perfectly smooth, straight highway (aligned memory, standard sizes).\n\nBut the real world isn't a highway. It's full of potholes, icy patches, and sudden brick walls.\n*   **Standard Testing:** Driving the Ferrari around the block once. \"It starts, so it works.\"\n*   **Systems Validation:** Driving the Ferrari into a brick wall at 100mph to see if the airbag works. Driving it on ice (unaligned memory). Driving it with only a thimble of gas (0-byte length). Driving it right up to the edge of a cliff (Memory Page Boundaries).\n\nIn SIMD programming, speed is useless without correctness. Because we are manipulating memory manually, a single off-by-one error doesn't just give the wrong answer—it crashes the entire application (Segmentation Fault).\n\n## 2. Technical Rationale\nWhy do we need a \"Torture Chamber\" for our code?\n1.  **The Oracle Problem:** How do you know your complex AVX-512 Dot Product is correct? You don't calculate it by hand. You compare it against a \"Golden Standard\"—a slow, boring, scalar C++ implementation that you *know* is correct.\n2.  **The Alignment Trap:** Instructions like `vmovaps` (Move Aligned Packed Single) are faster but will crash instantly if the memory address isn't divisible by 16 or 32. Your test harness must deliberately feed unaligned addresses to ensure your fallback logic works.\n3.  **The Page Boundary:** The most dangerous bug in systems programming. Operating Systems manage memory in \"Pages\" (usually 4096 bytes). If your SIMD instruction tries to read 16 bytes, but only 4 bytes are left in the current page, and the *next* page belongs to another process, the OS kills your program instantly.\n\n## 3. Internal Mechanics: Coverage & The Guard\nTo validate a system like this, we need a Matrix of Doom.\n\n### A. The Test Matrix\nWe don't just test random inputs. We iterate through every dangerous combination.\n\n\n![Test Matrix Coverage](./diagrams/diag-019.svg)\n\n*The Test Matrix Coverage. Notice the axes: Data Size (0 to Large), Alignment (0 to Cache Line), and CPU Generation. We must test the intersection of \"Unaligned Source\" + \"Aligned Destination\" + \"Tiny Size.\"*\n\n### B. The Oracle Pattern\nEvery test follows this structure:\n1.  **Generate Random Data:** Fill a buffer with garbage.\n2.  **Run Scalar:** Result A (The Truth).\n3.  **Run SIMD:** Result B (The Candidate).\n4.  **Assert:** `Result A == Result B`.\n\n### C. The Page Guard\nTo catch \"Over-reading,\" we use a trick. We allocate a buffer that ends *exactly* at a protected memory page.\n*   **Normal Alloc:** `[ Data ... ] [ More Free Heap space ... ]` -> Safe to over-read.\n*   **Guard Alloc:** `[ Data ... ] [ PROT_NONE Page ]` -> Over-reading triggers a crash immediately.\nThis forces bugs to show themselves during testing, rather than intermittently in production.\n\n## 4. The Debugging Lab\n\n### A. The \"Lucky Alignment\" False Positive\n*   **The Scenario:** You write a function that requires aligned memory. You run your test: `char buffer[100];`. It passes.\n*   **The Bug:** The compiler just happened to place `buffer` at address `0x...00` (aligned) by luck. In production, the user passes a pointer at `0x...01`, and the app explodes.\n*   **The Fix:** Manually offset your pointers in your test. `test_func(buffer + 1, size)`.\n\n### B. The Dirty Registers\n*   **The Scenario:** Your function works fine in isolation but returns garbage when called after a graphics rendering function.\n*   **The Reason:** You forgot to zero out your accumulator register (`_mm256_setzero_si256`) before starting your loop. You are adding your data to whatever garbage was left in the register by the previous function.\n*   **The Fix:** Always initialize your vectors.\n\n## 5. Code Scaffold\n\nWe will build a **Torture Harness**. It will verify a standard `memcpy` against our custom implementation, specifically hunting for alignment bugs.\n\n**Your Task:**\n1.  Create an \"Oracle\" (standard `memcpy`).\n2.  Create a loop that shifts the start pointer byte-by-byte (0 to 15) to test every alignment.\n3.  Compare the results byte-for-byte.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstring> // For std::memcpy (The Oracle)\n#include <cassert>\n\n// --- The Subject: Our \"Optimized\" Copy (Mocked) ---\n// This mimics a function that might fail on unaligned data\nvoid my_custom_copy(void* dest, const void* src, size_t n) {\n    // In a real scenario, this would be your AVX/SSE function.\n    // Here, we just wrap memcpy, but imagine it has bugs!\n    std::memcpy(dest, src, n); \n}\n\n// --- The Oracle: Truth Source ---\nvoid reference_copy(void* dest, const void* src, size_t n) {\n    std::memcpy(dest, src, n);\n}\n\nclass TortureChamber {\n    // Large buffer to play inside\n    std::vector<uint8_t> src_buffer;\n    std::vector<uint8_t> dst_ref;\n    std::vector<uint8_t> dst_test;\n    const size_t MAX_SIZE = 1024;\n\npublic:\n    TortureChamber() {\n        src_buffer.resize(MAX_SIZE * 2);\n        dst_ref.resize(MAX_SIZE * 2);\n        dst_test.resize(MAX_SIZE * 2);\n\n        // Fill source with random junk\n        for(size_t i=0; i<src_buffer.size(); i++) src_buffer[i] = (uint8_t)(i % 255);\n    }\n\n    void run_alignment_test() {\n        std::cout << \"[Test] Starting Alignment Torture...\\n\";\n\n        // Loop 1: Change Size\n        for (size_t size = 0; size < 128; ++size) {\n            \n            // Loop 2: Change Source Alignment (0 to 15)\n            for (size_t src_offset = 0; src_offset < 16; ++src_offset) {\n                \n                // Loop 3: Change Dest Alignment (0 to 15)\n                for (size_t dst_offset = 0; dst_offset < 16; ++dst_offset) {\n\n                    // Reset destinations\n                    std::fill(dst_ref.begin(), dst_ref.end(), 0);\n                    std::fill(dst_test.begin(), dst_test.end(), 0);\n\n                    // Pointers to the \"dangerous\" offsets\n                    uint8_t* p_src = src_buffer.data() + src_offset;\n                    uint8_t* p_ref = dst_ref.data() + dst_offset;\n                    uint8_t* p_tst = dst_test.data() + dst_offset;\n\n                    // 1. Run Oracle\n                    reference_copy(p_ref, p_src, size);\n\n                    // 2. Run Subject\n                    my_custom_copy(p_tst, p_src, size);\n\n                    // 3. Verify\n                    if (std::memcmp(p_ref, p_tst, size) != 0) {\n                        std::cerr << \">> FAILURE DETECTED!\\n\";\n                        std::cerr << \"   Size: \" << size << \"\\n\";\n                        std::cerr << \"   Src Offset: \" << src_offset << \"\\n\";\n                        std::cerr << \"   Dst Offset: \" << dst_offset << \"\\n\";\n                        std::exit(1);\n                    }\n                }\n            }\n        }\n        std::cout << \">> Success: All alignment combinations verified.\\n\";\n    }\n};\n\nint main() {\n    TortureChamber lab;\n    lab.run_alignment_test();\n    return 0;\n}\n```\n\n[↑ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-8\"></div>\n\n# Benchmarking Suite: The Scientific Method\n\n## 1. The Epiphany: The Wind Tunnel\nImagine you are an aerodynamic engineer. You claim your new spoiler design makes the car faster. You drive it around the block. \"Feels quicker,\" you say.\n\nThis is not science; it's guessing. In the world of high-performance systems, \"feeling\" fast is irrelevant. The OS is like the weather—sometimes there's a headwind (background updates), sometimes a tailwind (CPU frequency scaling).\n\nTo prove your AVX2 `memcpy` is actually faster than the Standard Library, you need a **Wind Tunnel**:\n1.  **Isolation:** No radio, no AC, no passengers (Shut down background tasks).\n2.  **Repetition:** You don't do one lap; you do 10,000 laps to average out the bumps.\n3.  **The Control Group:** You always race against a standard car (Baseline Implementation) to calculate the \"Speedup Factor.\"\n\n## 2. Technical Rationale\nWhy can't we just use `time ./my_program`?\n\n1.  **Resolution Limits:** System clocks measure in microseconds. Your AVX instruction takes *nanoseconds*. One run is too fast to measure.\n2.  **The Cold Start Problem:** When a CPU first wakes up, it's groggy. It's in a low-power state, and its Caches (L1/L2) are empty. The first run is always deceptively slow.\n3.  **Dead Code Elimination:** The Compiler is smarter than you. If you write a loop that calculates a value but never *prints* or *uses* it, the compiler deletes the loop entirely. Your benchmark will report \"0 seconds,\" and you will feel like a genius until you realize the code never ran.\n\n## 3. Internal Mechanics: The Stopwatch & The Black Hole\n\nTo build a trustworthy benchmark, we need three distinct phases.\n\n### Phase 1: The Warmup (Revving the Engine)\nWe run the function 1,000 times without measuring it. This forces the CPU to:\n*   Scale up its clock frequency (Turbo Boost).\n*   Load the data from RAM into the L1 Cache.\n*   Predict the branch patterns.\n\n### Phase 2: The Iteration (The Laps)\nWe run the function 1,000,000 times inside a `while` loop. We measure the *total* time and divide by the count.\n\n### Phase 3: The Black Hole (Escaping Optimization)\nTo stop the compiler from deleting our loop, we feed the result into a `volatile` variable or a \"Black Hole\" function. This tricks the compiler into thinking the result is critical, so it *must* execute the math.\n\n\n![Benchmark Harness Architecture](./diagrams/diag-020.svg)\n\n*The Benchmark Pipeline. Note the \"Warmup\" phase (Red) which is discarded. Only the \"Steady State\" iterations (Green) are recorded. The Statistical Analysis block filters out outliers caused by OS interruptions.*\n\n### Quick Breakdown: `std::chrono`\n> **High Resolution Clock:** The C++ standard tool for measuring time intervals. It asks the OS for the most precise tick count available (usually nanoseconds).\n\n## 4. The Debugging Lab\n\n### A. The \"Zero Second\" Miracle\n*   **The Symptom:** Your benchmark says your complex matrix multiplication took 0.00ns.\n*   **The Cause:** **Dead Code Elimination**. You calculated the matrix but didn't return it. The compiler deleted your function call.\n*   **The Fix:** Use `DoNotOptimize(result)`. In C++, reading/writing to a `volatile` memory address forces execution.\n\n### B. The Throttled CPU\n*   **The Symptom:** Your results vary wildly. Run 1: 50ms. Run 2: 120ms.\n*   **The Cause:** Thermal Throttling or Power Saving. Your laptop got hot, so the CPU slowed down. Or, your laptop was unplugged, so it's saving battery.\n*   **The Fix:** Always benchmark on a plugged-in machine, ideally with \"High Performance\" power plan enabled.\n\n## 5. Code Scaffold\n\nWe will build a **Micro-Benchmark Runner**. It will race a standard `std::accumulate` against a manual loop to see which is faster.\n\n**Your Task:**\n1.  Implement the `escape` function (The Black Hole).\n2.  Implement the `measure` function with a warmup phase.\n3.  Calculate the relative speedup ($Time_{baseline} / Time_{optimized}$).\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <numeric> // for std::accumulate\n#include <chrono>  // for time\n#include <cmath>\n\n// --- The Black Hole ---\n// This prevents the compiler from optimizing away our loops.\n// We tell the compiler: \"This value is modified externally, don't touch it.\"\ntemplate <class T>\nvoid do_not_optimize(T& value) {\n    asm volatile(\"\" : \"+r\"(value)); \n}\n\n// --- The Subjects ---\n\n// 1. The Baseline (Standard Library)\nlong long baseline_algo(const std::vector<int>& data) {\n    return std::accumulate(data.begin(), data.end(), 0LL);\n}\n\n// 2. The Challenger (Manual Loop)\nlong long challenge_algo(const std::vector<int>& data) {\n    long long sum = 0;\n    for (int x : data) {\n        sum += x;\n    }\n    return sum;\n}\n\n// --- The Harness ---\n\nstruct BenchResult {\n    std::string name;\n    double duration_ms;\n};\n\ntemplate <typename Func>\nBenchResult run_benchmark(std::string name, Func func, const std::vector<int>& data) {\n    using namespace std::chrono;\n\n    long long dummy_result = 0;\n\n    // 1. WARMUP (Rev the engine)\n    // Run for a bit to fill cache and wake up CPU\n    for (int i = 0; i < 1000; ++i) {\n        dummy_result = func(data);\n        do_not_optimize(dummy_result);\n    }\n\n    // 2. MEASURE\n    const int iterations = 10000;\n    auto start = high_resolution_clock::now();\n\n    for (int i = 0; i < iterations; ++i) {\n        dummy_result = func(data);\n        // CRITICAL: Force the compiler to believe this result is used\n        do_not_optimize(dummy_result);\n    }\n\n    auto end = high_resolution_clock::now();\n\n    // 3. CALCULATE\n    duration<double, std::milli> ms = end - start;\n    return {name, ms.count() / iterations};\n}\n\nint main() {\n    // Setup Data (1 Million Integers)\n    std::vector<int> data(1000000);\n    std::fill(data.begin(), data.end(), 1);\n\n    std::cout << \">> Benchmarking on \" << data.size() << \" elements...\\n\";\n\n    // Run Races\n    auto res_base = run_benchmark(\"std::accumulate\", baseline_algo, data);\n    auto res_opt  = run_benchmark(\"Manual Loop\",     challenge_algo, data);\n\n    // Report\n    std::cout << \"------------------------------------------------\\n\";\n    std::cout << res_base.name << \": \" << res_base.duration_ms << \" ms/iter\\n\";\n    std::cout << res_opt.name  << \": \" << res_opt.duration_ms  << \" ms/iter\\n\";\n    std::cout << \"------------------------------------------------\\n\";\n\n    double speedup = res_base.duration_ms / res_opt.duration_ms;\n    std::cout << \">> Speedup Factor: \" << speedup << \"x\\n\";\n\n    if (speedup > 1.0) std::cout << \">> Winner: Manual Loop\\n\";\n    else std::cout << \">> Winner: Standard Library (Compilers are smart!)\\n\";\n\n    return 0;\n}\n```\n\n[↑ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-9\"></div>\n\n# Library Integration: The Public Face\n\n## 1. The Epiphany: The Dashboard\nYou have just spent weeks building a V12 engine (your AVX-512 optimized algorithms). It is powerful, complex, and dangerous.\nIf you hand this engine to a driver (a consumer developer) with a bundle of loose wires and say, \"Touch the red wire to the blue wire to inject fuel,\" they will crash.\n\nA Library API is the **Car Dashboard**.\n*   **The Steering Wheel:** The public function `compute_dot_product()`. It’s clean, ergonomic, and doesn't scare the driver.\n*   **The Engine Cover:** The internal files (`.cpp`). We hide the complex fuel injection timing (AVX registers, dispatch tables) underneath. The driver never sees them.\n*   **The Ignition:** The initialization logic that automatically detects the CPU type. The driver just turns the key; they don't manually select \"Spark Plug Mode: Haswell\".\n\n## 2. Technical Rationale\nWhy do we spend time wrapping our code? Why not just give them the `.cpp` file?\n\n1.  **Symbol Pollution:** If you define a global function named `init()`, and the user also has a function named `init()`, the Linker will panic (Duplicate Symbol Error). We must wrap our code in **Namespaces**.\n2.  **The \"Mangling\" Wall:** C++ compilers change function names to include argument types (e.g., `_Z3addii` for `add(int, int)`). C compilers do not (`_add`). If a C program tries to call your C++ library, it won't find the name unless you use `extern \"C\"`.\n3.  **ABI Stability (Binary Compatibility):** If you change the size of a class in your library update, but the user doesn't recompile their application, their app will crash because it's looking for data at the wrong offsets. A clean API minimizes these breaking changes.\n\n## 3. Internal Mechanics: The Velvet Rope\nTo create a professional library, we must control exactly what the outside world sees.\n\n### A. The Export Macro\nOperating Systems hide symbols by default (or expose everything, depending on the compiler). We need a unified way to say \"This function is for the public.\"\n\n*   **Windows (DLL):** Needs `__declspec(dllexport)` to share a function.\n*   **Linux (GCC/Clang):** Needs `__attribute__((visibility(\"default\")))`.\n\n### B. The Header File (The Contract)\nThis is the *only* file the user sees. It must contain:\n1.  **Include Guards:** `#ifndef LIB_H ...` to prevent infinite inclusion loops.\n2.  **Extern \"C\":** To allow C and Python (via ctypes) to call your code.\n3.  **Documentation:** clear comments explaining inputs and outputs.\n\n\n![Public API Surface](./diagrams/diag-021.svg)\n\n*The Public API Surface. Notice how the internal logic (AVX Dispatcher, Resolver) is completely hidden. The User Application links only against the \"Exported Symbols\" (The Dashboard).*\n\n### C. The Dispatch Hiding\nThe user calls `fast_copy()`. Internally, we route this to `fast_copy_avx2()`. The user *never* sees the AVX2 version in the header. If they did, their compiler might try to compile AVX2 instructions on a machine that doesn't support them, causing a crash at compile-time or run-time.\n\n## 4. The Debugging Lab\n\n### A. The \"Undefined Reference\" Nightmare\n*   **The Symptom:** You compile your library, then try to use it in a C application. The linker screams: `undefined reference to 'simd_add'`.\n*   **The Cause:** You wrote the library in C++ but forgot to wrap the declaration in `extern \"C\"`. The C++ compiler mangled the name to `_Z8simd_addv`, but the C linker is looking for `_simd_add`.\n*   **The Fix:** Wrap public headers in the `extern \"C\" { ... }` block.\n\n### B. The \"Header Hell\"\n*   **The Symptom:** Your library works fine, but when the user includes `<windows.h>` *before* your library, everything breaks.\n*   **The Cause:** Macro collisions. `windows.h` often defines macros like `min` and `max`. If your header uses a variable named `max`, the preprocessor replaces it with garbage.\n*   **The Fix:** Keep your public headers minimal. Don't include heavy system headers in your public API if you can avoid it. Use distinct naming (`simd_max` instead of `max`).\n\n## 5. Code Scaffold\n\nWe will build the **Final Integration Layer**. This involves a portable header file and the implementation that bridges the public calls to our internal dispatcher.\n\n**Your Task:**\n1.  Create the `SIMD_API` macro to handle Windows/Linux export differences.\n2.  Wrap the API in a Namespace.\n3.  Implement the \"Facade\" functions that forward calls to the dispatcher.\n\n### Part 1: The Public Header (`simd_lib.h`)\nThis is what you give to the user.\n\n```cpp\n#ifndef SIMD_LIB_H\n#define SIMD_LIB_H\n\n#include <cstddef> // for size_t\n\n// --- 1. Portability Macros ---\n// We need to handle Windows (DLL) vs Linux (Shared Object)\n#if defined(_WIN32)\n    #ifdef SIMD_LIBRARY_EXPORTS // Defined when building the library itself\n        #define SIMD_API __declspec(dllexport)\n    #else\n        #define SIMD_API __declspec(dllimport) // Defined when USING the library\n    #endif\n#else\n    #define SIMD_API __attribute__((visibility(\"default\")))\n#endif\n\n// --- 2. C Compatibility ---\n// Allows this library to be used by C, C++, Python, Rust, etc.\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n    /**\n     * @brief Computes the dot product of two arrays using the fastest available SIMD instruction set.\n     * \n     * @param a Pointer to the first array (float).\n     * @param b Pointer to the second array (float).\n     * @param n Number of elements.\n     * @return float The sum of products.\n     */\n    SIMD_API float simd_dot_product(const float* a, const float* b, size_t n);\n\n    /**\n     * @brief High-speed memory copy. Handles alignment automatically.\n     */\n    SIMD_API void simd_memcpy(void* dest, const void* src, size_t n);\n\n    /**\n     * @brief Initialize the library manually (Optional).\n     * Detects CPU features. If not called, the first function call will trigger it.\n     */\n    SIMD_API void simd_init();\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // SIMD_LIB_H\n```\n\n### Part 2: The Implementation (`simd_lib.cpp`)\nThis is compiled into your `.dll` or `.so`.\n\n```cpp\n#include \"simd_lib.h\"\n#include <iostream>\n#include <mutex>\n\n// --- INTERNAL Declarations (Not visible to user) ---\n// These are the function pointer types defined in previous sections\ntypedef float (*dot_product_func)(const float*, const float*, size_t);\ntypedef void (*memcpy_func)(void*, const void*, size_t);\n\n// Forward declare the resolvers (implemented in cpu_dispatch.cpp)\nextern dot_product_func resolve_dot_product_impl(); \nextern memcpy_func resolve_memcpy_impl();\n\n// Global function pointers, initialized to null\nstatic dot_product_func g_dot_ptr = nullptr;\nstatic memcpy_func g_copy_ptr = nullptr;\nstatic std::once_flag g_init_flag;\n\n// --- INTERNAL: The Lazy Initializer ---\nvoid perform_cpu_detection() {\n    // This connects the global pointers to the AVX/SSE implementations\n    g_dot_ptr = resolve_dot_product_impl();\n    g_copy_ptr = resolve_memcpy_impl();\n    // In a real app, you might log here: \"Detected AVX-512 Support\"\n}\n\n// --- PUBLIC API Implementation ---\n\nSIMD_API void simd_init() {\n    std::call_once(g_init_flag, perform_cpu_detection);\n}\n\nSIMD_API float simd_dot_product(const float* a, const float* b, size_t n) {\n    // 1. Lazy Init: If pointer is null, run detection\n    // Note: We use double-checked locking optimization or std::call_once pattern in production\n    // For simplicity, we assume simd_init is fast or called once.\n    if (!g_dot_ptr) simd_init();\n\n    // 2. Dispatch\n    return g_dot_ptr(a, b, n);\n}\n\nSIMD_API void simd_memcpy(void* dest, const void* src, size_t n) {\n    if (!g_copy_ptr) simd_init();\n    g_copy_ptr(dest, src, n);\n}\n```\n\n[↑ Back to System Map](#satellite-map)\n"}