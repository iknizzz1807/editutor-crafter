{"html":"<h1 id=\"simple-mark-sweep-garbage-collector\">Simple Mark-Sweep Garbage Collector</h1>\n<p>A foundational garbage collector implementing the mark-sweep algorithm. This system automatically reclaims memory by identifying reachable objects from root references, marking them as live, and sweeping unreachable objects to free memory. The architecture demonstrates core GC concepts including object graphs, root scanning, tri-color marking, and memory compaction strategies.</p>\n<h1 id=\"system-architecture-overview\">System Architecture Overview</h1>\n<div id=\"ms-system-overview\"></div>\n\n<h2 id=\"the-city-sanitation-analogy\">The City Sanitation Analogy</h2>\n<p>Imagine a bustling city where buildings (objects) are constantly being constructed and abandoned. Your garbage collector is the <strong>sanitation department</strong> that must:</p>\n<ol>\n<li><strong>Identify which buildings are still in use</strong> by tracing roads (pointers) from government offices (root references)</li>\n<li><strong>Mark active buildings</strong> with a flag so they&#39;re not demolished</li>\n<li><strong>Sweep through the city</strong> and demolish abandoned buildings</li>\n<li><strong>Optionally compact</strong> the remaining buildings to eliminate gaps</li>\n</ol>\n<p>The genius? The sanitation department doesn&#39;t need residents to call when they abandon a buildingâ€”it figures it out automatically by checking connectivity.</p>\n<hr>\n<h2 id=\"why-this-architecture-exists-the-memory-leak-problem\">Why This Architecture Exists: The Memory Leak Problem</h2>\n<p><strong>The Core Problem</strong>: In manual memory management (like C), programmers must explicitly free every allocated object. This leads to two catastrophic failure modes:</p>\n<ul>\n<li><strong>Memory leaks</strong>: Forgetting to free â†’ program consumes unbounded memory</li>\n<li><strong>Use-after-free bugs</strong>: Freeing too early â†’ dangling pointers cause crashes or security vulnerabilities</li>\n</ul>\n<p><strong>The Solution</strong>: Automatic garbage collection inverts the problem. Instead of tracking &quot;what should be freed,&quot; we track &quot;what must be kept alive.&quot; Everything else is garbage.</p>\n<p><strong>The Trade-off</strong>: We sacrifice deterministic deallocation and accept periodic pause times in exchange for memory safety and programmer productivity.</p>\n<hr>\n<h2 id=\"the-complete-system-a-satellite-view\">The Complete System: A Satellite View</h2>\n<p>Our mark-sweep garbage collector consists of <strong>five interconnected subsystems</strong> that work in a precise choreography:</p>\n<p>{{DIAGRAM:system-overview}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    APPLICATION LAYER                         â”‚\nâ”‚  (User code creating objects, manipulating pointers)        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n             â”‚\n             â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  â‘  ROOT SET MANAGER                                         â”‚\nâ”‚  â€¢ Stack scanner (local variables)                          â”‚\nâ”‚  â€¢ Global variable registry                                 â”‚\nâ”‚  â€¢ Thread-local storage roots                               â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n             â”‚\n             â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  â‘¡ HEAP MANAGER                                             â”‚\nâ”‚  â€¢ Free list (available memory blocks)                      â”‚\nâ”‚  â€¢ Allocation policy (first-fit/best-fit)                   â”‚\nâ”‚  â€¢ Object metadata (size, type, mark bit)                   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n             â”‚\n             â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  â‘¢ MARK PHASE ENGINE                                        â”‚\nâ”‚  â€¢ Tri-color abstraction (White/Gray/Black)                 â”‚\nâ”‚  â€¢ Work queue (objects to scan)                             â”‚\nâ”‚  â€¢ Pointer traversal logic                                  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n             â”‚\n             â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  â‘£ SWEEP PHASE ENGINE                                       â”‚\nâ”‚  â€¢ Linear heap scan                                         â”‚\nâ”‚  â€¢ Unmarked object reclamation                              â”‚\nâ”‚  â€¢ Free list reconstruction                                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n             â”‚\n             â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  â‘¤ COMPACTION ENGINE (Optional)                             â”‚\nâ”‚  â€¢ Live object relocation                                   â”‚\nâ”‚  â€¢ Pointer fixup (updating references)                      â”‚\nâ”‚  â€¢ Defragmentation                                          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></div>\n\n<hr>\n<h2 id=\"internal-mechanics-how-the-pieces-interact\">Internal Mechanics: How the Pieces Interact</h2>\n<h3 id=\"the-gc-cycle-lifecycle\">The GC Cycle Lifecycle</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ALLOCATION â†’ TRIGGER â†’ MARK â†’ SWEEP â†’ [COMPACT] â†’ RESUME</code></pre></div>\n\n<p>Let&#39;s trace a single garbage collection cycle:</p>\n<h4 id=\"phase-0-normal-execution\"><strong>Phase 0: Normal Execution</strong></h4>\n<ul>\n<li>Application allocates objects via <code>gc_alloc(size)</code></li>\n<li>Heap manager maintains a <strong>free list</strong> of available memory blocks</li>\n<li>Each allocation checks: &quot;Is heap pressure too high?&quot; If yes â†’ trigger GC</li>\n</ul>\n<h4 id=\"phase-1-root-scanning\"><strong>Phase 1: Root Scanning</strong></h4>\n<p>The Root Set Manager identifies <strong>GC roots</strong>â€”pointers that are inherently reachable:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Example roots in a typical program</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> roots</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    &#x26;</span><span style=\"color:#E1E4E8\">global_var,</span><span style=\"color:#6A737D\">           // Global variables</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stack_frame_locals,</span><span style=\"color:#6A737D\">    // Local variables on call stack</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    thread_local_storage</span><span style=\"color:#6A737D\">   // Per-thread static data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Critical Insight</strong>: Roots are the &quot;axioms&quot; of reachability. If an object isn&#39;t reachable from a root (directly or transitively), it&#39;s garbage.</p>\n<h4 id=\"phase-2-mark-phase-tri-color-abstraction\"><strong>Phase 2: Mark Phase (Tri-Color Abstraction)</strong></h4>\n<p>The Mark Phase Engine uses a <strong>work queue</strong> to traverse the object graph:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>WHITE: Not yet visited (assumed garbage)\nGRAY:  Visited but children not yet scanned (work queue)\nBLACK: Fully processed (confirmed live)</code></pre></div>\n\n<p><strong>Algorithm</strong>:</p>\n<ol>\n<li>Color all objects WHITE</li>\n<li>Color all roots GRAY, add to work queue</li>\n<li>While work queue not empty:<ul>\n<li>Pop object O from queue</li>\n<li>For each pointer P in O:<ul>\n<li>If P points to WHITE object:<ul>\n<li>Color it GRAY</li>\n<li>Add to work queue</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Color O BLACK</li>\n</ul>\n</li>\n</ol>\n<p><strong>Why This Works</strong>: At the end, BLACK objects are reachable, WHITE objects are garbage. GRAY is a temporary state.</p>\n<h4 id=\"phase-3-sweep-phase\"><strong>Phase 3: Sweep Phase</strong></h4>\n<p>The Sweep Phase Engine performs a <strong>linear scan</strong> of the entire heap:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (each block in heap) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block.color </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> WHITE) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Unreachable â†’ reclaim</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        add_to_free_list</span><span style=\"color:#E1E4E8\">(block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Live object â†’ reset mark for next cycle</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block.color </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> WHITE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Performance Note</strong>: This is O(heap_size), not O(live_objects). Even if only 1% of the heap is live, we scan 100%.</p>\n<h4 id=\"phase-4-compaction-optional\"><strong>Phase 4: Compaction (Optional)</strong></h4>\n<p>The Compaction Engine eliminates <strong>fragmentation</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>BEFORE:  [OBJ1][FREE][OBJ2][FREE][FREE][OBJ3]\nAFTER:   [OBJ1][OBJ2][OBJ3][FREE][FREE][FREE]</code></pre></div>\n\n<p><strong>The Pointer Fixup Problem</strong>: When we move OBJ2, we must update <strong>every pointer</strong> that references it. This requires either:</p>\n<ul>\n<li>A second heap scan (expensive)</li>\n<li>Forwarding pointers (extra metadata)</li>\n<li>A remembered set (complex bookkeeping)</li>\n</ul>\n<hr>\n<h2 id=\"the-data-structures-memory-layout\">The Data Structures: Memory Layout</h2>\n<h3 id=\"object-header-per-allocation\">Object Header (Per Allocation)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">        // Object size in bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> marked : </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Mark bit (0=white, 1=black)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> type : </span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   // Object type ID (for pointer scanning)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Actual object data follows...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ObjectHeader;</span></span></code></pre></div>\n\n<p><strong>Why 1 Bit for Marking?</strong> We only need binary state. Some advanced GCs use 2 bits for tri-color, but we can implement tri-color with 1 bit + a work queue.</p>\n<h3 id=\"free-list-node\">Free List Node</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> FreeBlock {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} FreeBlock;</span></span></code></pre></div>\n\n<p><strong>Critical Detail</strong>: Free blocks <strong>reuse the object memory itself</strong> to store the linked list. This is why minimum allocation size must be â‰¥ <code>sizeof(FreeBlock)</code>.</p>\n<h3 id=\"root-set-registry\">Root Set Registry</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> roots;</span><span style=\"color:#6A737D\">       // Array of pointers to roots</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> capacity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} RootSet;</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"the-debugging-lab-common-failure-modes\">The Debugging Lab: Common Failure Modes</h2>\n<h3 id=\"-bug-1-premature-collection-false-negative\">ğŸ› <strong>Bug 1: Premature Collection (False Negative)</strong></h3>\n<p><strong>Symptom</strong>: Live objects are collected, causing use-after-free crashes.</p>\n<p><strong>Root Cause</strong>: A root was not registered. Example:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> temp </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// If 'temp' is in a register (not on stack), </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// and we don't register it as a root...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gc_collect</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\"> // BOOM: 'temp' is swept!</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Conservative stack scanning (treat anything that looks like a pointer as a root).</p>\n<h3 id=\"-bug-2-memory-leak-false-positive\">ğŸ› <strong>Bug 2: Memory Leak (False Positive)</strong></h3>\n<p><strong>Symptom</strong>: Memory usage grows unbounded despite GC running.</p>\n<p><strong>Root Cause</strong>: An unintended reference keeps objects alive. Example:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#E1E4E8\"> Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> debug_log</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\"> // Global array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// If we forget to clear old entries, they'reæ°¸ä¹… roots!</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Weak references or explicit nulling.</p>\n<h3 id=\"-bug-3-fragmentation-death-spiral\">ğŸ› <strong>Bug 3: Fragmentation Death Spiral</strong></h3>\n<p><strong>Symptom</strong>: Allocation fails despite sufficient total free memory.</p>\n<p><strong>Root Cause</strong>: Free memory is scattered in small chunks.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Heap: [OBJ][2KB free][OBJ][1KB free][OBJ][3KB free]\nRequest: 5KB â†’ FAIL (no contiguous block)</code></pre></div>\n\n<p><strong>Fix</strong>: Implement compaction or use a buddy allocator.</p>\n<hr>\n<h2 id=\"your-mission-the-code-scaffold\">Your Mission: The Code Scaffold</h2>\n<p>You will implement this system in <strong>five milestones</strong>:</p>\n<ol>\n<li><strong><a href=\"#heap-manager\">Heap Manager</a></strong>: Implement <code>gc_alloc()</code> and free list management</li>\n<li><strong><a href=\"#root-scanner\">Root Scanner</a></strong>: Build stack and global variable scanning</li>\n<li><strong><a href=\"#mark-engine\">Mark Engine</a></strong>: Implement tri-color marking with work queue</li>\n<li><strong><a href=\"#sweep-engine\">Sweep Engine</a></strong>: Reclaim unmarked objects</li>\n<li><strong><a href=\"#compaction\">Compaction</a></strong>: (Advanced) Relocate objects and fix pointers</li>\n</ol>\n<h3 id=\"starter-code-structure\">Starter Code Structure</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// gc.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> GC {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> heap_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RootSet roots;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectQueue mark_queue;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} GC;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Your tasks:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> heap_size</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_collect</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_register_root</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void**</span><span style=\"color:#FFAB70\"> root</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h3 id=\"success-criteria\">Success Criteria</h3>\n<p>Your implementation must pass these tests:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Test 1: Basic allocation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(obj </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test 2: Collection reclaims garbage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> temp </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">temp </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // No more references</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Verify 1000 bytes returned to free list</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test 3: Roots prevent collection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> root </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">500</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gc_register_root</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">root</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(root </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> // Still valid!</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"navigation-where-to-go-next\">Navigation: Where to Go Next</h2>\n<p>This overview gave you the <strong>30,000-foot view</strong>. Now it&#39;s time to zoom in:</p>\n<ul>\n<li><strong><a href=\"#heap-manager\">Heap Manager â†’</a></strong>: Learn how memory blocks are organized</li>\n<li><strong><a href=\"#root-scanner\">Root Scanner â†’</a></strong>: Understand how we find GC roots</li>\n<li><strong><a href=\"#mark-engine\">Mark Phase â†’</a></strong>: Deep-dive into graph traversal</li>\n<li><strong><a href=\"#sweep-engine\">Sweep Phase â†’</a></strong>: See how we reclaim memory</li>\n<li><strong><a href=\"#compaction\">Compaction â†’</a></strong>: Master defragmentation</li>\n</ul>\n<p>Each section will follow the same structure: analogy â†’ theory â†’ implementation â†’ debugging.</p>\n<p><strong>Pro Tip</strong>: Keep this system map open in a split-screen. When you get lost in implementation details, return here to see how the piece fits into the whole.</p>\n<hr>\n<p><a href=\"#satellite-map\">â†‘ Back to System Map</a></p>\n<div id=\"ms-heap-structure\"></div>\n\n<h1 id=\"milestone-2-heap-memory-organization\">Milestone 2: Heap Memory Organization</h1>\n<h2 id=\"the-epiphany-analogy-a-self-storage-facility\">The Epiphany Analogy: A Self-Storage Facility</h2>\n<p>Imagine a <strong>self-storage facility</strong> with units of different sizes. When a customer needs storage:</p>\n<ol>\n<li><strong>The manager checks the vacancy board</strong> (free list) for available units</li>\n<li><strong>Each unit has a label on the door</strong> (object header) showing:<ul>\n<li>Size of the unit</li>\n<li>Whether it&#39;s currently inspected/marked for renewal</li>\n<li>What type of items are stored (for insurance purposes)</li>\n</ul>\n</li>\n<li><strong>Empty units are chained together</strong> with signs pointing to the next available unit</li>\n<li><strong>The manager uses a &quot;first-fit&quot; strategy</strong>: Walk down the chain until you find a unit big enough</li>\n</ol>\n<p><strong>The Key Insight</strong>: The vacancy signs are <strong>written on the doors of empty units themselves</strong>â€”we don&#39;t need a separate building for bookkeeping. This is exactly how heap memory reuses freed space for metadata.</p>\n<hr>\n<h2 id=\"technical-rationale-why-this-design\">Technical Rationale: Why This Design?</h2>\n<h3 id=\"the-three-fundamental-constraints\">The Three Fundamental Constraints</h3>\n<p><strong>Constraint 1: Metadata Must Be Recoverable</strong></p>\n<ul>\n<li>During sweep phase, we must identify object boundaries without external help</li>\n<li>Solution: Every allocation includes a header with size information</li>\n</ul>\n<p><strong>Constraint 2: Free Space Must Be Trackable</strong></p>\n<ul>\n<li>We need O(1) access to available memory blocks</li>\n<li>Solution: Intrusive linked list (free list) stored in the freed memory itself</li>\n</ul>\n<p><strong>Constraint 3: GC Must Distinguish Pointers from Data</strong></p>\n<ul>\n<li>Not all bytes in an object are pointers (e.g., integers, floats)</li>\n<li>Solution: Type metadata in header tells us which fields to traverse</li>\n</ul>\n<h3 id=\"why-not-use-malloc\">Why Not Use <code>malloc()</code>?</h3>\n<p>Standard <code>malloc()</code> is <strong>GC-hostile</strong>:</p>\n<ul>\n<li>No standardized metadata layout (can&#39;t iterate heap)</li>\n<li>No mark bits (can&#39;t track reachability)</li>\n<li>Fragmentation-prone (no compaction support)</li>\n</ul>\n<p><strong>Our heap is a custom allocator</strong> designed for garbage collection.</p>\n<hr>\n<h2 id=\"internal-mechanics-the-memory-layout\">Internal Mechanics: The Memory Layout</h2>\n<h3 id=\"the-complete-heap-structure\">The Complete Heap Structure</h3>\n<p>{{DIAGRAM:heap-layout}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>HEAP MEMORY (Contiguous Block)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ HEAP START                                                   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚ â”‚ OBJECT 1 HEADER (16 bytes)                              â”‚ â”‚\nâ”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚ â”‚\nâ”‚ â”‚ â”‚ size: 64 â”‚ marked:0 â”‚ type: 3  â”‚ padding  â”‚          â”‚ â”‚\nâ”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ â”‚\nâ”‚ â”‚ OBJECT 1 DATA (64 bytes)                                â”‚ â”‚\nâ”‚ â”‚ [user data: pointers, integers, etc.]                   â”‚ â”‚\nâ”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚ â”‚ FREE BLOCK HEADER (16 bytes)                            â”‚ â”‚\nâ”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚ â”‚\nâ”‚ â”‚ â”‚ size:128 â”‚ next: â”€â”€â”€â”€â”€â”€â”€â”                   â”‚        â”‚ â”‚\nâ”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚ â”‚\nâ”‚ â”‚ FREE SPACE (128 bytes)    â”‚                             â”‚ â”‚\nâ”‚ â”‚ [unused memory]           â”‚                             â”‚ â”‚\nâ”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚ â”‚ OBJECT 2 HEADER (16 bytes)                              â”‚ â”‚\nâ”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚ â”‚\nâ”‚ â”‚ â”‚ size: 32 â”‚ marked:1 â”‚ type: 1  â”‚ padding  â”‚          â”‚ â”‚\nâ”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ â”‚\nâ”‚ â”‚ OBJECT 2 DATA (32 bytes)                                â”‚ â”‚\nâ”‚ â”‚ [user data]                                             â”‚ â”‚\nâ”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚ â”‚ FREE BLOCK HEADER (16 bytes)                            â”‚ â”‚\nâ”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚ â”‚\nâ”‚ â”‚ â”‚ size:256 â”‚ next: NULL                       â”‚        â”‚ â”‚\nâ”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚ â”‚\nâ”‚ â”‚ FREE SPACE (256 bytes)                                  â”‚ â”‚\nâ”‚ â”‚ [unused memory]                                         â”‚ â”‚\nâ”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ HEAP END                                                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nFREE LIST (Logical View):\nfree_list â†’ [128 bytes] â†’ [256 bytes] â†’ NULL</code></pre></div>\n\n<h3 id=\"anatomy-of-an-object-header\">Anatomy of an Object Header</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">        // Total size INCLUDING header (in bytes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> marked : </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // GC mark bit (0=white/unmarked, 1=black/marked)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> type : </span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   // Type ID (0-127) for pointer map lookup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> padding</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\"> // Align to 16 bytes (cache line friendly)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ObjectHeader;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Size: 16 bytes (8 + 1 + 7 padding)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Alignment: 16-byte boundary (required for SIMD, cache efficiency)</span></span></code></pre></div>\n\n<p><strong>ğŸ” Quick Breakdown: Why These Fields?</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Purpose</th>\n<th>Size</th>\n<th>Critical Details</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>size</code></td>\n<td>Enables heap iteration</td>\n<td>8 bytes</td>\n<td>Includes header size! <code>size &gt;= 16 + user_data</code></td>\n</tr>\n<tr>\n<td><code>marked</code></td>\n<td>Tri-color marking</td>\n<td>1 bit</td>\n<td>0=WHITE (garbage), 1=BLACK (live)</td>\n</tr>\n<tr>\n<td><code>type</code></td>\n<td>Pointer map index</td>\n<td>7 bits</td>\n<td>Maps to type descriptor (which fields are pointers)</td>\n</tr>\n<tr>\n<td><code>padding</code></td>\n<td>Alignment</td>\n<td>7 bytes</td>\n<td>Ensures 16-byte alignment for performance</td>\n</tr>\n</tbody></table>\n<p><strong>Why 16-Byte Alignment?</strong></p>\n<ul>\n<li>Modern CPUs fetch memory in cache lines (64 bytes)</li>\n<li>Misaligned access causes performance penalties (2x slower on some architectures)</li>\n<li>SIMD instructions (SSE, AVX) require 16-byte alignment</li>\n</ul>\n<h3 id=\"anatomy-of-a-free-block\">Anatomy of a Free Block</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> FreeBlock {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">              // Size of this free block (including header)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span><span style=\"color:#6A737D\">   // Pointer to next free block (or NULL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remaining bytes are unused</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} FreeBlock;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Size: 16 bytes minimum (8 + 8)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The rest of the block is unused memory</span></span></code></pre></div>\n\n<p><strong>Critical Insight</strong>: Free blocks <strong>overwrite</strong> the object header. When we allocate, we convert:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>FREE BLOCK                    ALLOCATED OBJECT\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ size: 128    â”‚             â”‚ size: 128    â”‚\nâ”‚ next: 0x...  â”‚    â”€â”€â”€â–º     â”‚ marked: 0    â”‚\nâ”‚ [unused]     â”‚             â”‚ type: 5      â”‚\nâ”‚ [unused]     â”‚             â”‚ [user data]  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></div>\n\n<h3 id=\"type-descriptors-the-pointer-map\">Type Descriptors: The Pointer Map</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> type_id;</span><span style=\"color:#6A737D\">           // Matches ObjectHeader.type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> field_count;</span><span style=\"color:#6A737D\">        // Number of fields in this type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t*</span><span style=\"color:#E1E4E8\"> pointer_offsets;</span><span style=\"color:#6A737D\">   // Array of byte offsets to pointer fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} TypeDescriptor;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Example: A \"Person\" object with 2 pointers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">TypeDescriptor person_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .type_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .field_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .pointer_offsets </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t[]</span><span style=\"color:#E1E4E8\">){</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">}</span><span style=\"color:#6A737D\">  // Pointers at bytes 0 and 8</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Why This Matters</strong>: During mark phase, we need to know which bytes are pointers:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Object layout for type 3 (Person):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// [0-7]:   char* name     (POINTER - must follow)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// [8-15]:  Person* friend (POINTER - must follow)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// [16-19]: int age        (NOT A POINTER - skip)</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"the-allocation-algorithm-first-fit-strategy\">The Allocation Algorithm: First-Fit Strategy</h2>\n<h3 id=\"high-level-flow\">High-Level Flow</h3>\n<p>{{DIAGRAM:allocation-flow}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>gc_alloc(size) called\n        â”‚\n        â–¼\n    Align size to 16-byte boundary\n    Add sizeof(ObjectHeader)\n        â”‚\n        â–¼\n    Traverse free list\n        â”‚\n        â”œâ”€â–º Block too small? â”€â”€â–º Continue to next\n        â”‚\n        â”œâ”€â–º Block exact fit? â”€â”€â–º Remove from list, return\n        â”‚\n        â””â”€â–º Block too large? â”€â”€â–º Split block:\n                                  â”Œâ”€ Allocated part (return)\n                                  â””â”€ Remainder (keep in list)</code></pre></div>\n\n<h3 id=\"the-implementation\">The Implementation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 1: Calculate total size needed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> aligned_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ALIGN_16</span><span style=\"color:#E1E4E8\">(size);</span><span style=\"color:#6A737D\">  // Round up to 16-byte boundary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> aligned_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 2: Ensure minimum allocation size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (total_size </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock);</span><span style=\"color:#6A737D\">  // Must fit free list node later</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 3: Search free list (first-fit)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> prev_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">gc->free_list;</span><span style=\"color:#6A737D\">  // Pointer to previous 'next' field</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (current </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (current->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> total_size) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Found a suitable block!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Step 4: Should we split the block?</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            size_t</span><span style=\"color:#E1E4E8\"> remainder </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current->size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> total_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (remainder </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Split: Create new free block from remainder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> new_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)current </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> total_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_free->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> remainder;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_free->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Update current block size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                current->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> total_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Link new free block into list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                *</span><span style=\"color:#E1E4E8\">prev_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_free;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // No split: Use entire block (avoid tiny fragments)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                *</span><span style=\"color:#E1E4E8\">prev_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Step 5: Initialize object header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            header->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current->size;</span><span style=\"color:#6A737D\">  // Actual allocated size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            header->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">            // Start unmarked (WHITE)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            header->type </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">              // Caller will set this</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Step 6: Return pointer to data (skip header)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)(header </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Move to next block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        prev_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">current->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 7: Out of memory - trigger GC</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Retry allocation (recursive call)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, size);</span><span style=\"color:#6A737D\">  // WARNING: Can infinite loop if heap too small!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>ğŸ” Quick Breakdown: The Pointer Trick</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> prev_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">free_list;</span></span></code></pre></div>\n\n<p>This is a <strong>pointer to a pointer</strong>. It allows us to modify the previous node&#39;s <code>next</code> field without special-casing the head of the list:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>// Without prev_ptr (ugly):\nif (current == gc-&gt;free_list) {\n    gc-&gt;free_list = current-&gt;next;  // Special case for head\n} else {\n    prev-&gt;next = current-&gt;next;     // General case\n}\n\n// With prev_ptr (elegant):\n*prev_ptr = current-&gt;next;  // Works for both head and middle!</code></pre></div>\n\n<h3 id=\"block-splitting-visualization\">Block Splitting Visualization</h3>\n<p>{{DIAGRAM:block-split}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>BEFORE ALLOCATION (Request: 64 bytes)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ FREE BLOCK                             â”‚\nâ”‚ size: 256                              â”‚\nâ”‚ next: NULL                             â”‚\nâ”‚ [240 bytes unused]                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nAFTER ALLOCATION (Split into 80 + 176)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ ALLOCATED OBJECT     â”‚ â”‚ NEW FREE BLOCK        â”‚\nâ”‚ size: 80             â”‚ â”‚ size: 176             â”‚\nâ”‚ marked: 0            â”‚ â”‚ next: NULL            â”‚\nâ”‚ type: 0              â”‚ â”‚ [160 bytes unused]    â”‚\nâ”‚ [64 bytes user data] â”‚ â”‚                       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         80 bytes              176 bytes</code></pre></div>\n\n<p><strong>Why Split?</strong> Without splitting, we&#39;d waste 176 bytes of the 256-byte block. Splitting allows future allocations to use the remainder.</p>\n<p><strong>Why Not Always Split?</strong> If remainder &lt; 16 bytes, it&#39;s too small to be useful. We&#39;d create &quot;dust&quot; that fragments the heap.</p>\n<hr>\n<h2 id=\"the-deallocation-algorithm-returning-to-free-list\">The Deallocation Algorithm: Returning to Free List</h2>\n<h3 id=\"the-implementation\">The Implementation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_free</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 1: Get object header (ptr points to data, not header)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ((ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 2: Convert to free block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)header;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> header->size;</span><span style=\"color:#6A737D\">  // Preserve size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 3: Insert at head of free list (O(1) operation)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: We do NOT coalesce adjacent blocks here (done during sweep)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Why Insert at Head?</strong> It&#39;s O(1). Inserting in sorted order would be O(n) but enable better coalescing. Trade-off: simplicity vs. fragmentation.</p>\n<hr>\n<h2 id=\"the-debugging-lab-common-pitfalls\">The Debugging Lab: Common Pitfalls</h2>\n<h3 id=\"-bug-1-off-by-one-in-pointer-arithmetic\">ğŸ› <strong>Bug 1: Off-by-One in Pointer Arithmetic</strong></h3>\n<p><strong>Symptom</strong>: Segmentation fault when accessing allocated memory.</p>\n<p><strong>Root Cause</strong>: Forgetting that <code>gc_alloc()</code> returns a pointer to <strong>data</strong>, not the header.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Treats data pointer as header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span><span style=\"color:#6A737D\">  // âŒ Points to user data!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">header</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Corrupts user data</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CORRECT: Subtract header size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ((ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // âœ… Points to actual header</span></span></code></pre></div>\n\n<p><strong>Visual Explanation</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Memory Layout:\n[HEADER][DATA DATA DATA]\n   â†‘       â†‘\n   |       â””â”€ gc_alloc() returns this\n   â””â”€ Header is HERE (ptr - sizeof(ObjectHeader))</code></pre></div>\n\n<h3 id=\"-bug-2-alignment-violations\">ğŸ› <strong>Bug 2: Alignment Violations</strong></h3>\n<p><strong>Symptom</strong>: Bus error on ARM, performance degradation on x86.</p>\n<p><strong>Root Cause</strong>: Allocating unaligned sizes.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: 13 bytes is not 16-byte aligned</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">13</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // âŒ May return unaligned pointer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CORRECT: Always align</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ALIGN_16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">size</span><span style=\"color:#E1E4E8\">) (((size) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 15</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#79B8FF\">15</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#B392F0\">ALIGN_16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">13</span><span style=\"color:#E1E4E8\">));</span><span style=\"color:#6A737D\">  // âœ… Allocates 16 bytes</span></span></code></pre></div>\n\n<p><strong>The Bit Trick Explained</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>size = 13 (binary: 0000 1101)\nsize + 15 = 28   (binary: 0001 1100)\n~15 = ...1111 0000 (mask)\n28 &amp; ~15 = 16    (binary: 0001 0000)  â† Rounded up!</code></pre></div>\n\n<h3 id=\"-bug-3-forgetting-minimum-block-size\">ğŸ› <strong>Bug 3: Forgetting Minimum Block Size</strong></h3>\n<p><strong>Symptom</strong>: Crash during <code>gc_free()</code> when trying to create free list node.</p>\n<p><strong>Root Cause</strong>: Allocated block is smaller than <code>sizeof(FreeBlock)</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: 8-byte allocation can't hold FreeBlock (16 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gc_free</span><span style=\"color:#E1E4E8\">(gc, ptr);</span><span style=\"color:#6A737D\">  // âŒ Overwrites adjacent memory!</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CORRECT: Enforce minimum in gc_alloc()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (total_size </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"-bug-4-fragmentation-death-spiral\">ğŸ› <strong>Bug 4: Fragmentation Death Spiral</strong></h3>\n<p><strong>Symptom</strong>: Allocation fails despite sufficient total free memory.</p>\n<p><strong>Scenario</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Free List: [16 bytes] â†’ [16 bytes] â†’ [16 bytes] â†’ [16 bytes]\nRequest: 64 bytes\nResult: FAIL (no contiguous block, even though 64 bytes are free)</code></pre></div>\n\n<p><strong>Fix Options</strong>:</p>\n<ol>\n<li><strong>Coalescing</strong>: Merge adjacent free blocks during sweep</li>\n<li><strong>Compaction</strong>: Move live objects together (covered in Milestone 5)</li>\n<li><strong>Best-Fit</strong>: Search for smallest sufficient block (reduces fragmentation)</li>\n</ol>\n<hr>\n<h2 id=\"visual-reference-memory-state-transitions\">Visual Reference: Memory State Transitions</h2>\n<p>{{DIAGRAM:state-transitions}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>INITIAL STATE (Empty Heap)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ FREE BLOCK                             â”‚\nâ”‚ size: 1024                             â”‚\nâ”‚ next: NULL                             â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nfree_list â†’ [1024]\n\nAFTER gc_alloc(gc, 64)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ OBJECT       â”‚ â”‚ FREE BLOCK           â”‚\nâ”‚ size: 80     â”‚ â”‚ size: 944            â”‚\nâ”‚ marked: 0    â”‚ â”‚ next: NULL           â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nfree_list â†’ [944]\n\nAFTER gc_alloc(gc, 128)\nâ”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ OBJ1 â”‚ â”‚ OBJ2   â”‚ â”‚ FREE BLOCK       â”‚\nâ”‚ 80   â”‚ â”‚ 144    â”‚ â”‚ size: 800        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nfree_list â†’ [800]\n\nAFTER gc_free(OBJ1)\nâ”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ FREE â”‚ â”‚ OBJ2   â”‚ â”‚ FREE BLOCK       â”‚\nâ”‚ 80 â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¤ size: 800        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nfree_list â†’ [80] â†’ [800]</code></pre></div>\n\n<hr>\n<h2 id=\"code-scaffold-your-implementation-tasks\">Code Scaffold: Your Implementation Tasks</h2>\n<h3 id=\"task-1-initialize-the-heap\">Task 1: Initialize the Heap</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> heap_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Allocate GC structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(GC));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Allocate heap memory (use mmap or malloc)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->heap_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->heap_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> heap_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize free list with entire heap as one block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> initial_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    initial_block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> heap_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    initial_block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> initial_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize root set (covered in next milestone)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->roots.roots </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->roots.count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->roots.capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> gc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-2-implement-allocation\">Task 2: Implement Allocation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement first-fit allocation (see algorithm above)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remember to:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Align size to 16 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Add header size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Enforce minimum block size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Split blocks when remainder is large enough</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Initialize object header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 6. Return pointer to DATA (not header)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Replace with your implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-3-implement-deallocation\">Task 3: Implement Deallocation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_free</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Convert object to free block and add to free list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remember to:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Handle NULL pointer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Get header from data pointer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Convert to FreeBlock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Insert into free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-4-helper-functions\">Task 4: Helper Functions</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Get object header from data pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#E1E4E8\"> ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ((ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get data pointer from header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#B392F0\"> get_data</span><span style=\"color:#E1E4E8\">(ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> header</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)(header </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check if pointer is within heap bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_heap_pointer</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> gc->heap_start </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"testing-your-implementation\">Testing Your Implementation</h2>\n<h3 id=\"test-1-basic-allocation\">Test 1: Basic Allocation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_basic_allocation</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(obj1 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(obj2 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify objects don't overlap</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)obj2 </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)obj1 </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#F97583\"> +</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Basic allocation test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-2-block-splitting\">Test 2: Block Splitting</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_block_splitting</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify free list still has space</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->free_list </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->free_list->size </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Block splitting test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-3-alignment\">Test 3: Alignment</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_alignment</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">13</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Odd size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify 16-byte alignment</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(((</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 15</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Alignment test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-4-exhaustion\">Test 4: Exhaustion</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_heap_exhaustion</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Small heap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This should trigger GC (which will fail since nothing is freeable)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // In a real implementation, this should return NULL or abort</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For now, just verify we don't crash</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Heap exhaustion test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-considerations\">Performance Considerations</h2>\n<h3 id=\"time-complexity\">Time Complexity</h3>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Complexity</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>gc_alloc()</code></td>\n<td>O(n) worst case</td>\n<td>Must traverse free list</td>\n</tr>\n<tr>\n<td><code>gc_free()</code></td>\n<td>O(1)</td>\n<td>Insert at head</td>\n</tr>\n<tr>\n<td>Heap iteration</td>\n<td>O(heap_size)</td>\n<td>Must scan entire heap</td>\n</tr>\n</tbody></table>\n<h3 id=\"space-overhead\">Space Overhead</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Per-object overhead: 16 bytes (header)\nFor 64-byte object: 16/80 = 20% overhead\nFor 1KB object: 16/1040 = 1.5% overhead</code></pre></div>\n\n<p><strong>Optimization</strong>: For small objects, use a separate <strong>small object allocator</strong> (e.g., slab allocator) to reduce overhead.</p>\n<h3 id=\"cache-performance\">Cache Performance</h3>\n<p><strong>Good</strong>: 16-byte alignment ensures cache-line alignment<br><strong>Bad</strong>: Free list traversal has poor spatial locality (random jumps)<br><strong>Fix</strong>: Use segregated free lists (separate lists for different size classes)</p>\n<hr>\n<h2 id=\"what-you39ve-learned\">What You&#39;ve Learned</h2>\n<p>âœ… <strong>Memory Layout</strong>: How objects and free blocks coexist in the heap<br>âœ… <strong>Allocation Strategy</strong>: First-fit algorithm with block splitting<br>âœ… <strong>Metadata Design</strong>: Object headers and type descriptors<br>âœ… <strong>Pointer Arithmetic</strong>: Converting between headers and data pointers<br>âœ… <strong>Alignment</strong>: Why and how to align memory allocations  </p>\n<hr>\n<h2 id=\"next-steps\">Next Steps</h2>\n<p>Now that you understand heap organization, you&#39;re ready to tackle:</p>\n<ul>\n<li><strong><a href=\"#root-scanner\">Root Scanner â†’</a></strong>: How to find GC roots on the stack and in globals</li>\n<li><strong><a href=\"#mark-engine\">Mark Phase â†’</a></strong>: Traversing the object graph to find live objects</li>\n<li><strong><a href=\"#sweep-engine\">Sweep Phase â†’</a></strong>: Reclaiming unmarked objects and rebuilding the free list</li>\n</ul>\n<p><strong>Pro Tip</strong>: Before moving on, make sure your <code>gc_alloc()</code> passes all tests. The rest of the GC depends on a correct heap implementation.</p>\n<hr>\n<p><a href=\"#satellite-map\">â†‘ Back to System Map</a></p>\n<div id=\"ms-allocation\"></div>\n\n<h1 id=\"memory-allocation-system-the-heap39s-puzzle-master\">Memory Allocation System: The Heap&#39;s Puzzle Master</h1>\n<h2 id=\"the-epiphany-analogy-the-parking-lot-attendant\">The Epiphany Analogy: The Parking Lot Attendant</h2>\n<p>Imagine you&#39;re managing a parking lot with 1,000 spaces. Cars of different sizes arrive constantly:</p>\n<ul>\n<li><strong>Motorcycles</strong> (small objects): Need 1 space</li>\n<li><strong>Sedans</strong> (medium objects): Need 2 spaces  </li>\n<li><strong>Buses</strong> (large objects): Need 10 spaces</li>\n</ul>\n<p>Your job as the attendant is to:</p>\n<ol>\n<li><strong>Find a spot</strong> that fits each vehicle (allocation)</li>\n<li><strong>Split large empty sections</strong> when a small car parks (block splitting)</li>\n<li><strong>Track which spaces are free</strong> (free list management)</li>\n<li><strong>Decide which spot to use</strong> when multiple options exist (allocation strategy)</li>\n</ol>\n<p>The challenge? Over time, you get <strong>fragmentation</strong>: empty spaces scattered everywhere, but no contiguous section large enough for a busâ€”even though total empty spaces exceed 10!</p>\n<p>This is <strong>exactly</strong> what a memory allocator does. Let&#39;s build one.</p>\n<hr>\n<h2 id=\"technical-rationale-why-allocation-strategies-matter\">Technical Rationale: Why Allocation Strategies Matter</h2>\n<h3 id=\"the-core-problem\">The Core Problem</h3>\n<p>When your program calls <code>gc_alloc(gc, 64)</code>, the allocator must answer three questions:</p>\n<ol>\n<li><strong>Where?</strong> Which free block should we use?</li>\n<li><strong>How much?</strong> Should we use the entire block or split it?</li>\n<li><strong>What next?</strong> How do we update the free list?</li>\n</ol>\n<p><strong>Bad decisions</strong> lead to:</p>\n<ul>\n<li><strong>External fragmentation</strong>: Free memory scattered in unusable chunks</li>\n<li><strong>Internal fragmentation</strong>: Wasted space within allocated blocks</li>\n<li><strong>Allocation failures</strong>: <code>malloc()</code> returns NULL despite available memory</li>\n</ul>\n<p><strong>Good strategies</strong> balance:</p>\n<ul>\n<li><strong>Speed</strong>: O(1) vs O(n) search time</li>\n<li><strong>Memory efficiency</strong>: Minimizing wasted space</li>\n<li><strong>Simplicity</strong>: Easier to debug and maintain</li>\n</ul>\n<hr>\n<h2 id=\"internal-mechanics-the-three-allocation-strategies\">Internal Mechanics: The Three Allocation Strategies</h2>\n<h3 id=\"strategy-1-first-fit-speed-champion\">Strategy 1: First-Fit (Speed Champion)</h3>\n<p><strong>Algorithm</strong>: Use the <strong>first</strong> free block that&#39;s large enough.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> gc_alloc_first_fit</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 1: Calculate total size needed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> aligned_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ALIGN_16</span><span style=\"color:#E1E4E8\">(size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> aligned_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Enforce minimum block size (must fit FreeBlock later)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (total_size </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 2: Search free list for first suitable block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">gc->free_list;</span><span style=\"color:#6A737D\">  // Pointer to pointer for easy removal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">current </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (block->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> total_size) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Found a fit!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Step 3: Decide whether to split</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            size_t</span><span style=\"color:#E1E4E8\"> remainder </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> total_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (remainder </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Split: Create new free block from remainder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> new_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)block </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> total_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> remainder;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Update free list to skip allocated portion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                *</span><span style=\"color:#E1E4E8\">current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Don't split: Use entire block (wastes remainder)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size;</span><span style=\"color:#6A737D\">  // Absorb the \"dust\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                *</span><span style=\"color:#E1E4E8\">current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span><span style=\"color:#6A737D\">    // Remove from free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Step 4: Initialize object header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            header->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> total_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            header->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            header->type </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Will be set by caller</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Step 5: Return pointer to DATA (not header)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)(header </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">current)->next;</span><span style=\"color:#6A737D\">  // Advance to next block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // No suitable block found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Pros</strong>:</p>\n<ul>\n<li>âš¡ <strong>Fast</strong>: O(1) best case, O(n) worst case</li>\n<li>ğŸ¯ <strong>Simple</strong>: Easy to implement and debug</li>\n</ul>\n<p><strong>Cons</strong>:</p>\n<ul>\n<li>ğŸ’” <strong>Fragmentation</strong>: Leaves small unusable blocks at the start of the heap</li>\n<li>ğŸ“Š <strong>Unpredictable</strong>: Performance varies based on allocation history</li>\n</ul>\n<p><strong>When to Use</strong>: General-purpose allocators, real-time systems (predictable worst-case)</p>\n<hr>\n<h3 id=\"strategy-2-best-fit-space-champion\">Strategy 2: Best-Fit (Space Champion)</h3>\n<p><strong>Algorithm</strong>: Use the <strong>smallest</strong> free block that&#39;s large enough.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> gc_alloc_best_fit</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> aligned_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ALIGN_16</span><span style=\"color:#E1E4E8\">(size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> aligned_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (total_size </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 1: Search entire free list for best fit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> best </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> best_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SIZE_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">current </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (block->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> total_size </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> block->size </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> best_size) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            best </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            best_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Perfect fit? Stop searching</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (block->size </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> total_size) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">current)->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (best </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // No suitable block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 2: Allocate from best block (same splitting logic as first-fit)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">best;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> remainder </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> total_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (remainder </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> new_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)block </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> total_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> remainder;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">best </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">best </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> total_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header->type </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)(header </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Pros</strong>:</p>\n<ul>\n<li>ğŸ’¾ <strong>Space-efficient</strong>: Minimizes wasted space per allocation</li>\n<li>ğŸ§© <strong>Less fragmentation</strong>: Leaves larger contiguous blocks</li>\n</ul>\n<p><strong>Cons</strong>:</p>\n<ul>\n<li>ğŸŒ <strong>Slower</strong>: Always O(n) (must scan entire list)</li>\n<li>ğŸª² <strong>Paradox</strong>: Can create more small &quot;dust&quot; blocks over time</li>\n</ul>\n<p><strong>When to Use</strong>: Memory-constrained systems, long-running servers</p>\n<hr>\n<h3 id=\"strategy-3-worst-fit-the-contrarian\">Strategy 3: Worst-Fit (The Contrarian)</h3>\n<p><strong>Algorithm</strong>: Use the <strong>largest</strong> free block.</p>\n<p><strong>Rationale</strong>: Splitting large blocks leaves large remainders, reducing fragmentation.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> gc_alloc_worst_fit</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Similar to best-fit, but search for LARGEST block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> worst </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> worst_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">current </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (block->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> total_size </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> block->size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> worst_size) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            worst </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            worst_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">current)->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... (same allocation logic)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Pros</strong>:</p>\n<ul>\n<li>ğŸ¯ <strong>Large remainders</strong>: Splits leave usable blocks</li>\n<li>ğŸ“ˆ <strong>Predictable</strong>: Consistent behavior</li>\n</ul>\n<p><strong>Cons</strong>:</p>\n<ul>\n<li>ğŸŒ <strong>Slow</strong>: Always O(n)</li>\n<li>ğŸ’” <strong>Wastes large blocks</strong>: Quickly exhausts big contiguous regions</li>\n</ul>\n<p><strong>When to Use</strong>: Rarely in practice (academic interest)</p>\n<hr>\n<h2 id=\"visual-reference-strategy-comparison\">Visual Reference: Strategy Comparison</h2>\n<p>{{DIAGRAM:allocation-strategies}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>SCENARIO: Allocate 64 bytes from this free list\n\nFree List State:\n[100 bytes] â†’ [200 bytes] â†’ [80 bytes] â†’ [500 bytes]\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nFIRST-FIT: Uses first sufficient block\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [100 bytes] â† SELECTED (first that fits)            â”‚\nâ”‚ Result: [64 allocated] [36 remainder]               â”‚\nâ”‚ New Free List: [36] â†’ [200] â†’ [80] â†’ [500]         â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nTime: O(1) in this case\nWaste: 0 bytes (remainder is usable)\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nBEST-FIT: Uses smallest sufficient block\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [80 bytes] â† SELECTED (smallest that fits)          â”‚\nâ”‚ Result: [64 allocated] [16 remainder]               â”‚\nâ”‚ New Free List: [100] â†’ [200] â†’ [16] â†’ [500]        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nTime: O(n) - must scan entire list\nWaste: 0 bytes, but created small 16-byte block\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nWORST-FIT: Uses largest block\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [500 bytes] â† SELECTED (largest available)          â”‚\nâ”‚ Result: [64 allocated] [436 remainder]              â”‚\nâ”‚ New Free List: [100] â†’ [200] â†’ [80] â†’ [436]        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nTime: O(n) - must scan entire list\nWaste: 0 bytes, large remainder preserved</code></pre></div>\n\n<hr>\n<h2 id=\"the-block-splitting-decision-tree\">The Block Splitting Decision Tree</h2>\n<p><strong>Critical Question</strong>: When should we split a free block?</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// The splitting threshold</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MIN_SPLIT_SIZE</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock)</span><span style=\"color:#6A737D\">  // Typically 16 bytes</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (block->size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> total_size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> MIN_SPLIT_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SPLIT: Remainder is large enough to be useful</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    split_block</span><span style=\"color:#E1E4E8\">(block, total_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // DON'T SPLIT: Remainder is \"dust\" - absorb it</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Example</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Request: 64 bytes (80 with header)\nBlock: 96 bytes\n\nRemainder: 96 - 80 = 16 bytes\nDecision: SPLIT (16 &gt;= 16)\n\nResult:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ ALLOCATED    â”‚ â”‚ FREE         â”‚\nâ”‚ 80 bytes     â”‚ â”‚ 16 bytes     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></div>\n\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Request: 64 bytes (80 with header)\nBlock: 88 bytes\n\nRemainder: 88 - 80 = 8 bytes\nDecision: DON'T SPLIT (8 &lt; 16)\n\nResult:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ ALLOCATED            â”‚\nâ”‚ 88 bytes (8 wasted)  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></div>\n\n<p><strong>Why 16 bytes?</strong> That&#39;s the size of <code>FreeBlock</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> FreeBlock {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">           // 8 bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span><span style=\"color:#6A737D\"> // 8 bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} FreeBlock;</span><span style=\"color:#6A737D\">  // Total: 16 bytes</span></span></code></pre></div>\n\n<p>If remainder &lt; 16 bytes, we can&#39;t create a valid free block node!</p>\n<hr>\n<h2 id=\"the-deallocation-algorithm-returning-memory\">The Deallocation Algorithm: Returning Memory</h2>\n<h3 id=\"the-simple-approach-no-coalescing\">The Simple Approach (No Coalescing)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_free</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 1: Get object header (ptr points to data, not header)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ((ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 2: Verify pointer is within heap bounds (safety check)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_heap_pointer</span><span style=\"color:#E1E4E8\">(gc, header)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Attempt to free invalid pointer </span><span style=\"color:#79B8FF\">%p\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ptr);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        abort</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 3: Convert to free block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)header;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> header->size;</span><span style=\"color:#6A737D\">  // Preserve size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 4: Insert at head of free list (O(1) operation)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: We do NOT coalesce adjacent blocks here</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // That's done during the sweep phase (Milestone 4)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Why Insert at Head?</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Before: free_list â†’ [200] â†’ [100] â†’ NULL\nFree 80-byte block\n\nAfter:  free_list â†’ [80] â†’ [200] â†’ [100] â†’ NULL\n                     â†‘\n                     New head (O(1) insertion)</code></pre></div>\n\n<p><strong>Alternative</strong>: Insert in <strong>address order</strong> (enables immediate coalescing):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_free_sorted</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ((ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)header;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find insertion point (keep list sorted by address)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">current </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> block) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">current)->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Insert block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Coalesce with next block if adjacent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)block </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> block->size </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)block->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block->size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->next->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Coalesce with previous block (requires tracking prev pointer)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... (left as exercise)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Trade-off</strong>: O(n) insertion vs. reduced fragmentation</p>\n<hr>\n<h2 id=\"the-debugging-lab-common-pitfalls\">The Debugging Lab: Common Pitfalls</h2>\n<h3 id=\"-bug-1-the-headerdata-pointer-confusion\">ğŸ› <strong>Bug 1: The Header/Data Pointer Confusion</strong></h3>\n<p><strong>Symptom</strong>: Segmentation fault, corrupted memory</p>\n<p><strong>Root Cause</strong>: Treating data pointer as header pointer</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Treats data pointer as header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span><span style=\"color:#6A737D\">  // âŒ Points to user data!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">header</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Corrupts first 4 bytes of user data</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CORRECT: Subtract header size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ((ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // âœ… Points to actual header</span></span></code></pre></div>\n\n<p><strong>Memory Layout Visualization</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>What gc_alloc() returns:\n                    â”Œâ”€ ptr (returned to user)\n                    â†“\n[HEADER: 16 bytes][DATA: 64 bytes]\n â†‘\n â””â”€ Actual header location (ptr - sizeof(ObjectHeader))\n\nPointer arithmetic:\nObjectHeader* header = ((ObjectHeader*)ptr) - 1;\n                        â””â”€ Subtracts 16 bytes (sizeof(ObjectHeader))</code></pre></div>\n\n<p><strong>The Fix</strong>: Always use helper functions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#E1E4E8\"> ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ((ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#B392F0\"> get_data</span><span style=\"color:#E1E4E8\">(ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> header</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)(header </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"-bug-2-alignment-violations\">ğŸ› <strong>Bug 2: Alignment Violations</strong></h3>\n<p><strong>Symptom</strong>: Bus error on ARM/RISC-V, performance degradation on x86</p>\n<p><strong>Root Cause</strong>: Allocating unaligned sizes</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: 13 bytes is not 16-byte aligned</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">13</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // âŒ May return unaligned pointer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CORRECT: Always align</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ALIGN_16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">size</span><span style=\"color:#E1E4E8\">) (((size) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 15</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#79B8FF\">15</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#B392F0\">ALIGN_16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">13</span><span style=\"color:#E1E4E8\">));</span><span style=\"color:#6A737D\">  // âœ… Allocates 16 bytes</span></span></code></pre></div>\n\n<p><strong>The Bit Trick Explained</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Goal: Round 13 up to next multiple of 16\n\nStep 1: Add (alignment - 1)\n13 + 15 = 28\nBinary: 0001 1100\n\nStep 2: Create mask (~15)\n15 = 0000 1111\n~15 = 1111 0000\n\nStep 3: AND to clear low bits\n  0001 1100  (28)\n&amp; 1111 0000  (~15)\n-----------\n  0001 0000  (16) â† Rounded up!\n\nWhy it works:\n- Adding 15 ensures we round UP (not down)\n- AND with ~15 clears the low 4 bits (forces multiple of 16)</code></pre></div>\n\n<p><strong>Test Cases</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">ALIGN_16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#6A737D\">   // 0000 0000 â†’ 0000 0000</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ALIGN_16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#6A737D\">  // 0001 0000 â†’ 0001 0000</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ALIGN_16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">13</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#6A737D\">  // 0001 1100 â†’ 0001 0000</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ALIGN_16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#6A737D\">  // 0010 0000 â†’ 0010 0000</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ALIGN_16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">17</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#6A737D\">  // 0010 0001 â†’ 0010 0000</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"-bug-3-forgetting-minimum-block-size\">ğŸ› <strong>Bug 3: Forgetting Minimum Block Size</strong></h3>\n<p><strong>Symptom</strong>: Crash during <code>gc_free()</code> when trying to write <code>FreeBlock</code> header</p>\n<p><strong>Root Cause</strong>: Allocated block is smaller than <code>sizeof(FreeBlock)</code></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: 8-byte allocation can't hold FreeBlock (16 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gc_free</span><span style=\"color:#E1E4E8\">(gc, ptr);</span><span style=\"color:#6A737D\">  // âŒ Overwrites adjacent memory!</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// What happens:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 1. gc_alloc() allocates 8 + 16 (header) = 24 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 2. gc_free() tries to write FreeBlock (16 bytes) at header location</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 3. FreeBlock.next (8 bytes) overwrites user data of NEXT object!</span></span></code></pre></div>\n\n<p><strong>The Fix</strong>: Enforce minimum in <code>gc_alloc()</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> aligned_size;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Ensure block can hold FreeBlock when freed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (total_size </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Visual Explanation</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>WRONG (8-byte allocation):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ ObjectHeader   â”‚ Data   â”‚\nâ”‚ 16 bytes       â”‚ 8 bytesâ”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         24 bytes total\n\nWhen freed, tries to write FreeBlock:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ FreeBlock              â”‚\nâ”‚ size: 8 | next: 8      â”‚ â† next pointer overflows!\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nCORRECT (16-byte minimum):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ ObjectHeader   â”‚ Data           â”‚\nâ”‚ 16 bytes       â”‚ 16 bytes       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         32 bytes total\n\nWhen freed:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ FreeBlock                      â”‚\nâ”‚ size: 32 | next: ptr           â”‚ â† Fits perfectly!\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></div>\n\n<hr>\n<h3 id=\"-bug-4-the-fragmentation-death-spiral\">ğŸ› <strong>Bug 4: The Fragmentation Death Spiral</strong></h3>\n<p><strong>Symptom</strong>: Allocation fails despite sufficient total free memory</p>\n<p><strong>Scenario</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Free List: [16] â†’ [16] â†’ [16] â†’ [16] â†’ [16] â†’ [16]\nTotal Free: 96 bytes\n\nRequest: gc_alloc(gc, 64)\nResult: NULL (no contiguous 64-byte block!)</code></pre></div>\n\n<p><strong>Root Cause</strong>: External fragmentation</p>\n<p><strong>Fix Option 1: Coalescing</strong> (Merge adjacent blocks)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> coalesce_free_list</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sort free list by address</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sort_free_list_by_address</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (current </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> current->next </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if current and next are adjacent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> current_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)current </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> current->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (current_end </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)current->next) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Merge!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current->size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> current->next->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current->next->next;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Don't advance - check if we can merge with new next</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Before Coalescing</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[16] â†’ [16] â†’ [16] â†’ [16]\n â†‘      â†‘      â†‘      â†‘\n A      B      C      D</code></pre></div>\n\n<p><strong>After Coalescing</strong> (if A, B, C, D are adjacent in memory):</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[64]\n â†‘\n A (merged A+B+C+D)</code></pre></div>\n\n<p><strong>Fix Option 2: Segregated Free Lists</strong> (Prevent fragmentation)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> small;</span><span style=\"color:#6A737D\">   // 16-64 bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> medium;</span><span style=\"color:#6A737D\">  // 65-256 bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> large;</span><span style=\"color:#6A737D\">   // 257+ bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SegregatedFreeList;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> gc_alloc_segregated</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (size </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> alloc_from_list</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">gc->free_lists.small, size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (size </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 256</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> alloc_from_list</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">gc->free_lists.medium, size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> alloc_from_list</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">gc->free_lists.large, size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix Option 3: Compaction</strong> (Move objects to eliminate gaps)</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Before:\n[OBJ1][FREE][OBJ2][FREE][OBJ3][FREE]\n\nAfter Compaction:\n[OBJ1][OBJ2][OBJ3][FREE FREE FREE]\n                   â””â”€ One large contiguous block</code></pre></div>\n\n<p>(Compaction covered in Milestone 5: Moving GC)</p>\n<hr>\n<h2 id=\"visual-reference-memory-state-transitions\">Visual Reference: Memory State Transitions</h2>\n<p>{{DIAGRAM:state-transitions}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nINITIAL STATE (Empty Heap)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ FREE BLOCK                                         â”‚\nâ”‚ size: 1024                                         â”‚\nâ”‚ next: NULL                                         â”‚\nâ”‚ [1008 bytes unused]                                â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nfree_list â†’ [1024]\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nAFTER gc_alloc(gc, 64)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ OBJECT           â”‚ â”‚ FREE BLOCK                   â”‚\nâ”‚ size: 80         â”‚ â”‚ size: 944                    â”‚\nâ”‚ marked: 0        â”‚ â”‚ next: NULL                   â”‚\nâ”‚ type: 0          â”‚ â”‚ [928 bytes unused]           â”‚\nâ”‚ [64 bytes data]  â”‚ â”‚                              â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n      80 bytes              944 bytes\n\nfree_list â†’ [944]\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nAFTER gc_alloc(gc, 128)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ OBJ1   â”‚ â”‚ OBJ2     â”‚ â”‚ FREE BLOCK                 â”‚\nâ”‚ 80     â”‚ â”‚ 144      â”‚ â”‚ size: 800                  â”‚\nâ”‚ m: 0   â”‚ â”‚ m: 0     â”‚ â”‚ next: NULL                 â”‚\nâ”‚ [64]   â”‚ â”‚ [128]    â”‚ â”‚ [784 bytes unused]         â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n   80 B       144 B            800 B\n\nfree_list â†’ [800]\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nAFTER gc_free(OBJ1)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ FREE   â”‚ â”‚ OBJ2     â”‚ â”‚ FREE BLOCK                 â”‚\nâ”‚ 80   â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¤ size: 800                  â”‚\nâ”‚ next â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ â”‚ next: NULL                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nfree_list â†’ [80] â†’ [800]\n             â†‘       â†‘\n             New    Old head\n             head\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nAFTER gc_alloc(gc, 32) - Uses first-fit\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ OBJ3   â”‚ â”‚ OBJ2     â”‚ â”‚ FREE BLOCK                 â”‚\nâ”‚ 48   â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¤ size: 800                  â”‚\nâ”‚ [32]   â”‚ â”‚ [128]    â”‚ â”‚ next: NULL                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n   48 B       144 B            800 B\n\nfree_list â†’ [32] â†’ [800]\n             â†‘\n             Remainder from splitting 80-byte block\n             (80 - 48 = 32 bytes left)</code></pre></div>\n\n<hr>\n<h2 id=\"code-scaffold-your-implementation-tasks\">Code Scaffold: Your Implementation Tasks</h2>\n<h3 id=\"task-1-initialize-the-heap\">Task 1: Initialize the Heap</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> heap_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Allocate GC structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(GC));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Allocate heap memory (use mmap or malloc)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: mmap() is better for large heaps (allows returning memory to OS)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->heap_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->heap_start </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->heap_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> heap_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize free list with entire heap as one block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> initial_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    initial_block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> heap_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    initial_block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> initial_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize root set (covered in next milestone)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->roots.roots </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->roots.count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->roots.capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->bytes_allocated </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->num_allocations </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->num_collections </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> gc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Testing</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_gc_init</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->heap_start </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->heap_size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->free_list </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->free_list->size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->free_list->next </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ gc_init test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"task-2-implement-first-fit-allocation\">Task 2: Implement First-Fit Allocation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 1 - Align size to 16 bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> aligned_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ALIGN_16</span><span style=\"color:#E1E4E8\">(size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 2 - Add header size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> aligned_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 3 - Enforce minimum block size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (total_size </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 4 - Search free list for first suitable block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">current </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (block->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> total_size) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Step 5 - Decide whether to split</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            size_t</span><span style=\"color:#E1E4E8\"> remainder </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> total_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (remainder </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Split block</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Hint: New block starts at (char*)block + total_size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Use entire block (absorb remainder)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Step 6 - Initialize object header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)block;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Set size, marked, type fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Step 7 - Update statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            gc->bytes_allocated </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> total_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            gc->num_allocations</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Step 8 - Return pointer to DATA (not header)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)(header </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">current)->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: No suitable block found - trigger GC</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For now, return NULL (GC implementation in Milestone 4)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Testing</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_gc_alloc</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test 1: Basic allocation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(obj1 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(((</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)obj1 </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 15</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Check alignment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test 2: Multiple allocations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(obj2 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(obj2 </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> obj1);</span><span style=\"color:#6A737D\">  // Should be after obj1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test 3: Verify header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(obj1);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(header->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#F97583\"> +</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(header->marked </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ gc_alloc test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"task-3-implement-deallocation\">Task 3: Implement Deallocation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_free</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Handle NULL pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Get header from data pointer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify pointer is within heap bounds (safety check)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_heap_pointer</span><span style=\"color:#E1E4E8\">(gc, header)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Invalid pointer </span><span style=\"color:#79B8FF\">%p\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ptr);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        abort</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Convert to free block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)header;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Insert at head of free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->bytes_allocated </span><span style=\"color:#F97583\">-=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Testing</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_gc_free</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free first object</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, obj1);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify free list has new block</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->free_list </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate again - should reuse freed block</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(obj3 </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> obj1);</span><span style=\"color:#6A737D\">  // Should reuse same address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ gc_free test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"task-4-helper-functions\">Task 4: Helper Functions</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Get object header from data pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#E1E4E8\"> ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ((ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get data pointer from header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#B392F0\"> get_data</span><span style=\"color:#E1E4E8\">(ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> header</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)(header </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check if pointer is within heap bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_heap_pointer</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> gc->heap_start </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Align size to 16 bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ALIGN_16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">size</span><span style=\"color:#E1E4E8\">) (((size) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 15</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#79B8FF\">15</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Print free list (for debugging)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> print_free_list</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Free List: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (block </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes at </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\">] â†’ \"</span><span style=\"color:#E1E4E8\">, block->size, (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"NULL</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"testing-your-implementation\">Testing Your Implementation</h2>\n<h3 id=\"test-suite\">Test Suite</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> run_allocation_tests</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Running allocation tests...</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_gc_init</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_gc_alloc</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_gc_free</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_block_splitting</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_alignment</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_minimum_size</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_heap_exhaustion</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_fragmentation</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">âœ“ All tests passed!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-1-basic-allocation\">Test 1: Basic Allocation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_basic_allocation</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(obj1 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(obj2 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify objects don't overlap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> h1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(obj1);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> h2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(obj2);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj1_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)h1 </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> h1->size;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(obj1_end </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)h2);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Basic allocation test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-2-block-splitting\">Test 2: Block Splitting</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_block_splitting</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate small object from large heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify free list still has space</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->free_list </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->free_list->size </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate expected remainder</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> allocated </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ALIGN_16</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (allocated </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        allocated </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> expected_remainder </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\"> allocated;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->free_list->size </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> expected_remainder);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Block splitting test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-3-alignment\">Test 3: Alignment</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_alignment</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test various odd sizes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> test_sizes</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">13</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">31</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">63</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">127</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#FFAB70\">test_sizes</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(obj </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Verify 16-byte alignment</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(((</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 15</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Alignment test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-4-minimum-size\">Test 4: Minimum Size</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_minimum_size</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate very small object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(obj </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free it</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify free list is valid (no corruption)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->free_list </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->free_list->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Minimum size test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-5-heap-exhaustion\">Test 5: Heap Exhaustion</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_heap_exhaustion</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Small heap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This should fail (not enough space)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(obj3 </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Heap exhaustion test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-6-fragmentation\">Test 6: Fragmentation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_fragmentation</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate 4 objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj4 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free alternating objects (creates fragmentation)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, obj1);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, obj3);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free list should have 2 blocks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (block </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(count </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // At least 2 free blocks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Fragmentation test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-considerations\">Performance Considerations</h2>\n<h3 id=\"time-complexity\">Time Complexity</h3>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>First-Fit</th>\n<th>Best-Fit</th>\n<th>Worst-Fit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>gc_alloc()</code></td>\n<td>O(n) worst, O(1) best</td>\n<td>O(n) always</td>\n<td>O(n) always</td>\n</tr>\n<tr>\n<td><code>gc_free()</code></td>\n<td>O(1)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Coalescing</td>\n<td>O(n log n)</td>\n<td>O(n log n)</td>\n<td>O(n log n)</td>\n</tr>\n</tbody></table>\n<h3 id=\"space-overhead\">Space Overhead</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Per-object overhead: 16 bytes (ObjectHeader)\n\nExamples:\n- 8-byte object:  16/32  = 50% overhead (forced to 32 bytes minimum)\n- 64-byte object: 16/80  = 20% overhead\n- 1KB object:     16/1040 = 1.5% overhead</code></pre></div>\n\n<p><strong>Optimization</strong>: Use <strong>segregated free lists</strong> for small objects:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Small objects (â‰¤64 bytes): Use slab allocator (8-byte overhead)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Large objects (>64 bytes): Use standard allocator (16-byte overhead)</span></span></code></pre></div>\n\n<h3 id=\"cache-performance\">Cache Performance</h3>\n<p><strong>Good</strong>:</p>\n<ul>\n<li>âœ… 16-byte alignment ensures cache-line alignment</li>\n<li>âœ… Sequential allocation has good spatial locality</li>\n</ul>\n<p><strong>Bad</strong>:</p>\n<ul>\n<li>âŒ Free list traversal has poor spatial locality (random jumps)</li>\n<li>âŒ Fragmentation reduces cache efficiency</li>\n</ul>\n<p><strong>Fix</strong>: Use <strong>segregated free lists</strong> (separate lists for different size classes):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> size_16;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> size_32;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> size_64;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> size_128;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> size_256;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> size_large;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SegregatedFreeList;</span></span></code></pre></div>\n\n<p>Benefits:</p>\n<ul>\n<li>Faster allocation (search smaller lists)</li>\n<li>Better cache locality (similar-sized objects clustered)</li>\n<li>Reduced fragmentation</li>\n</ul>\n<hr>\n<h2 id=\"what-you39ve-learned\">What You&#39;ve Learned</h2>\n<p>âœ… <strong>Memory Layout</strong>: How objects and free blocks coexist in the heap<br>âœ… <strong>Allocation Strategies</strong>: First-fit, best-fit, worst-fit trade-offs<br>âœ… <strong>Block Splitting</strong>: When and how to split free blocks<br>âœ… <strong>Metadata Design</strong>: Object headers and free block nodes<br>âœ… <strong>Pointer Arithmetic</strong>: Converting between headers and data pointers<br>âœ… <strong>Alignment</strong>: Why and how to align memory allocations<br>âœ… <strong>Fragmentation</strong>: External vs. internal, causes and solutions  </p>\n<hr>\n<h2 id=\"next-steps\">Next Steps</h2>\n<p>Now that you understand heap organization and allocation, you&#39;re ready to tackle:</p>\n<ul>\n<li><strong><a href=\"#root-scanner\">Root Scanner â†’</a></strong>: How to find GC roots on the stack and in globals</li>\n<li><strong><a href=\"#mark-engine\">Mark Phase â†’</a></strong>: Traversing the object graph to find live objects</li>\n<li><strong><a href=\"#sweep-engine\">Sweep Phase â†’</a></strong>: Reclaiming unmarked objects and rebuilding the free list</li>\n</ul>\n<p><strong>Pro Tip</strong>: Before moving on, make sure your <code>gc_alloc()</code> passes all tests. The rest of the GC depends on a correct heap implementation. Pay special attention to:</p>\n<ol>\n<li>Alignment (test on ARM if possible)</li>\n<li>Minimum block size (test with 1-byte allocations)</li>\n<li>Block splitting (verify remainder sizes)</li>\n</ol>\n<p><strong>Challenge</strong>: Implement best-fit allocation and compare fragmentation with first-fit using the test suite.</p>\n<hr>\n<p><a href=\"#satellite-map\">â†‘ Back to System Map</a></p>\n<div id=\"ms-root-scanning\"></div>\n\n<h1 id=\"milestone-4-root-set-identification\">Milestone 4: Root Set Identification</h1>\n<h2 id=\"the-epiphany-analogy-the-crime-scene-investigation\">The Epiphany Analogy: The Crime Scene Investigation</h2>\n<p>Imagine you&#39;re a detective investigating a crime scene. You need to find all the evidence that&#39;s <strong>currently in use</strong>:</p>\n<ul>\n<li><strong>Active witnesses</strong> (stack frames): People currently at the scene</li>\n<li><strong>Security cameras</strong> (CPU registers): What&#39;s being watched right now</li>\n<li><strong>Building residents</strong> (global variables): Permanent occupants who might have seen something</li>\n</ul>\n<p>You can&#39;t just look at <em>everything</em> in the cityâ€”that would take forever. You start with the <strong>active participants</strong> and follow their connections.</p>\n<p><strong>In garbage collection, this is exactly what root scanning does</strong>: Find all the pointers that are <strong>actively accessible</strong> right now, then trace from there to discover what&#39;s alive.</p>\n<hr>\n<h2 id=\"technical-rationale-why-root-scanning-matters\">Technical Rationale: Why Root Scanning Matters</h2>\n<h3 id=\"the-reachability-problem\">The Reachability Problem</h3>\n<p><strong>Question</strong>: How do we know which objects are still in use?</p>\n<p><strong>Answer</strong>: An object is alive if and only if:</p>\n<ol>\n<li>It&#39;s <strong>directly accessible</strong> from a root (stack, global, register), OR</li>\n<li>It&#39;s <strong>reachable</strong> from another alive object</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Root Set â†’ Object Graph â†’ Live Objects\n   â†“\n[Stack]  â†’  obj1  â†’  obj2  â†’  obj3\n[Global] â†’  obj4  â†’  obj5\n[Register] â†’ obj6</code></pre></div>\n\n<p><strong>Without accurate root scanning, the GC will</strong>:</p>\n<ul>\n<li>âŒ <strong>Collect live objects</strong> (use-after-free crashes)</li>\n<li>âŒ <strong>Keep dead objects</strong> (memory leaks)</li>\n<li>âŒ <strong>Corrupt program state</strong> (dangling pointers)</li>\n</ul>\n<h3 id=\"the-three-root-sources\">The Three Root Sources</h3>\n<table>\n<thead>\n<tr>\n<th>Root Type</th>\n<th>Location</th>\n<th>Lifetime</th>\n<th>Scanning Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Stack</strong></td>\n<td>Function call frames</td>\n<td>Function scope</td>\n<td>Walk stack frames</td>\n</tr>\n<tr>\n<td><strong>Globals</strong></td>\n<td><code>.data</code> and <code>.bss</code> sections</td>\n<td>Program lifetime</td>\n<td>Scan registered ranges</td>\n</tr>\n<tr>\n<td><strong>Registers</strong></td>\n<td>CPU registers</td>\n<td>Instruction-level</td>\n<td>Capture at GC entry</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"internal-mechanics-how-root-scanning-works\">Internal Mechanics: How Root Scanning Works</h2>\n<h3 id=\"architecture-overview\">Architecture Overview</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         GC Root Scanner                 â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                         â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚\nâ”‚  â”‚ Stack Walker â”‚  â”‚ Global Scan â”‚    â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â”‚\nâ”‚         â”‚                  â”‚            â”‚\nâ”‚         â–¼                  â–¼            â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚\nâ”‚  â”‚     Root Set (Array)         â”‚     â”‚\nâ”‚  â”‚  [ptr1, ptr2, ptr3, ...]     â”‚     â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚\nâ”‚                  â”‚                      â”‚\nâ”‚                  â–¼                      â”‚\nâ”‚         Mark Phase (Next)              â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></div>\n\n<p>{{DIAGRAM:root-scanner-architecture}}</p>\n<h3 id=\"step-1-stack-frame-walking\">Step 1: Stack Frame Walking</h3>\n<p><strong>The Challenge</strong>: The stack grows downward, and we need to scan upward from the current frame to the bottom.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>High Address\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   main() frame  â”‚  â† Stack bottom (oldest)\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   foo() frame   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   bar() frame   â”‚  â† Current frame (newest)\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   (unused)      â”‚  â† Stack pointer (SP)\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nLow Address</code></pre></div>\n\n<p><strong>Key Insight</strong>: Each stack frame contains:</p>\n<ul>\n<li><strong>Local variables</strong> (potential pointers)</li>\n<li><strong>Return address</strong> (not a heap pointer)</li>\n<li><strong>Saved registers</strong> (potential pointers)</li>\n<li><strong>Function arguments</strong> (potential pointers)</li>\n</ul>\n<p><strong>Problem</strong>: We can&#39;t distinguish pointers from integers!</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> foo</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 42</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">           // Not a pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> obj;</span><span style=\"color:#6A737D\">      // Pointer!</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> y </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">7fff1234</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Looks like a pointer, but isn't</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Solution</strong>: <strong>Conservative scanning</strong> â€” treat anything that <em>looks</em> like a heap pointer as a potential root.</p>\n<h3 id=\"step-2-conservative-pointer-detection\">Step 2: Conservative Pointer Detection</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_potential_pointer</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Must be within heap bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->heap_start </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ptr </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Must be aligned (pointers are word-aligned)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)ptr </span><span style=\"color:#F97583\">%</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Must point to a valid object header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_valid_header</span><span style=\"color:#E1E4E8\">(gc, header)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Trade-off</strong>:</p>\n<ul>\n<li>âœ… <strong>Safe</strong>: Never misses a real pointer (no use-after-free)</li>\n<li>âŒ <strong>Conservative</strong>: May keep dead objects alive (false positives)</li>\n</ul>\n<h3 id=\"step-3-global-variable-scanning\">Step 3: Global Variable Scanning</h3>\n<p><strong>The Problem</strong>: Where are global variables stored?</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In your program:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> global_obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Where is this in memory?</span></span></code></pre></div>\n\n<p><strong>Answer</strong>: In the <code>.data</code> or <code>.bss</code> sections of the executable.</p>\n<p><strong>Solution</strong>: Register global ranges manually:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> end;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} MemoryRange;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MemoryRange </span><span style=\"color:#FFAB70\">ranges</span><span style=\"color:#E1E4E8\">[MAX_GLOBAL_RANGES];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> num_ranges;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} GlobalRoots;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_register_globals</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> start</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> end</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->global_roots.ranges[gc->global_roots.num_ranges</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (MemoryRange){start, end};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Usage</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In your main():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> global_obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> global_obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register global variables</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_register_globals</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">global_obj1, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">global_obj2 </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Now GC can scan these globals</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"visual-reference\">Visual Reference</h2>\n<p>{{DIAGRAM:root-scanning-flow}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                  gc_collect()                       â”‚\nâ”‚                       â†“                             â”‚\nâ”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚\nâ”‚              â”‚ Scan Roots     â”‚                     â”‚\nâ”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚\nâ”‚                       â†“                             â”‚\nâ”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚\nâ”‚       â†“                               â†“             â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚\nâ”‚  â”‚ Stack   â”‚                    â”‚ Globals  â”‚       â”‚\nâ”‚  â”‚ Walker  â”‚                    â”‚ Scanner  â”‚       â”‚\nâ”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜       â”‚\nâ”‚       â”‚                               â”‚             â”‚\nâ”‚       â†“                               â†“             â”‚\nâ”‚  For each word:                  For each range:   â”‚\nâ”‚    if looks_like_ptr():            for each word:  â”‚\nâ”‚      add_root(ptr)                   if looks...   â”‚\nâ”‚                                                     â”‚\nâ”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚\nâ”‚              â”‚  Root Set      â”‚                     â”‚\nâ”‚              â”‚  [ptr array]   â”‚                     â”‚\nâ”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚\nâ”‚                       â†“                             â”‚\nâ”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚\nâ”‚              â”‚  Mark Phase    â”‚                     â”‚\nâ”‚              â”‚  (Next Mile)   â”‚                     â”‚\nâ”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></div>\n\n<hr>\n<h2 id=\"the-debugging-lab-common-root-scanning-bugs\">The Debugging Lab: Common Root Scanning Bugs</h2>\n<h3 id=\"bug-1-missing-stack-frames\">Bug 1: Missing Stack Frames</h3>\n<p><strong>Symptom</strong>: Objects are collected while still in use, causing crashes.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> foo</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span><span style=\"color:#6A737D\">  // CRASH: obj was collected!</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    use</span><span style=\"color:#E1E4E8\">(obj);</span><span style=\"color:#6A737D\">        // Use-after-free</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Cause</strong>: Stack scanning didn&#39;t reach the current frame.</p>\n<p><strong>Fix</strong>: Ensure stack scanning starts from the <strong>current</strong> stack pointer:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_collect</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> stack_top;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Capture current stack pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> __GNUC__</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stack_top </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> __builtin_frame_address</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #else</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> dummy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stack_top </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dummy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scan_stack</span><span style=\"color:#E1E4E8\">(gc, stack_top, gc->stack_bottom);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"bug-2-misaligned-pointer-detection\">Bug 2: Misaligned Pointer Detection</h3>\n<p><strong>Symptom</strong>: Valid pointers are missed, objects are incorrectly collected.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> Foo {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> padding</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> ptr;</span><span style=\"color:#6A737D\">  // Misaligned!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Cause</strong>: Pointer is not word-aligned, so <code>is_potential_pointer()</code> rejects it.</p>\n<p><strong>Fix</strong>: Scan <strong>all bytes</strong>, not just aligned words:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scan_memory_range</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> start</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> end</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scan byte-by-byte for misaligned pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> start; p </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)end </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">); p</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> potential_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)p;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_potential_pointer</span><span style=\"color:#E1E4E8\">(gc, potential_ptr)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            add_root</span><span style=\"color:#E1E4E8\">(gc, potential_ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Trade-off</strong>: Slower, but safer.</p>\n<h3 id=\"bug-3-false-positives-conservative-scanning\">Bug 3: False Positives (Conservative Scanning)</h3>\n<p><strong>Symptom</strong>: Memory usage grows over time (memory leak).</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> foo</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">7fff12345678</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Looks like a heap pointer!</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span><span style=\"color:#6A737D\">           // Object at 0x7fff12345678 kept alive</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Cause</strong>: Integer value happens to match a heap address.</p>\n<p><strong>Fix</strong>: This is <strong>inherent to conservative GC</strong>. Mitigations:</p>\n<ol>\n<li>Use <strong>precise GC</strong> (requires type information)</li>\n<li>Clear dead stack frames: <code>memset(old_frame, 0, frame_size)</code></li>\n<li>Use <strong>generational GC</strong> (reduces false positive impact)</li>\n</ol>\n<h3 id=\"bug-4-register-spilling\">Bug 4: Register Spilling</h3>\n<p><strong>Symptom</strong>: Pointers in registers are missed.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> foo</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // obj is in register, not on stack!</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span><span style=\"color:#6A737D\">  // CRASH: obj not found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Cause</strong>: Compiler optimized <code>obj</code> into a register.</p>\n<p><strong>Fix</strong>: Force register spilling before GC:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> GC_COLLECT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">gc</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">do</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Force all registers to stack */</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jmp_buf registers; </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    setjmp</span><span style=\"color:#E1E4E8\">(registers); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_collect_impl</span><span style=\"color:#E1E4E8\">(gc); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>How <code>setjmp</code> works</strong>: Saves all registers to the stack, making them scannable.</p>\n<hr>\n<h2 id=\"code-scaffold-your-implementation-tasks\">Code Scaffold: Your Implementation Tasks</h2>\n<h3 id=\"data-structures\">Data Structures</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Root set: dynamic array of potential pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> roots;</span><span style=\"color:#6A737D\">       // Array of root pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> count;</span><span style=\"color:#6A737D\">       // Number of roots</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> capacity;</span><span style=\"color:#6A737D\">    // Array capacity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} RootSet;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Global variable ranges</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> end;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} MemoryRange;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_GLOBAL_RANGES</span><span style=\"color:#79B8FF\"> 16</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MemoryRange </span><span style=\"color:#FFAB70\">ranges</span><span style=\"color:#E1E4E8\">[MAX_GLOBAL_RANGES];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> num_ranges;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} GlobalRoots;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Add to GC struct:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> GC {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... existing fields ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RootSet root_set;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GlobalRoots global_roots;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> stack_bottom;</span><span style=\"color:#6A737D\">  // Bottom of stack (set at init)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} GC;</span></span></code></pre></div>\n\n<h3 id=\"task-1-initialize-root-set\">Task 1: Initialize Root Set</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_root_set</span><span style=\"color:#E1E4E8\">(RootSet</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> roots</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Allocate initial capacity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    roots->capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 256</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    roots->count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    roots->roots </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(roots->capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (roots->roots </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Failed to allocate root set</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        abort</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> free_root_set</span><span style=\"color:#E1E4E8\">(RootSet</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> roots</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Free root array</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(roots->roots);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    roots->roots </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    roots->count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    roots->capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-2-add-root-to-set\">Task 2: Add Root to Set</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> add_root</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RootSet</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> roots </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">gc->root_set;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if we need to resize</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (roots->count </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> roots->capacity) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Double capacity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> new_capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> roots->capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void**</span><span style=\"color:#E1E4E8\"> new_roots </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> realloc</span><span style=\"color:#E1E4E8\">(roots->roots, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                   new_capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (new_roots </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Failed to resize root set</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            abort</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        roots->roots </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_roots;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        roots->capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_capacity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add pointer to array</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    roots->roots[roots->count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> clear_roots</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Reset count (don't free array)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->root_set.count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-3-conservative-pointer-detection\">Task 3: Conservative Pointer Detection</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_potential_pointer</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 1 - Check if within heap bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->heap_start </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ptr </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 2 - Check alignment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Pointers must be word-aligned (4 or 8 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)ptr </span><span style=\"color:#F97583\">%</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 3 - Check if points to valid object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Try to interpret as object header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sanity checks:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Size must be reasonable (not 0, not huge)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Must be within heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (header->size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> header->size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> gc->heap_size) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)header </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (obj_end </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Optional - Check type field is valid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (header->type </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> TYPE_MAX) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Quick Breakdown: Why These Checks?</strong></p>\n<ol>\n<li><strong>Heap bounds</strong>: Integers often look like pointers, but they&#39;re not in our heap</li>\n<li><strong>Alignment</strong>: Real pointers are aligned; random integers usually aren&#39;t</li>\n<li><strong>Valid header</strong>: If it&#39;s a real object, its header should make sense</li>\n<li><strong>Size check</strong>: Catches corrupted headers or false positives</li>\n</ol>\n<h3 id=\"task-4-stack-scanning\">Task 4: Stack Scanning</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scan_stack</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> stack_top</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> stack_bottom</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Ensure stack_top &#x3C; stack_bottom (stack grows down)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (stack_top </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> stack_bottom) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> temp </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stack_top;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stack_top </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stack_bottom;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stack_bottom </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> temp;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Scan every word on the stack</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Cast to uintptr_t* to scan word-by-word</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uintptr_t*</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uintptr_t*</span><span style=\"color:#E1E4E8\">)stack_top;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uintptr_t*</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uintptr_t*</span><span style=\"color:#E1E4E8\">)stack_bottom;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (p </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> end) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Read word from stack</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> potential_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">p;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Check if it looks like a heap pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_potential_pointer</span><span style=\"color:#E1E4E8\">(gc, potential_ptr)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Add to root set</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            add_root</span><span style=\"color:#E1E4E8\">(gc, potential_ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Move to next word</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Debugging Tip</strong>: Print the stack range and number of roots found:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Scanning stack: </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\"> to </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       stack_top, stack_bottom, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)stack_bottom </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">stack_top</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Found </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> potential roots</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">root_set.count);</span></span></code></pre></div>\n\n<h3 id=\"task-5-global-variable-scanning\">Task 5: Global Variable Scanning</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_register_globals</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> start</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> end</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check we haven't exceeded max ranges</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->global_roots.num_ranges </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> MAX_GLOBAL_RANGES) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Too many global ranges</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        abort</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add range to array</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MemoryRange range </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {start, end};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->global_roots.ranges[gc->global_roots.num_ranges</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> range;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scan_globals</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Scan each registered range</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->global_roots.num_ranges; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        MemoryRange</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> range </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">gc->global_roots.ranges[i];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Scan word-by-word</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uintptr_t*</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uintptr_t*</span><span style=\"color:#E1E4E8\">)range->start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uintptr_t*</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uintptr_t*</span><span style=\"color:#E1E4E8\">)range->end;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (p </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> end) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            void*</span><span style=\"color:#E1E4E8\"> potential_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">p;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_potential_pointer</span><span style=\"color:#E1E4E8\">(gc, potential_ptr)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                add_root</span><span style=\"color:#E1E4E8\">(gc, potential_ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            p</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-6-main-root-scanning-entry-point\">Task 6: Main Root Scanning Entry Point</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scan_roots</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Clear previous roots</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    clear_roots</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 1 - Capture current stack pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> stack_top;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> __GNUC__</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // GCC/Clang: Use builtin</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stack_top </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> __builtin_frame_address</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #else</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Fallback: Use address of local variable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> dummy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stack_top </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dummy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 2 - Scan stack</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scan_stack</span><span style=\"color:#E1E4E8\">(gc, stack_top, gc->stack_bottom);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 3 - Scan globals</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scan_globals</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 4 - Print statistics (debug)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Root scanning complete: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> roots found</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           gc->root_set.count);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-7-initialize-stack-bottom\">Task 7: Initialize Stack Bottom</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> heap_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(GC));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... existing initialization ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Capture stack bottom (do this FIRST in main())</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This should be called from main(), so we capture the bottom</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    volatile</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> dummy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stack_bottom </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">dummy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize root set</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_root_set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">gc->root_set);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize global roots</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->global_roots.num_ranges </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> gc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Important</strong>: <code>gc_init()</code> must be called from <code>main()</code> to capture the correct stack bottom!</p>\n<hr>\n<h2 id=\"testing-your-implementation\">Testing Your Implementation</h2>\n<h3 id=\"test-1-stack-scanning\">Test 1: Stack Scanning</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_stack_scanning</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scan roots</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scan_roots</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify all objects were found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> found1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">, found2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">, found3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->root_set.count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (gc->root_set.roots[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> obj1) found1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (gc->root_set.roots[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> obj2) found2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (gc->root_set.roots[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> obj3) found3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(found1 </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> found2 </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> found3);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Stack scanning test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-2-global-scanning\">Test 2: Global Scanning</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Global variables</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> global_obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> global_obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_global_scanning</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register globals</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_register_globals</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">global_obj1, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">global_obj2 </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate objects</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    global_obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    global_obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scan roots</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scan_roots</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify globals were found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> found1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">, found2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->root_set.count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (gc->root_set.roots[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> global_obj1) found1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (gc->root_set.roots[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> global_obj2) found2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(found1 </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> found2);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Global scanning test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-3-conservative-scanning-false-positives\">Test 3: Conservative Scanning (False Positives)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_conservative_scanning</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create integer that looks like a pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uintptr_t</span><span style=\"color:#E1E4E8\"> fake_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)obj;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scan roots</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scan_roots</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The fake pointer should be detected</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> found </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->root_set.count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)gc->root_set.roots[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> fake_ptr) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            found </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(found);</span><span style=\"color:#6A737D\">  // Conservative GC keeps it alive</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Conservative scanning test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-4-nested-function-calls\">Test 4: Nested Function Calls</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> nested_level_3</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scan_roots</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify obj is still found (3 frames deep)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> found </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->root_set.count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (gc->root_set.roots[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> obj) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            found </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(found);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> nested_level_2</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    nested_level_3</span><span style=\"color:#E1E4E8\">(gc, obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> nested_level_1</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    nested_level_2</span><span style=\"color:#E1E4E8\">(gc, obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_nested_calls</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    nested_level_1</span><span style=\"color:#E1E4E8\">(gc, obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Nested calls test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-5-root-set-resizing\">Test 5: Root Set Resizing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_root_set_resize</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate many objects to force resize</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#FFAB70\"> objects</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        objects</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scan roots (should trigger resize)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scan_roots</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify all objects were found</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->root_set.count </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->root_set.capacity </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> gc->root_set.count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Root set resize test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-considerations\">Performance Considerations</h2>\n<h3 id=\"time-complexity\">Time Complexity</h3>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Complexity</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>scan_stack()</code></td>\n<td>O(stack_size)</td>\n<td>Typically 1-8 MB</td>\n</tr>\n<tr>\n<td><code>scan_globals()</code></td>\n<td>O(global_size)</td>\n<td>Usually small</td>\n</tr>\n<tr>\n<td><code>is_potential_pointer()</code></td>\n<td>O(1)</td>\n<td>Just bounds checks</td>\n</tr>\n<tr>\n<td><strong>Total</strong></td>\n<td><strong>O(stack + globals)</strong></td>\n<td>Linear in root size</td>\n</tr>\n</tbody></table>\n<h3 id=\"space-complexity\">Space Complexity</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Root set size: O(number of pointers on stack + globals)\n\nTypical values:\n- Stack: 1000-10000 words (4-40 KB)\n- Globals: 100-1000 words (0.4-4 KB)\n- Root set: ~10000 pointers (40-80 KB)</code></pre></div>\n\n<h3 id=\"optimization-precise-stack-maps\">Optimization: Precise Stack Maps</h3>\n<p><strong>Problem</strong>: Conservative scanning is slow and causes false positives.</p>\n<p><strong>Solution</strong>: <strong>Precise GC</strong> with stack maps:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Compiler generates stack map for each function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> return_address;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> num_pointers;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#FFAB70\"> offsets</span><span style=\"color:#E1E4E8\">[MAX_POINTERS];</span><span style=\"color:#6A737D\">  // Offsets of pointers in frame</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} StackMap;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// At GC time, look up stack map for each frame</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scan_stack_precise</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> stack_top</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> frame_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)stack_top;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (frame_ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->stack_bottom) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> return_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> frame_ptr</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        StackMap</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> map </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> lookup_stack_map</span><span style=\"color:#E1E4E8\">(return_addr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Scan only known pointer locations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> map->num_pointers; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)frame_ptr </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> map->offsets[i]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            add_root</span><span style=\"color:#E1E4E8\">(gc, ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        frame_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">frame_ptr</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">  // Follow frame pointer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Benefits</strong>:</p>\n<ul>\n<li>âœ… No false positives</li>\n<li>âœ… Faster scanning (skip non-pointers)</li>\n<li>âœ… Enables moving GC (precise pointer knowledge)</li>\n</ul>\n<p><strong>Drawbacks</strong>:</p>\n<ul>\n<li>âŒ Requires compiler support</li>\n<li>âŒ Larger binary (stack maps embedded)</li>\n<li>âŒ Complex implementation</li>\n</ul>\n<hr>\n<h2 id=\"what-you39ve-learned\">What You&#39;ve Learned</h2>\n<p>âœ… <strong>Root Set Concept</strong>: What roots are and why they matter<br>âœ… <strong>Conservative Scanning</strong>: How to find pointers without type information<br>âœ… <strong>Stack Walking</strong>: How to traverse stack frames safely<br>âœ… <strong>Global Registration</strong>: How to track global variables<br>âœ… <strong>Pointer Validation</strong>: How to distinguish pointers from integers<br>âœ… <strong>False Positives</strong>: The trade-offs of conservative GC<br>âœ… <strong>Platform Differences</strong>: Stack layout and register handling  </p>\n<hr>\n<h2 id=\"next-steps\">Next Steps</h2>\n<p>Now that you can identify all GC roots, you&#39;re ready to:</p>\n<ul>\n<li><strong><a href=\"#mark-engine\">Mark Phase â†’</a></strong>: Traverse the object graph from roots to mark live objects</li>\n<li><strong><a href=\"#sweep-engine\">Sweep Phase â†’</a></strong>: Reclaim unmarked objects and rebuild the free list</li>\n<li><strong><a href=\"#gc-integration\">Integration â†’</a></strong>: Connect all phases into a working garbage collector</li>\n</ul>\n<p><strong>Pro Tip</strong>: Before moving on, verify your root scanner with the test suite. Pay special attention to:</p>\n<ol>\n<li><strong>Stack direction</strong>: Ensure <code>stack_top &lt; stack_bottom</code></li>\n<li><strong>Alignment</strong>: Test on both 32-bit and 64-bit platforms</li>\n<li><strong>False positives</strong>: Monitor memory usage over time</li>\n</ol>\n<p><strong>Challenge</strong>: Implement a <strong>root set deduplication</strong> pass to remove duplicate pointers (improves mark phase performance).</p>\n<hr>\n<p><a href=\"#satellite-map\">â†‘ Back to System Map</a></p>\n<div id=\"ms-mark-phase\"></div>\n\n<h1 id=\"mark-phase-implementation-the-graph-traversal-engine\">Mark Phase Implementation: The Graph Traversal Engine</h1>\n<h2 id=\"epiphany-analogy-the-lighthouse-network\">Epiphany Analogy: The Lighthouse Network</h2>\n<p>Imagine a coastal region during a blackout. You&#39;re in a helicopter with a spotlight, and your job is to identify which lighthouses are still operational.</p>\n<p><strong>Phase 1 (Roots)</strong>: You start by shining your light on the <strong>main control stations</strong> (roots) â€” the ones you know are always active.</p>\n<p><strong>Phase 2 (Mark)</strong>: Each lighthouse you illuminate has <strong>signal cables</strong> connecting it to other lighthouses. You follow each cable, marking every connected lighthouse with <strong>glow-in-the-dark paint</strong>. You use a <strong>work queue</strong> (a checklist) to ensure you don&#39;t miss any connections.</p>\n<p><strong>The Result</strong>: When you&#39;re done, every lighthouse with glow paint is <strong>reachable</strong> (alive). The dark ones are <strong>unreachable</strong> (garbage).</p>\n<p>This is <strong>mark-and-sweep garbage collection</strong>: roots â†’ traverse â†’ mark â†’ sweep.</p>\n<hr>\n<h2 id=\"technical-rationale-why-iterative-depth-first-traversal\">Technical Rationale: Why Iterative Depth-First Traversal?</h2>\n<h3 id=\"the-problem-object-graph-traversal\">The Problem: Object Graph Traversal</h3>\n<p>After root scanning, you have a set of <strong>entry points</strong> into the heap. But objects reference <em>other</em> objects, forming a <strong>directed graph</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Root Set:\n  obj1 â†’ obj2 â†’ obj4\n  obj3 â†’ obj5 â†’ obj6 â†’ obj7\n  \nUnreachable:\n  obj8 â†’ obj9  (no path from roots)</code></pre></div>\n\n<p><strong>Goal</strong>: Mark every object reachable from roots.</p>\n<h3 id=\"why-not-recursive-traversal\">Why Not Recursive Traversal?</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// âŒ DANGEROUS: Recursive marking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_recursive</span><span style=\"color:#E1E4E8\">(Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (obj->marked) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    obj->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (each child in obj->children) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mark_recursive</span><span style=\"color:#E1E4E8\">(child);</span><span style=\"color:#6A737D\">  // Stack overflow risk!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Problem</strong>: Deep object graphs (e.g., linked lists with 100,000 nodes) cause <strong>stack overflow</strong>.</p>\n<h3 id=\"the-solution-iterative-traversal-with-work-queue\">The Solution: Iterative Traversal with Work Queue</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// âœ… SAFE: Iterative marking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_iterative</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WorkQueue queue;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_queue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add all roots to queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (each root in gc->root_set) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        enqueue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue, root);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Process queue until empty</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">obj->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            obj->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Add children to queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (each child in obj->children) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                enqueue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue, child);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Benefits</strong>:</p>\n<ul>\n<li>âœ… <strong>Bounded stack usage</strong>: Only queue grows (on heap)</li>\n<li>âœ… <strong>Predictable memory</strong>: Queue size â‰ˆ graph width</li>\n<li>âœ… <strong>Debuggable</strong>: Can inspect queue state</li>\n</ul>\n<hr>\n<h2 id=\"internal-mechanics-the-mark-phase-architecture\">Internal Mechanics: The Mark Phase Architecture</h2>\n<h3 id=\"component-1-the-work-queue\">Component 1: The Work Queue</h3>\n<p>{{DIAGRAM:mark-work-queue}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Work Queue (FIFO):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [obj1] [obj3] [obj5] [obj7] ...     â”‚  â† Enqueue (back)\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n   â†‘\n   Dequeue (front)\n\nProperties:\n- Dynamic resizing (like root set)\n- FIFO order (breadth-first)\n- Duplicate detection (via mark bits)</code></pre></div>\n\n<h3 id=\"component-2-the-mark-bit\">Component 2: The Mark Bit</h3>\n<p>Each object header contains a <strong>mark bit</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> ObjectHeader {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">           // Object size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> marked : </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">       // Mark bit (1 bit)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> pinned : </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">       // Pinned flag</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> padding : </span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   // Alignment padding</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span><span style=\"color:#6A737D\">  // Free list link</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ObjectHeader;</span></span></code></pre></div>\n\n<p><strong>Mark Bit States</strong>:</p>\n<ul>\n<li><code>0</code> (unmarked): Not yet visited or unreachable</li>\n<li><code>1</code> (marked): Reachable from roots</li>\n</ul>\n<h3 id=\"component-3-object-scanning\">Component 3: Object Scanning</h3>\n<p>For each object, we must find <strong>all pointers it contains</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scan_object</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">, WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scan object's memory word-by-word (conservative)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uintptr_t*</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uintptr_t*</span><span style=\"color:#E1E4E8\">)obj;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uintptr_t*</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uintptr_t*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (p </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> end) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> potential_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">p;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_potential_pointer</span><span style=\"color:#E1E4E8\">(gc, potential_ptr)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            enqueue</span><span style=\"color:#E1E4E8\">(queue, potential_ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Quick Breakdown: Conservative Object Scanning</strong></p>\n<p>We scan <strong>every word</strong> in the object because we don&#39;t have type information. This means:</p>\n<ul>\n<li><strong>Integers that look like pointers</strong> â†’ Treated as pointers (false positives)</li>\n<li><strong>Actual pointers</strong> â†’ Correctly identified</li>\n<li><strong>Trade-off</strong>: Safety over precision</li>\n</ul>\n<hr>\n<h2 id=\"the-mark-algorithm-step-by-step\">The Mark Algorithm: Step-by-Step</h2>\n<h3 id=\"phase-1-initialization\">Phase 1: Initialization</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_phase</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 1: Clear all mark bits</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    clear_all_marks</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 2: Scan roots</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scan_roots</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 3: Initialize work queue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WorkQueue queue;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_work_queue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 4: Add roots to queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->root_set.count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        enqueue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue, gc->root_set.roots[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span></code></pre></div>\n\n<h3 id=\"phase-2-iterative-traversal\">Phase 2: Iterative Traversal</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">    // Step 5: Process queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">queue</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Get object header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Skip if already marked</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (header->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Mark object</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        header->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->stats.marked_objects</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->stats.marked_bytes </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Scan object for pointers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        scan_object</span><span style=\"color:#E1E4E8\">(gc, obj, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Step 6: Cleanup</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_work_queue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">queue</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"phase-3-statistics\">Phase 3: Statistics</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Mark phase complete:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Marked objects: </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">stats.marked_objects);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Marked bytes: </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">stats.marked_bytes);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Mark rate: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> MB/s</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">stats.marked_bytes </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">stats.mark_time_ms </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1000.0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"visual-reference\">Visual Reference</h2>\n<p>{{DIAGRAM:mark-phase-flow}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Mark Phase Flow:\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n1. CLEAR MARKS\n   â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”\n   â”‚ â—‹ A â”‚ â”‚ â—‹ B â”‚ â”‚ â—‹ C â”‚  (all unmarked)\n   â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜\n\n2. SCAN ROOTS\n   Roots: [A, C]\n   \n3. INITIALIZE QUEUE\n   Queue: [A] [C]\n\n4. PROCESS A\n   â”Œâ”€â”€â”€â”€â”€â”\n   â”‚ â— A â”‚ â† Mark\n   â””â”€â”€â”¬â”€â”€â”˜\n      â”‚ points to B\n      â†“\n   Queue: [C] [B]\n\n5. PROCESS C\n   â”Œâ”€â”€â”€â”€â”€â”\n   â”‚ â— C â”‚ â† Mark\n   â””â”€â”€â”€â”€â”€â”˜\n   (no children)\n   Queue: [B]\n\n6. PROCESS B\n   â”Œâ”€â”€â”€â”€â”€â”\n   â”‚ â— B â”‚ â† Mark\n   â””â”€â”€â”¬â”€â”€â”˜\n      â”‚ points to D\n      â†“\n   Queue: [D]\n\n7. PROCESS D\n   â”Œâ”€â”€â”€â”€â”€â”\n   â”‚ â— D â”‚ â† Mark\n   â””â”€â”€â”€â”€â”€â”˜\n   Queue: [] (empty)\n\n8. DONE\n   Marked: A, B, C, D\n   Unmarked: (garbage)</code></pre></div>\n\n<hr>\n<h2 id=\"the-debugging-lab-common-pitfalls\">The Debugging Lab: Common Pitfalls</h2>\n<h3 id=\"bug-1-forgetting-to-clear-marks\">Bug 1: Forgetting to Clear Marks</h3>\n<p><strong>Symptom</strong>: Objects never get collected after first GC.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// âŒ WRONG: Marks accumulate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_phase</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Missing: clear_all_marks(gc);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scan_roots</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// âœ… CORRECT: Clear marks before each GC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> clear_all_marks</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (Block</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start; </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         block </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->heap_end; </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         block </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> NEXT_BLOCK</span><span style=\"color:#E1E4E8\">(block)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        header->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"bug-2-infinite-loop-cycles\">Bug 2: Infinite Loop (Cycles)</h3>\n<p><strong>Symptom</strong>: Mark phase never terminates.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// âŒ WRONG: No duplicate detection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">queue</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Missing: if (header->marked) continue;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scan_object</span><span style=\"color:#E1E4E8\">(gc, obj, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span><span style=\"color:#6A737D\">  // Re-adds obj!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Check mark bit <strong>before</strong> marking:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// âœ… CORRECT: Skip already-marked objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (header</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">marked) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    continue</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Already processed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">header</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<h3 id=\"bug-3-queue-overflow\">Bug 3: Queue Overflow</h3>\n<p><strong>Symptom</strong>: Crash when marking large graphs.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// âŒ WRONG: Fixed-size queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_QUEUE_SIZE</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">[MAX_QUEUE_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> queue_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> enqueue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    queue</span><span style=\"color:#E1E4E8\">[queue_size</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> obj;</span><span style=\"color:#6A737D\">  // Overflow!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Dynamic resizing:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// âœ… CORRECT: Resizable queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> enqueue</span><span style=\"color:#E1E4E8\">(WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> q</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (q->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> q->capacity) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        q->capacity </span><span style=\"color:#F97583\">*=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        q->items </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> realloc</span><span style=\"color:#E1E4E8\">(q->items, q->capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    q->items[q->size</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> obj;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"bug-4-scanning-uninitialized-memory\">Bug 4: Scanning Uninitialized Memory</h3>\n<p><strong>Symptom</strong>: Random crashes or false pointers.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// âŒ WRONG: Scanning beyond object bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scan_object</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">, WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uintptr_t*</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uintptr_t*</span><span style=\"color:#E1E4E8\">)obj;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Missing: bounds check</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span><span style=\"color:#6A737D\">  // Arbitrary limit!</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        enqueue</span><span style=\"color:#E1E4E8\">(queue, (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">p</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Use object size from header:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// âœ… CORRECT: Respect object bounds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uintptr_t*</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uintptr_t*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">size);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (p </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> end) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Safe: within object bounds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"code-scaffold-your-implementation-tasks\">Code Scaffold: Your Implementation Tasks</h2>\n<h3 id=\"task-1-work-queue-implementation\">Task 1: Work Queue Implementation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> items;</span><span style=\"color:#6A737D\">      // Dynamic array of object pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">       // Current number of items</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> capacity;</span><span style=\"color:#6A737D\">   // Allocated capacity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> head;</span><span style=\"color:#6A737D\">       // Dequeue position (FIFO)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} WorkQueue;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_work_queue</span><span style=\"color:#E1E4E8\">(WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Allocate initial capacity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 256</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Start small</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->items </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(queue->capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (queue->items </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Failed to allocate work queue</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        abort</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize size and head</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->head </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> enqueue</span><span style=\"color:#E1E4E8\">(WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if resize needed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (queue->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> queue->capacity) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Double capacity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> new_capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> queue->capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void**</span><span style=\"color:#E1E4E8\"> new_items </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> realloc</span><span style=\"color:#E1E4E8\">(queue->items, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                   new_capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (new_items </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR: Failed to resize work queue</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            abort</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        queue->items </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_items;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        queue->capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_capacity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Work queue resized to </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, new_capacity);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add item to queue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->items[queue->size</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> obj;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if empty</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_empty</span><span style=\"color:#E1E4E8\">(queue)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return and remove front item</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> queue->items[queue->head</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_empty</span><span style=\"color:#E1E4E8\">(WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if all items processed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> queue->head </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> queue->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> destroy_work_queue</span><span style=\"color:#E1E4E8\">(WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Free memory</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(queue->items);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->items </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->head </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Debugging Tip</strong>: Track queue statistics:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> max_queue_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (queue</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> max_queue_size) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_queue_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> queue->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Max queue size: </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, max_queue_size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span></code></pre></div>\n\n<h3 id=\"task-2-clear-all-mark-bits\">Task 2: Clear All Mark Bits</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> clear_all_marks</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Iterate through all allocated blocks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> heap_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (current </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> heap_end) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Skip free blocks (check free list)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_in_free_list</span><span style=\"color:#E1E4E8\">(gc, header)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Clear mark bit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        header->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Move to next block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cleared all mark bits</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_in_free_list</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> header</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if header is in free list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> free_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list; </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         free_block </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">; </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         free_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> free_block->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (free_block </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> header) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Alternative Approach</strong>: Use a <strong>separate mark bitmap</strong> instead of mark bits in headers:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Bitmap: 1 bit per 8-byte word</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t*</span><span style=\"color:#E1E4E8\"> bits;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> num_bits;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} MarkBitmap;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> set_mark</span><span style=\"color:#E1E4E8\">(MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> bitmap</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> heap_start) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> byte </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> index </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bit </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> index </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bitmap->bits[byte] </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> bit);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-3-object-scanning\">Task 3: Object Scanning</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scan_object</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">, WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Get object header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate scan range</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uintptr_t*</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uintptr_t*</span><span style=\"color:#E1E4E8\">)obj;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uintptr_t*</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uintptr_t*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Scanning object </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\"> (size=</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, obj, header->size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> pointers_found </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Scan word-by-word</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (p </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> end) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> potential_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">p;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Check if it looks like a heap pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_potential_pointer</span><span style=\"color:#E1E4E8\">(gc, potential_ptr)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Add to work queue</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            enqueue</span><span style=\"color:#E1E4E8\">(queue, potential_ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pointers_found</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        p</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Found </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> pointers</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pointers_found);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-4-main-mark-phase\">Task 4: Main Mark Phase</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_phase</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">=== MARK PHASE START ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    clock_t</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 1 - Clear all marks</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    clear_all_marks</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 2 - Scan roots</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scan_roots</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Root set size: </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, gc->root_set.count);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 3 - Initialize work queue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WorkQueue queue;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_work_queue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 4 - Add all roots to queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->root_set.count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        enqueue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue, gc->root_set.roots[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 5 - Process work queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> objects_marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Get object header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Skip if already marked</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (header->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Mark object</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        header->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        objects_marked</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bytes_marked </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Scan object for child pointers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        scan_object</span><span style=\"color:#E1E4E8\">(gc, obj, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 6 - Cleanup</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_work_queue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Step 7 - Update statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.marked_objects </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> objects_marked;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.marked_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> bytes_marked;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    clock_t</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clock</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> elapsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)(end </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> CLOCKS_PER_SEC </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1000.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"=== MARK PHASE COMPLETE ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Objects marked: </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, objects_marked);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Bytes marked: </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, bytes_marked);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Time: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, elapsed);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Rate: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> MB/s</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           bytes_marked </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> elapsed </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1000.0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-5-mark-bit-helpers\">Task 5: Mark Bit Helpers</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_marked</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check mark bit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> header->marked;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> set_mark</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set mark bit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> clear_mark</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Clear mark bit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"testing-your-implementation\">Testing Your Implementation</h2>\n<h3 id=\"test-1-simple-linear-chain\">Test 1: Simple Linear Chain</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_linear_chain</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create chain: obj1 â†’ obj2 â†’ obj3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Link them</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> obj2;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> obj3;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark phase</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify all marked</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(obj1));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(obj2));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(obj3));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Linear chain test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-2-cyclic-graph\">Test 2: Cyclic Graph</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_cycle</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create cycle: obj1 â†’ obj2 â†’ obj3 â†’ obj1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> obj2;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> obj3;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)obj3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> obj1;</span><span style=\"color:#6A737D\">  // Cycle!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark phase (should terminate)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify all marked</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(obj1));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(obj2));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(obj3));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Cycle test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-3-unreachable-objects\">Test 3: Unreachable Objects</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_unreachable</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Reachable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Unreachable (not on stack after this block)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)obj2;</span><span style=\"color:#6A737D\">  // Suppress warning</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark phase</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // obj1 should be marked, obj2 should not</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(obj1));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: Can't easily test obj2 without keeping pointer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Unreachable test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-4-deep-graph\">Test 4: Deep Graph</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_deep_graph</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 1 MB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create deep chain (10,000 nodes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> first </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            first </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> obj;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (prev </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            *</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> obj;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> obj;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark phase (should not stack overflow)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify first is marked</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(first));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Deep graph test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-5-wide-graph\">Test 5: Wide Graph</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_wide_graph</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create root with 1000 children</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> root </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> children </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)root;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        children</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark phase</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify all marked</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(root));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">children</span><span style=\"color:#E1E4E8\">[i]));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Wide graph test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"test-6-mark-statistics\">Test 6: Mark Statistics</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_mark_statistics</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate known objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">300</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark phase</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify statistics</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->stats.marked_objects </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->stats.marked_bytes </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 600</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Mark statistics test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-considerations\">Performance Considerations</h2>\n<h3 id=\"time-complexity\">Time Complexity</h3>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Complexity</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>clear_all_marks()</code></td>\n<td>O(heap_size)</td>\n<td>Linear scan</td>\n</tr>\n<tr>\n<td><code>scan_roots()</code></td>\n<td>O(roots)</td>\n<td>From previous section</td>\n</tr>\n<tr>\n<td><strong>Mark traversal</strong></td>\n<td><strong>O(live_objects Ã— avg_pointers)</strong></td>\n<td><strong>Dominant cost</strong></td>\n</tr>\n<tr>\n<td><code>enqueue/dequeue</code></td>\n<td>O(1) amortized</td>\n<td>Dynamic array</td>\n</tr>\n<tr>\n<td><strong>Total</strong></td>\n<td><strong>O(heap + live_objects Ã— pointers)</strong></td>\n<td>Linear in live set</td>\n</tr>\n</tbody></table>\n<h3 id=\"space-complexity\">Space Complexity</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Work Queue Size:\n- Best case: O(1) (linear chain)\n- Worst case: O(live_objects) (all objects at same depth)\n- Typical: O(âˆšlive_objects) (balanced tree)\n\nExample:\n- 1 million objects\n- Average 4 pointers per object\n- Queue peak: ~1000 objects (4 KB)</code></pre></div>\n\n<h3 id=\"optimization-1-tri-color-marking\">Optimization 1: Tri-Color Marking</h3>\n<p><strong>Problem</strong>: Work queue can grow large.</p>\n<p><strong>Solution</strong>: Use <strong>tri-color abstraction</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WHITE,</span><span style=\"color:#6A737D\">  // Unmarked (not yet seen)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GRAY,</span><span style=\"color:#6A737D\">   // Marked but not scanned (in queue)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BLACK</span><span style=\"color:#6A737D\">   // Marked and scanned (done)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} Color;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Only GRAY objects are in queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_tricolor</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // All objects start WHITE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Roots become GRAY</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (each root) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        set_color</span><span style=\"color:#E1E4E8\">(root, GRAY);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        enqueue</span><span style=\"color:#E1E4E8\">(root);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Scan GRAY object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (each child) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">get_color</span><span style=\"color:#E1E4E8\">(child) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> WHITE) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                set_color</span><span style=\"color:#E1E4E8\">(child, GRAY);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                enqueue</span><span style=\"color:#E1E4E8\">(child);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Object is now BLACK (fully scanned)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        set_color</span><span style=\"color:#E1E4E8\">(obj, BLACK);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Benefits</strong>:</p>\n<ul>\n<li>âœ… Clearer algorithm structure</li>\n<li>âœ… Enables incremental GC (pause between objects)</li>\n<li>âœ… Easier to reason about correctness</li>\n</ul>\n<h3 id=\"optimization-2-pointer-filtering\">Optimization 2: Pointer Filtering</h3>\n<p><strong>Problem</strong>: Conservative scanning checks every word.</p>\n<p><strong>Solution</strong>: Use <strong>alignment hints</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_potential_pointer</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Quick reject: not aligned</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)ptr </span><span style=\"color:#F97583\">%</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Pointers are word-aligned</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Quick reject: out of heap bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->heap_start </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> gc->heap_end) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expensive check: valid object header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> is_valid_object</span><span style=\"color:#E1E4E8\">(gc, ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Speedup</strong>: ~2-3Ã— faster scanning</p>\n<h3 id=\"optimization-3-parallel-marking\">Optimization 3: Parallel Marking</h3>\n<p><strong>Problem</strong>: Single-threaded marking is slow.</p>\n<p><strong>Solution</strong>: <strong>Parallel work-stealing</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_parallel</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> num_threads</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WorkQueue </span><span style=\"color:#FFAB70\">queues</span><span style=\"color:#E1E4E8\">[num_threads];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Each thread has own queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #pragma</span><span style=\"color:#B392F0\"> omp</span><span style=\"color:#B392F0\"> parallel</span><span style=\"color:#B392F0\"> for</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_threads; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">queues</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (obj </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Try to steal from other threads</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> steal_work</span><span style=\"color:#E1E4E8\">(queues, num_threads, i);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (obj </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Mark and scan</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">atomic_test_and_set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">obj->marked)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                scan_object</span><span style=\"color:#E1E4E8\">(gc, obj, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">queues</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Speedup</strong>: ~4-8Ã— on modern CPUs</p>\n<hr>\n<h2 id=\"what-you39ve-learned\">What You&#39;ve Learned</h2>\n<p>âœ… <strong>Graph Traversal</strong>: How to walk object graphs without recursion<br>âœ… <strong>Work Queues</strong>: FIFO data structure for iterative algorithms<br>âœ… <strong>Mark Bits</strong>: Efficient boolean flags in object headers<br>âœ… <strong>Cycle Handling</strong>: Detecting and avoiding infinite loops<br>âœ… <strong>Conservative Scanning</strong>: Finding pointers without type info<br>âœ… <strong>Performance Tuning</strong>: Queue sizing, filtering, parallelization<br>âœ… <strong>Debugging Techniques</strong>: Statistics, logging, visualization  </p>\n<hr>\n<h2 id=\"next-steps\">Next Steps</h2>\n<p>You&#39;ve now implemented the <strong>mark phase</strong> â€” the heart of garbage collection! Next:</p>\n<ul>\n<li><strong><a href=\"#sweep-engine\">Sweep Phase â†’</a></strong>: Reclaim unmarked objects and rebuild free list</li>\n<li><strong><a href=\"#gc-integration\">Integration â†’</a></strong>: Connect mark-sweep into <code>gc_collect()</code></li>\n<li><strong><a href=\"#gc-optimization\">Optimization â†’</a></strong>: Generational GC, incremental marking</li>\n</ul>\n<p><strong>Pro Tip</strong>: Before moving on, run the test suite and verify:</p>\n<ol>\n<li><strong>No stack overflow</strong> on deep graphs (10,000+ nodes)</li>\n<li><strong>Correct cycle handling</strong> (mark phase terminates)</li>\n<li><strong>Accurate statistics</strong> (marked bytes match allocated bytes)</li>\n</ol>\n<p><strong>Challenge</strong>: Implement <strong>mark stack overflow recovery</strong> â€” when the work queue grows too large, fall back to recursive marking for a subset of objects.</p>\n<hr>\n<p><a href=\"#satellite-map\">â†‘ Back to System Map</a></p>\n<div id=\"ms-object-graph\"></div>\n\n<h1 id=\"object-graph-traversal-following-the-web-of-memory\">Object Graph Traversal: Following the Web of Memory</h1>\n<h2 id=\"the-epiphany-analogy-the-museum-curator39s-flashlight\">The Epiphany Analogy: The Museum Curator&#39;s Flashlight</h2>\n<p>Imagine you&#39;re a museum curator in a pitch-black warehouse filled with sculptures. Each sculpture has strings attached to other sculptures (references). Your job: find every sculpture connected to the entrance (roots) and mark them with glow-in-the-dark paint.</p>\n<p><strong>The naive approach</strong>: Follow each string recursively, going deeper and deeper. Problem? You might follow a 10,000-sculpture chain and run out of breadcrumbs (stack space).</p>\n<p><strong>The professional approach</strong>: Carry a clipboard (work queue). When you find a sculpture:</p>\n<ol>\n<li>Paint it with glow paint (mark bit)</li>\n<li>Write down all sculptures it points to on your clipboard</li>\n<li>Move to the next item on your clipboard</li>\n</ol>\n<p><strong>The cycle problem</strong>: What if sculpture A points to B, B points to C, and C points back to A? Solution: Before adding to your clipboard, check if it&#39;s already glowing. If it is, skip it!</p>\n<p>This is <strong>object graph traversal</strong> â€” the systematic exploration of memory&#39;s interconnected web.</p>\n<hr>\n<h2 id=\"technical-rationale-why-iterative-traversal\">Technical Rationale: Why Iterative Traversal?</h2>\n<h3 id=\"the-recursion-trap\">The Recursion Trap</h3>\n<p><strong>Naive recursive marking</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_recursive</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(obj)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Already visited</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    set_mark</span><span style=\"color:#E1E4E8\">(obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Recursively mark children</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (each child pointer in obj) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mark_recursive</span><span style=\"color:#E1E4E8\">(child);</span><span style=\"color:#6A737D\">  // âš ï¸ DANGER: Stack overflow!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>The problem</strong>:</p>\n<ul>\n<li>Each recursive call consumes <strong>~64 bytes</strong> of stack space (return address, frame pointer, local variables)</li>\n<li>Default stack size: <strong>~8 MB</strong> on Linux, <strong>~1 MB</strong> on Windows</li>\n<li>Maximum depth: <strong>~125,000 calls</strong> (Linux) or <strong>~15,000 calls</strong> (Windows)</li>\n<li>Real-world object graphs can be <strong>millions deep</strong> (linked lists, tree spines)</li>\n</ul>\n<p><strong>The solution</strong>: Replace the <strong>call stack</strong> with an <strong>explicit work queue</strong> in heap memory.</p>\n<hr>\n<h2 id=\"internal-mechanics-the-work-queue-algorithm\">Internal Mechanics: The Work Queue Algorithm</h2>\n<h3 id=\"data-structure-the-work-queue\">Data Structure: The Work Queue</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> items;</span><span style=\"color:#6A737D\">      // Dynamic array of object pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> capacity;</span><span style=\"color:#6A737D\">   // Total slots available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> head;</span><span style=\"color:#6A737D\">       // Next item to dequeue (read position)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> tail;</span><span style=\"color:#6A737D\">       // Next slot to enqueue (write position)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> count;</span><span style=\"color:#6A737D\">      // Number of items currently in queue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} WorkQueue;</span></span></code></pre></div>\n\n<p><strong>Memory layout</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Initial state (capacity=4):\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”\nâ”‚  ?  â”‚  ?  â”‚  ?  â”‚  ?  â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜\n â†‘head                    â†‘tail\n count=0\n\nAfter enqueue(A), enqueue(B):\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”\nâ”‚  A  â”‚  B  â”‚  ?  â”‚  ?  â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜\n â†‘head       â†‘tail\n count=2\n\nAfter dequeue() â†’ returns A:\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”\nâ”‚  A  â”‚  B  â”‚  ?  â”‚  ?  â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜\n       â†‘head â†‘tail\n       count=1</code></pre></div>\n\n<h3 id=\"algorithm-breadth-first-search-bfs\">Algorithm: Breadth-First Search (BFS)</h3>\n<p><strong>Why BFS over DFS?</strong></p>\n<ul>\n<li><strong>Better cache locality</strong>: Process objects at same depth together (likely allocated together)</li>\n<li><strong>Predictable memory usage</strong>: Queue size = objects at current depth</li>\n<li><strong>Easier to parallelize</strong>: Multiple threads can steal from queue</li>\n</ul>\n<p><strong>The traversal loop</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>1. Clear all mark bits (everything starts &quot;white&quot;)\n2. Add all roots to work queue (roots become &quot;gray&quot;)\n3. While queue not empty:\n   a. Dequeue object\n   b. If already marked, skip (avoid duplicate work)\n   c. Mark object (becomes &quot;black&quot;)\n   d. Scan object for child pointers\n   e. For each child:\n      - If unmarked, enqueue it (becomes &quot;gray&quot;)\n4. Done! All reachable objects are marked</code></pre></div>\n\n<p>{{DIAGRAM:object-graph-traversal}}</p>\n<hr>\n<h2 id=\"the-microscope-effect-bit-level-marking\">The Microscope Effect: Bit-Level Marking</h2>\n<h3 id=\"the-mark-bit\">The Mark Bit</h3>\n<p><strong>Location</strong>: Inside the <code>ObjectHeader</code> (from previous sections):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">           // Bytes: 0-7</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> marked : </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">    // Bit 64 (1 bit)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> pinned : </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">    // Bit 65 (1 bit)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> type : </span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">      // Bits 66-71 (6 bits)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... padding to 16 bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ObjectHeader;</span></span></code></pre></div>\n\n<p><strong>Memory representation</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Object at 0x1000:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ size=64 (8 bytes)                      â”‚ 0x1000\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ marked=0, pinned=0, type=0 (1 byte)   â”‚ 0x1008\nâ”‚ padding (7 bytes)                      â”‚ 0x1009-0x100F\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ User data (64 bytes)                   â”‚ 0x1010-0x104F\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nAfter marking:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ size=64 (unchanged)                    â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ marked=1 â† CHANGED, pinned=0, type=0  â”‚\nâ”‚ padding (unchanged)                    â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ User data (unchanged)                  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></div>\n\n<p><strong>Atomic operations</strong> (for parallel GC):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Test-and-set: atomically check and mark</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> atomic_mark</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GCC/Clang builtin</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> !</span><span style=\"color:#B392F0\">__sync_lock_test_and_set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">header->marked, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Returns true if we were first to mark it</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"the-debugging-lab-common-pitfalls\">The Debugging Lab: Common Pitfalls</h2>\n<h3 id=\"bug-1-infinite-loop-cycle-not-detected\">Bug #1: Infinite Loop (Cycle Not Detected)</h3>\n<p><strong>Symptom</strong>: Mark phase never terminates, CPU at 100%.</p>\n<p><strong>Cause</strong>: Forgetting to check <code>if (marked) continue;</code></p>\n<p><strong>Bad code</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">queue</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    set_mark</span><span style=\"color:#E1E4E8\">(obj);</span><span style=\"color:#6A737D\">  // âš ï¸ No check if already marked!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scan_object</span><span style=\"color:#E1E4E8\">(gc, obj, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span><span style=\"color:#6A737D\">  // Re-enqueues children</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>What happens</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Cycle: A â†’ B â†’ C â†’ A\n\nIteration 1: Dequeue A, mark A, enqueue B\nIteration 2: Dequeue B, mark B, enqueue C\nIteration 3: Dequeue C, mark C, enqueue A  â† A already marked!\nIteration 4: Dequeue A, mark A, enqueue B  â† Infinite loop!</code></pre></div>\n\n<p><strong>Fix</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">queue</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (header->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        continue</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // âœ… Skip already-marked objects</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    scan_object</span><span style=\"color:#E1E4E8\">(gc, obj, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Debugging tip</strong>: Add a counter and assert it doesn&#39;t exceed total objects:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> iterations </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">queue</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(iterations</span><span style=\"color:#F97583\">++</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#E1E4E8\"> gc->total_objects </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Safety net</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"bug-2-stack-overflow-despite-iterative-algorithm\">Bug #2: Stack Overflow (Despite Iterative Algorithm!)</h3>\n<p><strong>Symptom</strong>: Segmentation fault in <code>scan_object()</code>.</p>\n<p><strong>Cause</strong>: <code>scan_object()</code> itself uses recursion!</p>\n<p><strong>Bad code</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scan_object</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">, WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Conservative scan: treat every word as potential pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)obj;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> words </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj)->size </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> words; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_valid_pointer</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">[i])) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // âš ï¸ Recursive call!</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            scan_object</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">[i], queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Only enqueue, don&#39;t recurse:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scan_object</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">, WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)obj;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> words </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj)->size </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> words; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_valid_pointer</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">[i])) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            enqueue</span><span style=\"color:#E1E4E8\">(queue, </span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">[i]);</span><span style=\"color:#6A737D\">  // âœ… Add to queue, don't recurse</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"bug-3-queue-overflow-out-of-memory\">Bug #3: Queue Overflow (Out of Memory)</h3>\n<p><strong>Symptom</strong>: <code>malloc()</code> fails in <code>enqueue()</code>, or program crashes.</p>\n<p><strong>Cause</strong>: Work queue grows unbounded on wide graphs.</p>\n<p><strong>Example</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Root object with 1 million children</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> root </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">1000000</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\"> children </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)root;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    children</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Mark phase enqueues all 1 million children at once!</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Queue size: 1,000,000 Ã— 8 bytes = 8 MB</span></span></code></pre></div>\n\n<p><strong>Fix #1</strong>: Set a maximum queue size:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_QUEUE_SIZE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // 1M objects</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> enqueue</span><span style=\"color:#E1E4E8\">(WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> queue, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> obj) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (queue</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">count </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> MAX_QUEUE_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Fall back to recursive marking for this object</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mark_recursive_limited</span><span style=\"color:#E1E4E8\">(obj, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Max depth 100</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Normal enqueue logic...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix #2</strong>: Use a <strong>deque</strong> (double-ended queue) and switch to DFS when queue is large:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (queue</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">count </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> THRESHOLD) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Pop from tail (DFS) instead of head (BFS)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pop_tail</span><span style=\"color:#E1E4E8\">(queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Normal BFS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"bug-4-false-negatives-objects-not-marked\">Bug #4: False Negatives (Objects Not Marked)</h3>\n<p><strong>Symptom</strong>: Live objects are collected, causing use-after-free crashes.</p>\n<p><strong>Cause</strong>: Missing a pointer during scanning.</p>\n<p><strong>Example</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> x;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> next;</span><span style=\"color:#6A737D\">  // Pointer at offset 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} Node;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scan_object</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">, WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // âš ï¸ Assumes pointers are at word boundaries!</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)obj;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> words </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj)->size </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> words; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Misses 'next' pointer if sizeof(void*) = 8 and x = 4 bytes!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Scan byte-by-byte for conservative GC:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scan_object</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">, WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t*</span><span style=\"color:#E1E4E8\"> bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)obj;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj)->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check every possible pointer location</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">); i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> potential </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)(bytes </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_valid_pointer</span><span style=\"color:#E1E4E8\">(gc, potential)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            enqueue</span><span style=\"color:#E1E4E8\">(queue, potential);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Debugging tip</strong>: Enable verbose logging:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Scanning object at </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\"> (size=</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, obj, </span><span style=\"color:#B392F0\">GET_HEADER</span><span style=\"color:#E1E4E8\">(obj)</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">size</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> words; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_valid_pointer</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">[i])) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Found pointer: </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\"> â†’ </span><span style=\"color:#79B8FF\">%p\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"code-scaffold-your-implementation-tasks\">Code Scaffold: Your Implementation Tasks</h2>\n<h3 id=\"task-1-work-queue-initialization\">Task 1: Work Queue Initialization</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_work_queue</span><span style=\"color:#E1E4E8\">(WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Allocate initial capacity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 256</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Start small, grow as needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->items </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(queue->capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (queue->items </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Failed to allocate work queue</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->head </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->tail </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Your task</strong>: Add error handling and consider initial capacity based on heap size.</p>\n<p><strong>Hint</strong>: For a 1 MB heap with 64-byte objects, expect ~16,000 objects. A good initial capacity is <code>sqrt(total_objects)</code> â‰ˆ 128.</p>\n<hr>\n<h3 id=\"task-2-enqueue-with-dynamic-growth\">Task 2: Enqueue with Dynamic Growth</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> enqueue</span><span style=\"color:#E1E4E8\">(WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if queue is full</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (queue->count </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> queue->capacity) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Grow queue (double capacity)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> new_capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> queue->capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void**</span><span style=\"color:#E1E4E8\"> new_items </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> realloc</span><span style=\"color:#E1E4E8\">(queue->items, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                   new_capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (new_items </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Work queue out of memory</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        queue->items </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_items;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        queue->capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_capacity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Work queue grew to </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, new_capacity);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add item at tail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->items[queue->tail] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> obj;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->tail </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (queue->tail </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> queue->capacity;</span><span style=\"color:#6A737D\">  // Circular buffer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Your task</strong>: Handle the circular buffer wrap-around correctly.</p>\n<p><strong>Tricky case</strong>: After realloc, if <code>head &gt; tail</code>, you need to unwrap:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Before realloc (capacity=4, head=2, tail=1):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// [C, D, A, B]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//       â†‘h  â†‘t</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// After realloc (capacity=8), need to move A,B to end:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// [C, D, ?, ?, ?, ?, A, B]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//       â†‘h              â†‘t</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"task-3-dequeue\">Task 3: Dequeue</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if empty</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (queue->count </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Remove item from head</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> queue->items[queue->head];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->head </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (queue->head </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> queue->capacity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    queue->count</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> obj;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Your task</strong>: Add assertions to catch bugs:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(queue</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">count </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> queue</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">capacity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(queue</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">head </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> queue</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">capacity</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(queue</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">tail </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> queue</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">capacity</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"task-4-object-scanning-conservative\">Task 4: Object Scanning (Conservative)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scan_object</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">, WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Scanning object at </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\"> (size=</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, obj, header->size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Treat object as array of potential pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)obj;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> words </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> header->size </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> words; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> potential </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">[i];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Check if this looks like a valid pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_valid_pointer</span><span style=\"color:#E1E4E8\">(gc, potential)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Found pointer: </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\"> â†’ </span><span style=\"color:#79B8FF\">%p\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">ptr</span><span style=\"color:#E1E4E8\">[i], potential);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Enqueue child object</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            enqueue</span><span style=\"color:#E1E4E8\">(queue, potential);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Your task</strong>: Implement <code>is_valid_pointer()</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_valid_pointer</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Quick reject - NULL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Quick reject - not in heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->heap_start </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> gc->heap_end) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Quick reject - not aligned</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)ptr </span><span style=\"color:#F97583\">%</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Expensive check - valid object header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Walk free list and allocated list to confirm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (Implementation depends on your heap structure)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Optimization</strong>: Maintain a <strong>bitmap</strong> of valid object starts:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// 1 bit per 8-byte word in heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\"> object_bitmap </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> calloc</span><span style=\"color:#E1E4E8\">(heap_size </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// When allocating:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">set_bit</span><span style=\"color:#E1E4E8\">(object_bitmap, (ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> heap_start) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// When checking:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_valid_pointer</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> gc->heap_start) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> get_bit</span><span style=\"color:#E1E4E8\">(gc->object_bitmap, offset);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"task-5-main-traversal-loop\">Task 5: Main Traversal Loop</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> traverse_graph</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, WorkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> queue</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> objects_marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_empty</span><span style=\"color:#E1E4E8\">(queue)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Get object header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Skip if already marked (cycle detection)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (header->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Mark object</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        header->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        objects_marked</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bytes_marked </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Marked object </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\"> (size=</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">, total=</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               obj, header->size, objects_marked);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Scan for children</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        scan_object</span><span style=\"color:#E1E4E8\">(gc, obj, queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.marked_objects </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> objects_marked;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.marked_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> bytes_marked;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Your task</strong>: Add a <strong>progress indicator</strong> for large heaps:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (objects_marked </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Marked </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> objects (</span><span style=\"color:#79B8FF\">%.1f</span><span style=\"color:#9ECBFF\"> MB)...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           objects_marked, bytes_marked </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1024.0</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 1024.0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"visual-reference\">Visual Reference</h2>\n<p>{{DIAGRAM:work-queue-states}}</p>\n<p><strong>Queue states during traversal</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Graph: A â†’ B â†’ C\n       A â†’ D\n\nStep 1: Enqueue roots\nQueue: [A]\nMarked: {}\n\nStep 2: Dequeue A, mark A, enqueue children\nQueue: [B, D]\nMarked: {A}\n\nStep 3: Dequeue B, mark B, enqueue children\nQueue: [D, C]\nMarked: {A, B}\n\nStep 4: Dequeue D, mark D (no children)\nQueue: [C]\nMarked: {A, B, D}\n\nStep 5: Dequeue C, mark C (no children)\nQueue: []\nMarked: {A, B, C, D}\n\nDone!</code></pre></div>\n\n<hr>\n<h2 id=\"advanced-tri-color-invariant\">Advanced: Tri-Color Invariant</h2>\n<p><strong>The abstraction</strong>:</p>\n<ul>\n<li><strong>White</strong>: Unmarked (not yet discovered)</li>\n<li><strong>Gray</strong>: Marked but not scanned (in work queue)</li>\n<li><strong>Black</strong>: Marked and scanned (fully processed)</li>\n</ul>\n<p><strong>The invariant</strong>: No black object points to a white object.</p>\n<p><strong>Why it matters</strong>: Enables <strong>incremental GC</strong> â€” pause between objects without losing correctness.</p>\n<p><strong>Implementation</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> { WHITE, GRAY, BLACK } Color;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_incremental</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> max_objects</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> processed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">gc->work_queue) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> processed </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> max_objects) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">gc->work_queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Object is GRAY (in queue)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">get_color</span><span style=\"color:#E1E4E8\">(obj) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> GRAY);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Scan children</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (each child) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">get_color</span><span style=\"color:#E1E4E8\">(child) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> WHITE) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                set_color</span><span style=\"color:#E1E4E8\">(child, GRAY);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                enqueue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">gc->work_queue, child);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Object is now BLACK (fully scanned)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        set_color</span><span style=\"color:#E1E4E8\">(obj, BLACK);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        processed</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Pause here! Resume later.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"what-you39ve-mastered\">What You&#39;ve Mastered</h2>\n<p>âœ… <strong>Iterative graph traversal</strong> using explicit work queues<br>âœ… <strong>Cycle detection</strong> via mark bits<br>âœ… <strong>Conservative pointer scanning</strong> without type information<br>âœ… <strong>Dynamic queue management</strong> with growth and bounds checking<br>âœ… <strong>Debugging techniques</strong> for infinite loops and missing objects<br>âœ… <strong>Performance considerations</strong> for cache locality and parallelism<br>âœ… <strong>Tri-color abstraction</strong> for incremental collection  </p>\n<hr>\n<h2 id=\"next-challenge\">Next Challenge</h2>\n<p>Now that you can traverse the object graph, the next step is <strong>reclaiming memory</strong>:</p>\n<p><strong><a href=\"#sweep-engine\">â†’ Sweep Phase</a></strong>: Walk the heap, free unmarked objects, and rebuild the free list.</p>\n<p><strong>Before you continue</strong>, verify your implementation passes all tests:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> ./test_mark_phase</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Linear</span><span style=\"color:#9ECBFF\"> chain</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Cycle</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Unreachable</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Deep</span><span style=\"color:#9ECBFF\"> graph</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span><span style=\"color:#E1E4E8\"> (10,000 </span><span style=\"color:#9ECBFF\">nodes</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Wide</span><span style=\"color:#9ECBFF\"> graph</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span><span style=\"color:#E1E4E8\"> (1,000 </span><span style=\"color:#9ECBFF\">children</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Mark</span><span style=\"color:#9ECBFF\"> statistics</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span></code></pre></div>\n\n<p><strong>Pro challenge</strong>: Implement <strong>parallel marking</strong> with work-stealing queues. Hint: Use <code>pthread</code> or OpenMP, and make mark bits atomic.</p>\n<hr>\n<p><a href=\"#satellite-map\">â†‘ Back to System Map</a></p>\n<div id=\"ms-sweep-phase\"></div>\n\n<h1 id=\"sweep-phase-implementation-the-memory-reclamation-engine\">Sweep Phase Implementation: The Memory Reclamation Engine</h1>\n<h2 id=\"the-epiphany-analogy-the-post-party-cleanup\">The Epiphany Analogy: The Post-Party Cleanup</h2>\n<p>Imagine you just hosted a massive party in a warehouse. During the party, you walked around with a roll of <strong>green stickers</strong>, marking every piece of furniture that guests were actively using (the mark phase). Now the party&#39;s over, and you&#39;re left with a warehouse full of itemsâ€”some with green stickers, some without.</p>\n<p><strong>The sweep phase is your cleanup crew</strong>:</p>\n<ul>\n<li>Walk through the <em>entire warehouse</em> systematically (every square foot)</li>\n<li>If you find furniture <strong>without a green sticker</strong>, haul it to the dumpster (free it)</li>\n<li>If you find furniture <strong>with a green sticker</strong>, peel off the sticker and leave it in place (unmark for next time)</li>\n<li>As you clear space, update your <strong>&quot;available space&quot; map</strong> so you know where to put new furniture tomorrow</li>\n</ul>\n<p><strong>Key insight</strong>: Unlike the mark phase (which only visits <em>reachable</em> objects), the sweep phase must visit <strong>every object in the heap</strong>â€”both alive and dead. This is why sweep is typically O(heap_size), not O(live_objects).</p>\n<hr>\n<h2 id=\"technical-rationale-why-we-need-sweep\">Technical Rationale: Why We Need Sweep</h2>\n<h3 id=\"the-problem-fragmented-knowledge\">The Problem: Fragmented Knowledge</h3>\n<p>After marking, we know which objects are <strong>alive</strong> (marked), but we don&#39;t know:</p>\n<ol>\n<li><strong>Where the dead objects are</strong> (they weren&#39;t visited during marking)</li>\n<li><strong>How much memory we can reclaim</strong> (total size of unmarked objects)</li>\n<li><strong>How to allocate new objects</strong> (the free list is stale)</li>\n</ol>\n<h3 id=\"the-solution-linear-heap-scan\">The Solution: Linear Heap Scan</h3>\n<p>The sweep phase performs a <strong>single linear pass</strong> through the entire heap:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Heap Layout After Mark Phase:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [A:marked] [B:unmarked] [C:marked] [D:unmarked] [E:marked] â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n  â†‘ Keep      â†‘ Free       â†‘ Keep      â†‘ Free       â†‘ Keep\n\nAfter Sweep:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [A:live] [FREE] [C:live] [FREE] [E:live]                â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n           â†“         â†“\n    Free List: [B] â†’ [D] â†’ NULL</code></pre></div>\n\n<p><strong>Why linear scan?</strong> Because we don&#39;t have a &quot;list of all objects&quot;â€”objects are scattered throughout the heap. The only way to find them all is to walk memory sequentially.</p>\n<hr>\n<h2 id=\"internal-mechanics-the-sweep-algorithm\">Internal Mechanics: The Sweep Algorithm</h2>\n<h3 id=\"core-data-structures\">Core Data Structures</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> FreeBlock {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">              // Size of this free block</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span><span style=\"color:#6A737D\">   // Next free block (sorted by address)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} FreeBlock;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> free_list_head;</span><span style=\"color:#6A737D\">  // Start of free list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_free;</span><span style=\"color:#6A737D\">          // Total free bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> largest_free;</span><span style=\"color:#6A737D\">        // Largest contiguous block</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> objects_freed;</span><span style=\"color:#6A737D\">       // Statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_freed;</span><span style=\"color:#6A737D\">         // Statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SweepResult;</span></span></code></pre></div>\n\n<h3 id=\"the-sweep-state-machine\">The Sweep State Machine</h3>\n<p>Each object in the heap is in one of three states:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SWEEP_STATE_ALIVE,</span><span style=\"color:#6A737D\">      // Marked â†’ keep and unmark</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SWEEP_STATE_DEAD,</span><span style=\"color:#6A737D\">       // Unmarked â†’ free</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SWEEP_STATE_FREE</span><span style=\"color:#6A737D\">        // Already in free list â†’ coalesce</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SweepState;</span></span></code></pre></div>\n\n<h3 id=\"the-algorithm-pseudocode\">The Algorithm (Pseudocode)</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>function sweep(gc):\n    current = gc.heap_start\n    free_list = NULL\n    \n    while current &lt; gc.heap_end:\n        header = get_header(current)\n        \n        if header.marked:\n            // Object is alive\n            header.marked = false  // Unmark for next GC\n            current += sizeof(header) + header.size\n        else:\n            // Object is dead - convert to free block\n            free_block = (FreeBlock*)current\n            free_block.size = sizeof(header) + header.size\n            \n            // Try to coalesce with next block\n            next = current + free_block.size\n            while next &lt; heap_end AND is_free(next):\n                free_block.size += get_size(next)\n                next += get_size(next)\n            \n            // Add to free list\n            free_block.next = free_list\n            free_list = free_block\n            \n            current = next\n    \n    gc.free_list = free_list</code></pre></div>\n\n<p><strong>Critical detail</strong>: We must distinguish between:</p>\n<ul>\n<li><strong>Dead objects</strong> (unmarked allocations)</li>\n<li><strong>Free blocks</strong> (already in the free list from previous sweeps)</li>\n</ul>\n<hr>\n<h2 id=\"the-debugging-lab-common-sweep-bugs\">The Debugging Lab: Common Sweep Bugs</h2>\n<h3 id=\"bug-1-double-free-freeing-already-free-memory\">Bug #1: Double-Free (Freeing Already-Free Memory)</h3>\n<p><strong>Symptom</strong>: Heap corruption, overlapping allocations, crashes.</p>\n<p><strong>Cause</strong>: Treating a free block as a dead object.</p>\n<p><strong>Example</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Heap state:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// [A:marked] [FREE_BLOCK] [B:unmarked]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sweep</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->heap_end) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">header->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // âš ï¸ BUG: FREE_BLOCK has garbage in header->marked!</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            free_object</span><span style=\"color:#E1E4E8\">(ptr);</span><span style=\"color:#6A737D\">  // Double-free!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix #1</strong>: Use a <strong>magic number</strong> to identify free blocks:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FREE_BLOCK_MAGIC</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">DEADBEEF</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> FreeBlock {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> magic;</span><span style=\"color:#6A737D\">  // Always FREE_BLOCK_MAGIC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} FreeBlock;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_free_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> block->magic </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix #2</strong>: Use a <strong>separate bit</strong> in the header:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size : </span><span style=\"color:#79B8FF\">62</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#E1E4E8\"> marked : </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#E1E4E8\"> is_free : </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Set when added to free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ObjectHeader;</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"bug-2-lost-free-blocks-memory-leak\">Bug #2: Lost Free Blocks (Memory Leak)</h3>\n<p><strong>Symptom</strong>: Heap appears full even after GC, allocation fails.</p>\n<p><strong>Cause</strong>: Forgetting to add freed objects to the free list.</p>\n<p><strong>Example</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sweep</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->heap_end) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">header->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // âš ï¸ BUG: We mark it as free but don't link it!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            header->is_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Missing: add_to_free_list(gc, ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Always link freed blocks:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">header</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">marked </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">header</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">is_free) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add to front of free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.bytes_freed </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"bug-3-fragmentation-explosion\">Bug #3: Fragmentation Explosion</h3>\n<p><strong>Symptom</strong>: Allocation fails even though total free space is sufficient.</p>\n<p><strong>Cause</strong>: Not coalescing adjacent free blocks.</p>\n<p><strong>Example</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Before Sweep:\n[A:marked] [B:unmarked] [C:unmarked] [D:marked]\n\nAfter Sweep (without coalescing):\n[A:live] [FREE:64] [FREE:64] [D:live]\n\nFree List: [B:64] â†’ [C:64] â†’ NULL\n\nAllocation Request: 100 bytes\nResult: FAIL (no single block is large enough!)</code></pre></div>\n\n<p><strong>Fix</strong>: Coalesce during sweep:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sweep_with_coalescing</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->heap_end) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (header->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            header->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Start of a free region</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            void*</span><span style=\"color:#E1E4E8\"> free_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ptr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            size_t</span><span style=\"color:#E1E4E8\"> free_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Accumulate all adjacent dead objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            while</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->heap_end) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (header->marked) </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                size_t</span><span style=\"color:#E1E4E8\"> obj_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                free_size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> obj_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> obj_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Create one large free block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)free_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            block->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> free_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"bug-4-incorrect-size-calculation\">Bug #4: Incorrect Size Calculation</h3>\n<p><strong>Symptom</strong>: Heap corruption, allocations overlap, crashes.</p>\n<p><strong>Cause</strong>: Forgetting to include the header size when calculating block sizes.</p>\n<p><strong>Example</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sweep</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">header->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> header->size;</span><span style=\"color:#6A737D\">  // âš ï¸ BUG: Missing header size!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Next iteration:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size;</span><span style=\"color:#6A737D\">  // Skips into middle of next object!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Always account for metadata:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">block</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> total_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> total_size;</span></span></code></pre></div>\n\n<p><strong>Debugging tip</strong>: Add assertions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(ptr </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">heap_start</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">heap_end</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(total_size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(total_size </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">heap_size</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"visual-reference\">Visual Reference</h2>\n<p>{{DIAGRAM:sweep-process}}</p>\n<p><strong>Sweep process visualization</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Initial Heap (after mark):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [H][A:M] [H][B:U] [H][C:M] [H][D:U] [H][E:U] [H][F:M] â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n  â†‘        â†‘        â†‘        â†‘        â†‘        â†‘\n  Keep     Free     Keep     Free     Free     Keep\n\nLegend: [H]=Header, M=Marked, U=Unmarked\n\nStep 1: Scan A (marked)\nAction: Unmark, advance pointer\nResult: [H][A] ...\n\nStep 2: Scan B (unmarked)\nAction: Convert to free block\nResult: [H][A] [FREE:B] ...\n\nStep 3: Scan C (marked)\nAction: Unmark, advance pointer\nResult: [H][A] [FREE:B] [H][C] ...\n\nStep 4: Scan D (unmarked)\nAction: Start coalescing\nResult: [H][A] [FREE:B] [H][C] [FREE:D+E] ...\n                                 â†‘ Coalesced!\n\nStep 5: Scan F (marked)\nAction: Unmark, advance pointer\nResult: [H][A] [FREE:B] [H][C] [FREE:D+E] [H][F]\n\nFinal Free List (sorted by address):\n[FREE:B] â†’ [FREE:D+E] â†’ NULL</code></pre></div>\n\n<hr>\n<h2 id=\"code-scaffold-your-implementation-tasks\">Code Scaffold: Your Implementation Tasks</h2>\n<h3 id=\"task-1-basic-sweep-loop\">Task 1: Basic Sweep Loop</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">SweepResult </span><span style=\"color:#B392F0\">sweep_heap</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SweepResult result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Starting sweep phase...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Heap range: </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\"> - </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           gc->heap_start, gc->heap_end, gc->heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->heap_end) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Get object header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Calculate total size (header + payload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Check if this is already a free block</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_free_block</span><span style=\"color:#E1E4E8\">(ptr)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Skip free blocks from previous sweeps</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Check mark bit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (header->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Object is alive - unmark for next GC</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            header->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Kept object at </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\"> (size=</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ptr, header->size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> total_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Object is dead - free it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Freeing object at </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\"> (size=</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ptr, header->size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Convert to free block (Task 2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_free_block</span><span style=\"color:#E1E4E8\">(ptr, total_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Add to free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Update statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result.objects_freed</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result.bytes_freed </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> total_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> total_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Sort free list by address (Task 4)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result.free_list_head </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> sort_free_list</span><span style=\"color:#E1E4E8\">(free_list);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate statistics (Task 5)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    calculate_free_stats</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">result);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Your task</strong>: Add boundary checks:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(ptr </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">heap_start </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">heap_end</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(total_size </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> total_size </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">heap_size</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"task-2-free-block-creation\">Task 2: Free Block Creation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> create_free_block</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (size </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Block too small: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes at </span><span style=\"color:#79B8FF\">%p\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, size, ptr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize free block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Fill with debug pattern</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t*</span><span style=\"color:#E1E4E8\"> payload </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)(block </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> payload_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(payload, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">DD</span><span style=\"color:#E1E4E8\">, payload_size);</span><span style=\"color:#6A737D\">  // 0xDD = \"dead data\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Your task</strong>: Handle minimum block size:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MIN_BLOCK_SIZE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // 16 bytes minimum payload</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (size </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> MIN_BLOCK_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Too small to be useful - mark as padding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PaddingBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> padding </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (PaddingBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    padding</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PADDING_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    padding</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Don't add to free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"task-3-coalescing-adjacent-blocks\">Task 3: Coalescing Adjacent Blocks</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> coalesce_blocks</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> start_ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> start_ptr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Accumulate all adjacent dead/free blocks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->heap_end) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if this block can be coalesced</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_free_block</span><span style=\"color:#E1E4E8\">(ptr)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Already free - include it</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            total_size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">header->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Dead object - include it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            size_t</span><span style=\"color:#E1E4E8\"> obj_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            total_size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> obj_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> obj_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Live object - stop coalescing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create one large free block</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (total_size </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> create_free_block</span><span style=\"color:#E1E4E8\">(start_ptr, total_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Your task</strong>: Integrate coalescing into sweep:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">header</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">marked) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Try to coalesce with following blocks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> coalesce_blocks</span><span style=\"color:#E1E4E8\">(gc, ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.bytes_freed </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.objects_freed</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Count as one coalesced block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size;</span><span style=\"color:#6A737D\">  // Skip entire coalesced region</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"task-4-sorting-the-free-list\">Task 4: Sorting the Free List</h3>\n<p><strong>Why sort?</strong> Sorted free lists enable:</p>\n<ul>\n<li><strong>First-fit allocation</strong> (find first block large enough)</li>\n<li><strong>Best-fit allocation</strong> (find smallest block that fits)</li>\n<li><strong>Address-ordered coalescing</strong> (merge adjacent blocks efficiently)</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> sort_free_list</span><span style=\"color:#E1E4E8\">(FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> head</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (head </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> head->next </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> head;</span><span style=\"color:#6A737D\">  // Already sorted</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Convert to array for sorting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> head; b </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">; b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> blocks </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(count </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> head; b </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">; b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b->next) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        blocks</span><span style=\"color:#E1E4E8\">[i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Sort by address</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    qsort</span><span style=\"color:#E1E4E8\">(blocks, count, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">), compare_blocks);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Rebuild linked list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        blocks</span><span style=\"color:#E1E4E8\">[i]->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> blocks</span><span style=\"color:#E1E4E8\">[i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    blocks</span><span style=\"color:#E1E4E8\">[count </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">]->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> sorted_head </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> blocks</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(blocks);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> sorted_head;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> compare_blocks</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#FFAB70\"> a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#FFAB70\"> b</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block_a </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">(FreeBlock</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">)a;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block_b </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">(FreeBlock</span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">)b;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block_a </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> block_b) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block_a </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> block_b) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Your task</strong>: Optimize for already-sorted lists:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_sorted</span><span style=\"color:#E1E4E8\">(FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> head</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> head; b </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> b->next </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">; b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b->next) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (b </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> b->next) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Out of order</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> sort_free_list</span><span style=\"color:#E1E4E8\">(FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> head</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_sorted</span><span style=\"color:#E1E4E8\">(head)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> head;</span><span style=\"color:#6A737D\">  // Fast path</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Slow path: full sort</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"task-5-statistics-calculation\">Task 5: Statistics Calculation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> calculate_free_stats</span><span style=\"color:#E1E4E8\">(SweepResult</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> result</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result->total_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result->largest_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> block_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> result->free_list_head; </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         block </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">; </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Validate block</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(block->magic </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(block->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Accumulate totals</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result->total_free </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Track largest block</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (block->size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> result->largest_free) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result->largest_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Sweep complete:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Objects freed: </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, result->objects_freed);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Bytes freed: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> MB)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           result->bytes_freed, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           result->bytes_freed </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1024.0</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 1024.0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Free blocks: </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, block_count);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Total free: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> MB)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           result->total_free,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           result->total_free </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1024.0</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 1024.0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Largest block: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, result->largest_free);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Fragmentation: </span><span style=\"color:#79B8FF\">%.2f%%\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">           100.0</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)result->largest_free </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> result->total_free));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Your task</strong>: Add fragmentation metrics:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> block_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_free;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> largest_free;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> avg_block_size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> fragmentation_ratio;</span><span style=\"color:#6A737D\">  // 0.0 = no fragmentation, 1.0 = worst</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} FragmentationStats;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FragmentationStats </span><span style=\"color:#B392F0\">analyze_fragmentation</span><span style=\"color:#E1E4E8\">(FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> head</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FragmentationStats stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> head; b </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">; b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stats.block_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stats.total_free </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> b->size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (b->size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> stats.largest_free) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stats.largest_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (stats.block_count </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stats.avg_block_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)stats.total_free </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> stats.block_count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (stats.total_free </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Fragmentation = 1 - (largest / total)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stats.fragmentation_ratio </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ((</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)stats.largest_free </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> stats.total_free);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> stats;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"advanced-lazy-sweeping\">Advanced: Lazy Sweeping</h2>\n<p><strong>The problem</strong>: Sweeping the entire heap is slow (O(heap_size)).</p>\n<p><strong>The solution</strong>: Sweep incrementally during allocation.</p>\n<h3 id=\"lazy-sweep-algorithm\">Lazy Sweep Algorithm</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> sweep_ptr;</span><span style=\"color:#6A737D\">        // Current position in heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> sweep_complete;</span><span style=\"color:#6A737D\">    // Have we swept everything?</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} LazySweepState;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> allocate_with_lazy_sweep</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Try to allocate from existing free list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> try_allocate</span><span style=\"color:#E1E4E8\">(gc->free_list, size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // No suitable block - sweep more of the heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> objects_swept </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#E1E4E8\"> MAX_SWEEP_PER_ALLOC </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (objects_swept </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> MAX_SWEEP_PER_ALLOC </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           !</span><span style=\"color:#E1E4E8\">gc->lazy_sweep.sweep_complete) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> sweep_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->lazy_sweep.sweep_ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (sweep_ptr </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> gc->heap_end) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            gc->lazy_sweep.sweep_complete </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(sweep_ptr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> obj_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">header->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Found a dead object - free it</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_free_block</span><span style=\"color:#E1E4E8\">(sweep_ptr, obj_size);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            add_to_free_list</span><span style=\"color:#E1E4E8\">(gc, block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Try allocation again</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> try_allocate</span><span style=\"color:#E1E4E8\">(gc->free_list, size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            header->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Unmark for next GC</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->lazy_sweep.sweep_ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> obj_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        objects_swept</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Still no memory - trigger full GC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        full_gc</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> try_allocate</span><span style=\"color:#E1E4E8\">(gc->free_list, size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Benefits</strong>:</p>\n<ul>\n<li><strong>Lower pause times</strong> (spread work across allocations)</li>\n<li><strong>Better cache locality</strong> (sweep near recent allocations)</li>\n<li><strong>Adaptive</strong> (sweep more when memory is tight)</li>\n</ul>\n<p><strong>Tradeoffs</strong>:</p>\n<ul>\n<li><strong>Allocation is slower</strong> (must sweep before allocating)</li>\n<li><strong>More complex</strong> (must track sweep state)</li>\n<li><strong>Fragmentation</strong> (can&#39;t coalesce until sweep reaches that region)</li>\n</ul>\n<hr>\n<h2 id=\"advanced-parallel-sweeping\">Advanced: Parallel Sweeping</h2>\n<p><strong>The challenge</strong>: Sweep is embarrassingly parallel (each region is independent), but free list updates require synchronization.</p>\n<h3 id=\"parallel-sweep-with-thread-local-free-lists\">Parallel Sweep with Thread-Local Free Lists</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> local_free_list;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_freed;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> objects_freed;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ThreadSweepResult;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> parallel_sweep</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> num_threads</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ThreadSweepResult</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> results </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> calloc</span><span style=\"color:#E1E4E8\">(num_threads, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(ThreadSweepResult));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Divide heap into regions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> region_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_size </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> num_threads;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #pragma</span><span style=\"color:#B392F0\"> omp</span><span style=\"color:#B392F0\"> parallel</span><span style=\"color:#B392F0\"> for</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_threads; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> region_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> region_size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> region_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> num_threads </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           gc->heap_end </span><span style=\"color:#F97583\">:</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           region_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> region_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Sweep this region independently</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        results</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> sweep_region</span><span style=\"color:#E1E4E8\">(gc, region_start, region_end);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Merge thread-local free lists</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> merged_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_threads; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        merged_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> merge_free_lists</span><span style=\"color:#E1E4E8\">(merged_list, </span><span style=\"color:#FFAB70\">results</span><span style=\"color:#E1E4E8\">[i].local_free_list);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> sort_free_list</span><span style=\"color:#E1E4E8\">(merged_list);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(results);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Key insight</strong>: Each thread builds its own free list, then we merge at the end. No locks needed during sweep!</p>\n<hr>\n<h2 id=\"what-you39ve-mastered\">What You&#39;ve Mastered</h2>\n<p>âœ… <strong>Linear heap scanning</strong> to find all objects (alive and dead)<br>âœ… <strong>Free block management</strong> with magic numbers and size tracking<br>âœ… <strong>Coalescing</strong> to reduce fragmentation<br>âœ… <strong>Free list sorting</strong> for efficient allocation<br>âœ… <strong>Statistics collection</strong> for performance monitoring<br>âœ… <strong>Lazy sweeping</strong> for lower pause times<br>âœ… <strong>Parallel sweeping</strong> for multi-core performance  </p>\n<hr>\n<h2 id=\"testing-your-implementation\">Testing Your Implementation</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_sweep_phase</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 1 MB heap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate some objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> d </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark only A and C as reachable</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GET_HEADER</span><span style=\"color:#E1E4E8\">(a)->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GET_HEADER</span><span style=\"color:#E1E4E8\">(c)->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sweep</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SweepResult result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> sweep_heap</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify results</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(result.objects_freed </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // B and D</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(result.bytes_freed </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 128</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 256</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(result.free_list_head </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify marks were cleared</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">GET_HEADER</span><span style=\"color:#E1E4E8\">(a)->marked);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">GET_HEADER</span><span style=\"color:#E1E4E8\">(c)->marked);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify we can allocate from freed space</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> e </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(e </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Sweep phase test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Additional tests</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> ./test_sweep</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Basic</span><span style=\"color:#9ECBFF\"> sweep</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Coalescing</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span><span style=\"color:#E1E4E8\"> (3 </span><span style=\"color:#9ECBFF\">adjacent</span><span style=\"color:#9ECBFF\"> blocks</span><span style=\"color:#9ECBFF\"> â†’</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Fragmentation</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span><span style=\"color:#E1E4E8\"> (10% </span><span style=\"color:#9ECBFF\">fragmentation</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Large</span><span style=\"color:#9ECBFF\"> heap</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span><span style=\"color:#E1E4E8\"> (100 </span><span style=\"color:#9ECBFF\">MB,</span><span style=\"color:#9ECBFF\"> 1M</span><span style=\"color:#9ECBFF\"> objects</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Lazy</span><span style=\"color:#9ECBFF\"> sweep</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span><span style=\"color:#E1E4E8\"> (allocation </span><span style=\"color:#9ECBFF\">during</span><span style=\"color:#9ECBFF\"> sweep</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Parallel</span><span style=\"color:#9ECBFF\"> sweep</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span><span style=\"color:#E1E4E8\"> (4 </span><span style=\"color:#9ECBFF\">threads,</span><span style=\"color:#9ECBFF\"> 2x</span><span style=\"color:#9ECBFF\"> speedup</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-benchmarks\">Performance Benchmarks</h2>\n<p><strong>Expected performance</strong> (1 GHz CPU, 1 MB heap):</p>\n<table>\n<thead>\n<tr>\n<th>Heap Occupancy</th>\n<th>Objects</th>\n<th>Sweep Time</th>\n<th>Throughput</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>10% (sparse)</td>\n<td>1,600</td>\n<td>0.5 ms</td>\n<td>2 GB/s</td>\n</tr>\n<tr>\n<td>50% (typical)</td>\n<td>8,000</td>\n<td>2.0 ms</td>\n<td>500 MB/s</td>\n</tr>\n<tr>\n<td>90% (dense)</td>\n<td>14,400</td>\n<td>4.0 ms</td>\n<td>250 MB/s</td>\n</tr>\n</tbody></table>\n<p><strong>Optimization tips</strong>:</p>\n<ol>\n<li><strong>Cache-friendly scanning</strong>: Process 64-byte cache lines at a time</li>\n<li><strong>Prefetching</strong>: <code>__builtin_prefetch(ptr + 64)</code> before accessing</li>\n<li><strong>SIMD</strong>: Use vector instructions to check multiple mark bits</li>\n<li><strong>Huge pages</strong>: Reduce TLB misses for large heaps</li>\n</ol>\n<hr>\n<h2 id=\"next-challenge\">Next Challenge</h2>\n<p>You&#39;ve now implemented a complete <strong>mark-and-sweep garbage collector</strong>! ğŸ‰</p>\n<p><strong>What&#39;s next?</strong></p>\n<ol>\n<li><strong><a href=\"#allocation-strategies\">â†’ Allocation Strategies</a></strong>: Implement first-fit, best-fit, and segregated free lists</li>\n<li><strong><a href=\"#generational-gc\">â†’ Generational GC</a></strong>: Optimize for &quot;most objects die young&quot;</li>\n<li><strong><a href=\"#compaction\">â†’ Compaction</a></strong>: Eliminate fragmentation by moving objects</li>\n<li><strong><a href=\"#concurrent-gc\">â†’ Concurrent GC</a></strong>: Collect garbage while the program runs</li>\n</ol>\n<p><strong>Before you continue</strong>, verify your full GC works end-to-end:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> ./test_full_gc</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Root</span><span style=\"color:#9ECBFF\"> scanning</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Mark</span><span style=\"color:#9ECBFF\"> phase</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Sweep</span><span style=\"color:#9ECBFF\"> phase</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Full</span><span style=\"color:#9ECBFF\"> GC</span><span style=\"color:#9ECBFF\"> cycle</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Multiple</span><span style=\"color:#9ECBFF\"> GC</span><span style=\"color:#9ECBFF\"> cycles</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span><span style=\"color:#E1E4E8\"> (10 </span><span style=\"color:#9ECBFF\">cycles</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Stress</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span><span style=\"color:#E1E4E8\"> (1M </span><span style=\"color:#9ECBFF\">allocations,</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#9ECBFF\"> GC</span><span style=\"color:#9ECBFF\"> cycles</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<hr>\n<p><a href=\"#satellite-map\">â†‘ Back to System Map</a></p>\n<div id=\"ms-gc-trigger\"></div>\n\n<h1 id=\"collection-trigger-logic\">Collection Trigger Logic</h1>\n<h2 id=\"epiphany-analogy-the-smart-thermostat\">Epiphany Analogy: The Smart Thermostat</h2>\n<p>Imagine your home&#39;s heating system. A <strong>dumb thermostat</strong> turns on the heat at a fixed temperature (say, 68Â°F) every time. But a <strong>smart thermostat</strong> learns your patterns:</p>\n<ul>\n<li>It knows you wake up at 7 AM, so it pre-heats at 6:45 AM</li>\n<li>It detects when you&#39;re away and delays heating</li>\n<li>It monitors how quickly the house cools down and adjusts timing</li>\n<li>It triggers emergency heating if temperature drops dangerously low</li>\n</ul>\n<p><strong>Your GC trigger logic is the smart thermostat for memory</strong>. It must answer: <em>&quot;When should I pause the world and collect garbage?&quot;</em></p>\n<p>Too aggressive â†’ wasted CPU cycles collecting when memory is plentiful<br>Too passive â†’ out-of-memory crashes when allocation spikes  </p>\n<p>The art is in <strong>predicting memory pressure</strong> before it becomes critical.</p>\n<hr>\n<h2 id=\"technical-rationale-why-trigger-logic-matters\">Technical Rationale: Why Trigger Logic Matters</h2>\n<h3 id=\"the-fundamental-tradeoff\">The Fundamental Tradeoff</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  GC Frequency vs. Performance                   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                                 â”‚\nâ”‚  Frequent GC:                                   â”‚\nâ”‚    âœ“ Low memory footprint                       â”‚\nâ”‚    âœ“ Predictable pauses                         â”‚\nâ”‚    âœ— High CPU overhead (50%+ wasted)            â”‚\nâ”‚    âœ— Poor cache locality                        â”‚\nâ”‚                                                 â”‚\nâ”‚  Rare GC:                                       â”‚\nâ”‚    âœ“ Low CPU overhead (5-10%)                   â”‚\nâ”‚    âœ“ Better cache locality                      â”‚\nâ”‚    âœ— Large memory footprint                     â”‚\nâ”‚    âœ— Long pause times (100ms+)                  â”‚\nâ”‚    âœ— Risk of OOM crashes                        â”‚\nâ”‚                                                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></div>\n\n<p><strong>The goal</strong>: Trigger GC <em>just before</em> memory becomes critically low, but <em>not so often</em> that we waste CPU.</p>\n<h3 id=\"real-world-consequences\">Real-World Consequences</h3>\n<p><strong>Case Study: Web Server</strong></p>\n<ul>\n<li><strong>Too frequent GC</strong>: 200 req/sec â†’ 120 req/sec (40% throughput loss)</li>\n<li><strong>Too rare GC</strong>: Sudden 500ms pause â†’ dropped connections</li>\n<li><strong>Optimal GC</strong>: Trigger during request gaps, maintain 195 req/sec</li>\n</ul>\n<p><strong>Case Study: Game Engine</strong></p>\n<ul>\n<li><strong>Too frequent GC</strong>: 60 FPS â†’ 45 FPS (stuttering)</li>\n<li><strong>Too rare GC</strong>: 200ms pause â†’ visible frame drop</li>\n<li><strong>Optimal GC</strong>: Trigger during level loads, maintain 60 FPS</li>\n</ul>\n<hr>\n<h2 id=\"internal-mechanics-trigger-heuristics\">Internal Mechanics: Trigger Heuristics</h2>\n<h3 id=\"strategy-1-heap-occupancy-threshold\">Strategy 1: Heap Occupancy Threshold</h3>\n<p><strong>The simplest approach</strong>: Trigger GC when heap is X% full.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> heap_size;</span><span style=\"color:#6A737D\">           // Total heap capacity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_allocated;</span><span style=\"color:#6A737D\">     // Currently allocated</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_freed;</span><span style=\"color:#6A737D\">         // Available in free list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> gc_threshold;</span><span style=\"color:#6A737D\">        // Trigger at this occupancy (0.0-1.0)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} HeapStats;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> should_trigger_gc_simple</span><span style=\"color:#E1E4E8\">(HeapStats</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_used </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stats->bytes_allocated </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> stats->bytes_freed;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> occupancy </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)bytes_used </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> stats->heap_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> occupancy </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> stats->gc_threshold;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Example</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Heap: 10 MB\nThreshold: 0.75 (75%)\nAllocated: 8 MB\nFreed: 1 MB\nUsed: 7 MB (70%) â†’ No GC yet\n\n[Allocate 1 MB more]\nUsed: 8 MB (80%) â†’ TRIGGER GC!</code></pre></div>\n\n<p><strong>Quick Breakdown: Occupancy</strong></p>\n<blockquote>\n<p><strong>Occupancy</strong> = (Allocated - Freed) / Total Heap Size<br>It&#39;s the percentage of heap that&#39;s actually in use (not counting free blocks).</p>\n</blockquote>\n<p><strong>Pros</strong>:</p>\n<ul>\n<li>âœ… Simple to implement</li>\n<li>âœ… Predictable memory usage</li>\n<li>âœ… Works well for steady-state workloads</li>\n</ul>\n<p><strong>Cons</strong>:</p>\n<ul>\n<li>âŒ Ignores allocation rate (fast allocators hit threshold quickly)</li>\n<li>âŒ Ignores survival rate (if 90% survives, GC doesn&#39;t help much)</li>\n<li>âŒ Fixed threshold doesn&#39;t adapt to workload</li>\n</ul>\n<hr>\n<h3 id=\"strategy-2-allocation-rate-tracking\">Strategy 2: Allocation Rate Tracking</h3>\n<p><strong>The insight</strong>: If you&#39;re allocating 1 MB/sec, you&#39;ll run out of memory faster than if you&#39;re allocating 1 KB/sec.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_allocated_since_gc;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> time_since_gc_ms;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> allocation_threshold;</span><span style=\"color:#6A737D\">  // Trigger after this many bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} AllocationTracker;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> should_trigger_gc_allocation</span><span style=\"color:#E1E4E8\">(AllocationTracker</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tracker</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> tracker->bytes_allocated_since_gc </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> tracker->allocation_threshold;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> gc_alloc_with_tracking</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->tracker.bytes_allocated_since_gc </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">should_trigger_gc_allocation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">gc->tracker)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->tracker.bytes_allocated_since_gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->tracker.time_since_gc_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_time_ms</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> allocate</span><span style=\"color:#E1E4E8\">(gc, size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Example</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Threshold: 5 MB allocated â†’ trigger GC\nAllocation pattern:\n  T=0ms:   Allocate 1 MB (total: 1 MB)\n  T=10ms:  Allocate 2 MB (total: 3 MB)\n  T=20ms:  Allocate 3 MB (total: 6 MB) â†’ TRIGGER GC!</code></pre></div>\n\n<p><strong>Adaptive threshold</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> adjust_allocation_threshold</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, SweepResult</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> result</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If we freed a lot, increase threshold (GC was effective)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (result->bytes_freed </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> gc->tracker.allocation_threshold </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->tracker.allocation_threshold </span><span style=\"color:#F97583\">*=</span><span style=\"color:#79B8FF\"> 1.5</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If we freed little, decrease threshold (GC wasn't effective)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (result->bytes_freed </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->tracker.allocation_threshold </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 0.1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->tracker.allocation_threshold </span><span style=\"color:#F97583\">*=</span><span style=\"color:#79B8FF\"> 0.75</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clamp to reasonable bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->tracker.allocation_threshold </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->tracker.allocation_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Min 1 MB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->tracker.allocation_threshold </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> gc->heap_size </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->tracker.allocation_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_size </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Max 50% of heap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Pros</strong>:</p>\n<ul>\n<li>âœ… Adapts to allocation rate</li>\n<li>âœ… Prevents sudden OOM from allocation bursts</li>\n<li>âœ… Can learn optimal threshold over time</li>\n</ul>\n<p><strong>Cons</strong>:</p>\n<ul>\n<li>âŒ Doesn&#39;t account for object lifetimes</li>\n<li>âŒ Can trigger too often if objects die quickly</li>\n<li>âŒ Requires tuning of initial threshold</li>\n</ul>\n<hr>\n<h3 id=\"strategy-3-survival-rate-prediction\">Strategy 3: Survival Rate Prediction</h3>\n<p><strong>The insight</strong>: If 90% of objects survive GC, collecting garbage doesn&#39;t help much. Wait until more objects die.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_before_gc;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_after_gc;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> survival_rate;</span><span style=\"color:#6A737D\">       // Fraction that survived last GC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> target_survival;</span><span style=\"color:#6A737D\">     // Trigger when survival drops below this</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SurvivalTracker;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> update_survival_rate</span><span style=\"color:#E1E4E8\">(SurvivalTracker</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> tracker</span><span style=\"color:#E1E4E8\">, SweepResult</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> result</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tracker->bytes_after_gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tracker->bytes_before_gc </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> result->bytes_freed;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tracker->survival_rate </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)tracker->bytes_after_gc </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> tracker->bytes_before_gc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> should_trigger_gc_survival</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If last GC had high survival rate, wait longer before next GC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->survival.survival_rate </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0.8</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Need to allocate 2x heap size before triggering</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> gc->tracker.bytes_allocated_since_gc </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> gc->heap_size </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If last GC had low survival rate, trigger sooner</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (gc->survival.survival_rate </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.3</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Trigger after allocating 0.5x heap size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> gc->tracker.bytes_allocated_since_gc </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> gc->heap_size </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Medium survival rate - use standard threshold</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> gc->tracker.bytes_allocated_since_gc </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> gc->heap_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Example</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>GC #1: 10 MB before â†’ 9 MB after (90% survival)\n  â†’ High survival! Wait longer before next GC\n  â†’ Threshold: 20 MB allocated\n\nGC #2: 10 MB before â†’ 3 MB after (30% survival)\n  â†’ Low survival! Trigger GC sooner\n  â†’ Threshold: 5 MB allocated</code></pre></div>\n\n<p><strong>Pros</strong>:</p>\n<ul>\n<li>âœ… Avoids wasteful GC when objects are long-lived</li>\n<li>âœ… Triggers more often when objects are dying (GC is effective)</li>\n<li>âœ… Adapts to workload phase changes</li>\n</ul>\n<p><strong>Cons</strong>:</p>\n<ul>\n<li>âŒ Requires at least one GC to establish baseline</li>\n<li>âŒ Can be fooled by sudden workload changes</li>\n<li>âŒ Complex to tune</li>\n</ul>\n<hr>\n<h3 id=\"strategy-4-hybrid-multi-factor-heuristic\">Strategy 4: Hybrid Multi-Factor Heuristic</h3>\n<p><strong>The production approach</strong>: Combine multiple signals.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Heap pressure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> heap_occupancy;</span><span style=\"color:#6A737D\">           // 0.0 - 1.0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> heap_occupancy_threshold;</span><span style=\"color:#6A737D\"> // Trigger at 0.75</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocation rate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_allocated_since_gc;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> allocation_threshold;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Survival rate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> survival_rate;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> target_survival;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Time-based</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> time_since_gc_ms;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> max_time_between_gc_ms;</span><span style=\"color:#6A737D\"> // Force GC after this time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Fragmentation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> fragmentation_ratio;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> fragmentation_threshold;</span><span style=\"color:#6A737D\">  // Trigger at 0.5</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocation failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> last_allocation_failed;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} GCTriggerState;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> should_trigger_gc</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GCTriggerState</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> state </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">gc->trigger_state;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CRITICAL: Last allocation failed - MUST collect now</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (state->last_allocation_failed) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // URGENT: Heap is critically full</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (state->heap_occupancy </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0.95</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HIGH PRIORITY: Multiple factors indicate pressure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> pressure_signals </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (state->heap_occupancy </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> state->heap_occupancy_threshold) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pressure_signals</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (state->bytes_allocated_since_gc </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> state->allocation_threshold) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pressure_signals</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (state->fragmentation_ratio </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> state->fragmentation_threshold) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pressure_signals</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (state->time_since_gc_ms </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> state->max_time_between_gc_ms) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pressure_signals</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Trigger if 2+ signals indicate pressure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (pressure_signals </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // MEDIUM PRIORITY: High survival rate but heap is filling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (state->survival_rate </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0.8</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> state->heap_occupancy </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0.6</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Objects aren't dying - we're accumulating live data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Trigger GC to at least defragment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // LOW PRIORITY: Periodic GC to prevent long pauses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (state->time_since_gc_ms </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> state->max_time_between_gc_ms </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Decision tree visualization</strong>:</p>\n<p>{{DIAGRAM:gc-trigger-decision-tree}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>                    Allocation Request\n                           |\n                           v\n                  Last alloc failed?\n                    /           \\\n                  YES            NO\n                   |              |\n              TRIGGER GC          v\n                           Heap &gt; 95% full?\n                            /           \\\n                          YES            NO\n                           |              |\n                      TRIGGER GC          v\n                                   Count pressure signals:\n                                   - Heap occupancy high?\n                                   - Allocated too much?\n                                   - Fragmentation high?\n                                   - Too much time passed?\n                                          |\n                                          v\n                                   2+ signals?\n                                    /         \\\n                                  YES          NO\n                                   |            |\n                              TRIGGER GC    Continue</code></pre></div>\n\n<hr>\n<h2 id=\"visual-reference\">Visual Reference</h2>\n<p>{{DIAGRAM:gc-trigger-timeline}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Time â†’\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nHeap\nUsage\n  100% â”¤                                    â•­â”€ OOM! âœ—\n       â”‚                                â•­â”€â”€â”€â•¯\n   75% â”¤                            â•­â”€â”€â”€â•¯     â† Threshold\n       â”‚                        â•­â”€â”€â”€â•¯\n   50% â”¤                    â•­â”€â”€â”€â•¯\n       â”‚                â•­â”€â”€â”€â•¯\n   25% â”¤            â•­â”€â”€â”€â•¯\n       â”‚        â•­â”€â”€â”€â•¯\n    0% â”¼â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n       0ms    100ms   200ms   300ms   400ms   500ms\n\nWITHOUT GC TRIGGER: Crash at 500ms\n\n\nWITH GC TRIGGER (75% threshold):\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  100% â”¤\n       â”‚\n   75% â”¤            â•­â”€GC!â”€â•®         â•­â”€GC!â”€â•®\n       â”‚        â•­â”€â”€â”€â•¯     â•°â”€â”€â”€â•® â•­â”€â”€â”€â•¯     â•°â”€â”€â”€â•®\n   50% â”¤    â•­â”€â”€â”€â•¯             â•°â”€â•¯             â•°â”€â”€â”€â•®\n       â”‚â•­â”€â”€â”€â•¯                                      â•°â”€â”€â”€â•®\n   25% â”¤â•¯                                              â•°â”€â”€â”€\n       â”‚\n    0% â”¼\n       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n       0ms    100ms   200ms   300ms   400ms   500ms\n\nWITH GC TRIGGER: Stable operation, no crash</code></pre></div>\n\n<hr>\n<h2 id=\"the-debugging-lab-common-trigger-bugs\">The Debugging Lab: Common Trigger Bugs</h2>\n<h3 id=\"bug-1-trigger-too-late-oom-crash\">Bug 1: Trigger Too Late (OOM Crash)</h3>\n<p><strong>Symptom</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Allocating 1024 bytes...\nERROR: Out of memory!\nHeap occupancy: 99.8%\nLast GC: 5000ms ago</code></pre></div>\n\n<p><strong>Root cause</strong>: Threshold too high or not checking occupancy.</p>\n<p><strong>Fix</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// BEFORE: Only checking allocation count</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (bytes_allocated </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> threshold) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_collect</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AFTER: Also check heap occupancy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (bytes_allocated </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> threshold </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> heap_occupancy </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0.75</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_collect</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Prevention</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Add safety margin</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> double</span><span style=\"color:#E1E4E8\"> CRITICAL_THRESHOLD </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.95</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> double</span><span style=\"color:#E1E4E8\"> SAFE_THRESHOLD </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.75</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (heap_occupancy </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> CRITICAL_THRESHOLD) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Emergency GC - must succeed or crash gracefully</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (heap_occupancy </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> CRITICAL_THRESHOLD) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"FATAL: Out of memory after GC</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        abort</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"bug-2-trigger-too-often-thrashing\">Bug 2: Trigger Too Often (Thrashing)</h3>\n<p><strong>Symptom</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>GC #1: Freed 100 KB (10% of heap)\nGC #2: Freed 50 KB (5% of heap)\nGC #3: Freed 20 KB (2% of heap)\nGC #4: Freed 10 KB (1% of heap)\n...\nCPU usage: 90% (80% in GC!)</code></pre></div>\n\n<p><strong>Root cause</strong>: Triggering GC when survival rate is high.</p>\n<p><strong>Fix</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_collect</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> before </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->bytes_allocated;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SweepResult result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> sweep_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> after </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->bytes_allocated </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> result.bytes_freed;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> survival_rate </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)after </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> before;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If GC didn't help much, increase threshold</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (survival_rate </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0.9</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->trigger_state.allocation_threshold </span><span style=\"color:#F97583\">*=</span><span style=\"color:#79B8FF\"> 2.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"WARNING: High survival rate (</span><span style=\"color:#79B8FF\">%.1f%%</span><span style=\"color:#9ECBFF\">), \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">               \"increasing threshold to </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               survival_rate </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               gc->trigger_state.allocation_threshold);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"bug-3-ignoring-fragmentation\">Bug 3: Ignoring Fragmentation</h3>\n<p><strong>Symptom</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Allocation failed: No block large enough\nHeap occupancy: 45%\nFree memory: 5.5 MB\nLargest free block: 64 KB\nRequested: 1 MB</code></pre></div>\n\n<p><strong>Root cause</strong>: Heap is fragmented, but trigger only checks occupancy.</p>\n<p><strong>Fix</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> should_trigger_gc</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check occupancy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->heap_occupancy </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0.75</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check fragmentation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FragmentationStats stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> analyze_fragmentation</span><span style=\"color:#E1E4E8\">(gc->free_list);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (stats.fragmentation_ratio </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // More than 50% fragmented - trigger GC to compact</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if largest block is too small</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> avg_allocation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->total_allocated </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> gc->allocation_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (stats.largest_free </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> avg_allocation </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Can't satisfy typical allocations - trigger GC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"bug-4-not-adapting-to-workload-changes\">Bug 4: Not Adapting to Workload Changes</h3>\n<p><strong>Symptom</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Phase 1 (startup): GC every 100ms (good)\nPhase 2 (steady state): GC every 10ms (too often!)\nPhase 3 (shutdown): GC every 500ms (too rare!)</code></pre></div>\n\n<p><strong>Root cause</strong>: Fixed threshold doesn&#39;t adapt.</p>\n<p><strong>Fix</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> threshold;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> min_threshold;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> max_threshold;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> gc_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> total_gc_time_ms;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} AdaptiveThreshold;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> adjust_threshold_after_gc</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> gc_duration_ms</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AdaptiveThreshold</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> t </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">gc->adaptive;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t->gc_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t->total_gc_time_ms </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> gc_duration_ms;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> avg_gc_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)t->total_gc_time_ms </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> t->gc_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> gc_overhead </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> avg_gc_time </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (avg_gc_time </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Assume 100ms between GCs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Target: 5% GC overhead</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> double</span><span style=\"color:#E1E4E8\"> TARGET_OVERHEAD </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.05</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc_overhead </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> TARGET_OVERHEAD </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1.5</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // GC is taking too much time - increase threshold</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t->threshold </span><span style=\"color:#F97583\">*=</span><span style=\"color:#79B8FF\"> 1.2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (gc_overhead </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> TARGET_OVERHEAD </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // GC is cheap - can afford to run more often</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t->threshold </span><span style=\"color:#F97583\">*=</span><span style=\"color:#79B8FF\"> 0.9</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clamp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (t->threshold </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> t->min_threshold) t->threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> t->min_threshold;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (t->threshold </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> t->max_threshold) t->threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> t->max_threshold;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"code-scaffold-your-task\">Code Scaffold: Your Task</h2>\n<p>Implement a production-grade GC trigger system:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Heap metrics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> heap_size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_allocated;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_freed;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocation tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_allocated_since_gc;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> allocation_count_since_gc;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> time_since_gc_ms;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Historical data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> survival_rate;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> fragmentation_ratio;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Thresholds (adaptive)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> heap_occupancy_threshold;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> allocation_threshold;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> max_time_between_gc_ms;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_gc_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> total_gc_time_ms;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_bytes_allocated;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} GCTriggerState;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Implement this function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> should_trigger_gc</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GCTriggerState</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> state </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">gc->trigger_state;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TASK 1: Calculate current heap occupancy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: occupancy = (allocated - freed) / heap_size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> occupancy </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // TODO</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TASK 2: Check critical conditions (MUST trigger)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Last allocation failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Heap > 95% full</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - No free blocks available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#6A737D\">/* TODO */</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TASK 3: Count pressure signals</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> pressure_signals </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Signal 1: Heap occupancy above threshold</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#6A737D\">/* TODO */</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pressure_signals</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Signal 2: Allocated too much since last GC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#6A737D\">/* TODO */</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pressure_signals</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Signal 3: Too much time passed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#6A737D\">/* TODO */</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pressure_signals</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Signal 4: Fragmentation too high</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#6A737D\">/* TODO */</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pressure_signals</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TASK 4: Trigger if multiple signals indicate pressure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (pressure_signals </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TASK 5: Check for special cases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - High survival rate but heap filling (accumulating live data)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Periodic GC to prevent long pauses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#6A737D\">/* TODO */</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Implement adaptive threshold adjustment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> adjust_thresholds_after_gc</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, SweepResult</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> result</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#FFAB70\"> gc_duration_ms</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GCTriggerState</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> state </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">gc->trigger_state;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TASK 1: Update survival rate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // survival_rate = bytes_after / bytes_before</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> bytes_before </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> state->bytes_allocated;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> bytes_after </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> bytes_before </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> result->bytes_freed;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state->survival_rate </span><span style=\"color:#F97583\">=</span><span style=\"color:#6A737D\"> /* TODO */</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TASK 2: Update fragmentation ratio</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FragmentationStats frag </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> analyze_fragmentation</span><span style=\"color:#E1E4E8\">(gc->free_list);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state->fragmentation_ratio </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> frag.fragmentation_ratio;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TASK 3: Adjust allocation threshold based on survival rate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (state->survival_rate </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0.8</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // High survival - increase threshold (wait longer)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        state->allocation_threshold </span><span style=\"color:#F97583\">*=</span><span style=\"color:#6A737D\"> /* TODO */</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (state->survival_rate </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.3</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Low survival - decrease threshold (trigger sooner)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        state->allocation_threshold </span><span style=\"color:#F97583\">*=</span><span style=\"color:#6A737D\"> /* TODO */</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TASK 4: Adjust based on GC overhead</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state->total_gc_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state->total_gc_time_ms </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> gc_duration_ms;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> avg_gc_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)state->total_gc_time_ms </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> state->total_gc_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> time_between_gcs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)state->time_since_gc_ms;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> gc_overhead </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> avg_gc_time </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (avg_gc_time </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> time_between_gcs);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> double</span><span style=\"color:#E1E4E8\"> TARGET_OVERHEAD </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.05</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 5%</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc_overhead </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> TARGET_OVERHEAD </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1.5</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // GC overhead too high - trigger less often</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        state->heap_occupancy_threshold </span><span style=\"color:#F97583\">*=</span><span style=\"color:#6A737D\"> /* TODO */</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (gc_overhead </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> TARGET_OVERHEAD </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // GC overhead low - can trigger more often</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        state->heap_occupancy_threshold </span><span style=\"color:#F97583\">*=</span><span style=\"color:#6A737D\"> /* TODO */</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TASK 5: Clamp thresholds to reasonable bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (state->heap_occupancy_threshold </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        state->heap_occupancy_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (state->heap_occupancy_threshold </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0.9</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        state->heap_occupancy_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.9</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (state->allocation_threshold </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->heap_size </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        state->allocation_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_size </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (state->allocation_threshold </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> gc->heap_size </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        state->allocation_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_size </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TASK 6: Reset counters</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state->bytes_allocated_since_gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state->allocation_count_since_gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state->time_since_gc_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Implement allocation tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> gc_alloc_with_trigger</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TASK 1: Update allocation tracking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->trigger_state.bytes_allocated_since_gc </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->trigger_state.allocation_count_since_gc</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->trigger_state.total_bytes_allocated </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TASK 2: Check if we should trigger GC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">should_trigger_gc</span><span style=\"color:#E1E4E8\">(gc)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_time_ms</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Run GC</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mark_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SweepResult result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> sweep_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> gc_duration </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_time_ms</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Adjust thresholds based on results</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        adjust_thresholds_after_gc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">result, gc_duration);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        #ifdef</span><span style=\"color:#B392F0\"> GC_DEBUG</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"GC triggered: freed </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes (</span><span style=\"color:#79B8FF\">%.1f%%</span><span style=\"color:#9ECBFF\"> survival) in </span><span style=\"color:#79B8FF\">%llu</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               result.bytes_freed,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               gc->trigger_state.survival_rate </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               gc_duration);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TASK 3: Try to allocate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> try_allocate</span><span style=\"color:#E1E4E8\">(gc->free_list, size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TASK 4: If allocation failed, force GC and try again</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->trigger_state.last_allocation_failed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Force GC</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mark_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        sweep_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Try again</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> try_allocate</span><span style=\"color:#E1E4E8\">(gc->free_list, size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"FATAL: Out of memory after GC</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"  Requested: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, size);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"  Heap size: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, gc->heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"  Allocated: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, gc->trigger_state.bytes_allocated);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"  Free: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, gc->trigger_state.bytes_freed);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            abort</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->trigger_state.last_allocation_failed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"advanced-predictive-triggering\">Advanced: Predictive Triggering</h2>\n<p><strong>The cutting edge</strong>: Use machine learning to predict optimal GC timing.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Historical allocation patterns</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#FFAB70\"> allocation_history</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">  // Last 100 allocation sizes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#FFAB70\"> allocation_times</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">  // Timestamps</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> history_index;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Predicted values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> predicted_next_allocation;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> predicted_time_to_oom;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} PredictiveModel;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> update_prediction</span><span style=\"color:#E1E4E8\">(PredictiveModel</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> model</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> allocation_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add to history</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    model->allocation_history[model->history_index] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> allocation_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    model->allocation_times[model->history_index] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_time_ms</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    model->history_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (model->history_index </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate moving average</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> sum </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sum </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> model->allocation_history[i];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    model->predicted_next_allocation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sum </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate allocation rate (bytes/ms)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> time_span </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> model->allocation_times[</span><span style=\"color:#79B8FF\">99</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> model->allocation_times[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (time_span </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        double</span><span style=\"color:#E1E4E8\"> allocation_rate </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)sum </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> time_span;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Predict time until OOM</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> free_space </span><span style=\"color:#F97583\">=</span><span style=\"color:#6A737D\"> /* calculate free space */</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        model->predicted_time_to_oom </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)(free_space </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> allocation_rate);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> should_trigger_gc_predictive</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PredictiveModel</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> model </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">gc->predictive_model;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If we predict OOM in next 100ms, trigger GC now</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (model->predicted_time_to_oom </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If next allocation likely won't fit, trigger GC now</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FragmentationStats stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> analyze_fragmentation</span><span style=\"color:#E1E4E8\">(gc->free_list);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (model->predicted_next_allocation </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> stats.largest_free) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Benefits</strong>:</p>\n<ul>\n<li>Trigger GC <em>before</em> allocation fails</li>\n<li>Smooth out GC pauses by predicting quiet periods</li>\n<li>Adapt to complex allocation patterns</li>\n</ul>\n<p><strong>Tradeoffs</strong>:</p>\n<ul>\n<li>Requires significant history to be accurate</li>\n<li>Can be fooled by sudden workload changes</li>\n<li>More complex to implement and debug</li>\n</ul>\n<hr>\n<h2 id=\"testing-your-implementation\">Testing Your Implementation</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_gc_trigger</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 1 MB heap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->trigger_state.heap_occupancy_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.75</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->trigger_state.allocation_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 512</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 512 KB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test 1: Trigger on heap occupancy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        gc_alloc_with_trigger</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 10 KB each</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should have triggered GC when heap hit 75%</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->trigger_state.total_gc_count </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test 2: Trigger on allocation threshold</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->trigger_state.total_gc_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_alloc_with_trigger</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">600</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 600 KB (exceeds threshold)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->trigger_state.total_gc_count </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test 3: Adaptive threshold adjustment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> initial_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->trigger_state.heap_occupancy_threshold;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Simulate high survival rate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->trigger_state.survival_rate </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.95</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    adjust_thresholds_after_gc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">(SweepResult){</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Threshold should increase (wait longer before next GC)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->trigger_state.heap_occupancy_threshold </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> initial_threshold);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ GC trigger tests passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_gc_trigger_stress</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 10 MB heap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate aggressively</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">rand</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 1-1024 bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc_with_trigger</span><span style=\"color:#E1E4E8\">(gc, size);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(ptr </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Randomly free some objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">rand</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Mark as dead (in real code, this happens naturally)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            GET_HEADER</span><span style=\"color:#E1E4E8\">(ptr)->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should have triggered multiple GCs</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->trigger_state.total_gc_count </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should never have crashed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ GC trigger stress test passed (</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> GCs)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           gc->trigger_state.total_gc_count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-tuning-guide\">Performance Tuning Guide</h2>\n<h3 id=\"tuning-for-throughput-batch-processing\">Tuning for Throughput (Batch Processing)</h3>\n<p><strong>Goal</strong>: Minimize GC overhead, maximize work done.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Aggressive thresholds - trigger rarely</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">trigger_state.heap_occupancy_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.90</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 90%</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">trigger_state.allocation_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">heap_size </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 2x heap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">trigger_state.max_time_between_gc_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 10 seconds</span></span></code></pre></div>\n\n<p><strong>Expected</strong>: 2-5% GC overhead, large memory footprint.</p>\n<hr>\n<h3 id=\"tuning-for-latency-interactive-applications\">Tuning for Latency (Interactive Applications)</h3>\n<p><strong>Goal</strong>: Minimize pause times, keep GC predictable.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Conservative thresholds - trigger often</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">trigger_state.heap_occupancy_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.60</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 60%</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">trigger_state.allocation_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">heap_size </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 0.5x heap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">trigger_state.max_time_between_gc_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 100ms</span></span></code></pre></div>\n\n<p><strong>Expected</strong>: 10-15% GC overhead, small pauses (1-5ms).</p>\n<hr>\n<h3 id=\"tuning-for-memory-constrained-systems\">Tuning for Memory-Constrained Systems</h3>\n<p><strong>Goal</strong>: Minimize memory footprint, avoid OOM.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Very conservative thresholds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">trigger_state.heap_occupancy_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.50</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 50%</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">trigger_state.allocation_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">heap_size </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 0.25x heap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">gc</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">trigger_state.max_time_between_gc_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 50ms</span></span></code></pre></div>\n\n<p><strong>Expected</strong>: 20-30% GC overhead, but never OOM.</p>\n<hr>\n<h2 id=\"what-you39ve-mastered\">What You&#39;ve Mastered</h2>\n<p>âœ… <strong>Heap occupancy thresholds</strong> for simple triggering<br>âœ… <strong>Allocation rate tracking</strong> for adaptive triggering<br>âœ… <strong>Survival rate prediction</strong> to avoid wasteful GC<br>âœ… <strong>Multi-factor heuristics</strong> for production systems<br>âœ… <strong>Adaptive threshold adjustment</strong> for changing workloads<br>âœ… <strong>Predictive triggering</strong> using historical data<br>âœ… <strong>Performance tuning</strong> for different workload types  </p>\n<hr>\n<h2 id=\"next-steps\">Next Steps</h2>\n<p><strong>You now have a complete mark-and-sweep garbage collector with intelligent triggering!</strong> ğŸ‰</p>\n<p><strong>What&#39;s next?</strong></p>\n<ol>\n<li><strong><a href=\"#generational-gc\">â†’ Generational GC</a></strong>: Optimize for &quot;most objects die young&quot;</li>\n<li><strong><a href=\"#incremental-gc\">â†’ Incremental GC</a></strong>: Spread GC work across multiple allocations</li>\n<li><strong><a href=\"#concurrent-gc\">â†’ Concurrent GC</a></strong>: Collect garbage while program runs</li>\n<li><strong><a href=\"#compacting-gc\">â†’ Compacting GC</a></strong>: Eliminate fragmentation by moving objects</li>\n</ol>\n<p><strong>Before continuing</strong>, verify your trigger logic works under stress:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> ./test_gc_trigger</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Basic</span><span style=\"color:#9ECBFF\"> trigger</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Occupancy</span><span style=\"color:#9ECBFF\"> trigger</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Allocation</span><span style=\"color:#9ECBFF\"> trigger</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Adaptive</span><span style=\"color:#9ECBFF\"> threshold</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Stress</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span><span style=\"color:#E1E4E8\"> (47 </span><span style=\"color:#9ECBFF\">GCs,</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#9ECBFF\"> OOM</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Throughput</span><span style=\"color:#9ECBFF\"> test:</span><span style=\"color:#9ECBFF\"> 95%</span><span style=\"color:#9ECBFF\"> efficiency</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Latency</span><span style=\"color:#9ECBFF\"> test:</span><span style=\"color:#9ECBFF\"> max</span><span style=\"color:#9ECBFF\"> pause</span><span style=\"color:#9ECBFF\"> 3.2ms</span></span></code></pre></div>\n\n<hr>\n<p><a href=\"#satellite-map\">â†‘ Back to System Map</a></p>\n<h1 id=\"write-barrier-integration\">Write Barrier Integration</h1>\n<div id=\"ms-write-barrier\"></div>\n\n<h2 id=\"the-epiphany-analogy-the-security-camera-system\">The Epiphany Analogy: The Security Camera System</h2>\n<p>Imagine you&#39;re managing a massive library where books can reference other books (like a bibliography). You have a cleaning crew (garbage collector) that removes books nobody references anymore.</p>\n<p><strong>The problem</strong>: What if someone updates a bibliography <em>while</em> the cleaning crew is working? They might remove a book that just got referenced!</p>\n<p><strong>The solution</strong>: Install security cameras (write barriers) at every desk. Whenever someone writes a new reference, the camera records it. The cleaning crew checks these recordings to ensure they don&#39;t throw away newly-referenced books.</p>\n<p><strong>In memory management</strong>: A write barrier is a small piece of code that runs <em>every time</em> you update a pointer. It tracks these updates so the GC can handle them correctly, especially in advanced collectors (incremental, generational, concurrent).</p>\n<hr>\n<h2 id=\"technical-rationale-why-write-barriers\">Technical Rationale: Why Write Barriers?</h2>\n<h3 id=\"the-core-problem\">The Core Problem</h3>\n<p>In a simple stop-the-world GC, this works fine:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Program stops completely</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mark_phase</span><span style=\"color:#E1E4E8\">(gc);</span><span style=\"color:#6A737D\">    // Find all reachable objects</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sweep_phase</span><span style=\"color:#E1E4E8\">(gc);</span><span style=\"color:#6A737D\">   // Free unreachable objects</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Program resumes</span></span></code></pre></div>\n\n<p>But in <strong>advanced GC schemes</strong>, the program runs <em>during</em> collection:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Incremental GC: Collect in small steps</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mark_some_objects</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">run_program_for_a_bit</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">  // â† DANGER ZONE</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mark_more_objects</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">run_program_for_a_bit</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">  // â† Pointers can change here!</span></span></code></pre></div>\n\n<p><strong>The race condition</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Time 0: GC marks object A (reachable)\nTime 1: GC marks object B (unreachable, will be freed)\nTime 2: Program runs: A-&gt;next = B  â† B is now reachable!\nTime 3: GC sweeps, frees B  â† DISASTER! A points to freed memory!</code></pre></div>\n\n<p><strong>Write barriers prevent this</strong> by recording pointer updates.</p>\n<hr>\n<h2 id=\"the-three-flavors-of-write-barriers\">The Three Flavors of Write Barriers</h2>\n<h3 id=\"1-snapshot-at-the-beginning-satb\">1. <strong>Snapshot-At-The-Beginning (SATB)</strong></h3>\n<p><strong>Philosophy</strong>: Preserve the object graph as it existed when GC started.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> satb_write_barrier</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void**</span><span style=\"color:#FFAB70\"> slot</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> new_value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> old_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">slot;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If we're overwriting a pointer during GC, preserve the old target</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc_is_running </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> old_value </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mark_object</span><span style=\"color:#E1E4E8\">(old_value);</span><span style=\"color:#6A737D\">  // Don't let it be collected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">slot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_value;</span><span style=\"color:#6A737D\">  // Perform the write</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>When to use</strong>: Concurrent mark-and-sweep (like G1GC in Java).</p>\n<p><strong>Tradeoff</strong>: May keep some garbage alive until next GC cycle.</p>\n<hr>\n<h3 id=\"2-incremental-update-forward-barrier\">2. <strong>Incremental Update (Forward Barrier)</strong></h3>\n<p><strong>Philosophy</strong>: Track new references created during GC.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> incremental_write_barrier</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void**</span><span style=\"color:#FFAB70\"> slot</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> new_value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">slot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_value;</span><span style=\"color:#6A737D\">  // Perform the write first</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If we created a new reference during GC, mark the target</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc_is_running </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> new_value </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mark_object</span><span style=\"color:#E1E4E8\">(new_value);</span><span style=\"color:#6A737D\">  // Ensure it's not collected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>When to use</strong>: Incremental mark-and-sweep.</p>\n<p><strong>Tradeoff</strong>: Can cause &quot;mark stack overflow&quot; if many new references created.</p>\n<hr>\n<h3 id=\"3-generational-barrier-card-marking\">3. <strong>Generational Barrier (Card Marking)</strong></h3>\n<p><strong>Philosophy</strong>: Track old-to-young pointers for generational GC.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> generational_write_barrier</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void**</span><span style=\"color:#FFAB70\"> slot</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> new_value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">slot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_value;</span><span style=\"color:#6A737D\">  // Perform the write</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If an old object now points to a young object, record it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_old_generation</span><span style=\"color:#E1E4E8\">(slot) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#B392F0\"> is_young_generation</span><span style=\"color:#E1E4E8\">(new_value)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mark_card_dirty</span><span style=\"color:#E1E4E8\">(slot);</span><span style=\"color:#6A737D\">  // Mark this memory region as \"contains cross-gen pointer\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>When to use</strong>: Generational GC (most production systems).</p>\n<p><strong>Tradeoff</strong>: Requires extra memory for card table.</p>\n<hr>\n<h2 id=\"internal-mechanics-implementing-write-barriers\">Internal Mechanics: Implementing Write Barriers</h2>\n<h3 id=\"step-1-the-card-table-for-generational-gc\">Step 1: The Card Table (for Generational GC)</h3>\n<p>{{DIAGRAM:write-barrier-card-table}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Heap Memory:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [Object A] [Object B] [Object C] ...    â”‚  â† Actual objects\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â†“           â†“           â†“\nCard Table (1 byte per 512 bytes of heap):\nâ”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”\nâ”‚ 0 â”‚ 1 â”‚ 0 â”‚ 0 â”‚ 1 â”‚ 0 â”‚ 0 â”‚ 0 â”‚  â† 1 = &quot;dirty&quot; (contains interesting pointer)\nâ””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜</code></pre></div>\n\n<p><strong>The card table</strong> is a bitmap where each bit represents a region of memory (typically 512 bytes). When you update a pointer in that region, you mark the card as &quot;dirty.&quot;</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CARD_SIZE</span><span style=\"color:#79B8FF\"> 512</span><span style=\"color:#6A737D\">  // Bytes per card</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CARD_SHIFT</span><span style=\"color:#79B8FF\"> 9</span><span style=\"color:#6A737D\">   // log2(512) = 9</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t*</span><span style=\"color:#E1E4E8\"> cards;</span><span style=\"color:#6A737D\">        // Card table (1 byte per card)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> num_cards;</span><span style=\"color:#6A737D\">      // Total number of cards</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> heap_start;</span><span style=\"color:#6A737D\">      // Start of heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> heap_size;</span><span style=\"color:#6A737D\">      // Size of heap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} CardTable;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">CardTable</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> create_card_table</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> heap_start</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> heap_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CardTable</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> table </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(CardTable));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate number of cards needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    table->num_cards </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (heap_size </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> CARD_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> CARD_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    table->cards </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> calloc</span><span style=\"color:#E1E4E8\">(table->num_cards, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // All clean initially</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    table->heap_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    table->heap_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> heap_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> table;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get card index for a memory address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> size_t</span><span style=\"color:#B392F0\"> get_card_index</span><span style=\"color:#E1E4E8\">(CardTable</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> table</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)addr </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)table->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> CARD_SHIFT;</span><span style=\"color:#6A737D\">  // Divide by 512</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Mark a card as dirty</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> mark_card_dirty</span><span style=\"color:#E1E4E8\">(CardTable</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> table</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> card_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_card_index</span><span style=\"color:#E1E4E8\">(table, addr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    table->cards[card_idx] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Mark as dirty</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check if a card is dirty</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> is_card_dirty</span><span style=\"color:#E1E4E8\">(CardTable</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> table</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> card_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_card_index</span><span style=\"color:#E1E4E8\">(table, addr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> table->cards[card_idx] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Clear all cards (after processing)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> clear_card_table</span><span style=\"color:#E1E4E8\">(CardTable</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> table</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(table->cards, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, table->num_cards);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Memory overhead</strong>: For a 1 MB heap with 512-byte cards, you need 2 KB for the card table (0.2% overhead).</p>\n<hr>\n<h3 id=\"step-2-the-write-barrier-hook\">Step 2: The Write Barrier Hook</h3>\n<p>Now we need to intercept <em>every</em> pointer write. There are three approaches:</p>\n<h4 id=\"approach-a-compiler-support-best\"><strong>Approach A: Compiler Support (Best)</strong></h4>\n<p>Modern compilers can automatically insert write barriers:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// What you write:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">obj</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">field </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_value;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// What the compiler generates:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">write_barrier</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">obj</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">field</span><span style=\"color:#E1E4E8\">, new_value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">obj</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">field </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_value;</span></span></code></pre></div>\n\n<p><strong>How to enable</strong>: Use compiler intrinsics or custom passes (GCC plugins, LLVM passes).</p>\n<hr>\n<h4 id=\"approach-b-manual-macros-practical\"><strong>Approach B: Manual Macros (Practical)</strong></h4>\n<p>Define macros for all pointer writes:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> GC_WRITE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">obj</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">field</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">do</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_barrier</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">((obj)->field), (value)); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (obj)->field </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (value); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Usage:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">GC_WRITE</span><span style=\"color:#E1E4E8\">(my_object, next_ptr, new_object);</span></span></code></pre></div>\n\n<p><strong>Tradeoff</strong>: Requires disciplineâ€”easy to forget the macro.</p>\n<hr>\n<h4 id=\"approach-c-memory-protection-slow-but-automatic\"><strong>Approach C: Memory Protection (Slow but Automatic)</strong></h4>\n<p>Use <code>mprotect()</code> to make memory read-only, catch writes with signal handlers:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Mark old generation as read-only</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mprotect</span><span style=\"color:#E1E4E8\">(old_gen_start, old_gen_size, PROT_READ);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// When program tries to write:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> segfault_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> sig</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">siginfo_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> info</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> context</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> fault_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> info->si_addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Record the write</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_card_dirty</span><span style=\"color:#E1E4E8\">(card_table, fault_addr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Temporarily allow the write</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mprotect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">page_of</span><span style=\"color:#E1E4E8\">(fault_addr), PAGE_SIZE, PROT_READ </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PROT_WRITE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Tradeoff</strong>: 100-1000x slower than inline barriers. Only for debugging.</p>\n<hr>\n<h3 id=\"step-3-the-complete-write-barrier-implementation\">Step 3: The Complete Write Barrier Implementation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WB_NONE,</span><span style=\"color:#6A737D\">           // No write barrier (stop-the-world GC)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WB_SATB,</span><span style=\"color:#6A737D\">           // Snapshot-at-the-beginning (concurrent GC)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WB_INCREMENTAL,</span><span style=\"color:#6A737D\">    // Incremental update (incremental GC)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WB_GENERATIONAL</span><span style=\"color:#6A737D\">    // Card marking (generational GC)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} WriteBarrierType;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WriteBarrierType type;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CardTable</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> card_table;</span><span style=\"color:#6A737D\">      // For generational GC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> gc_is_running;</span><span style=\"color:#6A737D\">         // For SATB/incremental</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> barrier_calls;</span><span style=\"color:#6A737D\">       // Total write barrier invocations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> cards_dirtied;</span><span style=\"color:#6A737D\">       // Cards marked dirty</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> objects_marked;</span><span style=\"color:#6A737D\">      // Objects marked by barrier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} WriteBarrierState;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize write barrier system</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">WriteBarrierState</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> create_write_barrier</span><span style=\"color:#E1E4E8\">(WriteBarrierType </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                        void*</span><span style=\"color:#FFAB70\"> heap_start</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                        size_t</span><span style=\"color:#FFAB70\"> heap_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WriteBarrierState</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> wb </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(WriteBarrierState));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    wb->type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> type;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    wb->gc_is_running </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    wb->barrier_calls </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    wb->cards_dirtied </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    wb->objects_marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> WB_GENERATIONAL) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        wb->card_table </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_card_table</span><span style=\"color:#E1E4E8\">(heap_start, heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        wb->card_table </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> wb;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The universal write barrier</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> write_barrier</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void**</span><span style=\"color:#FFAB70\"> slot</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> new_value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WriteBarrierState</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> wb </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->write_barrier;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    wb->barrier_calls</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (wb->type) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> WB_NONE:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // No barrier needed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> WB_SATB: {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Snapshot-at-the-beginning: preserve old value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            void*</span><span style=\"color:#E1E4E8\"> old_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">slot;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (wb->gc_is_running </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> old_value </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(old_value);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">header->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    mark_object</span><span style=\"color:#E1E4E8\">(gc, old_value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    wb->objects_marked</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> WB_INCREMENTAL: {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Incremental update: mark new value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (wb->gc_is_running </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> new_value </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(new_value);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">header->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    mark_object</span><span style=\"color:#E1E4E8\">(gc, new_value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    wb->objects_marked</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> WB_GENERATIONAL: {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Card marking: track old-to-young pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_old_generation</span><span style=\"color:#E1E4E8\">(gc, slot) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                is_young_generation</span><span style=\"color:#E1E4E8\">(gc, new_value)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                mark_card_dirty</span><span style=\"color:#E1E4E8\">(wb->card_table, slot);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                wb->cards_dirtied</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Convenience macro for manual barrier insertion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> GC_WRITE_PTR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">obj</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">field</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">do</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_barrier</span><span style=\"color:#E1E4E8\">((gc), (</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">((obj)->field), (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)(value)); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (obj)->field </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (value); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"visual-reference-write-barrier-in-action\">Visual Reference: Write Barrier in Action</h2>\n<p>{{DIAGRAM:write-barrier-flow}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Without Write Barrier (BROKEN):\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nTime 0: GC starts marking\n  A (marked) â†’ B (marked) â†’ C (unmarked, will be freed)\n  \nTime 1: Program runs, updates pointer\n  A (marked) â†’ C (unmarked)  â† A now points to C!\n  B (marked) â†’ NULL\n  \nTime 2: GC sweeps\n  A (kept) â†’ [FREED MEMORY]  â† CRASH!\n  B (kept)\n\n\nWith Write Barrier (CORRECT):\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nTime 0: GC starts marking\n  A (marked) â†’ B (marked) â†’ C (unmarked)\n  \nTime 1: Program runs, updates pointer\n  A (marked) â†’ C (unmarked)\n  write_barrier() called â†’ marks C!  â† Barrier saves the day\n  \nTime 2: GC sweeps\n  A (kept) â†’ C (kept)  â† Safe!\n  B (freed)</code></pre></div>\n\n<hr>\n<h2 id=\"the-debugging-lab-common-write-barrier-bugs\">The Debugging Lab: Common Write Barrier Bugs</h2>\n<h3 id=\"bug-1-forgetting-the-barrier\">Bug #1: Forgetting the Barrier</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Direct pointer write</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">obj</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_obj;</span><span style=\"color:#6A737D\">  // â† No barrier! GC might collect new_obj!</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CORRECT: Use barrier macro</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">GC_WRITE_PTR</span><span style=\"color:#E1E4E8\">(gc, obj, next, new_obj);</span></span></code></pre></div>\n\n<p><strong>Symptom</strong>: Random crashes during GC, use-after-free errors.</p>\n<p><strong>Detection</strong>: Run with <code>mprotect</code>-based barriers (slow but catches all violations).</p>\n<hr>\n<h3 id=\"bug-2-barrier-after-write\">Bug #2: Barrier After Write</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Write happens before barrier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">obj</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_obj;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">write_barrier</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">obj</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">next</span><span style=\"color:#E1E4E8\">, new_obj);</span><span style=\"color:#6A737D\">  // â† Too late!</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CORRECT: Barrier before write</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">write_barrier</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">obj</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">next</span><span style=\"color:#E1E4E8\">, new_obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">obj</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_obj;</span></span></code></pre></div>\n\n<p><strong>Why it matters</strong>: In concurrent GC, another thread might see the new pointer before the barrier runs.</p>\n<hr>\n<h3 id=\"bug-3-barrier-on-non-heap-pointers\">Bug #3: Barrier on Non-Heap Pointers</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Barrier on stack variable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int*</span><span style=\"color:#E1E4E8\"> stack_var </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">write_barrier</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">stack_var</span><span style=\"color:#E1E4E8\">, heap_obj);</span><span style=\"color:#6A737D\">  // â† stack_var is not in heap!</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CORRECT: Only barrier heap-to-heap pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_heap_pointer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">obj</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">field</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_barrier</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">obj->field, new_value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Symptom</strong>: Segfaults in <code>get_card_index()</code> when address is outside heap.</p>\n<hr>\n<h3 id=\"bug-4-barrier-performance-overhead\">Bug #4: Barrier Performance Overhead</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Barrier in tight loop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GC_WRITE_PTR</span><span style=\"color:#E1E4E8\">(gc, array, </span><span style=\"color:#FFAB70\">elements</span><span style=\"color:#E1E4E8\">[i], new_value);</span><span style=\"color:#6A737D\">  // â† 1M barrier calls!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BETTER: Batch writes, single barrier</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    array->elements[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_value;</span><span style=\"color:#6A737D\">  // Direct write</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">write_barrier</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">array</span><span style=\"color:#F97583\">-></span><span style=\"color:#FFAB70\">elements</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], new_value);</span><span style=\"color:#6A737D\">  // Single barrier for whole array</span></span></code></pre></div>\n\n<p><strong>Optimization</strong>: Modern GCs use &quot;coarse-grained&quot; barriers that mark entire regions dirty.</p>\n<hr>\n<h2 id=\"code-scaffold-your-task\">Code Scaffold: Your Task</h2>\n<p>Integrate write barriers into your GC:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// TASK 1: Add write barrier state to GC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... existing fields ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WriteBarrierState</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> write_barrier;</span><span style=\"color:#6A737D\">  // â† Add this</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Generation tracking (for generational GC)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> young_gen_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> young_gen_size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> old_gen_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> old_gen_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} GC;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 2: Initialize write barrier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> create_gc_with_barrier</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> heap_size</span><span style=\"color:#E1E4E8\">, WriteBarrierType </span><span style=\"color:#FFAB70\">barrier_type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create write barrier state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->write_barrier </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_write_barrier</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        barrier_type,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->heap_start,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->heap_size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    );</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: For generational GC, split heap into generations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (barrier_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> WB_GENERATIONAL) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->young_gen_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> heap_size </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 25% young</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->young_gen_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->old_gen_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->young_gen_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->old_gen_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> heap_size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> gc->young_gen_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> gc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 3: Helper to check generation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_young_generation</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->write_barrier->type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> WB_GENERATIONAL) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> gc->young_gen_start </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->young_gen_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->young_gen_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_old_generation</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->write_barrier->type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> WB_GENERATIONAL) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> gc->old_gen_start </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->old_gen_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->old_gen_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 4: Implement SATB write barrier</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> satb_write_barrier_impl</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void**</span><span style=\"color:#FFAB70\"> slot</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> new_value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Get old value from slot</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> old_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">slot;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: If GC is running and old value exists, mark it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->write_barrier->gc_is_running </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> old_value </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(old_value);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">header->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Mark the old object to preserve snapshot</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            mark_object</span><span style=\"color:#E1E4E8\">(gc, old_value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            gc->write_barrier->objects_marked</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 5: Implement incremental write barrier</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> incremental_write_barrier_impl</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void**</span><span style=\"color:#FFAB70\"> slot</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> new_value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: If GC is running and new value exists, mark it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->write_barrier->gc_is_running </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> new_value </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(new_value);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">header->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Mark the new object to ensure it's not collected</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            mark_object</span><span style=\"color:#E1E4E8\">(gc, new_value);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            gc->write_barrier->objects_marked</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 6: Implement generational write barrier</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> generational_write_barrier_impl</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void**</span><span style=\"color:#FFAB70\"> slot</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> new_value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if this is an old-to-young pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_old_generation</span><span style=\"color:#E1E4E8\">(gc, slot) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#B392F0\"> is_young_generation</span><span style=\"color:#E1E4E8\">(gc, new_value)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Mark the card containing this slot as dirty</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mark_card_dirty</span><span style=\"color:#E1E4E8\">(gc->write_barrier->card_table, slot);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->write_barrier->cards_dirtied</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 7: Update mark phase to process dirty cards (generational GC)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_phase_with_cards</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Standard marking from roots</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_from_roots</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: If using generational GC, scan dirty cards</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->write_barrier->type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> WB_GENERATIONAL) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CardTable</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> table </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->write_barrier->card_table;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: For each dirty card, scan objects in that region</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> table->num_cards; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (table->cards[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Calculate memory region for this card</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                void*</span><span style=\"color:#E1E4E8\"> card_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)table->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> CARD_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                void*</span><span style=\"color:#E1E4E8\"> card_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)card_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> CARD_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Scan all objects in this card</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                scan_region_for_pointers</span><span style=\"color:#E1E4E8\">(gc, card_start, card_end);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Clear the card</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                table->cards[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 8: Helper to scan a memory region for pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scan_region_for_pointers</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> start</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> end</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Walk through memory, find objects, mark their references</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)end) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if this looks like an object header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_valid_object_header</span><span style=\"color:#E1E4E8\">(ptr)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // If object is in old generation, mark its children</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_old_generation</span><span style=\"color:#E1E4E8\">(gc, ptr)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                mark_object_children</span><span style=\"color:#E1E4E8\">(gc, ptr </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Skip ahead</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 9: Update allocation to use write barrier</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> gc_alloc_with_barrier</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc_with_trigger</span><span style=\"color:#E1E4E8\">(gc, size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: If using generational GC, allocate in young generation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->write_barrier->type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> WB_GENERATIONAL) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Mark object as young</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        header->generation </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Young generation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 10: Implement object promotion (young â†’ old)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> promote_object</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Move object from young to old generation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (header->generation </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Allocate in old generation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> new_location </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> allocate_in_old_gen</span><span style=\"color:#E1E4E8\">(gc, header->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Copy object data</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memcpy</span><span style=\"color:#E1E4E8\">(new_location, obj, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> header->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Update header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> new_header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(new_location);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_header->generation </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Old generation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Update all pointers to old location (requires forwarding pointer)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        header->forwarding_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_location;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"testing-your-write-barrier\">Testing Your Write Barrier</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_write_barrier_satb</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc_with_barrier</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">, WB_SATB);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate three objects: A â†’ B â†’ C</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj_a </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj_b </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> obj_c </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GC_WRITE_PTR</span><span style=\"color:#E1E4E8\">(gc, obj_a, next, obj_b);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GC_WRITE_PTR</span><span style=\"color:#E1E4E8\">(gc, obj_b, next, obj_c);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start GC (mark A and B)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->write_barrier->gc_is_running </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_object</span><span style=\"color:#E1E4E8\">(gc, obj_a);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_object</span><span style=\"color:#E1E4E8\">(gc, obj_b);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // C is not marked yet</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Program runs: A now points to C (bypassing B)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GC_WRITE_PTR</span><span style=\"color:#E1E4E8\">(gc, obj_a, next, obj_c);</span><span style=\"color:#6A737D\">  // â† Barrier should mark C!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify C was marked by barrier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header_c </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(obj_c);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(header_c->marked </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ SATB write barrier test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_write_barrier_generational</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc_with_barrier</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">, WB_GENERATIONAL);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate in young generation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> young_obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc_with_barrier</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_young_generation</span><span style=\"color:#E1E4E8\">(gc, young_obj));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Promote to old generation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    promote_object</span><span style=\"color:#E1E4E8\">(gc, young_obj);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> old_obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(young_obj)->forwarding_ptr;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_old_generation</span><span style=\"color:#E1E4E8\">(gc, old_obj));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate another young object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> young_obj2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc_with_barrier</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Old object points to young object</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GC_WRITE_PTR</span><span style=\"color:#E1E4E8\">(gc, old_obj, next, young_obj2);</span><span style=\"color:#6A737D\">  // â† Should dirty card!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify card was marked dirty</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_card_dirty</span><span style=\"color:#E1E4E8\">(gc->write_barrier->card_table, old_obj));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Generational write barrier test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_write_barrier_performance</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc_with_barrier</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">, WB_GENERATIONAL);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate 10,000 objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> objects </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        objects</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc_with_barrier</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Measure barrier overhead</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_time_us</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        GC_WRITE_PTR</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#FFAB70\">objects</span><span style=\"color:#E1E4E8\">[i], next, </span><span style=\"color:#FFAB70\">objects</span><span style=\"color:#E1E4E8\">[(i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> duration </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_time_us</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> ns_per_barrier </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)duration </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1000.0</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 10000.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Write barrier performance: </span><span style=\"color:#79B8FF\">%.1f</span><span style=\"color:#9ECBFF\"> ns/barrier</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ns_per_barrier);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Total barriers: </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, gc->write_barrier->barrier_calls);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Cards dirtied: </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, gc->write_barrier->cards_dirtied);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should be &#x3C; 50ns per barrier on modern hardware</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(ns_per_barrier </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-characteristics\">Performance Characteristics</h2>\n<h3 id=\"write-barrier-overhead\">Write Barrier Overhead</h3>\n<table>\n<thead>\n<tr>\n<th>Barrier Type</th>\n<th>Cost per Write</th>\n<th>Memory Overhead</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>None</strong></td>\n<td>0 ns</td>\n<td>0%</td>\n<td>Stop-the-world GC</td>\n</tr>\n<tr>\n<td><strong>SATB</strong></td>\n<td>5-10 ns</td>\n<td>0%</td>\n<td>Concurrent mark-sweep</td>\n</tr>\n<tr>\n<td><strong>Incremental</strong></td>\n<td>5-10 ns</td>\n<td>0%</td>\n<td>Incremental GC</td>\n</tr>\n<tr>\n<td><strong>Generational</strong></td>\n<td>10-20 ns</td>\n<td>0.2% (card table)</td>\n<td>Production systems</td>\n</tr>\n</tbody></table>\n<p><strong>Real-world impact</strong>: For a program that writes 1 million pointers/second, generational barriers add ~20ms overhead (2% of CPU time).</p>\n<hr>\n<h3 id=\"card-table-granularity-tradeoff\">Card Table Granularity Tradeoff</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Fine-grained (128 bytes/card):\n  âœ“ Precise: scan less memory during GC\n  âœ— More memory: 0.8% overhead\n  âœ— More cache misses\n\nCoarse-grained (4 KB/card):\n  âœ“ Less memory: 0.025% overhead\n  âœ“ Better cache behavior\n  âœ— Scan more memory during GC</code></pre></div>\n\n<p><strong>Sweet spot</strong>: 512 bytes/card (0.2% overhead, good cache behavior).</p>\n<hr>\n<h2 id=\"what-you39ve-mastered\">What You&#39;ve Mastered</h2>\n<p>âœ… <strong>Write barrier fundamentals</strong>: Why they&#39;re needed for advanced GC<br>âœ… <strong>Three barrier types</strong>: SATB, incremental, generational<br>âœ… <strong>Card table implementation</strong>: Efficient cross-generation tracking<br>âœ… <strong>Barrier integration</strong>: Hooking into pointer writes<br>âœ… <strong>Performance optimization</strong>: Minimizing barrier overhead<br>âœ… <strong>Debugging techniques</strong>: Catching missing barriers  </p>\n<hr>\n<h2 id=\"next-steps\">Next Steps</h2>\n<p><strong>You now have the foundation for advanced garbage collectors!</strong> ğŸ‰</p>\n<p><strong>What&#39;s next?</strong></p>\n<ol>\n<li><strong><a href=\"#generational-gc\">â†’ Generational GC</a></strong>: Use write barriers to implement a full generational collector</li>\n<li><strong><a href=\"#incremental-gc\">â†’ Incremental GC</a></strong>: Spread GC work across allocations using incremental barriers</li>\n<li><strong><a href=\"#concurrent-gc\">â†’ Concurrent GC</a></strong>: Run GC in parallel with program using SATB barriers</li>\n<li><strong><a href=\"#compacting-gc\">â†’ Compacting GC</a></strong>: Move objects to eliminate fragmentation</li>\n</ol>\n<p><strong>Before continuing</strong>, verify your write barriers work correctly:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> ./test_write_barrier</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> SATB</span><span style=\"color:#9ECBFF\"> barrier</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Incremental</span><span style=\"color:#9ECBFF\"> barrier</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Generational</span><span style=\"color:#9ECBFF\"> barrier</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Card</span><span style=\"color:#9ECBFF\"> table</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> passed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Performance</span><span style=\"color:#9ECBFF\"> test:</span><span style=\"color:#79B8FF\"> 15.3</span><span style=\"color:#9ECBFF\"> ns/barrier</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Stress</span><span style=\"color:#9ECBFF\"> test:</span><span style=\"color:#9ECBFF\"> 1M</span><span style=\"color:#9ECBFF\"> barriers,</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#9ECBFF\"> crashes</span></span></code></pre></div>\n\n<p><strong>Pro tip</strong>: Enable <code>mprotect</code>-based barriers during development to catch all missing barriers, then switch to inline barriers for production.</p>\n<hr>\n<p><a href=\"#satellite-map\">â†‘ Back to System Map</a></p>\n<div id=\"ms-fragmentation\"></div>\n\n<h1 id=\"fragmentation-management-the-jigsaw-puzzle-problem\">Fragmentation Management: The Jigsaw Puzzle Problem</h1>\n<h2 id=\"the-epiphany-analogy-the-parking-lot-paradox\">The Epiphany Analogy: The Parking Lot Paradox</h2>\n<p>Imagine a parking lot with 100 spaces. Throughout the day:</p>\n<ul>\n<li>ğŸš— Cars arrive (allocations)</li>\n<li>ğŸš™ Cars leave (deallocations)</li>\n<li>ğŸš A bus arrives needing 3 consecutive spaces</li>\n</ul>\n<p>By evening, you have 50 empty spaces... but they&#39;re scattered! The bus can&#39;t park even though there&#39;s plenty of room. <strong>This is fragmentation.</strong></p>\n<p>Your memory heap faces the same problem:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Before fragmentation:\n[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] â† Contiguous free space\n\nAfter many alloc/free cycles:\n[â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–‘â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–‘â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆ] â† Swiss cheese memory\n  â†‘    â†‘         â†‘\n  Free but unusable for large allocations!</code></pre></div>\n\n<p><strong>The brutal truth</strong>: Without fragmentation management, your allocator will fail even when 50% of memory is free.</p>\n<hr>\n<h2 id=\"technical-rationale-why-fragmentation-kills-performance\">Technical Rationale: Why Fragmentation Kills Performance</h2>\n<h3 id=\"the-two-faces-of-fragmentation\">The Two Faces of Fragmentation</h3>\n<p><strong>1. External Fragmentation</strong> (the parking lot problem)</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Heap state after 1000 allocations:\nTotal memory: 1 MB\nFree memory: 512 KB (50%!)\nLargest contiguous block: 4 KB â† Can't allocate 64 KB!\n\nResult: Out-of-memory despite having space</code></pre></div>\n\n<p><strong>2. Internal Fragmentation</strong> (the waste within)</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Request: 65 bytes\nAllocated: 128 bytes (next power of 2)\nWasted: 63 bytes (49% waste!)\n\nOver 10,000 allocations: 630 KB wasted</code></pre></div>\n\n<h3 id=\"real-world-impact\">Real-World Impact</h3>\n<p><strong>Case study: Long-running server</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Hour 0:  Fragmentation: 5%  | Max alloc: 1 MB\nHour 24: Fragmentation: 35% | Max alloc: 128 KB\nHour 48: Fragmentation: 60% | Max alloc: 16 KB â† Death spiral!</code></pre></div>\n\n<p><strong>Without fragmentation management</strong>: Server crashes after 48 hours despite using only 40% of memory.</p>\n<hr>\n<h2 id=\"internal-mechanics-the-three-pronged-defense\">Internal Mechanics: The Three-Pronged Defense</h2>\n<h3 id=\"strategy-1-coalescing-immediate-neighbor-merging\">Strategy 1: Coalescing (Immediate Neighbor Merging)</h3>\n<p><strong>The concept</strong>: When you free a block, immediately merge it with adjacent free blocks.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Before free(B):\n[Used A][Used B][Free C][Free D][Used E]\n         â†“ free\n[Used A][Free B][Free C][Free D][Used E]\n         â†“ coalesce\n[Used A][Free B+C+D (contiguous!)][Used E]</code></pre></div>\n\n<p><strong>Why it works</strong>: Prevents fragmentation from accumulating in the first place.</p>\n<p>{{DIAGRAM:coalescing-process}}</p>\n<h3 id=\"strategy-2-compaction-the-nuclear-option\">Strategy 2: Compaction (The Nuclear Option)</h3>\n<p><strong>The concept</strong>: Move all live objects together, eliminating all gaps.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Before compaction:\n[â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–‘â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–‘â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆ]\n\nAfter compaction:\n[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] â† One giant free block!</code></pre></div>\n\n<p><strong>The cost</strong>: Must update every pointer in the program (expensive!).</p>\n<p>{{DIAGRAM:compaction-phases}}</p>\n<h3 id=\"strategy-3-segregated-free-lists-prevention\">Strategy 3: Segregated Free Lists (Prevention)</h3>\n<p><strong>The concept</strong>: Keep separate free lists for different size classes.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Small (8-64 bytes):   [16][32][24][48]...\nMedium (65-512 bytes): [128][256][384]...\nLarge (513+ bytes):    [1024][2048]...</code></pre></div>\n\n<p><strong>Why it works</strong>: Small allocations can&#39;t fragment large blocks.</p>\n<hr>\n<h2 id=\"implementation-coalescing-with-boundary-tags\">Implementation: Coalescing with Boundary Tags</h2>\n<h3 id=\"the-data-structure\">The Data Structure</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> FreeBlock {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">              // Size of this block (including header)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span><span style=\"color:#6A737D\">   // Next free block in list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> prev;</span><span style=\"color:#6A737D\">   // Previous free block in list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> magic;</span><span style=\"color:#6A737D\">           // Corruption detection (0xDEADBEEF)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} FreeBlock;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> BlockFooter {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">              // Duplicate of header size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> magic;</span><span style=\"color:#6A737D\">           // Corruption detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} BlockFooter;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Layout in memory:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// [FreeBlock header][...free space...][BlockFooter]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//  â†‘                                   â†‘</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//  size field                          size field (for backward coalescing)</span></span></code></pre></div>\n\n<p><strong>Key insight</strong>: The footer lets you find the previous block&#39;s size by looking backward!</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Get footer of current block</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> GET_FOOTER</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">block</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ((BlockFooter</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)(block) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> (block)->size </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(BlockFooter)))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get previous block (if it exists)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> GET_PREV_BLOCK</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">block</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ((FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)(block) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     ((BlockFooter</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)(block) </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(BlockFooter)))->size))</span></span></code></pre></div>\n\n<p>{{DIAGRAM:boundary-tags}}</p>\n<hr>\n<h2 id=\"the-coalescing-algorithm\">The Coalescing Algorithm</h2>\n<h3 id=\"step-by-step-breakdown\">Step-by-Step Breakdown</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    COALESCE_NONE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">      // No neighbors are free</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    COALESCE_PREV </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">      // Previous block is free</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    COALESCE_NEXT </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">      // Next block is free</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    COALESCE_BOTH </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#6A737D\">       // Both neighbors are free</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} CoalesceCase;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> coalesce_block</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // STEP 1: Determine which neighbors are free</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CoalesceCase case_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> COALESCE_NONE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if previous block is free</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> prev_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)block </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BlockFooter</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> prev_footer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (BlockFooter</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)block </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(BlockFooter));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (prev_footer->magic </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            prev_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            case_type </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> COALESCE_PREV;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if next block is free</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> next_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)block </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> block->size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)next_block </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (next_block->magic </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            next_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            case_type </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> COALESCE_NEXT;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // STEP 2: Handle each case</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (case_type) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> COALESCE_NONE:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> coalesce_none</span><span style=\"color:#E1E4E8\">(gc, block);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> COALESCE_PREV:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> coalesce_prev</span><span style=\"color:#E1E4E8\">(gc, block);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> COALESCE_NEXT:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> coalesce_next</span><span style=\"color:#E1E4E8\">(gc, block);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> COALESCE_BOTH:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> coalesce_both</span><span style=\"color:#E1E4E8\">(gc, block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"case-1-no-coalescing-needed\">Case 1: No Coalescing Needed</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> coalesce_none</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Just add to free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->free_list) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->free_list->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set footer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BlockFooter</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> footer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_FOOTER</span><span style=\"color:#E1E4E8\">(block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    footer->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    footer->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.fragmentation_events</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"case-2-coalesce-with-previous-block\">Case 2: Coalesce with Previous Block</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> coalesce_prev</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get previous block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> prev_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_PREV_BLOCK</span><span style=\"color:#E1E4E8\">(block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove prev_block from free list (we'll re-add the merged block)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (prev_block->prev) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        prev_block->prev->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> prev_block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> prev_block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (prev_block->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        prev_block->next->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> prev_block->prev;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Merge: prev_block absorbs current block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    prev_block->size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update footer (now at end of merged block)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BlockFooter</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> footer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_FOOTER</span><span style=\"color:#E1E4E8\">(prev_block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    footer->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> prev_block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    footer->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Re-add to free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    prev_block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    prev_block->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->free_list) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->free_list->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> prev_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> prev_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.coalesce_prev_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> prev_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"case-3-coalesce-with-next-block\">Case 3: Coalesce with Next Block</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> coalesce_next</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)block </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> block->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove next_block from free list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (next_block->prev) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next_block->prev->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next_block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next_block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (next_block->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next_block->next->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next_block->prev;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Merge: current block absorbs next block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> next_block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update footer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BlockFooter</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> footer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_FOOTER</span><span style=\"color:#E1E4E8\">(block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    footer->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    footer->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add to free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->free_list) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->free_list->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.coalesce_next_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"case-4-coalesce-with-both-neighbors\">Case 4: Coalesce with Both Neighbors</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> coalesce_both</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> prev_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_PREV_BLOCK</span><span style=\"color:#E1E4E8\">(block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)block </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> block->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove both neighbors from free list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (Remove prev)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (prev_block->prev) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        prev_block->prev->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> prev_block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> prev_block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (prev_block->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        prev_block->next->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> prev_block->prev;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (Remove next)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (next_block->prev) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next_block->prev->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next_block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next_block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (next_block->next) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next_block->next->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next_block->prev;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Merge all three: prev absorbs current and next</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    prev_block->size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> next_block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update footer (now at end of triple-merged block)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BlockFooter</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> footer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_FOOTER</span><span style=\"color:#E1E4E8\">(prev_block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    footer->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> prev_block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    footer->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Re-add to free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    prev_block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    prev_block->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->free_list) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->free_list->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> prev_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> prev_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.coalesce_both_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> prev_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>{{DIAGRAM:coalesce-cases}}</p>\n<hr>\n<h2 id=\"implementation-compaction-optional\">Implementation: Compaction (Optional)</h2>\n<h3 id=\"when-to-compact\">When to Compact</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> CompactionPolicy {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> fragmentation_threshold;</span><span style=\"color:#6A737D\">  // Compact when fragmentation > this</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> min_heap_size;</span><span style=\"color:#6A737D\">           // Don't compact small heaps</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> last_compaction_time;</span><span style=\"color:#6A737D\">  // Rate limiting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> min_time_between_ms;</span><span style=\"color:#6A737D\">   // Minimum time between compactions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} CompactionPolicy;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> should_compact</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CompactionPolicy</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> policy </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">gc->compaction_policy;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate fragmentation ratio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> calculate_total_free_memory</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> largest_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> find_largest_free_block</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> fragmentation </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">float</span><span style=\"color:#E1E4E8\">)largest_block </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">float</span><span style=\"color:#E1E4E8\">)total_free);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check conditions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fragmentation </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> policy->fragmentation_threshold) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Not fragmented enough</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (gc->heap_size </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> policy->min_heap_size) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Heap too small to bother</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_time_ms</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (now </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> policy->last_compaction_time </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> policy->min_time_between_ms) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Too soon since last compaction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"the-compaction-algorithm-three-pass\">The Compaction Algorithm (Three-Pass)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> compact_heap</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_time_us</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // PASS 1: Calculate new addresses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> new_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (obj->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // This object survives - record its new address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            obj->forwarding_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            new_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)new_addr </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> obj->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> obj->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // PASS 2: Update all pointers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (obj->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            update_object_pointers</span><span style=\"color:#E1E4E8\">(gc, obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> obj->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update root pointers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    update_root_pointers</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // PASS 3: Move objects to new locations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (obj->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            void*</span><span style=\"color:#E1E4E8\"> new_location </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> obj->forwarding_ptr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (new_location </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> obj) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                memmove</span><span style=\"color:#E1E4E8\">(new_location, obj, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> obj->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> obj->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Reset free list (now one giant block at the end)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)new_addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)new_addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> duration </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_time_us</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.compaction_time_us </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> duration;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.compaction_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->compaction_policy.last_compaction_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_time_ms</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"updating-pointers-during-compaction\">Updating Pointers During Compaction</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> update_object_pointers</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scan object for pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void**</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> obj->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> end) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> target </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if this looks like a heap pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (target </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> gc->heap_start </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            target </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> target_header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(target);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Update to forwarding address</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (target_header->forwarding_ptr) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                *</span><span style=\"color:#E1E4E8\">ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)target_header->forwarding_ptr </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ptr</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> update_root_pointers</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> gc->root_count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void**</span><span style=\"color:#E1E4E8\"> root </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->roots[i];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> target </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">root;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (target </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> gc->heap_start </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            target </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> target_header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_HEADER</span><span style=\"color:#E1E4E8\">(target);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (target_header->forwarding_ptr) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                *</span><span style=\"color:#E1E4E8\">root </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)target_header->forwarding_ptr </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>{{DIAGRAM:compaction-three-pass}}</p>\n<hr>\n<h2 id=\"the-debugging-lab-common-fragmentation-bugs\">The Debugging Lab: Common Fragmentation Bugs</h2>\n<h3 id=\"bug-1-forgetting-to-coalesce\">Bug 1: Forgetting to Coalesce</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// âŒ WRONG: Just add to free list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_free_wrong</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Missing: coalesce_block(gc, block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Result after 1000 frees:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// [Free 64][Free 64][Free 64][Free 64]... â† Can't allocate 256 bytes!</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Always coalesce on free:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_free_correct</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    coalesce_block</span><span style=\"color:#E1E4E8\">(gc, block);</span><span style=\"color:#6A737D\">  // âœ“ Merge with neighbors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"bug-2-corrupted-boundary-tags\">Bug 2: Corrupted Boundary Tags</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// âŒ WRONG: Overwrite footer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> gc_alloc_wrong</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> find_free_block</span><span style=\"color:#E1E4E8\">(gc, size);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... split block ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Forgot to update footer!</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)block </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Later, during coalescing:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BlockFooter</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> footer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_FOOTER</span><span style=\"color:#E1E4E8\">(block);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// footer->size is garbage! â† Crash or corruption</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Always maintain footer invariant:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> update_block_footer</span><span style=\"color:#E1E4E8\">(FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BlockFooter</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> footer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> GET_FOOTER</span><span style=\"color:#E1E4E8\">(block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    footer->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    footer->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"bug-3-compaction-without-updating-all-pointers\">Bug 3: Compaction Without Updating All Pointers</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// âŒ WRONG: Forgot to update stack pointers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> compact_heap_wrong</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... calculate new addresses ...</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... update heap pointers ...</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... move objects ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Missing: update_stack_pointers(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Result: Stack still points to old addresses!</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stack_var;</span><span style=\"color:#6A737D\">  // Points to old location</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">obj</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">field </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 42</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">        // â† Writes to freed memory! Crash!</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Update ALL pointer sources:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> compact_heap_correct</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    calculate_new_addresses</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    update_heap_pointers</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    update_root_pointers</span><span style=\"color:#E1E4E8\">(gc);</span><span style=\"color:#6A737D\">      // âœ“ Roots</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    update_stack_pointers</span><span style=\"color:#E1E4E8\">(gc);</span><span style=\"color:#6A737D\">     // âœ“ Stack</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    update_register_pointers</span><span style=\"color:#E1E4E8\">(gc);</span><span style=\"color:#6A737D\">  // âœ“ Registers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    move_objects</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"debugging-tool-fragmentation-visualizer\">Debugging Tool: Fragmentation Visualizer</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> visualize_fragmentation</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">Heap Fragmentation Map:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Legend: â–ˆ=used â–‘=free</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t*</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> col </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> end) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (obj->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â–ˆ\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Used</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â–‘\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Free</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> obj->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">col </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 80</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            col </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    print_fragmentation_stats</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> print_fragmentation_stats</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> largest_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> num_free_blocks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (block) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_free </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (block->size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> largest_block) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            largest_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        num_free_blocks</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> fragmentation </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">float</span><span style=\"color:#E1E4E8\">)largest_block </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">float</span><span style=\"color:#E1E4E8\">)total_free);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Fragmentation Statistics:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Total free: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes (</span><span style=\"color:#79B8FF\">%.1f%%</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           total_free, </span><span style=\"color:#79B8FF\">100.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> total_free </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> gc->heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Largest block: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, largest_block);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Free blocks: </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, num_free_blocks);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Fragmentation: </span><span style=\"color:#79B8FF\">%.1f%%\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, fragmentation </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Coalesce events: prev=</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> next=</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> both=</span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           gc->stats.coalesce_prev_count,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           gc->stats.coalesce_next_count,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           gc->stats.coalesce_both_count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>{{DIAGRAM:fragmentation-visualizer}}</p>\n<hr>\n<h2 id=\"code-scaffold-your-tasks\">Code Scaffold: Your Tasks</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ============================================================================</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FRAGMENTATION MANAGEMENT IMPLEMENTATION</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ============================================================================</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FREE_BLOCK_MAGIC</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">DEADBEEF</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> USED_BLOCK_MAGIC</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">CAFEBABE</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> FreeBlock {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> prev;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> magic;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} FreeBlock;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> BlockFooter {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> magic;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} BlockFooter;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> FragmentationStats {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> coalesce_prev_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> coalesce_next_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> coalesce_both_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> fragmentation_events;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> compaction_count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> compaction_time_us;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} FragmentationStats;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 1: Implement boundary tag helpers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">BlockFooter</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> get_block_footer</span><span style=\"color:#E1E4E8\">(FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate footer address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: footer is at (block + block->size - sizeof(BlockFooter))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Replace this</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> get_prev_block</span><span style=\"color:#E1E4E8\">(FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Get previous block using its footer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   1. Get footer at (block - sizeof(BlockFooter))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   2. Read its size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   3. Calculate prev block start</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Replace this</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> get_next_block</span><span style=\"color:#E1E4E8\">(FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate next block address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: next = block + block->size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Replace this</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 2: Check if a block is free</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_block_free</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> heap_start</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> heap_end</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if block is within heap bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (block </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> heap_start </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> heap_end) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check magic number</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> fb </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)block;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return true if magic == FREE_BLOCK_MAGIC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Replace this</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 3: Initialize a free block with boundary tags</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_free_block</span><span style=\"color:#E1E4E8\">(FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set header fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->magic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set footer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BlockFooter</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> footer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_block_footer</span><span style=\"color:#E1E4E8\">(block);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set footer->size and footer->magic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 4: Implement coalesce_none</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> coalesce_none</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize block as free</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_free_block</span><span style=\"color:#E1E4E8\">(block, block->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add to head of free list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   block->next = gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   if (gc->free_list) gc->free_list->prev = block;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   gc->free_list = block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.fragmentation_events</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 5: Implement coalesce_prev</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> coalesce_prev</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Get previous block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> prev_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_prev_block</span><span style=\"color:#E1E4E8\">(block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Remove prev_block from free list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Update prev/next pointers of neighbors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Merge blocks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    prev_block->size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update footer of merged block</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_free_block</span><span style=\"color:#E1E4E8\">(prev_block, prev_block->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Re-add to free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.coalesce_prev_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> prev_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 6: Implement coalesce_next</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> coalesce_next</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Get next block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_next_block</span><span style=\"color:#E1E4E8\">(block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Remove next_block from free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Merge blocks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block->size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> next_block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update footer</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_free_block</span><span style=\"color:#E1E4E8\">(block, block->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add to free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.coalesce_next_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 7: Implement coalesce_both</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> coalesce_both</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Get both neighbors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> prev_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_prev_block</span><span style=\"color:#E1E4E8\">(block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_next_block</span><span style=\"color:#E1E4E8\">(block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Remove both from free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Merge all three blocks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    prev_block->size </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> next_block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update footer</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_free_block</span><span style=\"color:#E1E4E8\">(prev_block, prev_block->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Re-add to free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.coalesce_both_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> prev_block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 8: Implement main coalesce function</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> coalesce_block</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> block</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if previous block is free</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> prev_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)block </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_prev_block</span><span style=\"color:#E1E4E8\">(block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        prev_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> is_block_free</span><span style=\"color:#E1E4E8\">(prev, gc->heap_start, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                   (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if next block is free</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> next_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_next_block</span><span style=\"color:#E1E4E8\">(block);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)next </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        next_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> is_block_free</span><span style=\"color:#E1E4E8\">(next, gc->heap_start,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                   (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Call appropriate coalesce function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (prev_free </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> next_free) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> coalesce_both</span><span style=\"color:#E1E4E8\">(gc, block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (prev_free) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> coalesce_prev</span><span style=\"color:#E1E4E8\">(gc, block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (next_free) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> coalesce_next</span><span style=\"color:#E1E4E8\">(gc, block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> coalesce_none</span><span style=\"color:#E1E4E8\">(gc, block);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 9: Calculate fragmentation ratio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">float</span><span style=\"color:#B392F0\"> calculate_fragmentation</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate total free memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_free </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> largest_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->free_list;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (block) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_free </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (block->size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> largest_block) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            largest_block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate fragmentation ratio</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Formula: 1.0 - (largest_block / total_free)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (total_free </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Replace with calculation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 10: Implement compaction (OPTIONAL - Advanced)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> compact_heap</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // PASS 1: Calculate new addresses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> new_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (obj->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Record forwarding address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            obj->forwarding_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            new_addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)new_addr </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> obj->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> obj->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // PASS 2: Update pointers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update all object pointers to use forwarding addresses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // PASS 3: Move objects</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (obj->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            void*</span><span style=\"color:#E1E4E8\"> new_location </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> obj->forwarding_ptr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (new_location </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> obj) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Move object to new location</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                memmove</span><span style=\"color:#E1E4E8\">(new_location, obj, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> obj->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)obj </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> obj->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Reset free list to one giant block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)new_addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->free_list->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)new_addr;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_free_block</span><span style=\"color:#E1E4E8\">(gc->free_list, gc->free_list->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc->stats.compaction_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"testing-your-fragmentation-management\">Testing Your Fragmentation Management</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_coalescing_basic</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate 5 blocks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> d </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> e </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free alternating blocks: [A][free][C][free][E]</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, b);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, d);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should have 2 free blocks</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">count_free_blocks</span><span style=\"color:#E1E4E8\">(gc) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free C: should coalesce B+C+D into one block</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, c);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should now have 1 free block (B+C+D merged)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">count_free_blocks</span><span style=\"color:#E1E4E8\">(gc) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify we can allocate 192 bytes (3 * 64)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> large </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">192</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(large </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Basic coalescing test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_coalescing_all_cases</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test COALESCE_NONE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> a1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> a2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> a3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, a2);</span><span style=\"color:#6A737D\">  // Surrounded by used blocks</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->stats.fragmentation_events </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test COALESCE_PREV</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, a1);</span><span style=\"color:#6A737D\">  // Should merge with a2</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->stats.coalesce_prev_count </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test COALESCE_NEXT</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> b1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> b2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> b3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, b2);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, b3);</span><span style=\"color:#6A737D\">  // Should merge with b2</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->stats.coalesce_next_count </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test COALESCE_BOTH</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> c1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> c2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> c3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> c4 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, c1);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, c3);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, c2);</span><span style=\"color:#6A737D\">  // Should merge c1+c2+c3</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->stats.coalesce_both_count </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ All coalescing cases test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_fragmentation_measurement</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create severe fragmentation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> objects </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        objects</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free every other object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        gc_free</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#FFAB70\">objects</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Measure fragmentation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> frag </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> calculate_fragmentation</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should be highly fragmented (many small blocks)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(frag </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0.9</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // > 90% fragmented</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Fragmentation measurement: </span><span style=\"color:#79B8FF\">%.1f%%\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, frag </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free remaining objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        gc_free</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#FFAB70\">objects</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should now be fully coalesced</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">count_free_blocks</span><span style=\"color:#E1E4E8\">(gc) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    frag </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> calculate_fragmentation</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(frag </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.01</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // &#x3C; 1% fragmented</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ After coalescing: </span><span style=\"color:#79B8FF\">%.1f%%</span><span style=\"color:#9ECBFF\"> fragmented</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, frag </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_compaction</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate and fragment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> objects </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        objects</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark every 10th object as root</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        gc_add_root</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">objects</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free non-roots</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            gc_free</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#FFAB70\">objects</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Measure fragmentation before compaction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> frag_before </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> calculate_fragmentation</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Fragmentation before: </span><span style=\"color:#79B8FF\">%.1f%%\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, frag_before </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Compact</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    compact_heap</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Measure after</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    float</span><span style=\"color:#E1E4E8\"> frag_after </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> calculate_fragmentation</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Fragmentation after: </span><span style=\"color:#79B8FF\">%.1f%%\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, frag_after </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should be nearly zero fragmentation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(frag_after </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.01</span><span style=\"color:#F97583\">f</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify objects are still accessible</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">objects</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Object should have moved</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Compaction test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_boundary_tag_corruption</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify footer is correct</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block_a </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)((</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)a </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(FreeBlock));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BlockFooter</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> footer_a </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_block_footer</span><span style=\"color:#E1E4E8\">(block_a);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(footer_a->magic </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> FREE_BLOCK_MAGIC);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(footer_a->size </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> block_a->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Free and verify coalescing works</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, a);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_free</span><span style=\"color:#E1E4E8\">(gc, b);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should have coalesced</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">count_free_blocks</span><span style=\"color:#E1E4E8\">(gc) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Boundary tag integrity test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-characteristics\">Performance Characteristics</h2>\n<h3 id=\"coalescing-overhead\">Coalescing Overhead</h3>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Without Coalescing</th>\n<th>With Coalescing</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Free</strong></td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><strong>Alloc (fragmented)</strong></td>\n<td>O(n) search</td>\n<td>O(1) best-fit</td>\n</tr>\n<tr>\n<td><strong>Memory waste</strong></td>\n<td>50-80%</td>\n<td>5-10%</td>\n</tr>\n</tbody></table>\n<p><strong>Key insight</strong>: Coalescing adds ~10ns per free, but prevents catastrophic fragmentation.</p>\n<h3 id=\"compaction-cost\">Compaction Cost</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Heap size: 100 MB\nLive objects: 40 MB (40%)\nCompaction time: ~50ms\n\nBreakdown:\n  Pass 1 (calculate): 10ms\n  Pass 2 (update ptrs): 25ms â† Most expensive!\n  Pass 3 (move): 15ms</code></pre></div>\n\n<p><strong>When to compact</strong>: Only when fragmentation &gt; 60% and allocation fails.</p>\n<hr>\n<h2 id=\"what-you39ve-mastered\">What You&#39;ve Mastered</h2>\n<p>âœ… <strong>Fragmentation fundamentals</strong>: External vs internal fragmentation<br>âœ… <strong>Coalescing algorithm</strong>: Four-case boundary tag coalescing<br>âœ… <strong>Boundary tags</strong>: Efficient bidirectional merging<br>âœ… <strong>Fragmentation measurement</strong>: Quantifying memory waste<br>âœ… <strong>Compaction</strong>: Three-pass object relocation (optional)<br>âœ… <strong>Debugging techniques</strong>: Visualizing and fixing fragmentation bugs  </p>\n<hr>\n<h2 id=\"next-steps\">Next Steps</h2>\n<p><strong>You now have a production-grade memory allocator!</strong> ğŸ‰</p>\n<p><strong>What&#39;s next?</strong></p>\n<ol>\n<li><strong><a href=\"#generational-gc\">â†’ Generational GC</a></strong>: Combine fragmentation management with generational collection</li>\n<li><strong><a href=\"#concurrent-gc\">â†’ Concurrent GC</a></strong>: Handle fragmentation while program runs</li>\n<li><strong><a href=\"#memory-pools\">â†’ Memory Pools</a></strong>: Prevent fragmentation through segregated allocation</li>\n<li><strong><a href=\"#performance-tuning\">â†’ Performance Tuning</a></strong>: Optimize coalescing for your workload</li>\n</ol>\n<p><strong>Before continuing</strong>, verify your fragmentation management works:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> ./test_fragmentation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Basic</span><span style=\"color:#9ECBFF\"> coalescing:</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#9ECBFF\"> blocks</span><span style=\"color:#9ECBFF\"> â†’</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#9ECBFF\"> block</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> All</span><span style=\"color:#9ECBFF\"> cases:</span><span style=\"color:#9ECBFF\"> prev=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#9ECBFF\"> next=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#9ECBFF\"> both=</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Fragmentation:</span><span style=\"color:#9ECBFF\"> 95.2%</span><span style=\"color:#9ECBFF\"> â†’</span><span style=\"color:#9ECBFF\"> 0.3%</span><span style=\"color:#9ECBFF\"> after</span><span style=\"color:#9ECBFF\"> coalescing</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Compaction:</span><span style=\"color:#9ECBFF\"> 58.7%</span><span style=\"color:#9ECBFF\"> â†’</span><span style=\"color:#9ECBFF\"> 0.1%</span><span style=\"color:#9ECBFF\"> fragmentation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Boundary</span><span style=\"color:#9ECBFF\"> tags:</span><span style=\"color:#9ECBFF\"> no</span><span style=\"color:#9ECBFF\"> corruption</span><span style=\"color:#9ECBFF\"> detected</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> Stress</span><span style=\"color:#9ECBFF\"> test:</span><span style=\"color:#9ECBFF\"> 10K</span><span style=\"color:#9ECBFF\"> alloc/free</span><span style=\"color:#9ECBFF\"> cycles,</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#9ECBFF\"> leaks</span></span></code></pre></div>\n\n<p><strong>Pro tip</strong>: Use <code>visualize_fragmentation()</code> during development to see exactly where fragmentation occurs. It&#39;s like an X-ray for your heap!</p>\n<hr>\n<p><a href=\"#satellite-map\">â†‘ Back to System Map</a></p>\n<div id=\"ms-performance\"></div>\n\n<h1 id=\"performance-optimization-making-your-gc-blazingly-fast\">Performance Optimization: Making Your GC Blazingly Fast</h1>\n<h2 id=\"epiphany-analogy-the-formula-1-pit-stop\">Epiphany Analogy: The Formula 1 Pit Stop</h2>\n<p>Imagine a Formula 1 pit crew. They don&#39;t just change tiresâ€”they&#39;ve optimized every microsecond:</p>\n<ul>\n<li><strong>Tire changers</strong> position themselves before the car arrives (cache prefetching)</li>\n<li><strong>Tools</strong> are arranged in order of use (cache-friendly data layout)</li>\n<li><strong>Multiple crew members</strong> work simultaneously (parallelization)</li>\n<li><strong>Movements</strong> are choreographed to avoid collisions (false sharing prevention)</li>\n</ul>\n<p>Your GC is the same: a well-optimized collector can be <strong>10-100x faster</strong> than a naive implementation. The difference between &quot;my program stutters&quot; and &quot;I didn&#39;t even notice GC ran.&quot;</p>\n<hr>\n<h2 id=\"technical-rationale-why-performance-matters\">Technical Rationale: Why Performance Matters</h2>\n<h3 id=\"the-gc-tax\">The GC Tax</h3>\n<p>Every GC cycle steals time from your application:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Naive GC:     100ms pause every 1 second  â†’ 10% overhead\nOptimized GC:   5ms pause every 1 second  â†’ 0.5% overhead</code></pre></div>\n\n<p><strong>Real-world impact:</strong></p>\n<ul>\n<li><strong>Video games</strong>: 100ms pause = dropped frames, player notices lag</li>\n<li><strong>Web servers</strong>: 100ms pause = 1000 requests queued up</li>\n<li><strong>Trading systems</strong>: 100ms pause = millions of dollars lost</li>\n</ul>\n<h3 id=\"the-three-optimization-targets\">The Three Optimization Targets</h3>\n<ol>\n<li><strong>Mark phase</strong>: Traverse object graph (CPU + cache bound)</li>\n<li><strong>Sweep phase</strong>: Scan entire heap (memory bandwidth bound)</li>\n<li><strong>Allocation</strong>: Find free blocks (data structure bound)</li>\n</ol>\n<p>We&#39;ll optimize each independently.</p>\n<hr>\n<h2 id=\"internal-mechanics-cache-friendly-marking\">Internal Mechanics: Cache-Friendly Marking</h2>\n<h3 id=\"the-problem-cache-misses-kill-performance\">The Problem: Cache Misses Kill Performance</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// NAIVE: Random memory access pattern</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_naive</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (obj->marked) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    obj->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Chase pointers randomly through heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> obj->ptr_count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mark_naive</span><span style=\"color:#E1E4E8\">(gc, obj->pointers[i]);</span><span style=\"color:#6A737D\">  // â† Cache miss!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Problem</strong>: Each pointer dereference is a <strong>cache miss</strong> (100+ cycles).</p>\n<p><strong>Solution</strong>: Breadth-first traversal with prefetching.</p>\n<h3 id=\"cache-friendly-bfs-marking\">Cache-Friendly BFS Marking</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> queue;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> capacity;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> head;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> tail;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} MarkQueue;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// OPTIMIZED: Sequential access + prefetching</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_bfs_optimized</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> root</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MarkQueue queue;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_mark_queue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue, </span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    enqueue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue, root);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Process in batches for better cache utilization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> batch_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> min</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">queue_size</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> batch_size; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (obj->marked) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            obj->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Prefetch next objects while processing current</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#E1E4E8\"> batch_size) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                void*</span><span style=\"color:#E1E4E8\"> prefetch_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> peek</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue, i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                __builtin_prefetch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">get_header</span><span style=\"color:#E1E4E8\">(prefetch_ptr), </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Add children to queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> obj->ptr_count; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                enqueue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue, obj->pointers[j]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_mark_queue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Key optimizations:</strong></p>\n<ol>\n<li><strong>BFS instead of DFS</strong>: Better cache locality (process nearby objects together)</li>\n<li><strong>Batch processing</strong>: Amortize queue overhead</li>\n<li><strong>Prefetching</strong>: Tell CPU to load data before we need it</li>\n<li><strong>Sequential queue</strong>: Array-based queue is cache-friendly</li>\n</ol>\n<p>{{DIAGRAM:cache-friendly-marking}}</p>\n<hr>\n<h2 id=\"bitmap-marking-separate-metadata-from-data\">Bitmap Marking: Separate Metadata from Data</h2>\n<h3 id=\"the-problem-false-sharing\">The Problem: False Sharing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// BAD: Marking writes to object headers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> ObjectHeader {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> marked;</span><span style=\"color:#6A737D\">  // â† Writing this invalidates cache line!</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... other fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Problem</strong>: Marking one object invalidates the cache line containing nearby objects.</p>\n<h3 id=\"solution-external-bitmap\">Solution: External Bitmap</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t*</span><span style=\"color:#E1E4E8\"> bitmap;</span><span style=\"color:#6A737D\">      // 1 bit per 8 bytes of heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bitmap_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} MarkBitmap;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize bitmap (1 bit per 8-byte word)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> create_mark_bitmap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> heap_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> bm </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(MarkBitmap));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bm->bitmap_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (heap_size </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 63</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Round up to uint64_t</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bm->bitmap </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> calloc</span><span style=\"color:#E1E4E8\">(bm->bitmap_size, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> bm;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Mark object using bitmap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> bitmap_mark</span><span style=\"color:#E1E4E8\">(MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> bm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> heap_start</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> word_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bit_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bm->bitmap[word_index] </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">ULL</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> bit_index);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check if marked</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> bitmap_is_marked</span><span style=\"color:#E1E4E8\">(MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> bm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> heap_start</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> word_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bit_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (bm->bitmap[word_index] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">ULL</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> bit_index)) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Clear all marks (fast!)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> bitmap_clear</span><span style=\"color:#E1E4E8\">(MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> bm</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(bm->bitmap, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, bm->bitmap_size </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Benefits:</strong></p>\n<ul>\n<li><strong>No false sharing</strong>: Bitmap is separate from object data</li>\n<li><strong>Fast clearing</strong>: <code>memset()</code> is highly optimized</li>\n<li><strong>Cache-friendly</strong>: Bitmap is densely packed</li>\n<li><strong>Parallel-friendly</strong>: Different threads can mark different bitmap regions</li>\n</ul>\n<p>{{DIAGRAM:bitmap-marking}}</p>\n<hr>\n<h2 id=\"parallel-sweep-multi-threaded-heap-scanning\">Parallel Sweep: Multi-threaded Heap Scanning</h2>\n<h3 id=\"the-problem-sweep-is-sequential\">The Problem: Sweep is Sequential</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// SLOW: Single-threaded sweep</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sweep_sequential</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t*</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> end) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">obj->marked) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            gc_free</span><span style=\"color:#E1E4E8\">(gc, ptr </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            obj->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Clear for next cycle</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> obj->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Problem</strong>: Sweeping 1GB heap takes ~50ms on single core.</p>\n<h3 id=\"solution-parallel-region-sweep\">Solution: Parallel Region Sweep</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t*</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t*</span><span style=\"color:#E1E4E8\"> end;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> bitmap;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Per-thread results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> freed_bytes;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> freed_objects;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> local_free_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SweepTask;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> sweep_worker</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SweepTask</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> task </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (SweepTask</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> task->start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> local_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> task->end) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">bitmap_is_marked</span><span style=\"color:#E1E4E8\">(task->bitmap, task->gc->heap_start, ptr)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Object is dead - add to local free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            block->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> obj->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            block->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> local_list;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            local_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            task->freed_bytes </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            task->freed_objects</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(ObjectHeader) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> obj->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    task->local_free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> local_list;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sweep_parallel</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> bitmap</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> num_threads</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_t</span><span style=\"color:#FFAB70\"> threads</span><span style=\"color:#E1E4E8\">[num_threads];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SweepTask </span><span style=\"color:#FFAB70\">tasks</span><span style=\"color:#E1E4E8\">[num_threads];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> region_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->heap_size </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> num_threads;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Launch worker threads</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_threads; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        tasks</span><span style=\"color:#E1E4E8\">[i].gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        tasks</span><span style=\"color:#E1E4E8\">[i].start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> region_size);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        tasks</span><span style=\"color:#E1E4E8\">[i].end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> num_threads </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            ?</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)gc->heap_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> gc->heap_size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            :</span><span style=\"color:#FFAB70\"> tasks</span><span style=\"color:#E1E4E8\">[i].start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> region_size;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        tasks</span><span style=\"color:#E1E4E8\">[i].bitmap </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> bitmap;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        tasks</span><span style=\"color:#E1E4E8\">[i].freed_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        tasks</span><span style=\"color:#E1E4E8\">[i].freed_objects </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        tasks</span><span style=\"color:#E1E4E8\">[i].local_free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">threads</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, sweep_worker, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">tasks</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Wait for completion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_threads; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        pthread_join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">threads</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Merge free lists (single-threaded, but fast)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_threads; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> tasks</span><span style=\"color:#E1E4E8\">[i].local_free_list;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (block) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            add_to_free_list</span><span style=\"color:#E1E4E8\">(gc, block);</span><span style=\"color:#6A737D\">  // Your existing function</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->stats.bytes_freed </span><span style=\"color:#F97583\">+=</span><span style=\"color:#FFAB70\"> tasks</span><span style=\"color:#E1E4E8\">[i].freed_bytes;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc->stats.objects_freed </span><span style=\"color:#F97583\">+=</span><span style=\"color:#FFAB70\"> tasks</span><span style=\"color:#E1E4E8\">[i].freed_objects;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Key insights:</strong></p>\n<ul>\n<li><strong>No locks during sweep</strong>: Each thread owns a heap region</li>\n<li><strong>Local free lists</strong>: Avoid contention</li>\n<li><strong>Merge at end</strong>: Single-threaded merge is fast (just pointer manipulation)</li>\n</ul>\n<p><strong>Performance</strong>: 4 threads â†’ 3.5x speedup (not 4x due to merge overhead)</p>\n<p>{{DIAGRAM:parallel-sweep}}</p>\n<hr>\n<h2 id=\"the-debugging-lab-measuring-performance\">The Debugging Lab: Measuring Performance</h2>\n<h3 id=\"micro-benchmarking-framework\">Micro-Benchmarking Framework</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> total_ns;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} PerfCounter;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> timespec ts;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    clock_gettime</span><span style=\"color:#E1E4E8\">(CLOCK_MONOTONIC, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ts);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ts.tv_sec </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1000000000</span><span style=\"color:#F97583\">ULL</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> ts.tv_nsec;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PERF_START</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">counter</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> _start_##counter </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PERF_END</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">counter</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    do</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> _end </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        counter.total_ns </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> (_end </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> _start_##counter); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        counter.count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Usage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">PerfCounter mark_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"Mark\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">PerfCounter sweep_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"Sweep\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_collect_instrumented</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    PERF_START</span><span style=\"color:#E1E4E8\">(mark_time);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    PERF_END</span><span style=\"color:#E1E4E8\">(mark_time);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    PERF_START</span><span style=\"color:#E1E4E8\">(sweep_time);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sweep_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    PERF_END</span><span style=\"color:#E1E4E8\">(sweep_time);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> print_perf_stats</span><span style=\"color:#E1E4E8\">(PerfCounter</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> counter</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> avg_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (counter->total_ns </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> counter->count) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1000000.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms avg (</span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> calls)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           counter->name, avg_ms, counter->count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"cache-miss-profiling-linux\">Cache Miss Profiling (Linux)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/perf_event.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/syscall.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> cache_misses;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> cache_refs;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} CacheProfiler;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">CacheProfiler</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> create_cache_profiler</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CacheProfiler</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> prof </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(CacheProfiler));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> perf_event_attr pe </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pe.type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PERF_TYPE_HARDWARE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pe.size </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(pe);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pe.config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PERF_COUNT_HW_CACHE_MISSES;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pe.disabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pe.exclude_kernel </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    prof->fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> syscall</span><span style=\"color:#E1E4E8\">(__NR_perf_event_open, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pe, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> prof;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> profile_mark_phase</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, CacheProfiler</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> prof</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ioctl</span><span style=\"color:#E1E4E8\">(prof->fd, PERF_EVENT_IOC_RESET, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ioctl</span><span style=\"color:#E1E4E8\">(prof->fd, PERF_EVENT_IOC_ENABLE, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ioctl</span><span style=\"color:#E1E4E8\">(prof->fd, PERF_EVENT_IOC_DISABLE, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    read</span><span style=\"color:#E1E4E8\">(prof->fd, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">prof->cache_misses, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cache misses: </span><span style=\"color:#79B8FF\">%lu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, prof->cache_misses);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"common-performance-bugs\">Common Performance Bugs</h3>\n<h4 id=\"bug-1-unnecessary-pointer-chasing\">Bug 1: Unnecessary Pointer Chasing</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// BAD: Dereference header multiple times</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_slow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">get_header</span><span style=\"color:#E1E4E8\">(ptr)->marked) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Dereference 1</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    get_header</span><span style=\"color:#E1E4E8\">(ptr)->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">          // Dereference 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(ptr)->ptr_count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span><span style=\"color:#6A737D\">  // Dereference 3</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mark_slow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">get_header</span><span style=\"color:#E1E4E8\">(ptr)->pointers[i]);</span><span style=\"color:#6A737D\">  // Dereference 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GOOD: Cache header pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_fast</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(ptr);</span><span style=\"color:#6A737D\">  // Single dereference</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (obj->marked) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    obj->marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> obj->ptr_count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mark_fast</span><span style=\"color:#E1E4E8\">(obj->pointers[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Impact</strong>: 4x fewer memory accesses â†’ 2x faster marking</p>\n<h4 id=\"bug-2-false-sharing-in-parallel-sweep\">Bug 2: False Sharing in Parallel Sweep</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// BAD: Shared counter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> freed_bytes;</span><span style=\"color:#6A737D\">  // â† All threads write here!</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_mutex_t</span><span style=\"color:#E1E4E8\"> lock;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} SharedStats;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> sweep_worker_slow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">stats->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats->freed_bytes </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size;</span><span style=\"color:#6A737D\">  // Contention!</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">stats->lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GOOD: Per-thread counters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> freed_bytes;</span><span style=\"color:#6A737D\">  // Each thread has its own</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> padding</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">    // Prevent false sharing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ThreadStats;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> sweep_worker_fast</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ThreadStats</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> my_stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">thread_stats</span><span style=\"color:#E1E4E8\">[thread_id];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    my_stats->freed_bytes </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> block->size;</span><span style=\"color:#6A737D\">  // No contention!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Impact</strong>: Eliminates lock contention â†’ 10x faster on 8+ cores</p>\n<p>{{DIAGRAM:false-sharing}}</p>\n<hr>\n<h2 id=\"code-scaffold-your-optimization-tasks\">Code Scaffold: Your Optimization Tasks</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ============================================</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PERFORMANCE OPTIMIZATION TASKS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ============================================</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 1: Implement cache-friendly BFS marking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_bfs_optimized</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> bitmap</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> root</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create mark queue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MarkQueue queue;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_mark_queue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue, </span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    enqueue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue, root);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_empty</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Process in batches of 16</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> batch_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Calculate batch size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> batch_size; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Skip if already marked</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Mark using bitmap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Prefetch next object (i + 4)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Enqueue children</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_mark_queue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">queue);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 2: Implement bitmap operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> bitmap_mark</span><span style=\"color:#E1E4E8\">(MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> bm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> heap_start</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate word_index (which uint64_t)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> word_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate bit_index (which bit in that uint64_t)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bit_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set the bit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // bm->bitmap[word_index] |= ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#B392F0\"> bitmap_is_marked</span><span style=\"color:#E1E4E8\">(MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> bm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> heap_start</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)ptr </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate indices</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> word_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bit_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if bit is set</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Replace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 3: Implement parallel sweep worker</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> sweep_worker</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SweepTask</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> task </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (SweepTask</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> task->start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> local_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Scan region from start to end</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> task->end) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Check if object is marked in bitmap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> is_marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Use bitmap_is_marked</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">is_marked) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Add to local free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Update statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            task->freed_bytes </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Calculate size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            task->freed_objects</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Advance to next object</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ptr </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Calculate offset</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    task->local_free_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> local_list;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 4: Implement parallel sweep coordinator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sweep_parallel</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> bitmap</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> num_threads</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_t</span><span style=\"color:#FFAB70\"> threads</span><span style=\"color:#E1E4E8\">[num_threads];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SweepTask </span><span style=\"color:#FFAB70\">tasks</span><span style=\"color:#E1E4E8\">[num_threads];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate region size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> region_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Launch worker threads</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_threads; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Initialize task</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        tasks</span><span style=\"color:#E1E4E8\">[i].gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        tasks</span><span style=\"color:#E1E4E8\">[i].start </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Calculate start</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        tasks</span><span style=\"color:#E1E4E8\">[i].end </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">    // Calculate end</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        tasks</span><span style=\"color:#E1E4E8\">[i].bitmap </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> bitmap;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Create thread</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // pthread_create(...)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Wait for all threads</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_threads; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // pthread_join(...)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Merge free lists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_threads; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> block </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> tasks</span><span style=\"color:#E1E4E8\">[i].local_free_list;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (block) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            FreeBlock</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block->next;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Add to global free list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            block </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 5: Implement prefetching hint</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> prefetch_object</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Use compiler builtin to prefetch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // __builtin_prefetch(ptr, read_write, locality)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // read_write: 0 = read, 1 = write</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // locality: 0-3 (3 = keep in all cache levels)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 6: Implement mark queue (ring buffer)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> buffer;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> capacity;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> head;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> tail;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} MarkQueue;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_mark_queue</span><span style=\"color:#E1E4E8\">(MarkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> q</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> capacity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Allocate buffer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    q->buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    q->capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> capacity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    q->head </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    q->tail </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    q->size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> enqueue</span><span style=\"color:#E1E4E8\">(MarkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> q</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if full (resize if needed)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (q->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> q->capacity) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Resize queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        size_t</span><span style=\"color:#E1E4E8\"> new_capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> q->capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void**</span><span style=\"color:#E1E4E8\"> new_buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(new_capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Copy elements to new buffer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(q->buffer);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        q->buffer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_buffer;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        q->capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_capacity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add to tail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    q->buffer[q->tail] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    q->tail </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (q->tail </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> q->capacity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    q->size</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> dequeue</span><span style=\"color:#E1E4E8\">(MarkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> q</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if empty</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (q->size </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Remove from head</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> q->buffer[q->head];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    q->head </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (q->head </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> q->capacity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    q->size</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> peek</span><span style=\"color:#E1E4E8\">(MarkQueue</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> q</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Look ahead without removing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (offset </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> q->size) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (q->head </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> offset) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> q->capacity;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> q->buffer[index];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 7: Implement performance counters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> mark_time_ns;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> sweep_time_ns;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> total_collections;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> cache_misses;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> cache_refs;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} PerfStats;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_collect_with_profiling</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, PerfStats</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Measure mark phase</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> mark_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> mark_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Measure sweep phase</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> sweep_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sweep_phase</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> sweep_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats->mark_time_ns </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> (mark_end </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> mark_start);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats->sweep_time_ns </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> (sweep_end </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> sweep_start);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats->total_collections</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> print_perf_report</span><span style=\"color:#E1E4E8\">(PerfStats</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate averages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> avg_mark_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // stats->mark_time_ns / stats->total_collections / 1e6</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> avg_sweep_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"=== GC Performance Report ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Collections: </span><span style=\"color:#79B8FF\">%lu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, stats->total_collections);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Avg mark time: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, avg_mark_ms);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Avg sweep time: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, avg_sweep_ms);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate cache miss rate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (stats->cache_refs </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        double</span><span style=\"color:#E1E4E8\"> miss_rate </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // (double)stats->cache_misses / stats->cache_refs</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cache miss rate: </span><span style=\"color:#79B8FF\">%.1f%%\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, miss_rate </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 8: Implement cache-aligned allocation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CACHE_LINE_SIZE</span><span style=\"color:#79B8FF\"> 64</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> alloc_cache_aligned</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Allocate with alignment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #ifdef</span><span style=\"color:#B392F0\"> _WIN32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> _aligned_malloc</span><span style=\"color:#E1E4E8\">(size, CACHE_LINE_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #else</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        posix_memalign</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ptr, CACHE_LINE_SIZE, size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    #endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TASK 9: Implement false sharing prevention</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> freed_bytes;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> padding</span><span style=\"color:#E1E4E8\">[CACHE_LINE_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)];</span><span style=\"color:#6A737D\">  // Prevent false sharing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ThreadLocalStats;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> init_thread_stats</span><span style=\"color:#E1E4E8\">(ThreadLocalStats</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> num_threads</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Allocate cache-aligned array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Each thread's stats should be on separate cache line</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"testing-your-optimizations\">Testing Your Optimizations</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> benchmark_marking</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 100 MB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create complex object graph</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> objects </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        objects</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Create random references</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">objects</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> target </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> rand</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (target </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                add_reference</span><span style=\"color:#E1E4E8\">(obj, </span><span style=\"color:#FFAB70\">objects</span><span style=\"color:#E1E4E8\">[target]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Benchmark naive marking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mark_naive</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#FFAB70\">objects</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        clear_marks</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> naive_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Benchmark optimized marking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> bitmap </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_mark_bitmap</span><span style=\"color:#E1E4E8\">(gc->heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mark_bfs_optimized</span><span style=\"color:#E1E4E8\">(gc, bitmap, </span><span style=\"color:#FFAB70\">objects</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        bitmap_clear</span><span style=\"color:#E1E4E8\">(bitmap);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> optimized_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Naive marking: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, naive_time </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Optimized marking: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, optimized_time </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Speedup: </span><span style=\"color:#79B8FF\">%.1f</span><span style=\"color:#9ECBFF\">x</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)naive_time </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> optimized_time);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should be 3-5x faster</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(optimized_time </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#E1E4E8\"> naive_time);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> benchmark_parallel_sweep</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Fill heap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Benchmark sequential sweep</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sweep_sequential</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> seq_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Benchmark parallel sweep (4 threads)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> bitmap </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_mark_bitmap</span><span style=\"color:#E1E4E8\">(gc->heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sweep_parallel</span><span style=\"color:#E1E4E8\">(gc, bitmap, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> par_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Sequential sweep: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, seq_time </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Parallel sweep (4 threads): </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, par_time </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Speedup: </span><span style=\"color:#79B8FF\">%.1f</span><span style=\"color:#9ECBFF\">x</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)seq_time </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> par_time);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should be 2.5-3.5x faster on 4 cores</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(par_time </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#E1E4E8\"> seq_time);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_bitmap_correctness</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> heap_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> heap </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> bm </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_mark_bitmap</span><span style=\"color:#E1E4E8\">(heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark every 100th byte</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> heap_size; i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)heap </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        bitmap_mark</span><span style=\"color:#E1E4E8\">(bm, heap, ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify marks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> heap_size; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)heap </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> should_be_marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> is_marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> bitmap_is_marked</span><span style=\"color:#E1E4E8\">(bm, heap, ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(is_marked </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> should_be_marked);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clear and verify</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    bitmap_clear</span><span style=\"color:#E1E4E8\">(bm);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> heap_size; i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint8_t*</span><span style=\"color:#E1E4E8\">)heap </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">bitmap_is_marked</span><span style=\"color:#E1E4E8\">(bm, heap, ptr));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Bitmap correctness test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> stress_test_parallel_sweep</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 1 GB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate 1 million objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> objects </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000000</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        objects</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mark half randomly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> bitmap </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_mark_bitmap</span><span style=\"color:#E1E4E8\">(gc->heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">rand</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            bitmap_mark</span><span style=\"color:#E1E4E8\">(bitmap, gc->heap_start, </span><span style=\"color:#FFAB70\">objects</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sweep with different thread counts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> threads </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; threads </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">; threads </span><span style=\"color:#F97583\">*=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        sweep_parallel</span><span style=\"color:#E1E4E8\">(gc, bitmap, threads);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> threads: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, threads, time </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"âœ“ Parallel sweep stress test passed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"performance-characteristics\">Performance Characteristics</h2>\n<h3 id=\"optimization-impact\">Optimization Impact</h3>\n<table>\n<thead>\n<tr>\n<th>Optimization</th>\n<th>Speedup</th>\n<th>Complexity</th>\n<th>Worth It?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>BFS marking</strong></td>\n<td>2-3x</td>\n<td>Low</td>\n<td>âœ… Always</td>\n</tr>\n<tr>\n<td><strong>Bitmap marking</strong></td>\n<td>1.5-2x</td>\n<td>Medium</td>\n<td>âœ… Yes</td>\n</tr>\n<tr>\n<td><strong>Prefetching</strong></td>\n<td>1.2-1.5x</td>\n<td>Low</td>\n<td>âœ… Yes</td>\n</tr>\n<tr>\n<td><strong>Parallel sweep (4 cores)</strong></td>\n<td>3-3.5x</td>\n<td>High</td>\n<td>âœ… If heap &gt; 10MB</td>\n</tr>\n<tr>\n<td><strong>Cache alignment</strong></td>\n<td>1.1-1.3x</td>\n<td>Low</td>\n<td>âš ï¸ Diminishing returns</td>\n</tr>\n</tbody></table>\n<h3 id=\"real-world-numbers\">Real-World Numbers</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Heap: 100 MB\nObjects: 100,000\nReferences: 500,000\n\nNaive GC:\n  Mark: 45 ms\n  Sweep: 25 ms\n  Total: 70 ms\n\nOptimized GC:\n  Mark (BFS + bitmap): 12 ms\n  Sweep (4 threads): 7 ms\n  Total: 19 ms\n\nSpeedup: 3.7x</code></pre></div>\n\n<h3 id=\"when-to-optimize-what\">When to Optimize What</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Small heaps (&lt; 1 MB):\n  â†’ Skip parallelization (overhead &gt; benefit)\n  â†’ Use BFS + bitmap only\n\nMedium heaps (1-100 MB):\n  â†’ BFS + bitmap + prefetching\n  â†’ Parallel sweep with 2-4 threads\n\nLarge heaps (&gt; 100 MB):\n  â†’ All optimizations\n  â†’ 8+ threads for sweep\n  â†’ Consider concurrent GC</code></pre></div>\n\n<hr>\n<h2 id=\"what-you39ve-mastered\">What You&#39;ve Mastered</h2>\n<p>âœ… <strong>Cache-friendly algorithms</strong>: BFS traversal with prefetching<br>âœ… <strong>Bitmap marking</strong>: Separate metadata for better cache behavior<br>âœ… <strong>Parallel sweep</strong>: Multi-threaded heap scanning<br>âœ… <strong>Performance profiling</strong>: Measuring and optimizing hot paths<br>âœ… <strong>False sharing prevention</strong>: Cache line alignment<br>âœ… <strong>Micro-optimizations</strong>: Pointer caching, batch processing  </p>\n<p><strong>You now have a production-grade, high-performance GC!</strong> ğŸš€</p>\n<hr>\n<h2 id=\"next-steps\">Next Steps</h2>\n<p>Your GC is now <strong>fast</strong>. But can it scale to real-world applications?</p>\n<p><strong>Choose your path:</strong></p>\n<ol>\n<li><strong><a href=\"#generational-gc\">â†’ Generational GC</a></strong>: 10x faster by exploiting object lifetimes</li>\n<li><strong><a href=\"#concurrent-gc\">â†’ Concurrent GC</a></strong>: Eliminate pauses entirely</li>\n<li><strong><a href=\"#integration\">â†’ Real-World Integration</a></strong>: Embed your GC in a language runtime</li>\n<li><strong><a href=\"#advanced\">â†’ Advanced Topics</a></strong>: Incremental collection, region-based GC</li>\n</ol>\n<p><strong>Before continuing</strong>, verify your optimizations work:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> ./benchmark_gc</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Naive</span><span style=\"color:#9ECBFF\"> marking:</span><span style=\"color:#79B8FF\"> 45.2</span><span style=\"color:#9ECBFF\"> ms</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Optimized</span><span style=\"color:#9ECBFF\"> marking:</span><span style=\"color:#79B8FF\"> 12.3</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#9ECBFF\"> â†’</span><span style=\"color:#9ECBFF\"> 3.7x</span><span style=\"color:#9ECBFF\"> faster</span><span style=\"color:#9ECBFF\"> âœ“</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Sequential</span><span style=\"color:#9ECBFF\"> sweep:</span><span style=\"color:#79B8FF\"> 25.1</span><span style=\"color:#9ECBFF\"> ms</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Parallel</span><span style=\"color:#9ECBFF\"> sweep</span><span style=\"color:#E1E4E8\"> (4 </span><span style=\"color:#9ECBFF\">threads</span><span style=\"color:#E1E4E8\">): 7.2 ms â†’ 3.5x faster âœ“</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Cache</span><span style=\"color:#9ECBFF\"> miss</span><span style=\"color:#9ECBFF\"> rate:</span><span style=\"color:#9ECBFF\"> 8.3%</span><span style=\"color:#E1E4E8\"> (was </span><span style=\"color:#9ECBFF\">42.1%</span><span style=\"color:#E1E4E8\">) âœ“</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">âœ“</span><span style=\"color:#9ECBFF\"> All</span><span style=\"color:#9ECBFF\"> performance</span><span style=\"color:#9ECBFF\"> tests</span><span style=\"color:#9ECBFF\"> passed</span></span></code></pre></div>\n\n<p><strong>Pro tip</strong>: Use <code>perf stat</code> on Linux to measure cache misses:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> perf</span><span style=\"color:#9ECBFF\"> stat</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> cache-misses,cache-references</span><span style=\"color:#9ECBFF\"> ./your_gc_test</span></span></code></pre></div>\n\n<p>Look for &lt; 10% cache miss rate for optimal performance.</p>\n<hr>\n<p><a href=\"#satellite-map\">â†‘ Back to System Map</a></p>\n<div id=\"ms-testing\"></div>\n\n<h1 id=\"testing-amp-validation-the-crucible-of-confidence\">Testing &amp; Validation: The Crucible of Confidence</h1>\n<h2 id=\"epiphany-analogy-the-aircraft-pre-flight-checklist\">Epiphany Analogy: The Aircraft Pre-Flight Checklist</h2>\n<p>Imagine you&#39;re a pilot about to fly a 747. You don&#39;t just turn the key and hope for the best. You run through a <strong>pre-flight checklist</strong>: fuel levels, hydraulics, engine temperature, control surfaces, backup systems. Each test validates a critical assumption about the aircraft&#39;s behavior.</p>\n<p>Your garbage collector is the same. It&#39;s a <strong>life-support system</strong> for your program&#39;s memory. A single bugâ€”a missed pointer, a race condition, a memory leakâ€”can crash your entire application. Testing isn&#39;t optional; it&#39;s the difference between &quot;it works on my machine&quot; and &quot;it works in production under load.&quot;</p>\n<p>This section is your <strong>pre-flight checklist</strong> for memory safety.</p>\n<hr>\n<h2 id=\"technical-rationale-why-testing-gcs-is-uniquely-hard\">Technical Rationale: Why Testing GCs Is Uniquely Hard</h2>\n<h3 id=\"the-three-horsemen-of-gc-bugs\">The Three Horsemen of GC Bugs</h3>\n<ol>\n<li><p><strong>Non-Determinism</strong>: GC timing depends on allocation patterns, heap size, and thread scheduling. A bug might only appear after 10,000 collections.</p>\n</li>\n<li><p><strong>Invisible Corruption</strong>: A missed mark doesn&#39;t crash immediatelyâ€”it corrupts memory silently, causing a segfault 10 seconds later in unrelated code.</p>\n</li>\n<li><p><strong>Concurrency Chaos</strong>: Race conditions in parallel sweep can cause double-frees, use-after-frees, or memory leaksâ€”all of which are <strong>Heisenbugs</strong> (disappear when you add logging).</p>\n</li>\n</ol>\n<h3 id=\"what-we-must-validate\">What We Must Validate</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         GC Test Pyramid                 â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Stress Tests (1-2 tests)               â”‚  â† Does it survive chaos?\nâ”‚    â””â”€ 1M objects, 8 threads, 1 hour     â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Integration Tests (5-10 tests)         â”‚  â† Does it work end-to-end?\nâ”‚    â””â”€ Leak detection, correctness       â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Unit Tests (20-50 tests)               â”‚  â† Does each piece work?\nâ”‚    â””â”€ Bitmap ops, queue ops, marking    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></div>\n\n<p><strong>Key Insight</strong>: You can&#39;t just test &quot;does it collect garbage?&quot; You must test:</p>\n<ul>\n<li><strong>Correctness</strong>: Does it collect <em>only</em> garbage?</li>\n<li><strong>Completeness</strong>: Does it collect <em>all</em> garbage?</li>\n<li><strong>Safety</strong>: Does it avoid double-frees and use-after-frees?</li>\n<li><strong>Performance</strong>: Does it meet latency/throughput targets?</li>\n</ul>\n<hr>\n<h2 id=\"internal-mechanics-the-testing-arsenal\">Internal Mechanics: The Testing Arsenal</h2>\n<h3 id=\"1-leak-detection-the-canary-in-the-coal-mine\">1. Leak Detection: The Canary in the Coal Mine</h3>\n<p><strong>The Problem</strong>: Your GC might be &quot;working&quot; but slowly leaking memory because it misses objects in complex graphs.</p>\n<p><strong>The Solution</strong>: Track every allocation and verify the heap size converges to zero after collecting unreachable objects.</p>\n<p>{{DIAGRAM:leak-detection-flow}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Allocation Phase:\n  alloc(A) â†’ heap_size = 128\n  alloc(B) â†’ heap_size = 256\n  alloc(C) â†’ heap_size = 384\n\nDrop References:\n  A = NULL\n  B = NULL\n  C = NULL\n\nGC Collection:\n  mark_phase() â†’ 0 objects marked\n  sweep_phase() â†’ freed 384 bytes\n\nValidation:\n  assert(heap_size == 0) âœ“</code></pre></div>\n\n<h3 id=\"2-correctness-validation-the-reachability-oracle\">2. Correctness Validation: The Reachability Oracle</h3>\n<p><strong>The Problem</strong>: Your GC might collect <em>too much</em> (freeing live objects) or <em>too little</em> (missing garbage).</p>\n<p><strong>The Solution</strong>: Build a <strong>shadow graph</strong> that tracks reachability independently, then compare results.</p>\n<p>{{DIAGRAM:shadow-graph-validation}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Your GC's View:        Shadow Graph:\n  Root â†’ A â†’ B           Root â†’ A â†’ B\n         â†“                      â†“\n         C                      C\n\nAfter marking:\n  Your GC: {A, B, C}\n  Shadow:  {A, B, C}\n  \n  assert(your_marks == shadow_marks) âœ“</code></pre></div>\n\n<h3 id=\"3-stress-testing-the-chaos-monkey\">3. Stress Testing: The Chaos Monkey</h3>\n<p><strong>The Problem</strong>: Bugs hide in edge casesâ€”deeply nested graphs, circular references, high allocation rates, thread contention.</p>\n<p><strong>The Solution</strong>: Generate <strong>pathological workloads</strong> designed to break your GC.</p>\n<p>{{DIAGRAM:stress-test-scenarios}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Scenario 1: Deep Nesting\n  Root â†’ A â†’ B â†’ C â†’ ... â†’ Z (1000 levels)\n  Tests: Stack overflow in recursive marking\n\nScenario 2: Wide Graphs\n  Root â†’ [A, B, C, ..., Z] (10,000 children)\n  Tests: Mark queue overflow\n\nScenario 3: Circular References\n  A â†’ B â†’ C â†’ A\n  Tests: Infinite loops in marking\n\nScenario 4: Thrashing\n  Allocate 1M objects, free 999K, repeat\n  Tests: Fragmentation, sweep performance</code></pre></div>\n\n<hr>\n<h2 id=\"the-debugging-lab-common-test-failures\">The Debugging Lab: Common Test Failures</h2>\n<h3 id=\"failure-1-quotheap-size-doesn39t-reach-zero-after-gcquot\">Failure 1: &quot;Heap size doesn&#39;t reach zero after GC&quot;</h3>\n<p><strong>Symptom</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">test_leak_detection</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... allocate and free everything ...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(gc->used_bytes </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // FAILS: used_bytes = 1024</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Root Causes</strong>:</p>\n<ol>\n<li><strong>Missed marks</strong>: Your marking algorithm skipped an object</li>\n<li><strong>Dangling roots</strong>: A root pointer wasn&#39;t cleared</li>\n<li><strong>Bitmap bug</strong>: <code>bitmap_is_marked()</code> returns false positives</li>\n</ol>\n<p><strong>Debug Strategy</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Add instrumentation to sweep phase</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sweep_phase_debug</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> bm</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (Block</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->first_block; b; b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b->next) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">bitmap_is_marked</span><span style=\"color:#E1E4E8\">(bm, gc->heap_start, b)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"LEAK: Block at </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\"> (size=</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">) not marked</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   b, b->size);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            print_object_graph</span><span style=\"color:#E1E4E8\">(gc, b);</span><span style=\"color:#6A737D\">  // Who should have marked this?</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"failure-2-quotsegfault-in-user-code-after-gcquot\">Failure 2: &quot;Segfault in user code after GC&quot;</h3>\n<p><strong>Symptom</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">test_correctness</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    obj->data[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 42</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // SEGFAULT: obj was freed!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Root Causes</strong>:</p>\n<ol>\n<li><strong>Premature collection</strong>: Object was live but not marked</li>\n<li><strong>Root scanning bug</strong>: Stack/global roots weren&#39;t scanned</li>\n<li><strong>Race condition</strong>: Object freed while another thread was using it</li>\n</ol>\n<p><strong>Debug Strategy</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Add \"tombstone\" pattern to freed memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sweep_phase_debug</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> bm</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (Block</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->first_block; b; b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b->next) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">bitmap_is_marked</span><span style=\"color:#E1E4E8\">(bm, gc->heap_start, b)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            memset</span><span style=\"color:#E1E4E8\">(b, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">DEADBEEF</span><span style=\"color:#E1E4E8\">, b->size);</span><span style=\"color:#6A737D\">  // Fill with poison</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            free_block</span><span style=\"color:#E1E4E8\">(gc, b);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Now segfault will show 0xDEADBEEF in debugger</span></span></code></pre></div>\n\n<h3 id=\"failure-3-quotparallel-sweep-produces-different-results-than-sequentialquot\">Failure 3: &quot;Parallel sweep produces different results than sequential&quot;</h3>\n<p><strong>Symptom</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">test_parallel_correctness</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sweep_sequential</span><span style=\"color:#E1E4E8\">(gc, bm);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> seq_freed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->freed_bytes;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sweep_parallel</span><span style=\"color:#E1E4E8\">(gc, bm, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> par_freed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->freed_bytes;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(seq_freed </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> par_freed);</span><span style=\"color:#6A737D\">  // FAILS: 1024 != 1152</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Root Causes</strong>:</p>\n<ol>\n<li><strong>Race condition</strong>: Two threads free the same block</li>\n<li><strong>False sharing</strong>: Threads contend on <code>freed_bytes</code> counter</li>\n<li><strong>Incorrect partitioning</strong>: Threads overlap in heap regions</li>\n</ol>\n<p><strong>Debug Strategy</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Add per-thread accounting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> freed_bytes;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Block</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> freed_blocks</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> num_freed;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ThreadStats;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> sweep_worker_debug</span><span style=\"color:#E1E4E8\">(GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> gc</span><span style=\"color:#E1E4E8\">, MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> bm</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        size_t</span><span style=\"color:#FFAB70\"> start</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> end</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        ThreadStats</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (Block</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_block_at</span><span style=\"color:#E1E4E8\">(gc, start); </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\"> get_block_at</span><span style=\"color:#E1E4E8\">(gc, end); </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b->next) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">bitmap_is_marked</span><span style=\"color:#E1E4E8\">(bm, gc->heap_start, b)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stats->freed_blocks[stats->num_freed</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stats->freed_bytes </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> b->size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// After all threads finish, check for duplicates</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> validate_no_double_free</span><span style=\"color:#E1E4E8\">(ThreadStats</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> num_threads</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_threads; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_threads; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; a </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">[i].num_freed; a</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; b </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">[j].num_freed; b</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#E1E4E8\">[i].freed_blocks[a] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                           stats</span><span style=\"color:#E1E4E8\">[j].freed_blocks[b]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"code-scaffold-your-testing-suite\">Code Scaffold: Your Testing Suite</h2>\n<h3 id=\"task-1-implement-leak-detection-test\">Task 1: Implement Leak Detection Test</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;assert.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test: Allocate objects, drop all references, verify heap is empty</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_no_leaks_simple</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Running: test_no_leaks_simple...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 1 MB heap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Allocate 100 objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> objects </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        objects</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">objects</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Record heap usage before GC</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> used_before </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->used_bytes;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Heap usage before GC: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, used_before);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(used_before </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 128</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // At least 100 objects</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Drop all references (simulate objects going out of scope)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        objects</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Run GC (no roots, so everything should be collected)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify heap is empty</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> used_after </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->used_bytes;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Heap usage after GC: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, used_after);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (used_after </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  âŒ LEAK DETECTED: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes not freed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, used_after);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  âœ“ No leaks detected</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(objects);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_gc</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test: Complex object graph with circular references</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_no_leaks_circular</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Running: test_no_leaks_circular...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create circular reference: A â†’ B â†’ C â†’ A</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> Node {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        struct</span><span style=\"color:#E1E4E8\"> Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } Node;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(Node));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(Node));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(Node));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    a->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> c;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> a;</span><span style=\"color:#6A737D\">  // Circular!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> used_before </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->used_bytes;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Created circular graph: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, used_before);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Drop all external references</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    a </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: GC should collect entire cycle</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> used_after </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc->used_bytes;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  After GC: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, used_after);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(used_after </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Cycle should be collected</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  âœ“ Circular references collected correctly</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_gc</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-2-implement-correctness-validation\">Task 2: Implement Correctness Validation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Shadow graph: Independent reachability tracker</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> reachable;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> capacity;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ShadowGraph;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ShadowGraph</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> create_shadow_graph</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> capacity</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ShadowGraph</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> sg </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(ShadowGraph));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sg->reachable </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sg->capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> capacity;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sg->count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> sg;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> shadow_mark</span><span style=\"color:#E1E4E8\">(ShadowGraph</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> sg</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add to reachable set (if not already present)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> sg->count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (sg->reachable[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ptr) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Already marked</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(sg->count </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> sg->capacity);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sg->reachable[sg->count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ptr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> shadow_is_reachable</span><span style=\"color:#E1E4E8\">(ShadowGraph</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> sg</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if ptr is in reachable set</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> sg->count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (sg->reachable[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ptr) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_correctness_vs_shadow</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Running: test_correctness_vs_shadow...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ShadowGraph</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> shadow </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_shadow_graph</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create object graph</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   Root â†’ A â†’ B</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //          â†“</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //          C</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   D (unreachable)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> root </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> d </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Garbage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set up references (you'll need to implement this based on your GC)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For now, assume we can manually track references</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Manually mark reachable objects in shadow graph</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    shadow_mark</span><span style=\"color:#E1E4E8\">(shadow, root);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    shadow_mark</span><span style=\"color:#E1E4E8\">(shadow, a);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    shadow_mark</span><span style=\"color:#E1E4E8\">(shadow, b);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    shadow_mark</span><span style=\"color:#E1E4E8\">(shadow, c);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: D is NOT marked (it's garbage)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Run your GC's mark phase</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> bitmap </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_mark_bitmap</span><span style=\"color:#E1E4E8\">(gc->heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_from_roots</span><span style=\"color:#E1E4E8\">(gc, bitmap, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">root, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Compare results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> all_objects</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {root, a, b, c, d};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> gc_marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> bitmap_is_marked</span><span style=\"color:#E1E4E8\">(bitmap, gc->heap_start, </span><span style=\"color:#FFAB70\">all_objects</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> shadow_marked </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> shadow_is_reachable</span><span style=\"color:#E1E4E8\">(shadow, </span><span style=\"color:#FFAB70\">all_objects</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (gc_marked </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> shadow_marked) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  âŒ MISMATCH at object </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: GC=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, Shadow=</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   i, gc_marked, shadow_marked);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  âœ“ GC marking matches shadow graph</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_mark_bitmap</span><span style=\"color:#E1E4E8\">(bitmap);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(shadow->reachable);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(shadow);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_gc</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-3-implement-stress-tests\">Task 3: Implement Stress Tests</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Stress test: Deep nesting (tests stack overflow in recursive marking)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> stress_test_deep_nesting</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Running: stress_test_deep_nesting...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 10 MB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create linked list of 10,000 nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> Node {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        struct</span><span style=\"color:#E1E4E8\"> Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } Node;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> root </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(Node));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> root;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(Node));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Created chain of 10,000 nodes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Run GC (should not stack overflow)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> elapsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  GC completed in </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, elapsed </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  âœ“ No stack overflow</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_gc</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Stress test: Wide graphs (tests mark queue overflow)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> stress_test_wide_graph</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Running: stress_test_wide_graph...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 100 MB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create root with 100,000 children</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#FFAB70\"> children</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } WideNode;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WideNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> root </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (WideNode</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#B392F0\">gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(WideNode));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        root->children[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Created root with 100,000 children</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Run GC (mark queue should resize automatically)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> elapsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  GC completed in </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, elapsed </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  âœ“ Mark queue handled wide graph</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_gc</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Stress test: Allocation thrashing (tests fragmentation)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> stress_test_thrashing</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Running: stress_test_thrashing...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 10 MB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Allocate/free in tight loop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> round </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; round </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; round</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void**</span><span style=\"color:#E1E4E8\"> objects </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Allocate 10,000 objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            objects</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Free 99% of them (keep every 100th)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#F97583\"> !=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                objects</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // GC should reclaim most memory</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(objects);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Survived 100 rounds of thrashing</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Final heap usage: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, gc->used_bytes);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  âœ“ No excessive fragmentation</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_gc</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-4-implement-parallel-correctness-test\">Task 4: Implement Parallel Correctness Test</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Test: Parallel sweep produces same results as sequential</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_parallel_sweep_correctness</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Running: test_parallel_sweep_correctness...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create identical heaps</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> objects1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> objects2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        objects1</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc1, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        objects2</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc2, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Mark same objects in both heaps (every other object)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> bm1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_mark_bitmap</span><span style=\"color:#E1E4E8\">(gc1->heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MarkBitmap</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> bm2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_mark_bitmap</span><span style=\"color:#E1E4E8\">(gc2->heap_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        bitmap_mark</span><span style=\"color:#E1E4E8\">(bm1, gc1->heap_start, </span><span style=\"color:#FFAB70\">objects1</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        bitmap_mark</span><span style=\"color:#E1E4E8\">(bm2, gc2->heap_start, </span><span style=\"color:#FFAB70\">objects2</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Sequential sweep on gc1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sweep_sequential</span><span style=\"color:#E1E4E8\">(gc1, bm1);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> seq_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> seq_freed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc1->freed_bytes;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Parallel sweep on gc2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sweep_parallel</span><span style=\"color:#E1E4E8\">(gc2, bm2, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> par_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> par_freed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gc2->freed_bytes;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Compare results</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Sequential: freed </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes in </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           seq_freed, seq_time </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Parallel:   freed </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes in </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           par_freed, par_time </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (seq_freed </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> par_freed) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  âŒ MISMATCH: Sequential freed </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\">, Parallel freed </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               seq_freed, par_freed);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  âœ“ Parallel sweep is correct</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Speedup: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\">x</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)seq_time </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> par_time);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(objects1);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(objects2);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_mark_bitmap</span><span style=\"color:#E1E4E8\">(bm1);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_mark_bitmap</span><span style=\"color:#E1E4E8\">(bm2);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_gc</span><span style=\"color:#E1E4E8\">(gc1);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_gc</span><span style=\"color:#E1E4E8\">(gc2);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-5-implement-performance-regression-test\">Task 5: Implement Performance Regression Test</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Test: Verify optimizations meet performance targets</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_performance_targets</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Running: test_performance_targets...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // 100 MB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create realistic object graph</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void**</span><span style=\"color:#E1E4E8\"> objects </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        objects</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Add random references</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectHeader</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">objects</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> target </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> rand</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (target </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Add reference (implementation-specific)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Benchmark GC performance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PerfStats stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        gc_collect_with_profiling</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">stats);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate averages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> avg_mark_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (stats.mark_time_ns </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> stats.total_collections) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> avg_sweep_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (stats.sweep_time_ns </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> stats.total_collections) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> avg_total_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> avg_mark_ms </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> avg_sweep_ms;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Average mark time:  </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, avg_mark_ms);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Average sweep time: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, avg_sweep_ms);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  Average total time: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, avg_total_ms);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Assert performance targets</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Target: &#x3C; 20ms for 100MB heap with 100K objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (avg_total_ms </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 20.0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  âŒ PERFORMANCE REGRESSION: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms > 20 ms target</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               avg_total_ms);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  âœ“ Performance targets met</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(objects);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_gc</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-6-implement-memory-safety-test-valgrindasan\">Task 6: Implement Memory Safety Test (Valgrind/ASan)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Test: Run under Valgrind/AddressSanitizer to detect memory errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_memory_safety</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Running: test_memory_safety...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  (Run with: valgrind --leak-check=full ./test_gc)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  (Or compile with: -fsanitize=address)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Allocate and free objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        void*</span><span style=\"color:#E1E4E8\"> obj </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Use the object</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(obj, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">AB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Run GC multiple times</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Clean up</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    destroy_gc</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  âœ“ No memory errors detected</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  (Check Valgrind/ASan output for confirmation)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"task-7-implement-full-test-suite-runner\">Task 7: Implement Full Test Suite Runner</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Main test runner</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•‘   GC Test Suite - Comprehensive       â•‘</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Unit tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â”€â”€â”€ Unit Tests â”€â”€â”€</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_bitmap_correctness</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">  // From previous section</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add more unit tests (queue, allocation, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Leak detection tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">â”€â”€â”€ Leak Detection Tests â”€â”€â”€</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_no_leaks_simple</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_no_leaks_circular</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Correctness tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">â”€â”€â”€ Correctness Tests â”€â”€â”€</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_correctness_vs_shadow</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_parallel_sweep_correctness</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Stress tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">â”€â”€â”€ Stress Tests â”€â”€â”€</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    stress_test_deep_nesting</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    stress_test_wide_graph</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    stress_test_thrashing</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Performance tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">â”€â”€â”€ Performance Tests â”€â”€â”€</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_performance_targets</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    benchmark_marking</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">  // From previous section</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    benchmark_parallel_sweep</span><span style=\"color:#E1E4E8\">();</span><span style=\"color:#6A737D\">  // From previous section</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Memory safety</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">â”€â”€â”€ Memory Safety Tests â”€â”€â”€</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    test_memory_safety</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•‘   âœ“ ALL TESTS PASSED                  â•‘</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"visual-reference\">Visual Reference</h2>\n<p>{{DIAGRAM:test-pyramid}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n                    â”‚  Stress Tests   â”‚  â† 1-2 tests, run for hours\n                    â”‚  (Chaos Monkey) â”‚     Catch rare race conditions\n                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n                   â”‚ Integration Tests â”‚  â† 5-10 tests, run in CI\n                   â”‚ (End-to-End)      â”‚     Catch correctness bugs\n                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n              â”‚      Unit Tests          â”‚  â† 20-50 tests, run constantly\n              â”‚  (Individual Functions)  â”‚     Catch logic errors\n              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre></div>\n\n<p>{{DIAGRAM:leak-detection-timeline}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Time â†’\n  0ms: alloc(A), alloc(B), alloc(C)\n       Heap: [A][B][C]  (384 bytes)\n       \n 10ms: A = NULL, B = NULL, C = NULL\n       Heap: [A][B][C]  (384 bytes, all garbage)\n       \n 20ms: gc_collect()\n       Mark phase: 0 objects marked\n       Sweep phase: freed 384 bytes\n       \n 30ms: Validation\n       assert(heap_size == 0) âœ“</code></pre></div>\n\n<p>{{DIAGRAM:shadow-graph-comparison}}</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Your GC's Marking:              Shadow Graph (Ground Truth):\n                                \n  Root                            Root\n   â”œâ”€â†’ A (marked)                  â”œâ”€â†’ A (reachable)\n   â”‚    â”œâ”€â†’ B (marked)             â”‚    â”œâ”€â†’ B (reachable)\n   â”‚    â””â”€â†’ C (marked)             â”‚    â””â”€â†’ C (reachable)\n   â””â”€â†’ D (NOT marked)              â””â”€â†’ D (NOT reachable)\n   \nCompare:\n  for each object:\n    assert(gc_marked == shadow_reachable)</code></pre></div>\n\n<hr>\n<h2 id=\"the-debugging-lab-test-driven-debugging\">The Debugging Lab: Test-Driven Debugging</h2>\n<h3 id=\"scenario-1-intermittent-segfault-in-production\">Scenario 1: Intermittent Segfault in Production</h3>\n<p><strong>Symptom</strong>: Your GC works fine in tests but crashes randomly in production after 10 minutes.</p>\n<p><strong>Hypothesis</strong>: Race condition in parallel sweep.</p>\n<p><strong>Test to Write</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_parallel_sweep_race_condition</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Run parallel sweep 10,000 times with random delays</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Allocate objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Parallel sweep with random thread delays</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        sweep_parallel_with_delays</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Verify heap integrity</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        validate_heap_structure</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        destroy_gc</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Add proper synchronization to <code>freed_bytes</code> counter.</p>\n<h3 id=\"scenario-2-memory-usage-grows-over-time\">Scenario 2: Memory Usage Grows Over Time</h3>\n<p><strong>Symptom</strong>: Heap size increases by 1KB per GC cycle.</p>\n<p><strong>Hypothesis</strong>: Small leak in mark queue or bitmap.</p>\n<p><strong>Test to Write</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_gc_internal_memory_leak</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> initial_internal_memory </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_internal_memory_usage</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Run 1000 GC cycles</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> final_internal_memory </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_internal_memory_usage</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Internal memory should not grow</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(final_internal_memory </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> initial_internal_memory);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Ensure mark queue and bitmap are properly freed after each collection.</p>\n<h3 id=\"scenario-3-performance-degrades-over-time\">Scenario 3: Performance Degrades Over Time</h3>\n<p><strong>Symptom</strong>: First GC takes 5ms, 100th GC takes 50ms.</p>\n<p><strong>Hypothesis</strong>: Heap fragmentation or bitmap not being cleared.</p>\n<p><strong>Test to Write</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_gc_performance_stability</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> gc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> create_gc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#FFAB70\"> times</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Allocate some objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            gc_alloc</span><span style=\"color:#E1E4E8\">(gc, </span><span style=\"color:#79B8FF\">128</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Measure GC time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        gc_collect</span><span style=\"color:#E1E4E8\">(gc);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        times</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_nanos</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // First and last GC should have similar times</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> first_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> times</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> last_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> times</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">99</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"First GC: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms, Last GC: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\"> ms</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, first_ms, last_ms);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allow 20% variance</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(last_ms </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> first_ms </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1.2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Ensure bitmap is cleared between collections and implement defragmentation.</p>\n<hr>\n<h2 id=\"performance-characteristics-test-execution-time\">Performance Characteristics: Test Execution Time</h2>\n<table>\n<thead>\n<tr>\n<th>Test Type</th>\n<th>Count</th>\n<th>Time per Test</th>\n<th>Total Time</th>\n<th>Frequency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Unit tests</strong></td>\n<td>50</td>\n<td>1-10 ms</td>\n<td>0.5 sec</td>\n<td>Every commit</td>\n</tr>\n<tr>\n<td><strong>Integration tests</strong></td>\n<td>10</td>\n<td>100-500 ms</td>\n<td>5 sec</td>\n<td>Every commit</td>\n</tr>\n<tr>\n<td><strong>Stress tests</strong></td>\n<td>5</td>\n<td>10-60 sec</td>\n<td>5 min</td>\n<td>Nightly</td>\n</tr>\n<tr>\n<td><strong>Soak tests</strong></td>\n<td>1</td>\n<td>1-8 hours</td>\n<td>8 hours</td>\n<td>Weekly</td>\n</tr>\n</tbody></table>\n<p><strong>CI/CD Strategy</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>On every commit:\n  â†’ Run unit + integration tests (&lt; 10 seconds)\n  â†’ Block merge if any test fails\n\nNightly:\n  â†’ Run stress tests (5 minutes)\n  â†’ Run under Valgrind (30 minutes)\n  â†’ Run under ThreadSanitizer (30 minutes)\n\nWeekly:\n  â†’ Run soak test (8 hours)\n  â†’ Profile with perf/VTune\n  â†’ Generate coverage report</code></pre></div>\n\n<hr>\n<h2 id=\"what-you39ve-mastered\">What You&#39;ve Mastered</h2>\n<p>âœ… <strong>Leak detection</strong>: Verify all garbage is collected<br>âœ… <strong>Correctness validation</strong>: Compare against shadow graph<br>âœ… <strong>Stress testing</strong>: Break your GC with pathological workloads<br>âœ… <strong>Parallel correctness</strong>: Ensure thread-safe sweep<br>âœ… <strong>Performance regression</strong>: Catch slowdowns early<br>âœ… <strong>Memory safety</strong>: Integrate with Valgrind/ASan<br>âœ… <strong>Test-driven debugging</strong>: Write tests that reproduce bugs  </p>\n<p><strong>Your GC is now battle-tested and production-ready!</strong> ğŸ›¡ï¸</p>\n<hr>\n<h2 id=\"next-steps-beyond-testing\">Next Steps: Beyond Testing</h2>\n<p>You&#39;ve built a <strong>fast, correct, and tested</strong> garbage collector. But the journey doesn&#39;t end here.</p>\n<p><strong>Choose your next adventure:</strong></p>\n<ol>\n<li><strong><a href=\"#generational-gc\">â†’ Generational GC</a></strong>: Exploit the generational hypothesis for 10x speedup</li>\n<li><strong><a href=\"#concurrent-gc\">â†’ Concurrent GC</a></strong>: Eliminate pause times entirely</li>\n<li><strong><a href=\"#integration\">â†’ Real-World Integration</a></strong>: Embed your GC in a scripting language</li>\n<li><strong><a href=\"#advanced\">â†’ Advanced Optimizations</a></strong>: Incremental collection, region-based GC, escape analysis</li>\n</ol>\n<p><strong>Before continuing</strong>, run your full test suite:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> make</span><span style=\"color:#9ECBFF\"> test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Running:</span><span style=\"color:#9ECBFF\"> test_no_leaks_simple...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  âœ“</span><span style=\"color:#9ECBFF\"> No</span><span style=\"color:#9ECBFF\"> leaks</span><span style=\"color:#9ECBFF\"> detected</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Running:</span><span style=\"color:#9ECBFF\"> test_correctness_vs_shadow...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  âœ“</span><span style=\"color:#9ECBFF\"> GC</span><span style=\"color:#9ECBFF\"> marking</span><span style=\"color:#9ECBFF\"> matches</span><span style=\"color:#9ECBFF\"> shadow</span><span style=\"color:#9ECBFF\"> graph</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Running:</span><span style=\"color:#9ECBFF\"> stress_test_deep_nesting...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  âœ“</span><span style=\"color:#9ECBFF\"> No</span><span style=\"color:#9ECBFF\"> stack</span><span style=\"color:#9ECBFF\"> overflow</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Running:</span><span style=\"color:#9ECBFF\"> test_parallel_sweep_correctness...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  âœ“</span><span style=\"color:#9ECBFF\"> Parallel</span><span style=\"color:#9ECBFF\"> sweep</span><span style=\"color:#9ECBFF\"> is</span><span style=\"color:#9ECBFF\"> correct</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">Running:</span><span style=\"color:#9ECBFF\"> test_performance_targets...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  âœ“</span><span style=\"color:#9ECBFF\"> Performance</span><span style=\"color:#9ECBFF\"> targets</span><span style=\"color:#9ECBFF\"> met</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">â•‘</span><span style=\"color:#9ECBFF\">   âœ“</span><span style=\"color:#9ECBFF\"> ALL</span><span style=\"color:#9ECBFF\"> TESTS</span><span style=\"color:#9ECBFF\"> PASSED</span><span style=\"color:#E1E4E8\"> (32/32)         â•‘</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span></span></code></pre></div>\n\n<p><strong>Pro tip</strong>: Set up continuous fuzzing with AFL or libFuzzer to catch edge cases:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">$</span><span style=\"color:#9ECBFF\"> afl-fuzz</span><span style=\"color:#79B8FF\"> -i</span><span style=\"color:#9ECBFF\"> testcases/</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> findings/</span><span style=\"color:#9ECBFF\"> ./gc_fuzzer</span><span style=\"color:#9ECBFF\"> @@</span></span></code></pre></div>\n\n<p>This will generate millions of random object graphs and allocation patterns, finding bugs you never imagined.</p>\n<hr>\n<p><a href=\"#satellite-map\">â†‘ Back to System Map</a></p>\n","toc":[{"level":1,"text":"Simple Mark-Sweep Garbage Collector","id":"simple-mark-sweep-garbage-collector"},{"level":1,"text":"System Architecture Overview","id":"system-architecture-overview"},{"level":2,"text":"The City Sanitation Analogy","id":"the-city-sanitation-analogy"},{"level":2,"text":"Why This Architecture Exists: The Memory Leak Problem","id":"why-this-architecture-exists-the-memory-leak-problem"},{"level":2,"text":"The Complete System: A Satellite View","id":"the-complete-system-a-satellite-view"},{"level":2,"text":"Internal Mechanics: How the Pieces Interact","id":"internal-mechanics-how-the-pieces-interact"},{"level":3,"text":"The GC Cycle Lifecycle","id":"the-gc-cycle-lifecycle"},{"level":4,"text":"Phase 0: Normal Execution","id":"phase-0-normal-execution"},{"level":4,"text":"Phase 1: Root Scanning","id":"phase-1-root-scanning"},{"level":4,"text":"Phase 2: Mark Phase (Tri-Color Abstraction)","id":"phase-2-mark-phase-tri-color-abstraction"},{"level":4,"text":"Phase 3: Sweep Phase","id":"phase-3-sweep-phase"},{"level":4,"text":"Phase 4: Compaction (Optional)","id":"phase-4-compaction-optional"},{"level":2,"text":"The Data Structures: Memory Layout","id":"the-data-structures-memory-layout"},{"level":3,"text":"Object Header (Per Allocation)","id":"object-header-per-allocation"},{"level":3,"text":"Free List Node","id":"free-list-node"},{"level":3,"text":"Root Set Registry","id":"root-set-registry"},{"level":2,"text":"The Debugging Lab: Common Failure Modes","id":"the-debugging-lab-common-failure-modes"},{"level":3,"text":"ğŸ› Bug 1: Premature Collection (False Negative)","id":"-bug-1-premature-collection-false-negative"},{"level":3,"text":"ğŸ› Bug 2: Memory Leak (False Positive)","id":"-bug-2-memory-leak-false-positive"},{"level":3,"text":"ğŸ› Bug 3: Fragmentation Death Spiral","id":"-bug-3-fragmentation-death-spiral"},{"level":2,"text":"Your Mission: The Code Scaffold","id":"your-mission-the-code-scaffold"},{"level":3,"text":"Starter Code Structure","id":"starter-code-structure"},{"level":3,"text":"Success Criteria","id":"success-criteria"},{"level":2,"text":"Navigation: Where to Go Next","id":"navigation-where-to-go-next"},{"level":1,"text":"Milestone 2: Heap Memory Organization","id":"milestone-2-heap-memory-organization"},{"level":2,"text":"The Epiphany Analogy: A Self-Storage Facility","id":"the-epiphany-analogy-a-self-storage-facility"},{"level":2,"text":"Technical Rationale: Why This Design?","id":"technical-rationale-why-this-design"},{"level":3,"text":"The Three Fundamental Constraints","id":"the-three-fundamental-constraints"},{"level":3,"text":"Why Not Use malloc()?","id":"why-not-use-malloc"},{"level":2,"text":"Internal Mechanics: The Memory Layout","id":"internal-mechanics-the-memory-layout"},{"level":3,"text":"The Complete Heap Structure","id":"the-complete-heap-structure"},{"level":3,"text":"Anatomy of an Object Header","id":"anatomy-of-an-object-header"},{"level":3,"text":"Anatomy of a Free Block","id":"anatomy-of-a-free-block"},{"level":3,"text":"Type Descriptors: The Pointer Map","id":"type-descriptors-the-pointer-map"},{"level":2,"text":"The Allocation Algorithm: First-Fit Strategy","id":"the-allocation-algorithm-first-fit-strategy"},{"level":3,"text":"High-Level Flow","id":"high-level-flow"},{"level":3,"text":"The Implementation","id":"the-implementation"},{"level":3,"text":"Block Splitting Visualization","id":"block-splitting-visualization"},{"level":2,"text":"The Deallocation Algorithm: Returning to Free List","id":"the-deallocation-algorithm-returning-to-free-list"},{"level":3,"text":"The Implementation","id":"the-implementation"},{"level":2,"text":"The Debugging Lab: Common Pitfalls","id":"the-debugging-lab-common-pitfalls"},{"level":3,"text":"ğŸ› Bug 1: Off-by-One in Pointer Arithmetic","id":"-bug-1-off-by-one-in-pointer-arithmetic"},{"level":3,"text":"ğŸ› Bug 2: Alignment Violations","id":"-bug-2-alignment-violations"},{"level":3,"text":"ğŸ› Bug 3: Forgetting Minimum Block Size","id":"-bug-3-forgetting-minimum-block-size"},{"level":3,"text":"ğŸ› Bug 4: Fragmentation Death Spiral","id":"-bug-4-fragmentation-death-spiral"},{"level":2,"text":"Visual Reference: Memory State Transitions","id":"visual-reference-memory-state-transitions"},{"level":2,"text":"Code Scaffold: Your Implementation Tasks","id":"code-scaffold-your-implementation-tasks"},{"level":3,"text":"Task 1: Initialize the Heap","id":"task-1-initialize-the-heap"},{"level":3,"text":"Task 2: Implement Allocation","id":"task-2-implement-allocation"},{"level":3,"text":"Task 3: Implement Deallocation","id":"task-3-implement-deallocation"},{"level":3,"text":"Task 4: Helper Functions","id":"task-4-helper-functions"},{"level":2,"text":"Testing Your Implementation","id":"testing-your-implementation"},{"level":3,"text":"Test 1: Basic Allocation","id":"test-1-basic-allocation"},{"level":3,"text":"Test 2: Block Splitting","id":"test-2-block-splitting"},{"level":3,"text":"Test 3: Alignment","id":"test-3-alignment"},{"level":3,"text":"Test 4: Exhaustion","id":"test-4-exhaustion"},{"level":2,"text":"Performance Considerations","id":"performance-considerations"},{"level":3,"text":"Time Complexity","id":"time-complexity"},{"level":3,"text":"Space Overhead","id":"space-overhead"},{"level":3,"text":"Cache Performance","id":"cache-performance"},{"level":2,"text":"What You&#39;ve Learned","id":"what-you39ve-learned"},{"level":2,"text":"Next Steps","id":"next-steps"},{"level":1,"text":"Memory Allocation System: The Heap&#39;s Puzzle Master","id":"memory-allocation-system-the-heap39s-puzzle-master"},{"level":2,"text":"The Epiphany Analogy: The Parking Lot Attendant","id":"the-epiphany-analogy-the-parking-lot-attendant"},{"level":2,"text":"Technical Rationale: Why Allocation Strategies Matter","id":"technical-rationale-why-allocation-strategies-matter"},{"level":3,"text":"The Core Problem","id":"the-core-problem"},{"level":2,"text":"Internal Mechanics: The Three Allocation Strategies","id":"internal-mechanics-the-three-allocation-strategies"},{"level":3,"text":"Strategy 1: First-Fit (Speed Champion)","id":"strategy-1-first-fit-speed-champion"},{"level":3,"text":"Strategy 2: Best-Fit (Space Champion)","id":"strategy-2-best-fit-space-champion"},{"level":3,"text":"Strategy 3: Worst-Fit (The Contrarian)","id":"strategy-3-worst-fit-the-contrarian"},{"level":2,"text":"Visual Reference: Strategy Comparison","id":"visual-reference-strategy-comparison"},{"level":2,"text":"The Block Splitting Decision Tree","id":"the-block-splitting-decision-tree"},{"level":2,"text":"The Deallocation Algorithm: Returning Memory","id":"the-deallocation-algorithm-returning-memory"},{"level":3,"text":"The Simple Approach (No Coalescing)","id":"the-simple-approach-no-coalescing"},{"level":2,"text":"The Debugging Lab: Common Pitfalls","id":"the-debugging-lab-common-pitfalls"},{"level":3,"text":"ğŸ› Bug 1: The Header/Data Pointer Confusion","id":"-bug-1-the-headerdata-pointer-confusion"},{"level":3,"text":"ğŸ› Bug 2: Alignment Violations","id":"-bug-2-alignment-violations"},{"level":3,"text":"ğŸ› Bug 3: Forgetting Minimum Block Size","id":"-bug-3-forgetting-minimum-block-size"},{"level":3,"text":"ğŸ› Bug 4: The Fragmentation Death Spiral","id":"-bug-4-the-fragmentation-death-spiral"},{"level":2,"text":"Visual Reference: Memory State Transitions","id":"visual-reference-memory-state-transitions"},{"level":2,"text":"Code Scaffold: Your Implementation Tasks","id":"code-scaffold-your-implementation-tasks"},{"level":3,"text":"Task 1: Initialize the Heap","id":"task-1-initialize-the-heap"},{"level":3,"text":"Task 2: Implement First-Fit Allocation","id":"task-2-implement-first-fit-allocation"},{"level":3,"text":"Task 3: Implement Deallocation","id":"task-3-implement-deallocation"},{"level":3,"text":"Task 4: Helper Functions","id":"task-4-helper-functions"},{"level":2,"text":"Testing Your Implementation","id":"testing-your-implementation"},{"level":3,"text":"Test Suite","id":"test-suite"},{"level":3,"text":"Test 1: Basic Allocation","id":"test-1-basic-allocation"},{"level":3,"text":"Test 2: Block Splitting","id":"test-2-block-splitting"},{"level":3,"text":"Test 3: Alignment","id":"test-3-alignment"},{"level":3,"text":"Test 4: Minimum Size","id":"test-4-minimum-size"},{"level":3,"text":"Test 5: Heap Exhaustion","id":"test-5-heap-exhaustion"},{"level":3,"text":"Test 6: Fragmentation","id":"test-6-fragmentation"},{"level":2,"text":"Performance Considerations","id":"performance-considerations"},{"level":3,"text":"Time Complexity","id":"time-complexity"},{"level":3,"text":"Space Overhead","id":"space-overhead"},{"level":3,"text":"Cache Performance","id":"cache-performance"},{"level":2,"text":"What You&#39;ve Learned","id":"what-you39ve-learned"},{"level":2,"text":"Next Steps","id":"next-steps"},{"level":1,"text":"Milestone 4: Root Set Identification","id":"milestone-4-root-set-identification"},{"level":2,"text":"The Epiphany Analogy: The Crime Scene Investigation","id":"the-epiphany-analogy-the-crime-scene-investigation"},{"level":2,"text":"Technical Rationale: Why Root Scanning Matters","id":"technical-rationale-why-root-scanning-matters"},{"level":3,"text":"The Reachability Problem","id":"the-reachability-problem"},{"level":3,"text":"The Three Root Sources","id":"the-three-root-sources"},{"level":2,"text":"Internal Mechanics: How Root Scanning Works","id":"internal-mechanics-how-root-scanning-works"},{"level":3,"text":"Architecture Overview","id":"architecture-overview"},{"level":3,"text":"Step 1: Stack Frame Walking","id":"step-1-stack-frame-walking"},{"level":3,"text":"Step 2: Conservative Pointer Detection","id":"step-2-conservative-pointer-detection"},{"level":3,"text":"Step 3: Global Variable Scanning","id":"step-3-global-variable-scanning"},{"level":2,"text":"Visual Reference","id":"visual-reference"},{"level":2,"text":"The Debugging Lab: Common Root Scanning Bugs","id":"the-debugging-lab-common-root-scanning-bugs"},{"level":3,"text":"Bug 1: Missing Stack Frames","id":"bug-1-missing-stack-frames"},{"level":3,"text":"Bug 2: Misaligned Pointer Detection","id":"bug-2-misaligned-pointer-detection"},{"level":3,"text":"Bug 3: False Positives (Conservative Scanning)","id":"bug-3-false-positives-conservative-scanning"},{"level":3,"text":"Bug 4: Register Spilling","id":"bug-4-register-spilling"},{"level":2,"text":"Code Scaffold: Your Implementation Tasks","id":"code-scaffold-your-implementation-tasks"},{"level":3,"text":"Data Structures","id":"data-structures"},{"level":3,"text":"Task 1: Initialize Root Set","id":"task-1-initialize-root-set"},{"level":3,"text":"Task 2: Add Root to Set","id":"task-2-add-root-to-set"},{"level":3,"text":"Task 3: Conservative Pointer Detection","id":"task-3-conservative-pointer-detection"},{"level":3,"text":"Task 4: Stack Scanning","id":"task-4-stack-scanning"},{"level":3,"text":"Task 5: Global Variable Scanning","id":"task-5-global-variable-scanning"},{"level":3,"text":"Task 6: Main Root Scanning Entry Point","id":"task-6-main-root-scanning-entry-point"},{"level":3,"text":"Task 7: Initialize Stack Bottom","id":"task-7-initialize-stack-bottom"},{"level":2,"text":"Testing Your Implementation","id":"testing-your-implementation"},{"level":3,"text":"Test 1: Stack Scanning","id":"test-1-stack-scanning"},{"level":3,"text":"Test 2: Global Scanning","id":"test-2-global-scanning"},{"level":3,"text":"Test 3: Conservative Scanning (False Positives)","id":"test-3-conservative-scanning-false-positives"},{"level":3,"text":"Test 4: Nested Function Calls","id":"test-4-nested-function-calls"},{"level":3,"text":"Test 5: Root Set Resizing","id":"test-5-root-set-resizing"},{"level":2,"text":"Performance Considerations","id":"performance-considerations"},{"level":3,"text":"Time Complexity","id":"time-complexity"},{"level":3,"text":"Space Complexity","id":"space-complexity"},{"level":3,"text":"Optimization: Precise Stack Maps","id":"optimization-precise-stack-maps"},{"level":2,"text":"What You&#39;ve Learned","id":"what-you39ve-learned"},{"level":2,"text":"Next Steps","id":"next-steps"},{"level":1,"text":"Mark Phase Implementation: The Graph Traversal Engine","id":"mark-phase-implementation-the-graph-traversal-engine"},{"level":2,"text":"Epiphany Analogy: The Lighthouse Network","id":"epiphany-analogy-the-lighthouse-network"},{"level":2,"text":"Technical Rationale: Why Iterative Depth-First Traversal?","id":"technical-rationale-why-iterative-depth-first-traversal"},{"level":3,"text":"The Problem: Object Graph Traversal","id":"the-problem-object-graph-traversal"},{"level":3,"text":"Why Not Recursive Traversal?","id":"why-not-recursive-traversal"},{"level":3,"text":"The Solution: Iterative Traversal with Work Queue","id":"the-solution-iterative-traversal-with-work-queue"},{"level":2,"text":"Internal Mechanics: The Mark Phase Architecture","id":"internal-mechanics-the-mark-phase-architecture"},{"level":3,"text":"Component 1: The Work Queue","id":"component-1-the-work-queue"},{"level":3,"text":"Component 2: The Mark Bit","id":"component-2-the-mark-bit"},{"level":3,"text":"Component 3: Object Scanning","id":"component-3-object-scanning"},{"level":2,"text":"The Mark Algorithm: Step-by-Step","id":"the-mark-algorithm-step-by-step"},{"level":3,"text":"Phase 1: Initialization","id":"phase-1-initialization"},{"level":3,"text":"Phase 2: Iterative Traversal","id":"phase-2-iterative-traversal"},{"level":3,"text":"Phase 3: Statistics","id":"phase-3-statistics"},{"level":2,"text":"Visual Reference","id":"visual-reference"},{"level":2,"text":"The Debugging Lab: Common Pitfalls","id":"the-debugging-lab-common-pitfalls"},{"level":3,"text":"Bug 1: Forgetting to Clear Marks","id":"bug-1-forgetting-to-clear-marks"},{"level":3,"text":"Bug 2: Infinite Loop (Cycles)","id":"bug-2-infinite-loop-cycles"},{"level":3,"text":"Bug 3: Queue Overflow","id":"bug-3-queue-overflow"},{"level":3,"text":"Bug 4: Scanning Uninitialized Memory","id":"bug-4-scanning-uninitialized-memory"},{"level":2,"text":"Code Scaffold: Your Implementation Tasks","id":"code-scaffold-your-implementation-tasks"},{"level":3,"text":"Task 1: Work Queue Implementation","id":"task-1-work-queue-implementation"},{"level":3,"text":"Task 2: Clear All Mark Bits","id":"task-2-clear-all-mark-bits"},{"level":3,"text":"Task 3: Object Scanning","id":"task-3-object-scanning"},{"level":3,"text":"Task 4: Main Mark Phase","id":"task-4-main-mark-phase"},{"level":3,"text":"Task 5: Mark Bit Helpers","id":"task-5-mark-bit-helpers"},{"level":2,"text":"Testing Your Implementation","id":"testing-your-implementation"},{"level":3,"text":"Test 1: Simple Linear Chain","id":"test-1-simple-linear-chain"},{"level":3,"text":"Test 2: Cyclic Graph","id":"test-2-cyclic-graph"},{"level":3,"text":"Test 3: Unreachable Objects","id":"test-3-unreachable-objects"},{"level":3,"text":"Test 4: Deep Graph","id":"test-4-deep-graph"},{"level":3,"text":"Test 5: Wide Graph","id":"test-5-wide-graph"},{"level":3,"text":"Test 6: Mark Statistics","id":"test-6-mark-statistics"},{"level":2,"text":"Performance Considerations","id":"performance-considerations"},{"level":3,"text":"Time Complexity","id":"time-complexity"},{"level":3,"text":"Space Complexity","id":"space-complexity"},{"level":3,"text":"Optimization 1: Tri-Color Marking","id":"optimization-1-tri-color-marking"},{"level":3,"text":"Optimization 2: Pointer Filtering","id":"optimization-2-pointer-filtering"},{"level":3,"text":"Optimization 3: Parallel Marking","id":"optimization-3-parallel-marking"},{"level":2,"text":"What You&#39;ve Learned","id":"what-you39ve-learned"},{"level":2,"text":"Next Steps","id":"next-steps"},{"level":1,"text":"Object Graph Traversal: Following the Web of Memory","id":"object-graph-traversal-following-the-web-of-memory"},{"level":2,"text":"The Epiphany Analogy: The Museum Curator&#39;s Flashlight","id":"the-epiphany-analogy-the-museum-curator39s-flashlight"},{"level":2,"text":"Technical Rationale: Why Iterative Traversal?","id":"technical-rationale-why-iterative-traversal"},{"level":3,"text":"The Recursion Trap","id":"the-recursion-trap"},{"level":2,"text":"Internal Mechanics: The Work Queue Algorithm","id":"internal-mechanics-the-work-queue-algorithm"},{"level":3,"text":"Data Structure: The Work Queue","id":"data-structure-the-work-queue"},{"level":3,"text":"Algorithm: Breadth-First Search (BFS)","id":"algorithm-breadth-first-search-bfs"},{"level":2,"text":"The Microscope Effect: Bit-Level Marking","id":"the-microscope-effect-bit-level-marking"},{"level":3,"text":"The Mark Bit","id":"the-mark-bit"},{"level":2,"text":"The Debugging Lab: Common Pitfalls","id":"the-debugging-lab-common-pitfalls"},{"level":3,"text":"Bug #1: Infinite Loop (Cycle Not Detected)","id":"bug-1-infinite-loop-cycle-not-detected"},{"level":3,"text":"Bug #2: Stack Overflow (Despite Iterative Algorithm!)","id":"bug-2-stack-overflow-despite-iterative-algorithm"},{"level":3,"text":"Bug #3: Queue Overflow (Out of Memory)","id":"bug-3-queue-overflow-out-of-memory"},{"level":3,"text":"Bug #4: False Negatives (Objects Not Marked)","id":"bug-4-false-negatives-objects-not-marked"},{"level":2,"text":"Code Scaffold: Your Implementation Tasks","id":"code-scaffold-your-implementation-tasks"},{"level":3,"text":"Task 1: Work Queue Initialization","id":"task-1-work-queue-initialization"},{"level":3,"text":"Task 2: Enqueue with Dynamic Growth","id":"task-2-enqueue-with-dynamic-growth"},{"level":3,"text":"Task 3: Dequeue","id":"task-3-dequeue"},{"level":3,"text":"Task 4: Object Scanning (Conservative)","id":"task-4-object-scanning-conservative"},{"level":3,"text":"Task 5: Main Traversal Loop","id":"task-5-main-traversal-loop"},{"level":2,"text":"Visual Reference","id":"visual-reference"},{"level":2,"text":"Advanced: Tri-Color Invariant","id":"advanced-tri-color-invariant"},{"level":2,"text":"What You&#39;ve Mastered","id":"what-you39ve-mastered"},{"level":2,"text":"Next Challenge","id":"next-challenge"},{"level":1,"text":"Sweep Phase Implementation: The Memory Reclamation Engine","id":"sweep-phase-implementation-the-memory-reclamation-engine"},{"level":2,"text":"The Epiphany Analogy: The Post-Party Cleanup","id":"the-epiphany-analogy-the-post-party-cleanup"},{"level":2,"text":"Technical Rationale: Why We Need Sweep","id":"technical-rationale-why-we-need-sweep"},{"level":3,"text":"The Problem: Fragmented Knowledge","id":"the-problem-fragmented-knowledge"},{"level":3,"text":"The Solution: Linear Heap Scan","id":"the-solution-linear-heap-scan"},{"level":2,"text":"Internal Mechanics: The Sweep Algorithm","id":"internal-mechanics-the-sweep-algorithm"},{"level":3,"text":"Core Data Structures","id":"core-data-structures"},{"level":3,"text":"The Sweep State Machine","id":"the-sweep-state-machine"},{"level":3,"text":"The Algorithm (Pseudocode)","id":"the-algorithm-pseudocode"},{"level":2,"text":"The Debugging Lab: Common Sweep Bugs","id":"the-debugging-lab-common-sweep-bugs"},{"level":3,"text":"Bug #1: Double-Free (Freeing Already-Free Memory)","id":"bug-1-double-free-freeing-already-free-memory"},{"level":3,"text":"Bug #2: Lost Free Blocks (Memory Leak)","id":"bug-2-lost-free-blocks-memory-leak"},{"level":3,"text":"Bug #3: Fragmentation Explosion","id":"bug-3-fragmentation-explosion"},{"level":3,"text":"Bug #4: Incorrect Size Calculation","id":"bug-4-incorrect-size-calculation"},{"level":2,"text":"Visual Reference","id":"visual-reference"},{"level":2,"text":"Code Scaffold: Your Implementation Tasks","id":"code-scaffold-your-implementation-tasks"},{"level":3,"text":"Task 1: Basic Sweep Loop","id":"task-1-basic-sweep-loop"},{"level":3,"text":"Task 2: Free Block Creation","id":"task-2-free-block-creation"},{"level":3,"text":"Task 3: Coalescing Adjacent Blocks","id":"task-3-coalescing-adjacent-blocks"},{"level":3,"text":"Task 4: Sorting the Free List","id":"task-4-sorting-the-free-list"},{"level":3,"text":"Task 5: Statistics Calculation","id":"task-5-statistics-calculation"},{"level":2,"text":"Advanced: Lazy Sweeping","id":"advanced-lazy-sweeping"},{"level":3,"text":"Lazy Sweep Algorithm","id":"lazy-sweep-algorithm"},{"level":2,"text":"Advanced: Parallel Sweeping","id":"advanced-parallel-sweeping"},{"level":3,"text":"Parallel Sweep with Thread-Local Free Lists","id":"parallel-sweep-with-thread-local-free-lists"},{"level":2,"text":"What You&#39;ve Mastered","id":"what-you39ve-mastered"},{"level":2,"text":"Testing Your Implementation","id":"testing-your-implementation"},{"level":2,"text":"Performance Benchmarks","id":"performance-benchmarks"},{"level":2,"text":"Next Challenge","id":"next-challenge"},{"level":1,"text":"Collection Trigger Logic","id":"collection-trigger-logic"},{"level":2,"text":"Epiphany Analogy: The Smart Thermostat","id":"epiphany-analogy-the-smart-thermostat"},{"level":2,"text":"Technical Rationale: Why Trigger Logic Matters","id":"technical-rationale-why-trigger-logic-matters"},{"level":3,"text":"The Fundamental Tradeoff","id":"the-fundamental-tradeoff"},{"level":3,"text":"Real-World Consequences","id":"real-world-consequences"},{"level":2,"text":"Internal Mechanics: Trigger Heuristics","id":"internal-mechanics-trigger-heuristics"},{"level":3,"text":"Strategy 1: Heap Occupancy Threshold","id":"strategy-1-heap-occupancy-threshold"},{"level":3,"text":"Strategy 2: Allocation Rate Tracking","id":"strategy-2-allocation-rate-tracking"},{"level":3,"text":"Strategy 3: Survival Rate Prediction","id":"strategy-3-survival-rate-prediction"},{"level":3,"text":"Strategy 4: Hybrid Multi-Factor Heuristic","id":"strategy-4-hybrid-multi-factor-heuristic"},{"level":2,"text":"Visual Reference","id":"visual-reference"},{"level":2,"text":"The Debugging Lab: Common Trigger Bugs","id":"the-debugging-lab-common-trigger-bugs"},{"level":3,"text":"Bug 1: Trigger Too Late (OOM Crash)","id":"bug-1-trigger-too-late-oom-crash"},{"level":3,"text":"Bug 2: Trigger Too Often (Thrashing)","id":"bug-2-trigger-too-often-thrashing"},{"level":3,"text":"Bug 3: Ignoring Fragmentation","id":"bug-3-ignoring-fragmentation"},{"level":3,"text":"Bug 4: Not Adapting to Workload Changes","id":"bug-4-not-adapting-to-workload-changes"},{"level":2,"text":"Code Scaffold: Your Task","id":"code-scaffold-your-task"},{"level":2,"text":"Advanced: Predictive Triggering","id":"advanced-predictive-triggering"},{"level":2,"text":"Testing Your Implementation","id":"testing-your-implementation"},{"level":2,"text":"Performance Tuning Guide","id":"performance-tuning-guide"},{"level":3,"text":"Tuning for Throughput (Batch Processing)","id":"tuning-for-throughput-batch-processing"},{"level":3,"text":"Tuning for Latency (Interactive Applications)","id":"tuning-for-latency-interactive-applications"},{"level":3,"text":"Tuning for Memory-Constrained Systems","id":"tuning-for-memory-constrained-systems"},{"level":2,"text":"What You&#39;ve Mastered","id":"what-you39ve-mastered"},{"level":2,"text":"Next Steps","id":"next-steps"},{"level":1,"text":"Write Barrier Integration","id":"write-barrier-integration"},{"level":2,"text":"The Epiphany Analogy: The Security Camera System","id":"the-epiphany-analogy-the-security-camera-system"},{"level":2,"text":"Technical Rationale: Why Write Barriers?","id":"technical-rationale-why-write-barriers"},{"level":3,"text":"The Core Problem","id":"the-core-problem"},{"level":2,"text":"The Three Flavors of Write Barriers","id":"the-three-flavors-of-write-barriers"},{"level":3,"text":"1. Snapshot-At-The-Beginning (SATB)","id":"1-snapshot-at-the-beginning-satb"},{"level":3,"text":"2. Incremental Update (Forward Barrier)","id":"2-incremental-update-forward-barrier"},{"level":3,"text":"3. Generational Barrier (Card Marking)","id":"3-generational-barrier-card-marking"},{"level":2,"text":"Internal Mechanics: Implementing Write Barriers","id":"internal-mechanics-implementing-write-barriers"},{"level":3,"text":"Step 1: The Card Table (for Generational GC)","id":"step-1-the-card-table-for-generational-gc"},{"level":3,"text":"Step 2: The Write Barrier Hook","id":"step-2-the-write-barrier-hook"},{"level":4,"text":"Approach A: Compiler Support (Best)","id":"approach-a-compiler-support-best"},{"level":4,"text":"Approach B: Manual Macros (Practical)","id":"approach-b-manual-macros-practical"},{"level":4,"text":"Approach C: Memory Protection (Slow but Automatic)","id":"approach-c-memory-protection-slow-but-automatic"},{"level":3,"text":"Step 3: The Complete Write Barrier Implementation","id":"step-3-the-complete-write-barrier-implementation"},{"level":2,"text":"Visual Reference: Write Barrier in Action","id":"visual-reference-write-barrier-in-action"},{"level":2,"text":"The Debugging Lab: Common Write Barrier Bugs","id":"the-debugging-lab-common-write-barrier-bugs"},{"level":3,"text":"Bug #1: Forgetting the Barrier","id":"bug-1-forgetting-the-barrier"},{"level":3,"text":"Bug #2: Barrier After Write","id":"bug-2-barrier-after-write"},{"level":3,"text":"Bug #3: Barrier on Non-Heap Pointers","id":"bug-3-barrier-on-non-heap-pointers"},{"level":3,"text":"Bug #4: Barrier Performance Overhead","id":"bug-4-barrier-performance-overhead"},{"level":2,"text":"Code Scaffold: Your Task","id":"code-scaffold-your-task"},{"level":2,"text":"Testing Your Write Barrier","id":"testing-your-write-barrier"},{"level":2,"text":"Performance Characteristics","id":"performance-characteristics"},{"level":3,"text":"Write Barrier Overhead","id":"write-barrier-overhead"},{"level":3,"text":"Card Table Granularity Tradeoff","id":"card-table-granularity-tradeoff"},{"level":2,"text":"What You&#39;ve Mastered","id":"what-you39ve-mastered"},{"level":2,"text":"Next Steps","id":"next-steps"},{"level":1,"text":"Fragmentation Management: The Jigsaw Puzzle Problem","id":"fragmentation-management-the-jigsaw-puzzle-problem"},{"level":2,"text":"The Epiphany Analogy: The Parking Lot Paradox","id":"the-epiphany-analogy-the-parking-lot-paradox"},{"level":2,"text":"Technical Rationale: Why Fragmentation Kills Performance","id":"technical-rationale-why-fragmentation-kills-performance"},{"level":3,"text":"The Two Faces of Fragmentation","id":"the-two-faces-of-fragmentation"},{"level":3,"text":"Real-World Impact","id":"real-world-impact"},{"level":2,"text":"Internal Mechanics: The Three-Pronged Defense","id":"internal-mechanics-the-three-pronged-defense"},{"level":3,"text":"Strategy 1: Coalescing (Immediate Neighbor Merging)","id":"strategy-1-coalescing-immediate-neighbor-merging"},{"level":3,"text":"Strategy 2: Compaction (The Nuclear Option)","id":"strategy-2-compaction-the-nuclear-option"},{"level":3,"text":"Strategy 3: Segregated Free Lists (Prevention)","id":"strategy-3-segregated-free-lists-prevention"},{"level":2,"text":"Implementation: Coalescing with Boundary Tags","id":"implementation-coalescing-with-boundary-tags"},{"level":3,"text":"The Data Structure","id":"the-data-structure"},{"level":2,"text":"The Coalescing Algorithm","id":"the-coalescing-algorithm"},{"level":3,"text":"Step-by-Step Breakdown","id":"step-by-step-breakdown"},{"level":3,"text":"Case 1: No Coalescing Needed","id":"case-1-no-coalescing-needed"},{"level":3,"text":"Case 2: Coalesce with Previous Block","id":"case-2-coalesce-with-previous-block"},{"level":3,"text":"Case 3: Coalesce with Next Block","id":"case-3-coalesce-with-next-block"},{"level":3,"text":"Case 4: Coalesce with Both Neighbors","id":"case-4-coalesce-with-both-neighbors"},{"level":2,"text":"Implementation: Compaction (Optional)","id":"implementation-compaction-optional"},{"level":3,"text":"When to Compact","id":"when-to-compact"},{"level":3,"text":"The Compaction Algorithm (Three-Pass)","id":"the-compaction-algorithm-three-pass"},{"level":3,"text":"Updating Pointers During Compaction","id":"updating-pointers-during-compaction"},{"level":2,"text":"The Debugging Lab: Common Fragmentation Bugs","id":"the-debugging-lab-common-fragmentation-bugs"},{"level":3,"text":"Bug 1: Forgetting to Coalesce","id":"bug-1-forgetting-to-coalesce"},{"level":3,"text":"Bug 2: Corrupted Boundary Tags","id":"bug-2-corrupted-boundary-tags"},{"level":3,"text":"Bug 3: Compaction Without Updating All Pointers","id":"bug-3-compaction-without-updating-all-pointers"},{"level":3,"text":"Debugging Tool: Fragmentation Visualizer","id":"debugging-tool-fragmentation-visualizer"},{"level":2,"text":"Code Scaffold: Your Tasks","id":"code-scaffold-your-tasks"},{"level":2,"text":"Testing Your Fragmentation Management","id":"testing-your-fragmentation-management"},{"level":2,"text":"Performance Characteristics","id":"performance-characteristics"},{"level":3,"text":"Coalescing Overhead","id":"coalescing-overhead"},{"level":3,"text":"Compaction Cost","id":"compaction-cost"},{"level":2,"text":"What You&#39;ve Mastered","id":"what-you39ve-mastered"},{"level":2,"text":"Next Steps","id":"next-steps"},{"level":1,"text":"Performance Optimization: Making Your GC Blazingly Fast","id":"performance-optimization-making-your-gc-blazingly-fast"},{"level":2,"text":"Epiphany Analogy: The Formula 1 Pit Stop","id":"epiphany-analogy-the-formula-1-pit-stop"},{"level":2,"text":"Technical Rationale: Why Performance Matters","id":"technical-rationale-why-performance-matters"},{"level":3,"text":"The GC Tax","id":"the-gc-tax"},{"level":3,"text":"The Three Optimization Targets","id":"the-three-optimization-targets"},{"level":2,"text":"Internal Mechanics: Cache-Friendly Marking","id":"internal-mechanics-cache-friendly-marking"},{"level":3,"text":"The Problem: Cache Misses Kill Performance","id":"the-problem-cache-misses-kill-performance"},{"level":3,"text":"Cache-Friendly BFS Marking","id":"cache-friendly-bfs-marking"},{"level":2,"text":"Bitmap Marking: Separate Metadata from Data","id":"bitmap-marking-separate-metadata-from-data"},{"level":3,"text":"The Problem: False Sharing","id":"the-problem-false-sharing"},{"level":3,"text":"Solution: External Bitmap","id":"solution-external-bitmap"},{"level":2,"text":"Parallel Sweep: Multi-threaded Heap Scanning","id":"parallel-sweep-multi-threaded-heap-scanning"},{"level":3,"text":"The Problem: Sweep is Sequential","id":"the-problem-sweep-is-sequential"},{"level":3,"text":"Solution: Parallel Region Sweep","id":"solution-parallel-region-sweep"},{"level":2,"text":"The Debugging Lab: Measuring Performance","id":"the-debugging-lab-measuring-performance"},{"level":3,"text":"Micro-Benchmarking Framework","id":"micro-benchmarking-framework"},{"level":3,"text":"Cache Miss Profiling (Linux)","id":"cache-miss-profiling-linux"},{"level":3,"text":"Common Performance Bugs","id":"common-performance-bugs"},{"level":4,"text":"Bug 1: Unnecessary Pointer Chasing","id":"bug-1-unnecessary-pointer-chasing"},{"level":4,"text":"Bug 2: False Sharing in Parallel Sweep","id":"bug-2-false-sharing-in-parallel-sweep"},{"level":2,"text":"Code Scaffold: Your Optimization Tasks","id":"code-scaffold-your-optimization-tasks"},{"level":2,"text":"Testing Your Optimizations","id":"testing-your-optimizations"},{"level":2,"text":"Performance Characteristics","id":"performance-characteristics"},{"level":3,"text":"Optimization Impact","id":"optimization-impact"},{"level":3,"text":"Real-World Numbers","id":"real-world-numbers"},{"level":3,"text":"When to Optimize What","id":"when-to-optimize-what"},{"level":2,"text":"What You&#39;ve Mastered","id":"what-you39ve-mastered"},{"level":2,"text":"Next Steps","id":"next-steps"},{"level":1,"text":"Testing &amp; Validation: The Crucible of Confidence","id":"testing-amp-validation-the-crucible-of-confidence"},{"level":2,"text":"Epiphany Analogy: The Aircraft Pre-Flight Checklist","id":"epiphany-analogy-the-aircraft-pre-flight-checklist"},{"level":2,"text":"Technical Rationale: Why Testing GCs Is Uniquely Hard","id":"technical-rationale-why-testing-gcs-is-uniquely-hard"},{"level":3,"text":"The Three Horsemen of GC Bugs","id":"the-three-horsemen-of-gc-bugs"},{"level":3,"text":"What We Must Validate","id":"what-we-must-validate"},{"level":2,"text":"Internal Mechanics: The Testing Arsenal","id":"internal-mechanics-the-testing-arsenal"},{"level":3,"text":"1. Leak Detection: The Canary in the Coal Mine","id":"1-leak-detection-the-canary-in-the-coal-mine"},{"level":3,"text":"2. Correctness Validation: The Reachability Oracle","id":"2-correctness-validation-the-reachability-oracle"},{"level":3,"text":"3. Stress Testing: The Chaos Monkey","id":"3-stress-testing-the-chaos-monkey"},{"level":2,"text":"The Debugging Lab: Common Test Failures","id":"the-debugging-lab-common-test-failures"},{"level":3,"text":"Failure 1: &quot;Heap size doesn&#39;t reach zero after GC&quot;","id":"failure-1-quotheap-size-doesn39t-reach-zero-after-gcquot"},{"level":3,"text":"Failure 2: &quot;Segfault in user code after GC&quot;","id":"failure-2-quotsegfault-in-user-code-after-gcquot"},{"level":3,"text":"Failure 3: &quot;Parallel sweep produces different results than sequential&quot;","id":"failure-3-quotparallel-sweep-produces-different-results-than-sequentialquot"},{"level":2,"text":"Code Scaffold: Your Testing Suite","id":"code-scaffold-your-testing-suite"},{"level":3,"text":"Task 1: Implement Leak Detection Test","id":"task-1-implement-leak-detection-test"},{"level":3,"text":"Task 2: Implement Correctness Validation","id":"task-2-implement-correctness-validation"},{"level":3,"text":"Task 3: Implement Stress Tests","id":"task-3-implement-stress-tests"},{"level":3,"text":"Task 4: Implement Parallel Correctness Test","id":"task-4-implement-parallel-correctness-test"},{"level":3,"text":"Task 5: Implement Performance Regression Test","id":"task-5-implement-performance-regression-test"},{"level":3,"text":"Task 6: Implement Memory Safety Test (Valgrind/ASan)","id":"task-6-implement-memory-safety-test-valgrindasan"},{"level":3,"text":"Task 7: Implement Full Test Suite Runner","id":"task-7-implement-full-test-suite-runner"},{"level":2,"text":"Visual Reference","id":"visual-reference"},{"level":2,"text":"The Debugging Lab: Test-Driven Debugging","id":"the-debugging-lab-test-driven-debugging"},{"level":3,"text":"Scenario 1: Intermittent Segfault in Production","id":"scenario-1-intermittent-segfault-in-production"},{"level":3,"text":"Scenario 2: Memory Usage Grows Over Time","id":"scenario-2-memory-usage-grows-over-time"},{"level":3,"text":"Scenario 3: Performance Degrades Over Time","id":"scenario-3-performance-degrades-over-time"},{"level":2,"text":"Performance Characteristics: Test Execution Time","id":"performance-characteristics-test-execution-time"},{"level":2,"text":"What You&#39;ve Mastered","id":"what-you39ve-mastered"},{"level":2,"text":"Next Steps: Beyond Testing","id":"next-steps-beyond-testing"}],"title":"Simple Mark-Sweep Garbage Collector","markdown":"# Simple Mark-Sweep Garbage Collector\n\nA foundational garbage collector implementing the mark-sweep algorithm. This system automatically reclaims memory by identifying reachable objects from root references, marking them as live, and sweeping unreachable objects to free memory. The architecture demonstrates core GC concepts including object graphs, root scanning, tri-color marking, and memory compaction strategies.\n\n\n\n# System Architecture Overview\n\n<div id=\"ms-system-overview\"></div>\n\n## The City Sanitation Analogy\n\nImagine a bustling city where buildings (objects) are constantly being constructed and abandoned. Your garbage collector is the **sanitation department** that must:\n\n1. **Identify which buildings are still in use** by tracing roads (pointers) from government offices (root references)\n2. **Mark active buildings** with a flag so they're not demolished\n3. **Sweep through the city** and demolish abandoned buildings\n4. **Optionally compact** the remaining buildings to eliminate gaps\n\nThe genius? The sanitation department doesn't need residents to call when they abandon a buildingâ€”it figures it out automatically by checking connectivity.\n\n---\n\n## Why This Architecture Exists: The Memory Leak Problem\n\n**The Core Problem**: In manual memory management (like C), programmers must explicitly free every allocated object. This leads to two catastrophic failure modes:\n\n- **Memory leaks**: Forgetting to free â†’ program consumes unbounded memory\n- **Use-after-free bugs**: Freeing too early â†’ dangling pointers cause crashes or security vulnerabilities\n\n**The Solution**: Automatic garbage collection inverts the problem. Instead of tracking \"what should be freed,\" we track \"what must be kept alive.\" Everything else is garbage.\n\n**The Trade-off**: We sacrifice deterministic deallocation and accept periodic pause times in exchange for memory safety and programmer productivity.\n\n---\n\n## The Complete System: A Satellite View\n\nOur mark-sweep garbage collector consists of **five interconnected subsystems** that work in a precise choreography:\n\n{{DIAGRAM:system-overview}}\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    APPLICATION LAYER                         â”‚\nâ”‚  (User code creating objects, manipulating pointers)        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n             â”‚\n             â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  â‘  ROOT SET MANAGER                                         â”‚\nâ”‚  â€¢ Stack scanner (local variables)                          â”‚\nâ”‚  â€¢ Global variable registry                                 â”‚\nâ”‚  â€¢ Thread-local storage roots                               â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n             â”‚\n             â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  â‘¡ HEAP MANAGER                                             â”‚\nâ”‚  â€¢ Free list (available memory blocks)                      â”‚\nâ”‚  â€¢ Allocation policy (first-fit/best-fit)                   â”‚\nâ”‚  â€¢ Object metadata (size, type, mark bit)                   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n             â”‚\n             â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  â‘¢ MARK PHASE ENGINE                                        â”‚\nâ”‚  â€¢ Tri-color abstraction (White/Gray/Black)                 â”‚\nâ”‚  â€¢ Work queue (objects to scan)                             â”‚\nâ”‚  â€¢ Pointer traversal logic                                  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n             â”‚\n             â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  â‘£ SWEEP PHASE ENGINE                                       â”‚\nâ”‚  â€¢ Linear heap scan                                         â”‚\nâ”‚  â€¢ Unmarked object reclamation                              â”‚\nâ”‚  â€¢ Free list reconstruction                                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n             â”‚\n             â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  â‘¤ COMPACTION ENGINE (Optional)                             â”‚\nâ”‚  â€¢ Live object relocation                                   â”‚\nâ”‚  â€¢ Pointer fixup (updating references)                      â”‚\nâ”‚  â€¢ Defragmentation                                          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## Internal Mechanics: How the Pieces Interact\n\n### The GC Cycle Lifecycle\n\n```\nALLOCATION â†’ TRIGGER â†’ MARK â†’ SWEEP â†’ [COMPACT] â†’ RESUME\n```\n\nLet's trace a single garbage collection cycle:\n\n#### **Phase 0: Normal Execution**\n- Application allocates objects via `gc_alloc(size)`\n- Heap manager maintains a **free list** of available memory blocks\n- Each allocation checks: \"Is heap pressure too high?\" If yes â†’ trigger GC\n\n#### **Phase 1: Root Scanning**\nThe Root Set Manager identifies **GC roots**â€”pointers that are inherently reachable:\n\n```c\n// Example roots in a typical program\nvoid* roots[] = {\n    &global_var,           // Global variables\n    stack_frame_locals,    // Local variables on call stack\n    thread_local_storage   // Per-thread static data\n};\n```\n\n**Critical Insight**: Roots are the \"axioms\" of reachability. If an object isn't reachable from a root (directly or transitively), it's garbage.\n\n#### **Phase 2: Mark Phase (Tri-Color Abstraction)**\n\nThe Mark Phase Engine uses a **work queue** to traverse the object graph:\n\n```\nWHITE: Not yet visited (assumed garbage)\nGRAY:  Visited but children not yet scanned (work queue)\nBLACK: Fully processed (confirmed live)\n```\n\n**Algorithm**:\n1. Color all objects WHITE\n2. Color all roots GRAY, add to work queue\n3. While work queue not empty:\n   - Pop object O from queue\n   - For each pointer P in O:\n     - If P points to WHITE object:\n       - Color it GRAY\n       - Add to work queue\n   - Color O BLACK\n\n**Why This Works**: At the end, BLACK objects are reachable, WHITE objects are garbage. GRAY is a temporary state.\n\n#### **Phase 3: Sweep Phase**\n\nThe Sweep Phase Engine performs a **linear scan** of the entire heap:\n\n```c\nfor (each block in heap) {\n    if (block.color == WHITE) {\n        // Unreachable â†’ reclaim\n        add_to_free_list(block);\n    } else {\n        // Live object â†’ reset mark for next cycle\n        block.color = WHITE;\n    }\n}\n```\n\n**Performance Note**: This is O(heap_size), not O(live_objects). Even if only 1% of the heap is live, we scan 100%.\n\n#### **Phase 4: Compaction (Optional)**\n\nThe Compaction Engine eliminates **fragmentation**:\n\n```\nBEFORE:  [OBJ1][FREE][OBJ2][FREE][FREE][OBJ3]\nAFTER:   [OBJ1][OBJ2][OBJ3][FREE][FREE][FREE]\n```\n\n**The Pointer Fixup Problem**: When we move OBJ2, we must update **every pointer** that references it. This requires either:\n- A second heap scan (expensive)\n- Forwarding pointers (extra metadata)\n- A remembered set (complex bookkeeping)\n\n---\n\n## The Data Structures: Memory Layout\n\n### Object Header (Per Allocation)\n\n```c\ntypedef struct {\n    size_t size;        // Object size in bytes\n    uint8_t marked : 1; // Mark bit (0=white, 1=black)\n    uint8_t type : 7;   // Object type ID (for pointer scanning)\n    // Actual object data follows...\n} ObjectHeader;\n```\n\n**Why 1 Bit for Marking?** We only need binary state. Some advanced GCs use 2 bits for tri-color, but we can implement tri-color with 1 bit + a work queue.\n\n### Free List Node\n\n```c\ntypedef struct FreeBlock {\n    size_t size;\n    struct FreeBlock* next;\n} FreeBlock;\n```\n\n**Critical Detail**: Free blocks **reuse the object memory itself** to store the linked list. This is why minimum allocation size must be â‰¥ `sizeof(FreeBlock)`.\n\n### Root Set Registry\n\n```c\ntypedef struct {\n    void** roots;       // Array of pointers to roots\n    size_t count;\n    size_t capacity;\n} RootSet;\n```\n\n---\n\n## The Debugging Lab: Common Failure Modes\n\n### ğŸ› **Bug 1: Premature Collection (False Negative)**\n\n**Symptom**: Live objects are collected, causing use-after-free crashes.\n\n**Root Cause**: A root was not registered. Example:\n\n```c\nObject* temp = gc_alloc(100);\n// If 'temp' is in a register (not on stack), \n// and we don't register it as a root...\ngc_collect(); // BOOM: 'temp' is swept!\n```\n\n**Fix**: Conservative stack scanning (treat anything that looks like a pointer as a root).\n\n### ğŸ› **Bug 2: Memory Leak (False Positive)**\n\n**Symptom**: Memory usage grows unbounded despite GC running.\n\n**Root Cause**: An unintended reference keeps objects alive. Example:\n\n```c\nstatic Object* debug_log[1000]; // Global array\n// If we forget to clear old entries, they'reæ°¸ä¹… roots!\n```\n\n**Fix**: Weak references or explicit nulling.\n\n### ğŸ› **Bug 3: Fragmentation Death Spiral**\n\n**Symptom**: Allocation fails despite sufficient total free memory.\n\n**Root Cause**: Free memory is scattered in small chunks.\n\n```\nHeap: [OBJ][2KB free][OBJ][1KB free][OBJ][3KB free]\nRequest: 5KB â†’ FAIL (no contiguous block)\n```\n\n**Fix**: Implement compaction or use a buddy allocator.\n\n---\n\n## Your Mission: The Code Scaffold\n\nYou will implement this system in **five milestones**:\n\n1. **[Heap Manager](#heap-manager)**: Implement `gc_alloc()` and free list management\n2. **[Root Scanner](#root-scanner)**: Build stack and global variable scanning\n3. **[Mark Engine](#mark-engine)**: Implement tri-color marking with work queue\n4. **[Sweep Engine](#sweep-engine)**: Reclaim unmarked objects\n5. **[Compaction](#compaction)**: (Advanced) Relocate objects and fix pointers\n\n### Starter Code Structure\n\n```c\n// gc.h\ntypedef struct GC {\n    void* heap_start;\n    size_t heap_size;\n    FreeBlock* free_list;\n    RootSet roots;\n    ObjectQueue mark_queue;\n} GC;\n\n// Your tasks:\nGC* gc_init(size_t heap_size);\nvoid* gc_alloc(GC* gc, size_t size);\nvoid gc_collect(GC* gc);\nvoid gc_register_root(GC* gc, void** root);\n```\n\n### Success Criteria\n\nYour implementation must pass these tests:\n\n```c\n// Test 1: Basic allocation\nvoid* obj = gc_alloc(gc, 100);\nassert(obj != NULL);\n\n// Test 2: Collection reclaims garbage\nvoid* temp = gc_alloc(gc, 1000);\ntemp = NULL; // No more references\ngc_collect(gc);\n// Verify 1000 bytes returned to free list\n\n// Test 3: Roots prevent collection\nvoid* root = gc_alloc(gc, 500);\ngc_register_root(gc, &root);\ngc_collect(gc);\nassert(root != NULL); // Still valid!\n```\n\n---\n\n## Navigation: Where to Go Next\n\nThis overview gave you the **30,000-foot view**. Now it's time to zoom in:\n\n- **[Heap Manager â†’](#heap-manager)**: Learn how memory blocks are organized\n- **[Root Scanner â†’](#root-scanner)**: Understand how we find GC roots\n- **[Mark Phase â†’](#mark-engine)**: Deep-dive into graph traversal\n- **[Sweep Phase â†’](#sweep-engine)**: See how we reclaim memory\n- **[Compaction â†’](#compaction)**: Master defragmentation\n\nEach section will follow the same structure: analogy â†’ theory â†’ implementation â†’ debugging.\n\n**Pro Tip**: Keep this system map open in a split-screen. When you get lost in implementation details, return here to see how the piece fits into the whole.\n\n---\n\n[â†‘ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-heap-structure\"></div>\n\n# Milestone 2: Heap Memory Organization\n\n## The Epiphany Analogy: A Self-Storage Facility\n\nImagine a **self-storage facility** with units of different sizes. When a customer needs storage:\n\n1. **The manager checks the vacancy board** (free list) for available units\n2. **Each unit has a label on the door** (object header) showing:\n   - Size of the unit\n   - Whether it's currently inspected/marked for renewal\n   - What type of items are stored (for insurance purposes)\n3. **Empty units are chained together** with signs pointing to the next available unit\n4. **The manager uses a \"first-fit\" strategy**: Walk down the chain until you find a unit big enough\n\n**The Key Insight**: The vacancy signs are **written on the doors of empty units themselves**â€”we don't need a separate building for bookkeeping. This is exactly how heap memory reuses freed space for metadata.\n\n---\n\n## Technical Rationale: Why This Design?\n\n### The Three Fundamental Constraints\n\n**Constraint 1: Metadata Must Be Recoverable**\n- During sweep phase, we must identify object boundaries without external help\n- Solution: Every allocation includes a header with size information\n\n**Constraint 2: Free Space Must Be Trackable**\n- We need O(1) access to available memory blocks\n- Solution: Intrusive linked list (free list) stored in the freed memory itself\n\n**Constraint 3: GC Must Distinguish Pointers from Data**\n- Not all bytes in an object are pointers (e.g., integers, floats)\n- Solution: Type metadata in header tells us which fields to traverse\n\n### Why Not Use `malloc()`?\n\nStandard `malloc()` is **GC-hostile**:\n- No standardized metadata layout (can't iterate heap)\n- No mark bits (can't track reachability)\n- Fragmentation-prone (no compaction support)\n\n**Our heap is a custom allocator** designed for garbage collection.\n\n---\n\n## Internal Mechanics: The Memory Layout\n\n### The Complete Heap Structure\n\n{{DIAGRAM:heap-layout}}\n\n```\nHEAP MEMORY (Contiguous Block)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ HEAP START                                                   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚ â”‚ OBJECT 1 HEADER (16 bytes)                              â”‚ â”‚\nâ”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚ â”‚\nâ”‚ â”‚ â”‚ size: 64 â”‚ marked:0 â”‚ type: 3  â”‚ padding  â”‚          â”‚ â”‚\nâ”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ â”‚\nâ”‚ â”‚ OBJECT 1 DATA (64 bytes)                                â”‚ â”‚\nâ”‚ â”‚ [user data: pointers, integers, etc.]                   â”‚ â”‚\nâ”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚ â”‚ FREE BLOCK HEADER (16 bytes)                            â”‚ â”‚\nâ”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚ â”‚\nâ”‚ â”‚ â”‚ size:128 â”‚ next: â”€â”€â”€â”€â”€â”€â”€â”                   â”‚        â”‚ â”‚\nâ”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚ â”‚\nâ”‚ â”‚ FREE SPACE (128 bytes)    â”‚                             â”‚ â”‚\nâ”‚ â”‚ [unused memory]           â”‚                             â”‚ â”‚\nâ”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚ â”‚ OBJECT 2 HEADER (16 bytes)                              â”‚ â”‚\nâ”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚ â”‚\nâ”‚ â”‚ â”‚ size: 32 â”‚ marked:1 â”‚ type: 1  â”‚ padding  â”‚          â”‚ â”‚\nâ”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ â”‚\nâ”‚ â”‚ OBJECT 2 DATA (32 bytes)                                â”‚ â”‚\nâ”‚ â”‚ [user data]                                             â”‚ â”‚\nâ”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚ â”‚ FREE BLOCK HEADER (16 bytes)                            â”‚ â”‚\nâ”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚ â”‚\nâ”‚ â”‚ â”‚ size:256 â”‚ next: NULL                       â”‚        â”‚ â”‚\nâ”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚ â”‚\nâ”‚ â”‚ FREE SPACE (256 bytes)                                  â”‚ â”‚\nâ”‚ â”‚ [unused memory]                                         â”‚ â”‚\nâ”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ HEAP END                                                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nFREE LIST (Logical View):\nfree_list â†’ [128 bytes] â†’ [256 bytes] â†’ NULL\n```\n\n### Anatomy of an Object Header\n\n```c\ntypedef struct {\n    size_t size;        // Total size INCLUDING header (in bytes)\n    uint8_t marked : 1; // GC mark bit (0=white/unmarked, 1=black/marked)\n    uint8_t type : 7;   // Type ID (0-127) for pointer map lookup\n    uint8_t padding[7]; // Align to 16 bytes (cache line friendly)\n} ObjectHeader;\n\n// Size: 16 bytes (8 + 1 + 7 padding)\n// Alignment: 16-byte boundary (required for SIMD, cache efficiency)\n```\n\n**ğŸ” Quick Breakdown: Why These Fields?**\n\n| Field | Purpose | Size | Critical Details |\n|-------|---------|------|------------------|\n| `size` | Enables heap iteration | 8 bytes | Includes header size! `size >= 16 + user_data` |\n| `marked` | Tri-color marking | 1 bit | 0=WHITE (garbage), 1=BLACK (live) |\n| `type` | Pointer map index | 7 bits | Maps to type descriptor (which fields are pointers) |\n| `padding` | Alignment | 7 bytes | Ensures 16-byte alignment for performance |\n\n**Why 16-Byte Alignment?**\n- Modern CPUs fetch memory in cache lines (64 bytes)\n- Misaligned access causes performance penalties (2x slower on some architectures)\n- SIMD instructions (SSE, AVX) require 16-byte alignment\n\n### Anatomy of a Free Block\n\n```c\ntypedef struct FreeBlock {\n    size_t size;              // Size of this free block (including header)\n    struct FreeBlock* next;   // Pointer to next free block (or NULL)\n    // Remaining bytes are unused\n} FreeBlock;\n\n// Size: 16 bytes minimum (8 + 8)\n// The rest of the block is unused memory\n```\n\n**Critical Insight**: Free blocks **overwrite** the object header. When we allocate, we convert:\n\n```\nFREE BLOCK                    ALLOCATED OBJECT\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ size: 128    â”‚             â”‚ size: 128    â”‚\nâ”‚ next: 0x...  â”‚    â”€â”€â”€â–º     â”‚ marked: 0    â”‚\nâ”‚ [unused]     â”‚             â”‚ type: 5      â”‚\nâ”‚ [unused]     â”‚             â”‚ [user data]  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Type Descriptors: The Pointer Map\n\n```c\ntypedef struct {\n    uint8_t type_id;           // Matches ObjectHeader.type\n    size_t field_count;        // Number of fields in this type\n    size_t* pointer_offsets;   // Array of byte offsets to pointer fields\n} TypeDescriptor;\n\n// Example: A \"Person\" object with 2 pointers\nTypeDescriptor person_type = {\n    .type_id = 3,\n    .field_count = 2,\n    .pointer_offsets = (size_t[]){0, 8}  // Pointers at bytes 0 and 8\n};\n```\n\n**Why This Matters**: During mark phase, we need to know which bytes are pointers:\n\n```c\n// Object layout for type 3 (Person):\n// [0-7]:   char* name     (POINTER - must follow)\n// [8-15]:  Person* friend (POINTER - must follow)\n// [16-19]: int age        (NOT A POINTER - skip)\n```\n\n---\n\n## The Allocation Algorithm: First-Fit Strategy\n\n### High-Level Flow\n\n{{DIAGRAM:allocation-flow}}\n\n```\ngc_alloc(size) called\n        â”‚\n        â–¼\n    Align size to 16-byte boundary\n    Add sizeof(ObjectHeader)\n        â”‚\n        â–¼\n    Traverse free list\n        â”‚\n        â”œâ”€â–º Block too small? â”€â”€â–º Continue to next\n        â”‚\n        â”œâ”€â–º Block exact fit? â”€â”€â–º Remove from list, return\n        â”‚\n        â””â”€â–º Block too large? â”€â”€â–º Split block:\n                                  â”Œâ”€ Allocated part (return)\n                                  â””â”€ Remainder (keep in list)\n```\n\n### The Implementation\n\n```c\nvoid* gc_alloc(GC* gc, size_t size) {\n    // Step 1: Calculate total size needed\n    size_t aligned_size = ALIGN_16(size);  // Round up to 16-byte boundary\n    size_t total_size = sizeof(ObjectHeader) + aligned_size;\n    \n    // Step 2: Ensure minimum allocation size\n    if (total_size < sizeof(FreeBlock)) {\n        total_size = sizeof(FreeBlock);  // Must fit free list node later\n    }\n    \n    // Step 3: Search free list (first-fit)\n    FreeBlock** prev_ptr = &gc->free_list;  // Pointer to previous 'next' field\n    FreeBlock* current = gc->free_list;\n    \n    while (current != NULL) {\n        if (current->size >= total_size) {\n            // Found a suitable block!\n            \n            // Step 4: Should we split the block?\n            size_t remainder = current->size - total_size;\n            \n            if (remainder >= sizeof(FreeBlock)) {\n                // Split: Create new free block from remainder\n                FreeBlock* new_free = (FreeBlock*)((char*)current + total_size);\n                new_free->size = remainder;\n                new_free->next = current->next;\n                \n                // Update current block size\n                current->size = total_size;\n                \n                // Link new free block into list\n                *prev_ptr = new_free;\n            } else {\n                // No split: Use entire block (avoid tiny fragments)\n                *prev_ptr = current->next;\n            }\n            \n            // Step 5: Initialize object header\n            ObjectHeader* header = (ObjectHeader*)current;\n            header->size = current->size;  // Actual allocated size\n            header->marked = 0;            // Start unmarked (WHITE)\n            header->type = 0;              // Caller will set this\n            \n            // Step 6: Return pointer to data (skip header)\n            return (void*)(header + 1);\n        }\n        \n        // Move to next block\n        prev_ptr = &current->next;\n        current = current->next;\n    }\n    \n    // Step 7: Out of memory - trigger GC\n    gc_collect(gc);\n    \n    // Retry allocation (recursive call)\n    return gc_alloc(gc, size);  // WARNING: Can infinite loop if heap too small!\n}\n```\n\n**ğŸ” Quick Breakdown: The Pointer Trick**\n\n```c\nFreeBlock** prev_ptr = &gc->free_list;\n```\n\nThis is a **pointer to a pointer**. It allows us to modify the previous node's `next` field without special-casing the head of the list:\n\n```\n// Without prev_ptr (ugly):\nif (current == gc->free_list) {\n    gc->free_list = current->next;  // Special case for head\n} else {\n    prev->next = current->next;     // General case\n}\n\n// With prev_ptr (elegant):\n*prev_ptr = current->next;  // Works for both head and middle!\n```\n\n### Block Splitting Visualization\n\n{{DIAGRAM:block-split}}\n\n```\nBEFORE ALLOCATION (Request: 64 bytes)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ FREE BLOCK                             â”‚\nâ”‚ size: 256                              â”‚\nâ”‚ next: NULL                             â”‚\nâ”‚ [240 bytes unused]                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nAFTER ALLOCATION (Split into 80 + 176)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ ALLOCATED OBJECT     â”‚ â”‚ NEW FREE BLOCK        â”‚\nâ”‚ size: 80             â”‚ â”‚ size: 176             â”‚\nâ”‚ marked: 0            â”‚ â”‚ next: NULL            â”‚\nâ”‚ type: 0              â”‚ â”‚ [160 bytes unused]    â”‚\nâ”‚ [64 bytes user data] â”‚ â”‚                       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         80 bytes              176 bytes\n```\n\n**Why Split?** Without splitting, we'd waste 176 bytes of the 256-byte block. Splitting allows future allocations to use the remainder.\n\n**Why Not Always Split?** If remainder < 16 bytes, it's too small to be useful. We'd create \"dust\" that fragments the heap.\n\n---\n\n## The Deallocation Algorithm: Returning to Free List\n\n### The Implementation\n\n```c\nvoid gc_free(GC* gc, void* ptr) {\n    if (ptr == NULL) return;\n    \n    // Step 1: Get object header (ptr points to data, not header)\n    ObjectHeader* header = ((ObjectHeader*)ptr) - 1;\n    \n    // Step 2: Convert to free block\n    FreeBlock* block = (FreeBlock*)header;\n    block->size = header->size;  // Preserve size\n    \n    // Step 3: Insert at head of free list (O(1) operation)\n    block->next = gc->free_list;\n    gc->free_list = block;\n    \n    // Note: We do NOT coalesce adjacent blocks here (done during sweep)\n}\n```\n\n**Why Insert at Head?** It's O(1). Inserting in sorted order would be O(n) but enable better coalescing. Trade-off: simplicity vs. fragmentation.\n\n---\n\n## The Debugging Lab: Common Pitfalls\n\n### ğŸ› **Bug 1: Off-by-One in Pointer Arithmetic**\n\n**Symptom**: Segmentation fault when accessing allocated memory.\n\n**Root Cause**: Forgetting that `gc_alloc()` returns a pointer to **data**, not the header.\n\n```c\n// WRONG: Treats data pointer as header\nvoid* ptr = gc_alloc(gc, 64);\nObjectHeader* header = (ObjectHeader*)ptr;  // âŒ Points to user data!\nheader->marked = 1;  // Corrupts user data\n\n// CORRECT: Subtract header size\nObjectHeader* header = ((ObjectHeader*)ptr) - 1;  // âœ… Points to actual header\n```\n\n**Visual Explanation**:\n```\nMemory Layout:\n[HEADER][DATA DATA DATA]\n   â†‘       â†‘\n   |       â””â”€ gc_alloc() returns this\n   â””â”€ Header is HERE (ptr - sizeof(ObjectHeader))\n```\n\n### ğŸ› **Bug 2: Alignment Violations**\n\n**Symptom**: Bus error on ARM, performance degradation on x86.\n\n**Root Cause**: Allocating unaligned sizes.\n\n```c\n// WRONG: 13 bytes is not 16-byte aligned\nvoid* ptr = gc_alloc(gc, 13);  // âŒ May return unaligned pointer\n\n// CORRECT: Always align\n#define ALIGN_16(size) (((size) + 15) & ~15)\nvoid* ptr = gc_alloc(gc, ALIGN_16(13));  // âœ… Allocates 16 bytes\n```\n\n**The Bit Trick Explained**:\n```\nsize = 13 (binary: 0000 1101)\nsize + 15 = 28   (binary: 0001 1100)\n~15 = ...1111 0000 (mask)\n28 & ~15 = 16    (binary: 0001 0000)  â† Rounded up!\n```\n\n### ğŸ› **Bug 3: Forgetting Minimum Block Size**\n\n**Symptom**: Crash during `gc_free()` when trying to create free list node.\n\n**Root Cause**: Allocated block is smaller than `sizeof(FreeBlock)`.\n\n```c\n// WRONG: 8-byte allocation can't hold FreeBlock (16 bytes)\nvoid* ptr = gc_alloc(gc, 8);\ngc_free(gc, ptr);  // âŒ Overwrites adjacent memory!\n\n// CORRECT: Enforce minimum in gc_alloc()\nif (total_size < sizeof(FreeBlock)) {\n    total_size = sizeof(FreeBlock);\n}\n```\n\n### ğŸ› **Bug 4: Fragmentation Death Spiral**\n\n**Symptom**: Allocation fails despite sufficient total free memory.\n\n**Scenario**:\n```\nFree List: [16 bytes] â†’ [16 bytes] â†’ [16 bytes] â†’ [16 bytes]\nRequest: 64 bytes\nResult: FAIL (no contiguous block, even though 64 bytes are free)\n```\n\n**Fix Options**:\n1. **Coalescing**: Merge adjacent free blocks during sweep\n2. **Compaction**: Move live objects together (covered in Milestone 5)\n3. **Best-Fit**: Search for smallest sufficient block (reduces fragmentation)\n\n---\n\n## Visual Reference: Memory State Transitions\n\n{{DIAGRAM:state-transitions}}\n\n```\nINITIAL STATE (Empty Heap)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ FREE BLOCK                             â”‚\nâ”‚ size: 1024                             â”‚\nâ”‚ next: NULL                             â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nfree_list â†’ [1024]\n\nAFTER gc_alloc(gc, 64)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ OBJECT       â”‚ â”‚ FREE BLOCK           â”‚\nâ”‚ size: 80     â”‚ â”‚ size: 944            â”‚\nâ”‚ marked: 0    â”‚ â”‚ next: NULL           â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nfree_list â†’ [944]\n\nAFTER gc_alloc(gc, 128)\nâ”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ OBJ1 â”‚ â”‚ OBJ2   â”‚ â”‚ FREE BLOCK       â”‚\nâ”‚ 80   â”‚ â”‚ 144    â”‚ â”‚ size: 800        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nfree_list â†’ [800]\n\nAFTER gc_free(OBJ1)\nâ”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ FREE â”‚ â”‚ OBJ2   â”‚ â”‚ FREE BLOCK       â”‚\nâ”‚ 80 â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¤ size: 800        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nfree_list â†’ [80] â†’ [800]\n```\n\n---\n\n## Code Scaffold: Your Implementation Tasks\n\n### Task 1: Initialize the Heap\n\n```c\nGC* gc_init(size_t heap_size) {\n    // TODO: Allocate GC structure\n    GC* gc = malloc(sizeof(GC));\n    \n    // TODO: Allocate heap memory (use mmap or malloc)\n    gc->heap_start = malloc(heap_size);\n    gc->heap_size = heap_size;\n    \n    // TODO: Initialize free list with entire heap as one block\n    FreeBlock* initial_block = (FreeBlock*)gc->heap_start;\n    initial_block->size = heap_size;\n    initial_block->next = NULL;\n    gc->free_list = initial_block;\n    \n    // TODO: Initialize root set (covered in next milestone)\n    gc->roots.roots = NULL;\n    gc->roots.count = 0;\n    gc->roots.capacity = 0;\n    \n    return gc;\n}\n```\n\n### Task 2: Implement Allocation\n\n```c\nvoid* gc_alloc(GC* gc, size_t size) {\n    // TODO: Implement first-fit allocation (see algorithm above)\n    // Remember to:\n    // 1. Align size to 16 bytes\n    // 2. Add header size\n    // 3. Enforce minimum block size\n    // 4. Split blocks when remainder is large enough\n    // 5. Initialize object header\n    // 6. Return pointer to DATA (not header)\n    \n    return NULL;  // Replace with your implementation\n}\n```\n\n### Task 3: Implement Deallocation\n\n```c\nvoid gc_free(GC* gc, void* ptr) {\n    // TODO: Convert object to free block and add to free list\n    // Remember to:\n    // 1. Handle NULL pointer\n    // 2. Get header from data pointer\n    // 3. Convert to FreeBlock\n    // 4. Insert into free list\n}\n```\n\n### Task 4: Helper Functions\n\n```c\n// Get object header from data pointer\nstatic inline ObjectHeader* get_header(void* ptr) {\n    return ((ObjectHeader*)ptr) - 1;\n}\n\n// Get data pointer from header\nstatic inline void* get_data(ObjectHeader* header) {\n    return (void*)(header + 1);\n}\n\n// Check if pointer is within heap bounds\nbool is_heap_pointer(GC* gc, void* ptr) {\n    return ptr >= gc->heap_start && \n           ptr < (void*)((char*)gc->heap_start + gc->heap_size);\n}\n```\n\n---\n\n## Testing Your Implementation\n\n### Test 1: Basic Allocation\n\n```c\nvoid test_basic_allocation() {\n    GC* gc = gc_init(1024);\n    \n    void* obj1 = gc_alloc(gc, 64);\n    assert(obj1 != NULL);\n    \n    void* obj2 = gc_alloc(gc, 128);\n    assert(obj2 != NULL);\n    \n    // Verify objects don't overlap\n    assert((char*)obj2 >= (char*)obj1 + 64 + sizeof(ObjectHeader));\n    \n    printf(\"âœ“ Basic allocation test passed\\n\");\n}\n```\n\n### Test 2: Block Splitting\n\n```c\nvoid test_block_splitting() {\n    GC* gc = gc_init(1024);\n    \n    void* obj = gc_alloc(gc, 64);\n    \n    // Verify free list still has space\n    assert(gc->free_list != NULL);\n    assert(gc->free_list->size > 0);\n    \n    printf(\"âœ“ Block splitting test passed\\n\");\n}\n```\n\n### Test 3: Alignment\n\n```c\nvoid test_alignment() {\n    GC* gc = gc_init(1024);\n    \n    void* obj = gc_alloc(gc, 13);  // Odd size\n    \n    // Verify 16-byte alignment\n    assert(((uintptr_t)obj & 15) == 0);\n    \n    printf(\"âœ“ Alignment test passed\\n\");\n}\n```\n\n### Test 4: Exhaustion\n\n```c\nvoid test_heap_exhaustion() {\n    GC* gc = gc_init(256);  // Small heap\n    \n    void* obj1 = gc_alloc(gc, 100);\n    void* obj2 = gc_alloc(gc, 100);\n    \n    // This should trigger GC (which will fail since nothing is freeable)\n    void* obj3 = gc_alloc(gc, 100);\n    \n    // In a real implementation, this should return NULL or abort\n    // For now, just verify we don't crash\n    \n    printf(\"âœ“ Heap exhaustion test passed\\n\");\n}\n```\n\n---\n\n## Performance Considerations\n\n### Time Complexity\n\n| Operation | Complexity | Reason |\n|-----------|-----------|--------|\n| `gc_alloc()` | O(n) worst case | Must traverse free list |\n| `gc_free()` | O(1) | Insert at head |\n| Heap iteration | O(heap_size) | Must scan entire heap |\n\n### Space Overhead\n\n```\nPer-object overhead: 16 bytes (header)\nFor 64-byte object: 16/80 = 20% overhead\nFor 1KB object: 16/1040 = 1.5% overhead\n```\n\n**Optimization**: For small objects, use a separate **small object allocator** (e.g., slab allocator) to reduce overhead.\n\n### Cache Performance\n\n**Good**: 16-byte alignment ensures cache-line alignment  \n**Bad**: Free list traversal has poor spatial locality (random jumps)  \n**Fix**: Use segregated free lists (separate lists for different size classes)\n\n---\n\n## What You've Learned\n\nâœ… **Memory Layout**: How objects and free blocks coexist in the heap  \nâœ… **Allocation Strategy**: First-fit algorithm with block splitting  \nâœ… **Metadata Design**: Object headers and type descriptors  \nâœ… **Pointer Arithmetic**: Converting between headers and data pointers  \nâœ… **Alignment**: Why and how to align memory allocations  \n\n---\n\n## Next Steps\n\nNow that you understand heap organization, you're ready to tackle:\n\n- **[Root Scanner â†’](#root-scanner)**: How to find GC roots on the stack and in globals\n- **[Mark Phase â†’](#mark-engine)**: Traversing the object graph to find live objects\n- **[Sweep Phase â†’](#sweep-engine)**: Reclaiming unmarked objects and rebuilding the free list\n\n**Pro Tip**: Before moving on, make sure your `gc_alloc()` passes all tests. The rest of the GC depends on a correct heap implementation.\n\n---\n\n[â†‘ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-allocation\"></div>\n\n# Memory Allocation System: The Heap's Puzzle Master\n\n## The Epiphany Analogy: The Parking Lot Attendant\n\nImagine you're managing a parking lot with 1,000 spaces. Cars of different sizes arrive constantly:\n\n- **Motorcycles** (small objects): Need 1 space\n- **Sedans** (medium objects): Need 2 spaces  \n- **Buses** (large objects): Need 10 spaces\n\nYour job as the attendant is to:\n1. **Find a spot** that fits each vehicle (allocation)\n2. **Split large empty sections** when a small car parks (block splitting)\n3. **Track which spaces are free** (free list management)\n4. **Decide which spot to use** when multiple options exist (allocation strategy)\n\nThe challenge? Over time, you get **fragmentation**: empty spaces scattered everywhere, but no contiguous section large enough for a busâ€”even though total empty spaces exceed 10!\n\nThis is **exactly** what a memory allocator does. Let's build one.\n\n---\n\n## Technical Rationale: Why Allocation Strategies Matter\n\n### The Core Problem\n\nWhen your program calls `gc_alloc(gc, 64)`, the allocator must answer three questions:\n\n1. **Where?** Which free block should we use?\n2. **How much?** Should we use the entire block or split it?\n3. **What next?** How do we update the free list?\n\n**Bad decisions** lead to:\n- **External fragmentation**: Free memory scattered in unusable chunks\n- **Internal fragmentation**: Wasted space within allocated blocks\n- **Allocation failures**: `malloc()` returns NULL despite available memory\n\n**Good strategies** balance:\n- **Speed**: O(1) vs O(n) search time\n- **Memory efficiency**: Minimizing wasted space\n- **Simplicity**: Easier to debug and maintain\n\n---\n\n## Internal Mechanics: The Three Allocation Strategies\n\n### Strategy 1: First-Fit (Speed Champion)\n\n**Algorithm**: Use the **first** free block that's large enough.\n\n```c\nvoid* gc_alloc_first_fit(GC* gc, size_t size) {\n    // Step 1: Calculate total size needed\n    size_t aligned_size = ALIGN_16(size);\n    size_t total_size = sizeof(ObjectHeader) + aligned_size;\n    \n    // Enforce minimum block size (must fit FreeBlock later)\n    if (total_size < sizeof(FreeBlock)) {\n        total_size = sizeof(FreeBlock);\n    }\n    \n    // Step 2: Search free list for first suitable block\n    FreeBlock** current = &gc->free_list;  // Pointer to pointer for easy removal\n    \n    while (*current != NULL) {\n        FreeBlock* block = *current;\n        \n        if (block->size >= total_size) {\n            // Found a fit!\n            \n            // Step 3: Decide whether to split\n            size_t remainder = block->size - total_size;\n            \n            if (remainder >= sizeof(FreeBlock)) {\n                // Split: Create new free block from remainder\n                FreeBlock* new_block = (FreeBlock*)((char*)block + total_size);\n                new_block->size = remainder;\n                new_block->next = block->next;\n                \n                // Update free list to skip allocated portion\n                *current = new_block;\n            } else {\n                // Don't split: Use entire block (wastes remainder)\n                total_size = block->size;  // Absorb the \"dust\"\n                *current = block->next;    // Remove from free list\n            }\n            \n            // Step 4: Initialize object header\n            ObjectHeader* header = (ObjectHeader*)block;\n            header->size = total_size;\n            header->marked = 0;\n            header->type = 0;  // Will be set by caller\n            \n            // Step 5: Return pointer to DATA (not header)\n            return (void*)(header + 1);\n        }\n        \n        current = &(*current)->next;  // Advance to next block\n    }\n    \n    // No suitable block found\n    return NULL;\n}\n```\n\n**Pros**:\n- âš¡ **Fast**: O(1) best case, O(n) worst case\n- ğŸ¯ **Simple**: Easy to implement and debug\n\n**Cons**:\n- ğŸ’” **Fragmentation**: Leaves small unusable blocks at the start of the heap\n- ğŸ“Š **Unpredictable**: Performance varies based on allocation history\n\n**When to Use**: General-purpose allocators, real-time systems (predictable worst-case)\n\n---\n\n### Strategy 2: Best-Fit (Space Champion)\n\n**Algorithm**: Use the **smallest** free block that's large enough.\n\n```c\nvoid* gc_alloc_best_fit(GC* gc, size_t size) {\n    size_t aligned_size = ALIGN_16(size);\n    size_t total_size = sizeof(ObjectHeader) + aligned_size;\n    \n    if (total_size < sizeof(FreeBlock)) {\n        total_size = sizeof(FreeBlock);\n    }\n    \n    // Step 1: Search entire free list for best fit\n    FreeBlock** best = NULL;\n    FreeBlock** current = &gc->free_list;\n    size_t best_size = SIZE_MAX;\n    \n    while (*current != NULL) {\n        FreeBlock* block = *current;\n        \n        if (block->size >= total_size && block->size < best_size) {\n            best = current;\n            best_size = block->size;\n            \n            // Perfect fit? Stop searching\n            if (block->size == total_size) {\n                break;\n            }\n        }\n        \n        current = &(*current)->next;\n    }\n    \n    if (best == NULL) {\n        return NULL;  // No suitable block\n    }\n    \n    // Step 2: Allocate from best block (same splitting logic as first-fit)\n    FreeBlock* block = *best;\n    size_t remainder = block->size - total_size;\n    \n    if (remainder >= sizeof(FreeBlock)) {\n        FreeBlock* new_block = (FreeBlock*)((char*)block + total_size);\n        new_block->size = remainder;\n        new_block->next = block->next;\n        *best = new_block;\n    } else {\n        total_size = block->size;\n        *best = block->next;\n    }\n    \n    ObjectHeader* header = (ObjectHeader*)block;\n    header->size = total_size;\n    header->marked = 0;\n    header->type = 0;\n    \n    return (void*)(header + 1);\n}\n```\n\n**Pros**:\n- ğŸ’¾ **Space-efficient**: Minimizes wasted space per allocation\n- ğŸ§© **Less fragmentation**: Leaves larger contiguous blocks\n\n**Cons**:\n- ğŸŒ **Slower**: Always O(n) (must scan entire list)\n- ğŸª² **Paradox**: Can create more small \"dust\" blocks over time\n\n**When to Use**: Memory-constrained systems, long-running servers\n\n---\n\n### Strategy 3: Worst-Fit (The Contrarian)\n\n**Algorithm**: Use the **largest** free block.\n\n**Rationale**: Splitting large blocks leaves large remainders, reducing fragmentation.\n\n```c\nvoid* gc_alloc_worst_fit(GC* gc, size_t size) {\n    // Similar to best-fit, but search for LARGEST block\n    FreeBlock** worst = NULL;\n    FreeBlock** current = &gc->free_list;\n    size_t worst_size = 0;\n    \n    while (*current != NULL) {\n        FreeBlock* block = *current;\n        \n        if (block->size >= total_size && block->size > worst_size) {\n            worst = current;\n            worst_size = block->size;\n        }\n        \n        current = &(*current)->next;\n    }\n    \n    // ... (same allocation logic)\n}\n```\n\n**Pros**:\n- ğŸ¯ **Large remainders**: Splits leave usable blocks\n- ğŸ“ˆ **Predictable**: Consistent behavior\n\n**Cons**:\n- ğŸŒ **Slow**: Always O(n)\n- ğŸ’” **Wastes large blocks**: Quickly exhausts big contiguous regions\n\n**When to Use**: Rarely in practice (academic interest)\n\n---\n\n## Visual Reference: Strategy Comparison\n\n{{DIAGRAM:allocation-strategies}}\n\n```\nSCENARIO: Allocate 64 bytes from this free list\n\nFree List State:\n[100 bytes] â†’ [200 bytes] â†’ [80 bytes] â†’ [500 bytes]\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nFIRST-FIT: Uses first sufficient block\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [100 bytes] â† SELECTED (first that fits)            â”‚\nâ”‚ Result: [64 allocated] [36 remainder]               â”‚\nâ”‚ New Free List: [36] â†’ [200] â†’ [80] â†’ [500]         â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nTime: O(1) in this case\nWaste: 0 bytes (remainder is usable)\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nBEST-FIT: Uses smallest sufficient block\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [80 bytes] â† SELECTED (smallest that fits)          â”‚\nâ”‚ Result: [64 allocated] [16 remainder]               â”‚\nâ”‚ New Free List: [100] â†’ [200] â†’ [16] â†’ [500]        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nTime: O(n) - must scan entire list\nWaste: 0 bytes, but created small 16-byte block\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nWORST-FIT: Uses largest block\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [500 bytes] â† SELECTED (largest available)          â”‚\nâ”‚ Result: [64 allocated] [436 remainder]              â”‚\nâ”‚ New Free List: [100] â†’ [200] â†’ [80] â†’ [436]        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nTime: O(n) - must scan entire list\nWaste: 0 bytes, large remainder preserved\n```\n\n---\n\n## The Block Splitting Decision Tree\n\n**Critical Question**: When should we split a free block?\n\n```c\n// The splitting threshold\n#define MIN_SPLIT_SIZE sizeof(FreeBlock)  // Typically 16 bytes\n\nif (block->size - total_size >= MIN_SPLIT_SIZE) {\n    // SPLIT: Remainder is large enough to be useful\n    split_block(block, total_size);\n} else {\n    // DON'T SPLIT: Remainder is \"dust\" - absorb it\n    total_size = block->size;\n}\n```\n\n**Example**:\n\n```\nRequest: 64 bytes (80 with header)\nBlock: 96 bytes\n\nRemainder: 96 - 80 = 16 bytes\nDecision: SPLIT (16 >= 16)\n\nResult:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ ALLOCATED    â”‚ â”‚ FREE         â”‚\nâ”‚ 80 bytes     â”‚ â”‚ 16 bytes     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n```\nRequest: 64 bytes (80 with header)\nBlock: 88 bytes\n\nRemainder: 88 - 80 = 8 bytes\nDecision: DON'T SPLIT (8 < 16)\n\nResult:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ ALLOCATED            â”‚\nâ”‚ 88 bytes (8 wasted)  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Why 16 bytes?** That's the size of `FreeBlock`:\n\n```c\ntypedef struct FreeBlock {\n    size_t size;           // 8 bytes\n    struct FreeBlock* next; // 8 bytes\n} FreeBlock;  // Total: 16 bytes\n```\n\nIf remainder < 16 bytes, we can't create a valid free block node!\n\n---\n\n## The Deallocation Algorithm: Returning Memory\n\n### The Simple Approach (No Coalescing)\n\n```c\nvoid gc_free(GC* gc, void* ptr) {\n    if (ptr == NULL) return;\n    \n    // Step 1: Get object header (ptr points to data, not header)\n    ObjectHeader* header = ((ObjectHeader*)ptr) - 1;\n    \n    // Step 2: Verify pointer is within heap bounds (safety check)\n    if (!is_heap_pointer(gc, header)) {\n        fprintf(stderr, \"ERROR: Attempt to free invalid pointer %p\\n\", ptr);\n        abort();\n    }\n    \n    // Step 3: Convert to free block\n    FreeBlock* block = (FreeBlock*)header;\n    block->size = header->size;  // Preserve size\n    \n    // Step 4: Insert at head of free list (O(1) operation)\n    block->next = gc->free_list;\n    gc->free_list = block;\n    \n    // Note: We do NOT coalesce adjacent blocks here\n    // That's done during the sweep phase (Milestone 4)\n}\n```\n\n**Why Insert at Head?**\n\n```\nBefore: free_list â†’ [200] â†’ [100] â†’ NULL\nFree 80-byte block\n\nAfter:  free_list â†’ [80] â†’ [200] â†’ [100] â†’ NULL\n                     â†‘\n                     New head (O(1) insertion)\n```\n\n**Alternative**: Insert in **address order** (enables immediate coalescing):\n\n```c\nvoid gc_free_sorted(GC* gc, void* ptr) {\n    ObjectHeader* header = ((ObjectHeader*)ptr) - 1;\n    FreeBlock* block = (FreeBlock*)header;\n    block->size = header->size;\n    \n    // Find insertion point (keep list sorted by address)\n    FreeBlock** current = &gc->free_list;\n    \n    while (*current != NULL && *current < block) {\n        current = &(*current)->next;\n    }\n    \n    // Insert block\n    block->next = *current;\n    *current = block;\n    \n    // Coalesce with next block if adjacent\n    if ((char*)block + block->size == (char*)block->next) {\n        block->size += block->next->size;\n        block->next = block->next->next;\n    }\n    \n    // Coalesce with previous block (requires tracking prev pointer)\n    // ... (left as exercise)\n}\n```\n\n**Trade-off**: O(n) insertion vs. reduced fragmentation\n\n---\n\n## The Debugging Lab: Common Pitfalls\n\n### ğŸ› **Bug 1: The Header/Data Pointer Confusion**\n\n**Symptom**: Segmentation fault, corrupted memory\n\n**Root Cause**: Treating data pointer as header pointer\n\n```c\n// WRONG: Treats data pointer as header\nvoid* ptr = gc_alloc(gc, 64);\nObjectHeader* header = (ObjectHeader*)ptr;  // âŒ Points to user data!\nheader->marked = 1;  // Corrupts first 4 bytes of user data\n\n// CORRECT: Subtract header size\nObjectHeader* header = ((ObjectHeader*)ptr) - 1;  // âœ… Points to actual header\n```\n\n**Memory Layout Visualization**:\n\n```\nWhat gc_alloc() returns:\n                    â”Œâ”€ ptr (returned to user)\n                    â†“\n[HEADER: 16 bytes][DATA: 64 bytes]\n â†‘\n â””â”€ Actual header location (ptr - sizeof(ObjectHeader))\n\nPointer arithmetic:\nObjectHeader* header = ((ObjectHeader*)ptr) - 1;\n                        â””â”€ Subtracts 16 bytes (sizeof(ObjectHeader))\n```\n\n**The Fix**: Always use helper functions:\n\n```c\nstatic inline ObjectHeader* get_header(void* ptr) {\n    return ((ObjectHeader*)ptr) - 1;\n}\n\nstatic inline void* get_data(ObjectHeader* header) {\n    return (void*)(header + 1);\n}\n```\n\n---\n\n### ğŸ› **Bug 2: Alignment Violations**\n\n**Symptom**: Bus error on ARM/RISC-V, performance degradation on x86\n\n**Root Cause**: Allocating unaligned sizes\n\n```c\n// WRONG: 13 bytes is not 16-byte aligned\nvoid* ptr = gc_alloc(gc, 13);  // âŒ May return unaligned pointer\n\n// CORRECT: Always align\n#define ALIGN_16(size) (((size) + 15) & ~15)\nvoid* ptr = gc_alloc(gc, ALIGN_16(13));  // âœ… Allocates 16 bytes\n```\n\n**The Bit Trick Explained**:\n\n```\nGoal: Round 13 up to next multiple of 16\n\nStep 1: Add (alignment - 1)\n13 + 15 = 28\nBinary: 0001 1100\n\nStep 2: Create mask (~15)\n15 = 0000 1111\n~15 = 1111 0000\n\nStep 3: AND to clear low bits\n  0001 1100  (28)\n& 1111 0000  (~15)\n-----------\n  0001 0000  (16) â† Rounded up!\n\nWhy it works:\n- Adding 15 ensures we round UP (not down)\n- AND with ~15 clears the low 4 bits (forces multiple of 16)\n```\n\n**Test Cases**:\n\n```c\nALIGN_16(0)  = 0   // 0000 0000 â†’ 0000 0000\nALIGN_16(1)  = 16  // 0001 0000 â†’ 0001 0000\nALIGN_16(13) = 16  // 0001 1100 â†’ 0001 0000\nALIGN_16(16) = 16  // 0010 0000 â†’ 0010 0000\nALIGN_16(17) = 32  // 0010 0001 â†’ 0010 0000\n```\n\n---\n\n### ğŸ› **Bug 3: Forgetting Minimum Block Size**\n\n**Symptom**: Crash during `gc_free()` when trying to write `FreeBlock` header\n\n**Root Cause**: Allocated block is smaller than `sizeof(FreeBlock)`\n\n```c\n// WRONG: 8-byte allocation can't hold FreeBlock (16 bytes)\nvoid* ptr = gc_alloc(gc, 8);\ngc_free(gc, ptr);  // âŒ Overwrites adjacent memory!\n\n// What happens:\n// 1. gc_alloc() allocates 8 + 16 (header) = 24 bytes\n// 2. gc_free() tries to write FreeBlock (16 bytes) at header location\n// 3. FreeBlock.next (8 bytes) overwrites user data of NEXT object!\n```\n\n**The Fix**: Enforce minimum in `gc_alloc()`:\n\n```c\nsize_t total_size = sizeof(ObjectHeader) + aligned_size;\n\n// Ensure block can hold FreeBlock when freed\nif (total_size < sizeof(FreeBlock)) {\n    total_size = sizeof(FreeBlock);\n}\n```\n\n**Visual Explanation**:\n\n```\nWRONG (8-byte allocation):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ ObjectHeader   â”‚ Data   â”‚\nâ”‚ 16 bytes       â”‚ 8 bytesâ”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         24 bytes total\n\nWhen freed, tries to write FreeBlock:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ FreeBlock              â”‚\nâ”‚ size: 8 | next: 8      â”‚ â† next pointer overflows!\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nCORRECT (16-byte minimum):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ ObjectHeader   â”‚ Data           â”‚\nâ”‚ 16 bytes       â”‚ 16 bytes       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         32 bytes total\n\nWhen freed:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ FreeBlock                      â”‚\nâ”‚ size: 32 | next: ptr           â”‚ â† Fits perfectly!\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n### ğŸ› **Bug 4: The Fragmentation Death Spiral**\n\n**Symptom**: Allocation fails despite sufficient total free memory\n\n**Scenario**:\n\n```\nFree List: [16] â†’ [16] â†’ [16] â†’ [16] â†’ [16] â†’ [16]\nTotal Free: 96 bytes\n\nRequest: gc_alloc(gc, 64)\nResult: NULL (no contiguous 64-byte block!)\n```\n\n**Root Cause**: External fragmentation\n\n**Fix Option 1: Coalescing** (Merge adjacent blocks)\n\n```c\nvoid coalesce_free_list(GC* gc) {\n    // Sort free list by address\n    sort_free_list_by_address(gc);\n    \n    FreeBlock* current = gc->free_list;\n    \n    while (current != NULL && current->next != NULL) {\n        // Check if current and next are adjacent\n        void* current_end = (char*)current + current->size;\n        \n        if (current_end == (void*)current->next) {\n            // Merge!\n            current->size += current->next->size;\n            current->next = current->next->next;\n            // Don't advance - check if we can merge with new next\n        } else {\n            current = current->next;\n        }\n    }\n}\n```\n\n**Before Coalescing**:\n```\n[16] â†’ [16] â†’ [16] â†’ [16]\n â†‘      â†‘      â†‘      â†‘\n A      B      C      D\n```\n\n**After Coalescing** (if A, B, C, D are adjacent in memory):\n```\n[64]\n â†‘\n A (merged A+B+C+D)\n```\n\n**Fix Option 2: Segregated Free Lists** (Prevent fragmentation)\n\n```c\ntypedef struct {\n    FreeBlock* small;   // 16-64 bytes\n    FreeBlock* medium;  // 65-256 bytes\n    FreeBlock* large;   // 257+ bytes\n} SegregatedFreeList;\n\nvoid* gc_alloc_segregated(GC* gc, size_t size) {\n    if (size <= 64) {\n        return alloc_from_list(&gc->free_lists.small, size);\n    } else if (size <= 256) {\n        return alloc_from_list(&gc->free_lists.medium, size);\n    } else {\n        return alloc_from_list(&gc->free_lists.large, size);\n    }\n}\n```\n\n**Fix Option 3: Compaction** (Move objects to eliminate gaps)\n\n```\nBefore:\n[OBJ1][FREE][OBJ2][FREE][OBJ3][FREE]\n\nAfter Compaction:\n[OBJ1][OBJ2][OBJ3][FREE FREE FREE]\n                   â””â”€ One large contiguous block\n```\n\n(Compaction covered in Milestone 5: Moving GC)\n\n---\n\n## Visual Reference: Memory State Transitions\n\n{{DIAGRAM:state-transitions}}\n\n```\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nINITIAL STATE (Empty Heap)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ FREE BLOCK                                         â”‚\nâ”‚ size: 1024                                         â”‚\nâ”‚ next: NULL                                         â”‚\nâ”‚ [1008 bytes unused]                                â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nfree_list â†’ [1024]\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nAFTER gc_alloc(gc, 64)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ OBJECT           â”‚ â”‚ FREE BLOCK                   â”‚\nâ”‚ size: 80         â”‚ â”‚ size: 944                    â”‚\nâ”‚ marked: 0        â”‚ â”‚ next: NULL                   â”‚\nâ”‚ type: 0          â”‚ â”‚ [928 bytes unused]           â”‚\nâ”‚ [64 bytes data]  â”‚ â”‚                              â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n      80 bytes              944 bytes\n\nfree_list â†’ [944]\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nAFTER gc_alloc(gc, 128)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ OBJ1   â”‚ â”‚ OBJ2     â”‚ â”‚ FREE BLOCK                 â”‚\nâ”‚ 80     â”‚ â”‚ 144      â”‚ â”‚ size: 800                  â”‚\nâ”‚ m: 0   â”‚ â”‚ m: 0     â”‚ â”‚ next: NULL                 â”‚\nâ”‚ [64]   â”‚ â”‚ [128]    â”‚ â”‚ [784 bytes unused]         â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n   80 B       144 B            800 B\n\nfree_list â†’ [800]\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nAFTER gc_free(OBJ1)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ FREE   â”‚ â”‚ OBJ2     â”‚ â”‚ FREE BLOCK                 â”‚\nâ”‚ 80   â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¤ size: 800                  â”‚\nâ”‚ next â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ â”‚ next: NULL                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nfree_list â†’ [80] â†’ [800]\n             â†‘       â†‘\n             New    Old head\n             head\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nAFTER gc_alloc(gc, 32) - Uses first-fit\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ OBJ3   â”‚ â”‚ OBJ2     â”‚ â”‚ FREE BLOCK                 â”‚\nâ”‚ 48   â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¤ size: 800                  â”‚\nâ”‚ [32]   â”‚ â”‚ [128]    â”‚ â”‚ next: NULL                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n   48 B       144 B            800 B\n\nfree_list â†’ [32] â†’ [800]\n             â†‘\n             Remainder from splitting 80-byte block\n             (80 - 48 = 32 bytes left)\n```\n\n---\n\n## Code Scaffold: Your Implementation Tasks\n\n### Task 1: Initialize the Heap\n\n```c\nGC* gc_init(size_t heap_size) {\n    // TODO: Allocate GC structure\n    GC* gc = malloc(sizeof(GC));\n    if (gc == NULL) {\n        return NULL;\n    }\n    \n    // TODO: Allocate heap memory (use mmap or malloc)\n    // Hint: mmap() is better for large heaps (allows returning memory to OS)\n    gc->heap_start = malloc(heap_size);\n    if (gc->heap_start == NULL) {\n        free(gc);\n        return NULL;\n    }\n    \n    gc->heap_size = heap_size;\n    \n    // TODO: Initialize free list with entire heap as one block\n    FreeBlock* initial_block = (FreeBlock*)gc->heap_start;\n    initial_block->size = heap_size;\n    initial_block->next = NULL;\n    gc->free_list = initial_block;\n    \n    // TODO: Initialize root set (covered in next milestone)\n    gc->roots.roots = NULL;\n    gc->roots.count = 0;\n    gc->roots.capacity = 0;\n    \n    // TODO: Initialize statistics\n    gc->bytes_allocated = 0;\n    gc->num_allocations = 0;\n    gc->num_collections = 0;\n    \n    return gc;\n}\n```\n\n**Testing**:\n\n```c\nvoid test_gc_init() {\n    GC* gc = gc_init(1024);\n    assert(gc != NULL);\n    assert(gc->heap_start != NULL);\n    assert(gc->heap_size == 1024);\n    assert(gc->free_list != NULL);\n    assert(gc->free_list->size == 1024);\n    assert(gc->free_list->next == NULL);\n    printf(\"âœ“ gc_init test passed\\n\");\n}\n```\n\n---\n\n### Task 2: Implement First-Fit Allocation\n\n```c\nvoid* gc_alloc(GC* gc, size_t size) {\n    // TODO: Step 1 - Align size to 16 bytes\n    size_t aligned_size = ALIGN_16(size);\n    \n    // TODO: Step 2 - Add header size\n    size_t total_size = sizeof(ObjectHeader) + aligned_size;\n    \n    // TODO: Step 3 - Enforce minimum block size\n    if (total_size < sizeof(FreeBlock)) {\n        total_size = sizeof(FreeBlock);\n    }\n    \n    // TODO: Step 4 - Search free list for first suitable block\n    FreeBlock** current = &gc->free_list;\n    \n    while (*current != NULL) {\n        FreeBlock* block = *current;\n        \n        if (block->size >= total_size) {\n            // TODO: Step 5 - Decide whether to split\n            size_t remainder = block->size - total_size;\n            \n            if (remainder >= sizeof(FreeBlock)) {\n                // TODO: Split block\n                // Hint: New block starts at (char*)block + total_size\n                \n            } else {\n                // TODO: Use entire block (absorb remainder)\n                \n            }\n            \n            // TODO: Step 6 - Initialize object header\n            ObjectHeader* header = (ObjectHeader*)block;\n            // Set size, marked, type fields\n            \n            // TODO: Step 7 - Update statistics\n            gc->bytes_allocated += total_size;\n            gc->num_allocations++;\n            \n            // TODO: Step 8 - Return pointer to DATA (not header)\n            return (void*)(header + 1);\n        }\n        \n        current = &(*current)->next;\n    }\n    \n    // TODO: No suitable block found - trigger GC\n    // For now, return NULL (GC implementation in Milestone 4)\n    return NULL;\n}\n```\n\n**Testing**:\n\n```c\nvoid test_gc_alloc() {\n    GC* gc = gc_init(1024);\n    \n    // Test 1: Basic allocation\n    void* obj1 = gc_alloc(gc, 64);\n    assert(obj1 != NULL);\n    assert(((uintptr_t)obj1 & 15) == 0);  // Check alignment\n    \n    // Test 2: Multiple allocations\n    void* obj2 = gc_alloc(gc, 128);\n    assert(obj2 != NULL);\n    assert(obj2 > obj1);  // Should be after obj1\n    \n    // Test 3: Verify header\n    ObjectHeader* header = get_header(obj1);\n    assert(header->size >= 64 + sizeof(ObjectHeader));\n    assert(header->marked == 0);\n    \n    printf(\"âœ“ gc_alloc test passed\\n\");\n}\n```\n\n---\n\n### Task 3: Implement Deallocation\n\n```c\nvoid gc_free(GC* gc, void* ptr) {\n    // TODO: Handle NULL pointer\n    if (ptr == NULL) {\n        return;\n    }\n    \n    // TODO: Get header from data pointer\n    ObjectHeader* header = get_header(ptr);\n    \n    // TODO: Verify pointer is within heap bounds (safety check)\n    if (!is_heap_pointer(gc, header)) {\n        fprintf(stderr, \"ERROR: Invalid pointer %p\\n\", ptr);\n        abort();\n    }\n    \n    // TODO: Convert to free block\n    FreeBlock* block = (FreeBlock*)header;\n    block->size = header->size;\n    \n    // TODO: Insert at head of free list\n    block->next = gc->free_list;\n    gc->free_list = block;\n    \n    // TODO: Update statistics\n    gc->bytes_allocated -= block->size;\n}\n```\n\n**Testing**:\n\n```c\nvoid test_gc_free() {\n    GC* gc = gc_init(1024);\n    \n    void* obj1 = gc_alloc(gc, 64);\n    void* obj2 = gc_alloc(gc, 128);\n    \n    // Free first object\n    gc_free(gc, obj1);\n    \n    // Verify free list has new block\n    assert(gc->free_list != NULL);\n    \n    // Allocate again - should reuse freed block\n    void* obj3 = gc_alloc(gc, 32);\n    assert(obj3 == obj1);  // Should reuse same address\n    \n    printf(\"âœ“ gc_free test passed\\n\");\n}\n```\n\n---\n\n### Task 4: Helper Functions\n\n```c\n// Get object header from data pointer\nstatic inline ObjectHeader* get_header(void* ptr) {\n    return ((ObjectHeader*)ptr) - 1;\n}\n\n// Get data pointer from header\nstatic inline void* get_data(ObjectHeader* header) {\n    return (void*)(header + 1);\n}\n\n// Check if pointer is within heap bounds\nbool is_heap_pointer(GC* gc, void* ptr) {\n    return ptr >= gc->heap_start && \n           ptr < (void*)((char*)gc->heap_start + gc->heap_size);\n}\n\n// Align size to 16 bytes\n#define ALIGN_16(size) (((size) + 15) & ~15)\n\n// Print free list (for debugging)\nvoid print_free_list(GC* gc) {\n    printf(\"Free List: \");\n    FreeBlock* block = gc->free_list;\n    while (block != NULL) {\n        printf(\"[%zu bytes at %p] â†’ \", block->size, (void*)block);\n        block = block->next;\n    }\n    printf(\"NULL\\n\");\n}\n```\n\n---\n\n## Testing Your Implementation\n\n### Test Suite\n\n```c\nvoid run_allocation_tests() {\n    printf(\"Running allocation tests...\\n\\n\");\n    \n    test_gc_init();\n    test_gc_alloc();\n    test_gc_free();\n    test_block_splitting();\n    test_alignment();\n    test_minimum_size();\n    test_heap_exhaustion();\n    test_fragmentation();\n    \n    printf(\"\\nâœ“ All tests passed!\\n\");\n}\n```\n\n### Test 1: Basic Allocation\n\n```c\nvoid test_basic_allocation() {\n    GC* gc = gc_init(1024);\n    \n    void* obj1 = gc_alloc(gc, 64);\n    assert(obj1 != NULL);\n    \n    void* obj2 = gc_alloc(gc, 128);\n    assert(obj2 != NULL);\n    \n    // Verify objects don't overlap\n    ObjectHeader* h1 = get_header(obj1);\n    ObjectHeader* h2 = get_header(obj2);\n    \n    void* obj1_end = (char*)h1 + h1->size;\n    assert(obj1_end <= (void*)h2);\n    \n    printf(\"âœ“ Basic allocation test passed\\n\");\n}\n```\n\n### Test 2: Block Splitting\n\n```c\nvoid test_block_splitting() {\n    GC* gc = gc_init(1024);\n    \n    // Allocate small object from large heap\n    void* obj = gc_alloc(gc, 64);\n    \n    // Verify free list still has space\n    assert(gc->free_list != NULL);\n    assert(gc->free_list->size > 0);\n    \n    // Calculate expected remainder\n    size_t allocated = ALIGN_16(64) + sizeof(ObjectHeader);\n    if (allocated < sizeof(FreeBlock)) {\n        allocated = sizeof(FreeBlock);\n    }\n    \n    size_t expected_remainder = 1024 - allocated;\n    assert(gc->free_list->size == expected_remainder);\n    \n    printf(\"âœ“ Block splitting test passed\\n\");\n}\n```\n\n### Test 3: Alignment\n\n```c\nvoid test_alignment() {\n    GC* gc = gc_init(1024);\n    \n    // Test various odd sizes\n    size_t test_sizes[] = {1, 7, 13, 31, 63, 127};\n    \n    for (int i = 0; i < 6; i++) {\n        void* obj = gc_alloc(gc, test_sizes[i]);\n        assert(obj != NULL);\n        \n        // Verify 16-byte alignment\n        assert(((uintptr_t)obj & 15) == 0);\n    }\n    \n    printf(\"âœ“ Alignment test passed\\n\");\n}\n```\n\n### Test 4: Minimum Size\n\n```c\nvoid test_minimum_size() {\n    GC* gc = gc_init(1024);\n    \n    // Allocate very small object\n    void* obj = gc_alloc(gc, 1);\n    assert(obj != NULL);\n    \n    // Free it\n    gc_free(gc, obj);\n    \n    // Verify free list is valid (no corruption)\n    assert(gc->free_list != NULL);\n    assert(gc->free_list->size >= sizeof(FreeBlock));\n    \n    printf(\"âœ“ Minimum size test passed\\n\");\n}\n```\n\n### Test 5: Heap Exhaustion\n\n```c\nvoid test_heap_exhaustion() {\n    GC* gc = gc_init(256);  // Small heap\n    \n    void* obj1 = gc_alloc(gc, 100);\n    void* obj2 = gc_alloc(gc, 100);\n    \n    // This should fail (not enough space)\n    void* obj3 = gc_alloc(gc, 100);\n    assert(obj3 == NULL);\n    \n    printf(\"âœ“ Heap exhaustion test passed\\n\");\n}\n```\n\n### Test 6: Fragmentation\n\n```c\nvoid test_fragmentation() {\n    GC* gc = gc_init(1024);\n    \n    // Allocate 4 objects\n    void* obj1 = gc_alloc(gc, 100);\n    void* obj2 = gc_alloc(gc, 100);\n    void* obj3 = gc_alloc(gc, 100);\n    void* obj4 = gc_alloc(gc, 100);\n    \n    // Free alternating objects (creates fragmentation)\n    gc_free(gc, obj1);\n    gc_free(gc, obj3);\n    \n    // Free list should have 2 blocks\n    int count = 0;\n    FreeBlock* block = gc->free_list;\n    while (block != NULL) {\n        count++;\n        block = block->next;\n    }\n    \n    assert(count >= 2);  // At least 2 free blocks\n    \n    printf(\"âœ“ Fragmentation test passed\\n\");\n}\n```\n\n---\n\n## Performance Considerations\n\n### Time Complexity\n\n| Operation | First-Fit | Best-Fit | Worst-Fit |\n|-----------|-----------|----------|-----------|\n| `gc_alloc()` | O(n) worst, O(1) best | O(n) always | O(n) always |\n| `gc_free()` | O(1) | O(1) | O(1) |\n| Coalescing | O(n log n) | O(n log n) | O(n log n) |\n\n### Space Overhead\n\n```\nPer-object overhead: 16 bytes (ObjectHeader)\n\nExamples:\n- 8-byte object:  16/32  = 50% overhead (forced to 32 bytes minimum)\n- 64-byte object: 16/80  = 20% overhead\n- 1KB object:     16/1040 = 1.5% overhead\n```\n\n**Optimization**: Use **segregated free lists** for small objects:\n\n```c\n// Small objects (â‰¤64 bytes): Use slab allocator (8-byte overhead)\n// Large objects (>64 bytes): Use standard allocator (16-byte overhead)\n```\n\n### Cache Performance\n\n**Good**:\n- âœ… 16-byte alignment ensures cache-line alignment\n- âœ… Sequential allocation has good spatial locality\n\n**Bad**:\n- âŒ Free list traversal has poor spatial locality (random jumps)\n- âŒ Fragmentation reduces cache efficiency\n\n**Fix**: Use **segregated free lists** (separate lists for different size classes):\n\n```c\ntypedef struct {\n    FreeBlock* size_16;\n    FreeBlock* size_32;\n    FreeBlock* size_64;\n    FreeBlock* size_128;\n    FreeBlock* size_256;\n    FreeBlock* size_large;\n} SegregatedFreeList;\n```\n\nBenefits:\n- Faster allocation (search smaller lists)\n- Better cache locality (similar-sized objects clustered)\n- Reduced fragmentation\n\n---\n\n## What You've Learned\n\nâœ… **Memory Layout**: How objects and free blocks coexist in the heap  \nâœ… **Allocation Strategies**: First-fit, best-fit, worst-fit trade-offs  \nâœ… **Block Splitting**: When and how to split free blocks  \nâœ… **Metadata Design**: Object headers and free block nodes  \nâœ… **Pointer Arithmetic**: Converting between headers and data pointers  \nâœ… **Alignment**: Why and how to align memory allocations  \nâœ… **Fragmentation**: External vs. internal, causes and solutions  \n\n---\n\n## Next Steps\n\nNow that you understand heap organization and allocation, you're ready to tackle:\n\n- **[Root Scanner â†’](#root-scanner)**: How to find GC roots on the stack and in globals\n- **[Mark Phase â†’](#mark-engine)**: Traversing the object graph to find live objects\n- **[Sweep Phase â†’](#sweep-engine)**: Reclaiming unmarked objects and rebuilding the free list\n\n**Pro Tip**: Before moving on, make sure your `gc_alloc()` passes all tests. The rest of the GC depends on a correct heap implementation. Pay special attention to:\n1. Alignment (test on ARM if possible)\n2. Minimum block size (test with 1-byte allocations)\n3. Block splitting (verify remainder sizes)\n\n**Challenge**: Implement best-fit allocation and compare fragmentation with first-fit using the test suite.\n\n---\n\n[â†‘ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-root-scanning\"></div>\n\n# Milestone 4: Root Set Identification\n\n## The Epiphany Analogy: The Crime Scene Investigation\n\nImagine you're a detective investigating a crime scene. You need to find all the evidence that's **currently in use**:\n\n- **Active witnesses** (stack frames): People currently at the scene\n- **Security cameras** (CPU registers): What's being watched right now\n- **Building residents** (global variables): Permanent occupants who might have seen something\n\nYou can't just look at *everything* in the cityâ€”that would take forever. You start with the **active participants** and follow their connections.\n\n**In garbage collection, this is exactly what root scanning does**: Find all the pointers that are **actively accessible** right now, then trace from there to discover what's alive.\n\n---\n\n## Technical Rationale: Why Root Scanning Matters\n\n### The Reachability Problem\n\n**Question**: How do we know which objects are still in use?\n\n**Answer**: An object is alive if and only if:\n1. It's **directly accessible** from a root (stack, global, register), OR\n2. It's **reachable** from another alive object\n\n```\nRoot Set â†’ Object Graph â†’ Live Objects\n   â†“\n[Stack]  â†’  obj1  â†’  obj2  â†’  obj3\n[Global] â†’  obj4  â†’  obj5\n[Register] â†’ obj6\n```\n\n**Without accurate root scanning, the GC will**:\n- âŒ **Collect live objects** (use-after-free crashes)\n- âŒ **Keep dead objects** (memory leaks)\n- âŒ **Corrupt program state** (dangling pointers)\n\n### The Three Root Sources\n\n| Root Type | Location | Lifetime | Scanning Method |\n|-----------|----------|----------|-----------------|\n| **Stack** | Function call frames | Function scope | Walk stack frames |\n| **Globals** | `.data` and `.bss` sections | Program lifetime | Scan registered ranges |\n| **Registers** | CPU registers | Instruction-level | Capture at GC entry |\n\n---\n\n## Internal Mechanics: How Root Scanning Works\n\n### Architecture Overview\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         GC Root Scanner                 â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                         â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚\nâ”‚  â”‚ Stack Walker â”‚  â”‚ Global Scan â”‚    â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â”‚\nâ”‚         â”‚                  â”‚            â”‚\nâ”‚         â–¼                  â–¼            â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚\nâ”‚  â”‚     Root Set (Array)         â”‚     â”‚\nâ”‚  â”‚  [ptr1, ptr2, ptr3, ...]     â”‚     â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚\nâ”‚                  â”‚                      â”‚\nâ”‚                  â–¼                      â”‚\nâ”‚         Mark Phase (Next)              â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n{{DIAGRAM:root-scanner-architecture}}\n\n### Step 1: Stack Frame Walking\n\n**The Challenge**: The stack grows downward, and we need to scan upward from the current frame to the bottom.\n\n```\nHigh Address\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   main() frame  â”‚  â† Stack bottom (oldest)\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   foo() frame   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   bar() frame   â”‚  â† Current frame (newest)\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   (unused)      â”‚  â† Stack pointer (SP)\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nLow Address\n```\n\n**Key Insight**: Each stack frame contains:\n- **Local variables** (potential pointers)\n- **Return address** (not a heap pointer)\n- **Saved registers** (potential pointers)\n- **Function arguments** (potential pointers)\n\n**Problem**: We can't distinguish pointers from integers!\n\n```c\nvoid foo() {\n    int x = 42;           // Not a pointer\n    void* ptr = obj;      // Pointer!\n    long y = 0x7fff1234;  // Looks like a pointer, but isn't\n}\n```\n\n**Solution**: **Conservative scanning** â€” treat anything that *looks* like a heap pointer as a potential root.\n\n### Step 2: Conservative Pointer Detection\n\n```c\nbool is_potential_pointer(GC* gc, void* ptr) {\n    // 1. Must be within heap bounds\n    if (ptr < gc->heap_start || \n        ptr >= (char*)gc->heap_start + gc->heap_size) {\n        return false;\n    }\n    \n    // 2. Must be aligned (pointers are word-aligned)\n    if ((uintptr_t)ptr % sizeof(void*) != 0) {\n        return false;\n    }\n    \n    // 3. Must point to a valid object header\n    ObjectHeader* header = (ObjectHeader*)ptr - 1;\n    if (!is_valid_header(gc, header)) {\n        return false;\n    }\n    \n    return true;\n}\n```\n\n**Trade-off**:\n- âœ… **Safe**: Never misses a real pointer (no use-after-free)\n- âŒ **Conservative**: May keep dead objects alive (false positives)\n\n### Step 3: Global Variable Scanning\n\n**The Problem**: Where are global variables stored?\n\n```c\n// In your program:\nvoid* global_obj = NULL;  // Where is this in memory?\n```\n\n**Answer**: In the `.data` or `.bss` sections of the executable.\n\n**Solution**: Register global ranges manually:\n\n```c\ntypedef struct {\n    void* start;\n    void* end;\n} MemoryRange;\n\ntypedef struct {\n    MemoryRange ranges[MAX_GLOBAL_RANGES];\n    int num_ranges;\n} GlobalRoots;\n\nvoid gc_register_globals(GC* gc, void* start, void* end) {\n    gc->global_roots.ranges[gc->global_roots.num_ranges++] = \n        (MemoryRange){start, end};\n}\n```\n\n**Usage**:\n\n```c\n// In your main():\nvoid* global_obj1 = NULL;\nvoid* global_obj2 = NULL;\n\nint main() {\n    GC* gc = gc_init(1024);\n    \n    // Register global variables\n    gc_register_globals(gc, &global_obj1, &global_obj2 + 1);\n    \n    // Now GC can scan these globals\n}\n```\n\n---\n\n## Visual Reference\n\n{{DIAGRAM:root-scanning-flow}}\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                  gc_collect()                       â”‚\nâ”‚                       â†“                             â”‚\nâ”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚\nâ”‚              â”‚ Scan Roots     â”‚                     â”‚\nâ”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚\nâ”‚                       â†“                             â”‚\nâ”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚\nâ”‚       â†“                               â†“             â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚\nâ”‚  â”‚ Stack   â”‚                    â”‚ Globals  â”‚       â”‚\nâ”‚  â”‚ Walker  â”‚                    â”‚ Scanner  â”‚       â”‚\nâ”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜       â”‚\nâ”‚       â”‚                               â”‚             â”‚\nâ”‚       â†“                               â†“             â”‚\nâ”‚  For each word:                  For each range:   â”‚\nâ”‚    if looks_like_ptr():            for each word:  â”‚\nâ”‚      add_root(ptr)                   if looks...   â”‚\nâ”‚                                                     â”‚\nâ”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚\nâ”‚              â”‚  Root Set      â”‚                     â”‚\nâ”‚              â”‚  [ptr array]   â”‚                     â”‚\nâ”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚\nâ”‚                       â†“                             â”‚\nâ”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚\nâ”‚              â”‚  Mark Phase    â”‚                     â”‚\nâ”‚              â”‚  (Next Mile)   â”‚                     â”‚\nâ”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## The Debugging Lab: Common Root Scanning Bugs\n\n### Bug 1: Missing Stack Frames\n\n**Symptom**: Objects are collected while still in use, causing crashes.\n\n```c\nvoid foo() {\n    void* obj = gc_alloc(gc, 64);\n    gc_collect(gc);  // CRASH: obj was collected!\n    use(obj);        // Use-after-free\n}\n```\n\n**Cause**: Stack scanning didn't reach the current frame.\n\n**Fix**: Ensure stack scanning starts from the **current** stack pointer:\n\n```c\nvoid gc_collect(GC* gc) {\n    void* stack_top;\n    \n    // Capture current stack pointer\n    #ifdef __GNUC__\n        stack_top = __builtin_frame_address(0);\n    #else\n        volatile int dummy;\n        stack_top = (void*)&dummy;\n    #endif\n    \n    scan_stack(gc, stack_top, gc->stack_bottom);\n}\n```\n\n### Bug 2: Misaligned Pointer Detection\n\n**Symptom**: Valid pointers are missed, objects are incorrectly collected.\n\n```c\nstruct Foo {\n    char padding[3];\n    void* ptr;  // Misaligned!\n};\n```\n\n**Cause**: Pointer is not word-aligned, so `is_potential_pointer()` rejects it.\n\n**Fix**: Scan **all bytes**, not just aligned words:\n\n```c\nvoid scan_memory_range(GC* gc, void* start, void* end) {\n    // Scan byte-by-byte for misaligned pointers\n    for (char* p = start; p < (char*)end - sizeof(void*); p++) {\n        void* potential_ptr = *(void**)p;\n        if (is_potential_pointer(gc, potential_ptr)) {\n            add_root(gc, potential_ptr);\n        }\n    }\n}\n```\n\n**Trade-off**: Slower, but safer.\n\n### Bug 3: False Positives (Conservative Scanning)\n\n**Symptom**: Memory usage grows over time (memory leak).\n\n```c\nvoid foo() {\n    long x = 0x7fff12345678;  // Looks like a heap pointer!\n    gc_collect(gc);           // Object at 0x7fff12345678 kept alive\n}\n```\n\n**Cause**: Integer value happens to match a heap address.\n\n**Fix**: This is **inherent to conservative GC**. Mitigations:\n1. Use **precise GC** (requires type information)\n2. Clear dead stack frames: `memset(old_frame, 0, frame_size)`\n3. Use **generational GC** (reduces false positive impact)\n\n### Bug 4: Register Spilling\n\n**Symptom**: Pointers in registers are missed.\n\n```c\nvoid foo(GC* gc) {\n    void* obj = gc_alloc(gc, 64);\n    // obj is in register, not on stack!\n    gc_collect(gc);  // CRASH: obj not found\n}\n```\n\n**Cause**: Compiler optimized `obj` into a register.\n\n**Fix**: Force register spilling before GC:\n\n```c\n#define GC_COLLECT(gc) do { \\\n    /* Force all registers to stack */ \\\n    jmp_buf registers; \\\n    setjmp(registers); \\\n    gc_collect_impl(gc); \\\n} while(0)\n```\n\n**How `setjmp` works**: Saves all registers to the stack, making them scannable.\n\n---\n\n## Code Scaffold: Your Implementation Tasks\n\n### Data Structures\n\n```c\n// Root set: dynamic array of potential pointers\ntypedef struct {\n    void** roots;       // Array of root pointers\n    size_t count;       // Number of roots\n    size_t capacity;    // Array capacity\n} RootSet;\n\n// Global variable ranges\ntypedef struct {\n    void* start;\n    void* end;\n} MemoryRange;\n\n#define MAX_GLOBAL_RANGES 16\n\ntypedef struct {\n    MemoryRange ranges[MAX_GLOBAL_RANGES];\n    int num_ranges;\n} GlobalRoots;\n\n// Add to GC struct:\ntypedef struct GC {\n    // ... existing fields ...\n    \n    RootSet root_set;\n    GlobalRoots global_roots;\n    void* stack_bottom;  // Bottom of stack (set at init)\n} GC;\n```\n\n### Task 1: Initialize Root Set\n\n```c\nvoid init_root_set(RootSet* roots) {\n    // TODO: Allocate initial capacity\n    roots->capacity = 256;\n    roots->count = 0;\n    roots->roots = malloc(roots->capacity * sizeof(void*));\n    \n    if (roots->roots == NULL) {\n        fprintf(stderr, \"ERROR: Failed to allocate root set\\n\");\n        abort();\n    }\n}\n\nvoid free_root_set(RootSet* roots) {\n    // TODO: Free root array\n    free(roots->roots);\n    roots->roots = NULL;\n    roots->count = 0;\n    roots->capacity = 0;\n}\n```\n\n### Task 2: Add Root to Set\n\n```c\nvoid add_root(GC* gc, void* ptr) {\n    RootSet* roots = &gc->root_set;\n    \n    // TODO: Check if we need to resize\n    if (roots->count >= roots->capacity) {\n        // TODO: Double capacity\n        size_t new_capacity = roots->capacity * 2;\n        void** new_roots = realloc(roots->roots, \n                                   new_capacity * sizeof(void*));\n        \n        if (new_roots == NULL) {\n            fprintf(stderr, \"ERROR: Failed to resize root set\\n\");\n            abort();\n        }\n        \n        roots->roots = new_roots;\n        roots->capacity = new_capacity;\n    }\n    \n    // TODO: Add pointer to array\n    roots->roots[roots->count++] = ptr;\n}\n\nvoid clear_roots(GC* gc) {\n    // TODO: Reset count (don't free array)\n    gc->root_set.count = 0;\n}\n```\n\n### Task 3: Conservative Pointer Detection\n\n```c\nbool is_potential_pointer(GC* gc, void* ptr) {\n    // TODO: Step 1 - Check if within heap bounds\n    if (ptr < gc->heap_start || \n        ptr >= (char*)gc->heap_start + gc->heap_size) {\n        return false;\n    }\n    \n    // TODO: Step 2 - Check alignment\n    // Pointers must be word-aligned (4 or 8 bytes)\n    if ((uintptr_t)ptr % sizeof(void*) != 0) {\n        return false;\n    }\n    \n    // TODO: Step 3 - Check if points to valid object\n    // Try to interpret as object header\n    ObjectHeader* header = (ObjectHeader*)ptr;\n    \n    // Sanity checks:\n    // - Size must be reasonable (not 0, not huge)\n    // - Must be within heap\n    if (header->size == 0 || header->size > gc->heap_size) {\n        return false;\n    }\n    \n    void* obj_end = (char*)header + header->size;\n    if (obj_end > (char*)gc->heap_start + gc->heap_size) {\n        return false;\n    }\n    \n    // TODO: Optional - Check type field is valid\n    if (header->type >= TYPE_MAX) {\n        return false;\n    }\n    \n    return true;\n}\n```\n\n**Quick Breakdown: Why These Checks?**\n\n1. **Heap bounds**: Integers often look like pointers, but they're not in our heap\n2. **Alignment**: Real pointers are aligned; random integers usually aren't\n3. **Valid header**: If it's a real object, its header should make sense\n4. **Size check**: Catches corrupted headers or false positives\n\n### Task 4: Stack Scanning\n\n```c\nvoid scan_stack(GC* gc, void* stack_top, void* stack_bottom) {\n    // TODO: Ensure stack_top < stack_bottom (stack grows down)\n    if (stack_top > stack_bottom) {\n        void* temp = stack_top;\n        stack_top = stack_bottom;\n        stack_bottom = temp;\n    }\n    \n    // TODO: Scan every word on the stack\n    // Hint: Cast to uintptr_t* to scan word-by-word\n    uintptr_t* p = (uintptr_t*)stack_top;\n    uintptr_t* end = (uintptr_t*)stack_bottom;\n    \n    while (p < end) {\n        // TODO: Read word from stack\n        void* potential_ptr = (void*)*p;\n        \n        // TODO: Check if it looks like a heap pointer\n        if (is_potential_pointer(gc, potential_ptr)) {\n            // TODO: Add to root set\n            add_root(gc, potential_ptr);\n        }\n        \n        p++;  // Move to next word\n    }\n}\n```\n\n**Debugging Tip**: Print the stack range and number of roots found:\n\n```c\nprintf(\"Scanning stack: %p to %p (%zu bytes)\\n\", \n       stack_top, stack_bottom, \n       (char*)stack_bottom - (char*)stack_top);\nprintf(\"Found %zu potential roots\\n\", gc->root_set.count);\n```\n\n### Task 5: Global Variable Scanning\n\n```c\nvoid gc_register_globals(GC* gc, void* start, void* end) {\n    // TODO: Check we haven't exceeded max ranges\n    if (gc->global_roots.num_ranges >= MAX_GLOBAL_RANGES) {\n        fprintf(stderr, \"ERROR: Too many global ranges\\n\");\n        abort();\n    }\n    \n    // TODO: Add range to array\n    MemoryRange range = {start, end};\n    gc->global_roots.ranges[gc->global_roots.num_ranges++] = range;\n}\n\nvoid scan_globals(GC* gc) {\n    // TODO: Scan each registered range\n    for (int i = 0; i < gc->global_roots.num_ranges; i++) {\n        MemoryRange* range = &gc->global_roots.ranges[i];\n        \n        // TODO: Scan word-by-word\n        uintptr_t* p = (uintptr_t*)range->start;\n        uintptr_t* end = (uintptr_t*)range->end;\n        \n        while (p < end) {\n            void* potential_ptr = (void*)*p;\n            \n            if (is_potential_pointer(gc, potential_ptr)) {\n                add_root(gc, potential_ptr);\n            }\n            \n            p++;\n        }\n    }\n}\n```\n\n### Task 6: Main Root Scanning Entry Point\n\n```c\nvoid scan_roots(GC* gc) {\n    // TODO: Clear previous roots\n    clear_roots(gc);\n    \n    // TODO: Step 1 - Capture current stack pointer\n    void* stack_top;\n    \n    #ifdef __GNUC__\n        // GCC/Clang: Use builtin\n        stack_top = __builtin_frame_address(0);\n    #else\n        // Fallback: Use address of local variable\n        volatile int dummy;\n        stack_top = (void*)&dummy;\n    #endif\n    \n    // TODO: Step 2 - Scan stack\n    scan_stack(gc, stack_top, gc->stack_bottom);\n    \n    // TODO: Step 3 - Scan globals\n    scan_globals(gc);\n    \n    // TODO: Step 4 - Print statistics (debug)\n    #ifdef GC_DEBUG\n    printf(\"Root scanning complete: %zu roots found\\n\", \n           gc->root_set.count);\n    #endif\n}\n```\n\n### Task 7: Initialize Stack Bottom\n\n```c\nGC* gc_init(size_t heap_size) {\n    GC* gc = malloc(sizeof(GC));\n    if (gc == NULL) {\n        return NULL;\n    }\n    \n    // ... existing initialization ...\n    \n    // TODO: Capture stack bottom (do this FIRST in main())\n    // This should be called from main(), so we capture the bottom\n    volatile int dummy;\n    gc->stack_bottom = (void*)&dummy;\n    \n    // TODO: Initialize root set\n    init_root_set(&gc->root_set);\n    \n    // TODO: Initialize global roots\n    gc->global_roots.num_ranges = 0;\n    \n    return gc;\n}\n```\n\n**Important**: `gc_init()` must be called from `main()` to capture the correct stack bottom!\n\n---\n\n## Testing Your Implementation\n\n### Test 1: Stack Scanning\n\n```c\nvoid test_stack_scanning() {\n    GC* gc = gc_init(1024);\n    \n    // Allocate objects\n    void* obj1 = gc_alloc(gc, 64);\n    void* obj2 = gc_alloc(gc, 128);\n    void* obj3 = gc_alloc(gc, 256);\n    \n    // Scan roots\n    scan_roots(gc);\n    \n    // Verify all objects were found\n    bool found1 = false, found2 = false, found3 = false;\n    \n    for (size_t i = 0; i < gc->root_set.count; i++) {\n        if (gc->root_set.roots[i] == obj1) found1 = true;\n        if (gc->root_set.roots[i] == obj2) found2 = true;\n        if (gc->root_set.roots[i] == obj3) found3 = true;\n    }\n    \n    assert(found1 && found2 && found3);\n    printf(\"âœ“ Stack scanning test passed\\n\");\n}\n```\n\n### Test 2: Global Scanning\n\n```c\n// Global variables\nvoid* global_obj1 = NULL;\nvoid* global_obj2 = NULL;\n\nvoid test_global_scanning() {\n    GC* gc = gc_init(1024);\n    \n    // Register globals\n    gc_register_globals(gc, &global_obj1, &global_obj2 + 1);\n    \n    // Allocate objects\n    global_obj1 = gc_alloc(gc, 64);\n    global_obj2 = gc_alloc(gc, 128);\n    \n    // Scan roots\n    scan_roots(gc);\n    \n    // Verify globals were found\n    bool found1 = false, found2 = false;\n    \n    for (size_t i = 0; i < gc->root_set.count; i++) {\n        if (gc->root_set.roots[i] == global_obj1) found1 = true;\n        if (gc->root_set.roots[i] == global_obj2) found2 = true;\n    }\n    \n    assert(found1 && found2);\n    printf(\"âœ“ Global scanning test passed\\n\");\n}\n```\n\n### Test 3: Conservative Scanning (False Positives)\n\n```c\nvoid test_conservative_scanning() {\n    GC* gc = gc_init(1024);\n    \n    void* obj = gc_alloc(gc, 64);\n    \n    // Create integer that looks like a pointer\n    uintptr_t fake_ptr = (uintptr_t)obj;\n    \n    // Scan roots\n    scan_roots(gc);\n    \n    // The fake pointer should be detected\n    bool found = false;\n    for (size_t i = 0; i < gc->root_set.count; i++) {\n        if ((uintptr_t)gc->root_set.roots[i] == fake_ptr) {\n            found = true;\n            break;\n        }\n    }\n    \n    assert(found);  // Conservative GC keeps it alive\n    printf(\"âœ“ Conservative scanning test passed\\n\");\n}\n```\n\n### Test 4: Nested Function Calls\n\n```c\nvoid nested_level_3(GC* gc, void* obj) {\n    scan_roots(gc);\n    \n    // Verify obj is still found (3 frames deep)\n    bool found = false;\n    for (size_t i = 0; i < gc->root_set.count; i++) {\n        if (gc->root_set.roots[i] == obj) {\n            found = true;\n            break;\n        }\n    }\n    assert(found);\n}\n\nvoid nested_level_2(GC* gc, void* obj) {\n    nested_level_3(gc, obj);\n}\n\nvoid nested_level_1(GC* gc, void* obj) {\n    nested_level_2(gc, obj);\n}\n\nvoid test_nested_calls() {\n    GC* gc = gc_init(1024);\n    void* obj = gc_alloc(gc, 64);\n    \n    nested_level_1(gc, obj);\n    \n    printf(\"âœ“ Nested calls test passed\\n\");\n}\n```\n\n### Test 5: Root Set Resizing\n\n```c\nvoid test_root_set_resize() {\n    GC* gc = gc_init(1024);\n    \n    // Allocate many objects to force resize\n    void* objects[1000];\n    for (int i = 0; i < 1000; i++) {\n        objects[i] = gc_alloc(gc, 16);\n    }\n    \n    // Scan roots (should trigger resize)\n    scan_roots(gc);\n    \n    // Verify all objects were found\n    assert(gc->root_set.count >= 1000);\n    assert(gc->root_set.capacity >= gc->root_set.count);\n    \n    printf(\"âœ“ Root set resize test passed\\n\");\n}\n```\n\n---\n\n## Performance Considerations\n\n### Time Complexity\n\n| Operation | Complexity | Notes |\n|-----------|------------|-------|\n| `scan_stack()` | O(stack_size) | Typically 1-8 MB |\n| `scan_globals()` | O(global_size) | Usually small |\n| `is_potential_pointer()` | O(1) | Just bounds checks |\n| **Total** | **O(stack + globals)** | Linear in root size |\n\n### Space Complexity\n\n```\nRoot set size: O(number of pointers on stack + globals)\n\nTypical values:\n- Stack: 1000-10000 words (4-40 KB)\n- Globals: 100-1000 words (0.4-4 KB)\n- Root set: ~10000 pointers (40-80 KB)\n```\n\n### Optimization: Precise Stack Maps\n\n**Problem**: Conservative scanning is slow and causes false positives.\n\n**Solution**: **Precise GC** with stack maps:\n\n```c\n// Compiler generates stack map for each function\ntypedef struct {\n    uint32_t return_address;\n    uint8_t num_pointers;\n    uint16_t offsets[MAX_POINTERS];  // Offsets of pointers in frame\n} StackMap;\n\n// At GC time, look up stack map for each frame\nvoid scan_stack_precise(GC* gc, void* stack_top) {\n    void** frame_ptr = (void**)stack_top;\n    \n    while (frame_ptr < gc->stack_bottom) {\n        void* return_addr = frame_ptr[0];\n        StackMap* map = lookup_stack_map(return_addr);\n        \n        // Scan only known pointer locations\n        for (int i = 0; i < map->num_pointers; i++) {\n            void* ptr = *(void**)((char*)frame_ptr + map->offsets[i]);\n            add_root(gc, ptr);\n        }\n        \n        frame_ptr = (void**)frame_ptr[1];  // Follow frame pointer\n    }\n}\n```\n\n**Benefits**:\n- âœ… No false positives\n- âœ… Faster scanning (skip non-pointers)\n- âœ… Enables moving GC (precise pointer knowledge)\n\n**Drawbacks**:\n- âŒ Requires compiler support\n- âŒ Larger binary (stack maps embedded)\n- âŒ Complex implementation\n\n---\n\n## What You've Learned\n\nâœ… **Root Set Concept**: What roots are and why they matter  \nâœ… **Conservative Scanning**: How to find pointers without type information  \nâœ… **Stack Walking**: How to traverse stack frames safely  \nâœ… **Global Registration**: How to track global variables  \nâœ… **Pointer Validation**: How to distinguish pointers from integers  \nâœ… **False Positives**: The trade-offs of conservative GC  \nâœ… **Platform Differences**: Stack layout and register handling  \n\n---\n\n## Next Steps\n\nNow that you can identify all GC roots, you're ready to:\n\n- **[Mark Phase â†’](#mark-engine)**: Traverse the object graph from roots to mark live objects\n- **[Sweep Phase â†’](#sweep-engine)**: Reclaim unmarked objects and rebuild the free list\n- **[Integration â†’](#gc-integration)**: Connect all phases into a working garbage collector\n\n**Pro Tip**: Before moving on, verify your root scanner with the test suite. Pay special attention to:\n1. **Stack direction**: Ensure `stack_top < stack_bottom`\n2. **Alignment**: Test on both 32-bit and 64-bit platforms\n3. **False positives**: Monitor memory usage over time\n\n**Challenge**: Implement a **root set deduplication** pass to remove duplicate pointers (improves mark phase performance).\n\n---\n\n[â†‘ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-mark-phase\"></div>\n\n# Mark Phase Implementation: The Graph Traversal Engine\n\n## Epiphany Analogy: The Lighthouse Network\n\nImagine a coastal region during a blackout. You're in a helicopter with a spotlight, and your job is to identify which lighthouses are still operational.\n\n**Phase 1 (Roots)**: You start by shining your light on the **main control stations** (roots) â€” the ones you know are always active.\n\n**Phase 2 (Mark)**: Each lighthouse you illuminate has **signal cables** connecting it to other lighthouses. You follow each cable, marking every connected lighthouse with **glow-in-the-dark paint**. You use a **work queue** (a checklist) to ensure you don't miss any connections.\n\n**The Result**: When you're done, every lighthouse with glow paint is **reachable** (alive). The dark ones are **unreachable** (garbage).\n\nThis is **mark-and-sweep garbage collection**: roots â†’ traverse â†’ mark â†’ sweep.\n\n---\n\n## Technical Rationale: Why Iterative Depth-First Traversal?\n\n### The Problem: Object Graph Traversal\n\nAfter root scanning, you have a set of **entry points** into the heap. But objects reference *other* objects, forming a **directed graph**:\n\n```\nRoot Set:\n  obj1 â†’ obj2 â†’ obj4\n  obj3 â†’ obj5 â†’ obj6 â†’ obj7\n  \nUnreachable:\n  obj8 â†’ obj9  (no path from roots)\n```\n\n**Goal**: Mark every object reachable from roots.\n\n### Why Not Recursive Traversal?\n\n```c\n// âŒ DANGEROUS: Recursive marking\nvoid mark_recursive(Object* obj) {\n    if (obj->marked) return;\n    obj->marked = true;\n    \n    for (each child in obj->children) {\n        mark_recursive(child);  // Stack overflow risk!\n    }\n}\n```\n\n**Problem**: Deep object graphs (e.g., linked lists with 100,000 nodes) cause **stack overflow**.\n\n### The Solution: Iterative Traversal with Work Queue\n\n```c\n// âœ… SAFE: Iterative marking\nvoid mark_iterative(GC* gc) {\n    WorkQueue queue;\n    init_queue(&queue);\n    \n    // Add all roots to queue\n    for (each root in gc->root_set) {\n        enqueue(&queue, root);\n    }\n    \n    // Process queue until empty\n    while (!is_empty(&queue)) {\n        Object* obj = dequeue(&queue);\n        \n        if (!obj->marked) {\n            obj->marked = true;\n            \n            // Add children to queue\n            for (each child in obj->children) {\n                enqueue(&queue, child);\n            }\n        }\n    }\n}\n```\n\n**Benefits**:\n- âœ… **Bounded stack usage**: Only queue grows (on heap)\n- âœ… **Predictable memory**: Queue size â‰ˆ graph width\n- âœ… **Debuggable**: Can inspect queue state\n\n---\n\n## Internal Mechanics: The Mark Phase Architecture\n\n### Component 1: The Work Queue\n\n{{DIAGRAM:mark-work-queue}}\n\n```\nWork Queue (FIFO):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [obj1] [obj3] [obj5] [obj7] ...     â”‚  â† Enqueue (back)\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n   â†‘\n   Dequeue (front)\n\nProperties:\n- Dynamic resizing (like root set)\n- FIFO order (breadth-first)\n- Duplicate detection (via mark bits)\n```\n\n### Component 2: The Mark Bit\n\nEach object header contains a **mark bit**:\n\n```c\ntypedef struct ObjectHeader {\n    size_t size;           // Object size\n    bool marked : 1;       // Mark bit (1 bit)\n    bool pinned : 1;       // Pinned flag\n    uint8_t padding : 6;   // Alignment padding\n    struct ObjectHeader* next;  // Free list link\n} ObjectHeader;\n```\n\n**Mark Bit States**:\n- `0` (unmarked): Not yet visited or unreachable\n- `1` (marked): Reachable from roots\n\n### Component 3: Object Scanning\n\nFor each object, we must find **all pointers it contains**:\n\n```c\nvoid scan_object(GC* gc, void* obj, WorkQueue* queue) {\n    ObjectHeader* header = GET_HEADER(obj);\n    \n    // Scan object's memory word-by-word (conservative)\n    uintptr_t* p = (uintptr_t*)obj;\n    uintptr_t* end = (uintptr_t*)((char*)obj + header->size);\n    \n    while (p < end) {\n        void* potential_ptr = (void*)*p;\n        \n        if (is_potential_pointer(gc, potential_ptr)) {\n            enqueue(queue, potential_ptr);\n        }\n        \n        p++;\n    }\n}\n```\n\n**Quick Breakdown: Conservative Object Scanning**\n\nWe scan **every word** in the object because we don't have type information. This means:\n- **Integers that look like pointers** â†’ Treated as pointers (false positives)\n- **Actual pointers** â†’ Correctly identified\n- **Trade-off**: Safety over precision\n\n---\n\n## The Mark Algorithm: Step-by-Step\n\n### Phase 1: Initialization\n\n```c\nvoid mark_phase(GC* gc) {\n    // Step 1: Clear all mark bits\n    clear_all_marks(gc);\n    \n    // Step 2: Scan roots\n    scan_roots(gc);\n    \n    // Step 3: Initialize work queue\n    WorkQueue queue;\n    init_work_queue(&queue);\n    \n    // Step 4: Add roots to queue\n    for (size_t i = 0; i < gc->root_set.count; i++) {\n        enqueue(&queue, gc->root_set.roots[i]);\n    }\n```\n\n### Phase 2: Iterative Traversal\n\n```c\n    // Step 5: Process queue\n    while (!is_empty(&queue)) {\n        void* obj = dequeue(&queue);\n        \n        // Get object header\n        ObjectHeader* header = GET_HEADER(obj);\n        \n        // Skip if already marked\n        if (header->marked) {\n            continue;\n        }\n        \n        // Mark object\n        header->marked = true;\n        gc->stats.marked_objects++;\n        gc->stats.marked_bytes += header->size;\n        \n        // Scan object for pointers\n        scan_object(gc, obj, &queue);\n    }\n    \n    // Step 6: Cleanup\n    destroy_work_queue(&queue);\n}\n```\n\n### Phase 3: Statistics\n\n```c\n    #ifdef GC_DEBUG\n    printf(\"Mark phase complete:\\n\");\n    printf(\"  Marked objects: %zu\\n\", gc->stats.marked_objects);\n    printf(\"  Marked bytes: %zu\\n\", gc->stats.marked_bytes);\n    printf(\"  Mark rate: %.2f MB/s\\n\", \n           gc->stats.marked_bytes / gc->stats.mark_time_ms / 1000.0);\n    #endif\n}\n```\n\n---\n\n## Visual Reference\n\n{{DIAGRAM:mark-phase-flow}}\n\n```\nMark Phase Flow:\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n1. CLEAR MARKS\n   â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”\n   â”‚ â—‹ A â”‚ â”‚ â—‹ B â”‚ â”‚ â—‹ C â”‚  (all unmarked)\n   â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜\n\n2. SCAN ROOTS\n   Roots: [A, C]\n   \n3. INITIALIZE QUEUE\n   Queue: [A] [C]\n\n4. PROCESS A\n   â”Œâ”€â”€â”€â”€â”€â”\n   â”‚ â— A â”‚ â† Mark\n   â””â”€â”€â”¬â”€â”€â”˜\n      â”‚ points to B\n      â†“\n   Queue: [C] [B]\n\n5. PROCESS C\n   â”Œâ”€â”€â”€â”€â”€â”\n   â”‚ â— C â”‚ â† Mark\n   â””â”€â”€â”€â”€â”€â”˜\n   (no children)\n   Queue: [B]\n\n6. PROCESS B\n   â”Œâ”€â”€â”€â”€â”€â”\n   â”‚ â— B â”‚ â† Mark\n   â””â”€â”€â”¬â”€â”€â”˜\n      â”‚ points to D\n      â†“\n   Queue: [D]\n\n7. PROCESS D\n   â”Œâ”€â”€â”€â”€â”€â”\n   â”‚ â— D â”‚ â† Mark\n   â””â”€â”€â”€â”€â”€â”˜\n   Queue: [] (empty)\n\n8. DONE\n   Marked: A, B, C, D\n   Unmarked: (garbage)\n```\n\n---\n\n## The Debugging Lab: Common Pitfalls\n\n### Bug 1: Forgetting to Clear Marks\n\n**Symptom**: Objects never get collected after first GC.\n\n```c\n// âŒ WRONG: Marks accumulate\nvoid mark_phase(GC* gc) {\n    // Missing: clear_all_marks(gc);\n    scan_roots(gc);\n    // ...\n}\n```\n\n**Fix**:\n\n```c\n// âœ… CORRECT: Clear marks before each GC\nvoid clear_all_marks(GC* gc) {\n    for (Block* block = gc->heap_start; \n         block < gc->heap_end; \n         block = NEXT_BLOCK(block)) {\n        \n        ObjectHeader* header = (ObjectHeader*)block;\n        header->marked = false;\n    }\n}\n```\n\n### Bug 2: Infinite Loop (Cycles)\n\n**Symptom**: Mark phase never terminates.\n\n```c\n// âŒ WRONG: No duplicate detection\nwhile (!is_empty(&queue)) {\n    void* obj = dequeue(&queue);\n    \n    // Missing: if (header->marked) continue;\n    \n    header->marked = true;\n    scan_object(gc, obj, &queue);  // Re-adds obj!\n}\n```\n\n**Fix**: Check mark bit **before** marking:\n\n```c\n// âœ… CORRECT: Skip already-marked objects\nif (header->marked) {\n    continue;  // Already processed\n}\nheader->marked = true;\n```\n\n### Bug 3: Queue Overflow\n\n**Symptom**: Crash when marking large graphs.\n\n```c\n// âŒ WRONG: Fixed-size queue\n#define MAX_QUEUE_SIZE 1000\nvoid* queue[MAX_QUEUE_SIZE];\nsize_t queue_size = 0;\n\nvoid enqueue(void* obj) {\n    queue[queue_size++] = obj;  // Overflow!\n}\n```\n\n**Fix**: Dynamic resizing:\n\n```c\n// âœ… CORRECT: Resizable queue\nvoid enqueue(WorkQueue* q, void* obj) {\n    if (q->size >= q->capacity) {\n        q->capacity *= 2;\n        q->items = realloc(q->items, q->capacity * sizeof(void*));\n    }\n    q->items[q->size++] = obj;\n}\n```\n\n### Bug 4: Scanning Uninitialized Memory\n\n**Symptom**: Random crashes or false pointers.\n\n```c\n// âŒ WRONG: Scanning beyond object bounds\nvoid scan_object(GC* gc, void* obj, WorkQueue* queue) {\n    uintptr_t* p = (uintptr_t*)obj;\n    \n    // Missing: bounds check\n    for (int i = 0; i < 1000; i++) {  // Arbitrary limit!\n        enqueue(queue, (void*)p[i]);\n    }\n}\n```\n\n**Fix**: Use object size from header:\n\n```c\n// âœ… CORRECT: Respect object bounds\nObjectHeader* header = GET_HEADER(obj);\nuintptr_t* end = (uintptr_t*)((char*)obj + header->size);\n\nwhile (p < end) {\n    // Safe: within object bounds\n}\n```\n\n---\n\n## Code Scaffold: Your Implementation Tasks\n\n### Task 1: Work Queue Implementation\n\n```c\ntypedef struct {\n    void** items;      // Dynamic array of object pointers\n    size_t size;       // Current number of items\n    size_t capacity;   // Allocated capacity\n    size_t head;       // Dequeue position (FIFO)\n} WorkQueue;\n\nvoid init_work_queue(WorkQueue* queue) {\n    // TODO: Allocate initial capacity\n    queue->capacity = 256;  // Start small\n    queue->items = malloc(queue->capacity * sizeof(void*));\n    \n    if (queue->items == NULL) {\n        fprintf(stderr, \"ERROR: Failed to allocate work queue\\n\");\n        abort();\n    }\n    \n    // TODO: Initialize size and head\n    queue->size = 0;\n    queue->head = 0;\n}\n\nvoid enqueue(WorkQueue* queue, void* obj) {\n    // TODO: Check if resize needed\n    if (queue->size >= queue->capacity) {\n        // TODO: Double capacity\n        size_t new_capacity = queue->capacity * 2;\n        void** new_items = realloc(queue->items, \n                                   new_capacity * sizeof(void*));\n        \n        if (new_items == NULL) {\n            fprintf(stderr, \"ERROR: Failed to resize work queue\\n\");\n            abort();\n        }\n        \n        queue->items = new_items;\n        queue->capacity = new_capacity;\n        \n        #ifdef GC_DEBUG\n        printf(\"Work queue resized to %zu\\n\", new_capacity);\n        #endif\n    }\n    \n    // TODO: Add item to queue\n    queue->items[queue->size++] = obj;\n}\n\nvoid* dequeue(WorkQueue* queue) {\n    // TODO: Check if empty\n    if (is_empty(queue)) {\n        return NULL;\n    }\n    \n    // TODO: Return and remove front item\n    return queue->items[queue->head++];\n}\n\nbool is_empty(WorkQueue* queue) {\n    // TODO: Check if all items processed\n    return queue->head >= queue->size;\n}\n\nvoid destroy_work_queue(WorkQueue* queue) {\n    // TODO: Free memory\n    free(queue->items);\n    queue->items = NULL;\n    queue->size = 0;\n    queue->capacity = 0;\n    queue->head = 0;\n}\n```\n\n**Debugging Tip**: Track queue statistics:\n\n```c\n#ifdef GC_DEBUG\nsize_t max_queue_size = 0;\nif (queue->size > max_queue_size) {\n    max_queue_size = queue->size;\n}\nprintf(\"Max queue size: %zu\\n\", max_queue_size);\n#endif\n```\n\n### Task 2: Clear All Mark Bits\n\n```c\nvoid clear_all_marks(GC* gc) {\n    // TODO: Iterate through all allocated blocks\n    char* current = (char*)gc->heap_start;\n    char* heap_end = (char*)gc->heap_start + gc->heap_size;\n    \n    while (current < heap_end) {\n        ObjectHeader* header = (ObjectHeader*)current;\n        \n        // TODO: Skip free blocks (check free list)\n        if (is_in_free_list(gc, header)) {\n            current += sizeof(ObjectHeader) + header->size;\n            continue;\n        }\n        \n        // TODO: Clear mark bit\n        header->marked = false;\n        \n        // TODO: Move to next block\n        current += sizeof(ObjectHeader) + header->size;\n    }\n    \n    #ifdef GC_DEBUG\n    printf(\"Cleared all mark bits\\n\");\n    #endif\n}\n\nbool is_in_free_list(GC* gc, ObjectHeader* header) {\n    // TODO: Check if header is in free list\n    for (ObjectHeader* free_block = gc->free_list; \n         free_block != NULL; \n         free_block = free_block->next) {\n        \n        if (free_block == header) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n**Alternative Approach**: Use a **separate mark bitmap** instead of mark bits in headers:\n\n```c\n// Bitmap: 1 bit per 8-byte word\ntypedef struct {\n    uint8_t* bits;\n    size_t num_bits;\n} MarkBitmap;\n\nvoid set_mark(MarkBitmap* bitmap, void* obj) {\n    size_t index = ((char*)obj - heap_start) / 8;\n    size_t byte = index / 8;\n    size_t bit = index % 8;\n    bitmap->bits[byte] |= (1 << bit);\n}\n```\n\n### Task 3: Object Scanning\n\n```c\nvoid scan_object(GC* gc, void* obj, WorkQueue* queue) {\n    // TODO: Get object header\n    ObjectHeader* header = GET_HEADER(obj);\n    \n    // TODO: Calculate scan range\n    uintptr_t* p = (uintptr_t*)obj;\n    uintptr_t* end = (uintptr_t*)((char*)obj + header->size);\n    \n    #ifdef GC_DEBUG\n    printf(\"Scanning object %p (size=%zu)\\n\", obj, header->size);\n    size_t pointers_found = 0;\n    #endif\n    \n    // TODO: Scan word-by-word\n    while (p < end) {\n        void* potential_ptr = (void*)*p;\n        \n        // TODO: Check if it looks like a heap pointer\n        if (is_potential_pointer(gc, potential_ptr)) {\n            // TODO: Add to work queue\n            enqueue(queue, potential_ptr);\n            \n            #ifdef GC_DEBUG\n            pointers_found++;\n            #endif\n        }\n        \n        p++;\n    }\n    \n    #ifdef GC_DEBUG\n    printf(\"  Found %zu pointers\\n\", pointers_found);\n    #endif\n}\n```\n\n### Task 4: Main Mark Phase\n\n```c\nvoid mark_phase(GC* gc) {\n    #ifdef GC_DEBUG\n    printf(\"\\n=== MARK PHASE START ===\\n\");\n    clock_t start = clock();\n    #endif\n    \n    // TODO: Step 1 - Clear all marks\n    clear_all_marks(gc);\n    \n    // TODO: Step 2 - Scan roots\n    scan_roots(gc);\n    \n    #ifdef GC_DEBUG\n    printf(\"Root set size: %zu\\n\", gc->root_set.count);\n    #endif\n    \n    // TODO: Step 3 - Initialize work queue\n    WorkQueue queue;\n    init_work_queue(&queue);\n    \n    // TODO: Step 4 - Add all roots to queue\n    for (size_t i = 0; i < gc->root_set.count; i++) {\n        enqueue(&queue, gc->root_set.roots[i]);\n    }\n    \n    // TODO: Step 5 - Process work queue\n    size_t objects_marked = 0;\n    size_t bytes_marked = 0;\n    \n    while (!is_empty(&queue)) {\n        void* obj = dequeue(&queue);\n        \n        // TODO: Get object header\n        ObjectHeader* header = GET_HEADER(obj);\n        \n        // TODO: Skip if already marked\n        if (header->marked) {\n            continue;\n        }\n        \n        // TODO: Mark object\n        header->marked = true;\n        objects_marked++;\n        bytes_marked += header->size;\n        \n        // TODO: Scan object for child pointers\n        scan_object(gc, obj, &queue);\n    }\n    \n    // TODO: Step 6 - Cleanup\n    destroy_work_queue(&queue);\n    \n    // TODO: Step 7 - Update statistics\n    gc->stats.marked_objects = objects_marked;\n    gc->stats.marked_bytes = bytes_marked;\n    \n    #ifdef GC_DEBUG\n    clock_t end = clock();\n    double elapsed = (double)(end - start) / CLOCKS_PER_SEC * 1000.0;\n    \n    printf(\"=== MARK PHASE COMPLETE ===\\n\");\n    printf(\"  Objects marked: %zu\\n\", objects_marked);\n    printf(\"  Bytes marked: %zu\\n\", bytes_marked);\n    printf(\"  Time: %.2f ms\\n\", elapsed);\n    printf(\"  Rate: %.2f MB/s\\n\", \n           bytes_marked / elapsed / 1000.0);\n    #endif\n}\n```\n\n### Task 5: Mark Bit Helpers\n\n```c\nbool is_marked(void* obj) {\n    // TODO: Check mark bit\n    ObjectHeader* header = GET_HEADER(obj);\n    return header->marked;\n}\n\nvoid set_mark(void* obj) {\n    // TODO: Set mark bit\n    ObjectHeader* header = GET_HEADER(obj);\n    header->marked = true;\n}\n\nvoid clear_mark(void* obj) {\n    // TODO: Clear mark bit\n    ObjectHeader* header = GET_HEADER(obj);\n    header->marked = false;\n}\n```\n\n---\n\n## Testing Your Implementation\n\n### Test 1: Simple Linear Chain\n\n```c\nvoid test_linear_chain() {\n    GC* gc = gc_init(4096);\n    \n    // Create chain: obj1 â†’ obj2 â†’ obj3\n    void* obj1 = gc_alloc(gc, 64);\n    void* obj2 = gc_alloc(gc, 64);\n    void* obj3 = gc_alloc(gc, 64);\n    \n    // Link them\n    *(void**)obj1 = obj2;\n    *(void**)obj2 = obj3;\n    \n    // Mark phase\n    mark_phase(gc);\n    \n    // Verify all marked\n    assert(is_marked(obj1));\n    assert(is_marked(obj2));\n    assert(is_marked(obj3));\n    \n    printf(\"âœ“ Linear chain test passed\\n\");\n}\n```\n\n### Test 2: Cyclic Graph\n\n```c\nvoid test_cycle() {\n    GC* gc = gc_init(4096);\n    \n    // Create cycle: obj1 â†’ obj2 â†’ obj3 â†’ obj1\n    void* obj1 = gc_alloc(gc, 64);\n    void* obj2 = gc_alloc(gc, 64);\n    void* obj3 = gc_alloc(gc, 64);\n    \n    *(void**)obj1 = obj2;\n    *(void**)obj2 = obj3;\n    *(void**)obj3 = obj1;  // Cycle!\n    \n    // Mark phase (should terminate)\n    mark_phase(gc);\n    \n    // Verify all marked\n    assert(is_marked(obj1));\n    assert(is_marked(obj2));\n    assert(is_marked(obj3));\n    \n    printf(\"âœ“ Cycle test passed\\n\");\n}\n```\n\n### Test 3: Unreachable Objects\n\n```c\nvoid test_unreachable() {\n    GC* gc = gc_init(4096);\n    \n    // Reachable\n    void* obj1 = gc_alloc(gc, 64);\n    \n    // Unreachable (not on stack after this block)\n    {\n        void* obj2 = gc_alloc(gc, 64);\n        (void)obj2;  // Suppress warning\n    }\n    \n    // Mark phase\n    mark_phase(gc);\n    \n    // obj1 should be marked, obj2 should not\n    assert(is_marked(obj1));\n    // Note: Can't easily test obj2 without keeping pointer\n    \n    printf(\"âœ“ Unreachable test passed\\n\");\n}\n```\n\n### Test 4: Deep Graph\n\n```c\nvoid test_deep_graph() {\n    GC* gc = gc_init(1024 * 1024);  // 1 MB\n    \n    // Create deep chain (10,000 nodes)\n    void* prev = NULL;\n    void* first = NULL;\n    \n    for (int i = 0; i < 10000; i++) {\n        void* obj = gc_alloc(gc, 64);\n        \n        if (i == 0) {\n            first = obj;\n        }\n        \n        if (prev != NULL) {\n            *(void**)prev = obj;\n        }\n        \n        prev = obj;\n    }\n    \n    // Mark phase (should not stack overflow)\n    mark_phase(gc);\n    \n    // Verify first is marked\n    assert(is_marked(first));\n    \n    printf(\"âœ“ Deep graph test passed\\n\");\n}\n```\n\n### Test 5: Wide Graph\n\n```c\nvoid test_wide_graph() {\n    GC* gc = gc_init(1024 * 1024);\n    \n    // Create root with 1000 children\n    void* root = gc_alloc(gc, 1000 * sizeof(void*));\n    void** children = (void**)root;\n    \n    for (int i = 0; i < 1000; i++) {\n        children[i] = gc_alloc(gc, 64);\n    }\n    \n    // Mark phase\n    mark_phase(gc);\n    \n    // Verify all marked\n    assert(is_marked(root));\n    for (int i = 0; i < 1000; i++) {\n        assert(is_marked(children[i]));\n    }\n    \n    printf(\"âœ“ Wide graph test passed\\n\");\n}\n```\n\n### Test 6: Mark Statistics\n\n```c\nvoid test_mark_statistics() {\n    GC* gc = gc_init(4096);\n    \n    // Allocate known objects\n    void* obj1 = gc_alloc(gc, 100);\n    void* obj2 = gc_alloc(gc, 200);\n    void* obj3 = gc_alloc(gc, 300);\n    \n    // Mark phase\n    mark_phase(gc);\n    \n    // Verify statistics\n    assert(gc->stats.marked_objects == 3);\n    assert(gc->stats.marked_bytes == 600);\n    \n    printf(\"âœ“ Mark statistics test passed\\n\");\n}\n```\n\n---\n\n## Performance Considerations\n\n### Time Complexity\n\n| Operation | Complexity | Notes |\n|-----------|------------|-------|\n| `clear_all_marks()` | O(heap_size) | Linear scan |\n| `scan_roots()` | O(roots) | From previous section |\n| **Mark traversal** | **O(live_objects Ã— avg_pointers)** | **Dominant cost** |\n| `enqueue/dequeue` | O(1) amortized | Dynamic array |\n| **Total** | **O(heap + live_objects Ã— pointers)** | Linear in live set |\n\n### Space Complexity\n\n```\nWork Queue Size:\n- Best case: O(1) (linear chain)\n- Worst case: O(live_objects) (all objects at same depth)\n- Typical: O(âˆšlive_objects) (balanced tree)\n\nExample:\n- 1 million objects\n- Average 4 pointers per object\n- Queue peak: ~1000 objects (4 KB)\n```\n\n### Optimization 1: Tri-Color Marking\n\n**Problem**: Work queue can grow large.\n\n**Solution**: Use **tri-color abstraction**:\n\n```c\ntypedef enum {\n    WHITE,  // Unmarked (not yet seen)\n    GRAY,   // Marked but not scanned (in queue)\n    BLACK   // Marked and scanned (done)\n} Color;\n\n// Only GRAY objects are in queue\nvoid mark_tricolor(GC* gc) {\n    // All objects start WHITE\n    \n    // Roots become GRAY\n    for (each root) {\n        set_color(root, GRAY);\n        enqueue(root);\n    }\n    \n    while (!is_empty(&queue)) {\n        void* obj = dequeue(&queue);\n        \n        // Scan GRAY object\n        for (each child) {\n            if (get_color(child) == WHITE) {\n                set_color(child, GRAY);\n                enqueue(child);\n            }\n        }\n        \n        // Object is now BLACK (fully scanned)\n        set_color(obj, BLACK);\n    }\n}\n```\n\n**Benefits**:\n- âœ… Clearer algorithm structure\n- âœ… Enables incremental GC (pause between objects)\n- âœ… Easier to reason about correctness\n\n### Optimization 2: Pointer Filtering\n\n**Problem**: Conservative scanning checks every word.\n\n**Solution**: Use **alignment hints**:\n\n```c\nbool is_potential_pointer(GC* gc, void* ptr) {\n    // Quick reject: not aligned\n    if ((uintptr_t)ptr % sizeof(void*) != 0) {\n        return false;  // Pointers are word-aligned\n    }\n    \n    // Quick reject: out of heap bounds\n    if (ptr < gc->heap_start || ptr >= gc->heap_end) {\n        return false;\n    }\n    \n    // Expensive check: valid object header\n    return is_valid_object(gc, ptr);\n}\n```\n\n**Speedup**: ~2-3Ã— faster scanning\n\n### Optimization 3: Parallel Marking\n\n**Problem**: Single-threaded marking is slow.\n\n**Solution**: **Parallel work-stealing**:\n\n```c\nvoid mark_parallel(GC* gc, int num_threads) {\n    WorkQueue queues[num_threads];\n    \n    // Each thread has own queue\n    #pragma omp parallel for\n    for (int i = 0; i < num_threads; i++) {\n        while (true) {\n            void* obj = dequeue(&queues[i]);\n            \n            if (obj == NULL) {\n                // Try to steal from other threads\n                obj = steal_work(queues, num_threads, i);\n                if (obj == NULL) break;\n            }\n            \n            // Mark and scan\n            if (!atomic_test_and_set(&obj->marked)) {\n                scan_object(gc, obj, &queues[i]);\n            }\n        }\n    }\n}\n```\n\n**Speedup**: ~4-8Ã— on modern CPUs\n\n---\n\n## What You've Learned\n\nâœ… **Graph Traversal**: How to walk object graphs without recursion  \nâœ… **Work Queues**: FIFO data structure for iterative algorithms  \nâœ… **Mark Bits**: Efficient boolean flags in object headers  \nâœ… **Cycle Handling**: Detecting and avoiding infinite loops  \nâœ… **Conservative Scanning**: Finding pointers without type info  \nâœ… **Performance Tuning**: Queue sizing, filtering, parallelization  \nâœ… **Debugging Techniques**: Statistics, logging, visualization  \n\n---\n\n## Next Steps\n\nYou've now implemented the **mark phase** â€” the heart of garbage collection! Next:\n\n- **[Sweep Phase â†’](#sweep-engine)**: Reclaim unmarked objects and rebuild free list\n- **[Integration â†’](#gc-integration)**: Connect mark-sweep into `gc_collect()`\n- **[Optimization â†’](#gc-optimization)**: Generational GC, incremental marking\n\n**Pro Tip**: Before moving on, run the test suite and verify:\n1. **No stack overflow** on deep graphs (10,000+ nodes)\n2. **Correct cycle handling** (mark phase terminates)\n3. **Accurate statistics** (marked bytes match allocated bytes)\n\n**Challenge**: Implement **mark stack overflow recovery** â€” when the work queue grows too large, fall back to recursive marking for a subset of objects.\n\n---\n\n[â†‘ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-object-graph\"></div>\n\n# Object Graph Traversal: Following the Web of Memory\n\n## The Epiphany Analogy: The Museum Curator's Flashlight\n\nImagine you're a museum curator in a pitch-black warehouse filled with sculptures. Each sculpture has strings attached to other sculptures (references). Your job: find every sculpture connected to the entrance (roots) and mark them with glow-in-the-dark paint.\n\n**The naive approach**: Follow each string recursively, going deeper and deeper. Problem? You might follow a 10,000-sculpture chain and run out of breadcrumbs (stack space).\n\n**The professional approach**: Carry a clipboard (work queue). When you find a sculpture:\n1. Paint it with glow paint (mark bit)\n2. Write down all sculptures it points to on your clipboard\n3. Move to the next item on your clipboard\n\n**The cycle problem**: What if sculpture A points to B, B points to C, and C points back to A? Solution: Before adding to your clipboard, check if it's already glowing. If it is, skip it!\n\nThis is **object graph traversal** â€” the systematic exploration of memory's interconnected web.\n\n---\n\n## Technical Rationale: Why Iterative Traversal?\n\n### The Recursion Trap\n\n**Naive recursive marking**:\n```c\nvoid mark_recursive(void* obj) {\n    if (is_marked(obj)) return;  // Already visited\n    \n    set_mark(obj);\n    \n    // Recursively mark children\n    for (each child pointer in obj) {\n        mark_recursive(child);  // âš ï¸ DANGER: Stack overflow!\n    }\n}\n```\n\n**The problem**:\n- Each recursive call consumes **~64 bytes** of stack space (return address, frame pointer, local variables)\n- Default stack size: **~8 MB** on Linux, **~1 MB** on Windows\n- Maximum depth: **~125,000 calls** (Linux) or **~15,000 calls** (Windows)\n- Real-world object graphs can be **millions deep** (linked lists, tree spines)\n\n**The solution**: Replace the **call stack** with an **explicit work queue** in heap memory.\n\n---\n\n## Internal Mechanics: The Work Queue Algorithm\n\n### Data Structure: The Work Queue\n\n```c\ntypedef struct {\n    void** items;      // Dynamic array of object pointers\n    size_t capacity;   // Total slots available\n    size_t head;       // Next item to dequeue (read position)\n    size_t tail;       // Next slot to enqueue (write position)\n    size_t count;      // Number of items currently in queue\n} WorkQueue;\n```\n\n**Memory layout**:\n```\nInitial state (capacity=4):\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”\nâ”‚  ?  â”‚  ?  â”‚  ?  â”‚  ?  â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜\n â†‘head                    â†‘tail\n count=0\n\nAfter enqueue(A), enqueue(B):\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”\nâ”‚  A  â”‚  B  â”‚  ?  â”‚  ?  â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜\n â†‘head       â†‘tail\n count=2\n\nAfter dequeue() â†’ returns A:\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”\nâ”‚  A  â”‚  B  â”‚  ?  â”‚  ?  â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜\n       â†‘head â†‘tail\n       count=1\n```\n\n### Algorithm: Breadth-First Search (BFS)\n\n**Why BFS over DFS?**\n- **Better cache locality**: Process objects at same depth together (likely allocated together)\n- **Predictable memory usage**: Queue size = objects at current depth\n- **Easier to parallelize**: Multiple threads can steal from queue\n\n**The traversal loop**:\n```\n1. Clear all mark bits (everything starts \"white\")\n2. Add all roots to work queue (roots become \"gray\")\n3. While queue not empty:\n   a. Dequeue object\n   b. If already marked, skip (avoid duplicate work)\n   c. Mark object (becomes \"black\")\n   d. Scan object for child pointers\n   e. For each child:\n      - If unmarked, enqueue it (becomes \"gray\")\n4. Done! All reachable objects are marked\n```\n\n{{DIAGRAM:object-graph-traversal}}\n\n---\n\n## The Microscope Effect: Bit-Level Marking\n\n### The Mark Bit\n\n**Location**: Inside the `ObjectHeader` (from previous sections):\n```c\ntypedef struct {\n    size_t size;           // Bytes: 0-7\n    uint8_t marked : 1;    // Bit 64 (1 bit)\n    uint8_t pinned : 1;    // Bit 65 (1 bit)\n    uint8_t type : 6;      // Bits 66-71 (6 bits)\n    // ... padding to 16 bytes\n} ObjectHeader;\n```\n\n**Memory representation**:\n```\nObject at 0x1000:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ size=64 (8 bytes)                      â”‚ 0x1000\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ marked=0, pinned=0, type=0 (1 byte)   â”‚ 0x1008\nâ”‚ padding (7 bytes)                      â”‚ 0x1009-0x100F\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ User data (64 bytes)                   â”‚ 0x1010-0x104F\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nAfter marking:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ size=64 (unchanged)                    â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ marked=1 â† CHANGED, pinned=0, type=0  â”‚\nâ”‚ padding (unchanged)                    â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ User data (unchanged)                  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Atomic operations** (for parallel GC):\n```c\n// Test-and-set: atomically check and mark\nbool atomic_mark(void* obj) {\n    ObjectHeader* header = GET_HEADER(obj);\n    \n    // GCC/Clang builtin\n    return !__sync_lock_test_and_set(&header->marked, 1);\n    // Returns true if we were first to mark it\n}\n```\n\n---\n\n## The Debugging Lab: Common Pitfalls\n\n### Bug #1: Infinite Loop (Cycle Not Detected)\n\n**Symptom**: Mark phase never terminates, CPU at 100%.\n\n**Cause**: Forgetting to check `if (marked) continue;`\n\n**Bad code**:\n```c\nwhile (!is_empty(&queue)) {\n    void* obj = dequeue(&queue);\n    \n    set_mark(obj);  // âš ï¸ No check if already marked!\n    \n    scan_object(gc, obj, &queue);  // Re-enqueues children\n}\n```\n\n**What happens**:\n```\nCycle: A â†’ B â†’ C â†’ A\n\nIteration 1: Dequeue A, mark A, enqueue B\nIteration 2: Dequeue B, mark B, enqueue C\nIteration 3: Dequeue C, mark C, enqueue A  â† A already marked!\nIteration 4: Dequeue A, mark A, enqueue B  â† Infinite loop!\n```\n\n**Fix**:\n```c\nwhile (!is_empty(&queue)) {\n    void* obj = dequeue(&queue);\n    \n    ObjectHeader* header = GET_HEADER(obj);\n    if (header->marked) {\n        continue;  // âœ… Skip already-marked objects\n    }\n    \n    header->marked = true;\n    scan_object(gc, obj, &queue);\n}\n```\n\n**Debugging tip**: Add a counter and assert it doesn't exceed total objects:\n```c\nsize_t iterations = 0;\nwhile (!is_empty(&queue)) {\n    assert(iterations++ < gc->total_objects * 2);  // Safety net\n    // ...\n}\n```\n\n---\n\n### Bug #2: Stack Overflow (Despite Iterative Algorithm!)\n\n**Symptom**: Segmentation fault in `scan_object()`.\n\n**Cause**: `scan_object()` itself uses recursion!\n\n**Bad code**:\n```c\nvoid scan_object(GC* gc, void* obj, WorkQueue* queue) {\n    // Conservative scan: treat every word as potential pointer\n    void** ptr = (void**)obj;\n    size_t words = GET_HEADER(obj)->size / sizeof(void*);\n    \n    for (size_t i = 0; i < words; i++) {\n        if (is_valid_pointer(gc, ptr[i])) {\n            // âš ï¸ Recursive call!\n            scan_object(gc, ptr[i], queue);\n        }\n    }\n}\n```\n\n**Fix**: Only enqueue, don't recurse:\n```c\nvoid scan_object(GC* gc, void* obj, WorkQueue* queue) {\n    void** ptr = (void**)obj;\n    size_t words = GET_HEADER(obj)->size / sizeof(void*);\n    \n    for (size_t i = 0; i < words; i++) {\n        if (is_valid_pointer(gc, ptr[i])) {\n            enqueue(queue, ptr[i]);  // âœ… Add to queue, don't recurse\n        }\n    }\n}\n```\n\n---\n\n### Bug #3: Queue Overflow (Out of Memory)\n\n**Symptom**: `malloc()` fails in `enqueue()`, or program crashes.\n\n**Cause**: Work queue grows unbounded on wide graphs.\n\n**Example**:\n```c\n// Root object with 1 million children\nvoid* root = gc_alloc(gc, 1000000 * sizeof(void*));\nvoid** children = (void**)root;\n\nfor (int i = 0; i < 1000000; i++) {\n    children[i] = gc_alloc(gc, 64);\n}\n\n// Mark phase enqueues all 1 million children at once!\n// Queue size: 1,000,000 Ã— 8 bytes = 8 MB\n```\n\n**Fix #1**: Set a maximum queue size:\n```c\n#define MAX_QUEUE_SIZE (1024 * 1024)  // 1M objects\n\nvoid enqueue(WorkQueue* queue, void* obj) {\n    if (queue->count >= MAX_QUEUE_SIZE) {\n        // Fall back to recursive marking for this object\n        mark_recursive_limited(obj, 100);  // Max depth 100\n        return;\n    }\n    \n    // Normal enqueue logic...\n}\n```\n\n**Fix #2**: Use a **deque** (double-ended queue) and switch to DFS when queue is large:\n```c\nif (queue->count > THRESHOLD) {\n    // Pop from tail (DFS) instead of head (BFS)\n    void* obj = pop_tail(queue);\n} else {\n    // Normal BFS\n    void* obj = dequeue(queue);\n}\n```\n\n---\n\n### Bug #4: False Negatives (Objects Not Marked)\n\n**Symptom**: Live objects are collected, causing use-after-free crashes.\n\n**Cause**: Missing a pointer during scanning.\n\n**Example**:\n```c\ntypedef struct {\n    int x;\n    void* next;  // Pointer at offset 4\n} Node;\n\nvoid scan_object(GC* gc, void* obj, WorkQueue* queue) {\n    // âš ï¸ Assumes pointers are at word boundaries!\n    void** ptr = (void**)obj;\n    size_t words = GET_HEADER(obj)->size / sizeof(void*);\n    \n    for (size_t i = 0; i < words; i++) {\n        // Misses 'next' pointer if sizeof(void*) = 8 and x = 4 bytes!\n    }\n}\n```\n\n**Fix**: Scan byte-by-byte for conservative GC:\n```c\nvoid scan_object(GC* gc, void* obj, WorkQueue* queue) {\n    uint8_t* bytes = (uint8_t*)obj;\n    size_t size = GET_HEADER(obj)->size;\n    \n    // Check every possible pointer location\n    for (size_t i = 0; i <= size - sizeof(void*); i++) {\n        void* potential = *(void**)(bytes + i);\n        if (is_valid_pointer(gc, potential)) {\n            enqueue(queue, potential);\n        }\n    }\n}\n```\n\n**Debugging tip**: Enable verbose logging:\n```c\n#ifdef GC_DEBUG\nprintf(\"Scanning object at %p (size=%zu)\\n\", obj, GET_HEADER(obj)->size);\nfor (size_t i = 0; i < words; i++) {\n    if (is_valid_pointer(gc, ptr[i])) {\n        printf(\"  Found pointer: %p â†’ %p\\n\", &ptr[i], ptr[i]);\n    }\n}\n#endif\n```\n\n---\n\n## Code Scaffold: Your Implementation Tasks\n\n### Task 1: Work Queue Initialization\n\n```c\nvoid init_work_queue(WorkQueue* queue) {\n    // TODO: Allocate initial capacity\n    queue->capacity = 256;  // Start small, grow as needed\n    queue->items = malloc(queue->capacity * sizeof(void*));\n    \n    if (queue->items == NULL) {\n        fprintf(stderr, \"Failed to allocate work queue\\n\");\n        exit(1);\n    }\n    \n    queue->head = 0;\n    queue->tail = 0;\n    queue->count = 0;\n}\n```\n\n**Your task**: Add error handling and consider initial capacity based on heap size.\n\n**Hint**: For a 1 MB heap with 64-byte objects, expect ~16,000 objects. A good initial capacity is `sqrt(total_objects)` â‰ˆ 128.\n\n---\n\n### Task 2: Enqueue with Dynamic Growth\n\n```c\nvoid enqueue(WorkQueue* queue, void* obj) {\n    // TODO: Check if queue is full\n    if (queue->count == queue->capacity) {\n        // TODO: Grow queue (double capacity)\n        size_t new_capacity = queue->capacity * 2;\n        void** new_items = realloc(queue->items, \n                                   new_capacity * sizeof(void*));\n        \n        if (new_items == NULL) {\n            fprintf(stderr, \"Work queue out of memory\\n\");\n            exit(1);\n        }\n        \n        queue->items = new_items;\n        queue->capacity = new_capacity;\n        \n        #ifdef GC_DEBUG\n        printf(\"Work queue grew to %zu\\n\", new_capacity);\n        #endif\n    }\n    \n    // TODO: Add item at tail\n    queue->items[queue->tail] = obj;\n    queue->tail = (queue->tail + 1) % queue->capacity;  // Circular buffer\n    queue->count++;\n}\n```\n\n**Your task**: Handle the circular buffer wrap-around correctly.\n\n**Tricky case**: After realloc, if `head > tail`, you need to unwrap:\n```c\n// Before realloc (capacity=4, head=2, tail=1):\n// [C, D, A, B]\n//       â†‘h  â†‘t\n\n// After realloc (capacity=8), need to move A,B to end:\n// [C, D, ?, ?, ?, ?, A, B]\n//       â†‘h              â†‘t\n```\n\n---\n\n### Task 3: Dequeue\n\n```c\nvoid* dequeue(WorkQueue* queue) {\n    // TODO: Check if empty\n    if (queue->count == 0) {\n        return NULL;\n    }\n    \n    // TODO: Remove item from head\n    void* obj = queue->items[queue->head];\n    queue->head = (queue->head + 1) % queue->capacity;\n    queue->count--;\n    \n    return obj;\n}\n```\n\n**Your task**: Add assertions to catch bugs:\n```c\nassert(queue->count <= queue->capacity);\nassert(queue->head < queue->capacity);\nassert(queue->tail < queue->capacity);\n```\n\n---\n\n### Task 4: Object Scanning (Conservative)\n\n```c\nvoid scan_object(GC* gc, void* obj, WorkQueue* queue) {\n    ObjectHeader* header = GET_HEADER(obj);\n    \n    #ifdef GC_DEBUG\n    printf(\"Scanning object at %p (size=%zu)\\n\", obj, header->size);\n    #endif\n    \n    // TODO: Treat object as array of potential pointers\n    void** ptr = (void**)obj;\n    size_t words = header->size / sizeof(void*);\n    \n    for (size_t i = 0; i < words; i++) {\n        void* potential = ptr[i];\n        \n        // TODO: Check if this looks like a valid pointer\n        if (is_valid_pointer(gc, potential)) {\n            #ifdef GC_DEBUG\n            printf(\"  Found pointer: %p â†’ %p\\n\", &ptr[i], potential);\n            #endif\n            \n            // TODO: Enqueue child object\n            enqueue(queue, potential);\n        }\n    }\n}\n```\n\n**Your task**: Implement `is_valid_pointer()`:\n\n```c\nbool is_valid_pointer(GC* gc, void* ptr) {\n    // TODO: Quick reject - NULL\n    if (ptr == NULL) {\n        return false;\n    }\n    \n    // TODO: Quick reject - not in heap\n    if (ptr < gc->heap_start || ptr >= gc->heap_end) {\n        return false;\n    }\n    \n    // TODO: Quick reject - not aligned\n    if ((uintptr_t)ptr % sizeof(void*) != 0) {\n        return false;\n    }\n    \n    // TODO: Expensive check - valid object header\n    // Walk free list and allocated list to confirm\n    // (Implementation depends on your heap structure)\n    \n    return true;\n}\n```\n\n**Optimization**: Maintain a **bitmap** of valid object starts:\n```c\n// 1 bit per 8-byte word in heap\nuint8_t* object_bitmap = calloc(heap_size / 8 / 8, 1);\n\n// When allocating:\nset_bit(object_bitmap, (ptr - heap_start) / 8);\n\n// When checking:\nbool is_valid_pointer(GC* gc, void* ptr) {\n    size_t offset = (ptr - gc->heap_start) / 8;\n    return get_bit(gc->object_bitmap, offset);\n}\n```\n\n---\n\n### Task 5: Main Traversal Loop\n\n```c\nvoid traverse_graph(GC* gc, WorkQueue* queue) {\n    size_t objects_marked = 0;\n    size_t bytes_marked = 0;\n    \n    while (!is_empty(queue)) {\n        void* obj = dequeue(queue);\n        \n        // TODO: Get object header\n        ObjectHeader* header = GET_HEADER(obj);\n        \n        // TODO: Skip if already marked (cycle detection)\n        if (header->marked) {\n            continue;\n        }\n        \n        // TODO: Mark object\n        header->marked = true;\n        objects_marked++;\n        bytes_marked += header->size;\n        \n        #ifdef GC_DEBUG\n        printf(\"Marked object %p (size=%zu, total=%zu)\\n\", \n               obj, header->size, objects_marked);\n        #endif\n        \n        // TODO: Scan for children\n        scan_object(gc, obj, queue);\n    }\n    \n    // TODO: Update statistics\n    gc->stats.marked_objects = objects_marked;\n    gc->stats.marked_bytes = bytes_marked;\n}\n```\n\n**Your task**: Add a **progress indicator** for large heaps:\n```c\nif (objects_marked % 10000 == 0) {\n    printf(\"Marked %zu objects (%.1f MB)...\\n\", \n           objects_marked, bytes_marked / 1024.0 / 1024.0);\n}\n```\n\n---\n\n## Visual Reference\n\n{{DIAGRAM:work-queue-states}}\n\n**Queue states during traversal**:\n```\nGraph: A â†’ B â†’ C\n       A â†’ D\n\nStep 1: Enqueue roots\nQueue: [A]\nMarked: {}\n\nStep 2: Dequeue A, mark A, enqueue children\nQueue: [B, D]\nMarked: {A}\n\nStep 3: Dequeue B, mark B, enqueue children\nQueue: [D, C]\nMarked: {A, B}\n\nStep 4: Dequeue D, mark D (no children)\nQueue: [C]\nMarked: {A, B, D}\n\nStep 5: Dequeue C, mark C (no children)\nQueue: []\nMarked: {A, B, C, D}\n\nDone!\n```\n\n---\n\n## Advanced: Tri-Color Invariant\n\n**The abstraction**:\n- **White**: Unmarked (not yet discovered)\n- **Gray**: Marked but not scanned (in work queue)\n- **Black**: Marked and scanned (fully processed)\n\n**The invariant**: No black object points to a white object.\n\n**Why it matters**: Enables **incremental GC** â€” pause between objects without losing correctness.\n\n**Implementation**:\n```c\ntypedef enum { WHITE, GRAY, BLACK } Color;\n\nvoid mark_incremental(GC* gc, size_t max_objects) {\n    size_t processed = 0;\n    \n    while (!is_empty(&gc->work_queue) && processed < max_objects) {\n        void* obj = dequeue(&gc->work_queue);\n        \n        // Object is GRAY (in queue)\n        assert(get_color(obj) == GRAY);\n        \n        // Scan children\n        for (each child) {\n            if (get_color(child) == WHITE) {\n                set_color(child, GRAY);\n                enqueue(&gc->work_queue, child);\n            }\n        }\n        \n        // Object is now BLACK (fully scanned)\n        set_color(obj, BLACK);\n        processed++;\n    }\n    \n    // Pause here! Resume later.\n}\n```\n\n---\n\n## What You've Mastered\n\nâœ… **Iterative graph traversal** using explicit work queues  \nâœ… **Cycle detection** via mark bits  \nâœ… **Conservative pointer scanning** without type information  \nâœ… **Dynamic queue management** with growth and bounds checking  \nâœ… **Debugging techniques** for infinite loops and missing objects  \nâœ… **Performance considerations** for cache locality and parallelism  \nâœ… **Tri-color abstraction** for incremental collection  \n\n---\n\n## Next Challenge\n\nNow that you can traverse the object graph, the next step is **reclaiming memory**:\n\n**[â†’ Sweep Phase](#sweep-engine)**: Walk the heap, free unmarked objects, and rebuild the free list.\n\n**Before you continue**, verify your implementation passes all tests:\n```bash\n$ ./test_mark_phase\nâœ“ Linear chain test passed\nâœ“ Cycle test passed\nâœ“ Unreachable test passed\nâœ“ Deep graph test passed (10,000 nodes)\nâœ“ Wide graph test passed (1,000 children)\nâœ“ Mark statistics test passed\n```\n\n**Pro challenge**: Implement **parallel marking** with work-stealing queues. Hint: Use `pthread` or OpenMP, and make mark bits atomic.\n\n---\n\n[â†‘ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-sweep-phase\"></div>\n\n# Sweep Phase Implementation: The Memory Reclamation Engine\n\n## The Epiphany Analogy: The Post-Party Cleanup\n\nImagine you just hosted a massive party in a warehouse. During the party, you walked around with a roll of **green stickers**, marking every piece of furniture that guests were actively using (the mark phase). Now the party's over, and you're left with a warehouse full of itemsâ€”some with green stickers, some without.\n\n**The sweep phase is your cleanup crew**:\n- Walk through the *entire warehouse* systematically (every square foot)\n- If you find furniture **without a green sticker**, haul it to the dumpster (free it)\n- If you find furniture **with a green sticker**, peel off the sticker and leave it in place (unmark for next time)\n- As you clear space, update your **\"available space\" map** so you know where to put new furniture tomorrow\n\n**Key insight**: Unlike the mark phase (which only visits *reachable* objects), the sweep phase must visit **every object in the heap**â€”both alive and dead. This is why sweep is typically O(heap_size), not O(live_objects).\n\n---\n\n## Technical Rationale: Why We Need Sweep\n\n### The Problem: Fragmented Knowledge\n\nAfter marking, we know which objects are **alive** (marked), but we don't know:\n1. **Where the dead objects are** (they weren't visited during marking)\n2. **How much memory we can reclaim** (total size of unmarked objects)\n3. **How to allocate new objects** (the free list is stale)\n\n### The Solution: Linear Heap Scan\n\nThe sweep phase performs a **single linear pass** through the entire heap:\n\n```\nHeap Layout After Mark Phase:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [A:marked] [B:unmarked] [C:marked] [D:unmarked] [E:marked] â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n  â†‘ Keep      â†‘ Free       â†‘ Keep      â†‘ Free       â†‘ Keep\n\nAfter Sweep:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [A:live] [FREE] [C:live] [FREE] [E:live]                â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n           â†“         â†“\n    Free List: [B] â†’ [D] â†’ NULL\n```\n\n**Why linear scan?** Because we don't have a \"list of all objects\"â€”objects are scattered throughout the heap. The only way to find them all is to walk memory sequentially.\n\n---\n\n## Internal Mechanics: The Sweep Algorithm\n\n### Core Data Structures\n\n```c\ntypedef struct FreeBlock {\n    size_t size;              // Size of this free block\n    struct FreeBlock* next;   // Next free block (sorted by address)\n} FreeBlock;\n\ntypedef struct {\n    FreeBlock* free_list_head;  // Start of free list\n    size_t total_free;          // Total free bytes\n    size_t largest_free;        // Largest contiguous block\n    size_t objects_freed;       // Statistics\n    size_t bytes_freed;         // Statistics\n} SweepResult;\n```\n\n### The Sweep State Machine\n\nEach object in the heap is in one of three states:\n\n```c\ntypedef enum {\n    SWEEP_STATE_ALIVE,      // Marked â†’ keep and unmark\n    SWEEP_STATE_DEAD,       // Unmarked â†’ free\n    SWEEP_STATE_FREE        // Already in free list â†’ coalesce\n} SweepState;\n```\n\n### The Algorithm (Pseudocode)\n\n```\nfunction sweep(gc):\n    current = gc.heap_start\n    free_list = NULL\n    \n    while current < gc.heap_end:\n        header = get_header(current)\n        \n        if header.marked:\n            // Object is alive\n            header.marked = false  // Unmark for next GC\n            current += sizeof(header) + header.size\n        else:\n            // Object is dead - convert to free block\n            free_block = (FreeBlock*)current\n            free_block.size = sizeof(header) + header.size\n            \n            // Try to coalesce with next block\n            next = current + free_block.size\n            while next < heap_end AND is_free(next):\n                free_block.size += get_size(next)\n                next += get_size(next)\n            \n            // Add to free list\n            free_block.next = free_list\n            free_list = free_block\n            \n            current = next\n    \n    gc.free_list = free_list\n```\n\n**Critical detail**: We must distinguish between:\n- **Dead objects** (unmarked allocations)\n- **Free blocks** (already in the free list from previous sweeps)\n\n---\n\n## The Debugging Lab: Common Sweep Bugs\n\n### Bug #1: Double-Free (Freeing Already-Free Memory)\n\n**Symptom**: Heap corruption, overlapping allocations, crashes.\n\n**Cause**: Treating a free block as a dead object.\n\n**Example**:\n```c\n// Heap state:\n// [A:marked] [FREE_BLOCK] [B:unmarked]\n\nvoid sweep(GC* gc) {\n    void* ptr = gc->heap_start;\n    \n    while (ptr < gc->heap_end) {\n        ObjectHeader* header = GET_HEADER(ptr);\n        \n        if (!header->marked) {\n            // âš ï¸ BUG: FREE_BLOCK has garbage in header->marked!\n            free_object(ptr);  // Double-free!\n        }\n        \n        ptr += sizeof(ObjectHeader) + header->size;\n    }\n}\n```\n\n**Fix #1**: Use a **magic number** to identify free blocks:\n```c\n#define FREE_BLOCK_MAGIC 0xDEADBEEF\n\ntypedef struct FreeBlock {\n    uint32_t magic;  // Always FREE_BLOCK_MAGIC\n    size_t size;\n    struct FreeBlock* next;\n} FreeBlock;\n\nbool is_free_block(void* ptr) {\n    FreeBlock* block = (FreeBlock*)ptr;\n    return block->magic == FREE_BLOCK_MAGIC;\n}\n```\n\n**Fix #2**: Use a **separate bit** in the header:\n```c\ntypedef struct {\n    size_t size : 62;\n    unsigned marked : 1;\n    unsigned is_free : 1;  // Set when added to free list\n} ObjectHeader;\n```\n\n---\n\n### Bug #2: Lost Free Blocks (Memory Leak)\n\n**Symptom**: Heap appears full even after GC, allocation fails.\n\n**Cause**: Forgetting to add freed objects to the free list.\n\n**Example**:\n```c\nvoid sweep(GC* gc) {\n    void* ptr = gc->heap_start;\n    \n    while (ptr < gc->heap_end) {\n        ObjectHeader* header = GET_HEADER(ptr);\n        \n        if (!header->marked) {\n            // âš ï¸ BUG: We mark it as free but don't link it!\n            header->is_free = true;\n            // Missing: add_to_free_list(gc, ptr);\n        }\n        \n        ptr += sizeof(ObjectHeader) + header->size;\n    }\n}\n```\n\n**Fix**: Always link freed blocks:\n```c\nif (!header->marked && !header->is_free) {\n    FreeBlock* block = (FreeBlock*)ptr;\n    block->magic = FREE_BLOCK_MAGIC;\n    block->size = sizeof(ObjectHeader) + header->size;\n    \n    // Add to front of free list\n    block->next = gc->free_list;\n    gc->free_list = block;\n    \n    gc->stats.bytes_freed += block->size;\n}\n```\n\n---\n\n### Bug #3: Fragmentation Explosion\n\n**Symptom**: Allocation fails even though total free space is sufficient.\n\n**Cause**: Not coalescing adjacent free blocks.\n\n**Example**:\n```\nBefore Sweep:\n[A:marked] [B:unmarked] [C:unmarked] [D:marked]\n\nAfter Sweep (without coalescing):\n[A:live] [FREE:64] [FREE:64] [D:live]\n\nFree List: [B:64] â†’ [C:64] â†’ NULL\n\nAllocation Request: 100 bytes\nResult: FAIL (no single block is large enough!)\n```\n\n**Fix**: Coalesce during sweep:\n```c\nvoid sweep_with_coalescing(GC* gc) {\n    void* ptr = gc->heap_start;\n    FreeBlock* free_list = NULL;\n    \n    while (ptr < gc->heap_end) {\n        ObjectHeader* header = GET_HEADER(ptr);\n        \n        if (header->marked) {\n            header->marked = false;\n            ptr += sizeof(ObjectHeader) + header->size;\n        } else {\n            // Start of a free region\n            void* free_start = ptr;\n            size_t free_size = 0;\n            \n            // Accumulate all adjacent dead objects\n            while (ptr < gc->heap_end) {\n                header = GET_HEADER(ptr);\n                if (header->marked) break;\n                \n                size_t obj_size = sizeof(ObjectHeader) + header->size;\n                free_size += obj_size;\n                ptr += obj_size;\n            }\n            \n            // Create one large free block\n            FreeBlock* block = (FreeBlock*)free_start;\n            block->magic = FREE_BLOCK_MAGIC;\n            block->size = free_size;\n            block->next = free_list;\n            free_list = block;\n        }\n    }\n    \n    gc->free_list = free_list;\n}\n```\n\n---\n\n### Bug #4: Incorrect Size Calculation\n\n**Symptom**: Heap corruption, allocations overlap, crashes.\n\n**Cause**: Forgetting to include the header size when calculating block sizes.\n\n**Example**:\n```c\nvoid sweep(GC* gc) {\n    ObjectHeader* header = GET_HEADER(ptr);\n    \n    if (!header->marked) {\n        FreeBlock* block = (FreeBlock*)ptr;\n        block->size = header->size;  // âš ï¸ BUG: Missing header size!\n        \n        // Next iteration:\n        ptr += block->size;  // Skips into middle of next object!\n    }\n}\n```\n\n**Fix**: Always account for metadata:\n```c\nsize_t total_size = sizeof(ObjectHeader) + header->size;\nblock->size = total_size;\nptr += total_size;\n```\n\n**Debugging tip**: Add assertions:\n```c\nassert(ptr >= gc->heap_start);\nassert(ptr < gc->heap_end);\nassert(total_size >= sizeof(ObjectHeader));\nassert(total_size <= gc->heap_size);\n```\n\n---\n\n## Visual Reference\n\n{{DIAGRAM:sweep-process}}\n\n**Sweep process visualization**:\n```\nInitial Heap (after mark):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [H][A:M] [H][B:U] [H][C:M] [H][D:U] [H][E:U] [H][F:M] â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n  â†‘        â†‘        â†‘        â†‘        â†‘        â†‘\n  Keep     Free     Keep     Free     Free     Keep\n\nLegend: [H]=Header, M=Marked, U=Unmarked\n\nStep 1: Scan A (marked)\nAction: Unmark, advance pointer\nResult: [H][A] ...\n\nStep 2: Scan B (unmarked)\nAction: Convert to free block\nResult: [H][A] [FREE:B] ...\n\nStep 3: Scan C (marked)\nAction: Unmark, advance pointer\nResult: [H][A] [FREE:B] [H][C] ...\n\nStep 4: Scan D (unmarked)\nAction: Start coalescing\nResult: [H][A] [FREE:B] [H][C] [FREE:D+E] ...\n                                 â†‘ Coalesced!\n\nStep 5: Scan F (marked)\nAction: Unmark, advance pointer\nResult: [H][A] [FREE:B] [H][C] [FREE:D+E] [H][F]\n\nFinal Free List (sorted by address):\n[FREE:B] â†’ [FREE:D+E] â†’ NULL\n```\n\n---\n\n## Code Scaffold: Your Implementation Tasks\n\n### Task 1: Basic Sweep Loop\n\n```c\nSweepResult sweep_heap(GC* gc) {\n    SweepResult result = {0};\n    void* ptr = gc->heap_start;\n    FreeBlock* free_list = NULL;\n    \n    #ifdef GC_DEBUG\n    printf(\"Starting sweep phase...\\n\");\n    printf(\"Heap range: %p - %p (%zu bytes)\\n\", \n           gc->heap_start, gc->heap_end, gc->heap_size);\n    #endif\n    \n    while (ptr < gc->heap_end) {\n        // TODO: Get object header\n        ObjectHeader* header = GET_HEADER(ptr);\n        \n        // TODO: Calculate total size (header + payload)\n        size_t total_size = sizeof(ObjectHeader) + header->size;\n        \n        // TODO: Check if this is already a free block\n        if (is_free_block(ptr)) {\n            // Skip free blocks from previous sweeps\n            FreeBlock* block = (FreeBlock*)ptr;\n            ptr += block->size;\n            continue;\n        }\n        \n        // TODO: Check mark bit\n        if (header->marked) {\n            // Object is alive - unmark for next GC\n            header->marked = false;\n            \n            #ifdef GC_DEBUG\n            printf(\"  Kept object at %p (size=%zu)\\n\", ptr, header->size);\n            #endif\n            \n            ptr += total_size;\n        } else {\n            // Object is dead - free it\n            #ifdef GC_DEBUG\n            printf(\"  Freeing object at %p (size=%zu)\\n\", ptr, header->size);\n            #endif\n            \n            // TODO: Convert to free block (Task 2)\n            FreeBlock* block = create_free_block(ptr, total_size);\n            \n            // TODO: Add to free list\n            block->next = free_list;\n            free_list = block;\n            \n            // TODO: Update statistics\n            result.objects_freed++;\n            result.bytes_freed += total_size;\n            \n            ptr += total_size;\n        }\n    }\n    \n    // TODO: Sort free list by address (Task 4)\n    result.free_list_head = sort_free_list(free_list);\n    \n    // TODO: Calculate statistics (Task 5)\n    calculate_free_stats(&result);\n    \n    return result;\n}\n```\n\n**Your task**: Add boundary checks:\n```c\nassert(ptr >= gc->heap_start && ptr < gc->heap_end);\nassert(total_size > 0 && total_size <= gc->heap_size);\n```\n\n---\n\n### Task 2: Free Block Creation\n\n```c\nFreeBlock* create_free_block(void* ptr, size_t size) {\n    // TODO: Validate size\n    if (size < sizeof(FreeBlock)) {\n        fprintf(stderr, \"Block too small: %zu bytes at %p\\n\", size, ptr);\n        return NULL;\n    }\n    \n    // TODO: Initialize free block\n    FreeBlock* block = (FreeBlock*)ptr;\n    block->magic = FREE_BLOCK_MAGIC;\n    block->size = size;\n    block->next = NULL;\n    \n    #ifdef GC_DEBUG\n    // Fill with debug pattern\n    uint8_t* payload = (uint8_t*)(block + 1);\n    size_t payload_size = size - sizeof(FreeBlock);\n    memset(payload, 0xDD, payload_size);  // 0xDD = \"dead data\"\n    #endif\n    \n    return block;\n}\n```\n\n**Your task**: Handle minimum block size:\n```c\n#define MIN_BLOCK_SIZE (sizeof(FreeBlock) + 16)  // 16 bytes minimum payload\n\nif (size < MIN_BLOCK_SIZE) {\n    // Too small to be useful - mark as padding\n    PaddingBlock* padding = (PaddingBlock*)ptr;\n    padding->magic = PADDING_MAGIC;\n    padding->size = size;\n    return NULL;  // Don't add to free list\n}\n```\n\n---\n\n### Task 3: Coalescing Adjacent Blocks\n\n```c\nFreeBlock* coalesce_blocks(GC* gc, void* start_ptr) {\n    void* ptr = start_ptr;\n    size_t total_size = 0;\n    \n    // TODO: Accumulate all adjacent dead/free blocks\n    while (ptr < gc->heap_end) {\n        ObjectHeader* header = GET_HEADER(ptr);\n        \n        // Check if this block can be coalesced\n        if (is_free_block(ptr)) {\n            // Already free - include it\n            FreeBlock* block = (FreeBlock*)ptr;\n            total_size += block->size;\n            ptr += block->size;\n        } else if (!header->marked) {\n            // Dead object - include it\n            size_t obj_size = sizeof(ObjectHeader) + header->size;\n            total_size += obj_size;\n            ptr += obj_size;\n        } else {\n            // Live object - stop coalescing\n            break;\n        }\n    }\n    \n    // TODO: Create one large free block\n    if (total_size > 0) {\n        return create_free_block(start_ptr, total_size);\n    }\n    \n    return NULL;\n}\n```\n\n**Your task**: Integrate coalescing into sweep:\n```c\nif (!header->marked) {\n    // Try to coalesce with following blocks\n    FreeBlock* block = coalesce_blocks(gc, ptr);\n    \n    if (block != NULL) {\n        block->next = free_list;\n        free_list = block;\n        \n        result.bytes_freed += block->size;\n        result.objects_freed++;  // Count as one coalesced block\n        \n        ptr += block->size;  // Skip entire coalesced region\n    }\n}\n```\n\n---\n\n### Task 4: Sorting the Free List\n\n**Why sort?** Sorted free lists enable:\n- **First-fit allocation** (find first block large enough)\n- **Best-fit allocation** (find smallest block that fits)\n- **Address-ordered coalescing** (merge adjacent blocks efficiently)\n\n```c\nFreeBlock* sort_free_list(FreeBlock* head) {\n    if (head == NULL || head->next == NULL) {\n        return head;  // Already sorted\n    }\n    \n    // TODO: Convert to array for sorting\n    size_t count = 0;\n    for (FreeBlock* b = head; b != NULL; b = b->next) {\n        count++;\n    }\n    \n    FreeBlock** blocks = malloc(count * sizeof(FreeBlock*));\n    size_t i = 0;\n    for (FreeBlock* b = head; b != NULL; b = b->next) {\n        blocks[i++] = b;\n    }\n    \n    // TODO: Sort by address\n    qsort(blocks, count, sizeof(FreeBlock*), compare_blocks);\n    \n    // TODO: Rebuild linked list\n    for (size_t i = 0; i < count - 1; i++) {\n        blocks[i]->next = blocks[i + 1];\n    }\n    blocks[count - 1]->next = NULL;\n    \n    FreeBlock* sorted_head = blocks[0];\n    free(blocks);\n    \n    return sorted_head;\n}\n\nint compare_blocks(const void* a, const void* b) {\n    FreeBlock* block_a = *(FreeBlock**)a;\n    FreeBlock* block_b = *(FreeBlock**)b;\n    \n    if (block_a < block_b) return -1;\n    if (block_a > block_b) return 1;\n    return 0;\n}\n```\n\n**Your task**: Optimize for already-sorted lists:\n```c\nbool is_sorted(FreeBlock* head) {\n    for (FreeBlock* b = head; b != NULL && b->next != NULL; b = b->next) {\n        if (b >= b->next) {\n            return false;  // Out of order\n        }\n    }\n    return true;\n}\n\nFreeBlock* sort_free_list(FreeBlock* head) {\n    if (is_sorted(head)) {\n        return head;  // Fast path\n    }\n    \n    // Slow path: full sort\n    // ...\n}\n```\n\n---\n\n### Task 5: Statistics Calculation\n\n```c\nvoid calculate_free_stats(SweepResult* result) {\n    result->total_free = 0;\n    result->largest_free = 0;\n    size_t block_count = 0;\n    \n    for (FreeBlock* block = result->free_list_head; \n         block != NULL; \n         block = block->next) {\n        \n        // TODO: Validate block\n        assert(block->magic == FREE_BLOCK_MAGIC);\n        assert(block->size >= sizeof(FreeBlock));\n        \n        // TODO: Accumulate totals\n        result->total_free += block->size;\n        block_count++;\n        \n        // TODO: Track largest block\n        if (block->size > result->largest_free) {\n            result->largest_free = block->size;\n        }\n    }\n    \n    #ifdef GC_DEBUG\n    printf(\"Sweep complete:\\n\");\n    printf(\"  Objects freed: %zu\\n\", result->objects_freed);\n    printf(\"  Bytes freed: %zu (%.2f MB)\\n\", \n           result->bytes_freed, \n           result->bytes_freed / 1024.0 / 1024.0);\n    printf(\"  Free blocks: %zu\\n\", block_count);\n    printf(\"  Total free: %zu (%.2f MB)\\n\", \n           result->total_free,\n           result->total_free / 1024.0 / 1024.0);\n    printf(\"  Largest block: %zu bytes\\n\", result->largest_free);\n    printf(\"  Fragmentation: %.2f%%\\n\", \n           100.0 * (1.0 - (double)result->largest_free / result->total_free));\n    #endif\n}\n```\n\n**Your task**: Add fragmentation metrics:\n```c\ntypedef struct {\n    size_t block_count;\n    size_t total_free;\n    size_t largest_free;\n    double avg_block_size;\n    double fragmentation_ratio;  // 0.0 = no fragmentation, 1.0 = worst\n} FragmentationStats;\n\nFragmentationStats analyze_fragmentation(FreeBlock* head) {\n    FragmentationStats stats = {0};\n    \n    for (FreeBlock* b = head; b != NULL; b = b->next) {\n        stats.block_count++;\n        stats.total_free += b->size;\n        if (b->size > stats.largest_free) {\n            stats.largest_free = b->size;\n        }\n    }\n    \n    if (stats.block_count > 0) {\n        stats.avg_block_size = (double)stats.total_free / stats.block_count;\n    }\n    \n    if (stats.total_free > 0) {\n        // Fragmentation = 1 - (largest / total)\n        stats.fragmentation_ratio = 1.0 - \n            ((double)stats.largest_free / stats.total_free);\n    }\n    \n    return stats;\n}\n```\n\n---\n\n## Advanced: Lazy Sweeping\n\n**The problem**: Sweeping the entire heap is slow (O(heap_size)).\n\n**The solution**: Sweep incrementally during allocation.\n\n### Lazy Sweep Algorithm\n\n```c\ntypedef struct {\n    void* sweep_ptr;        // Current position in heap\n    bool sweep_complete;    // Have we swept everything?\n} LazySweepState;\n\nvoid* allocate_with_lazy_sweep(GC* gc, size_t size) {\n    // Try to allocate from existing free list\n    void* ptr = try_allocate(gc->free_list, size);\n    if (ptr != NULL) {\n        return ptr;\n    }\n    \n    // No suitable block - sweep more of the heap\n    size_t objects_swept = 0;\n    const size_t MAX_SWEEP_PER_ALLOC = 100;\n    \n    while (objects_swept < MAX_SWEEP_PER_ALLOC && \n           !gc->lazy_sweep.sweep_complete) {\n        \n        void* sweep_ptr = gc->lazy_sweep.sweep_ptr;\n        \n        if (sweep_ptr >= gc->heap_end) {\n            gc->lazy_sweep.sweep_complete = true;\n            break;\n        }\n        \n        ObjectHeader* header = GET_HEADER(sweep_ptr);\n        size_t obj_size = sizeof(ObjectHeader) + header->size;\n        \n        if (!header->marked) {\n            // Found a dead object - free it\n            FreeBlock* block = create_free_block(sweep_ptr, obj_size);\n            add_to_free_list(gc, block);\n            \n            // Try allocation again\n            ptr = try_allocate(gc->free_list, size);\n            if (ptr != NULL) {\n                return ptr;\n            }\n        } else {\n            header->marked = false;  // Unmark for next GC\n        }\n        \n        gc->lazy_sweep.sweep_ptr += obj_size;\n        objects_swept++;\n    }\n    \n    // Still no memory - trigger full GC\n    if (ptr == NULL) {\n        full_gc(gc);\n        ptr = try_allocate(gc->free_list, size);\n    }\n    \n    return ptr;\n}\n```\n\n**Benefits**:\n- **Lower pause times** (spread work across allocations)\n- **Better cache locality** (sweep near recent allocations)\n- **Adaptive** (sweep more when memory is tight)\n\n**Tradeoffs**:\n- **Allocation is slower** (must sweep before allocating)\n- **More complex** (must track sweep state)\n- **Fragmentation** (can't coalesce until sweep reaches that region)\n\n---\n\n## Advanced: Parallel Sweeping\n\n**The challenge**: Sweep is embarrassingly parallel (each region is independent), but free list updates require synchronization.\n\n### Parallel Sweep with Thread-Local Free Lists\n\n```c\ntypedef struct {\n    FreeBlock* local_free_list;\n    size_t bytes_freed;\n    size_t objects_freed;\n} ThreadSweepResult;\n\nvoid parallel_sweep(GC* gc, int num_threads) {\n    ThreadSweepResult* results = calloc(num_threads, sizeof(ThreadSweepResult));\n    \n    // Divide heap into regions\n    size_t region_size = gc->heap_size / num_threads;\n    \n    #pragma omp parallel for\n    for (int i = 0; i < num_threads; i++) {\n        void* region_start = gc->heap_start + (i * region_size);\n        void* region_end = (i == num_threads - 1) ? \n                           gc->heap_end : \n                           region_start + region_size;\n        \n        // Sweep this region independently\n        results[i] = sweep_region(gc, region_start, region_end);\n    }\n    \n    // Merge thread-local free lists\n    FreeBlock* merged_list = NULL;\n    for (int i = 0; i < num_threads; i++) {\n        merged_list = merge_free_lists(merged_list, results[i].local_free_list);\n    }\n    \n    gc->free_list = sort_free_list(merged_list);\n    free(results);\n}\n```\n\n**Key insight**: Each thread builds its own free list, then we merge at the end. No locks needed during sweep!\n\n---\n\n## What You've Mastered\n\nâœ… **Linear heap scanning** to find all objects (alive and dead)  \nâœ… **Free block management** with magic numbers and size tracking  \nâœ… **Coalescing** to reduce fragmentation  \nâœ… **Free list sorting** for efficient allocation  \nâœ… **Statistics collection** for performance monitoring  \nâœ… **Lazy sweeping** for lower pause times  \nâœ… **Parallel sweeping** for multi-core performance  \n\n---\n\n## Testing Your Implementation\n\n```c\nvoid test_sweep_phase() {\n    GC* gc = create_gc(1024 * 1024);  // 1 MB heap\n    \n    // Allocate some objects\n    void* a = gc_alloc(gc, 64);\n    void* b = gc_alloc(gc, 128);\n    void* c = gc_alloc(gc, 64);\n    void* d = gc_alloc(gc, 256);\n    \n    // Mark only A and C as reachable\n    GET_HEADER(a)->marked = true;\n    GET_HEADER(c)->marked = true;\n    \n    // Sweep\n    SweepResult result = sweep_heap(gc);\n    \n    // Verify results\n    assert(result.objects_freed == 2);  // B and D\n    assert(result.bytes_freed == 128 + 256 + 2 * sizeof(ObjectHeader));\n    assert(result.free_list_head != NULL);\n    \n    // Verify marks were cleared\n    assert(!GET_HEADER(a)->marked);\n    assert(!GET_HEADER(c)->marked);\n    \n    // Verify we can allocate from freed space\n    void* e = gc_alloc(gc, 100);\n    assert(e != NULL);\n    \n    printf(\"âœ“ Sweep phase test passed\\n\");\n}\n```\n\n**Additional tests**:\n```bash\n$ ./test_sweep\nâœ“ Basic sweep test passed\nâœ“ Coalescing test passed (3 adjacent blocks â†’ 1)\nâœ“ Fragmentation test passed (10% fragmentation)\nâœ“ Large heap test passed (100 MB, 1M objects)\nâœ“ Lazy sweep test passed (allocation during sweep)\nâœ“ Parallel sweep test passed (4 threads, 2x speedup)\n```\n\n---\n\n## Performance Benchmarks\n\n**Expected performance** (1 GHz CPU, 1 MB heap):\n\n| Heap Occupancy | Objects | Sweep Time | Throughput |\n|----------------|---------|------------|------------|\n| 10% (sparse)   | 1,600   | 0.5 ms     | 2 GB/s     |\n| 50% (typical)  | 8,000   | 2.0 ms     | 500 MB/s   |\n| 90% (dense)    | 14,400  | 4.0 ms     | 250 MB/s   |\n\n**Optimization tips**:\n1. **Cache-friendly scanning**: Process 64-byte cache lines at a time\n2. **Prefetching**: `__builtin_prefetch(ptr + 64)` before accessing\n3. **SIMD**: Use vector instructions to check multiple mark bits\n4. **Huge pages**: Reduce TLB misses for large heaps\n\n---\n\n## Next Challenge\n\nYou've now implemented a complete **mark-and-sweep garbage collector**! ğŸ‰\n\n**What's next?**\n\n1. **[â†’ Allocation Strategies](#allocation-strategies)**: Implement first-fit, best-fit, and segregated free lists\n2. **[â†’ Generational GC](#generational-gc)**: Optimize for \"most objects die young\"\n3. **[â†’ Compaction](#compaction)**: Eliminate fragmentation by moving objects\n4. **[â†’ Concurrent GC](#concurrent-gc)**: Collect garbage while the program runs\n\n**Before you continue**, verify your full GC works end-to-end:\n```bash\n$ ./test_full_gc\nâœ“ Root scanning test passed\nâœ“ Mark phase test passed\nâœ“ Sweep phase test passed\nâœ“ Full GC cycle test passed\nâœ“ Multiple GC cycles test passed (10 cycles)\nâœ“ Stress test passed (1M allocations, 100 GC cycles)\n```\n\n---\n\n[â†‘ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-gc-trigger\"></div>\n\n# Collection Trigger Logic\n\n## Epiphany Analogy: The Smart Thermostat\n\nImagine your home's heating system. A **dumb thermostat** turns on the heat at a fixed temperature (say, 68Â°F) every time. But a **smart thermostat** learns your patterns:\n\n- It knows you wake up at 7 AM, so it pre-heats at 6:45 AM\n- It detects when you're away and delays heating\n- It monitors how quickly the house cools down and adjusts timing\n- It triggers emergency heating if temperature drops dangerously low\n\n**Your GC trigger logic is the smart thermostat for memory**. It must answer: *\"When should I pause the world and collect garbage?\"*\n\nToo aggressive â†’ wasted CPU cycles collecting when memory is plentiful  \nToo passive â†’ out-of-memory crashes when allocation spikes  \n\nThe art is in **predicting memory pressure** before it becomes critical.\n\n---\n\n## Technical Rationale: Why Trigger Logic Matters\n\n### The Fundamental Tradeoff\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  GC Frequency vs. Performance                   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                                 â”‚\nâ”‚  Frequent GC:                                   â”‚\nâ”‚    âœ“ Low memory footprint                       â”‚\nâ”‚    âœ“ Predictable pauses                         â”‚\nâ”‚    âœ— High CPU overhead (50%+ wasted)            â”‚\nâ”‚    âœ— Poor cache locality                        â”‚\nâ”‚                                                 â”‚\nâ”‚  Rare GC:                                       â”‚\nâ”‚    âœ“ Low CPU overhead (5-10%)                   â”‚\nâ”‚    âœ“ Better cache locality                      â”‚\nâ”‚    âœ— Large memory footprint                     â”‚\nâ”‚    âœ— Long pause times (100ms+)                  â”‚\nâ”‚    âœ— Risk of OOM crashes                        â”‚\nâ”‚                                                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**The goal**: Trigger GC *just before* memory becomes critically low, but *not so often* that we waste CPU.\n\n### Real-World Consequences\n\n**Case Study: Web Server**\n- **Too frequent GC**: 200 req/sec â†’ 120 req/sec (40% throughput loss)\n- **Too rare GC**: Sudden 500ms pause â†’ dropped connections\n- **Optimal GC**: Trigger during request gaps, maintain 195 req/sec\n\n**Case Study: Game Engine**\n- **Too frequent GC**: 60 FPS â†’ 45 FPS (stuttering)\n- **Too rare GC**: 200ms pause â†’ visible frame drop\n- **Optimal GC**: Trigger during level loads, maintain 60 FPS\n\n---\n\n## Internal Mechanics: Trigger Heuristics\n\n### Strategy 1: Heap Occupancy Threshold\n\n**The simplest approach**: Trigger GC when heap is X% full.\n\n```c\ntypedef struct {\n    size_t heap_size;           // Total heap capacity\n    size_t bytes_allocated;     // Currently allocated\n    size_t bytes_freed;         // Available in free list\n    double gc_threshold;        // Trigger at this occupancy (0.0-1.0)\n} HeapStats;\n\nbool should_trigger_gc_simple(HeapStats* stats) {\n    size_t bytes_used = stats->bytes_allocated - stats->bytes_freed;\n    double occupancy = (double)bytes_used / stats->heap_size;\n    \n    return occupancy >= stats->gc_threshold;\n}\n```\n\n**Example**:\n```\nHeap: 10 MB\nThreshold: 0.75 (75%)\nAllocated: 8 MB\nFreed: 1 MB\nUsed: 7 MB (70%) â†’ No GC yet\n\n[Allocate 1 MB more]\nUsed: 8 MB (80%) â†’ TRIGGER GC!\n```\n\n**Quick Breakdown: Occupancy**\n> **Occupancy** = (Allocated - Freed) / Total Heap Size  \n> It's the percentage of heap that's actually in use (not counting free blocks).\n\n**Pros**:\n- âœ… Simple to implement\n- âœ… Predictable memory usage\n- âœ… Works well for steady-state workloads\n\n**Cons**:\n- âŒ Ignores allocation rate (fast allocators hit threshold quickly)\n- âŒ Ignores survival rate (if 90% survives, GC doesn't help much)\n- âŒ Fixed threshold doesn't adapt to workload\n\n---\n\n### Strategy 2: Allocation Rate Tracking\n\n**The insight**: If you're allocating 1 MB/sec, you'll run out of memory faster than if you're allocating 1 KB/sec.\n\n```c\ntypedef struct {\n    size_t bytes_allocated_since_gc;\n    uint64_t time_since_gc_ms;\n    size_t allocation_threshold;  // Trigger after this many bytes\n} AllocationTracker;\n\nbool should_trigger_gc_allocation(AllocationTracker* tracker) {\n    return tracker->bytes_allocated_since_gc >= tracker->allocation_threshold;\n}\n\nvoid* gc_alloc_with_tracking(GC* gc, size_t size) {\n    gc->tracker.bytes_allocated_since_gc += size;\n    \n    if (should_trigger_gc_allocation(&gc->tracker)) {\n        gc_collect(gc);\n        gc->tracker.bytes_allocated_since_gc = 0;\n        gc->tracker.time_since_gc_ms = get_time_ms();\n    }\n    \n    return allocate(gc, size);\n}\n```\n\n**Example**:\n```\nThreshold: 5 MB allocated â†’ trigger GC\nAllocation pattern:\n  T=0ms:   Allocate 1 MB (total: 1 MB)\n  T=10ms:  Allocate 2 MB (total: 3 MB)\n  T=20ms:  Allocate 3 MB (total: 6 MB) â†’ TRIGGER GC!\n```\n\n**Adaptive threshold**:\n```c\nvoid adjust_allocation_threshold(GC* gc, SweepResult* result) {\n    // If we freed a lot, increase threshold (GC was effective)\n    if (result->bytes_freed > gc->tracker.allocation_threshold * 0.5) {\n        gc->tracker.allocation_threshold *= 1.5;\n    }\n    // If we freed little, decrease threshold (GC wasn't effective)\n    else if (result->bytes_freed < gc->tracker.allocation_threshold * 0.1) {\n        gc->tracker.allocation_threshold *= 0.75;\n    }\n    \n    // Clamp to reasonable bounds\n    if (gc->tracker.allocation_threshold < 1024 * 1024) {\n        gc->tracker.allocation_threshold = 1024 * 1024;  // Min 1 MB\n    }\n    if (gc->tracker.allocation_threshold > gc->heap_size / 2) {\n        gc->tracker.allocation_threshold = gc->heap_size / 2;  // Max 50% of heap\n    }\n}\n```\n\n**Pros**:\n- âœ… Adapts to allocation rate\n- âœ… Prevents sudden OOM from allocation bursts\n- âœ… Can learn optimal threshold over time\n\n**Cons**:\n- âŒ Doesn't account for object lifetimes\n- âŒ Can trigger too often if objects die quickly\n- âŒ Requires tuning of initial threshold\n\n---\n\n### Strategy 3: Survival Rate Prediction\n\n**The insight**: If 90% of objects survive GC, collecting garbage doesn't help much. Wait until more objects die.\n\n```c\ntypedef struct {\n    size_t bytes_before_gc;\n    size_t bytes_after_gc;\n    double survival_rate;       // Fraction that survived last GC\n    double target_survival;     // Trigger when survival drops below this\n} SurvivalTracker;\n\nvoid update_survival_rate(SurvivalTracker* tracker, SweepResult* result) {\n    tracker->bytes_after_gc = tracker->bytes_before_gc - result->bytes_freed;\n    tracker->survival_rate = (double)tracker->bytes_after_gc / tracker->bytes_before_gc;\n}\n\nbool should_trigger_gc_survival(GC* gc) {\n    // If last GC had high survival rate, wait longer before next GC\n    if (gc->survival.survival_rate > 0.8) {\n        // Need to allocate 2x heap size before triggering\n        return gc->tracker.bytes_allocated_since_gc > gc->heap_size * 2;\n    }\n    // If last GC had low survival rate, trigger sooner\n    else if (gc->survival.survival_rate < 0.3) {\n        // Trigger after allocating 0.5x heap size\n        return gc->tracker.bytes_allocated_since_gc > gc->heap_size / 2;\n    }\n    // Medium survival rate - use standard threshold\n    else {\n        return gc->tracker.bytes_allocated_since_gc > gc->heap_size;\n    }\n}\n```\n\n**Example**:\n```\nGC #1: 10 MB before â†’ 9 MB after (90% survival)\n  â†’ High survival! Wait longer before next GC\n  â†’ Threshold: 20 MB allocated\n\nGC #2: 10 MB before â†’ 3 MB after (30% survival)\n  â†’ Low survival! Trigger GC sooner\n  â†’ Threshold: 5 MB allocated\n```\n\n**Pros**:\n- âœ… Avoids wasteful GC when objects are long-lived\n- âœ… Triggers more often when objects are dying (GC is effective)\n- âœ… Adapts to workload phase changes\n\n**Cons**:\n- âŒ Requires at least one GC to establish baseline\n- âŒ Can be fooled by sudden workload changes\n- âŒ Complex to tune\n\n---\n\n### Strategy 4: Hybrid Multi-Factor Heuristic\n\n**The production approach**: Combine multiple signals.\n\n```c\ntypedef struct {\n    // Heap pressure\n    double heap_occupancy;           // 0.0 - 1.0\n    double heap_occupancy_threshold; // Trigger at 0.75\n    \n    // Allocation rate\n    size_t bytes_allocated_since_gc;\n    size_t allocation_threshold;\n    \n    // Survival rate\n    double survival_rate;\n    double target_survival;\n    \n    // Time-based\n    uint64_t time_since_gc_ms;\n    uint64_t max_time_between_gc_ms; // Force GC after this time\n    \n    // Fragmentation\n    double fragmentation_ratio;\n    double fragmentation_threshold;  // Trigger at 0.5\n    \n    // Allocation failure\n    bool last_allocation_failed;\n} GCTriggerState;\n\nbool should_trigger_gc(GC* gc) {\n    GCTriggerState* state = &gc->trigger_state;\n    \n    // CRITICAL: Last allocation failed - MUST collect now\n    if (state->last_allocation_failed) {\n        return true;\n    }\n    \n    // URGENT: Heap is critically full\n    if (state->heap_occupancy >= 0.95) {\n        return true;\n    }\n    \n    // HIGH PRIORITY: Multiple factors indicate pressure\n    int pressure_signals = 0;\n    \n    if (state->heap_occupancy >= state->heap_occupancy_threshold) {\n        pressure_signals++;\n    }\n    \n    if (state->bytes_allocated_since_gc >= state->allocation_threshold) {\n        pressure_signals++;\n    }\n    \n    if (state->fragmentation_ratio >= state->fragmentation_threshold) {\n        pressure_signals++;\n    }\n    \n    if (state->time_since_gc_ms >= state->max_time_between_gc_ms) {\n        pressure_signals++;\n    }\n    \n    // Trigger if 2+ signals indicate pressure\n    if (pressure_signals >= 2) {\n        return true;\n    }\n    \n    // MEDIUM PRIORITY: High survival rate but heap is filling\n    if (state->survival_rate > 0.8 && state->heap_occupancy > 0.6) {\n        // Objects aren't dying - we're accumulating live data\n        // Trigger GC to at least defragment\n        return true;\n    }\n    \n    // LOW PRIORITY: Periodic GC to prevent long pauses\n    if (state->time_since_gc_ms >= state->max_time_between_gc_ms * 2) {\n        return true;\n    }\n    \n    return false;\n}\n```\n\n**Decision tree visualization**:\n\n{{DIAGRAM:gc-trigger-decision-tree}}\n\n```\n                    Allocation Request\n                           |\n                           v\n                  Last alloc failed?\n                    /           \\\n                  YES            NO\n                   |              |\n              TRIGGER GC          v\n                           Heap > 95% full?\n                            /           \\\n                          YES            NO\n                           |              |\n                      TRIGGER GC          v\n                                   Count pressure signals:\n                                   - Heap occupancy high?\n                                   - Allocated too much?\n                                   - Fragmentation high?\n                                   - Too much time passed?\n                                          |\n                                          v\n                                   2+ signals?\n                                    /         \\\n                                  YES          NO\n                                   |            |\n                              TRIGGER GC    Continue\n```\n\n---\n\n## Visual Reference\n\n{{DIAGRAM:gc-trigger-timeline}}\n\n```\nTime â†’\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nHeap\nUsage\n  100% â”¤                                    â•­â”€ OOM! âœ—\n       â”‚                                â•­â”€â”€â”€â•¯\n   75% â”¤                            â•­â”€â”€â”€â•¯     â† Threshold\n       â”‚                        â•­â”€â”€â”€â•¯\n   50% â”¤                    â•­â”€â”€â”€â•¯\n       â”‚                â•­â”€â”€â”€â•¯\n   25% â”¤            â•­â”€â”€â”€â•¯\n       â”‚        â•­â”€â”€â”€â•¯\n    0% â”¼â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n       0ms    100ms   200ms   300ms   400ms   500ms\n\nWITHOUT GC TRIGGER: Crash at 500ms\n\n\nWITH GC TRIGGER (75% threshold):\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  100% â”¤\n       â”‚\n   75% â”¤            â•­â”€GC!â”€â•®         â•­â”€GC!â”€â•®\n       â”‚        â•­â”€â”€â”€â•¯     â•°â”€â”€â”€â•® â•­â”€â”€â”€â•¯     â•°â”€â”€â”€â•®\n   50% â”¤    â•­â”€â”€â”€â•¯             â•°â”€â•¯             â•°â”€â”€â”€â•®\n       â”‚â•­â”€â”€â”€â•¯                                      â•°â”€â”€â”€â•®\n   25% â”¤â•¯                                              â•°â”€â”€â”€\n       â”‚\n    0% â”¼\n       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n       0ms    100ms   200ms   300ms   400ms   500ms\n\nWITH GC TRIGGER: Stable operation, no crash\n```\n\n---\n\n## The Debugging Lab: Common Trigger Bugs\n\n### Bug 1: Trigger Too Late (OOM Crash)\n\n**Symptom**:\n```\nAllocating 1024 bytes...\nERROR: Out of memory!\nHeap occupancy: 99.8%\nLast GC: 5000ms ago\n```\n\n**Root cause**: Threshold too high or not checking occupancy.\n\n**Fix**:\n```c\n// BEFORE: Only checking allocation count\nif (bytes_allocated > threshold) {\n    gc_collect();\n}\n\n// AFTER: Also check heap occupancy\nif (bytes_allocated > threshold || heap_occupancy > 0.75) {\n    gc_collect();\n}\n```\n\n**Prevention**:\n```c\n// Add safety margin\nconst double CRITICAL_THRESHOLD = 0.95;\nconst double SAFE_THRESHOLD = 0.75;\n\nif (heap_occupancy >= CRITICAL_THRESHOLD) {\n    // Emergency GC - must succeed or crash gracefully\n    gc_collect(gc);\n    if (heap_occupancy >= CRITICAL_THRESHOLD) {\n        fprintf(stderr, \"FATAL: Out of memory after GC\\n\");\n        abort();\n    }\n}\n```\n\n---\n\n### Bug 2: Trigger Too Often (Thrashing)\n\n**Symptom**:\n```\nGC #1: Freed 100 KB (10% of heap)\nGC #2: Freed 50 KB (5% of heap)\nGC #3: Freed 20 KB (2% of heap)\nGC #4: Freed 10 KB (1% of heap)\n...\nCPU usage: 90% (80% in GC!)\n```\n\n**Root cause**: Triggering GC when survival rate is high.\n\n**Fix**:\n```c\nvoid gc_collect(GC* gc) {\n    size_t before = gc->bytes_allocated;\n    \n    mark_phase(gc);\n    SweepResult result = sweep_phase(gc);\n    \n    size_t after = gc->bytes_allocated - result.bytes_freed;\n    double survival_rate = (double)after / before;\n    \n    // If GC didn't help much, increase threshold\n    if (survival_rate > 0.9) {\n        gc->trigger_state.allocation_threshold *= 2.0;\n        printf(\"WARNING: High survival rate (%.1f%%), \"\n               \"increasing threshold to %zu bytes\\n\",\n               survival_rate * 100, \n               gc->trigger_state.allocation_threshold);\n    }\n}\n```\n\n---\n\n### Bug 3: Ignoring Fragmentation\n\n**Symptom**:\n```\nAllocation failed: No block large enough\nHeap occupancy: 45%\nFree memory: 5.5 MB\nLargest free block: 64 KB\nRequested: 1 MB\n```\n\n**Root cause**: Heap is fragmented, but trigger only checks occupancy.\n\n**Fix**:\n```c\nbool should_trigger_gc(GC* gc) {\n    // Check occupancy\n    if (gc->heap_occupancy > 0.75) {\n        return true;\n    }\n    \n    // Check fragmentation\n    FragmentationStats stats = analyze_fragmentation(gc->free_list);\n    if (stats.fragmentation_ratio > 0.5) {\n        // More than 50% fragmented - trigger GC to compact\n        return true;\n    }\n    \n    // Check if largest block is too small\n    size_t avg_allocation = gc->total_allocated / gc->allocation_count;\n    if (stats.largest_free < avg_allocation * 2) {\n        // Can't satisfy typical allocations - trigger GC\n        return true;\n    }\n    \n    return false;\n}\n```\n\n---\n\n### Bug 4: Not Adapting to Workload Changes\n\n**Symptom**:\n```\nPhase 1 (startup): GC every 100ms (good)\nPhase 2 (steady state): GC every 10ms (too often!)\nPhase 3 (shutdown): GC every 500ms (too rare!)\n```\n\n**Root cause**: Fixed threshold doesn't adapt.\n\n**Fix**:\n```c\ntypedef struct {\n    double threshold;\n    double min_threshold;\n    double max_threshold;\n    size_t gc_count;\n    uint64_t total_gc_time_ms;\n} AdaptiveThreshold;\n\nvoid adjust_threshold_after_gc(GC* gc, uint64_t gc_duration_ms) {\n    AdaptiveThreshold* t = &gc->adaptive;\n    \n    t->gc_count++;\n    t->total_gc_time_ms += gc_duration_ms;\n    \n    double avg_gc_time = (double)t->total_gc_time_ms / t->gc_count;\n    double gc_overhead = avg_gc_time / (avg_gc_time + 100.0);  // Assume 100ms between GCs\n    \n    // Target: 5% GC overhead\n    const double TARGET_OVERHEAD = 0.05;\n    \n    if (gc_overhead > TARGET_OVERHEAD * 1.5) {\n        // GC is taking too much time - increase threshold\n        t->threshold *= 1.2;\n    } else if (gc_overhead < TARGET_OVERHEAD * 0.5) {\n        // GC is cheap - can afford to run more often\n        t->threshold *= 0.9;\n    }\n    \n    // Clamp\n    if (t->threshold < t->min_threshold) t->threshold = t->min_threshold;\n    if (t->threshold > t->max_threshold) t->threshold = t->max_threshold;\n}\n```\n\n---\n\n## Code Scaffold: Your Task\n\nImplement a production-grade GC trigger system:\n\n```c\ntypedef struct {\n    // Heap metrics\n    size_t heap_size;\n    size_t bytes_allocated;\n    size_t bytes_freed;\n    \n    // Allocation tracking\n    size_t bytes_allocated_since_gc;\n    size_t allocation_count_since_gc;\n    uint64_t time_since_gc_ms;\n    \n    // Historical data\n    double survival_rate;\n    double fragmentation_ratio;\n    \n    // Thresholds (adaptive)\n    double heap_occupancy_threshold;\n    size_t allocation_threshold;\n    uint64_t max_time_between_gc_ms;\n    \n    // Statistics\n    size_t total_gc_count;\n    uint64_t total_gc_time_ms;\n    size_t total_bytes_allocated;\n    \n} GCTriggerState;\n\n// TODO: Implement this function\nbool should_trigger_gc(GC* gc) {\n    GCTriggerState* state = &gc->trigger_state;\n    \n    // TASK 1: Calculate current heap occupancy\n    // Hint: occupancy = (allocated - freed) / heap_size\n    double occupancy = 0.0;  // TODO\n    \n    // TASK 2: Check critical conditions (MUST trigger)\n    // - Last allocation failed\n    // - Heap > 95% full\n    // - No free blocks available\n    if (/* TODO */) {\n        return true;\n    }\n    \n    // TASK 3: Count pressure signals\n    int pressure_signals = 0;\n    \n    // Signal 1: Heap occupancy above threshold\n    if (/* TODO */) {\n        pressure_signals++;\n    }\n    \n    // Signal 2: Allocated too much since last GC\n    if (/* TODO */) {\n        pressure_signals++;\n    }\n    \n    // Signal 3: Too much time passed\n    if (/* TODO */) {\n        pressure_signals++;\n    }\n    \n    // Signal 4: Fragmentation too high\n    if (/* TODO */) {\n        pressure_signals++;\n    }\n    \n    // TASK 4: Trigger if multiple signals indicate pressure\n    if (pressure_signals >= 2) {\n        return true;\n    }\n    \n    // TASK 5: Check for special cases\n    // - High survival rate but heap filling (accumulating live data)\n    // - Periodic GC to prevent long pauses\n    if (/* TODO */) {\n        return true;\n    }\n    \n    return false;\n}\n\n// TODO: Implement adaptive threshold adjustment\nvoid adjust_thresholds_after_gc(GC* gc, SweepResult* result, uint64_t gc_duration_ms) {\n    GCTriggerState* state = &gc->trigger_state;\n    \n    // TASK 1: Update survival rate\n    // survival_rate = bytes_after / bytes_before\n    double bytes_before = state->bytes_allocated;\n    double bytes_after = bytes_before - result->bytes_freed;\n    state->survival_rate = /* TODO */;\n    \n    // TASK 2: Update fragmentation ratio\n    FragmentationStats frag = analyze_fragmentation(gc->free_list);\n    state->fragmentation_ratio = frag.fragmentation_ratio;\n    \n    // TASK 3: Adjust allocation threshold based on survival rate\n    if (state->survival_rate > 0.8) {\n        // High survival - increase threshold (wait longer)\n        state->allocation_threshold *= /* TODO */;\n    } else if (state->survival_rate < 0.3) {\n        // Low survival - decrease threshold (trigger sooner)\n        state->allocation_threshold *= /* TODO */;\n    }\n    \n    // TASK 4: Adjust based on GC overhead\n    state->total_gc_count++;\n    state->total_gc_time_ms += gc_duration_ms;\n    \n    double avg_gc_time = (double)state->total_gc_time_ms / state->total_gc_count;\n    double time_between_gcs = (double)state->time_since_gc_ms;\n    double gc_overhead = avg_gc_time / (avg_gc_time + time_between_gcs);\n    \n    const double TARGET_OVERHEAD = 0.05;  // 5%\n    \n    if (gc_overhead > TARGET_OVERHEAD * 1.5) {\n        // GC overhead too high - trigger less often\n        state->heap_occupancy_threshold *= /* TODO */;\n    } else if (gc_overhead < TARGET_OVERHEAD * 0.5) {\n        // GC overhead low - can trigger more often\n        state->heap_occupancy_threshold *= /* TODO */;\n    }\n    \n    // TASK 5: Clamp thresholds to reasonable bounds\n    if (state->heap_occupancy_threshold < 0.5) {\n        state->heap_occupancy_threshold = 0.5;\n    }\n    if (state->heap_occupancy_threshold > 0.9) {\n        state->heap_occupancy_threshold = 0.9;\n    }\n    \n    if (state->allocation_threshold < gc->heap_size / 4) {\n        state->allocation_threshold = gc->heap_size / 4;\n    }\n    if (state->allocation_threshold > gc->heap_size * 2) {\n        state->allocation_threshold = gc->heap_size * 2;\n    }\n    \n    // TASK 6: Reset counters\n    state->bytes_allocated_since_gc = 0;\n    state->allocation_count_since_gc = 0;\n    state->time_since_gc_ms = 0;\n}\n\n// TODO: Implement allocation tracking\nvoid* gc_alloc_with_trigger(GC* gc, size_t size) {\n    // TASK 1: Update allocation tracking\n    gc->trigger_state.bytes_allocated_since_gc += size;\n    gc->trigger_state.allocation_count_since_gc++;\n    gc->trigger_state.total_bytes_allocated += size;\n    \n    // TASK 2: Check if we should trigger GC\n    if (should_trigger_gc(gc)) {\n        uint64_t start_time = get_time_ms();\n        \n        // Run GC\n        mark_phase(gc);\n        SweepResult result = sweep_phase(gc);\n        \n        uint64_t gc_duration = get_time_ms() - start_time;\n        \n        // Adjust thresholds based on results\n        adjust_thresholds_after_gc(gc, &result, gc_duration);\n        \n        #ifdef GC_DEBUG\n        printf(\"GC triggered: freed %zu bytes (%.1f%% survival) in %llu ms\\n\",\n               result.bytes_freed,\n               gc->trigger_state.survival_rate * 100,\n               gc_duration);\n        #endif\n    }\n    \n    // TASK 3: Try to allocate\n    void* ptr = try_allocate(gc->free_list, size);\n    \n    // TASK 4: If allocation failed, force GC and try again\n    if (ptr == NULL) {\n        gc->trigger_state.last_allocation_failed = true;\n        \n        // Force GC\n        mark_phase(gc);\n        sweep_phase(gc);\n        \n        // Try again\n        ptr = try_allocate(gc->free_list, size);\n        \n        if (ptr == NULL) {\n            fprintf(stderr, \"FATAL: Out of memory after GC\\n\");\n            fprintf(stderr, \"  Requested: %zu bytes\\n\", size);\n            fprintf(stderr, \"  Heap size: %zu bytes\\n\", gc->heap_size);\n            fprintf(stderr, \"  Allocated: %zu bytes\\n\", gc->trigger_state.bytes_allocated);\n            fprintf(stderr, \"  Free: %zu bytes\\n\", gc->trigger_state.bytes_freed);\n            abort();\n        }\n        \n        gc->trigger_state.last_allocation_failed = false;\n    }\n    \n    return ptr;\n}\n```\n\n---\n\n## Advanced: Predictive Triggering\n\n**The cutting edge**: Use machine learning to predict optimal GC timing.\n\n```c\ntypedef struct {\n    // Historical allocation patterns\n    size_t allocation_history[100];  // Last 100 allocation sizes\n    uint64_t allocation_times[100];  // Timestamps\n    size_t history_index;\n    \n    // Predicted values\n    size_t predicted_next_allocation;\n    uint64_t predicted_time_to_oom;\n    \n} PredictiveModel;\n\nvoid update_prediction(PredictiveModel* model, size_t allocation_size) {\n    // Add to history\n    model->allocation_history[model->history_index] = allocation_size;\n    model->allocation_times[model->history_index] = get_time_ms();\n    model->history_index = (model->history_index + 1) % 100;\n    \n    // Calculate moving average\n    size_t sum = 0;\n    for (int i = 0; i < 100; i++) {\n        sum += model->allocation_history[i];\n    }\n    model->predicted_next_allocation = sum / 100;\n    \n    // Calculate allocation rate (bytes/ms)\n    uint64_t time_span = model->allocation_times[99] - model->allocation_times[0];\n    if (time_span > 0) {\n        double allocation_rate = (double)sum / time_span;\n        \n        // Predict time until OOM\n        size_t free_space = /* calculate free space */;\n        model->predicted_time_to_oom = (uint64_t)(free_space / allocation_rate);\n    }\n}\n\nbool should_trigger_gc_predictive(GC* gc) {\n    PredictiveModel* model = &gc->predictive_model;\n    \n    // If we predict OOM in next 100ms, trigger GC now\n    if (model->predicted_time_to_oom < 100) {\n        return true;\n    }\n    \n    // If next allocation likely won't fit, trigger GC now\n    FragmentationStats stats = analyze_fragmentation(gc->free_list);\n    if (model->predicted_next_allocation > stats.largest_free) {\n        return true;\n    }\n    \n    return false;\n}\n```\n\n**Benefits**:\n- Trigger GC *before* allocation fails\n- Smooth out GC pauses by predicting quiet periods\n- Adapt to complex allocation patterns\n\n**Tradeoffs**:\n- Requires significant history to be accurate\n- Can be fooled by sudden workload changes\n- More complex to implement and debug\n\n---\n\n## Testing Your Implementation\n\n```c\nvoid test_gc_trigger() {\n    GC* gc = create_gc(1024 * 1024);  // 1 MB heap\n    gc->trigger_state.heap_occupancy_threshold = 0.75;\n    gc->trigger_state.allocation_threshold = 512 * 1024;  // 512 KB\n    \n    // Test 1: Trigger on heap occupancy\n    for (int i = 0; i < 100; i++) {\n        gc_alloc_with_trigger(gc, 10 * 1024);  // 10 KB each\n    }\n    // Should have triggered GC when heap hit 75%\n    assert(gc->trigger_state.total_gc_count > 0);\n    \n    // Test 2: Trigger on allocation threshold\n    gc->trigger_state.total_gc_count = 0;\n    gc_alloc_with_trigger(gc, 600 * 1024);  // 600 KB (exceeds threshold)\n    assert(gc->trigger_state.total_gc_count > 0);\n    \n    // Test 3: Adaptive threshold adjustment\n    double initial_threshold = gc->trigger_state.heap_occupancy_threshold;\n    \n    // Simulate high survival rate\n    gc->trigger_state.survival_rate = 0.95;\n    adjust_thresholds_after_gc(gc, &(SweepResult){0}, 10);\n    \n    // Threshold should increase (wait longer before next GC)\n    assert(gc->trigger_state.heap_occupancy_threshold > initial_threshold);\n    \n    printf(\"âœ“ GC trigger tests passed\\n\");\n}\n\nvoid test_gc_trigger_stress() {\n    GC* gc = create_gc(10 * 1024 * 1024);  // 10 MB heap\n    \n    // Allocate aggressively\n    for (int i = 0; i < 10000; i++) {\n        size_t size = (rand() % 1024) + 1;  // 1-1024 bytes\n        void* ptr = gc_alloc_with_trigger(gc, size);\n        assert(ptr != NULL);\n        \n        // Randomly free some objects\n        if (rand() % 10 == 0) {\n            // Mark as dead (in real code, this happens naturally)\n            GET_HEADER(ptr)->marked = false;\n        }\n    }\n    \n    // Should have triggered multiple GCs\n    assert(gc->trigger_state.total_gc_count > 5);\n    \n    // Should never have crashed\n    printf(\"âœ“ GC trigger stress test passed (%zu GCs)\\n\", \n           gc->trigger_state.total_gc_count);\n}\n```\n\n---\n\n## Performance Tuning Guide\n\n### Tuning for Throughput (Batch Processing)\n\n**Goal**: Minimize GC overhead, maximize work done.\n\n```c\n// Aggressive thresholds - trigger rarely\ngc->trigger_state.heap_occupancy_threshold = 0.90;  // 90%\ngc->trigger_state.allocation_threshold = gc->heap_size * 2;  // 2x heap\ngc->trigger_state.max_time_between_gc_ms = 10000;  // 10 seconds\n```\n\n**Expected**: 2-5% GC overhead, large memory footprint.\n\n---\n\n### Tuning for Latency (Interactive Applications)\n\n**Goal**: Minimize pause times, keep GC predictable.\n\n```c\n// Conservative thresholds - trigger often\ngc->trigger_state.heap_occupancy_threshold = 0.60;  // 60%\ngc->trigger_state.allocation_threshold = gc->heap_size / 2;  // 0.5x heap\ngc->trigger_state.max_time_between_gc_ms = 100;  // 100ms\n```\n\n**Expected**: 10-15% GC overhead, small pauses (1-5ms).\n\n---\n\n### Tuning for Memory-Constrained Systems\n\n**Goal**: Minimize memory footprint, avoid OOM.\n\n```c\n// Very conservative thresholds\ngc->trigger_state.heap_occupancy_threshold = 0.50;  // 50%\ngc->trigger_state.allocation_threshold = gc->heap_size / 4;  // 0.25x heap\ngc->trigger_state.max_time_between_gc_ms = 50;  // 50ms\n```\n\n**Expected**: 20-30% GC overhead, but never OOM.\n\n---\n\n## What You've Mastered\n\nâœ… **Heap occupancy thresholds** for simple triggering  \nâœ… **Allocation rate tracking** for adaptive triggering  \nâœ… **Survival rate prediction** to avoid wasteful GC  \nâœ… **Multi-factor heuristics** for production systems  \nâœ… **Adaptive threshold adjustment** for changing workloads  \nâœ… **Predictive triggering** using historical data  \nâœ… **Performance tuning** for different workload types  \n\n---\n\n## Next Steps\n\n**You now have a complete mark-and-sweep garbage collector with intelligent triggering!** ğŸ‰\n\n**What's next?**\n\n1. **[â†’ Generational GC](#generational-gc)**: Optimize for \"most objects die young\"\n2. **[â†’ Incremental GC](#incremental-gc)**: Spread GC work across multiple allocations\n3. **[â†’ Concurrent GC](#concurrent-gc)**: Collect garbage while program runs\n4. **[â†’ Compacting GC](#compacting-gc)**: Eliminate fragmentation by moving objects\n\n**Before continuing**, verify your trigger logic works under stress:\n\n```bash\n$ ./test_gc_trigger\nâœ“ Basic trigger test passed\nâœ“ Occupancy trigger test passed\nâœ“ Allocation trigger test passed\nâœ“ Adaptive threshold test passed\nâœ“ Stress test passed (47 GCs, 0 OOM)\nâœ“ Throughput test: 95% efficiency\nâœ“ Latency test: max pause 3.2ms\n```\n\n---\n\n[â†‘ Back to System Map](#satellite-map)\n\n\n# Write Barrier Integration\n\n<div id=\"ms-write-barrier\"></div>\n\n## The Epiphany Analogy: The Security Camera System\n\nImagine you're managing a massive library where books can reference other books (like a bibliography). You have a cleaning crew (garbage collector) that removes books nobody references anymore.\n\n**The problem**: What if someone updates a bibliography *while* the cleaning crew is working? They might remove a book that just got referenced!\n\n**The solution**: Install security cameras (write barriers) at every desk. Whenever someone writes a new reference, the camera records it. The cleaning crew checks these recordings to ensure they don't throw away newly-referenced books.\n\n**In memory management**: A write barrier is a small piece of code that runs *every time* you update a pointer. It tracks these updates so the GC can handle them correctly, especially in advanced collectors (incremental, generational, concurrent).\n\n---\n\n## Technical Rationale: Why Write Barriers?\n\n### The Core Problem\n\nIn a simple stop-the-world GC, this works fine:\n\n```c\n// Program stops completely\nmark_phase(gc);    // Find all reachable objects\nsweep_phase(gc);   // Free unreachable objects\n// Program resumes\n```\n\nBut in **advanced GC schemes**, the program runs *during* collection:\n\n```c\n// Incremental GC: Collect in small steps\nmark_some_objects(gc);\nrun_program_for_a_bit();  // â† DANGER ZONE\nmark_more_objects(gc);\nrun_program_for_a_bit();  // â† Pointers can change here!\n```\n\n**The race condition**:\n\n```\nTime 0: GC marks object A (reachable)\nTime 1: GC marks object B (unreachable, will be freed)\nTime 2: Program runs: A->next = B  â† B is now reachable!\nTime 3: GC sweeps, frees B  â† DISASTER! A points to freed memory!\n```\n\n**Write barriers prevent this** by recording pointer updates.\n\n---\n\n## The Three Flavors of Write Barriers\n\n### 1. **Snapshot-At-The-Beginning (SATB)**\n\n**Philosophy**: Preserve the object graph as it existed when GC started.\n\n```c\nvoid satb_write_barrier(void** slot, void* new_value) {\n    void* old_value = *slot;\n    \n    // If we're overwriting a pointer during GC, preserve the old target\n    if (gc_is_running && old_value != NULL) {\n        mark_object(old_value);  // Don't let it be collected\n    }\n    \n    *slot = new_value;  // Perform the write\n}\n```\n\n**When to use**: Concurrent mark-and-sweep (like G1GC in Java).\n\n**Tradeoff**: May keep some garbage alive until next GC cycle.\n\n---\n\n### 2. **Incremental Update (Forward Barrier)**\n\n**Philosophy**: Track new references created during GC.\n\n```c\nvoid incremental_write_barrier(void** slot, void* new_value) {\n    *slot = new_value;  // Perform the write first\n    \n    // If we created a new reference during GC, mark the target\n    if (gc_is_running && new_value != NULL) {\n        mark_object(new_value);  // Ensure it's not collected\n    }\n}\n```\n\n**When to use**: Incremental mark-and-sweep.\n\n**Tradeoff**: Can cause \"mark stack overflow\" if many new references created.\n\n---\n\n### 3. **Generational Barrier (Card Marking)**\n\n**Philosophy**: Track old-to-young pointers for generational GC.\n\n```c\nvoid generational_write_barrier(void** slot, void* new_value) {\n    *slot = new_value;  // Perform the write\n    \n    // If an old object now points to a young object, record it\n    if (is_old_generation(slot) && is_young_generation(new_value)) {\n        mark_card_dirty(slot);  // Mark this memory region as \"contains cross-gen pointer\"\n    }\n}\n```\n\n**When to use**: Generational GC (most production systems).\n\n**Tradeoff**: Requires extra memory for card table.\n\n---\n\n## Internal Mechanics: Implementing Write Barriers\n\n### Step 1: The Card Table (for Generational GC)\n\n{{DIAGRAM:write-barrier-card-table}}\n\n```\nHeap Memory:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ [Object A] [Object B] [Object C] ...    â”‚  â† Actual objects\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â†“           â†“           â†“\nCard Table (1 byte per 512 bytes of heap):\nâ”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”\nâ”‚ 0 â”‚ 1 â”‚ 0 â”‚ 0 â”‚ 1 â”‚ 0 â”‚ 0 â”‚ 0 â”‚  â† 1 = \"dirty\" (contains interesting pointer)\nâ””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜\n```\n\n**The card table** is a bitmap where each bit represents a region of memory (typically 512 bytes). When you update a pointer in that region, you mark the card as \"dirty.\"\n\n```c\n#define CARD_SIZE 512  // Bytes per card\n#define CARD_SHIFT 9   // log2(512) = 9\n\ntypedef struct {\n    uint8_t* cards;        // Card table (1 byte per card)\n    size_t num_cards;      // Total number of cards\n    void* heap_start;      // Start of heap\n    size_t heap_size;      // Size of heap\n} CardTable;\n\nCardTable* create_card_table(void* heap_start, size_t heap_size) {\n    CardTable* table = malloc(sizeof(CardTable));\n    \n    // Calculate number of cards needed\n    table->num_cards = (heap_size + CARD_SIZE - 1) / CARD_SIZE;\n    table->cards = calloc(table->num_cards, 1);  // All clean initially\n    table->heap_start = heap_start;\n    table->heap_size = heap_size;\n    \n    return table;\n}\n\n// Get card index for a memory address\nstatic inline size_t get_card_index(CardTable* table, void* addr) {\n    size_t offset = (uint8_t*)addr - (uint8_t*)table->heap_start;\n    return offset >> CARD_SHIFT;  // Divide by 512\n}\n\n// Mark a card as dirty\nstatic inline void mark_card_dirty(CardTable* table, void* addr) {\n    size_t card_idx = get_card_index(table, addr);\n    table->cards[card_idx] = 1;  // Mark as dirty\n}\n\n// Check if a card is dirty\nstatic inline bool is_card_dirty(CardTable* table, void* addr) {\n    size_t card_idx = get_card_index(table, addr);\n    return table->cards[card_idx] != 0;\n}\n\n// Clear all cards (after processing)\nvoid clear_card_table(CardTable* table) {\n    memset(table->cards, 0, table->num_cards);\n}\n```\n\n**Memory overhead**: For a 1 MB heap with 512-byte cards, you need 2 KB for the card table (0.2% overhead).\n\n---\n\n### Step 2: The Write Barrier Hook\n\nNow we need to intercept *every* pointer write. There are three approaches:\n\n#### **Approach A: Compiler Support (Best)**\n\nModern compilers can automatically insert write barriers:\n\n```c\n// What you write:\nobj->field = new_value;\n\n// What the compiler generates:\nwrite_barrier(&obj->field, new_value);\nobj->field = new_value;\n```\n\n**How to enable**: Use compiler intrinsics or custom passes (GCC plugins, LLVM passes).\n\n---\n\n#### **Approach B: Manual Macros (Practical)**\n\nDefine macros for all pointer writes:\n\n```c\n#define GC_WRITE(obj, field, value) do { \\\n    write_barrier(&((obj)->field), (value)); \\\n    (obj)->field = (value); \\\n} while(0)\n\n// Usage:\nGC_WRITE(my_object, next_ptr, new_object);\n```\n\n**Tradeoff**: Requires disciplineâ€”easy to forget the macro.\n\n---\n\n#### **Approach C: Memory Protection (Slow but Automatic)**\n\nUse `mprotect()` to make memory read-only, catch writes with signal handlers:\n\n```c\n// Mark old generation as read-only\nmprotect(old_gen_start, old_gen_size, PROT_READ);\n\n// When program tries to write:\nvoid segfault_handler(int sig, siginfo_t* info, void* context) {\n    void* fault_addr = info->si_addr;\n    \n    // Record the write\n    mark_card_dirty(card_table, fault_addr);\n    \n    // Temporarily allow the write\n    mprotect(page_of(fault_addr), PAGE_SIZE, PROT_READ | PROT_WRITE);\n}\n```\n\n**Tradeoff**: 100-1000x slower than inline barriers. Only for debugging.\n\n---\n\n### Step 3: The Complete Write Barrier Implementation\n\n```c\ntypedef enum {\n    WB_NONE,           // No write barrier (stop-the-world GC)\n    WB_SATB,           // Snapshot-at-the-beginning (concurrent GC)\n    WB_INCREMENTAL,    // Incremental update (incremental GC)\n    WB_GENERATIONAL    // Card marking (generational GC)\n} WriteBarrierType;\n\ntypedef struct {\n    WriteBarrierType type;\n    CardTable* card_table;      // For generational GC\n    bool gc_is_running;         // For SATB/incremental\n    \n    // Statistics\n    size_t barrier_calls;       // Total write barrier invocations\n    size_t cards_dirtied;       // Cards marked dirty\n    size_t objects_marked;      // Objects marked by barrier\n} WriteBarrierState;\n\n// Initialize write barrier system\nWriteBarrierState* create_write_barrier(WriteBarrierType type, \n                                        void* heap_start, \n                                        size_t heap_size) {\n    WriteBarrierState* wb = malloc(sizeof(WriteBarrierState));\n    wb->type = type;\n    wb->gc_is_running = false;\n    wb->barrier_calls = 0;\n    wb->cards_dirtied = 0;\n    wb->objects_marked = 0;\n    \n    if (type == WB_GENERATIONAL) {\n        wb->card_table = create_card_table(heap_start, heap_size);\n    } else {\n        wb->card_table = NULL;\n    }\n    \n    return wb;\n}\n\n// The universal write barrier\nvoid write_barrier(GC* gc, void** slot, void* new_value) {\n    WriteBarrierState* wb = gc->write_barrier;\n    wb->barrier_calls++;\n    \n    switch (wb->type) {\n        case WB_NONE:\n            // No barrier needed\n            break;\n            \n        case WB_SATB: {\n            // Snapshot-at-the-beginning: preserve old value\n            void* old_value = *slot;\n            if (wb->gc_is_running && old_value != NULL) {\n                ObjectHeader* header = GET_HEADER(old_value);\n                if (!header->marked) {\n                    mark_object(gc, old_value);\n                    wb->objects_marked++;\n                }\n            }\n            break;\n        }\n        \n        case WB_INCREMENTAL: {\n            // Incremental update: mark new value\n            if (wb->gc_is_running && new_value != NULL) {\n                ObjectHeader* header = GET_HEADER(new_value);\n                if (!header->marked) {\n                    mark_object(gc, new_value);\n                    wb->objects_marked++;\n                }\n            }\n            break;\n        }\n        \n        case WB_GENERATIONAL: {\n            // Card marking: track old-to-young pointers\n            if (is_old_generation(gc, slot) && \n                is_young_generation(gc, new_value)) {\n                mark_card_dirty(wb->card_table, slot);\n                wb->cards_dirtied++;\n            }\n            break;\n        }\n    }\n}\n\n// Convenience macro for manual barrier insertion\n#define GC_WRITE_PTR(gc, obj, field, value) do { \\\n    write_barrier((gc), (void**)&((obj)->field), (void*)(value)); \\\n    (obj)->field = (value); \\\n} while(0)\n```\n\n---\n\n## Visual Reference: Write Barrier in Action\n\n{{DIAGRAM:write-barrier-flow}}\n\n```\nWithout Write Barrier (BROKEN):\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nTime 0: GC starts marking\n  A (marked) â†’ B (marked) â†’ C (unmarked, will be freed)\n  \nTime 1: Program runs, updates pointer\n  A (marked) â†’ C (unmarked)  â† A now points to C!\n  B (marked) â†’ NULL\n  \nTime 2: GC sweeps\n  A (kept) â†’ [FREED MEMORY]  â† CRASH!\n  B (kept)\n\n\nWith Write Barrier (CORRECT):\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nTime 0: GC starts marking\n  A (marked) â†’ B (marked) â†’ C (unmarked)\n  \nTime 1: Program runs, updates pointer\n  A (marked) â†’ C (unmarked)\n  write_barrier() called â†’ marks C!  â† Barrier saves the day\n  \nTime 2: GC sweeps\n  A (kept) â†’ C (kept)  â† Safe!\n  B (freed)\n```\n\n---\n\n## The Debugging Lab: Common Write Barrier Bugs\n\n### Bug #1: Forgetting the Barrier\n\n```c\n// WRONG: Direct pointer write\nobj->next = new_obj;  // â† No barrier! GC might collect new_obj!\n\n// CORRECT: Use barrier macro\nGC_WRITE_PTR(gc, obj, next, new_obj);\n```\n\n**Symptom**: Random crashes during GC, use-after-free errors.\n\n**Detection**: Run with `mprotect`-based barriers (slow but catches all violations).\n\n---\n\n### Bug #2: Barrier After Write\n\n```c\n// WRONG: Write happens before barrier\nobj->next = new_obj;\nwrite_barrier(gc, &obj->next, new_obj);  // â† Too late!\n\n// CORRECT: Barrier before write\nwrite_barrier(gc, &obj->next, new_obj);\nobj->next = new_obj;\n```\n\n**Why it matters**: In concurrent GC, another thread might see the new pointer before the barrier runs.\n\n---\n\n### Bug #3: Barrier on Non-Heap Pointers\n\n```c\n// WRONG: Barrier on stack variable\nint* stack_var = malloc(sizeof(int));\nwrite_barrier(gc, &stack_var, heap_obj);  // â† stack_var is not in heap!\n\n// CORRECT: Only barrier heap-to-heap pointers\nif (is_heap_pointer(&obj->field)) {\n    write_barrier(gc, &obj->field, new_value);\n}\n```\n\n**Symptom**: Segfaults in `get_card_index()` when address is outside heap.\n\n---\n\n### Bug #4: Barrier Performance Overhead\n\n```c\n// WRONG: Barrier in tight loop\nfor (int i = 0; i < 1000000; i++) {\n    GC_WRITE_PTR(gc, array, elements[i], new_value);  // â† 1M barrier calls!\n}\n\n// BETTER: Batch writes, single barrier\nfor (int i = 0; i < 1000000; i++) {\n    array->elements[i] = new_value;  // Direct write\n}\nwrite_barrier(gc, &array->elements[0], new_value);  // Single barrier for whole array\n```\n\n**Optimization**: Modern GCs use \"coarse-grained\" barriers that mark entire regions dirty.\n\n---\n\n## Code Scaffold: Your Task\n\nIntegrate write barriers into your GC:\n\n```c\n// TASK 1: Add write barrier state to GC\ntypedef struct {\n    // ... existing fields ...\n    \n    WriteBarrierState* write_barrier;  // â† Add this\n    \n    // Generation tracking (for generational GC)\n    void* young_gen_start;\n    size_t young_gen_size;\n    void* old_gen_start;\n    size_t old_gen_size;\n} GC;\n\n// TASK 2: Initialize write barrier\nGC* create_gc_with_barrier(size_t heap_size, WriteBarrierType barrier_type) {\n    GC* gc = create_gc(heap_size);\n    \n    // TODO: Create write barrier state\n    gc->write_barrier = create_write_barrier(\n        barrier_type,\n        gc->heap_start,\n        gc->heap_size\n    );\n    \n    // TODO: For generational GC, split heap into generations\n    if (barrier_type == WB_GENERATIONAL) {\n        gc->young_gen_size = heap_size / 4;  // 25% young\n        gc->young_gen_start = gc->heap_start;\n        gc->old_gen_start = (uint8_t*)gc->heap_start + gc->young_gen_size;\n        gc->old_gen_size = heap_size - gc->young_gen_size;\n    }\n    \n    return gc;\n}\n\n// TASK 3: Helper to check generation\nbool is_young_generation(GC* gc, void* ptr) {\n    if (gc->write_barrier->type != WB_GENERATIONAL) {\n        return false;\n    }\n    \n    return ptr >= gc->young_gen_start && \n           ptr < (void*)((uint8_t*)gc->young_gen_start + gc->young_gen_size);\n}\n\nbool is_old_generation(GC* gc, void* ptr) {\n    if (gc->write_barrier->type != WB_GENERATIONAL) {\n        return false;\n    }\n    \n    return ptr >= gc->old_gen_start && \n           ptr < (void*)((uint8_t*)gc->old_gen_start + gc->old_gen_size);\n}\n\n// TASK 4: Implement SATB write barrier\nvoid satb_write_barrier_impl(GC* gc, void** slot, void* new_value) {\n    // TODO: Get old value from slot\n    void* old_value = *slot;\n    \n    // TODO: If GC is running and old value exists, mark it\n    if (gc->write_barrier->gc_is_running && old_value != NULL) {\n        ObjectHeader* header = GET_HEADER(old_value);\n        if (!header->marked) {\n            // TODO: Mark the old object to preserve snapshot\n            mark_object(gc, old_value);\n            gc->write_barrier->objects_marked++;\n        }\n    }\n}\n\n// TASK 5: Implement incremental write barrier\nvoid incremental_write_barrier_impl(GC* gc, void** slot, void* new_value) {\n    // TODO: If GC is running and new value exists, mark it\n    if (gc->write_barrier->gc_is_running && new_value != NULL) {\n        ObjectHeader* header = GET_HEADER(new_value);\n        if (!header->marked) {\n            // TODO: Mark the new object to ensure it's not collected\n            mark_object(gc, new_value);\n            gc->write_barrier->objects_marked++;\n        }\n    }\n}\n\n// TASK 6: Implement generational write barrier\nvoid generational_write_barrier_impl(GC* gc, void** slot, void* new_value) {\n    // TODO: Check if this is an old-to-young pointer\n    if (is_old_generation(gc, slot) && is_young_generation(gc, new_value)) {\n        // TODO: Mark the card containing this slot as dirty\n        mark_card_dirty(gc->write_barrier->card_table, slot);\n        gc->write_barrier->cards_dirtied++;\n    }\n}\n\n// TASK 7: Update mark phase to process dirty cards (generational GC)\nvoid mark_phase_with_cards(GC* gc) {\n    // Standard marking from roots\n    mark_from_roots(gc);\n    \n    // TODO: If using generational GC, scan dirty cards\n    if (gc->write_barrier->type == WB_GENERATIONAL) {\n        CardTable* table = gc->write_barrier->card_table;\n        \n        // TODO: For each dirty card, scan objects in that region\n        for (size_t i = 0; i < table->num_cards; i++) {\n            if (table->cards[i] != 0) {\n                // Calculate memory region for this card\n                void* card_start = (uint8_t*)table->heap_start + (i * CARD_SIZE);\n                void* card_end = (uint8_t*)card_start + CARD_SIZE;\n                \n                // TODO: Scan all objects in this card\n                scan_region_for_pointers(gc, card_start, card_end);\n                \n                // TODO: Clear the card\n                table->cards[i] = 0;\n            }\n        }\n    }\n}\n\n// TASK 8: Helper to scan a memory region for pointers\nvoid scan_region_for_pointers(GC* gc, void* start, void* end) {\n    // TODO: Walk through memory, find objects, mark their references\n    uint8_t* ptr = (uint8_t*)start;\n    \n    while (ptr < (uint8_t*)end) {\n        // Check if this looks like an object header\n        if (is_valid_object_header(ptr)) {\n            ObjectHeader* header = (ObjectHeader*)ptr;\n            \n            // If object is in old generation, mark its children\n            if (is_old_generation(gc, ptr)) {\n                mark_object_children(gc, ptr + sizeof(ObjectHeader));\n            }\n            \n            ptr += sizeof(ObjectHeader) + header->size;\n        } else {\n            ptr += sizeof(void*);  // Skip ahead\n        }\n    }\n}\n\n// TASK 9: Update allocation to use write barrier\nvoid* gc_alloc_with_barrier(GC* gc, size_t size) {\n    void* ptr = gc_alloc_with_trigger(gc, size);\n    \n    // TODO: If using generational GC, allocate in young generation\n    if (gc->write_barrier->type == WB_GENERATIONAL) {\n        // Mark object as young\n        ObjectHeader* header = GET_HEADER(ptr);\n        header->generation = 0;  // Young generation\n    }\n    \n    return ptr;\n}\n\n// TASK 10: Implement object promotion (young â†’ old)\nvoid promote_object(GC* gc, void* obj) {\n    ObjectHeader* header = GET_HEADER(obj);\n    \n    // TODO: Move object from young to old generation\n    if (header->generation == 0) {\n        // Allocate in old generation\n        void* new_location = allocate_in_old_gen(gc, header->size);\n        \n        // TODO: Copy object data\n        memcpy(new_location, obj, sizeof(ObjectHeader) + header->size);\n        \n        // TODO: Update header\n        ObjectHeader* new_header = GET_HEADER(new_location);\n        new_header->generation = 1;  // Old generation\n        \n        // TODO: Update all pointers to old location (requires forwarding pointer)\n        header->forwarding_ptr = new_location;\n    }\n}\n```\n\n---\n\n## Testing Your Write Barrier\n\n```c\nvoid test_write_barrier_satb() {\n    GC* gc = create_gc_with_barrier(1024 * 1024, WB_SATB);\n    \n    // Allocate three objects: A â†’ B â†’ C\n    void* obj_a = gc_alloc(gc, 64);\n    void* obj_b = gc_alloc(gc, 64);\n    void* obj_c = gc_alloc(gc, 64);\n    \n    GC_WRITE_PTR(gc, obj_a, next, obj_b);\n    GC_WRITE_PTR(gc, obj_b, next, obj_c);\n    \n    // Start GC (mark A and B)\n    gc->write_barrier->gc_is_running = true;\n    mark_object(gc, obj_a);\n    mark_object(gc, obj_b);\n    // C is not marked yet\n    \n    // Program runs: A now points to C (bypassing B)\n    GC_WRITE_PTR(gc, obj_a, next, obj_c);  // â† Barrier should mark C!\n    \n    // Verify C was marked by barrier\n    ObjectHeader* header_c = GET_HEADER(obj_c);\n    assert(header_c->marked == true);\n    \n    printf(\"âœ“ SATB write barrier test passed\\n\");\n}\n\nvoid test_write_barrier_generational() {\n    GC* gc = create_gc_with_barrier(1024 * 1024, WB_GENERATIONAL);\n    \n    // Allocate in young generation\n    void* young_obj = gc_alloc_with_barrier(gc, 64);\n    assert(is_young_generation(gc, young_obj));\n    \n    // Promote to old generation\n    promote_object(gc, young_obj);\n    void* old_obj = GET_HEADER(young_obj)->forwarding_ptr;\n    assert(is_old_generation(gc, old_obj));\n    \n    // Allocate another young object\n    void* young_obj2 = gc_alloc_with_barrier(gc, 64);\n    \n    // Old object points to young object\n    GC_WRITE_PTR(gc, old_obj, next, young_obj2);  // â† Should dirty card!\n    \n    // Verify card was marked dirty\n    assert(is_card_dirty(gc->write_barrier->card_table, old_obj));\n    \n    printf(\"âœ“ Generational write barrier test passed\\n\");\n}\n\nvoid test_write_barrier_performance() {\n    GC* gc = create_gc_with_barrier(10 * 1024 * 1024, WB_GENERATIONAL);\n    \n    // Allocate 10,000 objects\n    void** objects = malloc(10000 * sizeof(void*));\n    for (int i = 0; i < 10000; i++) {\n        objects[i] = gc_alloc_with_barrier(gc, 128);\n    }\n    \n    // Measure barrier overhead\n    uint64_t start = get_time_us();\n    \n    for (int i = 0; i < 10000; i++) {\n        GC_WRITE_PTR(gc, objects[i], next, objects[(i + 1) % 10000]);\n    }\n    \n    uint64_t duration = get_time_us() - start;\n    double ns_per_barrier = (double)duration * 1000.0 / 10000.0;\n    \n    printf(\"âœ“ Write barrier performance: %.1f ns/barrier\\n\", ns_per_barrier);\n    printf(\"  Total barriers: %zu\\n\", gc->write_barrier->barrier_calls);\n    printf(\"  Cards dirtied: %zu\\n\", gc->write_barrier->cards_dirtied);\n    \n    // Should be < 50ns per barrier on modern hardware\n    assert(ns_per_barrier < 100.0);\n}\n```\n\n---\n\n## Performance Characteristics\n\n### Write Barrier Overhead\n\n| Barrier Type | Cost per Write | Memory Overhead | Use Case |\n|--------------|----------------|-----------------|----------|\n| **None** | 0 ns | 0% | Stop-the-world GC |\n| **SATB** | 5-10 ns | 0% | Concurrent mark-sweep |\n| **Incremental** | 5-10 ns | 0% | Incremental GC |\n| **Generational** | 10-20 ns | 0.2% (card table) | Production systems |\n\n**Real-world impact**: For a program that writes 1 million pointers/second, generational barriers add ~20ms overhead (2% of CPU time).\n\n---\n\n### Card Table Granularity Tradeoff\n\n```\nFine-grained (128 bytes/card):\n  âœ“ Precise: scan less memory during GC\n  âœ— More memory: 0.8% overhead\n  âœ— More cache misses\n\nCoarse-grained (4 KB/card):\n  âœ“ Less memory: 0.025% overhead\n  âœ“ Better cache behavior\n  âœ— Scan more memory during GC\n```\n\n**Sweet spot**: 512 bytes/card (0.2% overhead, good cache behavior).\n\n---\n\n## What You've Mastered\n\nâœ… **Write barrier fundamentals**: Why they're needed for advanced GC  \nâœ… **Three barrier types**: SATB, incremental, generational  \nâœ… **Card table implementation**: Efficient cross-generation tracking  \nâœ… **Barrier integration**: Hooking into pointer writes  \nâœ… **Performance optimization**: Minimizing barrier overhead  \nâœ… **Debugging techniques**: Catching missing barriers  \n\n---\n\n## Next Steps\n\n**You now have the foundation for advanced garbage collectors!** ğŸ‰\n\n**What's next?**\n\n1. **[â†’ Generational GC](#generational-gc)**: Use write barriers to implement a full generational collector\n2. **[â†’ Incremental GC](#incremental-gc)**: Spread GC work across allocations using incremental barriers\n3. **[â†’ Concurrent GC](#concurrent-gc)**: Run GC in parallel with program using SATB barriers\n4. **[â†’ Compacting GC](#compacting-gc)**: Move objects to eliminate fragmentation\n\n**Before continuing**, verify your write barriers work correctly:\n\n```bash\n$ ./test_write_barrier\nâœ“ SATB barrier test passed\nâœ“ Incremental barrier test passed\nâœ“ Generational barrier test passed\nâœ“ Card table test passed\nâœ“ Performance test: 15.3 ns/barrier\nâœ“ Stress test: 1M barriers, 0 crashes\n```\n\n**Pro tip**: Enable `mprotect`-based barriers during development to catch all missing barriers, then switch to inline barriers for production.\n\n---\n\n[â†‘ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-fragmentation\"></div>\n\n# Fragmentation Management: The Jigsaw Puzzle Problem\n\n## The Epiphany Analogy: The Parking Lot Paradox\n\nImagine a parking lot with 100 spaces. Throughout the day:\n- ğŸš— Cars arrive (allocations)\n- ğŸš™ Cars leave (deallocations)\n- ğŸš A bus arrives needing 3 consecutive spaces\n\nBy evening, you have 50 empty spaces... but they're scattered! The bus can't park even though there's plenty of room. **This is fragmentation.**\n\nYour memory heap faces the same problem:\n\n```\nBefore fragmentation:\n[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] â† Contiguous free space\n\nAfter many alloc/free cycles:\n[â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–‘â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–‘â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆ] â† Swiss cheese memory\n  â†‘    â†‘         â†‘\n  Free but unusable for large allocations!\n```\n\n**The brutal truth**: Without fragmentation management, your allocator will fail even when 50% of memory is free.\n\n---\n\n## Technical Rationale: Why Fragmentation Kills Performance\n\n### The Two Faces of Fragmentation\n\n**1. External Fragmentation** (the parking lot problem)\n```\nHeap state after 1000 allocations:\nTotal memory: 1 MB\nFree memory: 512 KB (50%!)\nLargest contiguous block: 4 KB â† Can't allocate 64 KB!\n\nResult: Out-of-memory despite having space\n```\n\n**2. Internal Fragmentation** (the waste within)\n```\nRequest: 65 bytes\nAllocated: 128 bytes (next power of 2)\nWasted: 63 bytes (49% waste!)\n\nOver 10,000 allocations: 630 KB wasted\n```\n\n### Real-World Impact\n\n**Case study: Long-running server**\n```\nHour 0:  Fragmentation: 5%  | Max alloc: 1 MB\nHour 24: Fragmentation: 35% | Max alloc: 128 KB\nHour 48: Fragmentation: 60% | Max alloc: 16 KB â† Death spiral!\n```\n\n**Without fragmentation management**: Server crashes after 48 hours despite using only 40% of memory.\n\n---\n\n## Internal Mechanics: The Three-Pronged Defense\n\n### Strategy 1: Coalescing (Immediate Neighbor Merging)\n\n**The concept**: When you free a block, immediately merge it with adjacent free blocks.\n\n```\nBefore free(B):\n[Used A][Used B][Free C][Free D][Used E]\n         â†“ free\n[Used A][Free B][Free C][Free D][Used E]\n         â†“ coalesce\n[Used A][Free B+C+D (contiguous!)][Used E]\n```\n\n**Why it works**: Prevents fragmentation from accumulating in the first place.\n\n{{DIAGRAM:coalescing-process}}\n\n### Strategy 2: Compaction (The Nuclear Option)\n\n**The concept**: Move all live objects together, eliminating all gaps.\n\n```\nBefore compaction:\n[â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–‘â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–‘â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆ]\n\nAfter compaction:\n[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] â† One giant free block!\n```\n\n**The cost**: Must update every pointer in the program (expensive!).\n\n{{DIAGRAM:compaction-phases}}\n\n### Strategy 3: Segregated Free Lists (Prevention)\n\n**The concept**: Keep separate free lists for different size classes.\n\n```\nSmall (8-64 bytes):   [16][32][24][48]...\nMedium (65-512 bytes): [128][256][384]...\nLarge (513+ bytes):    [1024][2048]...\n```\n\n**Why it works**: Small allocations can't fragment large blocks.\n\n---\n\n## Implementation: Coalescing with Boundary Tags\n\n### The Data Structure\n\n```c\ntypedef struct FreeBlock {\n    size_t size;              // Size of this block (including header)\n    struct FreeBlock* next;   // Next free block in list\n    struct FreeBlock* prev;   // Previous free block in list\n    uint32_t magic;           // Corruption detection (0xDEADBEEF)\n} FreeBlock;\n\ntypedef struct BlockFooter {\n    size_t size;              // Duplicate of header size\n    uint32_t magic;           // Corruption detection\n} BlockFooter;\n\n// Layout in memory:\n// [FreeBlock header][...free space...][BlockFooter]\n//  â†‘                                   â†‘\n//  size field                          size field (for backward coalescing)\n```\n\n**Key insight**: The footer lets you find the previous block's size by looking backward!\n\n```c\n// Get footer of current block\n#define GET_FOOTER(block) \\\n    ((BlockFooter*)((uint8_t*)(block) + (block)->size - sizeof(BlockFooter)))\n\n// Get previous block (if it exists)\n#define GET_PREV_BLOCK(block) \\\n    ((FreeBlock*)((uint8_t*)(block) - \\\n     ((BlockFooter*)((uint8_t*)(block) - sizeof(BlockFooter)))->size))\n```\n\n{{DIAGRAM:boundary-tags}}\n\n---\n\n## The Coalescing Algorithm\n\n### Step-by-Step Breakdown\n\n```c\ntypedef enum {\n    COALESCE_NONE = 0,      // No neighbors are free\n    COALESCE_PREV = 1,      // Previous block is free\n    COALESCE_NEXT = 2,      // Next block is free\n    COALESCE_BOTH = 3       // Both neighbors are free\n} CoalesceCase;\n\nFreeBlock* coalesce_block(GC* gc, FreeBlock* block) {\n    // STEP 1: Determine which neighbors are free\n    CoalesceCase case_type = COALESCE_NONE;\n    \n    // Check if previous block is free\n    bool prev_free = false;\n    if ((uint8_t*)block > (uint8_t*)gc->heap_start) {\n        BlockFooter* prev_footer = (BlockFooter*)((uint8_t*)block - sizeof(BlockFooter));\n        if (prev_footer->magic == FREE_BLOCK_MAGIC) {\n            prev_free = true;\n            case_type |= COALESCE_PREV;\n        }\n    }\n    \n    // Check if next block is free\n    bool next_free = false;\n    FreeBlock* next_block = (FreeBlock*)((uint8_t*)block + block->size);\n    if ((uint8_t*)next_block < (uint8_t*)gc->heap_start + gc->heap_size) {\n        if (next_block->magic == FREE_BLOCK_MAGIC) {\n            next_free = true;\n            case_type |= COALESCE_NEXT;\n        }\n    }\n    \n    // STEP 2: Handle each case\n    switch (case_type) {\n        case COALESCE_NONE:\n            return coalesce_none(gc, block);\n        case COALESCE_PREV:\n            return coalesce_prev(gc, block);\n        case COALESCE_NEXT:\n            return coalesce_next(gc, block);\n        case COALESCE_BOTH:\n            return coalesce_both(gc, block);\n    }\n    \n    return block;\n}\n```\n\n### Case 1: No Coalescing Needed\n\n```c\nFreeBlock* coalesce_none(GC* gc, FreeBlock* block) {\n    // Just add to free list\n    block->magic = FREE_BLOCK_MAGIC;\n    block->next = gc->free_list;\n    block->prev = NULL;\n    \n    if (gc->free_list) {\n        gc->free_list->prev = block;\n    }\n    gc->free_list = block;\n    \n    // Set footer\n    BlockFooter* footer = GET_FOOTER(block);\n    footer->size = block->size;\n    footer->magic = FREE_BLOCK_MAGIC;\n    \n    gc->stats.fragmentation_events++;\n    return block;\n}\n```\n\n### Case 2: Coalesce with Previous Block\n\n```c\nFreeBlock* coalesce_prev(GC* gc, FreeBlock* block) {\n    // Get previous block\n    FreeBlock* prev_block = GET_PREV_BLOCK(block);\n    \n    // Remove prev_block from free list (we'll re-add the merged block)\n    if (prev_block->prev) {\n        prev_block->prev->next = prev_block->next;\n    } else {\n        gc->free_list = prev_block->next;\n    }\n    if (prev_block->next) {\n        prev_block->next->prev = prev_block->prev;\n    }\n    \n    // Merge: prev_block absorbs current block\n    prev_block->size += block->size;\n    \n    // Update footer (now at end of merged block)\n    BlockFooter* footer = GET_FOOTER(prev_block);\n    footer->size = prev_block->size;\n    footer->magic = FREE_BLOCK_MAGIC;\n    \n    // Re-add to free list\n    prev_block->next = gc->free_list;\n    prev_block->prev = NULL;\n    if (gc->free_list) {\n        gc->free_list->prev = prev_block;\n    }\n    gc->free_list = prev_block;\n    \n    gc->stats.coalesce_prev_count++;\n    return prev_block;\n}\n```\n\n### Case 3: Coalesce with Next Block\n\n```c\nFreeBlock* coalesce_next(GC* gc, FreeBlock* block) {\n    FreeBlock* next_block = (FreeBlock*)((uint8_t*)block + block->size);\n    \n    // Remove next_block from free list\n    if (next_block->prev) {\n        next_block->prev->next = next_block->next;\n    } else {\n        gc->free_list = next_block->next;\n    }\n    if (next_block->next) {\n        next_block->next->prev = next_block->prev;\n    }\n    \n    // Merge: current block absorbs next block\n    block->size += next_block->size;\n    block->magic = FREE_BLOCK_MAGIC;\n    \n    // Update footer\n    BlockFooter* footer = GET_FOOTER(block);\n    footer->size = block->size;\n    footer->magic = FREE_BLOCK_MAGIC;\n    \n    // Add to free list\n    block->next = gc->free_list;\n    block->prev = NULL;\n    if (gc->free_list) {\n        gc->free_list->prev = block;\n    }\n    gc->free_list = block;\n    \n    gc->stats.coalesce_next_count++;\n    return block;\n}\n```\n\n### Case 4: Coalesce with Both Neighbors\n\n```c\nFreeBlock* coalesce_both(GC* gc, FreeBlock* block) {\n    FreeBlock* prev_block = GET_PREV_BLOCK(block);\n    FreeBlock* next_block = (FreeBlock*)((uint8_t*)block + block->size);\n    \n    // Remove both neighbors from free list\n    // (Remove prev)\n    if (prev_block->prev) {\n        prev_block->prev->next = prev_block->next;\n    } else {\n        gc->free_list = prev_block->next;\n    }\n    if (prev_block->next) {\n        prev_block->next->prev = prev_block->prev;\n    }\n    \n    // (Remove next)\n    if (next_block->prev) {\n        next_block->prev->next = next_block->next;\n    } else {\n        gc->free_list = next_block->next;\n    }\n    if (next_block->next) {\n        next_block->next->prev = next_block->prev;\n    }\n    \n    // Merge all three: prev absorbs current and next\n    prev_block->size += block->size + next_block->size;\n    \n    // Update footer (now at end of triple-merged block)\n    BlockFooter* footer = GET_FOOTER(prev_block);\n    footer->size = prev_block->size;\n    footer->magic = FREE_BLOCK_MAGIC;\n    \n    // Re-add to free list\n    prev_block->next = gc->free_list;\n    prev_block->prev = NULL;\n    if (gc->free_list) {\n        gc->free_list->prev = prev_block;\n    }\n    gc->free_list = prev_block;\n    \n    gc->stats.coalesce_both_count++;\n    return prev_block;\n}\n```\n\n{{DIAGRAM:coalesce-cases}}\n\n---\n\n## Implementation: Compaction (Optional)\n\n### When to Compact\n\n```c\ntypedef struct CompactionPolicy {\n    float fragmentation_threshold;  // Compact when fragmentation > this\n    size_t min_heap_size;           // Don't compact small heaps\n    uint64_t last_compaction_time;  // Rate limiting\n    uint64_t min_time_between_ms;   // Minimum time between compactions\n} CompactionPolicy;\n\nbool should_compact(GC* gc) {\n    CompactionPolicy* policy = &gc->compaction_policy;\n    \n    // Calculate fragmentation ratio\n    size_t total_free = calculate_total_free_memory(gc);\n    size_t largest_block = find_largest_free_block(gc);\n    \n    float fragmentation = 1.0f - ((float)largest_block / (float)total_free);\n    \n    // Check conditions\n    if (fragmentation < policy->fragmentation_threshold) {\n        return false;  // Not fragmented enough\n    }\n    \n    if (gc->heap_size < policy->min_heap_size) {\n        return false;  // Heap too small to bother\n    }\n    \n    uint64_t now = get_time_ms();\n    if (now - policy->last_compaction_time < policy->min_time_between_ms) {\n        return false;  // Too soon since last compaction\n    }\n    \n    return true;\n}\n```\n\n### The Compaction Algorithm (Three-Pass)\n\n```c\nvoid compact_heap(GC* gc) {\n    uint64_t start_time = get_time_us();\n    \n    // PASS 1: Calculate new addresses\n    void* new_addr = gc->heap_start;\n    ObjectHeader* obj = gc->heap_start;\n    \n    while ((uint8_t*)obj < (uint8_t*)gc->heap_start + gc->heap_size) {\n        if (obj->marked) {\n            // This object survives - record its new address\n            obj->forwarding_ptr = new_addr;\n            new_addr = (uint8_t*)new_addr + sizeof(ObjectHeader) + obj->size;\n        }\n        obj = (ObjectHeader*)((uint8_t*)obj + sizeof(ObjectHeader) + obj->size);\n    }\n    \n    // PASS 2: Update all pointers\n    obj = gc->heap_start;\n    while ((uint8_t*)obj < (uint8_t*)gc->heap_start + gc->heap_size) {\n        if (obj->marked) {\n            update_object_pointers(gc, obj);\n        }\n        obj = (ObjectHeader*)((uint8_t*)obj + sizeof(ObjectHeader) + obj->size);\n    }\n    \n    // Update root pointers\n    update_root_pointers(gc);\n    \n    // PASS 3: Move objects to new locations\n    obj = gc->heap_start;\n    while ((uint8_t*)obj < (uint8_t*)gc->heap_start + gc->heap_size) {\n        if (obj->marked) {\n            void* new_location = obj->forwarding_ptr;\n            if (new_location != obj) {\n                memmove(new_location, obj, sizeof(ObjectHeader) + obj->size);\n            }\n        }\n        obj = (ObjectHeader*)((uint8_t*)obj + sizeof(ObjectHeader) + obj->size);\n    }\n    \n    // Reset free list (now one giant block at the end)\n    gc->free_list = (FreeBlock*)new_addr;\n    gc->free_list->size = (uint8_t*)gc->heap_start + gc->heap_size - (uint8_t*)new_addr;\n    gc->free_list->next = NULL;\n    gc->free_list->prev = NULL;\n    gc->free_list->magic = FREE_BLOCK_MAGIC;\n    \n    uint64_t duration = get_time_us() - start_time;\n    gc->stats.compaction_time_us += duration;\n    gc->stats.compaction_count++;\n    \n    gc->compaction_policy.last_compaction_time = get_time_ms();\n}\n```\n\n### Updating Pointers During Compaction\n\n```c\nvoid update_object_pointers(GC* gc, ObjectHeader* obj) {\n    // Scan object for pointers\n    void** ptr = (void**)((uint8_t*)obj + sizeof(ObjectHeader));\n    void** end = (void**)((uint8_t*)obj + sizeof(ObjectHeader) + obj->size);\n    \n    while (ptr < end) {\n        void* target = *ptr;\n        \n        // Check if this looks like a heap pointer\n        if (target >= gc->heap_start && \n            target < (void*)((uint8_t*)gc->heap_start + gc->heap_size)) {\n            \n            ObjectHeader* target_header = GET_HEADER(target);\n            \n            // Update to forwarding address\n            if (target_header->forwarding_ptr) {\n                *ptr = (uint8_t*)target_header->forwarding_ptr + sizeof(ObjectHeader);\n            }\n        }\n        \n        ptr++;\n    }\n}\n\nvoid update_root_pointers(GC* gc) {\n    for (size_t i = 0; i < gc->root_count; i++) {\n        void** root = gc->roots[i];\n        void* target = *root;\n        \n        if (target >= gc->heap_start && \n            target < (void*)((uint8_t*)gc->heap_start + gc->heap_size)) {\n            \n            ObjectHeader* target_header = GET_HEADER(target);\n            \n            if (target_header->forwarding_ptr) {\n                *root = (uint8_t*)target_header->forwarding_ptr + sizeof(ObjectHeader);\n            }\n        }\n    }\n}\n```\n\n{{DIAGRAM:compaction-three-pass}}\n\n---\n\n## The Debugging Lab: Common Fragmentation Bugs\n\n### Bug 1: Forgetting to Coalesce\n\n```c\n// âŒ WRONG: Just add to free list\nvoid gc_free_wrong(GC* gc, void* ptr) {\n    FreeBlock* block = (FreeBlock*)((uint8_t*)ptr - sizeof(FreeBlock));\n    block->next = gc->free_list;\n    gc->free_list = block;\n    // Missing: coalesce_block(gc, block);\n}\n\n// Result after 1000 frees:\n// [Free 64][Free 64][Free 64][Free 64]... â† Can't allocate 256 bytes!\n```\n\n**Fix**: Always coalesce on free:\n```c\nvoid gc_free_correct(GC* gc, void* ptr) {\n    FreeBlock* block = (FreeBlock*)((uint8_t*)ptr - sizeof(FreeBlock));\n    coalesce_block(gc, block);  // âœ“ Merge with neighbors\n}\n```\n\n### Bug 2: Corrupted Boundary Tags\n\n```c\n// âŒ WRONG: Overwrite footer\nvoid* gc_alloc_wrong(GC* gc, size_t size) {\n    FreeBlock* block = find_free_block(gc, size);\n    // ... split block ...\n    \n    // Forgot to update footer!\n    return (uint8_t*)block + sizeof(FreeBlock);\n}\n\n// Later, during coalescing:\nBlockFooter* footer = GET_FOOTER(block);\n// footer->size is garbage! â† Crash or corruption\n```\n\n**Fix**: Always maintain footer invariant:\n```c\nvoid update_block_footer(FreeBlock* block) {\n    BlockFooter* footer = GET_FOOTER(block);\n    footer->size = block->size;\n    footer->magic = FREE_BLOCK_MAGIC;\n}\n```\n\n### Bug 3: Compaction Without Updating All Pointers\n\n```c\n// âŒ WRONG: Forgot to update stack pointers\nvoid compact_heap_wrong(GC* gc) {\n    // ... calculate new addresses ...\n    // ... update heap pointers ...\n    // ... move objects ...\n    \n    // Missing: update_stack_pointers(gc);\n}\n\n// Result: Stack still points to old addresses!\nvoid* obj = stack_var;  // Points to old location\nobj->field = 42;        // â† Writes to freed memory! Crash!\n```\n\n**Fix**: Update ALL pointer sources:\n```c\nvoid compact_heap_correct(GC* gc) {\n    calculate_new_addresses(gc);\n    update_heap_pointers(gc);\n    update_root_pointers(gc);      // âœ“ Roots\n    update_stack_pointers(gc);     // âœ“ Stack\n    update_register_pointers(gc);  // âœ“ Registers\n    move_objects(gc);\n}\n```\n\n### Debugging Tool: Fragmentation Visualizer\n\n```c\nvoid visualize_fragmentation(GC* gc) {\n    printf(\"\\nHeap Fragmentation Map:\\n\");\n    printf(\"Legend: â–ˆ=used â–‘=free\\n\\n\");\n    \n    uint8_t* ptr = gc->heap_start;\n    uint8_t* end = (uint8_t*)gc->heap_start + gc->heap_size;\n    \n    int col = 0;\n    while (ptr < end) {\n        ObjectHeader* obj = (ObjectHeader*)ptr;\n        \n        if (obj->marked) {\n            printf(\"â–ˆ\");  // Used\n        } else {\n            printf(\"â–‘\");  // Free\n        }\n        \n        ptr += sizeof(ObjectHeader) + obj->size;\n        \n        if (++col >= 80) {\n            printf(\"\\n\");\n            col = 0;\n        }\n    }\n    \n    printf(\"\\n\\n\");\n    print_fragmentation_stats(gc);\n}\n\nvoid print_fragmentation_stats(GC* gc) {\n    size_t total_free = 0;\n    size_t largest_block = 0;\n    size_t num_free_blocks = 0;\n    \n    FreeBlock* block = gc->free_list;\n    while (block) {\n        total_free += block->size;\n        if (block->size > largest_block) {\n            largest_block = block->size;\n        }\n        num_free_blocks++;\n        block = block->next;\n    }\n    \n    float fragmentation = 1.0f - ((float)largest_block / (float)total_free);\n    \n    printf(\"Fragmentation Statistics:\\n\");\n    printf(\"  Total free: %zu bytes (%.1f%%)\\n\", \n           total_free, 100.0f * total_free / gc->heap_size);\n    printf(\"  Largest block: %zu bytes\\n\", largest_block);\n    printf(\"  Free blocks: %zu\\n\", num_free_blocks);\n    printf(\"  Fragmentation: %.1f%%\\n\", fragmentation * 100.0f);\n    printf(\"  Coalesce events: prev=%zu next=%zu both=%zu\\n\",\n           gc->stats.coalesce_prev_count,\n           gc->stats.coalesce_next_count,\n           gc->stats.coalesce_both_count);\n}\n```\n\n{{DIAGRAM:fragmentation-visualizer}}\n\n---\n\n## Code Scaffold: Your Tasks\n\n```c\n// ============================================================================\n// FRAGMENTATION MANAGEMENT IMPLEMENTATION\n// ============================================================================\n\n#define FREE_BLOCK_MAGIC 0xDEADBEEF\n#define USED_BLOCK_MAGIC 0xCAFEBABE\n\ntypedef struct FreeBlock {\n    size_t size;\n    struct FreeBlock* next;\n    struct FreeBlock* prev;\n    uint32_t magic;\n} FreeBlock;\n\ntypedef struct BlockFooter {\n    size_t size;\n    uint32_t magic;\n} BlockFooter;\n\ntypedef struct FragmentationStats {\n    size_t coalesce_prev_count;\n    size_t coalesce_next_count;\n    size_t coalesce_both_count;\n    size_t fragmentation_events;\n    size_t compaction_count;\n    uint64_t compaction_time_us;\n} FragmentationStats;\n\n// TASK 1: Implement boundary tag helpers\nBlockFooter* get_block_footer(FreeBlock* block) {\n    // TODO: Calculate footer address\n    // Hint: footer is at (block + block->size - sizeof(BlockFooter))\n    return NULL;  // Replace this\n}\n\nFreeBlock* get_prev_block(FreeBlock* block) {\n    // TODO: Get previous block using its footer\n    // Hint: \n    //   1. Get footer at (block - sizeof(BlockFooter))\n    //   2. Read its size\n    //   3. Calculate prev block start\n    return NULL;  // Replace this\n}\n\nFreeBlock* get_next_block(FreeBlock* block) {\n    // TODO: Calculate next block address\n    // Hint: next = block + block->size\n    return NULL;  // Replace this\n}\n\n// TASK 2: Check if a block is free\nbool is_block_free(void* block, void* heap_start, void* heap_end) {\n    // TODO: Check if block is within heap bounds\n    if (block < heap_start || block >= heap_end) {\n        return false;\n    }\n    \n    // TODO: Check magic number\n    FreeBlock* fb = (FreeBlock*)block;\n    // Return true if magic == FREE_BLOCK_MAGIC\n    return false;  // Replace this\n}\n\n// TASK 3: Initialize a free block with boundary tags\nvoid init_free_block(FreeBlock* block, size_t size) {\n    // TODO: Set header fields\n    block->size = size;\n    block->magic = FREE_BLOCK_MAGIC;\n    block->next = NULL;\n    block->prev = NULL;\n    \n    // TODO: Set footer\n    BlockFooter* footer = get_block_footer(block);\n    // Set footer->size and footer->magic\n}\n\n// TASK 4: Implement coalesce_none\nFreeBlock* coalesce_none(GC* gc, FreeBlock* block) {\n    // TODO: Initialize block as free\n    init_free_block(block, block->size);\n    \n    // TODO: Add to head of free list\n    // Hint: \n    //   block->next = gc->free_list;\n    //   if (gc->free_list) gc->free_list->prev = block;\n    //   gc->free_list = block;\n    \n    gc->stats.fragmentation_events++;\n    return block;\n}\n\n// TASK 5: Implement coalesce_prev\nFreeBlock* coalesce_prev(GC* gc, FreeBlock* block) {\n    // TODO: Get previous block\n    FreeBlock* prev_block = get_prev_block(block);\n    \n    // TODO: Remove prev_block from free list\n    // Hint: Update prev/next pointers of neighbors\n    \n    // TODO: Merge blocks\n    prev_block->size += block->size;\n    \n    // TODO: Update footer of merged block\n    init_free_block(prev_block, prev_block->size);\n    \n    // TODO: Re-add to free list\n    \n    gc->stats.coalesce_prev_count++;\n    return prev_block;\n}\n\n// TASK 6: Implement coalesce_next\nFreeBlock* coalesce_next(GC* gc, FreeBlock* block) {\n    // TODO: Get next block\n    FreeBlock* next_block = get_next_block(block);\n    \n    // TODO: Remove next_block from free list\n    \n    // TODO: Merge blocks\n    block->size += next_block->size;\n    \n    // TODO: Update footer\n    init_free_block(block, block->size);\n    \n    // TODO: Add to free list\n    \n    gc->stats.coalesce_next_count++;\n    return block;\n}\n\n// TASK 7: Implement coalesce_both\nFreeBlock* coalesce_both(GC* gc, FreeBlock* block) {\n    // TODO: Get both neighbors\n    FreeBlock* prev_block = get_prev_block(block);\n    FreeBlock* next_block = get_next_block(block);\n    \n    // TODO: Remove both from free list\n    \n    // TODO: Merge all three blocks\n    prev_block->size += block->size + next_block->size;\n    \n    // TODO: Update footer\n    init_free_block(prev_block, prev_block->size);\n    \n    // TODO: Re-add to free list\n    \n    gc->stats.coalesce_both_count++;\n    return prev_block;\n}\n\n// TASK 8: Implement main coalesce function\nFreeBlock* coalesce_block(GC* gc, FreeBlock* block) {\n    // TODO: Check if previous block is free\n    bool prev_free = false;\n    if ((uint8_t*)block > (uint8_t*)gc->heap_start) {\n        FreeBlock* prev = get_prev_block(block);\n        prev_free = is_block_free(prev, gc->heap_start, \n                                   (uint8_t*)gc->heap_start + gc->heap_size);\n    }\n    \n    // TODO: Check if next block is free\n    bool next_free = false;\n    FreeBlock* next = get_next_block(block);\n    if ((uint8_t*)next < (uint8_t*)gc->heap_start + gc->heap_size) {\n        next_free = is_block_free(next, gc->heap_start,\n                                   (uint8_t*)gc->heap_start + gc->heap_size);\n    }\n    \n    // TODO: Call appropriate coalesce function\n    if (prev_free && next_free) {\n        return coalesce_both(gc, block);\n    } else if (prev_free) {\n        return coalesce_prev(gc, block);\n    } else if (next_free) {\n        return coalesce_next(gc, block);\n    } else {\n        return coalesce_none(gc, block);\n    }\n}\n\n// TASK 9: Calculate fragmentation ratio\nfloat calculate_fragmentation(GC* gc) {\n    // TODO: Calculate total free memory\n    size_t total_free = 0;\n    size_t largest_block = 0;\n    \n    FreeBlock* block = gc->free_list;\n    while (block) {\n        total_free += block->size;\n        if (block->size > largest_block) {\n            largest_block = block->size;\n        }\n        block = block->next;\n    }\n    \n    // TODO: Calculate fragmentation ratio\n    // Formula: 1.0 - (largest_block / total_free)\n    if (total_free == 0) return 0.0f;\n    \n    return 0.0f;  // Replace with calculation\n}\n\n// TASK 10: Implement compaction (OPTIONAL - Advanced)\nvoid compact_heap(GC* gc) {\n    // PASS 1: Calculate new addresses\n    void* new_addr = gc->heap_start;\n    ObjectHeader* obj = gc->heap_start;\n    \n    while ((uint8_t*)obj < (uint8_t*)gc->heap_start + gc->heap_size) {\n        if (obj->marked) {\n            // TODO: Record forwarding address\n            obj->forwarding_ptr = new_addr;\n            new_addr = (uint8_t*)new_addr + sizeof(ObjectHeader) + obj->size;\n        }\n        obj = (ObjectHeader*)((uint8_t*)obj + sizeof(ObjectHeader) + obj->size);\n    }\n    \n    // PASS 2: Update pointers\n    // TODO: Update all object pointers to use forwarding addresses\n    \n    // PASS 3: Move objects\n    obj = gc->heap_start;\n    while ((uint8_t*)obj < (uint8_t*)gc->heap_start + gc->heap_size) {\n        if (obj->marked) {\n            void* new_location = obj->forwarding_ptr;\n            if (new_location != obj) {\n                // TODO: Move object to new location\n                memmove(new_location, obj, sizeof(ObjectHeader) + obj->size);\n            }\n        }\n        obj = (ObjectHeader*)((uint8_t*)obj + sizeof(ObjectHeader) + obj->size);\n    }\n    \n    // TODO: Reset free list to one giant block\n    gc->free_list = (FreeBlock*)new_addr;\n    gc->free_list->size = (uint8_t*)gc->heap_start + gc->heap_size - (uint8_t*)new_addr;\n    init_free_block(gc->free_list, gc->free_list->size);\n    \n    gc->stats.compaction_count++;\n}\n```\n\n---\n\n## Testing Your Fragmentation Management\n\n```c\nvoid test_coalescing_basic() {\n    GC* gc = create_gc(1024 * 1024);\n    \n    // Allocate 5 blocks\n    void* a = gc_alloc(gc, 64);\n    void* b = gc_alloc(gc, 64);\n    void* c = gc_alloc(gc, 64);\n    void* d = gc_alloc(gc, 64);\n    void* e = gc_alloc(gc, 64);\n    \n    // Free alternating blocks: [A][free][C][free][E]\n    gc_free(gc, b);\n    gc_free(gc, d);\n    \n    // Should have 2 free blocks\n    assert(count_free_blocks(gc) == 2);\n    \n    // Free C: should coalesce B+C+D into one block\n    gc_free(gc, c);\n    \n    // Should now have 1 free block (B+C+D merged)\n    assert(count_free_blocks(gc) == 1);\n    \n    // Verify we can allocate 192 bytes (3 * 64)\n    void* large = gc_alloc(gc, 192);\n    assert(large != NULL);\n    \n    printf(\"âœ“ Basic coalescing test passed\\n\");\n}\n\nvoid test_coalescing_all_cases() {\n    GC* gc = create_gc(1024 * 1024);\n    \n    // Test COALESCE_NONE\n    void* a1 = gc_alloc(gc, 64);\n    void* a2 = gc_alloc(gc, 64);\n    void* a3 = gc_alloc(gc, 64);\n    gc_free(gc, a2);  // Surrounded by used blocks\n    assert(gc->stats.fragmentation_events == 1);\n    \n    // Test COALESCE_PREV\n    gc_free(gc, a1);  // Should merge with a2\n    assert(gc->stats.coalesce_prev_count == 1);\n    \n    // Test COALESCE_NEXT\n    void* b1 = gc_alloc(gc, 64);\n    void* b2 = gc_alloc(gc, 64);\n    void* b3 = gc_alloc(gc, 64);\n    gc_free(gc, b2);\n    gc_free(gc, b3);  // Should merge with b2\n    assert(gc->stats.coalesce_next_count == 1);\n    \n    // Test COALESCE_BOTH\n    void* c1 = gc_alloc(gc, 64);\n    void* c2 = gc_alloc(gc, 64);\n    void* c3 = gc_alloc(gc, 64);\n    void* c4 = gc_alloc(gc, 64);\n    gc_free(gc, c1);\n    gc_free(gc, c3);\n    gc_free(gc, c2);  // Should merge c1+c2+c3\n    assert(gc->stats.coalesce_both_count == 1);\n    \n    printf(\"âœ“ All coalescing cases test passed\\n\");\n}\n\nvoid test_fragmentation_measurement() {\n    GC* gc = create_gc(1024 * 1024);\n    \n    // Create severe fragmentation\n    void** objects = malloc(100 * sizeof(void*));\n    for (int i = 0; i < 100; i++) {\n        objects[i] = gc_alloc(gc, 1024);\n    }\n    \n    // Free every other object\n    for (int i = 0; i < 100; i += 2) {\n        gc_free(gc, objects[i]);\n    }\n    \n    // Measure fragmentation\n    float frag = calculate_fragmentation(gc);\n    \n    // Should be highly fragmented (many small blocks)\n    assert(frag > 0.9f);  // > 90% fragmented\n    \n    printf(\"âœ“ Fragmentation measurement: %.1f%%\\n\", frag * 100.0f);\n    \n    // Free remaining objects\n    for (int i = 1; i < 100; i += 2) {\n        gc_free(gc, objects[i]);\n    }\n    \n    // Should now be fully coalesced\n    assert(count_free_blocks(gc) == 1);\n    frag = calculate_fragmentation(gc);\n    assert(frag < 0.01f);  // < 1% fragmented\n    \n    printf(\"âœ“ After coalescing: %.1f%% fragmented\\n\", frag * 100.0f);\n}\n\nvoid test_compaction() {\n    GC* gc = create_gc(1024 * 1024);\n    \n    // Allocate and fragment\n    void** objects = malloc(1000 * sizeof(void*));\n    for (int i = 0; i < 1000; i++) {\n        objects[i] = gc_alloc(gc, 128);\n    }\n    \n    // Mark every 10th object as root\n    for (int i = 0; i < 1000; i += 10) {\n        gc_add_root(gc, &objects[i]);\n    }\n    \n    // Free non-roots\n    for (int i = 0; i < 1000; i++) {\n        if (i % 10 != 0) {\n            gc_free(gc, objects[i]);\n        }\n    }\n    \n    // Measure fragmentation before compaction\n    float frag_before = calculate_fragmentation(gc);\n    printf(\"Fragmentation before: %.1f%%\\n\", frag_before * 100.0f);\n    \n    // Compact\n    compact_heap(gc);\n    \n    // Measure after\n    float frag_after = calculate_fragmentation(gc);\n    printf(\"Fragmentation after: %.1f%%\\n\", frag_after * 100.0f);\n    \n    // Should be nearly zero fragmentation\n    assert(frag_after < 0.01f);\n    \n    // Verify objects are still accessible\n    for (int i = 0; i < 1000; i += 10) {\n        assert(objects[i] != NULL);\n        // Object should have moved\n    }\n    \n    printf(\"âœ“ Compaction test passed\\n\");\n}\n\nvoid test_boundary_tag_corruption() {\n    GC* gc = create_gc(1024 * 1024);\n    \n    void* a = gc_alloc(gc, 64);\n    void* b = gc_alloc(gc, 64);\n    \n    // Verify footer is correct\n    FreeBlock* block_a = (FreeBlock*)((uint8_t*)a - sizeof(FreeBlock));\n    BlockFooter* footer_a = get_block_footer(block_a);\n    assert(footer_a->magic == FREE_BLOCK_MAGIC);\n    assert(footer_a->size == block_a->size);\n    \n    // Free and verify coalescing works\n    gc_free(gc, a);\n    gc_free(gc, b);\n    \n    // Should have coalesced\n    assert(count_free_blocks(gc) == 1);\n    \n    printf(\"âœ“ Boundary tag integrity test passed\\n\");\n}\n```\n\n---\n\n## Performance Characteristics\n\n### Coalescing Overhead\n\n| Operation | Without Coalescing | With Coalescing |\n|-----------|-------------------|-----------------|\n| **Free** | O(1) | O(1) |\n| **Alloc (fragmented)** | O(n) search | O(1) best-fit |\n| **Memory waste** | 50-80% | 5-10% |\n\n**Key insight**: Coalescing adds ~10ns per free, but prevents catastrophic fragmentation.\n\n### Compaction Cost\n\n```\nHeap size: 100 MB\nLive objects: 40 MB (40%)\nCompaction time: ~50ms\n\nBreakdown:\n  Pass 1 (calculate): 10ms\n  Pass 2 (update ptrs): 25ms â† Most expensive!\n  Pass 3 (move): 15ms\n```\n\n**When to compact**: Only when fragmentation > 60% and allocation fails.\n\n---\n\n## What You've Mastered\n\nâœ… **Fragmentation fundamentals**: External vs internal fragmentation  \nâœ… **Coalescing algorithm**: Four-case boundary tag coalescing  \nâœ… **Boundary tags**: Efficient bidirectional merging  \nâœ… **Fragmentation measurement**: Quantifying memory waste  \nâœ… **Compaction**: Three-pass object relocation (optional)  \nâœ… **Debugging techniques**: Visualizing and fixing fragmentation bugs  \n\n---\n\n## Next Steps\n\n**You now have a production-grade memory allocator!** ğŸ‰\n\n**What's next?**\n\n1. **[â†’ Generational GC](#generational-gc)**: Combine fragmentation management with generational collection\n2. **[â†’ Concurrent GC](#concurrent-gc)**: Handle fragmentation while program runs\n3. **[â†’ Memory Pools](#memory-pools)**: Prevent fragmentation through segregated allocation\n4. **[â†’ Performance Tuning](#performance-tuning)**: Optimize coalescing for your workload\n\n**Before continuing**, verify your fragmentation management works:\n\n```bash\n$ ./test_fragmentation\nâœ“ Basic coalescing: 3 blocks â†’ 1 block\nâœ“ All cases: prev=1 next=1 both=1\nâœ“ Fragmentation: 95.2% â†’ 0.3% after coalescing\nâœ“ Compaction: 58.7% â†’ 0.1% fragmentation\nâœ“ Boundary tags: no corruption detected\nâœ“ Stress test: 10K alloc/free cycles, 0 leaks\n```\n\n**Pro tip**: Use `visualize_fragmentation()` during development to see exactly where fragmentation occurs. It's like an X-ray for your heap!\n\n---\n\n[â†‘ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-performance\"></div>\n\n# Performance Optimization: Making Your GC Blazingly Fast\n\n## Epiphany Analogy: The Formula 1 Pit Stop\n\nImagine a Formula 1 pit crew. They don't just change tiresâ€”they've optimized every microsecond:\n\n- **Tire changers** position themselves before the car arrives (cache prefetching)\n- **Tools** are arranged in order of use (cache-friendly data layout)\n- **Multiple crew members** work simultaneously (parallelization)\n- **Movements** are choreographed to avoid collisions (false sharing prevention)\n\nYour GC is the same: a well-optimized collector can be **10-100x faster** than a naive implementation. The difference between \"my program stutters\" and \"I didn't even notice GC ran.\"\n\n---\n\n## Technical Rationale: Why Performance Matters\n\n### The GC Tax\n\nEvery GC cycle steals time from your application:\n\n```\nNaive GC:     100ms pause every 1 second  â†’ 10% overhead\nOptimized GC:   5ms pause every 1 second  â†’ 0.5% overhead\n```\n\n**Real-world impact:**\n- **Video games**: 100ms pause = dropped frames, player notices lag\n- **Web servers**: 100ms pause = 1000 requests queued up\n- **Trading systems**: 100ms pause = millions of dollars lost\n\n### The Three Optimization Targets\n\n1. **Mark phase**: Traverse object graph (CPU + cache bound)\n2. **Sweep phase**: Scan entire heap (memory bandwidth bound)\n3. **Allocation**: Find free blocks (data structure bound)\n\nWe'll optimize each independently.\n\n---\n\n## Internal Mechanics: Cache-Friendly Marking\n\n### The Problem: Cache Misses Kill Performance\n\n```c\n// NAIVE: Random memory access pattern\nvoid mark_naive(GC* gc, void* ptr) {\n    ObjectHeader* obj = get_header(ptr);\n    if (obj->marked) return;\n    \n    obj->marked = 1;\n    \n    // Chase pointers randomly through heap\n    for (size_t i = 0; i < obj->ptr_count; i++) {\n        mark_naive(gc, obj->pointers[i]);  // â† Cache miss!\n    }\n}\n```\n\n**Problem**: Each pointer dereference is a **cache miss** (100+ cycles).\n\n**Solution**: Breadth-first traversal with prefetching.\n\n### Cache-Friendly BFS Marking\n\n```c\ntypedef struct {\n    void** queue;\n    size_t capacity;\n    size_t head;\n    size_t tail;\n} MarkQueue;\n\n// OPTIMIZED: Sequential access + prefetching\nvoid mark_bfs_optimized(GC* gc, void* root) {\n    MarkQueue queue;\n    init_mark_queue(&queue, 1024);\n    \n    enqueue(&queue, root);\n    \n    while (!is_empty(&queue)) {\n        // Process in batches for better cache utilization\n        size_t batch_size = min(16, queue_size(&queue));\n        \n        for (size_t i = 0; i < batch_size; i++) {\n            void* ptr = dequeue(&queue);\n            ObjectHeader* obj = get_header(ptr);\n            \n            if (obj->marked) continue;\n            obj->marked = 1;\n            \n            // Prefetch next objects while processing current\n            if (i + 4 < batch_size) {\n                void* prefetch_ptr = peek(&queue, i + 4);\n                __builtin_prefetch(get_header(prefetch_ptr), 0, 3);\n            }\n            \n            // Add children to queue\n            for (size_t j = 0; j < obj->ptr_count; j++) {\n                enqueue(&queue, obj->pointers[j]);\n            }\n        }\n    }\n    \n    destroy_mark_queue(&queue);\n}\n```\n\n**Key optimizations:**\n1. **BFS instead of DFS**: Better cache locality (process nearby objects together)\n2. **Batch processing**: Amortize queue overhead\n3. **Prefetching**: Tell CPU to load data before we need it\n4. **Sequential queue**: Array-based queue is cache-friendly\n\n{{DIAGRAM:cache-friendly-marking}}\n\n---\n\n## Bitmap Marking: Separate Metadata from Data\n\n### The Problem: False Sharing\n\n```c\n// BAD: Marking writes to object headers\nstruct ObjectHeader {\n    size_t size;\n    uint8_t marked;  // â† Writing this invalidates cache line!\n    // ... other fields\n};\n```\n\n**Problem**: Marking one object invalidates the cache line containing nearby objects.\n\n### Solution: External Bitmap\n\n```c\ntypedef struct {\n    uint64_t* bitmap;      // 1 bit per 8 bytes of heap\n    size_t bitmap_size;\n} MarkBitmap;\n\n// Initialize bitmap (1 bit per 8-byte word)\nMarkBitmap* create_mark_bitmap(size_t heap_size) {\n    MarkBitmap* bm = malloc(sizeof(MarkBitmap));\n    bm->bitmap_size = (heap_size / 8 + 63) / 64;  // Round up to uint64_t\n    bm->bitmap = calloc(bm->bitmap_size, sizeof(uint64_t));\n    return bm;\n}\n\n// Mark object using bitmap\nstatic inline void bitmap_mark(MarkBitmap* bm, void* heap_start, void* ptr) {\n    size_t offset = (uint8_t*)ptr - (uint8_t*)heap_start;\n    size_t word_index = offset / (8 * 64);\n    size_t bit_index = (offset / 8) % 64;\n    \n    bm->bitmap[word_index] |= (1ULL << bit_index);\n}\n\n// Check if marked\nstatic inline bool bitmap_is_marked(MarkBitmap* bm, void* heap_start, void* ptr) {\n    size_t offset = (uint8_t*)ptr - (uint8_t*)heap_start;\n    size_t word_index = offset / (8 * 64);\n    size_t bit_index = (offset / 8) % 64;\n    \n    return (bm->bitmap[word_index] & (1ULL << bit_index)) != 0;\n}\n\n// Clear all marks (fast!)\nvoid bitmap_clear(MarkBitmap* bm) {\n    memset(bm->bitmap, 0, bm->bitmap_size * sizeof(uint64_t));\n}\n```\n\n**Benefits:**\n- **No false sharing**: Bitmap is separate from object data\n- **Fast clearing**: `memset()` is highly optimized\n- **Cache-friendly**: Bitmap is densely packed\n- **Parallel-friendly**: Different threads can mark different bitmap regions\n\n{{DIAGRAM:bitmap-marking}}\n\n---\n\n## Parallel Sweep: Multi-threaded Heap Scanning\n\n### The Problem: Sweep is Sequential\n\n```c\n// SLOW: Single-threaded sweep\nvoid sweep_sequential(GC* gc) {\n    uint8_t* ptr = gc->heap_start;\n    uint8_t* end = (uint8_t*)gc->heap_start + gc->heap_size;\n    \n    while (ptr < end) {\n        ObjectHeader* obj = (ObjectHeader*)ptr;\n        \n        if (!obj->marked) {\n            gc_free(gc, ptr + sizeof(ObjectHeader));\n        } else {\n            obj->marked = 0;  // Clear for next cycle\n        }\n        \n        ptr += sizeof(ObjectHeader) + obj->size;\n    }\n}\n```\n\n**Problem**: Sweeping 1GB heap takes ~50ms on single core.\n\n### Solution: Parallel Region Sweep\n\n```c\n#include <pthread.h>\n\ntypedef struct {\n    GC* gc;\n    uint8_t* start;\n    uint8_t* end;\n    MarkBitmap* bitmap;\n    \n    // Per-thread results\n    size_t freed_bytes;\n    size_t freed_objects;\n    FreeBlock* local_free_list;\n} SweepTask;\n\nvoid* sweep_worker(void* arg) {\n    SweepTask* task = (SweepTask*)arg;\n    \n    uint8_t* ptr = task->start;\n    FreeBlock* local_list = NULL;\n    \n    while (ptr < task->end) {\n        ObjectHeader* obj = (ObjectHeader*)ptr;\n        \n        if (!bitmap_is_marked(task->bitmap, task->gc->heap_start, ptr)) {\n            // Object is dead - add to local free list\n            FreeBlock* block = (FreeBlock*)ptr;\n            block->size = sizeof(ObjectHeader) + obj->size;\n            block->next = local_list;\n            local_list = block;\n            \n            task->freed_bytes += block->size;\n            task->freed_objects++;\n        }\n        \n        ptr += sizeof(ObjectHeader) + obj->size;\n    }\n    \n    task->local_free_list = local_list;\n    return NULL;\n}\n\nvoid sweep_parallel(GC* gc, MarkBitmap* bitmap, int num_threads) {\n    pthread_t threads[num_threads];\n    SweepTask tasks[num_threads];\n    \n    size_t region_size = gc->heap_size / num_threads;\n    \n    // Launch worker threads\n    for (int i = 0; i < num_threads; i++) {\n        tasks[i].gc = gc;\n        tasks[i].start = (uint8_t*)gc->heap_start + (i * region_size);\n        tasks[i].end = (i == num_threads - 1) \n            ? (uint8_t*)gc->heap_start + gc->heap_size\n            : tasks[i].start + region_size;\n        tasks[i].bitmap = bitmap;\n        tasks[i].freed_bytes = 0;\n        tasks[i].freed_objects = 0;\n        tasks[i].local_free_list = NULL;\n        \n        pthread_create(&threads[i], NULL, sweep_worker, &tasks[i]);\n    }\n    \n    // Wait for completion\n    for (int i = 0; i < num_threads; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    \n    // Merge free lists (single-threaded, but fast)\n    for (int i = 0; i < num_threads; i++) {\n        FreeBlock* block = tasks[i].local_free_list;\n        while (block) {\n            FreeBlock* next = block->next;\n            add_to_free_list(gc, block);  // Your existing function\n            block = next;\n        }\n        \n        gc->stats.bytes_freed += tasks[i].freed_bytes;\n        gc->stats.objects_freed += tasks[i].freed_objects;\n    }\n}\n```\n\n**Key insights:**\n- **No locks during sweep**: Each thread owns a heap region\n- **Local free lists**: Avoid contention\n- **Merge at end**: Single-threaded merge is fast (just pointer manipulation)\n\n**Performance**: 4 threads â†’ 3.5x speedup (not 4x due to merge overhead)\n\n{{DIAGRAM:parallel-sweep}}\n\n---\n\n## The Debugging Lab: Measuring Performance\n\n### Micro-Benchmarking Framework\n\n```c\n#include <time.h>\n\ntypedef struct {\n    const char* name;\n    uint64_t total_ns;\n    uint64_t count;\n} PerfCounter;\n\nstatic inline uint64_t get_nanos() {\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    return ts.tv_sec * 1000000000ULL + ts.tv_nsec;\n}\n\n#define PERF_START(counter) \\\n    uint64_t _start_##counter = get_nanos();\n\n#define PERF_END(counter) \\\n    do { \\\n        uint64_t _end = get_nanos(); \\\n        counter.total_ns += (_end - _start_##counter); \\\n        counter.count++; \\\n    } while(0)\n\n// Usage\nPerfCounter mark_time = {\"Mark\", 0, 0};\nPerfCounter sweep_time = {\"Sweep\", 0, 0};\n\nvoid gc_collect_instrumented(GC* gc) {\n    PERF_START(mark_time);\n    mark_phase(gc);\n    PERF_END(mark_time);\n    \n    PERF_START(sweep_time);\n    sweep_phase(gc);\n    PERF_END(sweep_time);\n}\n\nvoid print_perf_stats(PerfCounter* counter) {\n    double avg_ms = (counter->total_ns / counter->count) / 1000000.0;\n    printf(\"%s: %.2f ms avg (%lu calls)\\n\", \n           counter->name, avg_ms, counter->count);\n}\n```\n\n### Cache Miss Profiling (Linux)\n\n```c\n#include <linux/perf_event.h>\n#include <sys/syscall.h>\n\ntypedef struct {\n    int fd;\n    uint64_t cache_misses;\n    uint64_t cache_refs;\n} CacheProfiler;\n\nCacheProfiler* create_cache_profiler() {\n    CacheProfiler* prof = malloc(sizeof(CacheProfiler));\n    \n    struct perf_event_attr pe = {0};\n    pe.type = PERF_TYPE_HARDWARE;\n    pe.size = sizeof(pe);\n    pe.config = PERF_COUNT_HW_CACHE_MISSES;\n    pe.disabled = 1;\n    pe.exclude_kernel = 1;\n    \n    prof->fd = syscall(__NR_perf_event_open, &pe, 0, -1, -1, 0);\n    return prof;\n}\n\nvoid profile_mark_phase(GC* gc, CacheProfiler* prof) {\n    ioctl(prof->fd, PERF_EVENT_IOC_RESET, 0);\n    ioctl(prof->fd, PERF_EVENT_IOC_ENABLE, 0);\n    \n    mark_phase(gc);\n    \n    ioctl(prof->fd, PERF_EVENT_IOC_DISABLE, 0);\n    read(prof->fd, &prof->cache_misses, sizeof(uint64_t));\n    \n    printf(\"Cache misses: %lu\\n\", prof->cache_misses);\n}\n```\n\n### Common Performance Bugs\n\n#### Bug 1: Unnecessary Pointer Chasing\n\n```c\n// BAD: Dereference header multiple times\nvoid mark_slow(void* ptr) {\n    if (get_header(ptr)->marked) return;  // Dereference 1\n    get_header(ptr)->marked = 1;          // Dereference 2\n    \n    for (size_t i = 0; i < get_header(ptr)->ptr_count; i++) {  // Dereference 3\n        mark_slow(get_header(ptr)->pointers[i]);  // Dereference 4\n    }\n}\n\n// GOOD: Cache header pointer\nvoid mark_fast(void* ptr) {\n    ObjectHeader* obj = get_header(ptr);  // Single dereference\n    if (obj->marked) return;\n    obj->marked = 1;\n    \n    for (size_t i = 0; i < obj->ptr_count; i++) {\n        mark_fast(obj->pointers[i]);\n    }\n}\n```\n\n**Impact**: 4x fewer memory accesses â†’ 2x faster marking\n\n#### Bug 2: False Sharing in Parallel Sweep\n\n```c\n// BAD: Shared counter\ntypedef struct {\n    size_t freed_bytes;  // â† All threads write here!\n    pthread_mutex_t lock;\n} SharedStats;\n\nvoid* sweep_worker_slow(void* arg) {\n    // ...\n    pthread_mutex_lock(&stats->lock);\n    stats->freed_bytes += block->size;  // Contention!\n    pthread_mutex_unlock(&stats->lock);\n}\n\n// GOOD: Per-thread counters\ntypedef struct {\n    size_t freed_bytes;  // Each thread has its own\n    char padding[64];    // Prevent false sharing\n} ThreadStats;\n\nvoid* sweep_worker_fast(void* arg) {\n    ThreadStats* my_stats = &thread_stats[thread_id];\n    my_stats->freed_bytes += block->size;  // No contention!\n}\n```\n\n**Impact**: Eliminates lock contention â†’ 10x faster on 8+ cores\n\n{{DIAGRAM:false-sharing}}\n\n---\n\n## Code Scaffold: Your Optimization Tasks\n\n```c\n// ============================================\n// PERFORMANCE OPTIMIZATION TASKS\n// ============================================\n\n// TASK 1: Implement cache-friendly BFS marking\nvoid mark_bfs_optimized(GC* gc, MarkBitmap* bitmap, void* root) {\n    // TODO: Create mark queue\n    MarkQueue queue;\n    init_mark_queue(&queue, 1024);\n    \n    enqueue(&queue, root);\n    \n    while (!is_empty(&queue)) {\n        // TODO: Process in batches of 16\n        size_t batch_size = 0;  // Calculate batch size\n        \n        for (size_t i = 0; i < batch_size; i++) {\n            void* ptr = dequeue(&queue);\n            \n            // TODO: Skip if already marked\n            \n            // TODO: Mark using bitmap\n            \n            // TODO: Prefetch next object (i + 4)\n            \n            // TODO: Enqueue children\n        }\n    }\n    \n    destroy_mark_queue(&queue);\n}\n\n// TASK 2: Implement bitmap operations\nstatic inline void bitmap_mark(MarkBitmap* bm, void* heap_start, void* ptr) {\n    size_t offset = (uint8_t*)ptr - (uint8_t*)heap_start;\n    \n    // TODO: Calculate word_index (which uint64_t)\n    size_t word_index = 0;\n    \n    // TODO: Calculate bit_index (which bit in that uint64_t)\n    size_t bit_index = 0;\n    \n    // TODO: Set the bit\n    // bm->bitmap[word_index] |= ...\n}\n\nstatic inline bool bitmap_is_marked(MarkBitmap* bm, void* heap_start, void* ptr) {\n    size_t offset = (uint8_t*)ptr - (uint8_t*)heap_start;\n    \n    // TODO: Calculate indices\n    size_t word_index = 0;\n    size_t bit_index = 0;\n    \n    // TODO: Check if bit is set\n    return false;  // Replace\n}\n\n// TASK 3: Implement parallel sweep worker\nvoid* sweep_worker(void* arg) {\n    SweepTask* task = (SweepTask*)arg;\n    \n    uint8_t* ptr = task->start;\n    FreeBlock* local_list = NULL;\n    \n    // TODO: Scan region from start to end\n    while (ptr < task->end) {\n        ObjectHeader* obj = (ObjectHeader*)ptr;\n        \n        // TODO: Check if object is marked in bitmap\n        bool is_marked = false;  // Use bitmap_is_marked\n        \n        if (!is_marked) {\n            // TODO: Add to local free list\n            \n            // TODO: Update statistics\n            task->freed_bytes += 0;  // Calculate size\n            task->freed_objects++;\n        }\n        \n        // TODO: Advance to next object\n        ptr += 0;  // Calculate offset\n    }\n    \n    task->local_free_list = local_list;\n    return NULL;\n}\n\n// TASK 4: Implement parallel sweep coordinator\nvoid sweep_parallel(GC* gc, MarkBitmap* bitmap, int num_threads) {\n    pthread_t threads[num_threads];\n    SweepTask tasks[num_threads];\n    \n    // TODO: Calculate region size\n    size_t region_size = 0;\n    \n    // TODO: Launch worker threads\n    for (int i = 0; i < num_threads; i++) {\n        // Initialize task\n        tasks[i].gc = gc;\n        tasks[i].start = NULL;  // Calculate start\n        tasks[i].end = NULL;    // Calculate end\n        tasks[i].bitmap = bitmap;\n        \n        // TODO: Create thread\n        // pthread_create(...)\n    }\n    \n    // TODO: Wait for all threads\n    for (int i = 0; i < num_threads; i++) {\n        // pthread_join(...)\n    }\n    \n    // TODO: Merge free lists\n    for (int i = 0; i < num_threads; i++) {\n        FreeBlock* block = tasks[i].local_free_list;\n        while (block) {\n            FreeBlock* next = block->next;\n            // TODO: Add to global free list\n            block = next;\n        }\n    }\n}\n\n// TASK 5: Implement prefetching hint\nstatic inline void prefetch_object(void* ptr) {\n    // TODO: Use compiler builtin to prefetch\n    // __builtin_prefetch(ptr, read_write, locality)\n    // read_write: 0 = read, 1 = write\n    // locality: 0-3 (3 = keep in all cache levels)\n}\n\n// TASK 6: Implement mark queue (ring buffer)\ntypedef struct {\n    void** buffer;\n    size_t capacity;\n    size_t head;\n    size_t tail;\n    size_t size;\n} MarkQueue;\n\nvoid init_mark_queue(MarkQueue* q, size_t capacity) {\n    // TODO: Allocate buffer\n    q->buffer = malloc(capacity * sizeof(void*));\n    q->capacity = capacity;\n    q->head = 0;\n    q->tail = 0;\n    q->size = 0;\n}\n\nvoid enqueue(MarkQueue* q, void* ptr) {\n    // TODO: Check if full (resize if needed)\n    if (q->size >= q->capacity) {\n        // Resize queue\n        size_t new_capacity = q->capacity * 2;\n        void** new_buffer = malloc(new_capacity * sizeof(void*));\n        \n        // TODO: Copy elements to new buffer\n        \n        free(q->buffer);\n        q->buffer = new_buffer;\n        q->capacity = new_capacity;\n    }\n    \n    // TODO: Add to tail\n    q->buffer[q->tail] = ptr;\n    q->tail = (q->tail + 1) % q->capacity;\n    q->size++;\n}\n\nvoid* dequeue(MarkQueue* q) {\n    // TODO: Check if empty\n    if (q->size == 0) return NULL;\n    \n    // TODO: Remove from head\n    void* ptr = q->buffer[q->head];\n    q->head = (q->head + 1) % q->capacity;\n    q->size--;\n    \n    return ptr;\n}\n\nvoid* peek(MarkQueue* q, size_t offset) {\n    // TODO: Look ahead without removing\n    if (offset >= q->size) return NULL;\n    \n    size_t index = (q->head + offset) % q->capacity;\n    return q->buffer[index];\n}\n\n// TASK 7: Implement performance counters\ntypedef struct {\n    uint64_t mark_time_ns;\n    uint64_t sweep_time_ns;\n    uint64_t total_collections;\n    \n    uint64_t cache_misses;\n    uint64_t cache_refs;\n} PerfStats;\n\nvoid gc_collect_with_profiling(GC* gc, PerfStats* stats) {\n    // TODO: Measure mark phase\n    uint64_t mark_start = get_nanos();\n    mark_phase(gc);\n    uint64_t mark_end = get_nanos();\n    \n    // TODO: Measure sweep phase\n    uint64_t sweep_start = get_nanos();\n    sweep_phase(gc);\n    uint64_t sweep_end = get_nanos();\n    \n    // TODO: Update statistics\n    stats->mark_time_ns += (mark_end - mark_start);\n    stats->sweep_time_ns += (sweep_end - sweep_start);\n    stats->total_collections++;\n}\n\nvoid print_perf_report(PerfStats* stats) {\n    // TODO: Calculate averages\n    double avg_mark_ms = 0.0;  // stats->mark_time_ns / stats->total_collections / 1e6\n    double avg_sweep_ms = 0.0;\n    \n    printf(\"=== GC Performance Report ===\\n\");\n    printf(\"Collections: %lu\\n\", stats->total_collections);\n    printf(\"Avg mark time: %.2f ms\\n\", avg_mark_ms);\n    printf(\"Avg sweep time: %.2f ms\\n\", avg_sweep_ms);\n    \n    // TODO: Calculate cache miss rate\n    if (stats->cache_refs > 0) {\n        double miss_rate = 0.0;  // (double)stats->cache_misses / stats->cache_refs\n        printf(\"Cache miss rate: %.1f%%\\n\", miss_rate * 100.0);\n    }\n}\n\n// TASK 8: Implement cache-aligned allocation\n#define CACHE_LINE_SIZE 64\n\nvoid* alloc_cache_aligned(size_t size) {\n    // TODO: Allocate with alignment\n    void* ptr = NULL;\n    \n    #ifdef _WIN32\n        ptr = _aligned_malloc(size, CACHE_LINE_SIZE);\n    #else\n        posix_memalign(&ptr, CACHE_LINE_SIZE, size);\n    #endif\n    \n    return ptr;\n}\n\n// TASK 9: Implement false sharing prevention\ntypedef struct {\n    size_t freed_bytes;\n    char padding[CACHE_LINE_SIZE - sizeof(size_t)];  // Prevent false sharing\n} ThreadLocalStats;\n\nvoid init_thread_stats(ThreadLocalStats* stats, int num_threads) {\n    // TODO: Allocate cache-aligned array\n    // Each thread's stats should be on separate cache line\n}\n```\n\n---\n\n## Testing Your Optimizations\n\n```c\nvoid benchmark_marking() {\n    GC* gc = create_gc(100 * 1024 * 1024);  // 100 MB\n    \n    // Create complex object graph\n    void** objects = malloc(10000 * sizeof(void*));\n    for (int i = 0; i < 10000; i++) {\n        objects[i] = gc_alloc(gc, 128);\n        \n        // Create random references\n        ObjectHeader* obj = get_header(objects[i]);\n        for (int j = 0; j < 5; j++) {\n            int target = rand() % i;\n            if (target >= 0) {\n                add_reference(obj, objects[target]);\n            }\n        }\n    }\n    \n    // Benchmark naive marking\n    uint64_t start = get_nanos();\n    for (int i = 0; i < 100; i++) {\n        mark_naive(gc, objects[0]);\n        clear_marks(gc);\n    }\n    uint64_t naive_time = get_nanos() - start;\n    \n    // Benchmark optimized marking\n    MarkBitmap* bitmap = create_mark_bitmap(gc->heap_size);\n    start = get_nanos();\n    for (int i = 0; i < 100; i++) {\n        mark_bfs_optimized(gc, bitmap, objects[0]);\n        bitmap_clear(bitmap);\n    }\n    uint64_t optimized_time = get_nanos() - start;\n    \n    printf(\"Naive marking: %.2f ms\\n\", naive_time / 1e6 / 100);\n    printf(\"Optimized marking: %.2f ms\\n\", optimized_time / 1e6 / 100);\n    printf(\"Speedup: %.1fx\\n\", (double)naive_time / optimized_time);\n    \n    // Should be 3-5x faster\n    assert(optimized_time * 3 < naive_time);\n}\n\nvoid benchmark_parallel_sweep() {\n    GC* gc = create_gc(100 * 1024 * 1024);\n    \n    // Fill heap\n    for (int i = 0; i < 100000; i++) {\n        gc_alloc(gc, 1024);\n    }\n    \n    // Benchmark sequential sweep\n    uint64_t start = get_nanos();\n    sweep_sequential(gc);\n    uint64_t seq_time = get_nanos() - start;\n    \n    // Benchmark parallel sweep (4 threads)\n    MarkBitmap* bitmap = create_mark_bitmap(gc->heap_size);\n    start = get_nanos();\n    sweep_parallel(gc, bitmap, 4);\n    uint64_t par_time = get_nanos() - start;\n    \n    printf(\"Sequential sweep: %.2f ms\\n\", seq_time / 1e6);\n    printf(\"Parallel sweep (4 threads): %.2f ms\\n\", par_time / 1e6);\n    printf(\"Speedup: %.1fx\\n\", (double)seq_time / par_time);\n    \n    // Should be 2.5-3.5x faster on 4 cores\n    assert(par_time * 2 < seq_time);\n}\n\nvoid test_bitmap_correctness() {\n    size_t heap_size = 1024 * 1024;\n    void* heap = malloc(heap_size);\n    MarkBitmap* bm = create_mark_bitmap(heap_size);\n    \n    // Mark every 100th byte\n    for (size_t i = 0; i < heap_size; i += 100) {\n        void* ptr = (uint8_t*)heap + i;\n        bitmap_mark(bm, heap, ptr);\n    }\n    \n    // Verify marks\n    for (size_t i = 0; i < heap_size; i++) {\n        void* ptr = (uint8_t*)heap + i;\n        bool should_be_marked = (i % 100 == 0);\n        bool is_marked = bitmap_is_marked(bm, heap, ptr);\n        \n        assert(is_marked == should_be_marked);\n    }\n    \n    // Clear and verify\n    bitmap_clear(bm);\n    for (size_t i = 0; i < heap_size; i += 100) {\n        void* ptr = (uint8_t*)heap + i;\n        assert(!bitmap_is_marked(bm, heap, ptr));\n    }\n    \n    printf(\"âœ“ Bitmap correctness test passed\\n\");\n}\n\nvoid stress_test_parallel_sweep() {\n    GC* gc = create_gc(1024 * 1024 * 1024);  // 1 GB\n    \n    // Allocate 1 million objects\n    void** objects = malloc(1000000 * sizeof(void*));\n    for (int i = 0; i < 1000000; i++) {\n        objects[i] = gc_alloc(gc, 128);\n    }\n    \n    // Mark half randomly\n    MarkBitmap* bitmap = create_mark_bitmap(gc->heap_size);\n    for (int i = 0; i < 1000000; i++) {\n        if (rand() % 2) {\n            bitmap_mark(bitmap, gc->heap_start, objects[i]);\n        }\n    }\n    \n    // Sweep with different thread counts\n    for (int threads = 1; threads <= 8; threads *= 2) {\n        uint64_t start = get_nanos();\n        sweep_parallel(gc, bitmap, threads);\n        uint64_t time = get_nanos() - start;\n        \n        printf(\"%d threads: %.2f ms\\n\", threads, time / 1e6);\n    }\n    \n    printf(\"âœ“ Parallel sweep stress test passed\\n\");\n}\n```\n\n---\n\n## Performance Characteristics\n\n### Optimization Impact\n\n| Optimization | Speedup | Complexity | Worth It? |\n|--------------|---------|------------|-----------|\n| **BFS marking** | 2-3x | Low | âœ… Always |\n| **Bitmap marking** | 1.5-2x | Medium | âœ… Yes |\n| **Prefetching** | 1.2-1.5x | Low | âœ… Yes |\n| **Parallel sweep (4 cores)** | 3-3.5x | High | âœ… If heap > 10MB |\n| **Cache alignment** | 1.1-1.3x | Low | âš ï¸ Diminishing returns |\n\n### Real-World Numbers\n\n```\nHeap: 100 MB\nObjects: 100,000\nReferences: 500,000\n\nNaive GC:\n  Mark: 45 ms\n  Sweep: 25 ms\n  Total: 70 ms\n\nOptimized GC:\n  Mark (BFS + bitmap): 12 ms\n  Sweep (4 threads): 7 ms\n  Total: 19 ms\n\nSpeedup: 3.7x\n```\n\n### When to Optimize What\n\n```\nSmall heaps (< 1 MB):\n  â†’ Skip parallelization (overhead > benefit)\n  â†’ Use BFS + bitmap only\n\nMedium heaps (1-100 MB):\n  â†’ BFS + bitmap + prefetching\n  â†’ Parallel sweep with 2-4 threads\n\nLarge heaps (> 100 MB):\n  â†’ All optimizations\n  â†’ 8+ threads for sweep\n  â†’ Consider concurrent GC\n```\n\n---\n\n## What You've Mastered\n\nâœ… **Cache-friendly algorithms**: BFS traversal with prefetching  \nâœ… **Bitmap marking**: Separate metadata for better cache behavior  \nâœ… **Parallel sweep**: Multi-threaded heap scanning  \nâœ… **Performance profiling**: Measuring and optimizing hot paths  \nâœ… **False sharing prevention**: Cache line alignment  \nâœ… **Micro-optimizations**: Pointer caching, batch processing  \n\n**You now have a production-grade, high-performance GC!** ğŸš€\n\n---\n\n## Next Steps\n\nYour GC is now **fast**. But can it scale to real-world applications?\n\n**Choose your path:**\n\n1. **[â†’ Generational GC](#generational-gc)**: 10x faster by exploiting object lifetimes\n2. **[â†’ Concurrent GC](#concurrent-gc)**: Eliminate pauses entirely\n3. **[â†’ Real-World Integration](#integration)**: Embed your GC in a language runtime\n4. **[â†’ Advanced Topics](#advanced)**: Incremental collection, region-based GC\n\n**Before continuing**, verify your optimizations work:\n\n```bash\n$ ./benchmark_gc\nNaive marking: 45.2 ms\nOptimized marking: 12.3 ms â†’ 3.7x faster âœ“\n\nSequential sweep: 25.1 ms\nParallel sweep (4 threads): 7.2 ms â†’ 3.5x faster âœ“\n\nCache miss rate: 8.3% (was 42.1%) âœ“\n\nâœ“ All performance tests passed\n```\n\n**Pro tip**: Use `perf stat` on Linux to measure cache misses:\n\n```bash\n$ perf stat -e cache-misses,cache-references ./your_gc_test\n```\n\nLook for < 10% cache miss rate for optimal performance.\n\n---\n\n[â†‘ Back to System Map](#satellite-map)\n\n\n<div id=\"ms-testing\"></div>\n\n# Testing & Validation: The Crucible of Confidence\n\n## Epiphany Analogy: The Aircraft Pre-Flight Checklist\n\nImagine you're a pilot about to fly a 747. You don't just turn the key and hope for the best. You run through a **pre-flight checklist**: fuel levels, hydraulics, engine temperature, control surfaces, backup systems. Each test validates a critical assumption about the aircraft's behavior.\n\nYour garbage collector is the same. It's a **life-support system** for your program's memory. A single bugâ€”a missed pointer, a race condition, a memory leakâ€”can crash your entire application. Testing isn't optional; it's the difference between \"it works on my machine\" and \"it works in production under load.\"\n\nThis section is your **pre-flight checklist** for memory safety.\n\n---\n\n## Technical Rationale: Why Testing GCs Is Uniquely Hard\n\n### The Three Horsemen of GC Bugs\n\n1. **Non-Determinism**: GC timing depends on allocation patterns, heap size, and thread scheduling. A bug might only appear after 10,000 collections.\n\n2. **Invisible Corruption**: A missed mark doesn't crash immediatelyâ€”it corrupts memory silently, causing a segfault 10 seconds later in unrelated code.\n\n3. **Concurrency Chaos**: Race conditions in parallel sweep can cause double-frees, use-after-frees, or memory leaksâ€”all of which are **Heisenbugs** (disappear when you add logging).\n\n### What We Must Validate\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         GC Test Pyramid                 â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Stress Tests (1-2 tests)               â”‚  â† Does it survive chaos?\nâ”‚    â””â”€ 1M objects, 8 threads, 1 hour     â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Integration Tests (5-10 tests)         â”‚  â† Does it work end-to-end?\nâ”‚    â””â”€ Leak detection, correctness       â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Unit Tests (20-50 tests)               â”‚  â† Does each piece work?\nâ”‚    â””â”€ Bitmap ops, queue ops, marking    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Key Insight**: You can't just test \"does it collect garbage?\" You must test:\n- **Correctness**: Does it collect *only* garbage?\n- **Completeness**: Does it collect *all* garbage?\n- **Safety**: Does it avoid double-frees and use-after-frees?\n- **Performance**: Does it meet latency/throughput targets?\n\n---\n\n## Internal Mechanics: The Testing Arsenal\n\n### 1. Leak Detection: The Canary in the Coal Mine\n\n**The Problem**: Your GC might be \"working\" but slowly leaking memory because it misses objects in complex graphs.\n\n**The Solution**: Track every allocation and verify the heap size converges to zero after collecting unreachable objects.\n\n{{DIAGRAM:leak-detection-flow}}\n\n```\nAllocation Phase:\n  alloc(A) â†’ heap_size = 128\n  alloc(B) â†’ heap_size = 256\n  alloc(C) â†’ heap_size = 384\n\nDrop References:\n  A = NULL\n  B = NULL\n  C = NULL\n\nGC Collection:\n  mark_phase() â†’ 0 objects marked\n  sweep_phase() â†’ freed 384 bytes\n\nValidation:\n  assert(heap_size == 0) âœ“\n```\n\n### 2. Correctness Validation: The Reachability Oracle\n\n**The Problem**: Your GC might collect *too much* (freeing live objects) or *too little* (missing garbage).\n\n**The Solution**: Build a **shadow graph** that tracks reachability independently, then compare results.\n\n{{DIAGRAM:shadow-graph-validation}}\n\n```\nYour GC's View:        Shadow Graph:\n  Root â†’ A â†’ B           Root â†’ A â†’ B\n         â†“                      â†“\n         C                      C\n\nAfter marking:\n  Your GC: {A, B, C}\n  Shadow:  {A, B, C}\n  \n  assert(your_marks == shadow_marks) âœ“\n```\n\n### 3. Stress Testing: The Chaos Monkey\n\n**The Problem**: Bugs hide in edge casesâ€”deeply nested graphs, circular references, high allocation rates, thread contention.\n\n**The Solution**: Generate **pathological workloads** designed to break your GC.\n\n{{DIAGRAM:stress-test-scenarios}}\n\n```\nScenario 1: Deep Nesting\n  Root â†’ A â†’ B â†’ C â†’ ... â†’ Z (1000 levels)\n  Tests: Stack overflow in recursive marking\n\nScenario 2: Wide Graphs\n  Root â†’ [A, B, C, ..., Z] (10,000 children)\n  Tests: Mark queue overflow\n\nScenario 3: Circular References\n  A â†’ B â†’ C â†’ A\n  Tests: Infinite loops in marking\n\nScenario 4: Thrashing\n  Allocate 1M objects, free 999K, repeat\n  Tests: Fragmentation, sweep performance\n```\n\n---\n\n## The Debugging Lab: Common Test Failures\n\n### Failure 1: \"Heap size doesn't reach zero after GC\"\n\n**Symptom**:\n```c\ntest_leak_detection() {\n    // ... allocate and free everything ...\n    gc_collect(gc);\n    assert(gc->used_bytes == 0);  // FAILS: used_bytes = 1024\n}\n```\n\n**Root Causes**:\n1. **Missed marks**: Your marking algorithm skipped an object\n2. **Dangling roots**: A root pointer wasn't cleared\n3. **Bitmap bug**: `bitmap_is_marked()` returns false positives\n\n**Debug Strategy**:\n```c\n// Add instrumentation to sweep phase\nvoid sweep_phase_debug(GC* gc, MarkBitmap* bm) {\n    for (Block* b = gc->first_block; b; b = b->next) {\n        if (!bitmap_is_marked(bm, gc->heap_start, b)) {\n            printf(\"LEAK: Block at %p (size=%zu) not marked\\n\", \n                   b, b->size);\n            print_object_graph(gc, b);  // Who should have marked this?\n        }\n    }\n}\n```\n\n### Failure 2: \"Segfault in user code after GC\"\n\n**Symptom**:\n```c\ntest_correctness() {\n    Object* obj = gc_alloc(gc, 128);\n    gc_collect(gc);\n    obj->data[0] = 42;  // SEGFAULT: obj was freed!\n}\n```\n\n**Root Causes**:\n1. **Premature collection**: Object was live but not marked\n2. **Root scanning bug**: Stack/global roots weren't scanned\n3. **Race condition**: Object freed while another thread was using it\n\n**Debug Strategy**:\n```c\n// Add \"tombstone\" pattern to freed memory\nvoid sweep_phase_debug(GC* gc, MarkBitmap* bm) {\n    for (Block* b = gc->first_block; b; b = b->next) {\n        if (!bitmap_is_marked(bm, gc->heap_start, b)) {\n            memset(b, 0xDEADBEEF, b->size);  // Fill with poison\n            free_block(gc, b);\n        }\n    }\n}\n\n// Now segfault will show 0xDEADBEEF in debugger\n```\n\n### Failure 3: \"Parallel sweep produces different results than sequential\"\n\n**Symptom**:\n```c\ntest_parallel_correctness() {\n    sweep_sequential(gc, bm);\n    size_t seq_freed = gc->freed_bytes;\n    \n    sweep_parallel(gc, bm, 4);\n    size_t par_freed = gc->freed_bytes;\n    \n    assert(seq_freed == par_freed);  // FAILS: 1024 != 1152\n}\n```\n\n**Root Causes**:\n1. **Race condition**: Two threads free the same block\n2. **False sharing**: Threads contend on `freed_bytes` counter\n3. **Incorrect partitioning**: Threads overlap in heap regions\n\n**Debug Strategy**:\n```c\n// Add per-thread accounting\ntypedef struct {\n    size_t freed_bytes;\n    Block* freed_blocks[1000];\n    size_t num_freed;\n} ThreadStats;\n\nvoid sweep_worker_debug(GC* gc, MarkBitmap* bm, \n                        size_t start, size_t end,\n                        ThreadStats* stats) {\n    for (Block* b = get_block_at(gc, start); \n         b < get_block_at(gc, end); \n         b = b->next) {\n        if (!bitmap_is_marked(bm, gc->heap_start, b)) {\n            stats->freed_blocks[stats->num_freed++] = b;\n            stats->freed_bytes += b->size;\n        }\n    }\n}\n\n// After all threads finish, check for duplicates\nvoid validate_no_double_free(ThreadStats* stats, int num_threads) {\n    for (int i = 0; i < num_threads; i++) {\n        for (int j = i + 1; j < num_threads; j++) {\n            for (size_t a = 0; a < stats[i].num_freed; a++) {\n                for (size_t b = 0; b < stats[j].num_freed; b++) {\n                    assert(stats[i].freed_blocks[a] != \n                           stats[j].freed_blocks[b]);\n                }\n            }\n        }\n    }\n}\n```\n\n---\n\n## Code Scaffold: Your Testing Suite\n\n### Task 1: Implement Leak Detection Test\n\n```c\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// Test: Allocate objects, drop all references, verify heap is empty\nvoid test_no_leaks_simple() {\n    printf(\"Running: test_no_leaks_simple...\\n\");\n    \n    GC* gc = create_gc(1024 * 1024);  // 1 MB heap\n    \n    // TODO: Allocate 100 objects\n    void** objects = malloc(100 * sizeof(void*));\n    for (int i = 0; i < 100; i++) {\n        objects[i] = gc_alloc(gc, 128);\n        assert(objects[i] != NULL);\n    }\n    \n    // TODO: Record heap usage before GC\n    size_t used_before = gc->used_bytes;\n    printf(\"  Heap usage before GC: %zu bytes\\n\", used_before);\n    assert(used_before >= 100 * 128);  // At least 100 objects\n    \n    // TODO: Drop all references (simulate objects going out of scope)\n    for (int i = 0; i < 100; i++) {\n        objects[i] = NULL;\n    }\n    \n    // TODO: Run GC (no roots, so everything should be collected)\n    gc_collect(gc);\n    \n    // TODO: Verify heap is empty\n    size_t used_after = gc->used_bytes;\n    printf(\"  Heap usage after GC: %zu bytes\\n\", used_after);\n    \n    if (used_after != 0) {\n        printf(\"  âŒ LEAK DETECTED: %zu bytes not freed\\n\", used_after);\n        assert(0);\n    }\n    \n    printf(\"  âœ“ No leaks detected\\n\");\n    \n    free(objects);\n    destroy_gc(gc);\n}\n\n// Test: Complex object graph with circular references\nvoid test_no_leaks_circular() {\n    printf(\"Running: test_no_leaks_circular...\\n\");\n    \n    GC* gc = create_gc(1024 * 1024);\n    \n    // TODO: Create circular reference: A â†’ B â†’ C â†’ A\n    typedef struct Node {\n        struct Node* next;\n        char data[100];\n    } Node;\n    \n    Node* a = (Node*)gc_alloc(gc, sizeof(Node));\n    Node* b = (Node*)gc_alloc(gc, sizeof(Node));\n    Node* c = (Node*)gc_alloc(gc, sizeof(Node));\n    \n    a->next = b;\n    b->next = c;\n    c->next = a;  // Circular!\n    \n    size_t used_before = gc->used_bytes;\n    printf(\"  Created circular graph: %zu bytes\\n\", used_before);\n    \n    // TODO: Drop all external references\n    a = NULL;\n    b = NULL;\n    c = NULL;\n    \n    // TODO: GC should collect entire cycle\n    gc_collect(gc);\n    \n    size_t used_after = gc->used_bytes;\n    printf(\"  After GC: %zu bytes\\n\", used_after);\n    \n    assert(used_after == 0);  // Cycle should be collected\n    printf(\"  âœ“ Circular references collected correctly\\n\");\n    \n    destroy_gc(gc);\n}\n```\n\n### Task 2: Implement Correctness Validation\n\n```c\n// Shadow graph: Independent reachability tracker\ntypedef struct {\n    void** reachable;\n    size_t capacity;\n    size_t count;\n} ShadowGraph;\n\nShadowGraph* create_shadow_graph(size_t capacity) {\n    ShadowGraph* sg = malloc(sizeof(ShadowGraph));\n    sg->reachable = malloc(capacity * sizeof(void*));\n    sg->capacity = capacity;\n    sg->count = 0;\n    return sg;\n}\n\nvoid shadow_mark(ShadowGraph* sg, void* ptr) {\n    // TODO: Add to reachable set (if not already present)\n    for (size_t i = 0; i < sg->count; i++) {\n        if (sg->reachable[i] == ptr) return;  // Already marked\n    }\n    \n    assert(sg->count < sg->capacity);\n    sg->reachable[sg->count++] = ptr;\n}\n\nbool shadow_is_reachable(ShadowGraph* sg, void* ptr) {\n    // TODO: Check if ptr is in reachable set\n    for (size_t i = 0; i < sg->count; i++) {\n        if (sg->reachable[i] == ptr) return true;\n    }\n    return false;\n}\n\nvoid test_correctness_vs_shadow() {\n    printf(\"Running: test_correctness_vs_shadow...\\n\");\n    \n    GC* gc = create_gc(1024 * 1024);\n    ShadowGraph* shadow = create_shadow_graph(1000);\n    \n    // TODO: Create object graph\n    //   Root â†’ A â†’ B\n    //          â†“\n    //          C\n    //   D (unreachable)\n    \n    void* root = gc_alloc(gc, 64);\n    void* a = gc_alloc(gc, 64);\n    void* b = gc_alloc(gc, 64);\n    void* c = gc_alloc(gc, 64);\n    void* d = gc_alloc(gc, 64);  // Garbage\n    \n    // TODO: Set up references (you'll need to implement this based on your GC)\n    // For now, assume we can manually track references\n    \n    // TODO: Manually mark reachable objects in shadow graph\n    shadow_mark(shadow, root);\n    shadow_mark(shadow, a);\n    shadow_mark(shadow, b);\n    shadow_mark(shadow, c);\n    // Note: D is NOT marked (it's garbage)\n    \n    // TODO: Run your GC's mark phase\n    MarkBitmap* bitmap = create_mark_bitmap(gc->heap_size);\n    mark_from_roots(gc, bitmap, &root, 1);\n    \n    // TODO: Compare results\n    void* all_objects[] = {root, a, b, c, d};\n    for (int i = 0; i < 5; i++) {\n        bool gc_marked = bitmap_is_marked(bitmap, gc->heap_start, all_objects[i]);\n        bool shadow_marked = shadow_is_reachable(shadow, all_objects[i]);\n        \n        if (gc_marked != shadow_marked) {\n            printf(\"  âŒ MISMATCH at object %d: GC=%d, Shadow=%d\\n\",\n                   i, gc_marked, shadow_marked);\n            assert(0);\n        }\n    }\n    \n    printf(\"  âœ“ GC marking matches shadow graph\\n\");\n    \n    destroy_mark_bitmap(bitmap);\n    free(shadow->reachable);\n    free(shadow);\n    destroy_gc(gc);\n}\n```\n\n### Task 3: Implement Stress Tests\n\n```c\n// Stress test: Deep nesting (tests stack overflow in recursive marking)\nvoid stress_test_deep_nesting() {\n    printf(\"Running: stress_test_deep_nesting...\\n\");\n    \n    GC* gc = create_gc(10 * 1024 * 1024);  // 10 MB\n    \n    // TODO: Create linked list of 10,000 nodes\n    typedef struct Node {\n        struct Node* next;\n        char data[100];\n    } Node;\n    \n    Node* root = (Node*)gc_alloc(gc, sizeof(Node));\n    Node* current = root;\n    \n    for (int i = 0; i < 10000; i++) {\n        Node* next = (Node*)gc_alloc(gc, sizeof(Node));\n        current->next = next;\n        current = next;\n    }\n    \n    printf(\"  Created chain of 10,000 nodes\\n\");\n    \n    // TODO: Run GC (should not stack overflow)\n    uint64_t start = get_nanos();\n    gc_collect(gc);\n    uint64_t elapsed = get_nanos() - start;\n    \n    printf(\"  GC completed in %.2f ms\\n\", elapsed / 1e6);\n    printf(\"  âœ“ No stack overflow\\n\");\n    \n    destroy_gc(gc);\n}\n\n// Stress test: Wide graphs (tests mark queue overflow)\nvoid stress_test_wide_graph() {\n    printf(\"Running: stress_test_wide_graph...\\n\");\n    \n    GC* gc = create_gc(100 * 1024 * 1024);  // 100 MB\n    \n    // TODO: Create root with 100,000 children\n    typedef struct {\n        void* children[100000];\n        char data[64];\n    } WideNode;\n    \n    WideNode* root = (WideNode*)gc_alloc(gc, sizeof(WideNode));\n    \n    for (int i = 0; i < 100000; i++) {\n        root->children[i] = gc_alloc(gc, 128);\n    }\n    \n    printf(\"  Created root with 100,000 children\\n\");\n    \n    // TODO: Run GC (mark queue should resize automatically)\n    uint64_t start = get_nanos();\n    gc_collect(gc);\n    uint64_t elapsed = get_nanos() - start;\n    \n    printf(\"  GC completed in %.2f ms\\n\", elapsed / 1e6);\n    printf(\"  âœ“ Mark queue handled wide graph\\n\");\n    \n    destroy_gc(gc);\n}\n\n// Stress test: Allocation thrashing (tests fragmentation)\nvoid stress_test_thrashing() {\n    printf(\"Running: stress_test_thrashing...\\n\");\n    \n    GC* gc = create_gc(10 * 1024 * 1024);  // 10 MB\n    \n    // TODO: Allocate/free in tight loop\n    for (int round = 0; round < 100; round++) {\n        void** objects = malloc(10000 * sizeof(void*));\n        \n        // Allocate 10,000 objects\n        for (int i = 0; i < 10000; i++) {\n            objects[i] = gc_alloc(gc, 128);\n        }\n        \n        // Free 99% of them (keep every 100th)\n        for (int i = 0; i < 10000; i++) {\n            if (i % 100 != 0) {\n                objects[i] = NULL;\n            }\n        }\n        \n        // GC should reclaim most memory\n        gc_collect(gc);\n        \n        free(objects);\n    }\n    \n    printf(\"  Survived 100 rounds of thrashing\\n\");\n    printf(\"  Final heap usage: %zu bytes\\n\", gc->used_bytes);\n    printf(\"  âœ“ No excessive fragmentation\\n\");\n    \n    destroy_gc(gc);\n}\n```\n\n### Task 4: Implement Parallel Correctness Test\n\n```c\n// Test: Parallel sweep produces same results as sequential\nvoid test_parallel_sweep_correctness() {\n    printf(\"Running: test_parallel_sweep_correctness...\\n\");\n    \n    GC* gc1 = create_gc(10 * 1024 * 1024);\n    GC* gc2 = create_gc(10 * 1024 * 1024);\n    \n    // TODO: Create identical heaps\n    void** objects1 = malloc(10000 * sizeof(void*));\n    void** objects2 = malloc(10000 * sizeof(void*));\n    \n    for (int i = 0; i < 10000; i++) {\n        objects1[i] = gc_alloc(gc1, 128);\n        objects2[i] = gc_alloc(gc2, 128);\n    }\n    \n    // TODO: Mark same objects in both heaps (every other object)\n    MarkBitmap* bm1 = create_mark_bitmap(gc1->heap_size);\n    MarkBitmap* bm2 = create_mark_bitmap(gc2->heap_size);\n    \n    for (int i = 0; i < 10000; i += 2) {\n        bitmap_mark(bm1, gc1->heap_start, objects1[i]);\n        bitmap_mark(bm2, gc2->heap_start, objects2[i]);\n    }\n    \n    // TODO: Sequential sweep on gc1\n    uint64_t start = get_nanos();\n    sweep_sequential(gc1, bm1);\n    uint64_t seq_time = get_nanos() - start;\n    size_t seq_freed = gc1->freed_bytes;\n    \n    // TODO: Parallel sweep on gc2\n    start = get_nanos();\n    sweep_parallel(gc2, bm2, 4);\n    uint64_t par_time = get_nanos() - start;\n    size_t par_freed = gc2->freed_bytes;\n    \n    // TODO: Compare results\n    printf(\"  Sequential: freed %zu bytes in %.2f ms\\n\", \n           seq_freed, seq_time / 1e6);\n    printf(\"  Parallel:   freed %zu bytes in %.2f ms\\n\", \n           par_freed, par_time / 1e6);\n    \n    if (seq_freed != par_freed) {\n        printf(\"  âŒ MISMATCH: Sequential freed %zu, Parallel freed %zu\\n\",\n               seq_freed, par_freed);\n        assert(0);\n    }\n    \n    printf(\"  âœ“ Parallel sweep is correct\\n\");\n    printf(\"  Speedup: %.2fx\\n\", (double)seq_time / par_time);\n    \n    free(objects1);\n    free(objects2);\n    destroy_mark_bitmap(bm1);\n    destroy_mark_bitmap(bm2);\n    destroy_gc(gc1);\n    destroy_gc(gc2);\n}\n```\n\n### Task 5: Implement Performance Regression Test\n\n```c\n// Test: Verify optimizations meet performance targets\nvoid test_performance_targets() {\n    printf(\"Running: test_performance_targets...\\n\");\n    \n    GC* gc = create_gc(100 * 1024 * 1024);  // 100 MB\n    \n    // TODO: Create realistic object graph\n    void** objects = malloc(100000 * sizeof(void*));\n    for (int i = 0; i < 100000; i++) {\n        objects[i] = gc_alloc(gc, 128);\n        \n        // Add random references\n        ObjectHeader* obj = get_header(objects[i]);\n        for (int j = 0; j < 5; j++) {\n            int target = rand() % i;\n            if (target >= 0) {\n                // TODO: Add reference (implementation-specific)\n            }\n        }\n    }\n    \n    // TODO: Benchmark GC performance\n    PerfStats stats = {0};\n    \n    for (int i = 0; i < 10; i++) {\n        gc_collect_with_profiling(gc, &stats);\n    }\n    \n    // TODO: Calculate averages\n    double avg_mark_ms = (stats.mark_time_ns / stats.total_collections) / 1e6;\n    double avg_sweep_ms = (stats.sweep_time_ns / stats.total_collections) / 1e6;\n    double avg_total_ms = avg_mark_ms + avg_sweep_ms;\n    \n    printf(\"  Average mark time:  %.2f ms\\n\", avg_mark_ms);\n    printf(\"  Average sweep time: %.2f ms\\n\", avg_sweep_ms);\n    printf(\"  Average total time: %.2f ms\\n\", avg_total_ms);\n    \n    // TODO: Assert performance targets\n    // Target: < 20ms for 100MB heap with 100K objects\n    if (avg_total_ms > 20.0) {\n        printf(\"  âŒ PERFORMANCE REGRESSION: %.2f ms > 20 ms target\\n\",\n               avg_total_ms);\n        assert(0);\n    }\n    \n    printf(\"  âœ“ Performance targets met\\n\");\n    \n    free(objects);\n    destroy_gc(gc);\n}\n```\n\n### Task 6: Implement Memory Safety Test (Valgrind/ASan)\n\n```c\n// Test: Run under Valgrind/AddressSanitizer to detect memory errors\nvoid test_memory_safety() {\n    printf(\"Running: test_memory_safety...\\n\");\n    printf(\"  (Run with: valgrind --leak-check=full ./test_gc)\\n\");\n    printf(\"  (Or compile with: -fsanitize=address)\\n\");\n    \n    GC* gc = create_gc(1024 * 1024);\n    \n    // TODO: Allocate and free objects\n    for (int i = 0; i < 1000; i++) {\n        void* obj = gc_alloc(gc, 128);\n        // Use the object\n        memset(obj, 0xAB, 128);\n    }\n    \n    // TODO: Run GC multiple times\n    for (int i = 0; i < 10; i++) {\n        gc_collect(gc);\n    }\n    \n    // TODO: Clean up\n    destroy_gc(gc);\n    \n    printf(\"  âœ“ No memory errors detected\\n\");\n    printf(\"  (Check Valgrind/ASan output for confirmation)\\n\");\n}\n```\n\n### Task 7: Implement Full Test Suite Runner\n\n```c\n// Main test runner\nint main() {\n    printf(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\\n\");\n    printf(\"â•‘   GC Test Suite - Comprehensive       â•‘\\n\");\n    printf(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n\\n\");\n    \n    // Unit tests\n    printf(\"â”€â”€â”€ Unit Tests â”€â”€â”€\\n\");\n    test_bitmap_correctness();  // From previous section\n    // TODO: Add more unit tests (queue, allocation, etc.)\n    \n    // Leak detection tests\n    printf(\"\\nâ”€â”€â”€ Leak Detection Tests â”€â”€â”€\\n\");\n    test_no_leaks_simple();\n    test_no_leaks_circular();\n    \n    // Correctness tests\n    printf(\"\\nâ”€â”€â”€ Correctness Tests â”€â”€â”€\\n\");\n    test_correctness_vs_shadow();\n    test_parallel_sweep_correctness();\n    \n    // Stress tests\n    printf(\"\\nâ”€â”€â”€ Stress Tests â”€â”€â”€\\n\");\n    stress_test_deep_nesting();\n    stress_test_wide_graph();\n    stress_test_thrashing();\n    \n    // Performance tests\n    printf(\"\\nâ”€â”€â”€ Performance Tests â”€â”€â”€\\n\");\n    test_performance_targets();\n    benchmark_marking();  // From previous section\n    benchmark_parallel_sweep();  // From previous section\n    \n    // Memory safety\n    printf(\"\\nâ”€â”€â”€ Memory Safety Tests â”€â”€â”€\\n\");\n    test_memory_safety();\n    \n    printf(\"\\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\\n\");\n    printf(\"â•‘   âœ“ ALL TESTS PASSED                  â•‘\\n\");\n    printf(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n\");\n    \n    return 0;\n}\n```\n\n---\n\n## Visual Reference\n\n{{DIAGRAM:test-pyramid}}\n\n```\n                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n                    â”‚  Stress Tests   â”‚  â† 1-2 tests, run for hours\n                    â”‚  (Chaos Monkey) â”‚     Catch rare race conditions\n                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n                   â”‚ Integration Tests â”‚  â† 5-10 tests, run in CI\n                   â”‚ (End-to-End)      â”‚     Catch correctness bugs\n                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n              â”‚      Unit Tests          â”‚  â† 20-50 tests, run constantly\n              â”‚  (Individual Functions)  â”‚     Catch logic errors\n              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n{{DIAGRAM:leak-detection-timeline}}\n\n```\nTime â†’\n  0ms: alloc(A), alloc(B), alloc(C)\n       Heap: [A][B][C]  (384 bytes)\n       \n 10ms: A = NULL, B = NULL, C = NULL\n       Heap: [A][B][C]  (384 bytes, all garbage)\n       \n 20ms: gc_collect()\n       Mark phase: 0 objects marked\n       Sweep phase: freed 384 bytes\n       \n 30ms: Validation\n       assert(heap_size == 0) âœ“\n```\n\n{{DIAGRAM:shadow-graph-comparison}}\n\n```\nYour GC's Marking:              Shadow Graph (Ground Truth):\n                                \n  Root                            Root\n   â”œâ”€â†’ A (marked)                  â”œâ”€â†’ A (reachable)\n   â”‚    â”œâ”€â†’ B (marked)             â”‚    â”œâ”€â†’ B (reachable)\n   â”‚    â””â”€â†’ C (marked)             â”‚    â””â”€â†’ C (reachable)\n   â””â”€â†’ D (NOT marked)              â””â”€â†’ D (NOT reachable)\n   \nCompare:\n  for each object:\n    assert(gc_marked == shadow_reachable)\n```\n\n---\n\n## The Debugging Lab: Test-Driven Debugging\n\n### Scenario 1: Intermittent Segfault in Production\n\n**Symptom**: Your GC works fine in tests but crashes randomly in production after 10 minutes.\n\n**Hypothesis**: Race condition in parallel sweep.\n\n**Test to Write**:\n```c\nvoid test_parallel_sweep_race_condition() {\n    // Run parallel sweep 10,000 times with random delays\n    for (int i = 0; i < 10000; i++) {\n        GC* gc = create_gc(1024 * 1024);\n        \n        // Allocate objects\n        for (int j = 0; j < 1000; j++) {\n            gc_alloc(gc, 128);\n        }\n        \n        // Parallel sweep with random thread delays\n        sweep_parallel_with_delays(gc, 4);\n        \n        // Verify heap integrity\n        validate_heap_structure(gc);\n        \n        destroy_gc(gc);\n    }\n}\n```\n\n**Fix**: Add proper synchronization to `freed_bytes` counter.\n\n### Scenario 2: Memory Usage Grows Over Time\n\n**Symptom**: Heap size increases by 1KB per GC cycle.\n\n**Hypothesis**: Small leak in mark queue or bitmap.\n\n**Test to Write**:\n```c\nvoid test_gc_internal_memory_leak() {\n    GC* gc = create_gc(1024 * 1024);\n    \n    size_t initial_internal_memory = get_internal_memory_usage(gc);\n    \n    // Run 1000 GC cycles\n    for (int i = 0; i < 1000; i++) {\n        gc_alloc(gc, 128);\n        gc_collect(gc);\n    }\n    \n    size_t final_internal_memory = get_internal_memory_usage(gc);\n    \n    // Internal memory should not grow\n    assert(final_internal_memory == initial_internal_memory);\n}\n```\n\n**Fix**: Ensure mark queue and bitmap are properly freed after each collection.\n\n### Scenario 3: Performance Degrades Over Time\n\n**Symptom**: First GC takes 5ms, 100th GC takes 50ms.\n\n**Hypothesis**: Heap fragmentation or bitmap not being cleared.\n\n**Test to Write**:\n```c\nvoid test_gc_performance_stability() {\n    GC* gc = create_gc(10 * 1024 * 1024);\n    \n    uint64_t times[100];\n    \n    for (int i = 0; i < 100; i++) {\n        // Allocate some objects\n        for (int j = 0; j < 1000; j++) {\n            gc_alloc(gc, 128);\n        }\n        \n        // Measure GC time\n        uint64_t start = get_nanos();\n        gc_collect(gc);\n        times[i] = get_nanos() - start;\n    }\n    \n    // First and last GC should have similar times\n    double first_ms = times[0] / 1e6;\n    double last_ms = times[99] / 1e6;\n    \n    printf(\"First GC: %.2f ms, Last GC: %.2f ms\\n\", first_ms, last_ms);\n    \n    // Allow 20% variance\n    assert(last_ms < first_ms * 1.2);\n}\n```\n\n**Fix**: Ensure bitmap is cleared between collections and implement defragmentation.\n\n---\n\n## Performance Characteristics: Test Execution Time\n\n| Test Type | Count | Time per Test | Total Time | Frequency |\n|-----------|-------|---------------|------------|-----------|\n| **Unit tests** | 50 | 1-10 ms | 0.5 sec | Every commit |\n| **Integration tests** | 10 | 100-500 ms | 5 sec | Every commit |\n| **Stress tests** | 5 | 10-60 sec | 5 min | Nightly |\n| **Soak tests** | 1 | 1-8 hours | 8 hours | Weekly |\n\n**CI/CD Strategy**:\n```\nOn every commit:\n  â†’ Run unit + integration tests (< 10 seconds)\n  â†’ Block merge if any test fails\n\nNightly:\n  â†’ Run stress tests (5 minutes)\n  â†’ Run under Valgrind (30 minutes)\n  â†’ Run under ThreadSanitizer (30 minutes)\n\nWeekly:\n  â†’ Run soak test (8 hours)\n  â†’ Profile with perf/VTune\n  â†’ Generate coverage report\n```\n\n---\n\n## What You've Mastered\n\nâœ… **Leak detection**: Verify all garbage is collected  \nâœ… **Correctness validation**: Compare against shadow graph  \nâœ… **Stress testing**: Break your GC with pathological workloads  \nâœ… **Parallel correctness**: Ensure thread-safe sweep  \nâœ… **Performance regression**: Catch slowdowns early  \nâœ… **Memory safety**: Integrate with Valgrind/ASan  \nâœ… **Test-driven debugging**: Write tests that reproduce bugs  \n\n**Your GC is now battle-tested and production-ready!** ğŸ›¡ï¸\n\n---\n\n## Next Steps: Beyond Testing\n\nYou've built a **fast, correct, and tested** garbage collector. But the journey doesn't end here.\n\n**Choose your next adventure:**\n\n1. **[â†’ Generational GC](#generational-gc)**: Exploit the generational hypothesis for 10x speedup\n2. **[â†’ Concurrent GC](#concurrent-gc)**: Eliminate pause times entirely\n3. **[â†’ Real-World Integration](#integration)**: Embed your GC in a scripting language\n4. **[â†’ Advanced Optimizations](#advanced)**: Incremental collection, region-based GC, escape analysis\n\n**Before continuing**, run your full test suite:\n\n```bash\n$ make test\nRunning: test_no_leaks_simple...\n  âœ“ No leaks detected\nRunning: test_correctness_vs_shadow...\n  âœ“ GC marking matches shadow graph\nRunning: stress_test_deep_nesting...\n  âœ“ No stack overflow\nRunning: test_parallel_sweep_correctness...\n  âœ“ Parallel sweep is correct\nRunning: test_performance_targets...\n  âœ“ Performance targets met\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘   âœ“ ALL TESTS PASSED (32/32)         â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n```\n\n**Pro tip**: Set up continuous fuzzing with AFL or libFuzzer to catch edge cases:\n\n```bash\n$ afl-fuzz -i testcases/ -o findings/ ./gc_fuzzer @@\n```\n\nThis will generate millions of random object graphs and allocation patterns, finding bugs you never imagined.\n\n---\n\n[â†‘ Back to System Map](#satellite-map)\n"}