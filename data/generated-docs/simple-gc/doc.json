{"html":"<h1 id=\"architecting-a-mark-sweep-garbage-collector\">Architecting a Mark-Sweep Garbage Collector</h1>\n<h3 id=\"the-preamble-architecting-a-mark-sweep-garbage-collector\">The Preamble: Architecting a Mark-Sweep Garbage Collector</h3>\n<h4 id=\"the-analogy-the-great-tethered-expedition\">The Analogy: The Great Tethered Expedition</h4>\n<p>Imagine a vast, dark cavern representing your computer&#39;s memory. Inside this cavern are thousands of explorers (objects). To stay &quot;alive&quot; and relevant to the mission, an explorer must be connected to the Base Camp (the Stack/Roots) by a physical rope. </p>\n<p>Some explorers hold ropes connected directly to the Base Camp. Others hold onto the belts of those explorers, forming long, winding chains deep into the darkness. As long as there is a continuous chain of hands and ropes leading back to the Base Camp, an explorer is considered &quot;reachable.&quot;</p>\n<p>However, in the chaos of the expedition, links are frequently broken. An explorer might let go of their lead to grab a new one, or a chain might be severed entirely. These explorers are now drifting in the dark. They are no longer contributing to the mission, yet they are still consuming oxygen and space (memory). </p>\n<p>The <strong>Mark-Sweep Garbage Collector</strong> is the specialized recovery team. First, they start at the Base Camp and follow every rope, placing a glowing marker on every explorer they can reach (<strong>The Mark Phase</strong>). Once they have traversed every possible chain, they walk through the entire cavern. Anyone not wearing a glowing marker is quietly removed, freeing up their oxygen tanks and space for new explorers (<strong>The Sweep Phase</strong>).</p>\n<p>{{DIAGRAM:memory-graph-vs-flat-array}}</p>\n<hr>\n<h4 id=\"why-this-project-matters\">Why This Project Matters</h4>\n<p>In the modern software stack, we often treat memory management as a &quot;solved&quot; background process—a luxury provided by high-level runtimes like the JVM, V8, or Go. However, treating memory as a black box is a recipe for architectural fragility. </p>\n<p>This project matters because it pulls back the curtain on the most fundamental contract between software and hardware: <strong>Resource Lifecycle.</strong> By building a Mark-Sweep collector from scratch, you transition from a consumer of abstractions to an architect of them.</p>\n<p><strong>1. From Bytes to Biology</strong>\nYou will stop seeing memory as a flat, linear array of hexadecimal addresses. Instead, you will learn to visualize it as a <strong>Directed Graph</strong>. This shift in mental modeling is essential for understanding memory leaks, cache locality, and object lifecycles in any language.</p>\n<p><strong>2. The Engineering of &quot;Truth&quot;</strong>\nA Garbage Collector cannot afford to be &quot;mostly right.&quot; A single false negative (reclaiming memory that is still in use) results in a catastrophic crash. A single false positive (failing to reclaim dead memory) results in a leak. You will learn to build a system that maintains absolute integrity across complex, nested data structures.</p>\n<p>{{DIAGRAM:mark-sweep-lifecycle}}</p>\n<p><strong>3. Mastering the Runtime</strong>\nUnderstanding the Mark-Sweep algorithm is the gateway to advanced systems programming. The concepts we implement here—root scanning, pointer chasing, and atomic metadata management—are the same pillars used to build industrial-grade virtual machines and database engines.</p>\n<p>In this masterclass, we aren&#39;t just writing code to delete objects; we are building a robust, automated janitor for the digital world, ensuring that our systems can run indefinitely without drowning in their own exhaustion.</p>\n<h1 id=\"the-architect39s-blueprint\">The Architect&#39;s Blueprint</h1>\n<h1 id=\"the-architect39s-blueprint-mark-sweep-garbage-collector\">The Architect&#39;s Blueprint: Mark-Sweep Garbage Collector</h1>\n<p>This document outlines the technical architecture for a Stop-the-World (STW) Mark-Sweep Garbage Collector. The design focuses on a non-moving collector suitable for environments where pointer stability is required.</p>\n<hr>\n<h2 id=\"1-high-level-abstraction\">1. High-Level Abstraction</h2>\n<p>The system is divided into three primary domains: the <strong>Mutator</strong> (the application code), the <strong>Heap Manager</strong>, and the <strong>Collector</strong>.</p>\n<ol>\n<li><strong>The Mutator:</strong> Requests memory and manipulates pointers. It is unaware of the GC until a &quot;Stop-the-World&quot; event occurs.</li>\n<li><strong>The Heap Manager:</strong> Maintains a linked list or bitmap of all allocated blocks. It tracks the &quot;Object Graph.&quot;</li>\n<li><strong>The Collector:</strong> Orchestrates the two-phase reclamation process:<ul>\n<li><strong>Mark Phase:</strong> Performs a depth-first search (DFS) starting from the <strong>Root Set</strong> (stack, registers, globals). It sets a &quot;marked&quot; bit on every reachable object.</li>\n<li><strong>Sweep Phase:</strong> Linearly scans the heap. Any object without the &quot;marked&quot; bit is added back to the free list; marked objects have their bits cleared for the next cycle.</li>\n</ul>\n</li>\n</ol>\n<p>{{DIAGRAM:system_overview}}\n<em>Description: Interaction between the Mutator, the Root Set, and the Managed Heap during the GC lifecycle.</em></p>\n<p>{{DIAGRAM:mark_sweep_logic}}\n<em>Description: The transition from the Mark phase (graph traversal) to the Sweep phase (linear reclamation).</em></p>\n<hr>\n<h2 id=\"2-interface-specifications\">2. Interface Specifications</h2>\n<h3 id=\"21-data-structures\">2.1 Data Structures</h3>\n<h4 id=\"struct-gc_object\"><code>struct GC_Object</code></h4>\n<p>The header prepended to every allocation.</p>\n<ul>\n<li><strong><code>uintptr_t metadata</code></strong>: Contains the &quot;Mark Bit&quot; (1 bit) and potentially type information for scanning.</li>\n<li><strong><code>size_t size</code></strong>: The size of the allocation (needed for the Sweep phase to skip blocks).</li>\n<li><strong><code>struct GC_Object* next</code></strong>: Pointer to the next object in the global allocation list (allows linear sweeping).</li>\n<li><em>Reason:</em> Minimizes overhead while providing the Collector with the necessary breadcrumbs to traverse the entire heap regardless of reachability.</li>\n</ul>\n<h4 id=\"struct-gc_heap\"><code>struct GC_Heap</code></h4>\n<p>The global state of the collector.</p>\n<ul>\n<li><strong><code>GC_Object* head</code></strong>: Start of the linked list of all managed objects.</li>\n<li><strong><code>size_t used_bytes</code></strong>: Current memory pressure.</li>\n<li><strong><code>size_t threshold</code></strong>: The limit that triggers a collection cycle.</li>\n<li><strong><code>void** stack_bottom</code></strong>: Pointer to the base of the CPU stack to identify roots.</li>\n<li><em>Reason:</em> Centralizes tracking and provides the entry point for the Sweep phase.</li>\n</ul>\n<hr>\n<h3 id=\"22-key-functions-amp-apis\">2.2 Key Functions &amp; APIs</h3>\n<h4 id=\"void-gc_allocsize_t-size\"><code>void* gc_alloc(size_t size)</code></h4>\n<p><strong>Signature:</strong> <code>void* gc_alloc(size_t size)</code>\n<strong>Pseudocode:</strong></p>\n<ol>\n<li>If <code>used_bytes + size &gt; threshold</code>, call <code>gc_collect()</code>.</li>\n<li>Allocate <code>size + sizeof(GC_Object)</code> using system <code>malloc</code>.</li>\n<li>Initialize <code>GC_Object</code> header (mark_bit = 0).</li>\n<li>Prepend object to <code>GC_Heap-&gt;head</code>.</li>\n<li>Return pointer to memory immediately following the header.</li>\n</ol>\n<h4 id=\"void-gc_collect\"><code>void gc_collect()</code></h4>\n<p><strong>Signature:</strong> <code>void gc_collect(void)</code>\n<strong>Pseudocode:</strong></p>\n<ol>\n<li><strong>Stop-the-World:</strong> Suspend mutator threads (if applicable).</li>\n<li><strong>Mark Phase:</strong><ul>\n<li>Identify roots (Stack, Globals).</li>\n<li>For each root: <code>mark_object(root)</code>.</li>\n</ul>\n</li>\n<li><strong>Sweep Phase:</strong><ul>\n<li>Iterate <code>GC_Heap-&gt;head</code> list.</li>\n<li>If <code>obj-&gt;marked == 1</code>: set <code>obj-&gt;marked = 0</code>.</li>\n<li>Else: Unlink from list, <code>free(obj)</code>.</li>\n</ul>\n</li>\n<li><strong>Resume-the-World:</strong> Restart mutator.</li>\n</ol>\n<h4 id=\"void-mark_objectvoid-ptr\"><code>void mark_object(void* ptr)</code></h4>\n<p><strong>Signature:</strong> <code>void mark_object(void* ptr)</code>\n<strong>Pseudocode:</strong></p>\n<ol>\n<li>Find <code>GC_Object</code> header from <code>ptr</code>.</li>\n<li>If <code>header-&gt;marked == 1</code>, return (avoid infinite loops/redundancy).</li>\n<li>Set <code>header-&gt;marked = 1</code>.</li>\n<li>Scan the object&#39;s memory for potential pointers to other <code>GC_Objects</code>.</li>\n<li>For each found pointer <code>p</code>: <code>mark_object(p)</code>.</li>\n</ol>\n<hr>\n<h2 id=\"3-project-structure\">3. Project Structure</h2>\n<p>The project is organized to separate the core collection logic from the platform-specific stack scanning.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>/project-root\n│\n├── include/\n│   ├── gc.h             # Public API (gc_init, gc_alloc)\n│   └── internal.h       # Private structs (GC_Object, GC_Heap)\n│\n├── src/\n│   ├── allocator.c      # Memory allocation and heap list management\n│   ├── collector.c      # Mark and Sweep phase implementations\n│   ├── scanner.c        # Platform-specific root/stack scanning logic\n│   └── utils.c          # Logging and pointer validation helpers\n│\n├── tests/\n│   ├── test_basic.c     # Simple allocation/reclamation tests\n│   └── test_cycles.c    # Tests for circular reference handling\n│\n└── Makefile             # Build configuration</code></pre></div>\n\n<hr>\n<h2 id=\"4-implementation-constraints\">4. Implementation Constraints</h2>\n<ol>\n<li><strong>Pointer Alignment:</strong> The collector must assume pointers are word-aligned when scanning the stack.</li>\n<li><strong>False Positives:</strong> As a conservative collector (if type info is unavailable), any bit pattern resembling a valid heap address must be treated as a pointer.</li>\n<li><strong>Recursion Depth:</strong> The <code>mark_object</code> function should ideally use an explicit stack to avoid <code>StackOverflowError</code> during deep object graph traversal.</li>\n</ol>\n<h2 id=\"milestone-the-anatomy-of-a-managed-object\">Milestone: The Anatomy of a Managed Object</h2>\n<p>This milestone focuses on the <strong>Anatomy of a Managed Object</strong>. Before we can traverse a graph or sweep memory, we must define the &quot;Envelope&quot;—the metadata header that wraps every allocation. This header is the only way the Garbage Collector (GC) can distinguish between raw bytes and a trackable entity.</p>\n<h3 id=\"1-logic-walkthrough\">1. Logic Walkthrough</h3>\n<p>In a managed environment, the user (the Mutator) asks for $N$ bytes. The allocator, however, reserves $N + \\text{sizeof(Header)}$ bytes. </p>\n<ol>\n<li><strong>The Hidden Tax:</strong> Every object carries a header. The Mutator never sees this; it receives a pointer to the memory <em>immediately following</em> the header.</li>\n<li><strong>The Registry Link:</strong> To perform a <strong>Sweep</strong>, the GC needs to find every object ever allocated, even those no longer reachable by the Mutator. We achieve this by linking every header into a global linked list (the &quot;Object Registry&quot;) at the moment of allocation.</li>\n<li><strong>The Mark Bit:</strong> We need at least one bit to store the &quot;reachability&quot; status. During the Mark phase, we flip this bit.</li>\n<li><strong>Pointer Arithmetic:</strong> <ul>\n<li><strong>To User:</strong> <code>(void*)((char*)header + sizeof(GC_Object))</code></li>\n<li><strong>To Header:</strong> <code>(GC_Object*)((char*)user_ptr - sizeof(GC_Object))</code></li>\n</ul>\n</li>\n</ol>\n<p>{{DIAGRAM:object-layout}}\n<em>Description: A visualization of the memory block showing the Header (Metadata, Next Pointer, Size) followed by the User Payload.</em></p>\n<hr>\n<h3 id=\"2-pitfalls-\">2. Pitfalls (⚠️)</h3>\n<ul>\n<li><strong>Alignment Corruption:</strong> If your header is 13 bytes, the user payload will be misaligned. This causes significant performance degradation on x86 and crashes on ARM. <strong>Solution:</strong> Always pad the header to 8 or 16 bytes.</li>\n<li><strong>The &quot;Off-by-Header&quot; Bug:</strong> Forgetting to subtract the header size when the GC receives a pointer from the stack, leading to reading user data as metadata.</li>\n<li><strong>Header Overwrite:</strong> If the Mutator has a &quot;buffer overflow&quot; bug, it will overwrite the <em>next</em> object&#39;s header, corrupting the GC&#39;s global linked list and causing a crash during the next Sweep.</li>\n<li><strong>Size Transparency:</strong> The <code>size</code> stored in the header must represent the <em>payload</em> size, but the GC must remember to free the <em>total</em> size (Header + Payload).</li>\n</ul>\n<hr>\n<h3 id=\"3-infrastructure-code\">3. Infrastructure Code</h3>\n<p>This code defines the &quot;Contract&quot; for every managed object.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stddef.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdbool.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Ensure the header is aligned to the platform's word size</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> GC_Object {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> size;</span><span style=\"color:#6A737D\">                // Size of the payload</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> GC_Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span><span style=\"color:#6A737D\">     // Global list for the Sweep phase</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uintptr_t</span><span style=\"color:#E1E4E8\"> metadata;</span><span style=\"color:#6A737D\">         // Bit 0: Mark Bit, Bits 1-63: Type Info/Reserved</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} GC_Object;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MARK_BIT_MASK</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ALIGNMENT</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ALIGN</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">size</span><span style=\"color:#E1E4E8\">) (((size) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> (ALIGNMENT</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">(ALIGNMENT</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The Global Heap State</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC_Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> head;</span><span style=\"color:#6A737D\">           // Start of the \"Registry\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_allocated;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} GC_Heap;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#E1E4E8\"> GC_Heap global_heap </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\"> };</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"4-core-logic-skeleton-todos\">4. Core Logic Skeleton (TODOs)</h3>\n<p>You must implement the translation layer between the GC and the Mutator.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Wraps a raw allocation with a GC Header.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> gc_allocate_object</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> payload_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ALIGN</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(GC_Object) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> payload_size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. TODO: Call system malloc for total_size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. TODO: Initialize GC_Object fields (mark_bit = 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. TODO: Prepend this object to global_heap.head (The Registry)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Return the pointer to the PAYLOAD, not the header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">; </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Helper to convert a user pointer back to a GC_Object header.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">GC_Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> user_ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Use pointer arithmetic to move backward by sizeof(GC_Object)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Helper to check if an object is marked.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> is_marked</span><span style=\"color:#E1E4E8\">(GC_Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Perform bitwise AND with MARK_BIT_MASK</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"5-verification-code\">5. Verification Code</h3>\n<p>Use this test to ensure your pointer math and alignment are correct.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;assert.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> verify_milestone_anatomy</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Testing Object Anatomy...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> request </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_allocate_object</span><span style=\"color:#E1E4E8\">(request);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(ptr </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test Pointer Arithmetic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC_Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)(header </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test Alignment</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(((</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)ptr </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> ALIGNMENT) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test Registry</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(global_heap.head </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> header);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(header->size </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> request);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Verification Passed: Header/Payload translation is robust.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>{{DIAGRAM:pointer-arithmetic-logic}}\n<em>Description: Flowchart showing the bidirectional conversion between User Pointers and GC Headers.</em></p>\n<hr>\n<h3 id=\"6-grading-table\">6. Grading Table</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Criteria</th>\n<th align=\"left\">Weight</th>\n<th align=\"left\">Requirement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Alignment</strong></td>\n<td align=\"left\">30%</td>\n<td align=\"left\">Payload pointers must be 8-byte aligned.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Registry Integrity</strong></td>\n<td align=\"left\">30%</td>\n<td align=\"left\">New objects must be correctly prepended to the <code>global_heap.head</code> list.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Header Hiddenness</strong></td>\n<td align=\"left\">20%</td>\n<td align=\"left\">The <code>gc_allocate_object</code> must return a pointer to the payload, not the header.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Metadata Packing</strong></td>\n<td align=\"left\">20%</td>\n<td align=\"left\">Mark bit must be stored within the header (either bitfield or bitwise).</td>\n</tr>\n</tbody></table>\n<p><strong>Next Step:</strong> Once the anatomy is solid, we will move to <strong>Milestone: The Root Scanner</strong>, where we learn to find these objects by scanning the CPU stack.</p>\n<h2 id=\"milestone-the-root-of-the-problem-finding-entry-points\">Milestone: The Root of the Problem: Finding Entry Points</h2>\n<h2 id=\"milestone-the-root-of-the-problem-finding-entry-points\">Milestone: The Root of the Problem: Finding Entry Points</h2>\n<p>This milestone focuses on <strong>Root Discovery</strong>. In a garbage-collected environment, an object is &quot;alive&quot; only if it can be reached from a <strong>Root</strong>. If the GC cannot find the starting threads of the web, it will accidentally sweep away the entire heap.</p>\n<h3 id=\"1-logic-walkthrough\">1. Logic Walkthrough</h3>\n<p>The GC needs to find every pointer currently held by the CPU or the program&#39;s execution stack. Since we are building a <strong>Conservative GC</strong> for C, we don&#39;t have a &quot;Type Map&quot; telling us which stack offsets are pointers and which are just integers.</p>\n<ol>\n<li><strong>Defining the Search Space:</strong> The stack is a contiguous block of memory. It starts at a high address (the <code>stack_bottom</code>, captured at the start of <code>main</code>) and grows toward a lower address (the current Stack Pointer).</li>\n<li><strong>The Conservative Assumption:</strong> We treat every word-aligned value on the stack as a <em>potential</em> pointer. </li>\n<li><strong>The Validation Filter:</strong> For every word we find on the stack, we ask three questions:<ul>\n<li>Is it aligned to a pointer boundary (e.g., a multiple of 8)?</li>\n<li>Does the value fall between the lowest and highest addresses of our managed heap?</li>\n<li>Does it point to a valid <code>GC_Object</code> header we previously registered?</li>\n</ul>\n</li>\n<li><strong>Register Spilling:</strong> Pointers might live in CPU registers (like <code>RAX</code> or <code>RBX</code>) rather than on the RAM stack. To find these, we &quot;spill&quot; the registers onto the stack using <code>setjmp</code> before we start scanning.</li>\n</ol>\n<p>{{DIAGRAM:stack-scanning-process}}\n<em>Description: The GC scanning the stack from the current top (RSP) to the recorded bottom, identifying values that point into the Managed Heap.</em></p>\n<hr>\n<h3 id=\"2-pitfalls-\">2. Pitfalls (⚠️)</h3>\n<ul>\n<li><strong>The &quot;False Positive&quot; Problem:</strong> An integer (like <code>0x7fff1234</code>) might happen to match a heap address. A conservative GC must assume it <em>is</em> a pointer and keep that memory alive. This is safe (no crashes) but causes &quot;floating garbage.&quot;</li>\n<li><strong>Stack Direction:</strong> On almost all modern systems (x86/ARM), the stack grows <strong>downward</strong>. This means <code>stack_top</code> (current) is a lower memory address than <code>stack_bottom</code>.</li>\n<li><strong>Optimization Erasure:</strong> If a pointer is only held in a register and the compiler optimizes it away or moves it, the GC might not see it. We use <code>setjmp</code> or <code>__attribute__((noinline))</code> to prevent the compiler from being too clever during a GC cycle.</li>\n<li><strong>Misalignment:</strong> If you scan byte-by-byte, you will find &quot;ghost pointers&quot; formed by the tail of one variable and the head of another. <strong>Solution:</strong> Only scan in increments of <code>sizeof(void*)</code>.</li>\n</ul>\n<hr>\n<h3 id=\"3-infrastructure-code\">3. Infrastructure Code</h3>\n<p>We need to capture the environment and define the bounds of our &quot;searchable&quot; universe.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;setjmp.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uintptr_t</span><span style=\"color:#E1E4E8\"> heap_start;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uintptr_t</span><span style=\"color:#E1E4E8\"> heap_end;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> stack_bottom;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} GC_State;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#E1E4E8\"> GC_State state;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Captured at the very beginning of main()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> stack_base</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state.stack_bottom </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stack_base;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state.heap_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINTPTR_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state.heap_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Update heap bounds every time we allocate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> update_heap_bounds</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#FFAB70\"> addr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (addr </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> state.heap_start) state.heap_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (addr </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> state.heap_end) state.heap_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> addr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"4-core-logic-skeleton-todos\">4. Core Logic Skeleton (TODOs)</h3>\n<p>You must implement the logic that iterates through the stack and identifies potential roots.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Scans a range of memory (the stack) for potential pointers.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> scan_region</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uintptr_t*</span><span style=\"color:#FFAB70\"> start</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uintptr_t*</span><span style=\"color:#FFAB70\"> end</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Ensure start is lower than end for the loop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (start </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> end) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uintptr_t*</span><span style=\"color:#E1E4E8\"> temp </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> start;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> end;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> temp;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. TODO: Iterate from start to end, one word (uintptr_t) at a time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uintptr_t*</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> start; p </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> end; p</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uintptr_t</span><span style=\"color:#E1E4E8\"> val </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 2. TODO: Check if 'val' falls within [state.heap_start, state.heap_end]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 3. TODO: If it looks like a pointer, call mark_object((void*)val)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Triggers the root discovery process.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> find_roots</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jmp_buf regs;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    setjmp</span><span style=\"color:#E1E4E8\">(regs);</span><span style=\"color:#6A737D\"> // Spill registers to the stack</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> stack_top </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> __builtin_frame_address</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. TODO: Call scan_region using stack_top and state.stack_bottom</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"5-verification-code\">5. Verification Code</h3>\n<p>This test ensures that the GC can &quot;see&quot; a pointer sitting on the stack.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_root_discovery</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Testing Root Discovery...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Allocate something</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#E1E4E8\"> local_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_allocate_object</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uintptr_t</span><span style=\"color:#E1E4E8\"> addr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)local_ptr;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Manually trigger root scanning</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    find_roots</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Verify the object was marked</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC_Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(local_ptr);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: This assumes your mark_object logic is partially ready</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // or you can check a 'found_on_stack' flag for this milestone.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(header) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#9ECBFF\"> \"Error: Local stack pointer was not identified as a root!\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Verification Passed: Stack pointers are correctly identified.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>{{DIAGRAM:conservative-pointer-validation}}\n<em>Description: A logic gate showing the criteria for a stack word to be promoted to a &quot;Root&quot;: Alignment -&gt; Range Check -&gt; Header Verification.</em></p>\n<hr>\n<h3 id=\"6-grading-table\">6. Grading Table</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Criteria</th>\n<th align=\"left\">Weight</th>\n<th align=\"left\">Requirement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Range Bounds</strong></td>\n<td align=\"left\">20%</td>\n<td align=\"left\">Correct tracking of <code>heap_start</code> and <code>heap_end</code> during allocation.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Stack Traversal</strong></td>\n<td align=\"left\">30%</td>\n<td align=\"left\">Correct loop logic to iterate between <code>stack_top</code> and <code>stack_bottom</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Word Alignment</strong></td>\n<td align=\"left\">20%</td>\n<td align=\"left\">Scanning must jump by <code>sizeof(void*)</code> to avoid unaligned reads.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Register Spilling</strong></td>\n<td align=\"left\">15%</td>\n<td align=\"left\">Use of <code>setjmp</code> or similar to ensure registers are visible on the stack.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Conservative Safety</strong></td>\n<td align=\"left\">15%</td>\n<td align=\"left\">Logic must not crash if a stack value is a valid address but not a GC object.</td>\n</tr>\n</tbody></table>\n<p><strong>Next Step:</strong> Now that we can find the roots, we will implement <strong>Milestone: The Trace</strong>, where we follow these roots recursively to mark the entire reachable graph.</p>\n<h2 id=\"milestone-the-mark-phase-mapping-the-living\">Milestone: The Mark Phase: Mapping the Living</h2>\n<h2 id=\"milestone-the-mark-phase-mapping-the-living\">Milestone: The Mark Phase: Mapping the Living</h2>\n<p>This milestone focuses on <strong>Graph Traversal</strong>. Now that we can identify &quot;Roots&quot; (entry points from the stack), we must follow the trail. The Mark Phase is the process of traversing the directed graph of objects to distinguish between &quot;live&quot; data and &quot;garbage.&quot;</p>\n<h3 id=\"1-logic-walkthrough\">1. Logic Walkthrough</h3>\n<p>The Mark Phase is essentially a <strong>Depth-First Search (DFS)</strong> or <strong>Breadth-First Search (BFS)</strong> where the nodes are memory blocks and the edges are pointers.</p>\n<ol>\n<li><strong>The Recursive Discovery:</strong> When a root is identified, we don&#39;t just mark that object; we must &quot;look inside&quot; it. If that object contains pointers to other objects, those must be marked too.</li>\n<li><strong>The &quot;Conservative&quot; Scan:</strong> Because we are in C, we don&#39;t have a &quot;Type Map&quot; (a guide telling us where pointers are located inside a struct). Therefore, we treat the <strong>entire payload</strong> of a marked object as a potential source of pointers, just like we did with the stack.</li>\n<li><strong>Cycle Protection:</strong> In a graph with circular references (e.g., Object A points to B, and B points to A), a naive traversal would loop forever. We use the <strong>Mark Bit</strong> as a &quot;visited&quot; flag. If we encounter an object that is already marked, we stop recursing.</li>\n<li><strong>The Worklist:</strong> While recursion is intuitive, deep data structures (like a linked list with 100,000 nodes) can cause a <code>Stack Overflow</code>. Robust collectors often use an explicit <strong>Worklist</strong> (a stack or queue data structure) to manage the traversal.</li>\n</ol>\n<p>{{DIAGRAM:mark-traversal-flow}}\n<em>Description: A visualization of the marking process starting from a Root, traversing through child pointers, and skipping already-marked nodes to handle cycles.</em></p>\n<hr>\n<h3 id=\"2-pitfalls-\">2. Pitfalls (⚠️)</h3>\n<ul>\n<li><strong>Infinite Recursion:</strong> Failing to check the mark bit <em>before</em> recursing into an object&#39;s fields will cause a crash on any circular data structure.</li>\n<li><strong>Internal Pointers:</strong> In C, a pointer might point to the <em>middle</em> of an object (e.g., a pointer to a struct field). A strict GC might miss these. <strong>Solution:</strong> For this milestone, we assume pointers always point to the start of the allocated payload.</li>\n<li><strong>Stack Overflow:</strong> Using standard C recursion for the DFS is dangerous for deep graphs. </li>\n<li><strong>The &quot;Integer Lookalike&quot;:</strong> Just like stack scanning, scanning an object&#39;s payload will find integers that look like addresses. We must validate every potential pointer against our global registry.</li>\n</ul>\n<hr>\n<h3 id=\"3-infrastructure-code\">3. Infrastructure Code</h3>\n<p>To safely mark, we need a way to verify if a random memory address is actually one of our managed <code>GC_Object</code>s.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Validates if a pointer 'p' points to a managed GC_Object.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In a production GC, this might use a Hash Map or a Bloom Filter.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * For now, we iterate our global registry.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">GC_Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> find_header_in_registry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> p</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC_Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> global_heap.head;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (current </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Does 'p' point to the payload of this header?</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)(current </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> p) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"4-core-logic-skeleton-todos\">4. Core Logic Skeleton (TODOs)</h3>\n<p>You must implement the recursive marking logic.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Marks an object as live and recursively scans its payload for more pointers.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> mark_object</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ptr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. TODO: Translate the user pointer to a GC_Object header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. TODO: Use find_header_in_registry to ensure it's a valid managed object</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC_Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> find_header_in_registry</span><span style=\"color:#E1E4E8\">(ptr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">header) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. TODO: Check if already marked to prevent infinite loops</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(header)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. TODO: Set the mark bit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header->metadata </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> MARK_BIT_MASK;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. TODO: Scan the object's payload for potential pointers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The payload starts at (header + 1) and has length (header->size)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uintptr_t*</span><span style=\"color:#E1E4E8\"> payload_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uintptr_t*</span><span style=\"color:#E1E4E8\">)(header </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> words </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> header->size </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> words; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 6. TODO: Recursively call mark_object on every word found in the payload</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mark_object</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">payload_start</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>{{DIAGRAM:cycle-detection-logic}}\n<em>Description: Flowchart showing the &quot;Check Mark Bit -&gt; Set Mark Bit -&gt; Scan Children&quot; logic that ensures every reachable object is visited exactly once.</em></p>\n<hr>\n<h3 id=\"5-verification-code\">5. Verification Code</h3>\n<p>This test creates a complex graph (a circular linked list) and verifies that the GC marks all of them starting from a single root.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_mark_phase</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Testing Mark Phase Traversal...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Create three objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> Node { </span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> next; </span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\"> data; };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_allocate_object</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> Node));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_allocate_object</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> Node));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> Node</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> c </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_allocate_object</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> Node));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Link them in a cycle: A -> B -> C -> A</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    a->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> c;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> a;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Manually trigger marking from 'a'</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mark_object</span><span style=\"color:#E1E4E8\">(a);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Verify all are marked despite the cycle</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">get_header</span><span style=\"color:#E1E4E8\">(a)));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">get_header</span><span style=\"color:#E1E4E8\">(b)));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">get_header</span><span style=\"color:#E1E4E8\">(c)));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Verification Passed: Circular graphs are fully traversed and marked.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"6-grading-table\">6. Grading Table</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Criteria</th>\n<th align=\"left\">Weight</th>\n<th align=\"left\">Requirement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Recursive Depth</strong></td>\n<td align=\"left\">20%</td>\n<td align=\"left\">Correctly follows pointers from one object into another.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Cycle Handling</strong></td>\n<td align=\"left\">30%</td>\n<td align=\"left\">Must not enter an infinite loop when objects point to each other.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Payload Scanning</strong></td>\n<td align=\"left\">20%</td>\n<td align=\"left\">Correctly treats the object payload as a range of potential pointers.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Pointer Validation</strong></td>\n<td align=\"left\">20%</td>\n<td align=\"left\">Must use the registry to verify pointers before attempting to mark them.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Null Safety</strong></td>\n<td align=\"left\">10%</td>\n<td align=\"left\">Must gracefully handle NULL pointers or pointers to non-GC memory.</td>\n</tr>\n</tbody></table>\n<p><strong>Next Step:</strong> With the graph fully mapped and &quot;Live&quot; objects glowing with mark bits, we proceed to <strong>Milestone: The Sweep Phase</strong>, where we finally reclaim the unmarked darkness.</p>\n<h2 id=\"milestone-the-sweep-phase-reclaiming-the-dead\">Milestone: The Sweep Phase: Reclaiming the Dead</h2>\n<h2 id=\"milestone-the-sweep-phase-reclaiming-the-dead\">Milestone: The Sweep Phase: Reclaiming the Dead</h2>\n<p>This milestone focuses on <strong>Reclamation</strong>. After the Mark Phase has identified the &quot;living&quot; graph, the Sweep Phase performs a linear scan of the entire allocation registry. It is the moment of truth where unreachable memory is finally liberated and the system state is reset for the next cycle.</p>\n<h3 id=\"1-logic-walkthrough\">1. Logic Walkthrough</h3>\n<p>The Sweep Phase does not traverse the graph; it traverses the <strong>Registry</strong> (the global linked list of all objects created via <code>gc_alloc</code>).</p>\n<ol>\n<li><strong>Linear Iteration:</strong> The GC starts at <code>global_heap.head</code> and moves through every <code>GC_Object</code> using the <code>next</code> pointers.</li>\n<li><strong>The Decision Branch:</strong><ul>\n<li><strong>If Marked:</strong> The object is reachable. We <strong>clear the mark bit</strong> (reset it to 0) so it’s ready for the next GC cycle. We then move to the next object.</li>\n<li><strong>If Unmarked:</strong> The object is &quot;dead.&quot; It must be unlinked from the registry and its memory returned to the system.</li>\n</ul>\n</li>\n<li><strong>Unlinking Logic:</strong> Since this is a singly linked list, removing an object requires keeping track of the <code>previous</code> node to bridge the gap.</li>\n<li><strong>Accounting:</strong> As objects are freed, the <code>global_heap.total_allocated</code> counter must be decremented to reflect the current memory pressure accurately.</li>\n</ol>\n<p>{{DIAGRAM:sweep-process-flow}}\n<em>Description: A linear scan of the object registry where unmarked nodes are unlinked and freed, while marked nodes are kept and their bits reset.</em></p>\n<hr>\n<h3 id=\"2-pitfalls-\">2. Pitfalls (⚠️)</h3>\n<ul>\n<li><strong>The &quot;Head&quot; Case:</strong> If the very first object in the registry (<code>global_heap.head</code>) is dead, you must update the global head pointer itself. Failing to do this leads to a &quot;Use-After-Free&quot; when the GC tries to start the next sweep.</li>\n<li><strong>Freeing the Header vs. Payload:</strong> You must call <code>free()</code> on the pointer to the <strong>GC_Object header</strong>, not the user payload pointer.</li>\n<li><strong>Dangling <code>next</code> Pointers:</strong> When freeing an object, ensure you’ve already captured the pointer to the <code>next</code> object in the list, or you will lose the rest of the registry.</li>\n<li><strong>Forgetting the Reset:</strong> If you fail to set <code>mark_bit = 0</code> on survivors, every object that was alive during <em>this</em> cycle will be considered alive <em>forever</em>, leading to a permanent memory leak.</li>\n</ul>\n<hr>\n<h3 id=\"3-infrastructure-code\">3. Infrastructure Code</h3>\n<p>We need a helper to handle the actual system-level deallocation and accounting.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Internal helper to return memory to the OS and update stats.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_free_object</span><span style=\"color:#E1E4E8\">(GC_Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> obj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">obj) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update global accounting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: We subtract the total size (Header + Payload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ALIGN</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(GC_Object) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> obj->size);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    global_heap.total_allocated </span><span style=\"color:#F97583\">-=</span><span style=\"color:#E1E4E8\"> total_size;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Final liberation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(obj);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"4-core-logic-skeleton-todos\">4. Core Logic Skeleton (TODOs)</h3>\n<p>You must implement the logic that iterates the registry and decides the fate of each object.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Scans the global registry, freeing unmarked objects and resetting marked ones.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> gc_sweep</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC_Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> global_heap.head;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC_Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (current </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // 1. TODO: Check if the object is marked</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(current)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // 2. TODO: It's alive! Reset the mark bit for the next cycle</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current->metadata </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">MARK_BIT_MASK;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Move pointers forward</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            prev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current->next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // 3. TODO: It's dead. Capture the next pointer before freeing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            GC_Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> unreached </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current->next;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // 4. TODO: Unlink from the list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (prev </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // We are freeing the head of the list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                global_heap.head </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Bridge the gap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                prev->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // 5. TODO: Call gc_free_object on the unreached node</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            gc_free_object</span><span style=\"color:#E1E4E8\">(unreached);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>{{DIAGRAM:linked-list-unlinking}}\n<em>Description: Pointer manipulation required to remove a node from a singly linked list while maintaining the continuity of the registry.</em></p>\n<hr>\n<h3 id=\"5-verification-code\">5. Verification Code</h3>\n<p>This test ensures that dead objects are removed while live ones survive with their state reset.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_sweep_phase</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Testing Sweep Phase Reclamation...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Allocate two objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> live_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_allocate_object</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> dead_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> gc_allocate_object</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC_Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> live_header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(live_ptr);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GC_Object</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> dead_header </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> get_header</span><span style=\"color:#E1E4E8\">(dead_ptr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> initial_mem </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> global_heap.total_allocated;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Manually mark only one</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    live_header->metadata </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> MARK_BIT_MASK;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Run Sweep</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    gc_sweep</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Verify: Live object survives and is UNMARKED now</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(global_heap.head </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> live_header);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">is_marked</span><span style=\"color:#E1E4E8\">(live_header) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#9ECBFF\"> \"Error: Mark bit was not reset on survivor!\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Verify: Dead object is gone and memory stats updated</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(live_header->next </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(global_heap.total_allocated </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> initial_mem);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Verification Passed: Dead memory reclaimed, survivors reset.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<hr>\n<h3 id=\"6-grading-table\">6. Grading Table</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Criteria</th>\n<th align=\"left\">Weight</th>\n<th align=\"left\">Requirement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Unlinking Logic</strong></td>\n<td align=\"left\">30%</td>\n<td align=\"left\">Correctly handles middle-of-list and head-of-list deletions.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Memory Reclamation</strong></td>\n<td align=\"left\">30%</td>\n<td align=\"left\">Calls <code>free()</code> on the correct header address for unmarked objects.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Mark Bit Reset</strong></td>\n<td align=\"left\">20%</td>\n<td align=\"left\">All surviving objects must have <code>mark_bit == 0</code> after sweep.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Accounting Accuracy</strong></td>\n<td align=\"left\">10%</td>\n<td align=\"left\"><code>total_allocated</code> must accurately reflect the heap size after reclamation.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Pointer Continuity</strong></td>\n<td align=\"left\">10%</td>\n<td align=\"left\">The loop must not lose the <code>next</code> pointer when an object is freed.</td>\n</tr>\n</tbody></table>\n<p><strong>Next Step:</strong> You have completed the core engine! The final step is <strong>Integration</strong>, where we tie the Allocator, Root Scanner, Mark Phase, and Sweep Phase into a single, automated <code>gc_collect()</code> trigger.</p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd1.svg\" alt=\"The GC Mental Model: Reachability Graph\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd1.svg\" alt=\"The GC Mental Model: Reachability Graph\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd2.svg\" alt=\"Object Header Bit-Layout\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd3.svg\" alt=\"Memory Alignment & Padding\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd4.svg\" alt=\"The Allocation Registry Linked List\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd5.svg\" alt=\"Stack Frame Root Discovery\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd6.svg\" alt=\"Global vs. Local Roots\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd7.svg\" alt=\"Precise vs. Conservative Scanning\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd8.svg\" alt=\"The Marking Worklist (DFS)\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd9.svg\" alt=\"Handling Reference Cycles\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd10.svg\" alt=\"Tri-Color Marking Concept\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd11.svg\" alt=\"Type-Specific Traversal Logic\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd12.svg\" alt=\"The Sweep: Linear Registry Scan\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd13.svg\" alt=\"Unlinking and Freeing\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd14.svg\" alt=\"The Mark-Bit Reset Phase\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd15.svg\" alt=\"GC Trigger Thresholds\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd16.svg\" alt=\"Complete GC Lifecycle\"></p>\n<p><img src=\"/api/project/simple-gc/architecture-doc/asset?path=diagrams%2Fd16.svg\" alt=\"Complete GC Lifecycle\"></p>\n","toc":[{"level":1,"text":"Architecting a Mark-Sweep Garbage Collector","id":"architecting-a-mark-sweep-garbage-collector"},{"level":3,"text":"The Preamble: Architecting a Mark-Sweep Garbage Collector","id":"the-preamble-architecting-a-mark-sweep-garbage-collector"},{"level":4,"text":"The Analogy: The Great Tethered Expedition","id":"the-analogy-the-great-tethered-expedition"},{"level":4,"text":"Why This Project Matters","id":"why-this-project-matters"},{"level":1,"text":"The Architect&#39;s Blueprint","id":"the-architect39s-blueprint"},{"level":1,"text":"The Architect&#39;s Blueprint: Mark-Sweep Garbage Collector","id":"the-architect39s-blueprint-mark-sweep-garbage-collector"},{"level":2,"text":"1. High-Level Abstraction","id":"1-high-level-abstraction"},{"level":2,"text":"2. Interface Specifications","id":"2-interface-specifications"},{"level":3,"text":"2.1 Data Structures","id":"21-data-structures"},{"level":4,"text":"struct GC_Object","id":"struct-gc_object"},{"level":4,"text":"struct GC_Heap","id":"struct-gc_heap"},{"level":3,"text":"2.2 Key Functions &amp; APIs","id":"22-key-functions-amp-apis"},{"level":4,"text":"void* gc_alloc(size_t size)","id":"void-gc_allocsize_t-size"},{"level":4,"text":"void gc_collect()","id":"void-gc_collect"},{"level":4,"text":"void mark_object(void* ptr)","id":"void-mark_objectvoid-ptr"},{"level":2,"text":"3. Project Structure","id":"3-project-structure"},{"level":2,"text":"4. Implementation Constraints","id":"4-implementation-constraints"},{"level":2,"text":"Milestone: The Anatomy of a Managed Object","id":"milestone-the-anatomy-of-a-managed-object"},{"level":3,"text":"1. Logic Walkthrough","id":"1-logic-walkthrough"},{"level":3,"text":"2. Pitfalls (⚠️)","id":"2-pitfalls-"},{"level":3,"text":"3. Infrastructure Code","id":"3-infrastructure-code"},{"level":3,"text":"4. Core Logic Skeleton (TODOs)","id":"4-core-logic-skeleton-todos"},{"level":3,"text":"5. Verification Code","id":"5-verification-code"},{"level":3,"text":"6. Grading Table","id":"6-grading-table"},{"level":2,"text":"Milestone: The Root of the Problem: Finding Entry Points","id":"milestone-the-root-of-the-problem-finding-entry-points"},{"level":2,"text":"Milestone: The Root of the Problem: Finding Entry Points","id":"milestone-the-root-of-the-problem-finding-entry-points"},{"level":3,"text":"1. Logic Walkthrough","id":"1-logic-walkthrough"},{"level":3,"text":"2. Pitfalls (⚠️)","id":"2-pitfalls-"},{"level":3,"text":"3. Infrastructure Code","id":"3-infrastructure-code"},{"level":3,"text":"4. Core Logic Skeleton (TODOs)","id":"4-core-logic-skeleton-todos"},{"level":3,"text":"5. Verification Code","id":"5-verification-code"},{"level":3,"text":"6. Grading Table","id":"6-grading-table"},{"level":2,"text":"Milestone: The Mark Phase: Mapping the Living","id":"milestone-the-mark-phase-mapping-the-living"},{"level":2,"text":"Milestone: The Mark Phase: Mapping the Living","id":"milestone-the-mark-phase-mapping-the-living"},{"level":3,"text":"1. Logic Walkthrough","id":"1-logic-walkthrough"},{"level":3,"text":"2. Pitfalls (⚠️)","id":"2-pitfalls-"},{"level":3,"text":"3. Infrastructure Code","id":"3-infrastructure-code"},{"level":3,"text":"4. Core Logic Skeleton (TODOs)","id":"4-core-logic-skeleton-todos"},{"level":3,"text":"5. Verification Code","id":"5-verification-code"},{"level":3,"text":"6. Grading Table","id":"6-grading-table"},{"level":2,"text":"Milestone: The Sweep Phase: Reclaiming the Dead","id":"milestone-the-sweep-phase-reclaiming-the-dead"},{"level":2,"text":"Milestone: The Sweep Phase: Reclaiming the Dead","id":"milestone-the-sweep-phase-reclaiming-the-dead"},{"level":3,"text":"1. Logic Walkthrough","id":"1-logic-walkthrough"},{"level":3,"text":"2. Pitfalls (⚠️)","id":"2-pitfalls-"},{"level":3,"text":"3. Infrastructure Code","id":"3-infrastructure-code"},{"level":3,"text":"4. Core Logic Skeleton (TODOs)","id":"4-core-logic-skeleton-todos"},{"level":3,"text":"5. Verification Code","id":"5-verification-code"},{"level":3,"text":"6. Grading Table","id":"6-grading-table"}],"title":"Architecting a Mark-Sweep Garbage Collector","markdown":"# Architecting a Mark-Sweep Garbage Collector\n\n### The Preamble: Architecting a Mark-Sweep Garbage Collector\n\n#### The Analogy: The Great Tethered Expedition\nImagine a vast, dark cavern representing your computer's memory. Inside this cavern are thousands of explorers (objects). To stay \"alive\" and relevant to the mission, an explorer must be connected to the Base Camp (the Stack/Roots) by a physical rope. \n\nSome explorers hold ropes connected directly to the Base Camp. Others hold onto the belts of those explorers, forming long, winding chains deep into the darkness. As long as there is a continuous chain of hands and ropes leading back to the Base Camp, an explorer is considered \"reachable.\"\n\nHowever, in the chaos of the expedition, links are frequently broken. An explorer might let go of their lead to grab a new one, or a chain might be severed entirely. These explorers are now drifting in the dark. They are no longer contributing to the mission, yet they are still consuming oxygen and space (memory). \n\nThe **Mark-Sweep Garbage Collector** is the specialized recovery team. First, they start at the Base Camp and follow every rope, placing a glowing marker on every explorer they can reach (**The Mark Phase**). Once they have traversed every possible chain, they walk through the entire cavern. Anyone not wearing a glowing marker is quietly removed, freeing up their oxygen tanks and space for new explorers (**The Sweep Phase**).\n\n{{DIAGRAM:memory-graph-vs-flat-array}}\n\n---\n\n#### Why This Project Matters\n\nIn the modern software stack, we often treat memory management as a \"solved\" background process—a luxury provided by high-level runtimes like the JVM, V8, or Go. However, treating memory as a black box is a recipe for architectural fragility. \n\nThis project matters because it pulls back the curtain on the most fundamental contract between software and hardware: **Resource Lifecycle.** By building a Mark-Sweep collector from scratch, you transition from a consumer of abstractions to an architect of them.\n\n**1. From Bytes to Biology**\nYou will stop seeing memory as a flat, linear array of hexadecimal addresses. Instead, you will learn to visualize it as a **Directed Graph**. This shift in mental modeling is essential for understanding memory leaks, cache locality, and object lifecycles in any language.\n\n**2. The Engineering of \"Truth\"**\nA Garbage Collector cannot afford to be \"mostly right.\" A single false negative (reclaiming memory that is still in use) results in a catastrophic crash. A single false positive (failing to reclaim dead memory) results in a leak. You will learn to build a system that maintains absolute integrity across complex, nested data structures.\n\n{{DIAGRAM:mark-sweep-lifecycle}}\n\n**3. Mastering the Runtime**\nUnderstanding the Mark-Sweep algorithm is the gateway to advanced systems programming. The concepts we implement here—root scanning, pointer chasing, and atomic metadata management—are the same pillars used to build industrial-grade virtual machines and database engines.\n\nIn this masterclass, we aren't just writing code to delete objects; we are building a robust, automated janitor for the digital world, ensuring that our systems can run indefinitely without drowning in their own exhaustion.\n\n\n# The Architect's Blueprint\n\n# The Architect's Blueprint: Mark-Sweep Garbage Collector\n\nThis document outlines the technical architecture for a Stop-the-World (STW) Mark-Sweep Garbage Collector. The design focuses on a non-moving collector suitable for environments where pointer stability is required.\n\n---\n\n## 1. High-Level Abstraction\n\nThe system is divided into three primary domains: the **Mutator** (the application code), the **Heap Manager**, and the **Collector**.\n\n1.  **The Mutator:** Requests memory and manipulates pointers. It is unaware of the GC until a \"Stop-the-World\" event occurs.\n2.  **The Heap Manager:** Maintains a linked list or bitmap of all allocated blocks. It tracks the \"Object Graph.\"\n3.  **The Collector:** Orchestrates the two-phase reclamation process:\n    *   **Mark Phase:** Performs a depth-first search (DFS) starting from the **Root Set** (stack, registers, globals). It sets a \"marked\" bit on every reachable object.\n    *   **Sweep Phase:** Linearly scans the heap. Any object without the \"marked\" bit is added back to the free list; marked objects have their bits cleared for the next cycle.\n\n{{DIAGRAM:system_overview}}\n*Description: Interaction between the Mutator, the Root Set, and the Managed Heap during the GC lifecycle.*\n\n{{DIAGRAM:mark_sweep_logic}}\n*Description: The transition from the Mark phase (graph traversal) to the Sweep phase (linear reclamation).*\n\n---\n\n## 2. Interface Specifications\n\n### 2.1 Data Structures\n\n#### `struct GC_Object`\nThe header prepended to every allocation.\n*   **`uintptr_t metadata`**: Contains the \"Mark Bit\" (1 bit) and potentially type information for scanning.\n*   **`size_t size`**: The size of the allocation (needed for the Sweep phase to skip blocks).\n*   **`struct GC_Object* next`**: Pointer to the next object in the global allocation list (allows linear sweeping).\n*   *Reason:* Minimizes overhead while providing the Collector with the necessary breadcrumbs to traverse the entire heap regardless of reachability.\n\n#### `struct GC_Heap`\nThe global state of the collector.\n*   **`GC_Object* head`**: Start of the linked list of all managed objects.\n*   **`size_t used_bytes`**: Current memory pressure.\n*   **`size_t threshold`**: The limit that triggers a collection cycle.\n*   **`void** stack_bottom`**: Pointer to the base of the CPU stack to identify roots.\n*   *Reason:* Centralizes tracking and provides the entry point for the Sweep phase.\n\n---\n\n### 2.2 Key Functions & APIs\n\n#### `void* gc_alloc(size_t size)`\n**Signature:** `void* gc_alloc(size_t size)`\n**Pseudocode:**\n1. If `used_bytes + size > threshold`, call `gc_collect()`.\n2. Allocate `size + sizeof(GC_Object)` using system `malloc`.\n3. Initialize `GC_Object` header (mark_bit = 0).\n4. Prepend object to `GC_Heap->head`.\n5. Return pointer to memory immediately following the header.\n\n#### `void gc_collect()`\n**Signature:** `void gc_collect(void)`\n**Pseudocode:**\n1. **Stop-the-World:** Suspend mutator threads (if applicable).\n2. **Mark Phase:**\n   - Identify roots (Stack, Globals).\n   - For each root: `mark_object(root)`.\n3. **Sweep Phase:**\n   - Iterate `GC_Heap->head` list.\n   - If `obj->marked == 1`: set `obj->marked = 0`.\n   - Else: Unlink from list, `free(obj)`.\n4. **Resume-the-World:** Restart mutator.\n\n#### `void mark_object(void* ptr)`\n**Signature:** `void mark_object(void* ptr)`\n**Pseudocode:**\n1. Find `GC_Object` header from `ptr`.\n2. If `header->marked == 1`, return (avoid infinite loops/redundancy).\n3. Set `header->marked = 1`.\n4. Scan the object's memory for potential pointers to other `GC_Objects`.\n5. For each found pointer `p`: `mark_object(p)`.\n\n---\n\n## 3. Project Structure\n\nThe project is organized to separate the core collection logic from the platform-specific stack scanning.\n\n```text\n/project-root\n│\n├── include/\n│   ├── gc.h             # Public API (gc_init, gc_alloc)\n│   └── internal.h       # Private structs (GC_Object, GC_Heap)\n│\n├── src/\n│   ├── allocator.c      # Memory allocation and heap list management\n│   ├── collector.c      # Mark and Sweep phase implementations\n│   ├── scanner.c        # Platform-specific root/stack scanning logic\n│   └── utils.c          # Logging and pointer validation helpers\n│\n├── tests/\n│   ├── test_basic.c     # Simple allocation/reclamation tests\n│   └── test_cycles.c    # Tests for circular reference handling\n│\n└── Makefile             # Build configuration\n```\n\n---\n\n## 4. Implementation Constraints\n\n1.  **Pointer Alignment:** The collector must assume pointers are word-aligned when scanning the stack.\n2.  **False Positives:** As a conservative collector (if type info is unavailable), any bit pattern resembling a valid heap address must be treated as a pointer.\n3.  **Recursion Depth:** The `mark_object` function should ideally use an explicit stack to avoid `StackOverflowError` during deep object graph traversal.\n\n## Milestone: The Anatomy of a Managed Object\n\nThis milestone focuses on the **Anatomy of a Managed Object**. Before we can traverse a graph or sweep memory, we must define the \"Envelope\"—the metadata header that wraps every allocation. This header is the only way the Garbage Collector (GC) can distinguish between raw bytes and a trackable entity.\n\n### 1. Logic Walkthrough\n\nIn a managed environment, the user (the Mutator) asks for $N$ bytes. The allocator, however, reserves $N + \\text{sizeof(Header)}$ bytes. \n\n1.  **The Hidden Tax:** Every object carries a header. The Mutator never sees this; it receives a pointer to the memory *immediately following* the header.\n2.  **The Registry Link:** To perform a **Sweep**, the GC needs to find every object ever allocated, even those no longer reachable by the Mutator. We achieve this by linking every header into a global linked list (the \"Object Registry\") at the moment of allocation.\n3.  **The Mark Bit:** We need at least one bit to store the \"reachability\" status. During the Mark phase, we flip this bit.\n4.  **Pointer Arithmetic:** \n    *   **To User:** `(void*)((char*)header + sizeof(GC_Object))`\n    *   **To Header:** `(GC_Object*)((char*)user_ptr - sizeof(GC_Object))`\n\n{{DIAGRAM:object-layout}}\n*Description: A visualization of the memory block showing the Header (Metadata, Next Pointer, Size) followed by the User Payload.*\n\n---\n\n### 2. Pitfalls (⚠️)\n\n*   **Alignment Corruption:** If your header is 13 bytes, the user payload will be misaligned. This causes significant performance degradation on x86 and crashes on ARM. **Solution:** Always pad the header to 8 or 16 bytes.\n*   **The \"Off-by-Header\" Bug:** Forgetting to subtract the header size when the GC receives a pointer from the stack, leading to reading user data as metadata.\n*   **Header Overwrite:** If the Mutator has a \"buffer overflow\" bug, it will overwrite the *next* object's header, corrupting the GC's global linked list and causing a crash during the next Sweep.\n*   **Size Transparency:** The `size` stored in the header must represent the *payload* size, but the GC must remember to free the *total* size (Header + Payload).\n\n---\n\n### 3. Infrastructure Code\n\nThis code defines the \"Contract\" for every managed object.\n\n```c\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n// Ensure the header is aligned to the platform's word size\ntypedef struct GC_Object {\n    size_t size;                // Size of the payload\n    struct GC_Object* next;     // Global list for the Sweep phase\n    uintptr_t metadata;         // Bit 0: Mark Bit, Bits 1-63: Type Info/Reserved\n} GC_Object;\n\n#define MARK_BIT_MASK 0x1\n#define ALIGNMENT 8\n#define ALIGN(size) (((size) + (ALIGNMENT-1)) & ~(ALIGNMENT-1))\n\n// The Global Heap State\ntypedef struct {\n    GC_Object* head;           // Start of the \"Registry\"\n    size_t total_allocated;\n} GC_Heap;\n\nstatic GC_Heap global_heap = { NULL, 0 };\n```\n\n---\n\n### 4. Core Logic Skeleton (TODOs)\n\nYou must implement the translation layer between the GC and the Mutator.\n\n```c\n/**\n * Wraps a raw allocation with a GC Header.\n */\nvoid* gc_allocate_object(size_t payload_size) {\n    size_t total_size = ALIGN(sizeof(GC_Object) + payload_size);\n    \n    // 1. TODO: Call system malloc for total_size\n    // 2. TODO: Initialize GC_Object fields (mark_bit = 0)\n    // 3. TODO: Prepend this object to global_heap.head (The Registry)\n    \n    // 4. Return the pointer to the PAYLOAD, not the header\n    return NULL; \n}\n\n/**\n * Helper to convert a user pointer back to a GC_Object header.\n */\nGC_Object* get_header(void* user_ptr) {\n    // TODO: Use pointer arithmetic to move backward by sizeof(GC_Object)\n    return NULL;\n}\n\n/**\n * Helper to check if an object is marked.\n */\nbool is_marked(GC_Object* obj) {\n    // TODO: Perform bitwise AND with MARK_BIT_MASK\n    return false;\n}\n```\n\n---\n\n### 5. Verification Code\n\nUse this test to ensure your pointer math and alignment are correct.\n\n```c\n#include <assert.h>\n#include <stdio.h>\n\nvoid verify_milestone_anatomy() {\n    printf(\"Testing Object Anatomy...\\n\");\n\n    size_t request = 20;\n    void* ptr = gc_allocate_object(request);\n    assert(ptr != NULL);\n\n    // Test Pointer Arithmetic\n    GC_Object* header = get_header(ptr);\n    assert((void*)(header + 1) == ptr);\n    \n    // Test Alignment\n    assert(((uintptr_t)ptr % ALIGNMENT) == 0);\n    \n    // Test Registry\n    assert(global_heap.head == header);\n    assert(header->size >= request);\n\n    printf(\"Verification Passed: Header/Payload translation is robust.\\n\");\n}\n```\n\n{{DIAGRAM:pointer-arithmetic-logic}}\n*Description: Flowchart showing the bidirectional conversion between User Pointers and GC Headers.*\n\n---\n\n### 6. Grading Table\n\n| Criteria | Weight | Requirement |\n| :--- | :--- | :--- |\n| **Alignment** | 30% | Payload pointers must be 8-byte aligned. |\n| **Registry Integrity** | 30% | New objects must be correctly prepended to the `global_heap.head` list. |\n| **Header Hiddenness** | 20% | The `gc_allocate_object` must return a pointer to the payload, not the header. |\n| **Metadata Packing** | 20% | Mark bit must be stored within the header (either bitfield or bitwise). |\n\n**Next Step:** Once the anatomy is solid, we will move to **Milestone: The Root Scanner**, where we learn to find these objects by scanning the CPU stack.\n\n\n## Milestone: The Root of the Problem: Finding Entry Points\n\n## Milestone: The Root of the Problem: Finding Entry Points\n\nThis milestone focuses on **Root Discovery**. In a garbage-collected environment, an object is \"alive\" only if it can be reached from a **Root**. If the GC cannot find the starting threads of the web, it will accidentally sweep away the entire heap.\n\n### 1. Logic Walkthrough\n\nThe GC needs to find every pointer currently held by the CPU or the program's execution stack. Since we are building a **Conservative GC** for C, we don't have a \"Type Map\" telling us which stack offsets are pointers and which are just integers.\n\n1.  **Defining the Search Space:** The stack is a contiguous block of memory. It starts at a high address (the `stack_bottom`, captured at the start of `main`) and grows toward a lower address (the current Stack Pointer).\n2.  **The Conservative Assumption:** We treat every word-aligned value on the stack as a *potential* pointer. \n3.  **The Validation Filter:** For every word we find on the stack, we ask three questions:\n    *   Is it aligned to a pointer boundary (e.g., a multiple of 8)?\n    *   Does the value fall between the lowest and highest addresses of our managed heap?\n    *   Does it point to a valid `GC_Object` header we previously registered?\n4.  **Register Spilling:** Pointers might live in CPU registers (like `RAX` or `RBX`) rather than on the RAM stack. To find these, we \"spill\" the registers onto the stack using `setjmp` before we start scanning.\n\n{{DIAGRAM:stack-scanning-process}}\n*Description: The GC scanning the stack from the current top (RSP) to the recorded bottom, identifying values that point into the Managed Heap.*\n\n---\n\n### 2. Pitfalls (⚠️)\n\n*   **The \"False Positive\" Problem:** An integer (like `0x7fff1234`) might happen to match a heap address. A conservative GC must assume it *is* a pointer and keep that memory alive. This is safe (no crashes) but causes \"floating garbage.\"\n*   **Stack Direction:** On almost all modern systems (x86/ARM), the stack grows **downward**. This means `stack_top` (current) is a lower memory address than `stack_bottom`.\n*   **Optimization Erasure:** If a pointer is only held in a register and the compiler optimizes it away or moves it, the GC might not see it. We use `setjmp` or `__attribute__((noinline))` to prevent the compiler from being too clever during a GC cycle.\n*   **Misalignment:** If you scan byte-by-byte, you will find \"ghost pointers\" formed by the tail of one variable and the head of another. **Solution:** Only scan in increments of `sizeof(void*)`.\n\n---\n\n### 3. Infrastructure Code\n\nWe need to capture the environment and define the bounds of our \"searchable\" universe.\n\n```c\n#include <setjmp.h>\n#include <stdint.h>\n\ntypedef struct {\n    uintptr_t heap_start;\n    uintptr_t heap_end;\n    void* stack_bottom;\n} GC_State;\n\nstatic GC_State state;\n\n// Captured at the very beginning of main()\nvoid gc_init(void* stack_base) {\n    state.stack_bottom = stack_base;\n    state.heap_start = UINTPTR_MAX;\n    state.heap_end = 0;\n}\n\n// Update heap bounds every time we allocate\nvoid update_heap_bounds(uintptr_t addr) {\n    if (addr < state.heap_start) state.heap_start = addr;\n    if (addr > state.heap_end) state.heap_end = addr;\n}\n```\n\n---\n\n### 4. Core Logic Skeleton (TODOs)\n\nYou must implement the logic that iterates through the stack and identifies potential roots.\n\n```c\n/**\n * Scans a range of memory (the stack) for potential pointers.\n */\nvoid scan_region(uintptr_t* start, uintptr_t* end) {\n    // Ensure start is lower than end for the loop\n    if (start > end) {\n        uintptr_t* temp = start;\n        start = end;\n        end = temp;\n    }\n\n    // 1. TODO: Iterate from start to end, one word (uintptr_t) at a time\n    for (uintptr_t* p = start; p < end; p++) {\n        uintptr_t val = *p;\n        \n        // 2. TODO: Check if 'val' falls within [state.heap_start, state.heap_end]\n        // 3. TODO: If it looks like a pointer, call mark_object((void*)val)\n    }\n}\n\n/**\n * Triggers the root discovery process.\n */\nvoid find_roots() {\n    jmp_buf regs;\n    setjmp(regs); // Spill registers to the stack\n    \n    void* stack_top = __builtin_frame_address(0);\n    \n    // 4. TODO: Call scan_region using stack_top and state.stack_bottom\n}\n```\n\n---\n\n### 5. Verification Code\n\nThis test ensures that the GC can \"see\" a pointer sitting on the stack.\n\n```c\nvoid test_root_discovery() {\n    printf(\"Testing Root Discovery...\\n\");\n\n    // 1. Allocate something\n    void* volatile local_ptr = gc_allocate_object(64);\n    uintptr_t addr = (uintptr_t)local_ptr;\n\n    // 2. Manually trigger root scanning\n    find_roots();\n\n    // 3. Verify the object was marked\n    GC_Object* header = get_header(local_ptr);\n    // Note: This assumes your mark_object logic is partially ready\n    // or you can check a 'found_on_stack' flag for this milestone.\n    assert(is_marked(header) && \"Error: Local stack pointer was not identified as a root!\");\n\n    printf(\"Verification Passed: Stack pointers are correctly identified.\\n\");\n}\n```\n\n{{DIAGRAM:conservative-pointer-validation}}\n*Description: A logic gate showing the criteria for a stack word to be promoted to a \"Root\": Alignment -> Range Check -> Header Verification.*\n\n---\n\n### 6. Grading Table\n\n| Criteria | Weight | Requirement |\n| :--- | :--- | :--- |\n| **Range Bounds** | 20% | Correct tracking of `heap_start` and `heap_end` during allocation. |\n| **Stack Traversal** | 30% | Correct loop logic to iterate between `stack_top` and `stack_bottom`. |\n| **Word Alignment** | 20% | Scanning must jump by `sizeof(void*)` to avoid unaligned reads. |\n| **Register Spilling** | 15% | Use of `setjmp` or similar to ensure registers are visible on the stack. |\n| **Conservative Safety** | 15% | Logic must not crash if a stack value is a valid address but not a GC object. |\n\n**Next Step:** Now that we can find the roots, we will implement **Milestone: The Trace**, where we follow these roots recursively to mark the entire reachable graph.\n\n\n## Milestone: The Mark Phase: Mapping the Living\n\n## Milestone: The Mark Phase: Mapping the Living\n\nThis milestone focuses on **Graph Traversal**. Now that we can identify \"Roots\" (entry points from the stack), we must follow the trail. The Mark Phase is the process of traversing the directed graph of objects to distinguish between \"live\" data and \"garbage.\"\n\n### 1. Logic Walkthrough\n\nThe Mark Phase is essentially a **Depth-First Search (DFS)** or **Breadth-First Search (BFS)** where the nodes are memory blocks and the edges are pointers.\n\n1.  **The Recursive Discovery:** When a root is identified, we don't just mark that object; we must \"look inside\" it. If that object contains pointers to other objects, those must be marked too.\n2.  **The \"Conservative\" Scan:** Because we are in C, we don't have a \"Type Map\" (a guide telling us where pointers are located inside a struct). Therefore, we treat the **entire payload** of a marked object as a potential source of pointers, just like we did with the stack.\n3.  **Cycle Protection:** In a graph with circular references (e.g., Object A points to B, and B points to A), a naive traversal would loop forever. We use the **Mark Bit** as a \"visited\" flag. If we encounter an object that is already marked, we stop recursing.\n4.  **The Worklist:** While recursion is intuitive, deep data structures (like a linked list with 100,000 nodes) can cause a `Stack Overflow`. Robust collectors often use an explicit **Worklist** (a stack or queue data structure) to manage the traversal.\n\n{{DIAGRAM:mark-traversal-flow}}\n*Description: A visualization of the marking process starting from a Root, traversing through child pointers, and skipping already-marked nodes to handle cycles.*\n\n---\n\n### 2. Pitfalls (⚠️)\n\n*   **Infinite Recursion:** Failing to check the mark bit *before* recursing into an object's fields will cause a crash on any circular data structure.\n*   **Internal Pointers:** In C, a pointer might point to the *middle* of an object (e.g., a pointer to a struct field). A strict GC might miss these. **Solution:** For this milestone, we assume pointers always point to the start of the allocated payload.\n*   **Stack Overflow:** Using standard C recursion for the DFS is dangerous for deep graphs. \n*   **The \"Integer Lookalike\":** Just like stack scanning, scanning an object's payload will find integers that look like addresses. We must validate every potential pointer against our global registry.\n\n---\n\n### 3. Infrastructure Code\n\nTo safely mark, we need a way to verify if a random memory address is actually one of our managed `GC_Object`s.\n\n```c\n/**\n * Validates if a pointer 'p' points to a managed GC_Object.\n * In a production GC, this might use a Hash Map or a Bloom Filter.\n * For now, we iterate our global registry.\n */\nGC_Object* find_header_in_registry(void* p) {\n    GC_Object* current = global_heap.head;\n    while (current != NULL) {\n        // Does 'p' point to the payload of this header?\n        if ((void*)(current + 1) == p) {\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n```\n\n---\n\n### 4. Core Logic Skeleton (TODOs)\n\nYou must implement the recursive marking logic.\n\n```c\n/**\n * Marks an object as live and recursively scans its payload for more pointers.\n */\nvoid mark_object(void* ptr) {\n    if (ptr == NULL) return;\n\n    // 1. TODO: Translate the user pointer to a GC_Object header\n    // 2. TODO: Use find_header_in_registry to ensure it's a valid managed object\n    GC_Object* header = find_header_in_registry(ptr);\n    if (!header) return;\n\n    // 3. TODO: Check if already marked to prevent infinite loops\n    if (is_marked(header)) return;\n\n    // 4. TODO: Set the mark bit\n    header->metadata |= MARK_BIT_MASK;\n\n    // 5. TODO: Scan the object's payload for potential pointers\n    // The payload starts at (header + 1) and has length (header->size)\n    uintptr_t* payload_start = (uintptr_t*)(header + 1);\n    size_t words = header->size / sizeof(uintptr_t);\n\n    for (size_t i = 0; i < words; i++) {\n        // 6. TODO: Recursively call mark_object on every word found in the payload\n        mark_object((void*)payload_start[i]);\n    }\n}\n```\n\n{{DIAGRAM:cycle-detection-logic}}\n*Description: Flowchart showing the \"Check Mark Bit -> Set Mark Bit -> Scan Children\" logic that ensures every reachable object is visited exactly once.*\n\n---\n\n### 5. Verification Code\n\nThis test creates a complex graph (a circular linked list) and verifies that the GC marks all of them starting from a single root.\n\n```c\nvoid test_mark_phase() {\n    printf(\"Testing Mark Phase Traversal...\\n\");\n\n    // 1. Create three objects\n    struct Node { void* next; long data; };\n    struct Node* a = gc_allocate_object(sizeof(struct Node));\n    struct Node* b = gc_allocate_object(sizeof(struct Node));\n    struct Node* c = gc_allocate_object(sizeof(struct Node));\n\n    // 2. Link them in a cycle: A -> B -> C -> A\n    a->next = b;\n    b->next = c;\n    c->next = a;\n\n    // 3. Manually trigger marking from 'a'\n    mark_object(a);\n\n    // 4. Verify all are marked despite the cycle\n    assert(is_marked(get_header(a)));\n    assert(is_marked(get_header(b)));\n    assert(is_marked(get_header(c)));\n\n    printf(\"Verification Passed: Circular graphs are fully traversed and marked.\\n\");\n}\n```\n\n---\n\n### 6. Grading Table\n\n| Criteria | Weight | Requirement |\n| :--- | :--- | :--- |\n| **Recursive Depth** | 20% | Correctly follows pointers from one object into another. |\n| **Cycle Handling** | 30% | Must not enter an infinite loop when objects point to each other. |\n| **Payload Scanning** | 20% | Correctly treats the object payload as a range of potential pointers. |\n| **Pointer Validation** | 20% | Must use the registry to verify pointers before attempting to mark them. |\n| **Null Safety** | 10% | Must gracefully handle NULL pointers or pointers to non-GC memory. |\n\n**Next Step:** With the graph fully mapped and \"Live\" objects glowing with mark bits, we proceed to **Milestone: The Sweep Phase**, where we finally reclaim the unmarked darkness.\n\n\n## Milestone: The Sweep Phase: Reclaiming the Dead\n\n## Milestone: The Sweep Phase: Reclaiming the Dead\n\nThis milestone focuses on **Reclamation**. After the Mark Phase has identified the \"living\" graph, the Sweep Phase performs a linear scan of the entire allocation registry. It is the moment of truth where unreachable memory is finally liberated and the system state is reset for the next cycle.\n\n### 1. Logic Walkthrough\n\nThe Sweep Phase does not traverse the graph; it traverses the **Registry** (the global linked list of all objects created via `gc_alloc`).\n\n1.  **Linear Iteration:** The GC starts at `global_heap.head` and moves through every `GC_Object` using the `next` pointers.\n2.  **The Decision Branch:**\n    *   **If Marked:** The object is reachable. We **clear the mark bit** (reset it to 0) so it’s ready for the next GC cycle. We then move to the next object.\n    *   **If Unmarked:** The object is \"dead.\" It must be unlinked from the registry and its memory returned to the system.\n3.  **Unlinking Logic:** Since this is a singly linked list, removing an object requires keeping track of the `previous` node to bridge the gap.\n4.  **Accounting:** As objects are freed, the `global_heap.total_allocated` counter must be decremented to reflect the current memory pressure accurately.\n\n{{DIAGRAM:sweep-process-flow}}\n*Description: A linear scan of the object registry where unmarked nodes are unlinked and freed, while marked nodes are kept and their bits reset.*\n\n---\n\n### 2. Pitfalls (⚠️)\n\n*   **The \"Head\" Case:** If the very first object in the registry (`global_heap.head`) is dead, you must update the global head pointer itself. Failing to do this leads to a \"Use-After-Free\" when the GC tries to start the next sweep.\n*   **Freeing the Header vs. Payload:** You must call `free()` on the pointer to the **GC_Object header**, not the user payload pointer.\n*   **Dangling `next` Pointers:** When freeing an object, ensure you’ve already captured the pointer to the `next` object in the list, or you will lose the rest of the registry.\n*   **Forgetting the Reset:** If you fail to set `mark_bit = 0` on survivors, every object that was alive during *this* cycle will be considered alive *forever*, leading to a permanent memory leak.\n\n---\n\n### 3. Infrastructure Code\n\nWe need a helper to handle the actual system-level deallocation and accounting.\n\n```c\n#include <stdlib.h>\n\n/**\n * Internal helper to return memory to the OS and update stats.\n */\nvoid gc_free_object(GC_Object* obj) {\n    if (!obj) return;\n\n    // Update global accounting\n    // Note: We subtract the total size (Header + Payload)\n    size_t total_size = ALIGN(sizeof(GC_Object) + obj->size);\n    global_heap.total_allocated -= total_size;\n\n    // Final liberation\n    free(obj);\n}\n```\n\n---\n\n### 4. Core Logic Skeleton (TODOs)\n\nYou must implement the logic that iterates the registry and decides the fate of each object.\n\n```c\n/**\n * Scans the global registry, freeing unmarked objects and resetting marked ones.\n */\nvoid gc_sweep() {\n    GC_Object* current = global_heap.head;\n    GC_Object* prev = NULL;\n\n    while (current != NULL) {\n        // 1. TODO: Check if the object is marked\n        if (is_marked(current)) {\n            // 2. TODO: It's alive! Reset the mark bit for the next cycle\n            current->metadata &= ~MARK_BIT_MASK;\n            \n            // Move pointers forward\n            prev = current;\n            current = current->next;\n        } else {\n            // 3. TODO: It's dead. Capture the next pointer before freeing\n            GC_Object* unreached = current;\n            current = current->next;\n\n            // 4. TODO: Unlink from the list\n            if (prev == NULL) {\n                // We are freeing the head of the list\n                global_heap.head = current;\n            } else {\n                // Bridge the gap\n                prev->next = current;\n            }\n\n            // 5. TODO: Call gc_free_object on the unreached node\n            gc_free_object(unreached);\n        }\n    }\n}\n```\n\n{{DIAGRAM:linked-list-unlinking}}\n*Description: Pointer manipulation required to remove a node from a singly linked list while maintaining the continuity of the registry.*\n\n---\n\n### 5. Verification Code\n\nThis test ensures that dead objects are removed while live ones survive with their state reset.\n\n```c\nvoid test_sweep_phase() {\n    printf(\"Testing Sweep Phase Reclamation...\\n\");\n\n    // 1. Allocate two objects\n    void* live_ptr = gc_allocate_object(32);\n    void* dead_ptr = gc_allocate_object(32);\n    \n    GC_Object* live_header = get_header(live_ptr);\n    GC_Object* dead_header = get_header(dead_ptr);\n    size_t initial_mem = global_heap.total_allocated;\n\n    // 2. Manually mark only one\n    live_header->metadata |= MARK_BIT_MASK;\n\n    // 3. Run Sweep\n    gc_sweep();\n\n    // 4. Verify: Live object survives and is UNMARKED now\n    assert(global_heap.head == live_header);\n    assert(!is_marked(live_header) && \"Error: Mark bit was not reset on survivor!\");\n\n    // 5. Verify: Dead object is gone and memory stats updated\n    assert(live_header->next == NULL);\n    assert(global_heap.total_allocated < initial_mem);\n\n    printf(\"Verification Passed: Dead memory reclaimed, survivors reset.\\n\");\n}\n```\n\n---\n\n### 6. Grading Table\n\n| Criteria | Weight | Requirement |\n| :--- | :--- | :--- |\n| **Unlinking Logic** | 30% | Correctly handles middle-of-list and head-of-list deletions. |\n| **Memory Reclamation** | 30% | Calls `free()` on the correct header address for unmarked objects. |\n| **Mark Bit Reset** | 20% | All surviving objects must have `mark_bit == 0` after sweep. |\n| **Accounting Accuracy** | 10% | `total_allocated` must accurately reflect the heap size after reclamation. |\n| **Pointer Continuity** | 10% | The loop must not lose the `next` pointer when an object is freed. |\n\n**Next Step:** You have completed the core engine! The final step is **Integration**, where we tie the Allocator, Root Scanner, Mark Phase, and Sweep Phase into a single, automated `gc_collect()` trigger.\n\n![The GC Mental Model: Reachability Graph](./diagrams/d1.svg)\n\n![The GC Mental Model: Reachability Graph](./diagrams/d1.svg)\n\n![Object Header Bit-Layout](./diagrams/d2.svg)\n\n![Memory Alignment & Padding](./diagrams/d3.svg)\n\n![The Allocation Registry Linked List](./diagrams/d4.svg)\n\n![Stack Frame Root Discovery](./diagrams/d5.svg)\n\n![Global vs. Local Roots](./diagrams/d6.svg)\n\n![Precise vs. Conservative Scanning](./diagrams/d7.svg)\n\n![The Marking Worklist (DFS)](./diagrams/d8.svg)\n\n![Handling Reference Cycles](./diagrams/d9.svg)\n\n![Tri-Color Marking Concept](./diagrams/d10.svg)\n\n![Type-Specific Traversal Logic](./diagrams/d11.svg)\n\n![The Sweep: Linear Registry Scan](./diagrams/d12.svg)\n\n![Unlinking and Freeing](./diagrams/d13.svg)\n\n![The Mark-Bit Reset Phase](./diagrams/d14.svg)\n\n![GC Trigger Thresholds](./diagrams/d15.svg)\n\n![Complete GC Lifecycle](./diagrams/d16.svg)\n\n![Complete GC Lifecycle](./diagrams/d16.svg)\n"}