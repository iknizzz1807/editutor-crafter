{"html":"<h1 id=\"subscription-amp-billing-system-design-document\">Subscription &amp; Billing System: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>A comprehensive subscription management platform that handles recurring billing, usage tracking, and customer lifecycle management. The key architectural challenge is maintaining consistency across distributed billing operations while supporting complex pricing models, proration calculations, and real-time usage metering.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all milestones - establishes the business and technical context</p>\n</blockquote>\n<h3 id=\"mental-model-the-digital-subscription-economy\">Mental Model: The Digital Subscription Economy</h3>\n<p>Think of subscription billing like running a <strong>premium gym with multiple membership tiers</strong>. In the physical world, a gym might offer basic access, premium classes, and VIP concierge services at different monthly rates. Members can upgrade from basic to premium mid-month (paying the difference), pause their membership during vacation, or cancel at the end of their billing cycle. The gym needs to track who has access to which facilities, when payments are due, how much to charge for partial months, and what happens when a member&#39;s credit card expires.</p>\n<p>Now imagine this gym operates across multiple time zones, serves millions of members simultaneously, never closes for maintenance, and offers hundreds of different membership combinations. The digital subscription economy amplifies every complexity of physical membership management by orders of magnitude.</p>\n<p><strong>Subscription billing systems</strong> are the digital equivalent of that gym&#39;s membership office, but they must handle several additional layers of complexity that don&#39;t exist in physical businesses:</p>\n<ol>\n<li><p><strong>Instant Global Scale</strong>: A software product can acquire thousands of customers overnight across different countries, currencies, and regulatory environments. Unlike a physical gym that grows gradually, digital products can experience explosive growth that breaks traditional billing approaches.</p>\n</li>\n<li><p><strong>Complex Usage Patterns</strong>: Digital services often combine fixed monthly fees with variable usage charges. Think of it like a gym membership that includes basic access but charges extra per personal training session, except the &quot;sessions&quot; might be API calls, storage gigabytes, or processed transactions measured in real-time.</p>\n</li>\n<li><p><strong>Continuous Service Delivery</strong>: Physical gyms can temporarily restrict access for non-payment, but digital services face the challenge of real-time entitlement decisions. When a customer&#39;s payment fails, the system must instantly determine what features to disable while maintaining a path to service restoration.</p>\n</li>\n<li><p><strong>Microscopic Financial Precision</strong>: Digital billing operates at scales where rounding errors of a few cents, multiplied across millions of customers and thousands of plan changes, can result in significant revenue leakage or compliance violations.</p>\n</li>\n</ol>\n<p>The mental model throughout this design will be that we&#39;re building <strong>a fully automated membership management system</strong> for a service that never sleeps, serves global customers, and must make split-second decisions about service access based on complex financial calculations.</p>\n<h3 id=\"existing-approaches-and-trade-offs\">Existing Approaches and Trade-offs</h3>\n<p>When building subscription billing capabilities, engineering teams face a fundamental <strong>build-versus-buy decision</strong> that significantly impacts development velocity, operational complexity, and long-term business flexibility. The landscape includes several mature third-party solutions alongside the option of building a custom system.</p>\n<h4 id=\"third-party-billing-platforms\">Third-Party Billing Platforms</h4>\n<p><strong>Stripe Billing</strong> represents the most popular third-party approach, offering a comprehensive subscription management layer on top of Stripe&#39;s payment processing infrastructure. The platform provides pre-built subscription lifecycle management, automatic proration calculations, and extensive webhook integration for real-time billing events.</p>\n<table>\n<thead>\n<tr>\n<th>Capability</th>\n<th>Stripe Billing</th>\n<th>Custom Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Time to Market</td>\n<td>2-4 weeks integration</td>\n<td>6-12 months development</td>\n</tr>\n<tr>\n<td>Proration Logic</td>\n<td>Pre-built, battle-tested</td>\n<td>Must implement and debug</td>\n</tr>\n<tr>\n<td>Payment Failures</td>\n<td>Automatic retry policies</td>\n<td>Custom dunning management</td>\n</tr>\n<tr>\n<td>Tax Compliance</td>\n<td>Built-in tax calculation</td>\n<td>Manual tax service integration</td>\n</tr>\n<tr>\n<td>Multi-currency</td>\n<td>Native support</td>\n<td>Exchange rate management needed</td>\n</tr>\n<tr>\n<td>Usage Metering</td>\n<td>Basic usage reporting</td>\n<td>Full control over aggregation</td>\n</tr>\n<tr>\n<td>Complex Pricing</td>\n<td>Limited to Stripe&#39;s models</td>\n<td>Unlimited customization</td>\n</tr>\n<tr>\n<td>Vendor Lock-in</td>\n<td>High - data and logic coupling</td>\n<td>None - full ownership</td>\n</tr>\n<tr>\n<td>Monthly Cost</td>\n<td>$0.5% of revenue + payment fees</td>\n<td>Infrastructure + development costs</td>\n</tr>\n</tbody></table>\n<p><strong>Chargebee</strong> and <strong>Recurly</strong> offer similar comprehensive billing platforms with slightly different feature emphases. Chargebee excels at complex pricing models and revenue recognition, while Recurly focuses on subscription analytics and churn reduction features.</p>\n<p><strong>Specialized Platforms</strong> like Lago, Metronome, and Togai have emerged specifically for usage-based billing scenarios. These platforms excel at high-volume event ingestion and complex usage aggregation but may lack the subscription lifecycle sophistication of general-purpose billing platforms.</p>\n<h4 id=\"custom-solution-trade-offs\">Custom Solution Trade-offs</h4>\n<p>Building a custom subscription billing system offers complete control over business logic and data ownership, but introduces significant engineering complexity and ongoing maintenance responsibilities.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: The decision isn&#39;t just about initial development effort - it&#39;s about accepting long-term responsibility for financial accuracy, compliance, and operational reliability in a domain where mistakes directly impact revenue.</p>\n</blockquote>\n<p><strong>Advantages of Custom Development:</strong></p>\n<ul>\n<li><p><strong>Business Logic Flexibility</strong>: Complete control over pricing models, proration algorithms, and subscription lifecycle policies. This becomes crucial for businesses with unique pricing strategies or complex B2B arrangements that don&#39;t fit standard platform templates.</p>\n</li>\n<li><p><strong>Data Ownership and Integration</strong>: Direct access to all billing and usage data without API limitations. This enables sophisticated analytics, machine learning applications, and seamless integration with existing business systems.</p>\n</li>\n<li><p><strong>Cost Predictability</strong>: Fixed infrastructure costs rather than percentage-based fees that scale with revenue. For high-volume businesses, this can represent significant savings compared to platform fees.</p>\n</li>\n<li><p><strong>Performance Optimization</strong>: Ability to optimize database schemas, caching strategies, and processing pipelines for specific usage patterns and scale requirements.</p>\n</li>\n</ul>\n<p><strong>Disadvantages of Custom Development:</strong></p>\n<ul>\n<li><p><strong>Domain Complexity Underestimation</strong>: Subscription billing appears straightforward but contains numerous edge cases around calendar calculations, timezone handling, currency precision, and regulatory compliance. Teams consistently underestimate the effort required to handle these correctly.</p>\n</li>\n<li><p><strong>Financial Accuracy Responsibility</strong>: Custom systems must achieve the same level of financial precision and audit compliance as established platforms, but without the benefit of years of production hardening and edge case discovery.</p>\n</li>\n<li><p><strong>Ongoing Maintenance Burden</strong>: Billing systems require continuous updates for payment processor changes, tax regulation updates, currency support, and security compliance requirements.</p>\n</li>\n<li><p><strong>Expertise Requirements</strong>: Building reliable billing systems requires deep understanding of payment processing, financial regulations, tax compliance, and accounting principles - expertise that may not exist within typical engineering teams.</p>\n</li>\n</ul>\n<h4 id=\"hybrid-approaches\">Hybrid Approaches</h4>\n<p>Many successful implementations combine third-party platforms for core payment processing and basic subscription management with custom systems for business-specific logic and advanced analytics.</p>\n<p><strong>Payment Gateway + Custom Billing Logic</strong>: Use established payment processors (Stripe, Braintree) for payment collection and PCI compliance while building custom subscription management, proration, and usage tracking systems. This approach provides payment reliability while maintaining business logic control.</p>\n<p><strong>Platform Integration with Custom Extensions</strong>: Implement core billing through platforms like Stripe or Chargebee while building custom systems for specialized requirements like complex usage aggregation, custom pricing models, or advanced analytics that exceed platform capabilities.</p>\n<blockquote>\n<p><strong>Architecture Decision: Custom System with Payment Gateway Integration</strong></p>\n<ul>\n<li><strong>Context</strong>: This design document focuses on building a custom subscription billing system that integrates with an existing payment gateway (from the prerequisite payment-gateway project). This represents a middle-ground approach that maintains control over business logic while leveraging proven payment processing infrastructure.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Full third-party platform (Stripe Billing)</li>\n<li>Hybrid payment platform with custom subscription logic</li>\n<li>Completely custom payment and billing system</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Custom billing system with payment gateway integration (Option 2)</li>\n<li><strong>Rationale</strong>: Provides maximum business logic flexibility and data ownership while avoiding the complexity and compliance burden of payment processing. Enables sophisticated usage-based billing and custom proration logic that may not fit platform constraints.</li>\n<li><strong>Consequences</strong>: Requires building and maintaining complex billing logic, but enables unlimited customization and direct data access. Development timeline extends 6-12 months compared to platform integration, but eliminates ongoing percentage-based fees and vendor lock-in.</li>\n</ul>\n</blockquote>\n<h4 id=\"technical-challenges-in-custom-billing-systems\">Technical Challenges in Custom Billing Systems</h4>\n<p>Building reliable subscription billing systems presents several technical challenges that don&#39;t exist in typical CRUD applications:</p>\n<p><strong>Financial Precision and Consistency</strong>: Billing calculations must maintain perfect accuracy across concurrent operations, system failures, and data migrations. Unlike other domains where eventual consistency may be acceptable, financial systems require immediate consistency with full audit trails.</p>\n<p><strong>Complex State Management</strong>: Subscriptions, invoices, and payment states interact in intricate ways that create potential race conditions and inconsistent state scenarios. The system must handle concurrent plan changes, payment processing, and usage updates without compromising data integrity.</p>\n<p><strong>Time-Sensitive Processing</strong>: Billing cycles, trial expirations, and payment retries operate on strict time schedules that cannot be missed. The system must reliably process time-sensitive events even during high load periods or infrastructure failures.</p>\n<p><strong>Multi-Tenant Data Isolation</strong>: Billing systems often serve multiple business entities or customer segments with different pricing rules, tax requirements, and compliance needs. The architecture must ensure complete data isolation while maintaining operational efficiency.</p>\n<p><strong>Integration Complexity</strong>: Modern billing systems integrate with payment processors, tax calculation services, accounting systems, CRM platforms, and business intelligence tools. Each integration introduces potential failure modes and data synchronization challenges.</p>\n<p><strong>Regulatory Compliance</strong>: Subscription billing systems must comply with financial regulations, data privacy laws, and industry-specific requirements that vary by geography and business model. These requirements often change over time, requiring system flexibility.</p>\n<blockquote>\n<p><strong>Critical Design Principle</strong>: In billing systems, correctness is more important than performance, but the system must be designed to achieve both. Financial accuracy cannot be compromised for faster processing, but slow billing operations create poor customer experiences and operational challenges.</p>\n</blockquote>\n<p>The remainder of this design document provides detailed guidance for building a custom subscription billing system that addresses these challenges while maintaining the flexibility advantages that justify custom development over third-party platforms.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The implementation approach for this subscription billing system prioritizes <strong>financial accuracy and auditability</strong> over development speed. The technology choices reflect the need for strong consistency, precise decimal calculations, and reliable event processing.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database</td>\n<td>PostgreSQL with ACID transactions</td>\n<td>PostgreSQL + Redis for session data</td>\n</tr>\n<tr>\n<td>Decimal Precision</td>\n<td>Python <code>decimal.Decimal</code> library</td>\n<td>Custom fixed-point arithmetic</td>\n</tr>\n<tr>\n<td>Task Scheduling</td>\n<td>APScheduler for billing cycles</td>\n<td>Celery + Redis for distributed tasks</td>\n</tr>\n<tr>\n<td>API Framework</td>\n<td>FastAPI with Pydantic validation</td>\n<td>Django REST Framework</td>\n</tr>\n<tr>\n<td>Event Processing</td>\n<td>Direct database triggers</td>\n<td>Event sourcing with Kafka</td>\n</tr>\n<tr>\n<td>Monitoring</td>\n<td>Structured logging + Prometheus</td>\n<td>Full observability stack (traces, metrics, logs)</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td>pytest with factory-boy</td>\n<td>Property-based testing with Hypothesis</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-project-structure\">Recommended Project Structure</h4>\n<p>The codebase organization separates business domain logic from infrastructure concerns, enabling easier testing and future scaling decisions:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>subscription-billing/\n├── src/billing/\n│   ├── __init__.py\n│   ├── domain/                    # Core business logic\n│   │   ├── __init__.py\n│   │   ├── models/                # Business entities\n│   │   │   ├── customer.py\n│   │   │   ├── plan.py\n│   │   │   ├── subscription.py\n│   │   │   └── invoice.py\n│   │   ├── services/              # Business operations\n│   │   │   ├── plan_manager.py\n│   │   │   ├── subscription_engine.py\n│   │   │   ├── proration_calculator.py\n│   │   │   └── usage_tracker.py\n│   │   └── exceptions.py\n│   ├── infrastructure/            # External integrations\n│   │   ├── database/\n│   │   │   ├── repositories.py\n│   │   │   └── migrations/\n│   │   ├── payment_gateway/\n│   │   │   └── gateway_client.py\n│   │   ├── events/\n│   │   │   └── webhook_handlers.py\n│   │   └── tasks/\n│   │       └── billing_jobs.py\n│   ├── api/                       # HTTP interface\n│   │   ├── __init__.py\n│   │   ├── routers/\n│   │   │   ├── plans.py\n│   │   │   ├── subscriptions.py\n│   │   │   └── usage.py\n│   │   ├── schemas/               # Request/response models\n│   │   └── dependencies.py\n│   └── config/\n│       ├── settings.py\n│       └── logging.py\n├── tests/\n│   ├── unit/\n│   ├── integration/\n│   └── fixtures/\n├── scripts/\n│   ├── migrate_data.py\n│   └── billing_reconciliation.py\n├── docker-compose.yml\n├── requirements.txt\n└── README.md</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Database Connection and Transaction Management</strong> (<code>infrastructure/database/connection.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> contextlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Generator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> psycopg2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> psycopg2.extras </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> RealDictCursor</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> psycopg2.extensions </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ISOLATION_LEVEL_SERIALIZABLE</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DatabaseManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages database connections with transaction support for billing operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, connection_string: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.connection_string </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> connection_string</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._setup_decimal_adapter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _setup_decimal_adapter</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Configure psycopg2 to handle Python Decimal objects properly.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        from</span><span style=\"color:#E1E4E8\"> psycopg2.extensions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> register_adapter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        from</span><span style=\"color:#E1E4E8\"> psycopg2 </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sql</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#B392F0\"> adapt_decimal</span><span style=\"color:#E1E4E8\">(decimal_obj):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> sql.Literal(</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(decimal_obj))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        register_adapter(Decimal, adapt_decimal)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @contextlib.contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> transaction</span><span style=\"color:#E1E4E8\">(self, isolation_level</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">ISOLATION_LEVEL_SERIALIZABLE</span><span style=\"color:#E1E4E8\">) -> Generator:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Provides transactional context for billing operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Uses SERIALIZABLE isolation to prevent financial inconsistencies.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        conn </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> psycopg2.connect(</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.connection_string,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            cursor_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">RealDictCursor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        conn.set_isolation_level(isolation_level)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            yield</span><span style=\"color:#E1E4E8\"> conn</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            conn.commit()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logger.info(</span><span style=\"color:#9ECBFF\">\"Transaction committed successfully\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            conn.rollback()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Transaction rolled back due to error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        finally</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            conn.close()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> execute_query</span><span style=\"color:#E1E4E8\">(self, query: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, params</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute a read-only query and return results.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.transaction() </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> conn:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cursor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> conn.cursor()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cursor.execute(query, params)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> cursor.fetchall()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Global database instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DatabaseManager(</span><span style=\"color:#9ECBFF\">\"postgresql://billing:password@localhost/billing_db\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Money and Currency Handling</strong> (<code>domain/value_objects.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal, </span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Immutable money value that maintains precision and currency information.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Always stores amounts in the smallest currency unit (e.g., cents for USD).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    amount_cents: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currency_code: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> re.match(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">^[A-Z]</span><span style=\"color:#F97583\">{3}</span><span style=\"color:#79B8FF\">$</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Invalid currency code: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.currency_code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Amount must be stored as integer cents\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_decimal</span><span style=\"color:#E1E4E8\">(cls, amount: Union[Decimal, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], currency: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create Money from decimal amount (e.g., 19.99 USD).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        decimal_amount </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(amount))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(decimal_amount.quantize(Decimal(</span><span style=\"color:#9ECBFF\">'0.01'</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">rounding</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(cents, currency.upper())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_decimal</span><span style=\"color:#E1E4E8\">(self) -> Decimal:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert to decimal representation (e.g., 1999 cents -> 19.99).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 100</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __add__</span><span style=\"color:#E1E4E8\">(self, other: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.currency_code:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Cannot add </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.currency_code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> and </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">other.currency_code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Money(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> other.amount_cents, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __sub__</span><span style=\"color:#E1E4E8\">(self, other: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.currency_code:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Cannot subtract </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.currency_code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> and </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">other.currency_code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Money(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> other.amount_cents, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __mul__</span><span style=\"color:#E1E4E8\">(self, factor: Union[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Decimal]) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Multiply money by a factor, rounding to nearest cent.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(factor, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> Money(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> factor, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        decimal_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(factor))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rounded_cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(decimal_result.quantize(Decimal(</span><span style=\"color:#9ECBFF\">'1'</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">rounding</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Money(rounded_cents, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_zero</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_positive</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_negative</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Currency definitions for validation</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">SUPPORTED_CURRENCIES</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'USD'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'US Dollar'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'$'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'EUR'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Euro'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'€'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'GBP'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'British Pound'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'£'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_currency</span><span style=\"color:#E1E4E8\">(currency_code: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validate that currency is supported by the system.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> currency_code.upper() </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span></span></code></pre></div>\n\n<p><strong>Event Logging for Audit Trails</strong> (<code>infrastructure/audit/event_logger.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuditEventType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUBSCRIPTION_CREATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription_created\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUBSCRIPTION_UPDATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription_updated\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PLAN_CHANGED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"plan_changed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAYMENT_PROCESSED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"payment_processed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    USAGE_RECORDED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"usage_recorded\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVOICE_GENERATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"invoice_generated\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuditLogger</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Immutable audit trail for all billing operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Required for compliance and debugging billing issues.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, database_manager):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> database_manager</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{__name__}</span><span style=\"color:#9ECBFF\">.audit\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> log_event</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        event_type: AuditEventType,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entity_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entity_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        changes: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        actor_id: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        metadata: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Log a billing operation event with complete context.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        All events are immutable and permanently stored.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        event_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'event_id'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._generate_event_id(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'timestamp'</span><span style=\"color:#E1E4E8\">: datetime.now(timezone.utc).isoformat(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'event_type'</span><span style=\"color:#E1E4E8\">: event_type.value,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'entity_id'</span><span style=\"color:#E1E4E8\">: entity_id,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'entity_type'</span><span style=\"color:#E1E4E8\">: entity_type,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'actor_id'</span><span style=\"color:#E1E4E8\">: actor_id,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'changes'</span><span style=\"color:#E1E4E8\">: changes </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'metadata'</span><span style=\"color:#E1E4E8\">: metadata </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Log to application logs for immediate visibility</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger.info(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Audit Event: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">event_type.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">extra</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">event_data)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Store in database for permanent audit trail</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._store_audit_event(event_data)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _generate_event_id</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate unique event identifier.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(uuid.uuid4())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _store_audit_event</span><span style=\"color:#E1E4E8\">(self, event_data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Store audit event in database audit table.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        query </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        INSERT INTO audit_events (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            event_id, timestamp, event_type, entity_id, entity_type,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            actor_id, changes, metadata</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ) VALUES (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            %(event_id)s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%(timestamp)s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%(event_type)s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%(entity_id)s</span><span style=\"color:#9ECBFF\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            %(entity_type)s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%(actor_id)s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%(changes)s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%(metadata)s</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        )</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Convert dictionaries to JSON strings for storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        params </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> event_data.copy()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        params[</span><span style=\"color:#9ECBFF\">'changes'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.dumps(params[</span><span style=\"color:#9ECBFF\">'changes'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        params[</span><span style=\"color:#9ECBFF\">'metadata'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.dumps(params[</span><span style=\"color:#9ECBFF\">'metadata'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.db.transaction() </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> conn:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cursor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> conn.cursor()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cursor.execute(query, params)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Audit logging failure should not break business operations</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Failed to store audit event: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Global audit logger instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">audit_logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> AuditLogger(db)</span></span></code></pre></div>\n\n<h4 id=\"core-system-configuration\">Core System Configuration</h4>\n<p><strong>Application Settings</strong> (<code>config/settings.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BillingSettings</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Central configuration for billing system behavior.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Database configuration</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DATABASE_URL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> os.getenv(</span><span style=\"color:#9ECBFF\">'DATABASE_URL'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'postgresql://billing:password@localhost/billing_db'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Payment gateway integration</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAYMENT_GATEWAY_URL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> os.getenv(</span><span style=\"color:#9ECBFF\">'PAYMENT_GATEWAY_URL'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'http://localhost:8001'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAYMENT_GATEWAY_API_KEY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> os.getenv(</span><span style=\"color:#9ECBFF\">'PAYMENT_GATEWAY_API_KEY'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Billing cycle configuration</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEFAULT_BILLING_ANCHOR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#6A737D\">  # Day of month for monthly billing</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BILLING_GRACE_PERIOD_DAYS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MAX_PAYMENT_RETRIES</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAYMENT_RETRY_DELAYS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># Days between retry attempts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Currency and precision settings</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEFAULT_CURRENCY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'USD'</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUPPORTED_CURRENCIES</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'USD'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'EUR'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'GBP'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DECIMAL_PRECISION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#9ECBFF\">'0.01'</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Cent precision</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Usage billing configuration</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    USAGE_AGGREGATION_WINDOW</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3600</span><span style=\"color:#6A737D\">  # Seconds (1 hour)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MAX_USAGE_EVENTS_PER_REQUEST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    USAGE_IDEMPOTENCY_WINDOW_HOURS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 24</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Trial and subscription defaults</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEFAULT_TRIAL_DAYS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 14</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUBSCRIPTION_REACTIVATION_GRACE_DAYS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # System limits</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MAX_PLAN_FEATURES</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 50</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MAX_PRICING_TIERS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 10</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Webhook configuration</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WEBHOOK_TIMEOUT_SECONDS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WEBHOOK_RETRY_ATTEMPTS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_currency_config</span><span style=\"color:#E1E4E8\">(cls, currency_code: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get configuration for specific currency.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currency_configs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'USD'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'$'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'EUR'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'€'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'GBP'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'£'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> currency_configs.get(currency_code, currency_configs[</span><span style=\"color:#9ECBFF\">'USD'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">settings </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BillingSettings()</span></span></code></pre></div>\n\n<h4 id=\"development-and-testing-setup\">Development and Testing Setup</h4>\n<p><strong>Docker Compose for Local Development</strong> (<code>docker-compose.yml</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">yaml</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#85E89D\">version</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'3.8'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#85E89D\">services</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  postgres</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    image</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">postgres:15</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    environment</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      POSTGRES_DB</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">billing_db</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      POSTGRES_USER</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">billing</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      POSTGRES_PASSWORD</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">password</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    ports</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      - </span><span style=\"color:#9ECBFF\">\"5432:5432\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    volumes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      - </span><span style=\"color:#9ECBFF\">billing_postgres_data:/var/lib/postgresql/data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      - </span><span style=\"color:#9ECBFF\">./scripts/init_db.sql:/docker-entrypoint-initdb.d/init_db.sql</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  redis</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    image</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">redis:7-alpine</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    ports</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      - </span><span style=\"color:#9ECBFF\">\"6379:6379\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  billing_api</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    build</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">.</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    ports</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      - </span><span style=\"color:#9ECBFF\">\"8000:8000\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    environment</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      DATABASE_URL</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">postgresql://billing:password@postgres:5432/billing_db</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      REDIS_URL</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">redis://redis:6379</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    depends_on</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      - </span><span style=\"color:#9ECBFF\">postgres</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      - </span><span style=\"color:#9ECBFF\">redis</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    volumes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      - </span><span style=\"color:#9ECBFF\">.:/app</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    command</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">python -m uvicorn src.billing.api.main:app --host 0.0.0.0 --reload</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#85E89D\">volumes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  billing_postgres_data</span><span style=\"color:#E1E4E8\">:</span></span></code></pre></div>\n\n<h4 id=\"key-development-patterns\">Key Development Patterns</h4>\n<p><strong>Error Handling Strategy</strong>: The billing system implements a <strong>fail-fast with detailed context</strong> approach. Financial operations either complete successfully with full audit trails or fail immediately with sufficient information for debugging and customer communication.</p>\n<p><strong>Testing Philosophy</strong>: Every financial calculation includes property-based tests that verify mathematical properties (e.g., <code>upgrade_charge + downgrade_credit = 0</code> for immediate plan switches). Unit tests cover edge cases while integration tests validate complete billing workflows.</p>\n<p><strong>Monitoring and Alerting</strong>: The system logs all financial operations at INFO level with structured data, enabling real-time monitoring of billing accuracy and performance. Critical financial discrepancies trigger immediate alerts.</p>\n<blockquote>\n<p><strong>Development Checkpoint</strong>: After setting up this infrastructure, you should be able to start the application with <code>docker-compose up</code> and see a healthy PostgreSQL connection with proper decimal handling. Test the Money class with various currency calculations to verify precision handling works correctly.</p>\n</blockquote>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all milestones - establishes scope and requirements for the subscription billing system</p>\n</blockquote>\n<h3 id=\"mental-model-building-a-financial-operating-system\">Mental Model: Building a Financial Operating System</h3>\n<p>Think of the subscription billing system as a <strong>financial operating system</strong> for digital businesses. Just like how your computer&#39;s operating system manages resources, schedules tasks, and provides services to applications, our billing system manages financial resources, schedules recurring payments, and provides billing services to business applications.</p>\n<p>Consider Netflix&#39;s subscription model. When you sign up, the system must track your plan selection, manage your free trial period, automatically charge your payment method each month on your billing anniversary, handle plan upgrades when you switch from Basic to Premium, calculate prorated charges if you upgrade mid-month, track your viewing hours for potential usage-based features, generate invoices with proper tax calculations, retry failed payments with smart dunning logic, and gracefully handle cancellations while maintaining data integrity. This complexity multiplied across millions of subscribers requires a robust, reliable financial operating system.</p>\n<p>The key insight is that subscription billing is not just about charging credit cards monthly. It&#39;s about managing complex financial relationships over time, handling state transitions reliably, maintaining audit trails for compliance, and ensuring every cent is accounted for with mathematical precision. Like an operating system, it must be reliable, performant, and extensible while hiding complexity from the applications that use it.</p>\n<h3 id=\"functional-requirements\">Functional Requirements</h3>\n<p>The subscription billing system must provide comprehensive lifecycle management capabilities that handle every aspect of the customer&#39;s financial journey from trial signup through cancellation and beyond.</p>\n<h4 id=\"core-subscription-management\">Core Subscription Management</h4>\n<p>The system must support flexible subscription creation with multiple plan tiers and pricing models. Every customer must be able to select from available plans, with the system automatically provisioning their subscription with the correct billing cycle, feature entitlements, and payment schedule. The platform must handle multiple billing intervals including monthly, quarterly, and annual cycles, with proper calendar handling for edge cases like month-end dates.</p>\n<table>\n<thead>\n<tr>\n<th>Capability</th>\n<th>Description</th>\n<th>Business Rules</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Plan Selection</td>\n<td>Customer chooses from available subscription tiers</td>\n<td>Must validate plan availability and currency support</td>\n</tr>\n<tr>\n<td>Trial Management</td>\n<td>Free trial periods with automatic conversion</td>\n<td>Trial length configurable per plan, requires payment method on file</td>\n</tr>\n<tr>\n<td>Billing Cycles</td>\n<td>Multiple billing intervals (monthly, quarterly, annual)</td>\n<td>Billing anchor date preserved across cycles, handle calendar edge cases</td>\n</tr>\n<tr>\n<td>Feature Provisioning</td>\n<td>Grant access based on subscription tier</td>\n<td>Real-time feature flag updates, immediate access changes</td>\n</tr>\n<tr>\n<td>Multi-Currency Support</td>\n<td>Global customer base with local currencies</td>\n<td>Support major currencies, handle exchange rate fluctuations</td>\n</tr>\n</tbody></table>\n<h4 id=\"plan-and-pricing-flexibility\">Plan and Pricing Flexibility</h4>\n<p>The system must accommodate diverse pricing strategies that businesses use to optimize revenue. This includes flat-rate subscriptions, per-seat pricing for team plans, tiered usage allowances, and volume-based discounts. Plan management must support versioning to protect existing customers while allowing businesses to evolve their pricing strategies.</p>\n<table>\n<thead>\n<tr>\n<th>Pricing Model</th>\n<th>Implementation Requirements</th>\n<th>Edge Cases</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Flat-Rate</td>\n<td>Fixed monthly/annual fee</td>\n<td>Handle currency precision, tax calculations</td>\n</tr>\n<tr>\n<td>Per-Seat</td>\n<td>Base price plus per-user charges</td>\n<td>Seat additions/removals mid-cycle, minimum seat requirements</td>\n</tr>\n<tr>\n<td>Tiered Usage</td>\n<td>Included allowance plus overage rates</td>\n<td>Usage tracking accuracy, billing period boundaries</td>\n</tr>\n<tr>\n<td>Volume Discounts</td>\n<td>Price breaks at usage thresholds</td>\n<td>Retroactive discounts vs progressive pricing</td>\n</tr>\n<tr>\n<td>Custom Contracts</td>\n<td>Enterprise-specific pricing terms</td>\n<td>Contract versioning, approval workflows</td>\n</tr>\n</tbody></table>\n<h4 id=\"subscription-lifecycle-transitions\">Subscription Lifecycle Transitions</h4>\n<p>The system must handle every possible subscription state change with proper validation, audit logging, and downstream effects. State transitions must be atomic to prevent inconsistent states, and all changes must trigger appropriate notifications and integrations.</p>\n<table>\n<thead>\n<tr>\n<th>State Transition</th>\n<th>Trigger Conditions</th>\n<th>Required Actions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Trial → Active</td>\n<td>Trial period expires, valid payment method</td>\n<td>Process first payment, activate features, send welcome email</td>\n</tr>\n<tr>\n<td>Active → Past Due</td>\n<td>Payment failure</td>\n<td>Disable features based on grace period policy, start dunning sequence</td>\n</tr>\n<tr>\n<td>Past Due → Active</td>\n<td>Successful payment retry</td>\n<td>Restore full access, clear past due status, update billing cycle</td>\n</tr>\n<tr>\n<td>Active → Cancelled</td>\n<td>Customer or admin cancellation</td>\n<td>Calculate final charges, schedule termination, retain data per policy</td>\n</tr>\n<tr>\n<td>Cancelled → Active</td>\n<td>Reactivation within grace period</td>\n<td>Restore subscription state, recalculate billing, reactivate features</td>\n</tr>\n</tbody></table>\n<h4 id=\"proration-and-plan-changes\">Proration and Plan Changes</h4>\n<p>Mid-cycle plan changes require sophisticated proration calculations that account for time remaining in the billing period, feature usage to date, and credit management. The system must support both immediate and scheduled plan changes, with proper financial reconciliation in all cases.</p>\n<blockquote>\n<p><strong>Critical Design Principle</strong>: Proration calculations must be deterministic and auditable. The same inputs must always produce identical outputs, and every calculation step must be logged for customer service and compliance purposes.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Change Type</th>\n<th>Calculation Method</th>\n<th>Credit Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Upgrade</td>\n<td>Prorated charge for price difference</td>\n<td>Immediate charge to payment method</td>\n</tr>\n<tr>\n<td>Downgrade</td>\n<td>Credit for unused higher-tier value</td>\n<td>Apply credit to customer balance for future invoices</td>\n</tr>\n<tr>\n<td>Quantity Increase</td>\n<td>Prorated charge for additional seats/units</td>\n<td>Immediate charge based on remaining billing period</td>\n</tr>\n<tr>\n<td>Quantity Decrease</td>\n<td>Credit for removed seats/units</td>\n<td>Credit application with configurable timing</td>\n</tr>\n</tbody></table>\n<h4 id=\"usage-based-billing-integration\">Usage-Based Billing Integration</h4>\n<p>For products with consumption-based pricing, the system must accurately track usage events, aggregate them across billing periods, and convert usage into billable charges. Usage tracking must be idempotent to handle duplicate events, and aggregation must be mathematically precise to prevent revenue leakage or customer disputes.</p>\n<p>The usage engine must support multiple aggregation methods including sum (total API calls), count (number of transactions), maximum (peak concurrent users), and last-value (storage at end of period). Each aggregation method serves different billing models and requires different handling of late-arriving data.</p>\n<table>\n<thead>\n<tr>\n<th>Usage Pattern</th>\n<th>Aggregation Method</th>\n<th>Billing Calculation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>API Calls</td>\n<td>Sum across billing period</td>\n<td>Total calls × per-call rate + overage tiers</td>\n</tr>\n<tr>\n<td>Storage</td>\n<td>Last value in period</td>\n<td>GB-months × storage rate</td>\n</tr>\n<tr>\n<td>Concurrent Users</td>\n<td>Maximum daily peak</td>\n<td>Peak users × per-user rate</td>\n</tr>\n<tr>\n<td>Transactions</td>\n<td>Count with deduplication</td>\n<td>Transaction count × per-transaction fee</td>\n</tr>\n<tr>\n<td>Bandwidth</td>\n<td>Sum with time weighting</td>\n<td>Total GB × bandwidth rate + burst charges</td>\n</tr>\n</tbody></table>\n<h3 id=\"non-functional-requirements\">Non-Functional Requirements</h3>\n<p>The billing system operates in a high-stakes environment where errors directly impact revenue and customer trust. Non-functional requirements are not optional nice-to-haves but essential characteristics that determine system success.</p>\n<h4 id=\"financial-precision-and-data-integrity\">Financial Precision and Data Integrity</h4>\n<p>All monetary calculations must maintain cent-level precision throughout the system lifecycle. The system must use the <code>Money</code> value object with fixed-point arithmetic to eliminate floating-point precision errors that could accumulate into significant revenue discrepancies over millions of transactions.</p>\n<table>\n<thead>\n<tr>\n<th>Precision Requirement</th>\n<th>Implementation Standard</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Currency Calculations</td>\n<td>Store all amounts in smallest currency unit (cents)</td>\n<td>Automated reconciliation against payment processor</td>\n</tr>\n<tr>\n<td>Proration Math</td>\n<td>Use <code>DECIMAL_PRECISION</code> constant for rounding</td>\n<td>Unit tests with known edge cases, property-based testing</td>\n</tr>\n<tr>\n<td>Tax Calculations</td>\n<td>Round per jurisdiction rules</td>\n<td>Integration tests with tax service providers</td>\n</tr>\n<tr>\n<td>Exchange Rates</td>\n<td>Daily rate updates with historical tracking</td>\n<td>Compare against multiple rate sources</td>\n</tr>\n<tr>\n<td>Audit Trail</td>\n<td>Every calculation step logged</td>\n<td>End-to-end audit reports match transaction details</td>\n</tr>\n</tbody></table>\n<h4 id=\"performance-and-scalability-targets\">Performance and Scalability Targets</h4>\n<p>The system must handle enterprise-scale workloads with predictable performance characteristics. Billing operations have natural batch processing windows (monthly cycles) but also require real-time responsiveness for customer-facing operations like plan changes and usage queries.</p>\n<table>\n<thead>\n<tr>\n<th>Operation Type</th>\n<th>Performance Target</th>\n<th>Scalability Requirement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Plan Changes</td>\n<td>&lt; 2 seconds end-to-end</td>\n<td>Handle 1000 concurrent plan changes</td>\n</tr>\n<tr>\n<td>Usage Event Ingestion</td>\n<td>&lt; 100ms per event, 10K events/second</td>\n<td>Linear scaling with processing nodes</td>\n</tr>\n<tr>\n<td>Monthly Billing Run</td>\n<td>Process 100K subscriptions in 4 hours</td>\n<td>Parallel processing with progress tracking</td>\n</tr>\n<tr>\n<td>Invoice Generation</td>\n<td>&lt; 5 seconds per invoice</td>\n<td>Support 1M+ invoices per billing cycle</td>\n</tr>\n<tr>\n<td>Payment Processing</td>\n<td>&lt; 10 seconds including gateway roundtrip</td>\n<td>Graceful degradation during gateway issues</td>\n</tr>\n</tbody></table>\n<h4 id=\"reliability-and-fault-tolerance\">Reliability and Fault Tolerance</h4>\n<p>Billing system failures can result in lost revenue, duplicate charges, or compliance violations. The system must be designed for high availability with comprehensive error recovery and graceful degradation capabilities.</p>\n<blockquote>\n<p><strong>Reliability Principle</strong>: Every billing operation must be either fully completed or safely rolled back. Partial states that could result in financial discrepancies are unacceptable.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Failure Scenario</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database Connection Loss</td>\n<td>Health checks every 30 seconds</td>\n<td>Automatic failover to read replica, queue writes</td>\n</tr>\n<tr>\n<td>Payment Gateway Timeout</td>\n<td>Request timeout after 30 seconds</td>\n<td>Retry with exponential backoff, manual reconciliation queue</td>\n</tr>\n<tr>\n<td>Proration Calculation Error</td>\n<td>Input validation and range checks</td>\n<td>Fallback to manual approval workflow</td>\n</tr>\n<tr>\n<td>Usage Data Corruption</td>\n<td>Checksum validation on aggregation</td>\n<td>Rebuild from raw events, alert operations team</td>\n</tr>\n<tr>\n<td>Billing Cycle Processing Failure</td>\n<td>Progress tracking and heartbeat monitoring</td>\n<td>Resume from last checkpoint, skip completed records</td>\n</tr>\n</tbody></table>\n<h4 id=\"security-and-compliance-standards\">Security and Compliance Standards</h4>\n<p>The billing system handles sensitive financial data and must meet stringent security requirements including PCI DSS Level 1 compliance for payment card data handling. All financial operations must maintain comprehensive audit trails for regulatory compliance and customer dispute resolution.</p>\n<table>\n<thead>\n<tr>\n<th>Security Domain</th>\n<th>Requirement</th>\n<th>Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Data Encryption</td>\n<td>All PII and financial data encrypted at rest and in transit</td>\n<td>AES-256 encryption, TLS 1.3 for transport</td>\n</tr>\n<tr>\n<td>Access Control</td>\n<td>Role-based permissions with principle of least privilege</td>\n<td>Integration with identity provider, session management</td>\n</tr>\n<tr>\n<td>Audit Logging</td>\n<td>Every billing operation logged with actor identification</td>\n<td>Immutable audit log, tamper detection</td>\n</tr>\n<tr>\n<td>PCI Compliance</td>\n<td>Never store payment card data in billing database</td>\n<td>Token-based payment references, annual compliance audit</td>\n</tr>\n<tr>\n<td>Data Retention</td>\n<td>Customer data retention per privacy regulations</td>\n<td>Automated data lifecycle management, right to deletion</td>\n</tr>\n</tbody></table>\n<h3 id=\"explicit-non-goals\">Explicit Non-Goals</h3>\n<p>Clearly defining what the subscription billing system will <strong>not</strong> handle is crucial for maintaining focus and preventing scope creep. These exclusions represent deliberate architectural decisions that keep the system focused on its core competencies.</p>\n<h4 id=\"payment-processing-infrastructure\">Payment Processing Infrastructure</h4>\n<p>The billing system will <strong>not</strong> implement direct payment processing capabilities such as credit card authorization, fraud detection, or PCI-compliant card data storage. These capabilities are provided by the prerequisite payment gateway system, which handles all sensitive payment operations and compliance requirements.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Capability</th>\n<th>Rationale</th>\n<th>Alternative Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Credit Card Processing</td>\n<td>Requires PCI Level 1 compliance infrastructure</td>\n<td>Integrate with existing payment gateway</td>\n</tr>\n<tr>\n<td>Fraud Detection</td>\n<td>Specialized domain requiring ML models and risk databases</td>\n<td>Use payment processor&#39;s fraud services</td>\n</tr>\n<tr>\n<td>Payment Method Storage</td>\n<td>Complex PCI compliance and security requirements</td>\n<td>Store tokenized references only</td>\n</tr>\n<tr>\n<td>Chargeback Management</td>\n<td>Requires specialized dispute handling processes</td>\n<td>Payment gateway handles disputes</td>\n</tr>\n<tr>\n<td>Bank Account Verification</td>\n<td>Complex regulatory requirements vary by jurisdiction</td>\n<td>Use payment processor&#39;s ACH services</td>\n</tr>\n</tbody></table>\n<h4 id=\"advanced-revenue-recognition\">Advanced Revenue Recognition</h4>\n<p>The system will not implement complex revenue recognition rules required for GAAP or IFRS financial reporting. While the system tracks subscription revenue and provides basic reporting, sophisticated revenue recognition with contract modifications, performance obligations, and accounting standard compliance is outside scope.</p>\n<blockquote>\n<p><strong>Boundary Decision</strong>: The billing system focuses on operational billing accuracy rather than accounting compliance. Financial reporting requirements should be handled by dedicated accounting systems that consume billing data.</p>\n</blockquote>\n<h4 id=\"complex-tax-calculation\">Complex Tax Calculation</h4>\n<p>The system will not implement comprehensive tax calculation engines for sales tax, VAT, or other jurisdiction-specific tax requirements. Basic tax rate application is supported, but complex tax scenarios such as tax nexus determination, exemption certificate management, and regulatory filing are handled by specialized tax services.</p>\n<table>\n<thead>\n<tr>\n<th>Tax Complexity</th>\n<th>System Support</th>\n<th>External Integration</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Simple Tax Rates</td>\n<td>Apply configured rates per jurisdiction</td>\n<td>Built-in capability</td>\n</tr>\n<tr>\n<td>Tax Nexus Rules</td>\n<td>Not supported</td>\n<td>Integrate with tax calculation service</td>\n</tr>\n<tr>\n<td>Exemption Certificates</td>\n<td>Not supported</td>\n<td>Use tax service certificate management</td>\n</tr>\n<tr>\n<td>Regulatory Filing</td>\n<td>Not supported</td>\n<td>Export data to tax compliance system</td>\n</tr>\n<tr>\n<td>Multi-jurisdictional Compliance</td>\n<td>Not supported</td>\n<td>Tax service handles compliance</td>\n</tr>\n</tbody></table>\n<h4 id=\"enterprise-contract-management\">Enterprise Contract Management</h4>\n<p>The system will not support complex enterprise contract features such as custom approval workflows, contract negotiation tracking, or sophisticated discount approval chains. While the system supports flexible pricing and custom plans, it assumes these configurations are managed through administrative interfaces rather than complex contract lifecycle management.</p>\n<h4 id=\"multi-tenant-architecture\">Multi-Tenant Architecture</h4>\n<p>The initial system design assumes a single-tenant deployment model. While the data model and service architecture are designed to be tenant-aware for future extension, the system will not initially support multiple isolated customer organizations within a single deployment instance.</p>\n<h4 id=\"real-time-analytics-and-business-intelligence\">Real-Time Analytics and Business Intelligence</h4>\n<p>The system will not include sophisticated analytics dashboards, revenue forecasting, or business intelligence capabilities. While basic subscription metrics and billing reports are provided, advanced analytics should be handled by dedicated business intelligence systems that consume billing data through APIs.</p>\n<table>\n<thead>\n<tr>\n<th>Analytics Type</th>\n<th>System Capability</th>\n<th>External Tool Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Basic Subscription Metrics</td>\n<td>Count active subscriptions, MRR calculation</td>\n<td>Built-in reporting</td>\n</tr>\n<tr>\n<td>Customer Lifecycle Analysis</td>\n<td>Not supported</td>\n<td>Business intelligence platform</td>\n</tr>\n<tr>\n<td>Revenue Forecasting</td>\n<td>Not supported</td>\n<td>Analytics platform</td>\n</tr>\n<tr>\n<td>Cohort Analysis</td>\n<td>Not supported</td>\n<td>Data warehouse and BI tools</td>\n</tr>\n<tr>\n<td>Churn Prediction</td>\n<td>Not supported</td>\n<td>Machine learning platform</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The subscription billing system requires careful technology selection to handle the demanding requirements of financial precision, high availability, and regulatory compliance.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Web Framework</td>\n<td>Flask with SQLAlchemy</td>\n<td>FastAPI with async database drivers</td>\n</tr>\n<tr>\n<td>Database</td>\n<td>PostgreSQL with financial precision types</td>\n<td>PostgreSQL with read replicas and connection pooling</td>\n</tr>\n<tr>\n<td>Message Queue</td>\n<td>Redis with pub/sub</td>\n<td>Apache Kafka for high-throughput event streaming</td>\n</tr>\n<tr>\n<td>Caching</td>\n<td>Redis with TTL-based invalidation</td>\n<td>Redis Cluster with consistent hashing</td>\n</tr>\n<tr>\n<td>API Documentation</td>\n<td>OpenAPI/Swagger auto-generation</td>\n<td>AsyncAPI for event-driven APIs</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>pytest with factory patterns</td>\n<td>pytest with property-based testing (Hypothesis)</td>\n</tr>\n<tr>\n<td>Monitoring</td>\n<td>Prometheus with custom business metrics</td>\n<td>Datadog with financial reconciliation dashboards</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-project-structure\">Recommended Project Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>subscription-billing/\n├── src/\n│   ├── billing/\n│   │   ├── __init__.py\n│   │   ├── domain/                    ← Core business entities\n│   │   │   ├── entities/\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── money.py          ← Money value object\n│   │   │   │   ├── customer.py\n│   │   │   │   ├── plan.py\n│   │   │   │   └── subscription.py\n│   │   │   ├── services/             ← Business logic services\n│   │   │   │   ├── plan_manager.py\n│   │   │   │   ├── subscription_engine.py\n│   │   │   │   ├── proration_calculator.py\n│   │   │   │   └── usage_tracker.py\n│   │   │   └── repositories/         ← Data access abstractions\n│   │   ├── infrastructure/           ← External integrations\n│   │   │   ├── database/\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── models.py         ← SQLAlchemy models\n│   │   │   │   └── migrations/\n│   │   │   ├── payment_gateway/\n│   │   │   └── notifications/\n│   │   ├── api/                      ← HTTP API layer\n│   │   │   ├── __init__.py\n│   │   │   ├── routes/\n│   │   │   └── schemas/\n│   │   └── tasks/                    ← Background job processing\n│   │       ├── billing_cycle.py\n│   │       └── usage_aggregation.py\n├── tests/\n│   ├── unit/\n│   ├── integration/\n│   └── fixtures/\n├── migrations/                       ← Database schema evolution\n├── config/\n│   ├── development.py\n│   ├── production.py\n│   └── test.py\n├── requirements/\n│   ├── base.txt\n│   ├── development.txt\n│   └── production.txt\n└── docker/\n    ├── Dockerfile\n    └── docker-compose.yml</code></pre></div>\n\n<h4 id=\"core-infrastructure-components\">Core Infrastructure Components</h4>\n<p><strong>Money Value Object Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/billing/domain/entities/money.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal, </span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> attr</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Financial precision constant - always round to nearest cent</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DECIMAL_PRECISION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#9ECBFF\">'0.01'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_CURRENCY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'USD'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Supported currencies with metadata</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">SUPPORTED_CURRENCIES</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'USD'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'$'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'US Dollar'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'EUR'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'€'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Euro'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'GBP'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'£'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'British Pound'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'CAD'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'C$'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Canadian Dollar'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'JPY'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'¥'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Japanese Yen'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@attr.s</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">auto_attribs</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Immutable value object for financial amounts.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Stores amounts as integer cents to avoid floating-point precision issues.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    All arithmetic operations return new Money instances.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    amount_cents: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currency_code: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> DEFAULT_CURRENCY</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> __attrs_post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unsupported currency: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.currency_code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Amount must be stored as integer cents\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_decimal</span><span style=\"color:#E1E4E8\">(cls, amount: Decimal, currency: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> DEFAULT_CURRENCY</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create Money from decimal amount, converting to cents.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Round to appropriate precision for currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Convert to integer cents (multiply by 100 for most currencies)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle zero-decimal currencies like JPY</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate amount is not negative for billing purposes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_decimal</span><span style=\"color:#E1E4E8\">(self) -> Decimal:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert to decimal representation for display and calculations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Divide cents by appropriate factor based on currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return Decimal with proper precision</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle zero-decimal currencies</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add</span><span style=\"color:#E1E4E8\">(self, other: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add two Money amounts, must be same currency.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate currencies match</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add amounts in cents</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return new Money instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> subtract</span><span style=\"color:#E1E4E8\">(self, other: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Subtract other from this amount.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate currencies match</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Subtract in cents</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Allow negative results for credits/refunds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> multiply</span><span style=\"color:#E1E4E8\">(self, factor: Decimal) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Multiply amount by decimal factor, used for proration.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Multiply cents by factor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Round to nearest cent using ROUND_HALF_UP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return new Money instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Database Transaction Management:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/billing/infrastructure/database/__init__.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> contextlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> create_engine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy.orm </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sessionmaker</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Serializable isolation for financial operations</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ISOLATION_LEVEL_SERIALIZABLE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'SERIALIZABLE'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DatabaseManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages database connections and transactions for billing operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, connection_string: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.connection_string </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> connection_string</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.engine </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.SessionFactory </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize SQLAlchemy engine with connection pooling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Configure session factory with appropriate defaults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Set up connection health checking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> transaction</span><span style=\"color:#E1E4E8\">(self, isolation_level: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Provide transactional context for billing operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            isolation_level: Database isolation level, defaults to READ_COMMITTED</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                           Use ISOLATION_LEVEL_SERIALIZABLE for financial operations</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        session </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.SessionFactory()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> isolation_level:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            session.connection(</span><span style=\"color:#FFAB70\">execution_options</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"isolation_level\"</span><span style=\"color:#E1E4E8\">: isolation_level})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Begin transaction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Yield session to calling code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Commit transaction on success</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Log successful transaction for audit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Rollback transaction on any error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Log rollback details for debugging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Re-raise exception for handling by calling code</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        finally</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Always close session to return to pool</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span></code></pre></div>\n\n<p><strong>Audit Logging Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/billing/domain/services/audit_logger.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuditEventType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Categories for billing system audit events.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUBSCRIPTION_CREATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription_created\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUBSCRIPTION_CANCELLED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription_cancelled\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PLAN_CHANGED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"plan_changed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAYMENT_PROCESSED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"payment_processed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PRORATION_CALCULATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"proration_calculated\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    USAGE_RECORDED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"usage_recorded\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVOICE_GENERATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"invoice_generated\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuditLogger</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Records immutable audit trail for all billing operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, database_manager: DatabaseManager):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> database_manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> log_event</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        event_type: AuditEventType,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entity_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entity_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        changes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        actor_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        metadata: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record audit event for billing operation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            event_type: Type of operation being audited</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            entity_id: ID of the entity being modified</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            entity_type: Type of entity (subscription, invoice, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            changes: Before/after values for the operation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            actor_id: ID of user or system performing the operation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            metadata: Additional context for the operation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create audit record with timestamp and unique ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Serialize changes and metadata to JSON</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Insert into audit_events table using serializable transaction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle any insertion errors without affecting main operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Log audit record creation for debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"configuration-management\">Configuration Management</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/billing/config.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BillingSettings</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Configuration settings for the billing system.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Financial precision settings</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DECIMAL_PRECISION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#9ECBFF\">'0.01'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEFAULT_CURRENCY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'USD'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Billing cycle settings</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BILLING_GRACE_PERIOD_DAYS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 7</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DUNNING_RETRY_ATTEMPTS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PRORATION_ROUNDING_METHOD</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'ROUND_HALF_UP'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Performance settings</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    USAGE_BATCH_SIZE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BILLING_PROCESSING_CHUNK_SIZE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 500</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Integration settings</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAYMENT_GATEWAY_TIMEOUT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WEBHOOK_RETRY_ATTEMPTS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_environment</span><span style=\"color:#E1E4E8\">(cls) -> </span><span style=\"color:#9ECBFF\">'BillingSettings'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Load settings from environment variables.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        settings </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Override defaults with environment variables</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate required settings are present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Type conversion and validation for numeric settings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return configured settings instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> settings</span></span></code></pre></div>\n\n<h4 id=\"milestone-validation-checkpoints\">Milestone Validation Checkpoints</h4>\n<p><strong>Checkpoint 1 - Core Infrastructure:</strong>\nRun <code>python -m pytest tests/unit/test_money.py -v</code> to verify the <code>Money</code> value object handles all currency operations correctly. Expected output should show all precision tests passing, including edge cases like currency conversion and proration calculations.</p>\n<p><strong>Checkpoint 2 - Database Setup:</strong>\nExecute <code>python -m billing.infrastructure.database.setup_test_data</code> to create sample plans and subscriptions. Verify you can query the database and see properly formatted monetary values stored as integers.</p>\n<p><strong>Checkpoint 3 - Requirements Validation:</strong>\nCreate a simple test subscription through the API and verify all functional requirements are testable:</p>\n<ul>\n<li>Plan selection creates subscription with correct billing cycle</li>\n<li>Trial period is properly configured and tracked</li>\n<li>Payment method is tokenized and stored securely</li>\n<li>Audit events are created for all operations</li>\n</ul>\n<h4 id=\"common-configuration-pitfalls\">Common Configuration Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Floating-Point Currency Storage</strong>\nNever store monetary amounts as floating-point numbers in the database. Use integer cents or decimal types with fixed precision. Floating-point arithmetic can introduce rounding errors that compound over thousands of transactions.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Audit Logging</strong>\nBilling systems require comprehensive audit trails for compliance and dispute resolution. Log every state change, calculation, and external API call with sufficient detail to reconstruct the operation later.</p>\n<p>⚠️ <strong>Pitfall: Inadequate Error Handling</strong>\nBilling operations must be atomic - either fully completed or fully rolled back. Partial states where money has been charged but subscription hasn&#39;t been activated can result in customer disputes and revenue recognition issues.</p>\n<p>⚠️ <strong>Pitfall: Time Zone Confusion</strong>\nAlways store timestamps in UTC and convert to customer&#39;s local timezone for display only. Billing cycles based on local times can create confusion when customers travel or daylight saving time changes occur.</p>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all milestones - provides the overall system structure that supports plan management, subscription lifecycle, proration, and usage-based billing</p>\n</blockquote>\n<h3 id=\"component-overview\">Component Overview</h3>\n<h4 id=\"mental-model-the-financial-operations-center\">Mental Model: The Financial Operations Center</h4>\n<p>Think of the subscription billing system like a modern financial operations center at a major bank. Just as a bank has specialized departments—customer accounts, loan processing, transaction monitoring, payment clearing, and audit—our billing system divides complex financial operations into focused, specialized components that work together seamlessly.</p>\n<p>The <strong>Plan Management</strong> component acts like the bank&#39;s product catalog department, defining what financial products (subscription plans) are available, their terms, and who can access them. The <strong>Subscription Engine</strong> functions like the account management department, tracking each customer&#39;s relationship with the bank, their account status, and lifecycle events. The <strong>Usage Tracker</strong> operates like the transaction monitoring system, recording every billable event in real-time. The <strong>Invoice Generator</strong> works like the billing department, calculating what each customer owes and producing formal billing statements. Finally, the <strong>Payment Processor</strong> acts like the payment clearing house, handling the actual movement of money.</p>\n<p>Each department has clear responsibilities and communicates through well-defined channels, but they&#39;re all orchestrated to create a seamless customer experience. When a customer upgrades their plan, multiple departments coordinate: product catalog validates the new plan, account management updates the relationship, billing calculates proration, and payment processing handles any immediate charges.</p>\n<p>The subscription billing system follows this same pattern of specialized components with clear boundaries but coordinated workflows.</p>\n<h4 id=\"core-system-components\">Core System Components</h4>\n<p><img src=\"/api/project/subscription-billing/architecture-doc/asset?path=diagrams%2Fsystem-architecture.svg\" alt=\"System Component Architecture\"></p>\n<p>The subscription billing system consists of six major components, each with distinct responsibilities and clear interfaces:</p>\n<p><strong>Plan Management Component</strong></p>\n<p>The Plan Management component serves as the product catalog and pricing engine for the entire system. It maintains the canonical definition of all subscription plans, their pricing tiers, feature entitlements, and billing parameters. This component handles plan versioning to ensure existing customers retain their original terms while new customers receive updated plans. It validates plan configurations for consistency and provides the pricing logic used throughout the system.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Data Owned</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Plan Definition</td>\n<td>Maintains subscription plans with pricing, features, and terms</td>\n<td>Plan configurations, pricing tiers, feature matrices</td>\n</tr>\n<tr>\n<td>Pricing Logic</td>\n<td>Calculates base charges for different plan types and billing intervals</td>\n<td>Pricing formulas, currency conversions, discount rules</td>\n</tr>\n<tr>\n<td>Feature Entitlements</td>\n<td>Maps plan tiers to accessible features and usage limits</td>\n<td>Feature flags, quota definitions, access control lists</td>\n</tr>\n<tr>\n<td>Plan Versioning</td>\n<td>Manages plan changes while protecting existing customer terms</td>\n<td>Plan versions, deprecation schedules, grandfathering rules</td>\n</tr>\n</tbody></table>\n<p><strong>Subscription Engine</strong></p>\n<p>The Subscription Engine manages the complete customer subscription lifecycle from creation through cancellation. It maintains the subscription state machine, processes lifecycle events like renewals and cancellations, and coordinates with other components during plan changes. This component serves as the system of record for all subscription relationships and their current status.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Data Owned</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lifecycle Management</td>\n<td>Handles subscription creation, renewal, cancellation, and reactivation</td>\n<td>Subscription records, state transitions, lifecycle events</td>\n</tr>\n<tr>\n<td>State Machine</td>\n<td>Enforces valid subscription state transitions and business rules</td>\n<td>Current states, transition logs, business rule validations</td>\n</tr>\n<tr>\n<td>Billing Orchestration</td>\n<td>Coordinates billing cycles and triggers invoice generation</td>\n<td>Billing schedules, anniversary dates, renewal triggers</td>\n</tr>\n<tr>\n<td>Plan Changes</td>\n<td>Processes upgrades and downgrades with effective date management</td>\n<td>Change requests, effective dates, approval workflows</td>\n</tr>\n</tbody></table>\n<p><strong>Usage Tracker</strong></p>\n<p>The Usage Tracker implements event-based metering for usage-based billing scenarios. It ingests usage events with idempotent processing, aggregates consumption data over billing periods, and calculates usage-based charges according to plan terms. This component ensures accurate usage measurement and prevents double-billing through robust deduplication.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Data Owned</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Event Ingestion</td>\n<td>Accepts and validates usage events with idempotency protection</td>\n<td>Usage events, deduplication keys, ingestion timestamps</td>\n</tr>\n<tr>\n<td>Usage Aggregation</td>\n<td>Sums, counts, or calculates max usage over billing periods</td>\n<td>Aggregated usage totals, billing period boundaries, calculation results</td>\n</tr>\n<tr>\n<td>Overage Calculation</td>\n<td>Determines charges when usage exceeds plan allowances</td>\n<td>Usage limits, overage rates, tiered pricing calculations</td>\n</tr>\n<tr>\n<td>Real-time Quotas</td>\n<td>Tracks current usage against plan limits for quota enforcement</td>\n<td>Current usage counters, quota thresholds, limit enforcement</td>\n</tr>\n</tbody></table>\n<p><strong>Proration Calculator</strong></p>\n<p>The Proration Calculator handles all partial charge and credit calculations when subscriptions change mid-cycle. It implements precise financial calculations for time-based and quantity-based proration, manages customer credit balances, and ensures accurate billing during plan transitions. This component is critical for maintaining customer trust through transparent and accurate billing adjustments.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Data Owned</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Proration Logic</td>\n<td>Calculates partial charges and credits for mid-cycle changes</td>\n<td>Proration formulas, time calculations, rounding rules</td>\n</tr>\n<tr>\n<td>Credit Management</td>\n<td>Tracks and applies customer credit balances</td>\n<td>Credit balances, credit applications, expiration policies</td>\n</tr>\n<tr>\n<td>Change Processing</td>\n<td>Handles immediate and scheduled plan changes with correct timing</td>\n<td>Change schedules, effective dates, processing queues</td>\n</tr>\n<tr>\n<td>Financial Precision</td>\n<td>Ensures accurate monetary calculations with proper rounding</td>\n<td>Precision settings, rounding algorithms, audit trails</td>\n</tr>\n</tbody></table>\n<p><strong>Invoice Generator</strong></p>\n<p>The Invoice Generator creates formal billing statements by combining subscription charges, usage fees, proration adjustments, and credit applications. It produces invoices in multiple formats, handles tax calculations, and maintains a complete audit trail of all billing activity. This component ensures compliance with accounting standards and provides customers with clear, detailed billing statements.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Data Owned</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Invoice Creation</td>\n<td>Generates invoices from subscription charges, usage, and adjustments</td>\n<td>Invoice templates, line items, tax calculations</td>\n</tr>\n<tr>\n<td>Line Item Assembly</td>\n<td>Combines base charges, usage fees, proration, and credits into invoice lines</td>\n<td>Charge breakdowns, itemized billing, descriptive labels</td>\n</tr>\n<tr>\n<td>Tax Calculation</td>\n<td>Applies appropriate tax rates based on customer location and plan type</td>\n<td>Tax rates, jurisdiction rules, exemption handling</td>\n</tr>\n<tr>\n<td>Audit Trail</td>\n<td>Maintains complete financial audit trail for compliance</td>\n<td>Invoice history, change logs, financial reconciliation data</td>\n</tr>\n</tbody></table>\n<p><strong>Payment Processor</strong></p>\n<p>The Payment Processor integrates with the prerequisite payment gateway system to handle actual money movement. It processes recurring charges, manages payment methods, handles payment failures with retry logic, and processes webhooks from payment providers. This component abstracts payment complexity and provides consistent payment handling across the billing system.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Data Owned</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Payment Execution</td>\n<td>Processes charges through payment gateways with retry logic</td>\n<td>Payment attempts, transaction records, retry schedules</td>\n</tr>\n<tr>\n<td>Method Management</td>\n<td>Handles customer payment methods and updates</td>\n<td>Payment methods, expiration tracking, update notifications</td>\n</tr>\n<tr>\n<td>Webhook Processing</td>\n<td>Processes payment gateway webhooks with idempotency</td>\n<td>Webhook events, processing status, duplicate prevention</td>\n</tr>\n<tr>\n<td>Failure Handling</td>\n<td>Manages payment failures with dunning and grace periods</td>\n<td>Failure reasons, retry attempts, dunning workflows</td>\n</tr>\n</tbody></table>\n<h4 id=\"component-interaction-patterns\">Component Interaction Patterns</h4>\n<p>The components interact through well-defined interfaces using event-driven and synchronous communication patterns. Each component publishes domain events when significant state changes occur, allowing other components to react appropriately without tight coupling.</p>\n<p><strong>Event-Driven Communication</strong></p>\n<p>Components publish events for major state changes that other components need to know about. This ensures loose coupling while maintaining system consistency. Events are processed asynchronously with at-least-once delivery guarantees.</p>\n<table>\n<thead>\n<tr>\n<th>Event Type</th>\n<th>Publisher</th>\n<th>Subscribers</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SubscriptionCreated</code></td>\n<td>Subscription Engine</td>\n<td>Usage Tracker, Invoice Generator</td>\n<td>Initialize tracking and billing for new subscription</td>\n</tr>\n<tr>\n<td><code>SubscriptionCancelled</code></td>\n<td>Subscription Engine</td>\n<td>Usage Tracker, Payment Processor</td>\n<td>Stop usage tracking and cancel recurring payments</td>\n</tr>\n<tr>\n<td><code>PlanChanged</code></td>\n<td>Subscription Engine</td>\n<td>Proration Calculator, Usage Tracker</td>\n<td>Trigger proration and update usage limits</td>\n</tr>\n<tr>\n<td><code>UsageReported</code></td>\n<td>Usage Tracker</td>\n<td>Invoice Generator</td>\n<td>Include usage charges in next billing cycle</td>\n</tr>\n<tr>\n<td><code>PaymentFailed</code></td>\n<td>Payment Processor</td>\n<td>Subscription Engine</td>\n<td>Trigger dunning process and state changes</td>\n</tr>\n<tr>\n<td><code>InvoiceGenerated</code></td>\n<td>Invoice Generator</td>\n<td>Payment Processor</td>\n<td>Trigger payment processing for new invoices</td>\n</tr>\n</tbody></table>\n<p><strong>Synchronous API Communication</strong></p>\n<p>For operations requiring immediate consistency or validation, components communicate through synchronous APIs. These interactions are typically read-only queries or validation requests that need immediate responses.</p>\n<table>\n<thead>\n<tr>\n<th>API Call</th>\n<th>Caller</th>\n<th>Provider</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ValidatePlanChange</code></td>\n<td>Subscription Engine</td>\n<td>Plan Management</td>\n<td>Validate plan upgrade/downgrade before processing</td>\n</tr>\n<tr>\n<td><code>CalculateProration</code></td>\n<td>Subscription Engine</td>\n<td>Proration Calculator</td>\n<td>Get proration amounts for plan changes</td>\n</tr>\n<tr>\n<td><code>GetUsageTotal</code></td>\n<td>Invoice Generator</td>\n<td>Usage Tracker</td>\n<td>Retrieve usage charges for invoice generation</td>\n</tr>\n<tr>\n<td><code>GetCreditBalance</code></td>\n<td>Invoice Generator</td>\n<td>Proration Calculator</td>\n<td>Include customer credits in invoice</td>\n</tr>\n<tr>\n<td><code>ProcessPayment</code></td>\n<td>Invoice Generator</td>\n<td>Payment Processor</td>\n<td>Execute payment for new invoice</td>\n</tr>\n</tbody></table>\n<h3 id=\"integration-patterns\">Integration Patterns</h3>\n<h4 id=\"mental-model-the-banking-network\">Mental Model: The Banking Network</h4>\n<p>Think of how banks integrate with each other and external financial systems. Your local bank doesn&#39;t operate in isolation—it connects to credit card networks, clearing houses, federal reserve systems, and other banks through standardized protocols and interfaces. Each connection has specific purposes, security requirements, and failure handling procedures.</p>\n<p>Similarly, our subscription billing system must integrate with external payment providers, tax calculation services, customer management systems, and business intelligence tools. Each integration requires careful design of interfaces, error handling, and data consistency guarantees.</p>\n<p>Just as banks use different communication methods for different purposes—real-time wire transfers use secure direct connections while batch processing uses file transfers—our billing system uses different integration patterns based on the requirements of each external system.</p>\n<h4 id=\"payment-gateway-integration\">Payment Gateway Integration</h4>\n<p>The subscription billing system integrates with the prerequisite payment gateway system through both API calls and webhook processing. This integration handles the actual movement of money while the billing system focuses on subscription logic and financial calculations.</p>\n<blockquote>\n<p><strong>Decision: Payment Gateway Integration Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: The billing system needs to process payments but should not handle sensitive payment data directly due to PCI compliance requirements</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Direct payment processing with PCI compliance</li>\n<li>Integration with existing payment gateway</li>\n<li>Third-party billing service integration</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Integrate with the prerequisite payment gateway system</li>\n<li><strong>Rationale</strong>: Leverages existing payment infrastructure, maintains PCI compliance, and focuses billing system on subscription-specific logic rather than payment processing</li>\n<li><strong>Consequences</strong>: Enables faster development and better security but creates dependency on payment gateway availability and capabilities</li>\n</ul>\n</blockquote>\n<p><strong>API Integration Pattern</strong></p>\n<p>The Payment Processor component communicates with the payment gateway through RESTful APIs for payment method management, charge processing, and customer management. All API calls include idempotency keys to prevent duplicate processing during retries.</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Method</th>\n<th>Purpose</th>\n<th>Idempotency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Create Customer</td>\n<td>POST /customers</td>\n<td>Create gateway customer record</td>\n<td>Customer ID as idempotency key</td>\n</tr>\n<tr>\n<td>Add Payment Method</td>\n<td>POST /customers/{id}/payment-methods</td>\n<td>Attach payment method to customer</td>\n<td>Method fingerprint as key</td>\n</tr>\n<tr>\n<td>Process Charge</td>\n<td>POST /charges</td>\n<td>Execute one-time or recurring payment</td>\n<td>Internal transaction ID as key</td>\n</tr>\n<tr>\n<td>Refund Payment</td>\n<td>POST /refunds</td>\n<td>Process refunds for plan downgrades</td>\n<td>Refund request ID as key</td>\n</tr>\n</tbody></table>\n<p><strong>Webhook Integration Pattern</strong></p>\n<p>The payment gateway sends webhooks for asynchronous events like payment success, failure, and disputes. The billing system processes these webhooks with careful attention to idempotency, ordering, and failure handling.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Payment Gateway → Webhook Endpoint → Event Queue → Payment Processor → Subscription Engine</code></pre></div>\n\n<p>The webhook processing follows a reliable pattern:</p>\n<ol>\n<li><strong>Immediate Acknowledgment</strong>: Webhook endpoint immediately returns 200 OK after basic validation</li>\n<li><strong>Event Queuing</strong>: Valid webhooks are queued for asynchronous processing</li>\n<li><strong>Idempotent Processing</strong>: Each webhook event is processed exactly once using event IDs</li>\n<li><strong>State Reconciliation</strong>: Processing updates subscription states based on payment outcomes</li>\n<li><strong>Retry Logic</strong>: Failed webhook processing retries with exponential backoff</li>\n</ol>\n<h4 id=\"customer-management-integration\">Customer Management Integration</h4>\n<p>The billing system integrates with existing customer management systems to maintain consistent customer data and avoid duplicating customer information. This integration typically follows an event-driven pattern where customer changes trigger updates in the billing system.</p>\n<p><strong>Customer Data Synchronization</strong></p>\n<table>\n<thead>\n<tr>\n<th>Integration Type</th>\n<th>Direction</th>\n<th>Data Synchronized</th>\n<th>Trigger</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Customer Creation</td>\n<td>CRM → Billing</td>\n<td>Customer ID, contact info, billing address</td>\n<td>New customer signup</td>\n</tr>\n<tr>\n<td>Profile Updates</td>\n<td>CRM → Billing</td>\n<td>Address changes, contact updates</td>\n<td>Customer profile modification</td>\n</tr>\n<tr>\n<td>Subscription Events</td>\n<td>Billing → CRM</td>\n<td>Subscription status, plan changes</td>\n<td>Billing lifecycle events</td>\n</tr>\n<tr>\n<td>Usage Analytics</td>\n<td>Billing → CRM</td>\n<td>Usage patterns, billing history</td>\n<td>Reporting and analytics needs</td>\n</tr>\n</tbody></table>\n<h4 id=\"tax-calculation-integration\">Tax Calculation Integration</h4>\n<p>For businesses operating in multiple jurisdictions, the billing system integrates with tax calculation services to ensure compliance with local tax regulations. This integration is particularly important for usage-based billing where tax calculations may be complex.</p>\n<p><strong>Tax Service Integration Pattern</strong></p>\n<p>The Invoice Generator component calls tax calculation services during invoice generation to determine appropriate tax amounts based on customer location, product type, and billing amounts.</p>\n<table>\n<thead>\n<tr>\n<th>Tax Scenario</th>\n<th>Integration Point</th>\n<th>Data Sent</th>\n<th>Data Received</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Subscription Charges</td>\n<td>Invoice generation</td>\n<td>Customer address, plan type, charge amount</td>\n<td>Tax rate, tax amount, tax jurisdiction</td>\n</tr>\n<tr>\n<td>Usage Charges</td>\n<td>Usage billing</td>\n<td>Usage type, consumption amount, customer location</td>\n<td>Applicable tax rates and amounts</td>\n</tr>\n<tr>\n<td>Proration Adjustments</td>\n<td>Plan changes</td>\n<td>Original charge, prorated amount, effective dates</td>\n<td>Adjusted tax calculations</td>\n</tr>\n<tr>\n<td>Refunds</td>\n<td>Cancellations</td>\n<td>Original tax amount, refund reason, jurisdiction</td>\n<td>Tax refund amount and handling</td>\n</tr>\n</tbody></table>\n<h4 id=\"business-intelligence-integration\">Business Intelligence Integration</h4>\n<p>The billing system provides data to business intelligence and analytics platforms through both real-time events and batch data exports. This enables revenue reporting, customer analytics, and business performance monitoring.</p>\n<p><strong>Analytics Data Flow</strong></p>\n<table>\n<thead>\n<tr>\n<th>Data Type</th>\n<th>Export Method</th>\n<th>Frequency</th>\n<th>Contents</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Revenue Events</td>\n<td>Real-time streaming</td>\n<td>Immediate</td>\n<td>Invoice generation, payment success, refunds</td>\n</tr>\n<tr>\n<td>Usage Metrics</td>\n<td>Batch export</td>\n<td>Daily</td>\n<td>Aggregated usage by customer, plan, and feature</td>\n</tr>\n<tr>\n<td>Subscription Analytics</td>\n<td>Batch export</td>\n<td>Daily</td>\n<td>Churn analysis, upgrade/downgrade patterns, lifecycle metrics</td>\n</tr>\n<tr>\n<td>Financial Reconciliation</td>\n<td>Batch export</td>\n<td>Monthly</td>\n<td>Complete financial audit trail for accounting</td>\n</tr>\n</tbody></table>\n<h4 id=\"external-service-error-handling\">External Service Error Handling</h4>\n<p>All external integrations implement robust error handling and fallback strategies to ensure billing operations continue even when external services are unavailable.</p>\n<blockquote>\n<p><strong>Critical Design Principle</strong>: External service failures should degrade functionality gracefully rather than preventing core billing operations</p>\n</blockquote>\n<p><strong>Error Handling Strategy</strong></p>\n<table>\n<thead>\n<tr>\n<th>Service</th>\n<th>Error Type</th>\n<th>Immediate Action</th>\n<th>Fallback Strategy</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Payment Gateway</td>\n<td>Network timeout</td>\n<td>Retry with exponential backoff</td>\n<td>Queue payment for later processing</td>\n<td>Process when service recovers</td>\n</tr>\n<tr>\n<td>Tax Service</td>\n<td>Service unavailable</td>\n<td>Use cached tax rates</td>\n<td>Apply default tax rate with adjustment flag</td>\n<td>Recalculate when service returns</td>\n</tr>\n<tr>\n<td>Customer Service</td>\n<td>Data sync failure</td>\n<td>Log inconsistency</td>\n<td>Continue with local customer data</td>\n<td>Sync when connectivity restored</td>\n</tr>\n<tr>\n<td>Analytics</td>\n<td>Export failure</td>\n<td>Queue events locally</td>\n<td>Continue billing operations</td>\n<td>Replay events when service available</td>\n</tr>\n</tbody></table>\n<h3 id=\"recommended-codebase-structure\">Recommended Codebase Structure</h3>\n<h4 id=\"mental-model-the-corporate-organizational-chart\">Mental Model: The Corporate Organizational Chart</h4>\n<p>Think of a well-organized corporation with clear departments, reporting structures, and communication channels. The accounting department doesn&#39;t directly manage customer service, but they work together through defined processes. Similarly, our codebase structure reflects the business domain organization while maintaining clean separation of concerns.</p>\n<p>Just as a company has shared services (IT, legal, facilities) that support all departments, our codebase has common infrastructure (database, logging, configuration) that supports all business components. The directory structure should make it immediately clear which code handles which business responsibility, just like an organizational chart shows who handles which business function.</p>\n<h4 id=\"directory-structure-organization\">Directory Structure Organization</h4>\n<p>The codebase follows a domain-driven design approach with clear separation between business logic, infrastructure concerns, and external interfaces. This structure supports both the current requirements and future scalability needs.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>subscription-billing-system/\n├── cmd/                           # Application entry points\n│   ├── billing-server/           # Main billing API server\n│   │   └── main.py\n│   ├── usage-ingestion/          # Usage event ingestion service\n│   │   └── main.py\n│   └── billing-scheduler/        # Batch billing operations\n│       └── main.py\n├── internal/                     # Internal business logic (not importable)\n│   ├── domain/                   # Core business entities and rules\n│   │   ├── customer/\n│   │   │   ├── __init__.py\n│   │   │   ├── models.py        # Customer entity and value objects\n│   │   │   └── repository.py    # Customer data access interface\n│   │   ├── plan/\n│   │   │   ├── __init__.py\n│   │   │   ├── models.py        # Plan entities and pricing logic\n│   │   │   ├── repository.py    # Plan data access interface\n│   │   │   └── service.py       # Plan management business logic\n│   │   ├── subscription/\n│   │   │   ├── __init__.py\n│   │   │   ├── models.py        # Subscription state machine and lifecycle\n│   │   │   ├── repository.py    # Subscription persistence interface\n│   │   │   └── service.py       # Subscription lifecycle management\n│   │   ├── usage/\n│   │   │   ├── __init__.py\n│   │   │   ├── models.py        # Usage events and aggregation\n│   │   │   ├── repository.py    # Usage data storage interface\n│   │   │   └── service.py       # Usage tracking and aggregation logic\n│   │   ├── billing/\n│   │   │   ├── __init__.py\n│   │   │   ├── models.py        # Invoice and payment entities\n│   │   │   ├── proration.py     # Proration calculation logic\n│   │   │   ├── invoice.py       # Invoice generation service\n│   │   │   └── payment.py       # Payment processing coordination\n│   │   └── shared/\n│   │       ├── __init__.py\n│   │       ├── money.py         # Money value object and currency handling\n│   │       ├── events.py        # Domain event definitions\n│   │       └── errors.py        # Business exception definitions\n│   ├── infrastructure/           # External system integrations and technical concerns\n│   │   ├── database/\n│   │   │   ├── __init__.py\n│   │   │   ├── connection.py    # DatabaseManager and transaction handling\n│   │   │   ├── migrations/      # Database schema migrations\n│   │   │   └── repositories/    # Concrete repository implementations\n│   │   │       ├── customer_repository.py\n│   │   │       ├── plan_repository.py\n│   │   │       ├── subscription_repository.py\n│   │   │       ├── usage_repository.py\n│   │   │       └── billing_repository.py\n│   │   ├── payment_gateway/\n│   │   │   ├── __init__.py\n│   │   │   ├── client.py        # Payment gateway API client\n│   │   │   ├── webhook_handler.py # Webhook processing\n│   │   │   └── models.py        # Payment gateway data models\n│   │   ├── messaging/\n│   │   │   ├── __init__.py\n│   │   │   ├── event_bus.py     # Domain event publishing and subscription\n│   │   │   └── queue_manager.py # Message queue integration\n│   │   ├── external_services/\n│   │   │   ├── __init__.py\n│   │   │   ├── tax_service.py   # Tax calculation service integration\n│   │   │   └── analytics_service.py # Business intelligence integration\n│   │   └── monitoring/\n│   │       ├── __init__.py\n│   │       ├── audit_logger.py  # Audit trail implementation\n│   │       └── metrics.py       # Performance and business metrics\n│   └── api/                     # HTTP API layer\n│       ├── __init__.py\n│       ├── handlers/            # HTTP request handlers\n│       │   ├── plan_handlers.py\n│       │   ├── subscription_handlers.py\n│       │   ├── usage_handlers.py\n│       │   ├── billing_handlers.py\n│       │   └── webhook_handlers.py\n│       ├── middleware/          # HTTP middleware\n│       │   ├── authentication.py\n│       │   ├── rate_limiting.py\n│       │   └── error_handling.py\n│       └── serializers/         # Request/response serialization\n│           ├── plan_serializers.py\n│           ├── subscription_serializers.py\n│           └── billing_serializers.py\n├── config/                      # Configuration management\n│   ├── __init__.py\n│   ├── settings.py             # BillingSettings and configuration loading\n│   ├── database.py             # Database configuration\n│   └── environments/           # Environment-specific configurations\n│       ├── development.py\n│       ├── staging.py\n│       └── production.py\n├── tests/                      # Test suites\n│   ├── unit/                   # Unit tests for business logic\n│   │   ├── domain/\n│   │   └── infrastructure/\n│   ├── integration/            # Integration tests\n│   │   ├── database/\n│   │   ├── payment_gateway/\n│   │   └── api/\n│   ├── end_to_end/            # Full workflow tests\n│   │   ├── subscription_lifecycle/\n│   │   ├── billing_cycles/\n│   │   └── plan_changes/\n│   └── fixtures/              # Test data and mocks\n│       ├── customers.py\n│       ├── plans.py\n│       └── usage_events.py\n├── scripts/                   # Operational and development scripts\n│   ├── migrate_database.py   # Database migration runner\n│   ├── seed_test_data.py     # Development data seeding\n│   └── billing_reconciliation.py # Financial reconciliation utilities\n├── docs/                     # Documentation\n│   ├── api/                  # API documentation\n│   ├── deployment/          # Deployment guides\n│   └── troubleshooting/     # Operational guides\n├── requirements.txt         # Python dependencies\n├── setup.py                # Package configuration\n└── README.md               # Project overview and setup</code></pre></div>\n\n<h4 id=\"architecture-layer-responsibilities\">Architecture Layer Responsibilities</h4>\n<p>The codebase structure enforces clear architectural boundaries and dependencies through its organization:</p>\n<p><strong>Domain Layer (<code>internal/domain/</code>)</strong></p>\n<p>The domain layer contains pure business logic with no external dependencies. This layer defines the core business entities, their behavior, and the rules that govern the subscription billing domain. It should be possible to test this layer without any external systems.</p>\n<table>\n<thead>\n<tr>\n<th>Directory</th>\n<th>Responsibility</th>\n<th>Dependencies</th>\n<th>Key Artifacts</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>customer/</code></td>\n<td>Customer entity and customer-related business rules</td>\n<td>None (pure business logic)</td>\n<td>Customer model, validation rules</td>\n</tr>\n<tr>\n<td><code>plan/</code></td>\n<td>Plan definitions, pricing logic, feature entitlements</td>\n<td>Domain shared types only</td>\n<td>Plan hierarchy, pricing calculators</td>\n</tr>\n<tr>\n<td><code>subscription/</code></td>\n<td>Subscription lifecycle, state machine, business rules</td>\n<td>Customer and Plan domains</td>\n<td>State machine, lifecycle events</td>\n</tr>\n<tr>\n<td><code>usage/</code></td>\n<td>Usage tracking, aggregation, quota enforcement</td>\n<td>Subscription domain</td>\n<td>Usage events, aggregation rules</td>\n</tr>\n<tr>\n<td><code>billing/</code></td>\n<td>Invoice generation, proration, payment coordination</td>\n<td>All other domains</td>\n<td>Proration algorithms, invoice logic</td>\n</tr>\n<tr>\n<td><code>shared/</code></td>\n<td>Cross-domain value objects and domain events</td>\n<td>None</td>\n<td><code>Money</code> type, domain events, exceptions</td>\n</tr>\n</tbody></table>\n<p><strong>Infrastructure Layer (<code>internal/infrastructure/</code>)</strong></p>\n<p>The infrastructure layer handles all external system concerns including databases, payment gateways, message queues, and monitoring systems. This layer implements the interfaces defined in the domain layer and provides concrete implementations for external integrations.</p>\n<table>\n<thead>\n<tr>\n<th>Directory</th>\n<th>Responsibility</th>\n<th>Dependencies</th>\n<th>Key Artifacts</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>database/</code></td>\n<td>Data persistence, transaction management, migrations</td>\n<td>Domain repository interfaces</td>\n<td><code>DatabaseManager</code>, concrete repositories</td>\n</tr>\n<tr>\n<td><code>payment_gateway/</code></td>\n<td>Payment processing, webhook handling</td>\n<td>Domain payment interfaces</td>\n<td>Gateway client, webhook processor</td>\n</tr>\n<tr>\n<td><code>messaging/</code></td>\n<td>Event publishing, message queuing</td>\n<td>Domain events</td>\n<td>Event bus, queue managers</td>\n</tr>\n<tr>\n<td><code>external_services/</code></td>\n<td>Tax calculation, analytics, customer sync</td>\n<td>Domain service interfaces</td>\n<td>Service clients, data adapters</td>\n</tr>\n<tr>\n<td><code>monitoring/</code></td>\n<td>Audit logging, metrics, observability</td>\n<td>Domain events and entities</td>\n<td>Audit logger, metrics collectors</td>\n</tr>\n</tbody></table>\n<p><strong>API Layer (<code>internal/api/</code>)</strong></p>\n<p>The API layer provides HTTP interfaces for external clients and handles request/response serialization, authentication, and error handling. This layer coordinates between HTTP requests and domain services but contains no business logic itself.</p>\n<table>\n<thead>\n<tr>\n<th>Directory</th>\n<th>Responsibility</th>\n<th>Dependencies</th>\n<th>Key Artifacts</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>handlers/</code></td>\n<td>HTTP request processing, response formatting</td>\n<td>Domain services</td>\n<td>Request handlers, response builders</td>\n</tr>\n<tr>\n<td><code>middleware/</code></td>\n<td>Cross-cutting HTTP concerns</td>\n<td>Infrastructure services</td>\n<td>Auth middleware, rate limiters</td>\n</tr>\n<tr>\n<td><code>serializers/</code></td>\n<td>Request/response data transformation</td>\n<td>Domain models</td>\n<td>Data serializers, validators</td>\n</tr>\n</tbody></table>\n<h4 id=\"configuration-and-deployment-structure\">Configuration and Deployment Structure</h4>\n<p><strong>Configuration Management (<code>config/</code>)</strong></p>\n<p>The configuration system supports multiple environments while maintaining security best practices for sensitive configuration data like database credentials and API keys.</p>\n<table>\n<thead>\n<tr>\n<th>File</th>\n<th>Purpose</th>\n<th>Content Type</th>\n<th>Environment Sensitivity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>settings.py</code></td>\n<td><code>BillingSettings</code> class and configuration loading logic</td>\n<td>Python code</td>\n<td>Non-sensitive defaults</td>\n</tr>\n<tr>\n<td><code>database.py</code></td>\n<td>Database connection configuration</td>\n<td>Python code</td>\n<td>Environment-dependent</td>\n</tr>\n<tr>\n<td><code>environments/development.py</code></td>\n<td>Development environment overrides</td>\n<td>Python code</td>\n<td>Development-specific settings</td>\n</tr>\n<tr>\n<td><code>environments/staging.py</code></td>\n<td>Staging environment configuration</td>\n<td>Python code</td>\n<td>Staging-specific settings</td>\n</tr>\n<tr>\n<td><code>environments/production.py</code></td>\n<td>Production environment configuration</td>\n<td>Python code</td>\n<td>Production settings (no secrets)</td>\n</tr>\n</tbody></table>\n<p><strong>Testing Strategy Organization (<code>tests/</code>)</strong></p>\n<p>The testing structure mirrors the application architecture to ensure comprehensive coverage at all levels while maintaining test isolation and fast feedback loops.</p>\n<table>\n<thead>\n<tr>\n<th>Test Type</th>\n<th>Directory</th>\n<th>Purpose</th>\n<th>Dependencies</th>\n<th>Execution Speed</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unit Tests</td>\n<td><code>tests/unit/domain/</code></td>\n<td>Test business logic in isolation</td>\n<td>None (mocked dependencies)</td>\n<td>Fast (&lt; 1s)</td>\n</tr>\n<tr>\n<td>Integration Tests</td>\n<td><code>tests/integration/</code></td>\n<td>Test component integration</td>\n<td>Real databases, test services</td>\n<td>Medium (1-10s)</td>\n</tr>\n<tr>\n<td>End-to-End Tests</td>\n<td><code>tests/end_to_end/</code></td>\n<td>Test complete workflows</td>\n<td>Full system deployment</td>\n<td>Slow (10s+)</td>\n</tr>\n<tr>\n<td>Test Fixtures</td>\n<td><code>tests/fixtures/</code></td>\n<td>Shared test data and mocks</td>\n<td>Test utilities only</td>\n<td>N/A</td>\n</tr>\n</tbody></table>\n<h4 id=\"development-workflow-support\">Development Workflow Support</h4>\n<p><strong>Scripts and Utilities (<code>scripts/</code>)</strong></p>\n<p>The scripts directory provides operational tools that developers and operators need for managing the billing system throughout its lifecycle.</p>\n<table>\n<thead>\n<tr>\n<th>Script</th>\n<th>Purpose</th>\n<th>Usage Context</th>\n<th>Dependencies</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>migrate_database.py</code></td>\n<td>Apply database schema migrations</td>\n<td>Development, deployment</td>\n<td>Database connection, migration files</td>\n</tr>\n<tr>\n<td><code>seed_test_data.py</code></td>\n<td>Create realistic test data for development</td>\n<td>Development, testing</td>\n<td>Domain models, repositories</td>\n</tr>\n<tr>\n<td><code>billing_reconciliation.py</code></td>\n<td>Verify billing accuracy and detect discrepancies</td>\n<td>Operations, financial auditing</td>\n<td>Full system access</td>\n</tr>\n</tbody></table>\n<p>This codebase structure provides several key benefits for development teams:</p>\n<ol>\n<li><strong>Clear Separation of Concerns</strong>: Business logic is isolated from infrastructure concerns, making the code easier to test and modify</li>\n<li><strong>Dependency Direction</strong>: Dependencies flow from infrastructure toward domain, never the reverse, ensuring business logic remains independent</li>\n<li><strong>Test Strategy Alignment</strong>: Test organization mirrors code organization, making it easy to find and write appropriate tests</li>\n<li><strong>Scalability Support</strong>: Structure supports adding new components or splitting services without major reorganization</li>\n<li><strong>Operational Readiness</strong>: Configuration and deployment structure supports multiple environments and operational needs</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<p>The following technology choices provide a solid foundation for implementing the subscription billing system while maintaining flexibility for future enhancements:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Web Framework</td>\n<td><strong>Flask</strong> with Flask-RESTful</td>\n<td><strong>FastAPI</strong> with Pydantic</td>\n<td>FastAPI provides automatic API documentation and better async support</td>\n</tr>\n<tr>\n<td>Database</td>\n<td><strong>PostgreSQL</strong> with SQLAlchemy</td>\n<td><strong>PostgreSQL</strong> with async SQLAlchemy</td>\n<td>PostgreSQL offers strong consistency guarantees for financial data</td>\n</tr>\n<tr>\n<td>Message Queue</td>\n<td><strong>Redis</strong> with Python RQ</td>\n<td><strong>RabbitMQ</strong> with Celery</td>\n<td>Redis provides simple setup; RabbitMQ offers better reliability guarantees</td>\n</tr>\n<tr>\n<td>Caching</td>\n<td><strong>Redis</strong> (same instance as queue)</td>\n<td><strong>Redis Cluster</strong></td>\n<td>Redis handles both caching and simple queuing needs</td>\n</tr>\n<tr>\n<td>HTTP Client</td>\n<td><strong>requests</strong> library</td>\n<td><strong>httpx</strong> with async support</td>\n<td>httpx provides better async support for payment gateway integration</td>\n</tr>\n<tr>\n<td>Database Migrations</td>\n<td><strong>Alembic</strong> (SQLAlchemy migrations)</td>\n<td><strong>Alembic</strong> with custom migration scripts</td>\n<td>Alembic integrates well with SQLAlchemy ORM</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td><strong>Python-decouple</strong></td>\n<td><strong>Pydantic Settings</strong></td>\n<td>Pydantic provides type-safe configuration with validation</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td><strong>pytest</strong> with fixtures</td>\n<td><strong>pytest</strong> with factories and mocks</td>\n<td>pytest offers excellent fixture support for complex test scenarios</td>\n</tr>\n<tr>\n<td>API Documentation</td>\n<td><strong>Flask-RESTX</strong> (automatic docs)</td>\n<td><strong>FastAPI</strong> (built-in OpenAPI)</td>\n<td>Automatic API documentation reduces maintenance overhead</td>\n</tr>\n</tbody></table>\n<h4 id=\"core-infrastructure-setup\">Core Infrastructure Setup</h4>\n<p>Here&#39;s the foundational infrastructure code that supports all billing components. This code handles cross-cutting concerns like database transactions, audit logging, and financial precision:</p>\n<p><strong>Money Value Object (<code>internal/domain/shared/money.py</code>)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal, </span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Financial precision configuration</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DECIMAL_PRECISION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#9ECBFF\">'0.01'</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Cent precision for financial calculations</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_CURRENCY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'USD'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Supported currencies with display information</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">SUPPORTED_CURRENCIES</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'USD'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'$'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'US Dollar'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'EUR'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'€'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Euro'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'GBP'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'£'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'British Pound'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'JPY'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'¥'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Japanese Yen'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Immutable value object for financial amounts.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Stores amounts in smallest currency unit (cents) to avoid floating point errors.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    amount_cents: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currency_code: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unsupported currency: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.currency_code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Money amounts cannot be negative\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_decimal</span><span style=\"color:#E1E4E8\">(cls, amount: Decimal, currency: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> DEFAULT_CURRENCY</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create Money from decimal amount (e.g., 10.50 -> Money(1050, 'USD'))\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currency_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">[currency]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> currency_info[</span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Currencies like JPY don't have decimal places</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            amount_cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(amount.quantize(Decimal(</span><span style=\"color:#9ECBFF\">'1'</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">rounding</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Most currencies use cents</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            multiplier </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\"> currency_info[</span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            amount_cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">((amount </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> multiplier).quantize(Decimal(</span><span style=\"color:#9ECBFF\">'1'</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">rounding</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">amount_cents</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">amount_cents, </span><span style=\"color:#FFAB70\">currency_code</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">currency)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_decimal</span><span style=\"color:#E1E4E8\">(self) -> Decimal:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert Money to decimal amount (e.g., Money(1050, 'USD') -> Decimal('10.50'))\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currency_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> currency_info[</span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            divisor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\"> currency_info[</span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> divisor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __add__</span><span style=\"color:#E1E4E8\">(self, other: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._check_same_currency(other)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Money(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> other.amount_cents, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __sub__</span><span style=\"color:#E1E4E8\">(self, other: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._check_same_currency(other)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result_cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> other.amount_cents</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> result_cents </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cannot subtract to negative money amount\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Money(result_cents, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _check_same_currency</span><span style=\"color:#E1E4E8\">(self, other: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.currency_code:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Cannot operate on different currencies: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.currency_code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> and </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">other.currency_code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Database Transaction Manager (<code>internal/infrastructure/database/connection.py</code>)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> contextlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> create_engine, text</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy.orm </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sessionmaker, Session</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy.engine </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Engine</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Database isolation levels for different operation types</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ISOLATION_LEVEL_SERIALIZABLE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"SERIALIZABLE\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ISOLATION_LEVEL_READ_COMMITTED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"READ_COMMITTED\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DatabaseManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Manages database connections, transactions, and ensures proper isolation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    for financial operations that require strong consistency.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, connection_string: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.connection_string </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> connection_string</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.engine: Engine </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_engine(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            connection_string,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            pool_pre_ping</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># Verify connections before use</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            pool_recycle</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">3600</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#6A737D\"># Recycle connections every hour</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            echo</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#6A737D\">           # Set to True for SQL debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.SessionLocal </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sessionmaker(</span><span style=\"color:#FFAB70\">bind</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.engine)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> transaction</span><span style=\"color:#E1E4E8\">(self, isolation_level: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> ISOLATION_LEVEL_READ_COMMITTED</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Provide database transaction with specified isolation level.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Use SERIALIZABLE for financial operations to prevent race conditions.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        session </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.SessionLocal()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Set transaction isolation level</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            session.execute(text(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"SET TRANSACTION ISOLATION LEVEL </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">isolation_level</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            yield</span><span style=\"color:#E1E4E8\"> session</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            session.commit()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logger.debug(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Transaction committed with isolation level </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">isolation_level</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            session.rollback()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Transaction rolled back due to error: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        finally</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            session.close()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> health_check</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if database connection is healthy\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.transaction() </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> session:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                session.execute(text(</span><span style=\"color:#9ECBFF\">\"SELECT 1\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Database health check failed: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span></code></pre></div>\n\n<p><strong>Audit Event Logger (<code>internal/infrastructure/monitoring/audit_logger.py</code>)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, asdict</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuditEventType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Categories for different types of billing operations\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUBSCRIPTION_CREATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription_created\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUBSCRIPTION_CHANGED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription_changed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUBSCRIPTION_CANCELLED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription_cancelled\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PLAN_CREATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"plan_created\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PLAN_MODIFIED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"plan_modified\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVOICE_GENERATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"invoice_generated\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAYMENT_PROCESSED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"payment_processed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAYMENT_FAILED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"payment_failed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    USAGE_REPORTED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"usage_reported\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PRORATION_CALCULATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"proration_calculated\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuditEvent</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Audit trail event for billing operations\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event_type: AuditEventType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entity_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entity_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    changes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    actor_id: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metadata: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuditLogger</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Records audit trail for all billing operations to ensure</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    compliance and enable financial reconciliation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, database_manager):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.database_manager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> database_manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> log_event</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        event_type: AuditEventType, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entity_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entity_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        changes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        actor_id: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        metadata: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Record an audit event for billing operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        This creates an immutable record of what changed, when, and who made the change.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        event </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> AuditEvent(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            event_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">event_type,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            entity_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">entity_id,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            entity_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">entity_type,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            changes</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">changes,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            actor_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">actor_id,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            timestamp</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">datetime.utcnow(),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            metadata</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">metadata </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.database_manager.transaction() </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> session:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Insert audit event into audit_events table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Implementation would insert event data into database</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                logger.info(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Audit event recorded: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">event_type.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> for </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">entity_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#79B8FF\"> {</span><span style=\"color:#E1E4E8\">entity_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Failed to record audit event: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Audit failures should not break business operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # but should be monitored and alerted on</span></span></code></pre></div>\n\n<p><strong>Configuration Management (<code>config/settings.py</code>)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BillingSettings</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Central configuration for the billing system.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Supports environment-specific overrides while maintaining security.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Database configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    database_url: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    database_pool_size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 10</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Payment gateway settings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payment_gateway_url: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payment_gateway_api_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # Should come from environment variables</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payment_webhook_secret: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">   # Should come from environment variables</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Billing behavior configuration  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    default_currency: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"USD\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    trial_period_days: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 14</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    grace_period_days: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 7</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_retry_attempts: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Usage tracking settings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    usage_aggregation_batch_size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    usage_retention_days: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 365</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Financial precision</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rounding_precision: Decimal </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#9ECBFF\">'0.01'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # External service timeouts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payment_gateway_timeout: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#6A737D\">  # seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tax_service_timeout: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#6A737D\">      # seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_environment</span><span style=\"color:#E1E4E8\">(cls) -> </span><span style=\"color:#9ECBFF\">'BillingSettings'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Load configuration from environment variables with validation\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            database_url</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">os.getenv(</span><span style=\"color:#9ECBFF\">'DATABASE_URL'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'postgresql://localhost/billing'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            database_pool_size</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">(os.getenv(</span><span style=\"color:#9ECBFF\">'DATABASE_POOL_SIZE'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'10'</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            payment_gateway_url</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">os.getenv(</span><span style=\"color:#9ECBFF\">'PAYMENT_GATEWAY_URL'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'https://api.stripe.com'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            payment_gateway_api_key</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">os.getenv(</span><span style=\"color:#9ECBFF\">'PAYMENT_GATEWAY_API_KEY'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            payment_webhook_secret</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">os.getenv(</span><span style=\"color:#9ECBFF\">'PAYMENT_WEBHOOK_SECRET'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            trial_period_days</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">(os.getenv(</span><span style=\"color:#9ECBFF\">'TRIAL_PERIOD_DAYS'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'14'</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            grace_period_days</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">(os.getenv(</span><span style=\"color:#9ECBFF\">'GRACE_PERIOD_DAYS'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'7'</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span></code></pre></div>\n\n<h4 id=\"component-service-skeletons\">Component Service Skeletons</h4>\n<p>Here are the core service interfaces that implement the main billing components. These provide the structure for implementing each milestone:</p>\n<p><strong>Plan Management Service (<code>internal/domain/plan/service.py</code>)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Plan, PlanVersion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .repository </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PlanRepository</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PlanManagementService</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Handles subscription plan creation, modification, and versioning.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Corresponds to Milestone 1: Plans &#x26; Pricing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, plan_repository: PlanRepository, audit_logger):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.plan_repository </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> plan_repository</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.audit_logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> audit_logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_plan</span><span style=\"color:#E1E4E8\">(self, plan_data: </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">) -> Plan:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create new subscription plan with pricing and feature configuration.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Validate plan data structure and pricing configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Check for plan name uniqueness within organization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: Create Plan entity with initial version</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Validate pricing tiers and feature entitlements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 5: Persist plan and log audit event</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 6: Return created plan with generated ID</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> modify_plan</span><span style=\"color:#E1E4E8\">(self, plan_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, changes: </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">) -> PlanVersion:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create new version of existing plan while preserving existing subscriptions.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Load existing plan and validate modification permissions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Create new plan version with changes applied</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: Validate new version maintains backward compatibility</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Archive old version and activate new version</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 5: Log plan modification audit event</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 6: Return new plan version</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> calculate_plan_price</span><span style=\"color:#E1E4E8\">(self, plan_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, quantity: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Calculate pricing for plan based on quantity and pricing model.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Load plan pricing configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Determine pricing model (flat, per-seat, tiered, volume)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: Apply quantity to pricing calculation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Handle tiered vs volume pricing correctly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 5: Return Money object with calculated amount</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Subscription Lifecycle Service (<code>internal/domain/subscription/service.py</code>)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Subscription, SubscriptionState</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .repository </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SubscriptionRepository</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SubscriptionLifecycleService</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Manages complete subscription lifecycle from creation to cancellation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Corresponds to Milestone 2: Subscription Lifecycle.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, subscription_repository: SubscriptionRepository, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 plan_service, audit_logger):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.subscription_repository </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> subscription_repository</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.plan_service </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> plan_service</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.audit_logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> audit_logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_subscription</span><span style=\"color:#E1E4E8\">(self, customer_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, plan_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          payment_method_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, trial_end: Optional[datetime] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Subscription:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create new subscription with trial or immediate activation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Validate customer exists and has valid payment method</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Load and validate plan is available for new subscriptions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: Calculate billing anchor date and first billing date</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Create subscription entity with appropriate initial state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 5: Set up trial period if specified or plan includes trial</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 6: Persist subscription and publish SubscriptionCreated event</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 7: Return created subscription with all details</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_renewal</span><span style=\"color:#E1E4E8\">(self, subscription_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Process subscription renewal at end of billing period.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Load subscription and verify it's due for renewal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Check subscription is in renewable state (active, past_due)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: Generate invoice for upcoming billing period</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Attempt payment processing through payment service</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 5: Update subscription state based on payment result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 6: Schedule next renewal date if payment succeeded</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 7: Return success/failure status</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> cancel_subscription</span><span style=\"color:#E1E4E8\">(self, subscription_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          cancel_at_period_end: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">, reason: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Subscription:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Cancel subscription immediately or at end of current billing period.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Load subscription and validate it can be cancelled</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Calculate effective cancellation date based on cancel_at_period_end</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: Update subscription state to cancelled or scheduled for cancellation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Process any refunds if cancelling mid-period</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 5: Clean up recurring payment schedules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 6: Log cancellation audit event with reason</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 7: Return updated subscription</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"file-structure-implementation\">File Structure Implementation</h4>\n<p>Here&#39;s how to organize the initial project structure with key files:</p>\n<p><strong>Project Initialization Script (<code>setup_project.py</code>)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/usr/bin/env python3</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Script to initialize the subscription billing system project structure.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Run this to create all necessary directories and placeholder files.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_directory_structure</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create the complete project directory structure\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    directories </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'cmd/billing-server'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'cmd/usage-ingestion'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'cmd/billing-scheduler'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/domain/customer'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/domain/plan'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/domain/subscription'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/domain/usage'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/domain/billing'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/domain/shared'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/infrastructure/database'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/infrastructure/database/repositories'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/infrastructure/database/migrations'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/infrastructure/payment_gateway'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/infrastructure/messaging'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/infrastructure/external_services'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/infrastructure/monitoring'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/api/handlers'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/api/middleware'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'internal/api/serializers'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'config/environments'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'tests/unit/domain'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'tests/integration'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'tests/end_to_end'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'tests/fixtures'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'scripts'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'docs/api'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'docs/deployment'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'docs/troubleshooting'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> directory </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> directories:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Path(directory).mkdir(</span><span style=\"color:#FFAB70\">parents</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">exist_ok</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Create __init__.py files for Python packages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#9ECBFF\"> 'internal'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> directory </span><span style=\"color:#F97583\">or</span><span style=\"color:#9ECBFF\"> 'config'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> directory </span><span style=\"color:#F97583\">or</span><span style=\"color:#9ECBFF\"> 'tests'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> directory:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (Path(directory) </span><span style=\"color:#F97583\">/</span><span style=\"color:#9ECBFF\"> '__init__.py'</span><span style=\"color:#E1E4E8\">).touch()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✅ Project directory structure created successfully\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> __name__</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#9ECBFF\"> '__main__'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    create_directory_structure()</span></span></code></pre></div>\n\n<h4 id=\"milestone-validation-checkpoints\">Milestone Validation Checkpoints</h4>\n<p>After implementing each component, use these checkpoints to verify functionality:</p>\n<p><strong>Milestone 1 Checkpoint: Plan Management</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test plan creation and pricing calculation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/unit/domain/plan/</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from internal.domain.plan.service import PlanManagementService</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\"># Verify plan creation works with sample data</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print('✅ Plan management component ready')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Checkpoint: Subscription Lifecycle</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test subscription state machine and lifecycle</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/unit/domain/subscription/</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from internal.domain.subscription.service import SubscriptionLifecycleService</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\"># Verify subscription creation and state transitions</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print('✅ Subscription lifecycle component ready')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p><strong>Integration Checkpoint: Database and Payment Gateway</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test database connectivity and payment integration</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from config.settings import BillingSettings</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from internal.infrastructure.database.connection import DatabaseManager</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">settings = BillingSettings.from_environment()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">db = DatabaseManager(settings.database_url)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">if db.health_check():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    print('✅ Database connection working')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">else:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    print('❌ Database connection failed')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p>This implementation guidance provides the foundation for building the subscription billing system with proper separation of concerns, financial precision, and scalability. The structure supports both current requirements and future enhancements while maintaining clean architectural boundaries.</p>\n<h2 id=\"data-model-and-core-entities\">Data Model and Core Entities</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all milestones - provides the data structures and relationships that support plan management (Milestone 1), subscription lifecycle (Milestone 2), proration calculations (Milestone 3), and usage-based billing (Milestone 4)</p>\n</blockquote>\n<h3 id=\"mental-model-the-financial-ledger-system\">Mental Model: The Financial Ledger System</h3>\n<p>Think of the subscription billing data model like a traditional accounting ledger system that a bank might use. Each customer is like an account holder with a unique account number. Subscription plans are like different types of banking products (checking accounts, savings accounts, credit cards) - each with specific terms, fees, and features. Active subscriptions are like opened accounts that generate recurring transactions. Invoices are like monthly statements that itemize all charges and payments. Usage events are like individual transaction records that get aggregated into summary line items on the statement.</p>\n<p>Just as a bank must maintain perfect accuracy in financial records and preserve complete audit trails, our billing system must ensure every monetary amount is precise to the cent, every state change is tracked, and every calculation can be verified. The data model serves as the foundation for financial integrity - any errors or inconsistencies at this level cascade into billing disputes, revenue leakage, and compliance violations.</p>\n<p>The key insight is that subscription billing is fundamentally an event-sourced financial system. Every significant business event (subscription creation, plan changes, usage consumption, payments) generates immutable records that collectively define the current state. This approach ensures we can always reconstruct how we arrived at any billing amount and provides the auditability that financial systems require.</p>\n<h3 id=\"core-business-entities\">Core Business Entities</h3>\n<p>The subscription billing system is built around five core entities that represent the fundamental business concepts. Each entity captures specific aspects of the customer relationship and billing lifecycle, with carefully designed relationships that maintain referential integrity and support complex billing scenarios.</p>\n<p><img src=\"/api/project/subscription-billing/architecture-doc/asset?path=diagrams%2Fdata-model-relationships.svg\" alt=\"Core Entity Relationship Diagram\"></p>\n<h4 id=\"customer-entity\">Customer Entity</h4>\n<p>The <code>Customer</code> entity represents the billing account holder and serves as the root aggregate for all subscription-related activities. A customer can have multiple subscriptions but maintains unified billing settings and credit balances across all their services.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>customer_id</code></td>\n<td>UUID</td>\n<td>Primary key, immutable unique identifier for the customer</td>\n</tr>\n<tr>\n<td><code>external_id</code></td>\n<td>String</td>\n<td>Optional external system identifier for integration purposes</td>\n</tr>\n<tr>\n<td><code>email</code></td>\n<td>String</td>\n<td>Primary email address for billing communications and account recovery</td>\n</tr>\n<tr>\n<td><code>name</code></td>\n<td>String</td>\n<td>Full name or company name for invoice display</td>\n</tr>\n<tr>\n<td><code>billing_address</code></td>\n<td>JSON</td>\n<td>Structured address object with street, city, state, postal_code, country</td>\n</tr>\n<tr>\n<td><code>tax_id</code></td>\n<td>String</td>\n<td>Tax identification number for tax calculation and compliance</td>\n</tr>\n<tr>\n<td><code>currency</code></td>\n<td>String</td>\n<td>Preferred currency code (ISO 4217) for all billing in this account</td>\n</tr>\n<tr>\n<td><code>credit_balance_cents</code></td>\n<td>Integer</td>\n<td>Current credit balance in smallest currency unit (cents)</td>\n</tr>\n<tr>\n<td><code>payment_method_id</code></td>\n<td>UUID</td>\n<td>Reference to default payment method in payment gateway</td>\n</tr>\n<tr>\n<td><code>billing_email</code></td>\n<td>String</td>\n<td>Optional separate email for billing notifications</td>\n</tr>\n<tr>\n<td><code>account_status</code></td>\n<td>Enum</td>\n<td>Current account status: active, suspended, closed</td>\n</tr>\n<tr>\n<td><code>created_at</code></td>\n<td>Timestamp</td>\n<td>Account creation date for analytics and lifecycle tracking</td>\n</tr>\n<tr>\n<td><code>updated_at</code></td>\n<td>Timestamp</td>\n<td>Last modification timestamp for change tracking</td>\n</tr>\n<tr>\n<td><code>metadata</code></td>\n<td>JSON</td>\n<td>Extensible field for custom attributes and integration data</td>\n</tr>\n</tbody></table>\n<p>The customer entity includes a <code>credit_balance_cents</code> field that accumulates credits from downgrades, refunds, and promotional credits. This balance is automatically applied to future invoices, providing a seamless experience for customers receiving credits. The <code>billing_address</code> and <code>tax_id</code> fields support tax calculation requirements and compliance with regional billing regulations.</p>\n<h4 id=\"plan-entity\">Plan Entity</h4>\n<p>The <code>Plan</code> entity defines the pricing structure, billing terms, and feature entitlements for subscription offerings. Plans are versioned to ensure existing subscribers maintain their original terms while allowing the business to evolve pricing over time.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>plan_id</code></td>\n<td>UUID</td>\n<td>Primary key, immutable unique identifier for this plan version</td>\n</tr>\n<tr>\n<td><code>plan_code</code></td>\n<td>String</td>\n<td>Human-readable identifier (e.g., &quot;pro-monthly-v2&quot;)</td>\n</tr>\n<tr>\n<td><code>name</code></td>\n<td>String</td>\n<td>Display name for customer-facing interfaces</td>\n</tr>\n<tr>\n<td><code>description</code></td>\n<td>String</td>\n<td>Detailed description of plan features and benefits</td>\n</tr>\n<tr>\n<td><code>status</code></td>\n<td>Enum</td>\n<td>Plan status: active, deprecated, archived</td>\n</tr>\n<tr>\n<td><code>billing_interval</code></td>\n<td>Enum</td>\n<td>Recurring billing period: monthly, quarterly, annual</td>\n</tr>\n<tr>\n<td><code>billing_interval_count</code></td>\n<td>Integer</td>\n<td>Number of intervals between charges (e.g., 2 for bi-monthly)</td>\n</tr>\n<tr>\n<td><code>pricing_model</code></td>\n<td>Enum</td>\n<td>Pricing structure: flat_rate, per_seat, tiered, volume</td>\n</tr>\n<tr>\n<td><code>base_price_cents</code></td>\n<td>Integer</td>\n<td>Base recurring charge in smallest currency unit</td>\n</tr>\n<tr>\n<td><code>currency</code></td>\n<td>String</td>\n<td>Currency code (ISO 4217) for all pricing in this plan</td>\n</tr>\n<tr>\n<td><code>trial_period_days</code></td>\n<td>Integer</td>\n<td>Length of free trial period, null if no trial offered</td>\n</tr>\n<tr>\n<td><code>setup_fee_cents</code></td>\n<td>Integer</td>\n<td>One-time setup charge applied at subscription creation</td>\n</tr>\n<tr>\n<td><code>features</code></td>\n<td>JSON</td>\n<td>Array of feature flags and entitlements included in this plan</td>\n</tr>\n<tr>\n<td><code>usage_limits</code></td>\n<td>JSON</td>\n<td>Monthly usage quotas for metered features</td>\n</tr>\n<tr>\n<td><code>pricing_tiers</code></td>\n<td>JSON</td>\n<td>Tiered pricing structure for usage-based billing</td>\n</tr>\n<tr>\n<td><code>created_at</code></td>\n<td>Timestamp</td>\n<td>Plan creation date for lifecycle tracking</td>\n</tr>\n<tr>\n<td><code>updated_at</code></td>\n<td>Timestamp</td>\n<td>Last modification timestamp</td>\n</tr>\n<tr>\n<td><code>deprecated_at</code></td>\n<td>Timestamp</td>\n<td>Date when plan was deprecated (null if still active)</td>\n</tr>\n<tr>\n<td><code>metadata</code></td>\n<td>JSON</td>\n<td>Extensible field for custom plan attributes</td>\n</tr>\n</tbody></table>\n<p>The <code>pricing_tiers</code> field supports complex usage-based billing scenarios. For example, an API plan might have tiers like: &quot;First 1,000 calls free, next 9,000 calls at $0.001 each, additional calls at $0.0005 each.&quot; The <code>features</code> field contains an array of feature flags that the entitlement system uses to control access to application functionality.</p>\n<blockquote>\n<p><strong>Decision: Plan Versioning Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: When businesses need to change pricing or features, they must decide whether to update existing plans or create new versions</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Update plans in-place (simple but breaks existing customer terms)</li>\n<li>Create new plan versions and deprecate old ones</li>\n<li>Full plan history with temporal validity periods</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Create new plan versions and deprecate old ones</li>\n<li><strong>Rationale</strong>: Preserves existing customer terms (critical for trust), provides clear upgrade paths, and maintains audit trail while avoiding the complexity of temporal data management</li>\n<li><strong>Consequences</strong>: Requires plan migration workflows and slightly more complex plan selection logic, but ensures customer contract integrity</li>\n</ul>\n</blockquote>\n<h4 id=\"subscription-entity\">Subscription Entity</h4>\n<p>The <code>Subscription</code> entity represents an active customer enrollment in a specific plan. It tracks the subscription lifecycle, billing schedule, and current state while maintaining complete history of plan changes and modifications.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>subscription_id</code></td>\n<td>UUID</td>\n<td>Primary key, immutable unique identifier</td>\n</tr>\n<tr>\n<td><code>customer_id</code></td>\n<td>UUID</td>\n<td>Foreign key reference to customer entity</td>\n</tr>\n<tr>\n<td><code>plan_id</code></td>\n<td>UUID</td>\n<td>Foreign key reference to current plan</td>\n</tr>\n<tr>\n<td><code>status</code></td>\n<td>Enum</td>\n<td>Current state: trial, active, past_due, cancelled, expired</td>\n</tr>\n<tr>\n<td><code>billing_cycle_anchor</code></td>\n<td>Integer</td>\n<td>Day of month for recurring billing (1-31)</td>\n</tr>\n<tr>\n<td><code>current_period_start</code></td>\n<td>Date</td>\n<td>Start date of current billing period</td>\n</tr>\n<tr>\n<td><code>current_period_end</code></td>\n<td>Date</td>\n<td>End date of current billing period</td>\n</tr>\n<tr>\n<td><code>trial_start</code></td>\n<td>Date</td>\n<td>Trial period start date (null if no trial)</td>\n</tr>\n<tr>\n<td><code>trial_end</code></td>\n<td>Date</td>\n<td>Trial period end date (null if no trial)</td>\n</tr>\n<tr>\n<td><code>cancelled_at</code></td>\n<td>Timestamp</td>\n<td>Cancellation request timestamp (null if not cancelled)</td>\n</tr>\n<tr>\n<td><code>cancel_at_period_end</code></td>\n<td>Boolean</td>\n<td>Whether cancellation takes effect at period end</td>\n</tr>\n<tr>\n<td><code>ended_at</code></td>\n<td>Timestamp</td>\n<td>Actual subscription termination timestamp</td>\n</tr>\n<tr>\n<td><code>quantity</code></td>\n<td>Integer</td>\n<td>Number of seats or units for per-seat pricing</td>\n</tr>\n<tr>\n<td><code>proration_behavior</code></td>\n<td>Enum</td>\n<td>How to handle mid-cycle changes: immediate, next_cycle</td>\n</tr>\n<tr>\n<td><code>collection_method</code></td>\n<td>Enum</td>\n<td>Payment timing: charge_automatically, send_invoice</td>\n</tr>\n<tr>\n<td><code>days_until_due</code></td>\n<td>Integer</td>\n<td>Payment terms for invoice-based collection</td>\n</tr>\n<tr>\n<td><code>created_at</code></td>\n<td>Timestamp</td>\n<td>Subscription creation timestamp</td>\n</tr>\n<tr>\n<td><code>updated_at</code></td>\n<td>Timestamp</td>\n<td>Last modification timestamp</td>\n</tr>\n<tr>\n<td><code>metadata</code></td>\n<td>JSON</td>\n<td>Custom attributes and integration data</td>\n</tr>\n</tbody></table>\n<p>The <code>billing_cycle_anchor</code> field ensures consistent billing dates. For example, a subscription created on January 31st with a monthly billing interval will bill on the last day of each month (February 28th, March 31st, etc.) rather than causing month overflow issues. The <code>proration_behavior</code> setting controls whether plan changes take effect immediately with prorated charges or wait until the next billing cycle.</p>\n<h4 id=\"invoice-entity\">Invoice Entity</h4>\n<p>The <code>Invoice</code> entity represents a billing statement that itemizes charges, credits, and payment details for a specific billing period. Invoices are immutable once finalized to ensure financial accuracy and audit compliance.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>invoice_id</code></td>\n<td>UUID</td>\n<td>Primary key, immutable unique identifier</td>\n</tr>\n<tr>\n<td><code>customer_id</code></td>\n<td>UUID</td>\n<td>Foreign key reference to customer</td>\n</tr>\n<tr>\n<td><code>subscription_id</code></td>\n<td>UUID</td>\n<td>Primary subscription for this invoice (nullable for one-off charges)</td>\n</tr>\n<tr>\n<td><code>invoice_number</code></td>\n<td>String</td>\n<td>Sequential human-readable identifier (e.g., &quot;INV-2024-001234&quot;)</td>\n</tr>\n<tr>\n<td><code>status</code></td>\n<td>Enum</td>\n<td>Invoice state: draft, open, paid, void, uncollectible</td>\n</tr>\n<tr>\n<td><code>period_start</code></td>\n<td>Date</td>\n<td>Billing period start date</td>\n</tr>\n<tr>\n<td><code>period_end</code></td>\n<td>Date</td>\n<td>Billing period end date</td>\n</tr>\n<tr>\n<td><code>subtotal_cents</code></td>\n<td>Integer</td>\n<td>Total charges before credits and taxes</td>\n</tr>\n<tr>\n<td><code>credit_applied_cents</code></td>\n<td>Integer</td>\n<td>Credits applied from customer balance</td>\n</tr>\n<tr>\n<td><code>tax_cents</code></td>\n<td>Integer</td>\n<td>Tax amount calculated based on customer location</td>\n</tr>\n<tr>\n<td><code>total_cents</code></td>\n<td>Integer</td>\n<td>Final amount due after credits and taxes</td>\n</tr>\n<tr>\n<td><code>amount_paid_cents</code></td>\n<td>Integer</td>\n<td>Amount actually collected</td>\n</tr>\n<tr>\n<td><code>amount_remaining_cents</code></td>\n<td>Integer</td>\n<td>Outstanding balance (total - paid)</td>\n</tr>\n<tr>\n<td><code>currency</code></td>\n<td>String</td>\n<td>Currency code for all amounts on this invoice</td>\n</tr>\n<tr>\n<td><code>due_date</code></td>\n<td>Date</td>\n<td>Payment due date for collection</td>\n</tr>\n<tr>\n<td><code>paid_at</code></td>\n<td>Timestamp</td>\n<td>Payment completion timestamp (null if unpaid)</td>\n</tr>\n<tr>\n<td><code>voided_at</code></td>\n<td>Timestamp</td>\n<td>Void timestamp (null if not voided)</td>\n</tr>\n<tr>\n<td><code>payment_attempt_count</code></td>\n<td>Integer</td>\n<td>Number of payment collection attempts</td>\n</tr>\n<tr>\n<td><code>next_payment_attempt</code></td>\n<td>Timestamp</td>\n<td>Scheduled retry timestamp for failed payments</td>\n</tr>\n<tr>\n<td><code>created_at</code></td>\n<td>Timestamp</td>\n<td>Invoice generation timestamp</td>\n</tr>\n<tr>\n<td><code>finalized_at</code></td>\n<td>Timestamp</td>\n<td>When invoice became immutable</td>\n</tr>\n<tr>\n<td><code>metadata</code></td>\n<td>JSON</td>\n<td>Additional invoice attributes</td>\n</tr>\n</tbody></table>\n<p>The invoice tracks separate amounts for charges, credits, taxes, and payments to provide complete transparency in billing calculations. The <code>payment_attempt_count</code> and <code>next_payment_attempt</code> fields support dunning management by tracking retry attempts and scheduling future collection efforts.</p>\n<h4 id=\"invoice-line-item-entity\">Invoice Line Item Entity</h4>\n<p>Invoice line items provide detailed breakdown of charges and credits on each invoice. This granular structure supports complex billing scenarios including proration, usage charges, and plan changes.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>line_item_id</code></td>\n<td>UUID</td>\n<td>Primary key, immutable unique identifier</td>\n</tr>\n<tr>\n<td><code>invoice_id</code></td>\n<td>UUID</td>\n<td>Foreign key reference to parent invoice</td>\n</tr>\n<tr>\n<td><code>subscription_id</code></td>\n<td>UUID</td>\n<td>Subscription generating this line item (nullable)</td>\n</tr>\n<tr>\n<td><code>type</code></td>\n<td>Enum</td>\n<td>Line item type: subscription, usage, proration_credit, setup_fee</td>\n</tr>\n<tr>\n<td><code>description</code></td>\n<td>String</td>\n<td>Human-readable description of the charge</td>\n</tr>\n<tr>\n<td><code>period_start</code></td>\n<td>Date</td>\n<td>Service period start date for this line item</td>\n</tr>\n<tr>\n<td><code>period_end</code></td>\n<td>Date</td>\n<td>Service period end date for this line item</td>\n</tr>\n<tr>\n<td><code>quantity</code></td>\n<td>Decimal</td>\n<td>Units being charged (e.g., seats, API calls)</td>\n</tr>\n<tr>\n<td><code>unit_amount_cents</code></td>\n<td>Integer</td>\n<td>Price per unit in smallest currency unit</td>\n</tr>\n<tr>\n<td><code>amount_cents</code></td>\n<td>Integer</td>\n<td>Total amount for this line item (quantity × unit_amount)</td>\n</tr>\n<tr>\n<td><code>proration_factor</code></td>\n<td>Decimal</td>\n<td>Percentage of billing period (e.g., 0.5 for half month)</td>\n</tr>\n<tr>\n<td><code>plan_id</code></td>\n<td>UUID</td>\n<td>Plan associated with this charge (nullable)</td>\n</tr>\n<tr>\n<td><code>usage_summary</code></td>\n<td>JSON</td>\n<td>Aggregated usage data for usage-based line items</td>\n</tr>\n<tr>\n<td><code>created_at</code></td>\n<td>Timestamp</td>\n<td>Line item creation timestamp</td>\n</tr>\n<tr>\n<td><code>metadata</code></td>\n<td>JSON</td>\n<td>Additional line item attributes</td>\n</tr>\n</tbody></table>\n<p>The <code>proration_factor</code> field captures the exact percentage of a billing period that a charge covers, enabling precise proration calculations. For example, a mid-month upgrade from a $10 plan to a $20 plan with 15 days remaining would generate a proration credit line item with factor 0.5 (15/30 days) for -$5.</p>\n<h4 id=\"payment-entity\">Payment Entity</h4>\n<p>The <code>Payment</code> entity records payment attempts and their results, integrating with the external payment gateway while maintaining local records for reconciliation and reporting.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>payment_id</code></td>\n<td>UUID</td>\n<td>Primary key, immutable unique identifier</td>\n</tr>\n<tr>\n<td><code>customer_id</code></td>\n<td>UUID</td>\n<td>Foreign key reference to customer</td>\n</tr>\n<tr>\n<td><code>invoice_id</code></td>\n<td>UUID</td>\n<td>Foreign key reference to invoice being paid</td>\n</tr>\n<tr>\n<td><code>payment_intent_id</code></td>\n<td>String</td>\n<td>External payment gateway transaction identifier</td>\n</tr>\n<tr>\n<td><code>amount_cents</code></td>\n<td>Integer</td>\n<td>Payment amount in smallest currency unit</td>\n</tr>\n<tr>\n<td><code>currency</code></td>\n<td>String</td>\n<td>Payment currency code</td>\n</tr>\n<tr>\n<td><code>status</code></td>\n<td>Enum</td>\n<td>Payment state: pending, succeeded, failed, cancelled, refunded</td>\n</tr>\n<tr>\n<td><code>payment_method_type</code></td>\n<td>String</td>\n<td>Payment method used (card, bank_transfer, etc.)</td>\n</tr>\n<tr>\n<td><code>failure_code</code></td>\n<td>String</td>\n<td>Error code from payment gateway (null if successful)</td>\n</tr>\n<tr>\n<td><code>failure_message</code></td>\n<td>String</td>\n<td>Human-readable failure description</td>\n</tr>\n<tr>\n<td><code>gateway_response</code></td>\n<td>JSON</td>\n<td>Complete response from payment processor</td>\n</tr>\n<tr>\n<td><code>captured_at</code></td>\n<td>Timestamp</td>\n<td>When payment was captured (null if pending)</td>\n</tr>\n<tr>\n<td><code>refunded_at</code></td>\n<td>Timestamp</td>\n<td>Refund timestamp (null if not refunded)</td>\n</tr>\n<tr>\n<td><code>refunded_amount_cents</code></td>\n<td>Integer</td>\n<td>Amount refunded (null if no refund)</td>\n</tr>\n<tr>\n<td><code>created_at</code></td>\n<td>Timestamp</td>\n<td>Payment attempt timestamp</td>\n</tr>\n<tr>\n<td><code>metadata</code></td>\n<td>JSON</td>\n<td>Additional payment attributes</td>\n</tr>\n</tbody></table>\n<h3 id=\"entity-relationships-and-constraints\">Entity Relationships and Constraints</h3>\n<p>The relationships between entities enforce business rules and maintain data integrity across the subscription lifecycle. These constraints prevent invalid states and ensure consistent billing behavior.</p>\n<h4 id=\"primary-relationships\">Primary Relationships</h4>\n<p>The core entity relationships follow a hierarchical structure where customers own subscriptions, subscriptions generate invoices, and invoices are settled by payments. This design supports both simple single-subscription customers and complex enterprise accounts with multiple subscriptions and consolidated billing.</p>\n<table>\n<thead>\n<tr>\n<th>Relationship</th>\n<th>Cardinality</th>\n<th>Foreign Key</th>\n<th>Constraint Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Customer → Subscription</td>\n<td>One to Many</td>\n<td><code>subscription.customer_id</code></td>\n<td>Each customer can have multiple active subscriptions</td>\n</tr>\n<tr>\n<td>Plan → Subscription</td>\n<td>One to Many</td>\n<td><code>subscription.plan_id</code></td>\n<td>Multiple subscriptions can use the same plan</td>\n</tr>\n<tr>\n<td>Customer → Invoice</td>\n<td>One to Many</td>\n<td><code>invoice.customer_id</code></td>\n<td>All invoices belong to a specific customer</td>\n</tr>\n<tr>\n<td>Subscription → Invoice</td>\n<td>One to Many</td>\n<td><code>invoice.subscription_id</code></td>\n<td>Subscriptions generate recurring invoices</td>\n</tr>\n<tr>\n<td>Invoice → Line Item</td>\n<td>One to Many</td>\n<td><code>line_item.invoice_id</code></td>\n<td>Each invoice contains one or more line items</td>\n</tr>\n<tr>\n<td>Invoice → Payment</td>\n<td>One to Many</td>\n<td><code>payment.invoice_id</code></td>\n<td>Invoices may require multiple payment attempts</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Subscription-Invoice Relationship</strong></p>\n<ul>\n<li><strong>Context</strong>: Some billing systems link invoices directly to billing periods, others to specific subscriptions</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Link invoices to subscriptions (enables subscription-specific billing)</li>\n<li>Link invoices to customers only (enables consolidated billing)</li>\n<li>Support both models with nullable subscription references</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Support both models with nullable subscription references</li>\n<li><strong>Rationale</strong>: Provides flexibility for enterprise customers who need consolidated billing while maintaining subscription-specific invoices for simpler use cases</li>\n<li><strong>Consequences</strong>: Requires conditional logic in billing workflows but supports both B2B and B2C billing patterns</li>\n</ul>\n</blockquote>\n<h4 id=\"business-rule-constraints\">Business Rule Constraints</h4>\n<p>The subscription billing system enforces several critical business rules through database constraints and application logic. These rules prevent data corruption and ensure billing accuracy.</p>\n<table>\n<thead>\n<tr>\n<th>Constraint</th>\n<th>Entity</th>\n<th>Rule Description</th>\n<th>Enforcement Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Currency Consistency</td>\n<td>Customer, Plan, Subscription</td>\n<td>All entities in a billing relationship must use the same currency</td>\n<td>Application validation</td>\n</tr>\n<tr>\n<td>Billing Period Validity</td>\n<td>Subscription</td>\n<td><code>current_period_end</code> must be after <code>current_period_start</code></td>\n<td>Database check constraint</td>\n</tr>\n<tr>\n<td>Trial Period Logic</td>\n<td>Subscription</td>\n<td>Trial end must be before or equal to first billing date</td>\n<td>Application validation</td>\n</tr>\n<tr>\n<td>Invoice Immutability</td>\n<td>Invoice</td>\n<td>Finalized invoices cannot be modified</td>\n<td>Application logic</td>\n</tr>\n<tr>\n<td>Payment Amount Validation</td>\n<td>Payment</td>\n<td>Payment amount cannot exceed invoice total</td>\n<td>Application validation</td>\n</tr>\n<tr>\n<td>Status Transitions</td>\n<td>Subscription, Invoice</td>\n<td>Only valid state transitions are allowed</td>\n<td>Application state machine</td>\n</tr>\n<tr>\n<td>Credit Balance Consistency</td>\n<td>Customer</td>\n<td>Credit balance cannot be negative after applying credits</td>\n<td>Database check constraint</td>\n</tr>\n<tr>\n<td>Plan Version Integrity</td>\n<td>Plan</td>\n<td>Deprecated plans cannot be assigned to new subscriptions</td>\n<td>Application validation</td>\n</tr>\n</tbody></table>\n<p>The currency consistency constraint prevents billing errors that could occur when mixing currencies within a customer account. For example, a customer with USD billing cannot be assigned a plan priced in EUR without explicit currency conversion.</p>\n<h4 id=\"data-integrity-rules\">Data Integrity Rules</h4>\n<p>Financial systems require additional integrity safeguards beyond standard relational constraints. These rules ensure monetary calculations are accurate and auditable.</p>\n<p><strong>Money Amount Precision</strong>: All monetary amounts are stored as integers representing the smallest currency unit (cents for USD). This eliminates floating-point precision errors that could accumulate across many billing cycles. The system uses a <code>Money</code> type that encapsulates amount and currency to prevent mixing currencies in calculations.</p>\n<p><strong>Idempotent Operations</strong>: Critical operations like invoice generation and payment processing must be idempotent to prevent duplicate charges. Each operation includes an idempotency key that prevents duplicate execution if requests are retried.</p>\n<p><strong>Audit Trail Requirements</strong>: Every modification to subscription state, plan assignments, and billing amounts generates an audit event. This provides complete traceability for compliance and customer service purposes.</p>\n<p><strong>Referential Integrity</strong>: Foreign key relationships are enforced at the database level where possible, with application-level validation for complex business rules. Cascade delete operations are restricted to prevent accidental data loss.</p>\n<h3 id=\"usage-tracking-data-model\">Usage Tracking Data Model</h3>\n<p>Usage-based billing requires a separate data model optimized for high-volume event ingestion and efficient aggregation. This model supports real-time usage tracking while providing the performance needed for billing calculations across large customer bases.</p>\n<h4 id=\"usage-event-entity\">Usage Event Entity</h4>\n<p>The <code>UsageEvent</code> entity captures individual metered activities that contribute to usage-based charges. Events are designed to be immutable and idempotent to ensure accurate billing regardless of retry behavior or duplicate submissions.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>event_id</code></td>\n<td>UUID</td>\n<td>Primary key, immutable unique identifier</td>\n</tr>\n<tr>\n<td><code>idempotency_key</code></td>\n<td>String</td>\n<td>Client-provided key for duplicate detection</td>\n</tr>\n<tr>\n<td><code>customer_id</code></td>\n<td>UUID</td>\n<td>Foreign key reference to customer</td>\n</tr>\n<tr>\n<td><code>subscription_id</code></td>\n<td>UUID</td>\n<td>Foreign key reference to subscription</td>\n</tr>\n<tr>\n<td><code>event_type</code></td>\n<td>String</td>\n<td>Meter name (e.g., &quot;api_calls&quot;, &quot;storage_gb&quot;)</td>\n</tr>\n<tr>\n<td><code>quantity</code></td>\n<td>Decimal</td>\n<td>Amount consumed in this event</td>\n</tr>\n<tr>\n<td><code>unit</code></td>\n<td>String</td>\n<td>Unit of measurement (calls, GB, hours)</td>\n</tr>\n<tr>\n<td><code>timestamp</code></td>\n<td>Timestamp</td>\n<td>When the usage occurred (client-reported)</td>\n</tr>\n<tr>\n<td><code>processed_at</code></td>\n<td>Timestamp</td>\n<td>When the event was received and validated</td>\n</tr>\n<tr>\n<td><code>billing_period</code></td>\n<td>String</td>\n<td>Billing period this event contributes to (YYYY-MM format)</td>\n</tr>\n<tr>\n<td><code>properties</code></td>\n<td>JSON</td>\n<td>Additional event metadata and dimensions</td>\n</tr>\n<tr>\n<td><code>source_system</code></td>\n<td>String</td>\n<td>System that generated this usage event</td>\n</tr>\n<tr>\n<td><code>aggregated</code></td>\n<td>Boolean</td>\n<td>Whether this event has been included in billing calculations</td>\n</tr>\n<tr>\n<td><code>created_at</code></td>\n<td>Timestamp</td>\n<td>Event record creation timestamp</td>\n</tr>\n</tbody></table>\n<p>The <code>idempotency_key</code> field prevents double-counting when client systems retry usage submissions. The billing system checks for existing events with the same idempotency key and customer before creating new records. The <code>billing_period</code> field enables efficient querying for aggregation without complex date range calculations.</p>\n<blockquote>\n<p><strong>Decision: Usage Event Aggregation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Usage events can accumulate to millions of records per month, requiring efficient aggregation for billing</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Real-time aggregation into running totals (fast billing but complex consistency)</li>\n<li>Batch aggregation during billing cycle (simple but potential delays)</li>\n<li>Hybrid approach with periodic pre-aggregation and billing-time finalization</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hybrid approach with periodic pre-aggregation</li>\n<li><strong>Rationale</strong>: Balances billing speed with system complexity while providing near real-time usage visibility for customers</li>\n<li><strong>Consequences</strong>: Requires background aggregation jobs and eventual consistency handling, but enables responsive usage dashboards and fast billing</li>\n</ul>\n</blockquote>\n<h4 id=\"usage-aggregation-entity\">Usage Aggregation Entity</h4>\n<p>The <code>UsageAggregation</code> entity stores pre-computed usage totals for efficient billing calculations. Aggregations are updated periodically and finalized during billing to ensure accuracy.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>aggregation_id</code></td>\n<td>UUID</td>\n<td>Primary key, immutable unique identifier</td>\n</tr>\n<tr>\n<td><code>customer_id</code></td>\n<td>UUID</td>\n<td>Foreign key reference to customer</td>\n</tr>\n<tr>\n<td><code>subscription_id</code></td>\n<td>UUID</td>\n<td>Foreign key reference to subscription</td>\n</tr>\n<tr>\n<td><code>event_type</code></td>\n<td>String</td>\n<td>Meter name being aggregated</td>\n</tr>\n<tr>\n<td><code>billing_period</code></td>\n<td>String</td>\n<td>Billing period for this aggregation (YYYY-MM format)</td>\n</tr>\n<tr>\n<td><code>period_start</code></td>\n<td>Date</td>\n<td>Start date of the billing period</td>\n</tr>\n<tr>\n<td><code>period_end</code></td>\n<td>Date</td>\n<td>End date of the billing period</td>\n</tr>\n<tr>\n<td><code>total_quantity</code></td>\n<td>Decimal</td>\n<td>Total usage amount for this period</td>\n</tr>\n<tr>\n<td><code>event_count</code></td>\n<td>Integer</td>\n<td>Number of events included in aggregation</td>\n</tr>\n<tr>\n<td><code>last_event_timestamp</code></td>\n<td>Timestamp</td>\n<td>Timestamp of most recent event included</td>\n</tr>\n<tr>\n<td><code>is_finalized</code></td>\n<td>Boolean</td>\n<td>Whether aggregation is complete for billing</td>\n</tr>\n<tr>\n<td><code>finalized_at</code></td>\n<td>Timestamp</td>\n<td>When aggregation was finalized</td>\n</tr>\n<tr>\n<td><code>updated_at</code></td>\n<td>Timestamp</td>\n<td>Last aggregation update timestamp</td>\n</tr>\n</tbody></table>\n<h4 id=\"usage-billing-entity\">Usage Billing Entity</h4>\n<p>The <code>UsageBilling</code> entity calculates billable amounts from usage aggregations based on plan pricing tiers and limits. This separation allows for complex usage billing scenarios and provides transparency in billing calculations.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>usage_billing_id</code></td>\n<td>UUID</td>\n<td>Primary key, immutable unique identifier</td>\n</tr>\n<tr>\n<td><code>aggregation_id</code></td>\n<td>UUID</td>\n<td>Foreign key reference to usage aggregation</td>\n</tr>\n<tr>\n<td><code>plan_id</code></td>\n<td>UUID</td>\n<td>Plan used for billing calculation</td>\n</tr>\n<tr>\n<td><code>event_type</code></td>\n<td>String</td>\n<td>Meter name being billed</td>\n</tr>\n<tr>\n<td><code>billing_period</code></td>\n<td>String</td>\n<td>Billing period for this calculation</td>\n</tr>\n<tr>\n<td><code>included_quantity</code></td>\n<td>Decimal</td>\n<td>Usage amount included in plan (free tier)</td>\n</tr>\n<tr>\n<td><code>billable_quantity</code></td>\n<td>Decimal</td>\n<td>Usage amount subject to charges</td>\n</tr>\n<tr>\n<td><code>total_amount_cents</code></td>\n<td>Integer</td>\n<td>Total charges for this usage type</td>\n</tr>\n<tr>\n<td><code>tier_breakdown</code></td>\n<td>JSON</td>\n<td>Detailed calculation showing each pricing tier</td>\n</tr>\n<tr>\n<td><code>calculated_at</code></td>\n<td>Timestamp</td>\n<td>When billing calculation was performed</td>\n</tr>\n<tr>\n<td><code>invoice_line_item_id</code></td>\n<td>UUID</td>\n<td>Reference to generated invoice line item</td>\n</tr>\n</tbody></table>\n<p>The <code>tier_breakdown</code> field contains a detailed calculation showing how usage was allocated across pricing tiers. For example: <code>{&quot;tiers&quot;: [{&quot;range&quot;: &quot;0-1000&quot;, &quot;quantity&quot;: 1000, &quot;rate_cents&quot;: 0, &quot;amount_cents&quot;: 0}, {&quot;range&quot;: &quot;1001-5000&quot;, &quot;quantity&quot;: 2500, &quot;rate_cents&quot;: 1, &quot;amount_cents&quot;: 2500}]}</code></p>\n<h4 id=\"usage-event-processing-flow\">Usage Event Processing Flow</h4>\n<p>Usage events flow through several processing stages to ensure accuracy and performance in high-volume scenarios. This pipeline architecture supports real-time ingestion while maintaining billing accuracy.</p>\n<p><img src=\"/api/project/subscription-billing/architecture-doc/asset?path=diagrams%2Fusage-aggregation-flow.svg\" alt=\"Usage Event Processing and Aggregation\"></p>\n<ol>\n<li><p><strong>Event Ingestion</strong>: Client systems submit usage events via API with idempotency keys. Events are validated for required fields, reasonable quantities, and timestamp constraints.</p>\n</li>\n<li><p><strong>Deduplication</strong>: The system checks <code>idempotency_key</code> and <code>customer_id</code> combinations to prevent duplicate events. Duplicate submissions return the original event ID without creating new records.</p>\n</li>\n<li><p><strong>Temporal Assignment</strong>: Events are assigned to billing periods based on the customer&#39;s subscription billing cycle, not calendar months. This ensures usage aligns with subscription billing boundaries.</p>\n</li>\n<li><p><strong>Aggregation</strong>: Background processes periodically aggregate events into usage totals, updating the <code>aggregated</code> flag to prevent double-counting in future runs.</p>\n</li>\n<li><p><strong>Billing Calculation</strong>: During invoice generation, usage aggregations are converted to billable amounts using current plan pricing. This separation allows for plan changes without re-processing historical events.</p>\n</li>\n<li><p><strong>Audit and Reconciliation</strong>: Usage totals are validated against event counts and quantities to detect processing errors or data corruption.</p>\n</li>\n</ol>\n<h4 id=\"common-usage-tracking-pitfalls\">Common Usage Tracking Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Clock Skew in Event Timestamps</strong>\nWhen client systems report usage events with their local timestamps, clock differences can cause events to appear in the wrong billing period. This leads to usage being credited to the wrong invoice.</p>\n<p><em>Why it&#39;s wrong</em>: A client system with a fast clock might report usage events with timestamps in the next billing period, causing them to be excluded from the current invoice.</p>\n<p><em>How to fix</em>: Use server-side processing timestamps for billing period assignment while preserving client timestamps for audit purposes. Implement reasonable timestamp validation to reject events with timestamps too far in the future or past.</p>\n<p>⚠️ <strong>Pitfall: Aggregation Boundary Errors</strong>\nIncorrect billing period boundaries can cause usage to be split across multiple invoices or excluded entirely. This is especially problematic for subscriptions with non-standard billing anchors.</p>\n<p><em>Why it&#39;s wrong</em>: Using calendar month boundaries instead of subscription-specific billing periods causes usage to be prorated incorrectly or appear on the wrong invoice.</p>\n<p><em>How to fix</em>: Calculate billing periods using the subscription&#39;s <code>billing_cycle_anchor</code> and <code>current_period_start</code>/<code>current_period_end</code> dates. Store the computed billing period with each event to avoid recalculation errors.</p>\n<p>⚠️ <strong>Pitfall: Usage Tier Calculation Errors</strong>\nComplex pricing tiers can be implemented incorrectly, leading to overcharges or undercharges. Tiered pricing (each tier priced separately) is often confused with volume pricing (single rate based on total usage).</p>\n<p><em>Why it&#39;s wrong</em>: Applying a single rate to total usage instead of calculating each tier separately can dramatically overcharge customers in higher usage tiers.</p>\n<p><em>How to fix</em>: Implement tier calculations that iterate through each pricing tier, calculating charges for usage within that tier&#39;s range, and sum the results. Store the tier breakdown for transparency and debugging.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides the foundational code structure and starter implementations for the core data model. The focus is on creating robust, type-safe implementations that prevent common billing errors.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database</td>\n<td>PostgreSQL with SQLAlchemy ORM</td>\n<td>PostgreSQL with async SQLAlchemy + connection pooling</td>\n</tr>\n<tr>\n<td>Money Handling</td>\n<td>Custom Money class with Decimal</td>\n<td>Money library (py-money) with currency validation</td>\n</tr>\n<tr>\n<td>UUID Generation</td>\n<td>uuid.uuid4()</td>\n<td>shortuuid for human-readable IDs</td>\n</tr>\n<tr>\n<td>Timestamp Handling</td>\n<td>datetime with UTC timezone</td>\n<td>pendulum library for robust datetime operations</td>\n</tr>\n<tr>\n<td>JSON Validation</td>\n<td>Manual validation</td>\n<td>Pydantic models for structured JSON fields</td>\n</tr>\n<tr>\n<td>Database Migrations</td>\n<td>Alembic (included with SQLAlchemy)</td>\n<td>Alembic with custom migration templates</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>subscription-billing/\n├── src/\n│   ├── models/\n│   │   ├── __init__.py           ← Export all entities\n│   │   ├── base.py               ← Base model with common fields\n│   │   ├── customer.py           ← Customer entity and related models\n│   │   ├── plan.py               ← Plan and pricing models\n│   │   ├── subscription.py       ← Subscription lifecycle models\n│   │   ├── invoice.py            ← Invoice and line item models\n│   │   ├── payment.py            ← Payment tracking models\n│   │   └── usage.py              ← Usage tracking models\n│   ├── types/\n│   │   ├── __init__.py\n│   │   ├── money.py              ← Money type with currency handling\n│   │   ├── enums.py              ← All system enums\n│   │   └── audit.py              ← Audit event types and logging\n│   ├── database/\n│   │   ├── __init__.py\n│   │   ├── connection.py         ← Database connection management\n│   │   └── migrations/           ← Alembic migration files\n│   └── config/\n│       ├── __init__.py\n│       └── settings.py           ← Database and system configuration\n├── tests/\n│   ├── test_models/              ← Unit tests for each entity\n│   └── test_integration/         ← Database integration tests\n└── requirements.txt</code></pre></div>\n\n<h4 id=\"core-types-implementation\">Core Types Implementation</h4>\n<p><strong>Complete Money Type Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/types/money.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal, </span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Currency configuration with precision and display information</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">any</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'USD'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'US Dollar'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'$'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'EUR'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Euro'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'€'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'GBP'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'British Pound'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'£'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'JPY'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Japanese Yen'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'¥'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_CURRENCY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'USD'</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DECIMAL_PRECISION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#9ECBFF\">'0.01'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Immutable money type that stores amounts in smallest currency unit (cents)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    to avoid floating-point precision errors in financial calculations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, amount_cents: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, currency_code: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> currency_code </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unsupported currency: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">currency_code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> amount_cents</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> currency_code.upper()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_decimal</span><span style=\"color:#E1E4E8\">(cls, amount: Decimal, currency: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create Money instance from decimal amount (e.g., 19.99 USD).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Rounds to appropriate precision for the currency.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currency_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">[currency.upper()]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        decimal_places </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> currency_info[</span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Convert to smallest unit (e.g., cents for USD)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        multiplier </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\"> decimal_places)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        amount_cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">((amount </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> multiplier).quantize(Decimal(</span><span style=\"color:#9ECBFF\">'1'</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">rounding</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(amount_cents, currency)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_decimal</span><span style=\"color:#E1E4E8\">(self) -> Decimal:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Convert to decimal representation (e.g., 1999 cents -> 19.99).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currency_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        decimal_places </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> currency_info[</span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        divisor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\"> decimal_places)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> divisor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __add__</span><span style=\"color:#E1E4E8\">(self, other: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.currency_code:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cannot add different currencies\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Money(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> other.amount_cents, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __sub__</span><span style=\"color:#E1E4E8\">(self, other: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.currency_code:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cannot subtract different currencies\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Money(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> other.amount_cents, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __eq__</span><span style=\"color:#E1E4E8\">(self, other: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.amount_cents </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.currency_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __repr__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Money(</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.amount_cents</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, '</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.currency_code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">')\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currency_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        symbol </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> currency_info[</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        amount </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.to_decimal()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">symbol</span><span style=\"color:#79B8FF\">}{</span><span style=\"color:#E1E4E8\">amount</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p><strong>Enum Definitions:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/types/enums.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SubscriptionStatus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TRIAL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"trial\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ACTIVE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"active\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAST_DUE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"past_due\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CANCELLED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"cancelled\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EXPIRED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"expired\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PlanStatus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ACTIVE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"active\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEPRECATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"deprecated\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ARCHIVED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"archived\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PricingModel</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FLAT_RATE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"flat_rate\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PER_SEAT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"per_seat\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TIERED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"tiered\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    VOLUME</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"volume\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BillingInterval</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MONTHLY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"monthly\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    QUARTERLY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"quarterly\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ANNUAL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"annual\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvoiceStatus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DRAFT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"draft\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OPEN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"open\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"paid\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    VOID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"void\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UNCOLLECTIBLE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"uncollectible\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PaymentStatus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PENDING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"pending\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUCCEEDED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"succeeded\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FAILED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"failed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CANCELLED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"cancelled\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    REFUNDED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"refunded\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuditEventType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUBSCRIPTION_CREATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription_created\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUBSCRIPTION_CANCELLED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription_cancelled\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PLAN_CHANGED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"plan_changed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVOICE_GENERATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"invoice_generated\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAYMENT_PROCESSED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"payment_processed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    USAGE_RECORDED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"usage_recorded\"</span></span></code></pre></div>\n\n<p><strong>Database Connection Management:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/database/connection.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> create_engine, event</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy.ext.declarative </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> declarative_base</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy.orm </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sessionmaker, Session</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> contextlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Generator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Database isolation levels for financial operations</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ISOLATION_LEVEL_SERIALIZABLE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"SERIALIZABLE\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DatabaseManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, connection_string: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.connection_string </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> connection_string</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.engine </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_engine(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            connection_string,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            echo</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">os.getenv(</span><span style=\"color:#9ECBFF\">\"DEBUG_SQL\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"false\"</span><span style=\"color:#E1E4E8\">).lower() </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"true\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            pool_pre_ping</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># Validate connections before use</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            pool_recycle</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">3600</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#6A737D\"># Refresh connections hourly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.SessionLocal </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sessionmaker(</span><span style=\"color:#FFAB70\">bind</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.engine)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> transaction</span><span style=\"color:#E1E4E8\">(self, isolation_level: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> ISOLATION_LEVEL_SERIALIZABLE</span><span style=\"color:#E1E4E8\">) -> Generator[Session, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Provide database transaction with specified isolation level.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Financial operations should use SERIALIZABLE to prevent race conditions.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        session </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.SessionLocal()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        session.connection(</span><span style=\"color:#FFAB70\">execution_options</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"isolation_level\"</span><span style=\"color:#E1E4E8\">: isolation_level})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            yield</span><span style=\"color:#E1E4E8\"> session</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            session.commit()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            session.rollback()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        finally</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            session.close()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Base model with common fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">Base </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> declarative_base()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Global database manager instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">db_manager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DatabaseManager(os.getenv(</span><span style=\"color:#9ECBFF\">\"DATABASE_URL\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"postgresql://localhost/billing\"</span><span style=\"color:#E1E4E8\">))</span></span></code></pre></div>\n\n<p><strong>Base Model with Audit Trail:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/models/base.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Column, DateTime, String, Text</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy.dialects.postgresql </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> UUID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">JSONB</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy.sql </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> func</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> database.connection </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Base</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> types.audit </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> AuditEventType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BaseModel</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Base</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    __abstract__ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Common fields for all entities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_at </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(DateTime(</span><span style=\"color:#FFAB70\">timezone</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">server_default</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">func.now(), </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    updated_at </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(DateTime(</span><span style=\"color:#FFAB70\">timezone</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">server_default</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">func.now(), </span><span style=\"color:#FFAB70\">onupdate</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">func.now(), </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metadata </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(</span><span style=\"color:#79B8FF\">JSONB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> log_event</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event_type: AuditEventType,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entity_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entity_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    changes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    actor_id: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metadata: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Record audit trail event for billing operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This is a placeholder - implement with your audit logging system.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    audit_record </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"event_type\"</span><span style=\"color:#E1E4E8\">: event_type.value,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"entity_id\"</span><span style=\"color:#E1E4E8\">: entity_id,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"entity_type\"</span><span style=\"color:#E1E4E8\">: entity_type,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"changes\"</span><span style=\"color:#E1E4E8\">: changes,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"actor_id\"</span><span style=\"color:#E1E4E8\">: actor_id,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"metadata\"</span><span style=\"color:#E1E4E8\">: metadata </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"timestamp\"</span><span style=\"color:#E1E4E8\">: datetime.utcnow().isoformat(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement actual audit logging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Options: database table, external audit service, structured logs</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"AUDIT: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">audit_record</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"core-entity-skeletons\">Core Entity Skeletons</h4>\n<p><strong>Customer Model:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/models/customer.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Column, String, Integer, Boolean</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy.dialects.postgresql </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> UUID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">JSONB</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> models.base </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BaseModel</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> types.enums </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> AccountStatus</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Customer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BaseModel</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    __tablename__ </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'customers'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    customer_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(UUID(</span><span style=\"color:#FFAB70\">as_uuid</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">primary_key</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">uuid.uuid4)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    external_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(String(</span><span style=\"color:#79B8FF\">255</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">unique</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    email </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(String(</span><span style=\"color:#79B8FF\">255</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">index</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(String(</span><span style=\"color:#79B8FF\">255</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement billing address as structured JSON</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    billing_address </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(</span><span style=\"color:#79B8FF\">JSONB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add tax_id field with validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tax_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(String(</span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currency </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(String(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'USD'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    credit_balance_cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(Integer, </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Integrate with payment gateway for payment method storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payment_method_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(String(</span><span style=\"color:#79B8FF\">255</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    billing_email </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(String(</span><span style=\"color:#79B8FF\">255</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    account_status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(String(</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'active'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> apply_credit</span><span style=\"color:#E1E4E8\">(self, amount_cents: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Add credit to customer balance. Used for refunds and downgrades.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate amount is positive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Log credit application event</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Update credit_balance_cents</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> consume_credit</span><span style=\"color:#E1E4E8\">(self, amount_cents: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Apply available credit to reduce invoice amount.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns amount of credit actually applied.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate available credit to apply (min of requested and available)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Update credit balance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Log credit consumption event</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return amount applied</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Plan Model:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/models/plan.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Column, String, Integer, Text, Boolean</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy.dialects.postgresql </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> UUID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">JSONB</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> models.base </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BaseModel</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> types.enums </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PlanStatus, BillingInterval, PricingModel</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Plan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BaseModel</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    __tablename__ </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'plans'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(UUID(</span><span style=\"color:#FFAB70\">as_uuid</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">primary_key</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">uuid.uuid4)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan_code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(String(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">unique</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(String(</span><span style=\"color:#79B8FF\">255</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    description </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(Text, </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(String(</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">PlanStatus.</span><span style=\"color:#79B8FF\">ACTIVE</span><span style=\"color:#E1E4E8\">.value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    billing_interval </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(String(</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    billing_interval_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(Integer, </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pricing_model </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(String(</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    base_price_cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(Integer, </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currency </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(String(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'USD'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    trial_period_days </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(Integer, </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    setup_fee_cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(Integer, </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Structured data for features and pricing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    features </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(</span><span style=\"color:#79B8FF\">JSONB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    usage_limits </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(</span><span style=\"color:#79B8FF\">JSONB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pricing_tiers </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Column(</span><span style=\"color:#79B8FF\">JSONB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">nullable</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> calculate_usage_charge</span><span style=\"color:#E1E4E8\">(self, usage_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, quantity: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Calculate charges for usage beyond plan limits.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns charge amount in cents.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Get usage limit for this usage_type from usage_limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate overage quantity (usage - limit)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Apply tiered pricing from pricing_tiers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return total charge in cents</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> has_feature</span><span style=\"color:#E1E4E8\">(self, feature_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Check if plan includes specified feature.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check if feature_name exists in features list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_available_for_signup</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Check if plan can be used for new subscriptions.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return True only if status is ACTIVE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Checkpoint 1: Basic Entity Creation</strong>\nAfter implementing the core entities, verify the data model works correctly:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run basic model tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_models/</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test money type operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from src.types.money import Money</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from decimal import Decimal</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\"># Create money instances</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">usd_19_99 = Money.from_decimal(Decimal('19.99'), 'USD')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">usd_5_00 = Money.from_decimal(Decimal('5.00'), 'USD')</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\"># Test arithmetic</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">total = usd_19_99 + usd_5_00</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(f'Total: {total}')  # Should print: </span><span style=\"color:#E1E4E8\">$24</span><span style=\"color:#9ECBFF\">.99</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\"># Test precision</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">cents_1999 = Money(1999, 'USD')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(f'From cents: {cents_1999}')  # Should print: </span><span style=\"color:#E1E4E8\">$19</span><span style=\"color:#9ECBFF\">.99</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p>Expected output shows proper money arithmetic without precision errors.</p>\n<p><strong>Checkpoint 2: Database Schema Creation</strong>\nVerify the database schema generates correctly:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Generate migration for core entities</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">alembic</span><span style=\"color:#9ECBFF\"> revision</span><span style=\"color:#79B8FF\"> --autogenerate</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> \"Add core billing entities\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Apply migration</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">alembic</span><span style=\"color:#9ECBFF\"> upgrade</span><span style=\"color:#9ECBFF\"> head</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify tables were created</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">psql</span><span style=\"color:#E1E4E8\"> $DATABASE_URL </span><span style=\"color:#79B8FF\">-c</span><span style=\"color:#9ECBFF\"> \"\\dt\"</span></span></code></pre></div>\n\n<p>You should see tables for customers, plans, subscriptions, invoices, invoice_line_items, payments, usage_events, usage_aggregations, and usage_billing.</p>\n<p><strong>Checkpoint 3: Entity Relationship Validation</strong>\nTest that foreign key relationships work correctly:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test script to verify relationships</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Customer, Plan, Subscription</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.database.connection </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> db_manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.types.money </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Money</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">with</span><span style=\"color:#E1E4E8\"> db_manager.transaction() </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> session:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Create test customer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    customer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Customer(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        email</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"test@example.com\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"Test Customer\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        currency</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"USD\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    session.add(customer)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Create test plan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Plan(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        plan_code</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"test-monthly\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"Test Monthly Plan\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        billing_interval</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"monthly\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        pricing_model</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"flat_rate\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        base_price_cents</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1999</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># $19.99</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        currency</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"USD\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    session.add(plan)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    session.flush()  </span><span style=\"color:#6A737D\"># Get IDs before creating subscription</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Create subscription linking customer and plan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subscription </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Subscription(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        customer_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">customer.customer_id,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        plan_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">plan.plan_id,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        status</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"active\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    session.add(subscription)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ Successfully created related entities\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p>This checkpoint confirms that the core data model supports the relationships needed for subscription billing workflows.</p>\n<h2 id=\"plan-management-component\">Plan Management Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (Plans &amp; Pricing) - implements flexible pricing plans with tiers, features, and currencies</p>\n</blockquote>\n<h3 id=\"mental-model-product-catalog-design\">Mental Model: Product Catalog Design</h3>\n<p>Think of plan management like designing a product catalog for a large retail chain. Just as a store needs a master catalog that defines each product&#39;s price, features, and availability across different locations, a subscription system needs a plan catalog that defines pricing models, feature entitlements, and billing terms across different customer segments.</p>\n<p>Consider how Apple manages its iPhone product line. They maintain multiple models (iPhone 15, iPhone 15 Pro, iPhone 15 Pro Max) with different storage tiers (128GB, 256GB, 512GB, 1TB). Each combination has a specific price point and set of features. When Apple releases the iPhone 16, they don&#39;t delete the iPhone 15 from existence - existing customers keep their devices and support contracts. Similarly, when you deprecate a subscription plan, existing subscribers must be &quot;grandfathered&quot; into their original terms.</p>\n<p>The catalog also defines what features each product tier unlocks. An iPhone 15 Pro includes features that the base iPhone 15 doesn&#39;t have (ProRAW photography, macro lens, etc.). In subscription systems, this translates to feature entitlements - a Premium plan might include API access limits of 10,000 requests per month, while a Basic plan only allows 1,000 requests.</p>\n<p>Just as retailers need to handle currency conversion for international customers (a $999 iPhone costs €1,129 in Europe due to taxes and exchange rates), subscription plans must support multiple currencies with appropriate regional pricing. The key insight is that you&#39;re not just storing prices - you&#39;re building a comprehensive product management system that governs what customers can access and how much they pay.</p>\n<h3 id=\"pricing-model-implementation\">Pricing Model Implementation</h3>\n<p>The plan management system must support three fundamental pricing models, each serving different business use cases and customer preferences. Understanding these models is crucial because each requires different calculation logic, validation rules, and upgrade/downgrade behavior.</p>\n<p><strong>Flat-Rate Pricing</strong> represents the simplest subscription model where customers pay a fixed amount regardless of usage. Think of Netflix&#39;s monthly subscription - whether you watch one movie or fifty, you pay the same $15.99. This model provides predictable revenue for the business and predictable costs for customers. The implementation stores a single <code>base_price_cents</code> value per plan, and billing calculations are straightforward multiplication based on the billing interval.</p>\n<p><strong>Tiered Pricing</strong> creates multiple usage brackets with different rates per bracket, similar to progressive tax systems. Consider a cloud storage service where the first 100GB costs $5, the next 400GB costs $0.03 per GB, and anything beyond 500GB costs $0.02 per GB. A customer using 750GB would pay: $5 (first tier) + $12 (400GB × $0.03) + $5 (250GB × $0.02) = $22 total. Each usage unit is charged at the rate of its respective tier.</p>\n<p><strong>Volume Pricing</strong> applies a single rate to the entire usage amount based on which tier the total usage falls into. Using the same cloud storage example, if a customer uses 750GB, they would pay the entire 750GB at the $0.02 rate (since they&#39;re in the highest tier), resulting in a $15 charge. This model rewards higher usage with better rates across all consumption.</p>\n<p>The distinction between tiered and volume pricing is critical and frequently misunderstood. Tiered pricing charges each bracket separately (like tax brackets), while volume pricing applies one rate to the entire amount (like bulk discounts). The Plan entity must clearly specify which model applies to avoid billing errors.</p>\n<table>\n<thead>\n<tr>\n<th>Pricing Model</th>\n<th>Description</th>\n<th>Calculation Method</th>\n<th>Use Case Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Flat-Rate</td>\n<td>Fixed charge per billing period</td>\n<td><code>base_price_cents × billing_periods</code></td>\n<td>Netflix subscription</td>\n</tr>\n<tr>\n<td>Tiered</td>\n<td>Different rates per usage bracket</td>\n<td>Sum of (bracket_usage × bracket_rate)</td>\n<td>Progressive API pricing</td>\n</tr>\n<tr>\n<td>Volume</td>\n<td>Single rate based on total usage tier</td>\n<td><code>total_usage × applicable_tier_rate</code></td>\n<td>Bulk storage discounts</td>\n</tr>\n</tbody></table>\n<p><strong>Feature Entitlements</strong> represent what capabilities each plan unlocks for subscribers. Unlike pricing, which determines charges, entitlements determine access control throughout your application. A plan defines both what a customer pays and what they can do.</p>\n<p>Feature entitlements should be designed as a flexible key-value system where each plan maps to a set of feature flags and their corresponding limits. For example, a &quot;Starter&quot; plan might include <code>api_requests_per_month: 1000</code>, <code>max_team_members: 5</code>, <code>advanced_analytics: false</code>, while a &quot;Professional&quot; plan might include <code>api_requests_per_month: 10000</code>, <code>max_team_members: 25</code>, <code>advanced_analytics: true</code>.</p>\n<p>The Plan entity structure must accommodate all these pricing models while maintaining clarity about which model applies:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>plan_id</code></td>\n<td>UUID</td>\n<td>Unique identifier for the plan</td>\n</tr>\n<tr>\n<td><code>plan_code</code></td>\n<td>str</td>\n<td>Human-readable code (e.g., &quot;starter-monthly&quot;)</td>\n</tr>\n<tr>\n<td><code>name</code></td>\n<td>str</td>\n<td>Display name (e.g., &quot;Starter Plan&quot;)</td>\n</tr>\n<tr>\n<td><code>description</code></td>\n<td>str</td>\n<td>Marketing description of the plan</td>\n</tr>\n<tr>\n<td><code>billing_interval</code></td>\n<td>str</td>\n<td>Frequency of charges (monthly, yearly, quarterly)</td>\n</tr>\n<tr>\n<td><code>pricing_model</code></td>\n<td>str</td>\n<td>Type of pricing (flat_rate, tiered, volume)</td>\n</tr>\n<tr>\n<td><code>base_price_cents</code></td>\n<td>int</td>\n<td>Base price in smallest currency unit</td>\n</tr>\n<tr>\n<td><code>currency</code></td>\n<td>str</td>\n<td>Currency code (USD, EUR, GBP)</td>\n</tr>\n<tr>\n<td><code>trial_period_days</code></td>\n<td>int</td>\n<td>Number of free trial days (0 if no trial)</td>\n</tr>\n<tr>\n<td><code>feature_entitlements</code></td>\n<td>JSON</td>\n<td>Key-value mapping of features to limits</td>\n</tr>\n<tr>\n<td><code>pricing_tiers</code></td>\n<td>JSON</td>\n<td>Array of tier definitions for tiered/volume pricing</td>\n</tr>\n<tr>\n<td><code>is_active</code></td>\n<td>bool</td>\n<td>Whether new subscriptions can use this plan</td>\n</tr>\n<tr>\n<td><code>created_at</code></td>\n<td>timestamp</td>\n<td>Plan creation time</td>\n</tr>\n<tr>\n<td><code>deprecated_at</code></td>\n<td>timestamp</td>\n<td>When plan was deprecated (null if active)</td>\n</tr>\n</tbody></table>\n<p>The <code>pricing_tiers</code> field for tiered and volume pricing contains an array of tier objects:</p>\n<table>\n<thead>\n<tr>\n<th>Tier Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>tier_number</code></td>\n<td>int</td>\n<td>Order of the tier (1, 2, 3, etc.)</td>\n</tr>\n<tr>\n<td><code>min_quantity</code></td>\n<td>int</td>\n<td>Minimum usage for this tier</td>\n</tr>\n<tr>\n<td><code>max_quantity</code></td>\n<td>int</td>\n<td>Maximum usage for this tier (null for unlimited)</td>\n</tr>\n<tr>\n<td><code>price_per_unit_cents</code></td>\n<td>int</td>\n<td>Cost per unit in this tier</td>\n</tr>\n<tr>\n<td><code>flat_fee_cents</code></td>\n<td>int</td>\n<td>Fixed fee for entering this tier</td>\n</tr>\n</tbody></table>\n<h3 id=\"adr-plan-versioning-strategy\">ADR: Plan Versioning Strategy</h3>\n<blockquote>\n<p><strong>Decision: Immutable Plan Versioning with Grandfathering</strong></p>\n<ul>\n<li><p><strong>Context</strong>: When businesses need to change plan pricing or features, they face a dilemma. Updating existing plans affects current subscribers, potentially violating their original agreement or creating customer dissatisfaction. However, maintaining multiple plan versions creates complexity in the system and administrative overhead.</p>\n</li>\n<li><p><strong>Options Considered</strong>: </p>\n<ol>\n<li>Mutable plans with forced migrations</li>\n<li>Plan versioning with optional migrations  </li>\n<li>Immutable plans with grandfathering</li>\n</ol>\n</li>\n<li><p><strong>Decision</strong>: Implement immutable plan versioning where plan changes create new versions, and existing subscribers remain on their original plan version unless they explicitly choose to migrate.</p>\n</li>\n<li><p><strong>Rationale</strong>: This approach honors existing customer agreements while allowing business flexibility to adjust pricing and features for new customers. It prevents unexpected billing changes that could damage customer relationships and ensures legal compliance with subscription terms.</p>\n</li>\n<li><p><strong>Consequences</strong>: Increases system complexity as multiple plan versions must be maintained. Customer support must understand which customers are on which plan versions. Reporting and analytics become more complex when aggregating across plan versions.</p>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Mutable Plans</td>\n<td>Simple data model, single plan per type</td>\n<td>Breaks existing customer agreements, potential legal issues</td>\n</tr>\n<tr>\n<td>Optional Migrations</td>\n<td>Balanced approach, customer choice</td>\n<td>Complex migration logic, unclear customer experience</td>\n</tr>\n<tr>\n<td>Immutable Versioning</td>\n<td>Honors agreements, clear audit trail</td>\n<td>Multiple versions to maintain, complex reporting</td>\n</tr>\n</tbody></table>\n<p>The immutable versioning strategy requires extending the Plan entity to support version tracking. When a plan needs modification, the system creates a new plan record with an incremented version number, marking the previous version as deprecated for new subscriptions while keeping it available for existing subscribers.</p>\n<p><strong>Plan Version Management</strong> introduces additional fields to track the relationship between plan versions:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>plan_family_id</code></td>\n<td>UUID</td>\n<td>Groups all versions of the same logical plan</td>\n</tr>\n<tr>\n<td><code>version_number</code></td>\n<td>int</td>\n<td>Sequential version within the plan family</td>\n</tr>\n<tr>\n<td><code>supersedes_plan_id</code></td>\n<td>UUID</td>\n<td>Previous version this plan replaces</td>\n</tr>\n<tr>\n<td><code>migration_eligible</code></td>\n<td>bool</td>\n<td>Whether existing subscribers can upgrade to this version</td>\n</tr>\n<tr>\n<td><code>migration_incentive</code></td>\n<td>JSON</td>\n<td>Special offers for customers who migrate</td>\n</tr>\n</tbody></table>\n<p>The plan family concept allows grouping related plan versions while maintaining clear lineage. For example, all versions of the &quot;Professional Plan&quot; share the same <code>plan_family_id</code> but have different <code>version_number</code> values. This enables reporting across all Professional subscribers while maintaining version-specific billing logic.</p>\n<p><strong>Grandfathering Rules</strong> define how existing subscribers interact with plan changes:</p>\n<ol>\n<li><strong>Price Protection</strong>: Existing subscribers maintain their original pricing unless they voluntarily change plans</li>\n<li><strong>Feature Evolution</strong>: New features may be added to all versions of a plan family, but existing features cannot be removed</li>\n<li><strong>Billing Interval Lock</strong>: Subscribers cannot be forced to change from monthly to yearly billing or vice versa</li>\n<li><strong>Migration Windows</strong>: When offering upgrades, provide limited-time migration opportunities with clear terms</li>\n</ol>\n<h3 id=\"common-pitfalls-in-plan-management\">Common Pitfalls in Plan Management</h3>\n<p>⚠️ <strong>Pitfall: Currency Float Arithmetic</strong>\nUsing floating-point arithmetic for currency calculations introduces rounding errors that accumulate over many transactions. A plan priced at $9.99 might be stored as 9.989999... internally, leading to billing discrepancies. Always store prices as integers in the smallest currency unit (cents for USD, pence for GBP). Use the <code>Money</code> type consistently throughout the system and convert to decimal representation only for display purposes.</p>\n<p>⚠️ <strong>Pitfall: Plan Deletion Instead of Deprecation</strong>\nDeleting old plans breaks the referential integrity of existing subscriptions and makes historical reporting impossible. Instead of deletion, mark plans as deprecated with a timestamp. Deprecated plans should not be available for new subscriptions but must remain queryable for existing subscribers. This maintains data consistency and supports customer service inquiries about historical billing.</p>\n<p>⚠️ <strong>Pitfall: Inconsistent Feature Entitlement Checking</strong>\nChecking subscription status (<code>active</code>) instead of plan features (<code>has_feature</code>) leads to incorrect access control. An active subscription to a Basic plan should not grant access to Premium features, even if the subscription is current on payments. Always check the specific feature entitlement rather than subscription status alone. This prevents feature access bugs and ensures proper plan enforcement.</p>\n<p>⚠️ <strong>Pitfall: Timezone-Naive Billing Intervals</strong>\nStoring billing intervals as simple strings like &quot;monthly&quot; without considering timezone effects creates ambiguity about when billing occurs. A customer in Tokyo subscribing on January 31st might have their billing date shift unexpectedly due to timezone calculations. Store billing anchor dates as UTC timestamps and perform timezone conversion only for display purposes.</p>\n<p>⚠️ <strong>Pitfall: Hard-Coded Feature Lists</strong>\nEmbedding feature names directly in application code makes plan management inflexible and requires code deployments to add new features. Instead, use a dynamic feature entitlement system where plans reference configurable feature keys. This allows business users to create new plans and modify feature access without engineering involvement.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Plan Storage</td>\n<td>SQLite with JSON columns</td>\n<td>PostgreSQL with JSONB indexing</td>\n</tr>\n<tr>\n<td>Feature Flags</td>\n<td>Simple key-value in plan JSON</td>\n<td>Redis with feature flag service</td>\n</tr>\n<tr>\n<td>Currency Handling</td>\n<td>Python Decimal with hardcoded rates</td>\n<td>Integration with currency exchange API</td>\n</tr>\n<tr>\n<td>Plan Validation</td>\n<td>Pydantic models with basic validation</td>\n<td>Marshmallow with custom business rules</td>\n</tr>\n<tr>\n<td>Caching</td>\n<td>In-memory Python dict</td>\n<td>Redis with TTL-based invalidation</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>subscription_system/\n  core/\n    models/\n      plan.py              ← Plan entity and validation\n      money.py             ← Money type and currency handling\n    services/\n      plan_service.py      ← Plan management business logic\n      feature_service.py   ← Feature entitlement checking\n    repositories/\n      plan_repository.py   ← Plan data access layer\n  api/\n    plan_api.py           ← REST endpoints for plan management\n  migrations/\n    001_create_plans.sql  ← Database schema creation\n  tests/\n    test_plan_models.py   ← Unit tests for plan logic\n    test_plan_service.py  ← Service layer tests</code></pre></div>\n\n<p><strong>Infrastructure Starter Code</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># core/models/money.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal, </span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'USD'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'$'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'US Dollar'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'EUR'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'€'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Euro'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'GBP'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'£'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'British Pound'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'JPY'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'¥'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'name'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Japanese Yen'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_CURRENCY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'USD'</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DECIMAL_PRECISION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#9ECBFF\">'0.01'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a monetary amount with currency, stored as integer cents.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, amount_cents: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, currency_code: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> currency_code </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unsupported currency: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">currency_code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> amount_cents</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> currency_code</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_decimal</span><span style=\"color:#E1E4E8\">(cls, amount: Decimal, currency: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create Money from decimal amount, converting to cents.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> currency </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unsupported currency: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">currency</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        decimal_places </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">[currency][</span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        multiplier </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\"> decimal_places)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        amount_cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(amount.quantize(</span><span style=\"color:#79B8FF\">DECIMAL_PRECISION</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rounding</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> multiplier)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(amount_cents, currency)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_decimal</span><span style=\"color:#E1E4E8\">(self) -> Decimal:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert Money to decimal representation for display.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        decimal_places </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code][</span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        divisor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\"> decimal_places)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> divisor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __add__</span><span style=\"color:#E1E4E8\">(self, other: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.currency_code:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cannot add different currencies\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Money(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> other.amount_cents, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        symbol </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code][</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">symbol</span><span style=\"color:#79B8FF\">}{self</span><span style=\"color:#E1E4E8\">.to_decimal()</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># core/models/plan.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> uuid </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> UUID</span><span style=\"color:#E1E4E8\">, uuid4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PricingModel</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FLAT_RATE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"flat_rate\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TIERED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"tiered\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    VOLUME</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"volume\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BillingInterval</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MONTHLY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"monthly\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    YEARLY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"yearly\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    QUARTERLY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"quarterly\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PricingTier</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a single tier in tiered or volume pricing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tier_number: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    min_quantity: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_quantity: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># None for unlimited</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    price_per_unit_cents: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flat_fee_cents: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Plan</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Core plan entity with pricing and feature information.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">uuid4)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan_code: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    description: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    billing_interval: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> BillingInterval.</span><span style=\"color:#79B8FF\">MONTHLY</span><span style=\"color:#E1E4E8\">.value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pricing_model: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> PricingModel.</span><span style=\"color:#79B8FF\">FLAT_RATE</span><span style=\"color:#E1E4E8\">.value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    base_price_cents: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currency: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> DEFAULT_CURRENCY</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    trial_period_days: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    feature_entitlements: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pricing_tiers: List[PricingTier] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_active: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    plan_family_id: Optional[</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    version_number: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    supersedes_plan_id: Optional[</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    migration_eligible: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_at: datetime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">datetime.utcnow)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    deprecated_at: Optional[datetime] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> has_feature</span><span style=\"color:#E1E4E8\">(self, feature_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if this plan includes the specified feature.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement feature checking logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle boolean features (return feature_entitlements.get(feature_name, False))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle numeric limits (return feature_entitlements.get(feature_name, 0) > 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Consider feature inheritance from plan family</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_feature_limit</span><span style=\"color:#E1E4E8\">(self, feature_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get the numeric limit for a feature, or None if unlimited.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Extract numeric limits from feature_entitlements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle special case of -1 or None meaning unlimited</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return 0 if feature is not included in this plan</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> calculate_base_charge</span><span style=\"color:#E1E4E8\">(self) -> Money:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Calculate the base recurring charge for this plan.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return Money object with base_price_cents and currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle case where pricing_model is not flat_rate (should return 0)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Database repository implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PlanRepository</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Data access layer for plan operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, db_manager):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> db_manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_plan</span><span style=\"color:#E1E4E8\">(self, plan: Plan) -> Plan:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create a new plan in the database.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate plan data before insertion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check for unique plan_code within plan_family</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Insert plan record with all fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle database constraints and return created plan</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_plan_by_id</span><span style=\"color:#E1E4E8\">(self, plan_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">) -> Optional[Plan]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Retrieve a plan by its ID.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Query database for plan with given ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Convert database row to Plan object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle case where plan is not found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_active_plans</span><span style=\"color:#E1E4E8\">(self) -> List[Plan]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get all plans available for new subscriptions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Query for plans where is_active = True and deprecated_at IS NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Convert database rows to Plan objects</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Order by plan_family_id and version_number</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> deprecate_plan</span><span style=\"color:#E1E4E8\">(self, plan_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Mark a plan as deprecated, preventing new subscriptions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Set deprecated_at timestamp to current time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Set is_active to False</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure existing subscriptions are not affected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return True if plan was found and updated</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># core/services/plan_service.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> uuid </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> UUID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> core.models.plan </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Plan, PricingModel, Money</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> core.repositories.plan_repository </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PlanRepository</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PlanService</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Business logic for plan management operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, plan_repo: PlanRepository):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.plan_repo </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> plan_repo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_plan_family</span><span style=\"color:#E1E4E8\">(self, plan_data: </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">) -> Plan:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create the first version of a new plan family.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate required fields (name, plan_code, pricing_model, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate new plan_family_id (same as plan_id for first version)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Set version_number to 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate pricing_model and ensure required pricing data exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create Plan object and save via repository</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return created plan</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_plan_version</span><span style=\"color:#E1E4E8\">(self, plan_family_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, updated_data: </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">) -> Plan:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create a new version of an existing plan family.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Get latest version of the plan family</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that changes warrant a new version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Increment version_number</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Set supersedes_plan_id to previous version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Deprecate previous version if specified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create and save new plan version</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> calculate_plan_charge</span><span style=\"color:#E1E4E8\">(self, plan: Plan, usage_quantity: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) -> Money:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Calculate total charge for a plan given usage quantity.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle flat_rate pricing (return base_price_cents)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle tiered pricing (sum charges across tiers)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle volume pricing (find tier and apply rate to total)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add any flat fees from pricing tiers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return Money object with calculated amount</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_plan_upgrade</span><span style=\"color:#E1E4E8\">(self, from_plan_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, to_plan_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate that a plan change is allowed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that both plans exist and are in same family OR different families</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify to_plan allows migrations (migration_eligible = True)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure currency compatibility</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check business rules (e.g., no downgrades, version restrictions)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return True if upgrade is valid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># core/services/feature_service.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FeatureService</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Service for checking feature entitlements and usage limits.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, plan_repo: PlanRepository):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.plan_repo </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> plan_repo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> check_feature_access</span><span style=\"color:#E1E4E8\">(self, plan_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, feature_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if a plan grants access to a specific feature.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Retrieve plan from repository</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Call plan.has_feature(feature_name)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle case where plan is not found (return False)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Log access check for auditing purposes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_feature_usage_limit</span><span style=\"color:#E1E4E8\">(self, plan_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, feature_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get the usage limit for a feature, or None if unlimited.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Retrieve plan from repository</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Call plan.get_feature_limit(feature_name)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle inheritance from plan family if configured</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return limit or None for unlimited access</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_feature_usage</span><span style=\"color:#E1E4E8\">(self, plan_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, feature_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, proposed_usage: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if proposed usage is within plan limits.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Get feature limit for the plan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle unlimited access (limit is None)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Compare proposed_usage against limit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return True if usage is within limits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint</strong></p>\n<p>After implementing the plan management component, verify the following functionality:</p>\n<p><strong>Test Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run unit tests for plan models and services</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_plan_models.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_plan_service.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test plan creation via API</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8000/api/plans</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -d</span><span style=\"color:#9ECBFF\"> '{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"plan_code\": \"starter-monthly\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"name\": \"Starter Plan\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"billing_interval\": \"monthly\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"base_price_cents\": 999,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"currency\": \"USD\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"feature_entitlements\": {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">      \"api_requests_per_month\": 1000,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">      \"max_team_members\": 5</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    }</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  }'</span></span></code></pre></div>\n\n<p><strong>Expected Behavior:</strong></p>\n<ol>\n<li>Plan creation should return a complete Plan object with generated <code>plan_id</code> and <code>plan_family_id</code></li>\n<li>Feature checking should correctly identify which features are included in each plan</li>\n<li>Pricing calculations should handle different pricing models accurately</li>\n<li>Plan versioning should create new versions without affecting existing plans</li>\n<li>Currency handling should maintain precision without floating-point errors</li>\n</ol>\n<p><strong>Signs of Issues:</strong></p>\n<ul>\n<li><strong>Plan creation fails</strong>: Check required field validation and database constraints</li>\n<li><strong>Currency precision errors</strong>: Verify all prices are stored as integers in cents</li>\n<li><strong>Feature access bugs</strong>: Ensure feature checking uses plan entitlements, not subscription status</li>\n<li><strong>Version conflicts</strong>: Check that plan_family_id relationships are maintained correctly</li>\n</ul>\n<h2 id=\"subscription-lifecycle-management\">Subscription Lifecycle Management</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (Subscription Lifecycle) - implements subscription creation, activation, renewal, and cancellation with appropriate state transitions and billing cycle management</p>\n</blockquote>\n<h3 id=\"mental-model-membership-lifecycle\">Mental Model: Membership Lifecycle</h3>\n<p>Think of subscription management like running a premium fitness club with sophisticated membership tiers. When someone joins your gym, they don&#39;t just pay once and disappear - they enter into an ongoing relationship with predictable patterns and lifecycle events.</p>\n<p>Consider how gym memberships work in the real world. A new member might start with a free trial week to test the facilities. During this trial, they have access to basic equipment but can&#39;t use premium services like personal training or spa facilities. If they don&#39;t cancel before the trial ends, their membership automatically converts to a paid plan - perhaps a monthly membership at $50 per month.</p>\n<p>Once they&#39;re an active paying member, several things can happen. They might upgrade to a premium plan to access the spa and personal training. They could downgrade to a basic plan if money gets tight. They might go on vacation and pause their membership for a month. Eventually, they might cancel - either immediately (forfeiting any prepaid time) or at the end of their current billing period.</p>\n<p>Throughout this lifecycle, the gym must track payment status carefully. If a member&#39;s credit card fails, they don&#39;t immediately lose access - there&#39;s a grace period where the gym tries to collect payment while the member can still use facilities. Only after multiple failed attempts does the membership move to a suspended state.</p>\n<p>This is exactly how subscription billing works. Each <strong>subscription</strong> represents an ongoing relationship between a customer and a service, with predictable state transitions, billing cycles, and lifecycle events. The subscription moves through various states (trial, active, past_due, cancelled) based on payment success, customer actions, and business rules.</p>\n<p>The key insight is that subscriptions are not just payment records - they&#39;re stateful entities that evolve over time according to business logic. Managing this lifecycle correctly ensures customers have a smooth experience while protecting business revenue through proper dunning management and retention policies.</p>\n<h3 id=\"subscription-state-machine\">Subscription State Machine</h3>\n<p>A subscription&#39;s journey follows a well-defined state machine where each state represents a distinct phase of the customer relationship. Understanding these states and their transitions is crucial for implementing reliable billing logic and providing clear customer communication.</p>\n<p>The subscription lifecycle begins when a customer selects a plan and provides payment information. Unlike simple e-commerce transactions, subscriptions must track ongoing state because the relationship extends far beyond the initial purchase. Each state change triggers specific business logic, from provisioning access to sending dunning emails.</p>\n<p><img src=\"/api/project/subscription-billing/architecture-doc/asset?path=diagrams%2Fsubscription-state-machine.svg\" alt=\"Subscription Lifecycle State Machine\"></p>\n<p>Here are the core subscription states and their business meaning:</p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th>Description</th>\n<th>Customer Access</th>\n<th>Billing Status</th>\n<th>Duration</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>incomplete</code></td>\n<td>Subscription created but payment method not yet confirmed</td>\n<td>No access</td>\n<td>Payment pending</td>\n<td>Until payment succeeds/fails</td>\n</tr>\n<tr>\n<td><code>trialing</code></td>\n<td>Free trial period active</td>\n<td>Limited access per plan</td>\n<td>No charges</td>\n<td>Until trial_end_date</td>\n</tr>\n<tr>\n<td><code>active</code></td>\n<td>Paying subscription in good standing</td>\n<td>Full access</td>\n<td>Charges successfully</td>\n<td>Until next billing event</td>\n</tr>\n<tr>\n<td><code>past_due</code></td>\n<td>Payment failed but still retrying</td>\n<td>Access per grace policy</td>\n<td>Retry attempts active</td>\n<td>Until payment succeeds or retry limit</td>\n</tr>\n<tr>\n<td><code>unpaid</code></td>\n<td>Payment retries exhausted, subscription suspended</td>\n<td>No access</td>\n<td>No further retries</td>\n<td>Until manual intervention</td>\n</tr>\n<tr>\n<td><code>cancelled</code></td>\n<td>Subscription terminated by customer or system</td>\n<td>No access (or until period_end)</td>\n<td>No future charges</td>\n<td>Permanent</td>\n</tr>\n<tr>\n<td><code>paused</code></td>\n<td>Temporarily suspended by customer request</td>\n<td>No access</td>\n<td>No charges during pause</td>\n<td>Until resume_date</td>\n</tr>\n</tbody></table>\n<p>The state transitions are governed by specific events and business rules:</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Action Taken</th>\n<th>Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>incomplete</code></td>\n<td>Payment succeeds</td>\n<td><code>active</code> or <code>trialing</code></td>\n<td>Provision access, start trial if configured</td>\n<td>Valid payment method confirmed</td>\n</tr>\n<tr>\n<td><code>incomplete</code></td>\n<td>Payment fails</td>\n<td><code>cancelled</code></td>\n<td>Send failure notification</td>\n<td>After maximum retry attempts</td>\n</tr>\n<tr>\n<td><code>trialing</code></td>\n<td>Trial expires</td>\n<td><code>active</code></td>\n<td>Charge first payment, continue service</td>\n<td>Successful payment collection</td>\n</tr>\n<tr>\n<td><code>trialing</code></td>\n<td>Trial expires</td>\n<td><code>past_due</code></td>\n<td>Start dunning process</td>\n<td>Payment collection fails</td>\n</tr>\n<tr>\n<td><code>trialing</code></td>\n<td>Customer cancels</td>\n<td><code>cancelled</code></td>\n<td>Terminate access immediately</td>\n<td>No refund due (trial was free)</td>\n</tr>\n<tr>\n<td><code>active</code></td>\n<td>Renewal payment succeeds</td>\n<td><code>active</code></td>\n<td>Extend billing period, continue access</td>\n<td>Normal billing cycle</td>\n</tr>\n<tr>\n<td><code>active</code></td>\n<td>Renewal payment fails</td>\n<td><code>past_due</code></td>\n<td>Start retry sequence, maintain access</td>\n<td>Begin grace period</td>\n</tr>\n<tr>\n<td><code>active</code></td>\n<td>Customer cancels</td>\n<td><code>cancelled</code> or <code>active</code></td>\n<td>Schedule termination</td>\n<td>Immediate vs end-of-period</td>\n</tr>\n<tr>\n<td><code>active</code></td>\n<td>Customer pauses</td>\n<td><code>paused</code></td>\n<td>Suspend access, stop billing</td>\n<td>If pause feature enabled</td>\n</tr>\n<tr>\n<td><code>past_due</code></td>\n<td>Payment succeeds</td>\n<td><code>active</code></td>\n<td>Restore full access, extend period</td>\n<td>During retry window</td>\n</tr>\n<tr>\n<td><code>past_due</code></td>\n<td>Retry limit exceeded</td>\n<td><code>unpaid</code></td>\n<td>Suspend access, stop retries</td>\n<td>After final dunning attempt</td>\n</tr>\n<tr>\n<td><code>unpaid</code></td>\n<td>Payment method updated</td>\n<td><code>active</code></td>\n<td>Charge outstanding amount, restore access</td>\n<td>Manual intervention successful</td>\n</tr>\n<tr>\n<td><code>unpaid</code></td>\n<td>Extended grace period</td>\n<td><code>cancelled</code></td>\n<td>Permanent termination</td>\n<td>Business decision to close account</td>\n</tr>\n<tr>\n<td><code>paused</code></td>\n<td>Resume requested</td>\n<td><code>active</code></td>\n<td>Restore access, resume billing</td>\n<td>Customer-initiated resume</td>\n</tr>\n<tr>\n<td><code>paused</code></td>\n<td>Resume date reached</td>\n<td><code>active</code></td>\n<td>Automatic restoration</td>\n<td>Scheduled resume</td>\n</tr>\n<tr>\n<td><code>cancelled</code></td>\n<td>Reactivation requested</td>\n<td><code>active</code></td>\n<td>Create new subscription</td>\n<td>Within reactivation window</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Design Principle</strong>: State transitions must be atomic and auditable. Every state change should be recorded with a timestamp, triggering event, and actor (system, customer, admin). This audit trail is essential for customer support, revenue recognition, and debugging billing issues.</p>\n</blockquote>\n<p>The state machine enforces important business invariants that prevent data corruption and revenue leakage:</p>\n<p><strong>Access Control Invariants</strong>: Only <code>active</code> and <code>trialing</code> subscriptions grant feature access. The <code>past_due</code> state may grant continued access during a grace period, but this must be explicitly configured per business policy.</p>\n<p><strong>Billing Invariants</strong>: Charges only occur for <code>active</code> subscriptions or when transitioning from <code>trialing</code> to <code>active</code>. Past due subscriptions do not generate new charges - they only retry collecting existing outstanding amounts.</p>\n<p><strong>Cancellation Invariants</strong>: Once a subscription reaches <code>cancelled</code> state, it cannot directly transition back to <code>active</code>. Reactivation must create a new subscription entity to maintain clear audit trails and prevent accidental billing.</p>\n<p><strong>Temporal Invariants</strong>: State transitions must respect billing cycle boundaries. For example, a cancellation with <code>at_period_end=true</code> should not immediately change state - instead, it schedules a future transition.</p>\n<h3 id=\"adr-renewal-processing-architecture\">ADR: Renewal Processing Architecture</h3>\n<p>The subscription billing system must process thousands of renewals daily with precise timing and reliable failure handling. This architectural decision determines how we schedule and execute recurring billing operations across the entire customer base.</p>\n<blockquote>\n<p><strong>Decision: Event-Driven Renewal Processing with Cron Trigger</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to process subscription renewals reliably at specific dates and times, handle failures gracefully, and support both immediate and scheduled billing operations. Traditional cron-based systems can miss renewals if the system is down, while purely event-driven systems need careful orchestration for time-based triggers.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li><strong>Pure Cron-Based Processing</strong>: Traditional scheduled jobs that query for due renewals</li>\n<li><strong>Pure Event-Driven Processing</strong>: All renewals triggered by timer events or external signals  </li>\n<li><strong>Hybrid Event-Driven with Cron Bootstrap</strong>: Cron triggers event publishing, events drive actual processing</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hybrid approach with cron-triggered event publishing and event-driven renewal processing</li>\n<li><strong>Rationale</strong>: Combines reliable scheduling with robust failure handling and clear separation of concerns between scheduling and processing logic</li>\n<li><strong>Consequences</strong>: Enables retry logic, audit trails, and distributed processing while maintaining predictable renewal timing</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pure Cron</td>\n<td>Simple implementation, predictable timing, easy debugging</td>\n<td>No retry logic, single point of failure, difficult to scale</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Pure Event-Driven</td>\n<td>Excellent failure handling, scalable, testable</td>\n<td>Complex time-based triggering, harder to ensure coverage</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Hybrid Approach</td>\n<td>Best of both worlds, robust failure handling, scalable</td>\n<td>Moderate complexity, two systems to maintain</td>\n<td>Medium</td>\n</tr>\n</tbody></table>\n<p>The hybrid architecture works through a clear separation of responsibilities:</p>\n<p><strong>Cron Scheduler Component</strong>: Runs every hour and identifies subscriptions with <code>billing_cycle_anchor</code> dates that fall within the next processing window. For each eligible subscription, it publishes a <code>BillingDueEvent</code> to the event queue with the subscription ID and intended billing date.</p>\n<p><strong>Renewal Processing Engine</strong>: Consumes <code>BillingDueEvent</code> messages and executes the actual billing logic. Each event is processed independently with full retry semantics, error handling, and transaction isolation. If processing fails, the event remains in the queue for retry with exponential backoff.</p>\n<p><strong>Idempotency Protection</strong>: Each billing event includes an idempotency key based on the subscription ID and billing period start date. This prevents duplicate charges if the same renewal is processed multiple times due to retries or system issues.</p>\n<p>The processing flow follows these steps:</p>\n<ol>\n<li><strong>Cron Query Phase</strong>: Every hour, query subscriptions where <code>next_billing_date &lt;= now() + 1 hour</code> and <code>status IN (&#39;active&#39;, &#39;trialing&#39;)</code></li>\n<li><strong>Event Publishing Phase</strong>: For each eligible subscription, publish <code>BillingDueEvent{subscription_id, billing_date, idempotency_key}</code> to the renewal queue</li>\n<li><strong>Processing Phase</strong>: Renewal workers consume events and execute billing logic within database transactions</li>\n<li><strong>Completion Phase</strong>: Update subscription&#39;s <code>next_billing_date</code> and <code>last_billing_date</code> fields, record audit events</li>\n<li><strong>Failure Handling Phase</strong>: Failed events retry with exponential backoff, with alerts after multiple failures</li>\n</ol>\n<p>This architecture provides several key benefits for subscription billing reliability:</p>\n<p><strong>Exactly-Once Processing</strong>: The combination of idempotency keys and event-driven processing ensures each billing cycle is charged exactly once, even with system failures or retries.</p>\n<p><strong>Graceful Failure Handling</strong>: Individual renewal failures don&#39;t impact other customers. Failed renewals automatically retry while successful ones proceed normally.</p>\n<p><strong>Audit Trail</strong>: Every billing event is recorded with timestamps, processing results, and failure reasons. This audit trail is crucial for customer support and financial reconciliation.</p>\n<p><strong>Horizontal Scaling</strong>: Multiple renewal workers can process events in parallel, allowing the system to scale renewal processing capacity independently from the scheduling component.</p>\n<h3 id=\"dunning-and-grace-period-policies\">Dunning and Grace Period Policies</h3>\n<p>When subscription payments fail, the system enters a carefully orchestrated dunning process designed to recover revenue while maintaining positive customer relationships. Dunning management balances aggressive payment collection with customer retention, using progressively escalating communication and access restrictions.</p>\n<p>Think of dunning like a library&#39;s approach to overdue books. The library doesn&#39;t immediately ban patrons when books are late - instead, they start with gentle email reminders, then firmer notices, and finally restrict borrowing privileges only after extended non-compliance. Throughout this process, patrons can restore good standing by simply returning books and paying modest late fees.</p>\n<p>Subscription dunning follows similar principles but with more sophisticated timing and communication strategies. The goal is to recover failed payments while preserving long-term customer value and minimizing involuntary churn.</p>\n<p><strong>Grace Period Configuration</strong>: The grace period defines how long customers retain service access after payment failure. This policy varies significantly based on business model and customer segment:</p>\n<table>\n<thead>\n<tr>\n<th>Customer Segment</th>\n<th>Grace Period</th>\n<th>Access Policy</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Enterprise Plans</td>\n<td>7-14 days</td>\n<td>Full access maintained</td>\n<td>High LTV, complex procurement processes</td>\n</tr>\n<tr>\n<td>Annual Subscribers</td>\n<td>5-7 days</td>\n<td>Full access maintained</td>\n<td>Strong commitment signal, seasonal payment issues</td>\n</tr>\n<tr>\n<td>Monthly Consumer</td>\n<td>3-5 days</td>\n<td>Limited access or full restriction</td>\n<td>Higher churn rate, faster resolution needed</td>\n</tr>\n<tr>\n<td>Trial Conversions</td>\n<td>1-2 days</td>\n<td>Immediate restriction</td>\n<td>Lower engagement, price-sensitive segment</td>\n</tr>\n</tbody></table>\n<p>During the grace period, the system implements a structured retry schedule that balances collection success with customer experience:</p>\n<p><strong>Immediate Retry (T+0)</strong>: Attempt payment collection within 1 hour of initial failure. Many payment failures are temporary (insufficient funds that resolve quickly, temporary network issues) and succeed on immediate retry.</p>\n<p><strong>Short-Term Retries (T+1 to T+3 days)</strong>: Retry payment every 24 hours during the first three days. This catches customers who need time to update payment methods or resolve banking issues.</p>\n<p><strong>Extended Retries (T+4 to T+7 days)</strong>: Retry every 48-72 hours during the extended grace period. At this point, also escalate to email and in-app notifications requesting payment method updates.</p>\n<p><strong>Final Attempt (T+7 days)</strong>: Make final payment attempt before transitioning subscription to <code>unpaid</code> status. Send clear communication about impending service suspension and provide easy payment recovery options.</p>\n<p>The dunning communication strategy escalates in tone and urgency while maintaining professional, helpful messaging:</p>\n<table>\n<thead>\n<tr>\n<th>Retry Attempt</th>\n<th>Communication Type</th>\n<th>Message Tone</th>\n<th>Call-to-Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1st Failure</td>\n<td>Email notification</td>\n<td>Informational</td>\n<td>&quot;Update payment method&quot;</td>\n</tr>\n<tr>\n<td>2nd Attempt</td>\n<td>Email + In-app banner</td>\n<td>Concerned</td>\n<td>&quot;Avoid service interruption&quot;</td>\n</tr>\n<tr>\n<td>3rd Attempt</td>\n<td>Email + Account restriction</td>\n<td>Urgent</td>\n<td>&quot;Immediate action required&quot;</td>\n</tr>\n<tr>\n<td>Final Notice</td>\n<td>Email + SMS (if enabled)</td>\n<td>Final warning</td>\n<td>&quot;Service suspended in 24 hours&quot;</td>\n</tr>\n</tbody></table>\n<p><strong>Smart Retry Logic</strong>: Modern dunning systems implement intelligent retry timing based on failure codes from payment processors. Different failure types suggest different retry strategies:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Insufficient Funds (decline_code: insufficient_funds):\n  - Retry after 3 days (payday timing)\n  - Retry after 7 days (next payday)\n  - Higher success rate on Fridays and first of month\n\nCard Expired (decline_code: expired_card):\n  - Immediate retry (customer may have updated)\n  - Email notification to update payment method\n  - No point in automatic retries without customer action\n\nNetwork Error (decline_code: processing_error):\n  - Immediate retry\n  - Retry after 1 hour\n  - Treat as temporary technical issue</code></pre></div>\n\n<p><strong>Revenue Recovery Optimization</strong>: Effective dunning processes can recover 15-40% of initially failed payments through strategic timing and communication. The key metrics to track include:</p>\n<ul>\n<li><strong>Recovery Rate</strong>: Percentage of failed payments ultimately collected during dunning period</li>\n<li><strong>Recovery Time</strong>: Average days between failure and successful collection  </li>\n<li><strong>Involuntary Churn Rate</strong>: Percentage of customers lost due to payment failures (vs voluntary cancellations)</li>\n<li><strong>Customer Satisfaction</strong>: Support ticket volume and satisfaction scores during dunning periods</li>\n</ul>\n<p><strong>Dunning Automation Rules</strong>: The system should automatically adjust dunning behavior based on customer history and payment patterns:</p>\n<p><strong>Good Payment History</strong>: Customers with 12+ months of successful payments receive extended grace periods and gentler communication, recognizing that payment failures are likely temporary issues rather than inability to pay.</p>\n<p><strong>New Customers</strong>: Recent subscribers receive accelerated dunning with proactive support outreach, as payment failures often indicate setup issues rather than financial problems.</p>\n<p><strong>High-Value Customers</strong>: Accounts with high monthly values or annual contracts trigger immediate human intervention alongside automated dunning, ensuring personalized support for revenue-critical relationships.</p>\n<blockquote>\n<p><strong>Dunning Best Practice</strong>: Always provide customers with clear self-service options to resolve payment issues. Include direct links to update payment methods, view current balances, and contact support. Many customers want to resolve payment issues quickly but need easy paths to do so.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The subscription lifecycle management system requires careful coordination between state management, payment processing, and customer communication. This implementation guidance provides the foundational code structure and core logic patterns needed to build reliable subscription billing.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>State Machine</td>\n<td>Enum + switch statements</td>\n<td>State pattern with transition validation</td>\n<td>Start simple, refactor as complexity grows</td>\n</tr>\n<tr>\n<td>Background Jobs</td>\n<td>APScheduler (Python)</td>\n<td>Celery + Redis</td>\n<td>APScheduler sufficient for moderate scale</td>\n</tr>\n<tr>\n<td>Event Queue</td>\n<td>Database table + polling</td>\n<td>Redis/RabbitMQ message queue</td>\n<td>Database approach simpler for MVP</td>\n</tr>\n<tr>\n<td>Retry Logic</td>\n<td>Custom exponential backoff</td>\n<td>Tenacity library</td>\n<td>Tenacity provides robust retry patterns</td>\n</tr>\n<tr>\n<td>Audit Logging</td>\n<td>Structured logging to files</td>\n<td>Centralized logging (ELK stack)</td>\n<td>File logging adequate for single instance</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended Project Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>subscription_billing/\n  subscription/\n    __init__.py\n    models.py              # Subscription entity and state definitions\n    lifecycle.py           # State machine and transition logic\n    renewal_processor.py   # Billing cycle processing\n    dunning_manager.py     # Failed payment handling\n    state_machine.py       # State transition validation\n  billing/\n    invoice_generator.py   # Invoice creation (next section)\n    payment_processor.py   # Payment gateway integration\n  events/\n    __init__.py\n    event_publisher.py     # Event publishing infrastructure\n    handlers.py            # Event handlers for lifecycle events\n  jobs/\n    __init__.py\n    renewal_scheduler.py   # Cron job for identifying due renewals\n    dunning_scheduler.py   # Scheduled dunning operations</code></pre></div>\n\n<p><strong>Core Infrastructure - Event System:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> uuid </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> UUID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SubscriptionEventType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CREATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription.created\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ACTIVATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription.activated\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RENEWED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription.renewed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAYMENT_FAILED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription.payment_failed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CANCELLED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription.cancelled\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAUSED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription.paused\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RESUMED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription.resumed\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SubscriptionEvent</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, event_type: SubscriptionEventType, subscription_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any], idempotency_key: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.event_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> UUID</span><span style=\"color:#E1E4E8\">.generate()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.event_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> event_type</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.subscription_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> subscription_id</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.idempotency_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> idempotency_key </span><span style=\"color:#F97583\">or</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">subscription_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">_</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">event_type.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">_</span><span style=\"color:#79B8FF\">{int</span><span style=\"color:#E1E4E8\">(datetime.utcnow().timestamp())</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.created_at </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> datetime.utcnow()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EventPublisher</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, database_manager: DatabaseManager):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> database_manager</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> publish</span><span style=\"color:#E1E4E8\">(self, event: SubscriptionEvent) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Publish event to event store with idempotency protection\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.db.transaction(</span><span style=\"color:#79B8FF\">ISOLATION_LEVEL_SERIALIZABLE</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Check for duplicate events</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            existing </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.db.execute(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"SELECT event_id FROM subscription_events WHERE idempotency_key = </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                (event.idempotency_key,)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ).fetchone()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> existing:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.logger.info(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Duplicate event </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">event.idempotency_key</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> ignored\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Insert new event</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.db.execute(</span><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                INSERT INTO subscription_events (event_id, event_type, subscription_id, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                                               data, idempotency_key, created_at)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                VALUES (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"\"\"</span><span style=\"color:#E1E4E8\">, (event.event_id, event.event_type.value, event.subscription_id,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  json.dumps(event.data), event.idempotency_key, event.created_at))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span></code></pre></div>\n\n<p><strong>Core Infrastructure - Audit Logging:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuditEventType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUBSCRIPTION_STATE_CHANGE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription.state_change\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAYMENT_ATTEMPT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"payment.attempt\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BILLING_CYCLE_PROCESSED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"billing.cycle_processed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DUNNING_ACTION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"dunning.action\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuditEvent</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event_type: AuditEventType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entity_id: </span><span style=\"color:#79B8FF\">UUID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entity_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    changes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    actor_id: Optional[</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metadata: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: datetime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuditLogger</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, database_manager: DatabaseManager):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> database_manager</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> log_event</span><span style=\"color:#E1E4E8\">(self, event_type: AuditEventType, entity_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  entity_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, changes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  actor_id: Optional[</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  metadata: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record audit event for compliance and debugging\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        audit_event </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> AuditEvent(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            event_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">event_type,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            entity_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">entity_id, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            entity_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">entity_type,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            changes</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">changes,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            actor_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">actor_id,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            metadata</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">metadata </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {},</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            timestamp</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">datetime.utcnow()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.db.transaction(</span><span style=\"color:#79B8FF\">ISOLATION_LEVEL_SERIALIZABLE</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.db.execute(</span><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                INSERT INTO audit_log (event_type, entity_id, entity_type, changes,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                                     actor_id, metadata, timestamp)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                VALUES (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"\"\"</span><span style=\"color:#E1E4E8\">, (audit_event.event_type.value, audit_event.entity_id,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  audit_event.entity_type, json.dumps(audit_event.changes),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  audit_event.actor_id, json.dumps(audit_event.metadata),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  audit_event.timestamp))</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton - Subscription Lifecycle Manager:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SubscriptionStatus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INCOMPLETE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"incomplete\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TRIALING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"trialing\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ACTIVE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"active\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAST_DUE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"past_due\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UNPAID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"unpaid\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CANCELLED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"cancelled\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAUSED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"paused\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SubscriptionLifecycleManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, database_manager: DatabaseManager, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 event_publisher: EventPublisher,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 audit_logger: AuditLogger):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> database_manager</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.events </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> event_publisher</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.audit </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> audit_logger</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_subscription</span><span style=\"color:#E1E4E8\">(self, customer_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, plan_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          payment_method_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, trial_end_date: Optional[datetime] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Subscription:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create new subscription for customer with specified plan\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.db.transaction(</span><span style=\"color:#79B8FF\">ISOLATION_LEVEL_SERIALIZABLE</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load plan details to determine trial period and billing interval</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Calculate billing_cycle_anchor based on plan interval (monthly = day of month, yearly = day of year)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Set initial status (trialing if trial period, incomplete if payment setup needed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Calculate next_billing_date based on trial_end_date or immediate billing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Insert subscription record with all calculated fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Publish SUBSCRIPTION_CREATED event with plan and customer details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Log audit event for subscription creation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Return created subscription object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> transition_state</span><span style=\"color:#E1E4E8\">(self, subscription_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, new_status: SubscriptionStatus, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        reason: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, actor_id: Optional[</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Transition subscription to new state with validation and audit trail\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.db.transaction(</span><span style=\"color:#79B8FF\">ISOLATION_LEVEL_SERIALIZABLE</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load current subscription with row-level lock (SELECT FOR UPDATE)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate state transition is allowed (use transition matrix)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Update subscription status and transition timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Record state change in audit log with old/new status and reason  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Publish appropriate event based on new state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Execute state-specific side effects (provision access, send notifications)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Use a transition validation table to check current_state -> new_state is valid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_renewal</span><span style=\"color:#E1E4E8\">(self, subscription_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, billing_date: datetime, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       idempotency_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process recurring billing for active subscription\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.db.transaction(</span><span style=\"color:#79B8FF\">ISOLATION_LEVEL_SERIALIZABLE</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check idempotency - return True if already processed this billing cycle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Load subscription and verify it's in renewable state (active, trialing)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate billing period (start_date = last_billing_date, end_date = next_billing_date)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Generate invoice for base plan charges (delegate to invoice generator)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Attempt payment collection (delegate to payment processor)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle payment result - update next_billing_date if successful, start dunning if failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Update subscription's last_billing_date and billing cycle count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Publish SUBSCRIPTION_RENEWED event with billing details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Use idempotency_key = f\"{subscription_id}_{billing_date.strftime('%Y-%m-%d')}\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> cancel_subscription</span><span style=\"color:#E1E4E8\">(self, subscription_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, cancel_at_period_end: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          reason: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"customer_request\"</span><span style=\"color:#E1E4E8\">, actor_id: Optional[</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Cancel subscription immediately or at end of current billing period\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.db.transaction(</span><span style=\"color:#79B8FF\">ISOLATION_LEVEL_SERIALIZABLE</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load subscription and verify it's cancellable (not already cancelled)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If cancel_at_period_end=False, transition to cancelled immediately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If cancel_at_period_end=True, set cancelled_at = current_period_end, keep status active</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Record cancellation reason and schedule termination job if needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Publish SUBSCRIPTION_CANCELLED event with cancellation details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Log audit event with cancellation reason and effective date</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Use a separate cancelled_at field rather than changing status immediately</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton - Dunning Manager:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DunningAction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RETRY_PAYMENT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"retry_payment\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SEND_EMAIL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"send_email\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RESTRICT_ACCESS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"restrict_access\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUSPEND_SUBSCRIPTION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"suspend_subscription\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DunningManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, database_manager: DatabaseManager,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 payment_processor: PaymentProcessor,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 notification_service: NotificationService):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> database_manager</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.payment_processor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> payment_processor</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.notifications </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> notification_service</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_payment_failure</span><span style=\"color:#E1E4E8\">(self, subscription_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, invoice_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              failure_reason: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Initialize dunning process for failed payment\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.db.transaction(</span><span style=\"color:#79B8FF\">ISOLATION_LEVEL_SERIALIZABLE</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Transition subscription to past_due status if currently active</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create dunning_attempts record with failure details and retry schedule</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Schedule immediate retry attempt (many failures are temporary)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Send initial payment failure notification to customer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Log audit event for dunning process start</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Store retry_count and next_retry_date in dunning_attempts table</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_dunning_retry</span><span style=\"color:#E1E4E8\">(self, subscription_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute scheduled dunning retry attempt\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.db.transaction(</span><span style=\"color:#79B8FF\">ISOLATION_LEVEL_SERIALIZABLE</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load subscription and outstanding invoice details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check if still within dunning window (not exceeded max retry count)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Attempt payment collection using stored payment method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If successful: transition to active, clear dunning state, extend billing period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If failed: increment retry count, schedule next attempt with backoff</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If retry limit exceeded: transition to unpaid status, suspend access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Send appropriate notification based on retry result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Log audit event for dunning attempt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Use exponential backoff - day 1, 3, 7, 14 for retry timing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> calculate_next_retry_date</span><span style=\"color:#E1E4E8\">(self, retry_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, last_attempt: datetime) -> datetime:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Calculate next retry date using exponential backoff with jitter\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Define base retry intervals [1, 3, 7, 14] days for attempts 1-4</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add random jitter (±2 hours) to prevent thundering herd</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Respect business hours - schedule retries during 9AM-5PM customer timezone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return calculated datetime for next retry attempt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use random.uniform(-2, 2) for jitter in hours</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing the subscription lifecycle management:</p>\n<ol>\n<li><p><strong>Unit Test Coverage</strong>: Run <code>python -m pytest subscription/test_lifecycle.py -v</code> and verify:</p>\n<ul>\n<li>All state transitions are validated correctly</li>\n<li>Renewal processing handles idempotency </li>\n<li>Dunning retries follow exponential backoff</li>\n<li>Audit events are created for all state changes</li>\n</ul>\n</li>\n<li><p><strong>Integration Test</strong>: Create a test subscription and verify:</p>\n<ul>\n<li>New subscription starts in correct state (trialing or active)</li>\n<li>Trial expiration triggers billing attempt</li>\n<li>Payment failures initiate dunning process</li>\n<li>Successful dunning recovery restores active status</li>\n<li>Cancellation respects at_period_end setting</li>\n</ul>\n</li>\n<li><p><strong>Manual Verification</strong>: </p>\n<ul>\n<li>Check database - subscription state changes should have corresponding audit_log entries</li>\n<li>Verify idempotency - processing the same renewal twice should not create duplicate charges</li>\n<li>Test dunning - failed payments should schedule retry attempts with correct timing</li>\n</ul>\n</li>\n</ol>\n<p><strong>Common Issues and Debugging:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Duplicate renewals</td>\n<td>Missing idempotency check</td>\n<td>Check subscription_events table for duplicate idempotency_key</td>\n<td>Add unique constraint on idempotency_key</td>\n</tr>\n<tr>\n<td>State transitions fail</td>\n<td>Invalid transition attempted</td>\n<td>Check audit_log for rejected transitions</td>\n<td>Add transition validation matrix</td>\n</tr>\n<tr>\n<td>Dunning not triggering</td>\n<td>Cron job not running or query incorrect</td>\n<td>Check dunning_attempts table creation</td>\n<td>Verify scheduler configuration and SQL query</td>\n</tr>\n<tr>\n<td>Payment retries too aggressive</td>\n<td>Incorrect backoff calculation</td>\n<td>Log retry_count and next_retry_date</td>\n<td>Implement exponential backoff correctly</td>\n</tr>\n</tbody></table>\n<h2 id=\"proration-and-plan-changes\">Proration and Plan Changes</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (Proration &amp; Plan Changes) - implements upgrade/downgrade with prorated charges and credits for mid-cycle plan changes</p>\n</blockquote>\n<h3 id=\"mental-model-partial-refunds-and-charges\">Mental Model: Partial Refunds and Charges</h3>\n<p>Think of proration like your monthly gym membership that you upgrade mid-month from Basic ($30) to Premium ($60). When you upgrade on day 15 of a 30-day billing cycle, you&#39;ve already paid for the full month of Basic service, but now you want Premium for the remaining 15 days. The gym needs to figure out: &quot;How much extra should we charge for the upgrade?&quot; They calculate that you used half your Basic membership (15 days worth = $15), so you have $15 of unused Basic time. Premium costs $60, so for 15 days it&#39;s $30. The additional charge is $30 - $15 = $15.</p>\n<p>This same logic applies when you downgrade. If you switch from Premium to Basic mid-cycle, you&#39;ve overpaid and deserve a credit for the difference. The gym calculates how much Premium time you have left, converts it to Basic pricing, and either refunds the difference or applies it as credit to your account.</p>\n<p><strong>Proration</strong> is this fair calculation system that ensures customers pay exactly for what they use, even when they change plans mid-cycle. It prevents both customer frustration (&quot;Why am I paying for features I&#39;m not using?&quot;) and business revenue leakage (&quot;Why are we giving away premium features for basic pricing?&quot;).</p>\n<p>The mathematical challenge is handling edge cases: What happens during February with 28 days when your billing cycle started on a 31-day month? What about timezone differences when a customer upgrades at 11:59 PM? How do you round fractions of cents fairly across thousands of customers? These details can make or break the fairness and accuracy of your billing system.</p>\n<p><img src=\"/api/project/subscription-billing/architecture-doc/asset?path=diagrams%2Fplan-change-flow.svg\" alt=\"Plan Change and Proration Flow\"></p>\n<h3 id=\"proration-calculation-algorithms\">Proration Calculation Algorithms</h3>\n<p>Proration calculations form the mathematical foundation for fair billing when customers change their subscription plans mid-cycle. The core principle is proportional allocation: customers should pay for exactly the service they receive, regardless of when they make changes during their billing period.</p>\n<h4 id=\"time-based-proration-formula\">Time-Based Proration Formula</h4>\n<p>Time-based proration calculates charges based on the remaining days in the current billing cycle. This is the most common proration method for subscription billing systems.</p>\n<table>\n<thead>\n<tr>\n<th>Variable</th>\n<th>Description</th>\n<th>Example Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>days_remaining</code></td>\n<td>Days left in current billing cycle</td>\n<td>15</td>\n</tr>\n<tr>\n<td><code>total_cycle_days</code></td>\n<td>Total days in current billing period</td>\n<td>30</td>\n</tr>\n<tr>\n<td><code>old_plan_price</code></td>\n<td>Monthly price of current plan</td>\n<td>$30.00</td>\n</tr>\n<tr>\n<td><code>new_plan_price</code></td>\n<td>Monthly price of target plan</td>\n<td>$60.00</td>\n</tr>\n<tr>\n<td><code>usage_factor</code></td>\n<td>Fraction of cycle remaining</td>\n<td>0.5 (15/30)</td>\n</tr>\n</tbody></table>\n<p>The proration algorithm follows these steps:</p>\n<ol>\n<li><p><strong>Calculate the usage factor</strong> by dividing remaining days by total cycle days. This gives the proportion of the billing cycle that will use the new plan.</p>\n</li>\n<li><p><strong>Determine unused value from the old plan</strong> by multiplying the old plan price by the usage factor. This represents the monetary value of service time the customer has already paid for but won&#39;t receive.</p>\n</li>\n<li><p><strong>Calculate new plan cost for remaining period</strong> by multiplying the new plan price by the usage factor. This represents the cost of providing the new service level for the remaining time.</p>\n</li>\n<li><p><strong>Compute the proration amount</strong> as the difference between new plan cost and unused old plan value. Positive values indicate additional charges; negative values indicate credits owed.</p>\n</li>\n<li><p><strong>Handle currency precision</strong> by rounding to the smallest currency unit (cents) using consistent rounding rules across all calculations.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Key Insight</strong>: The proration calculation must be deterministic and repeatable. Running the same calculation multiple times with identical inputs must always produce the same result, even if processed days apart.</p>\n</blockquote>\n<h4 id=\"quantity-based-proration-formula\">Quantity-Based Proration Formula</h4>\n<p>Quantity-based proration applies when plan changes involve user seats, storage limits, or other measurable quantities rather than time periods.</p>\n<table>\n<thead>\n<tr>\n<th>Variable</th>\n<th>Description</th>\n<th>Example Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>old_quantity</code></td>\n<td>Current quantity (seats, GB, etc.)</td>\n<td>5 seats</td>\n</tr>\n<tr>\n<td><code>new_quantity</code></td>\n<td>Target quantity after change</td>\n<td>8 seats</td>\n</tr>\n<tr>\n<td><code>unit_price</code></td>\n<td>Price per unit for remaining period</td>\n<td>$10/seat</td>\n</tr>\n<tr>\n<td><code>days_remaining</code></td>\n<td>Days left in billing cycle</td>\n<td>15</td>\n</tr>\n<tr>\n<td><code>total_cycle_days</code></td>\n<td>Total days in billing period</td>\n<td>30</td>\n</tr>\n</tbody></table>\n<p>Quantity-based proration follows this algorithm:</p>\n<ol>\n<li><p><strong>Calculate the quantity difference</strong> between new and old quantities. This determines how many additional units require billing.</p>\n</li>\n<li><p><strong>Determine the time factor</strong> using the same method as time-based proration (remaining days divided by total cycle days).</p>\n</li>\n<li><p><strong>Calculate unit cost for remaining period</strong> by multiplying the unit price by the time factor.</p>\n</li>\n<li><p><strong>Compute total proration charge</strong> by multiplying the quantity difference by the unit cost for the remaining period.</p>\n</li>\n<li><p><strong>Apply minimum and maximum quantity constraints</strong> as defined by the plan rules to ensure the change is within allowed boundaries.</p>\n</li>\n</ol>\n<h4 id=\"combined-proration-scenarios\">Combined Proration Scenarios</h4>\n<p>Real-world plan changes often involve both time and quantity adjustments simultaneously. For example, upgrading from a Basic plan (5 seats, $50/month) to a Professional plan (unlimited seats, $100/month) mid-cycle requires calculating both the base plan change and any quantity adjustments.</p>\n<p>The combined algorithm processes these changes in sequence:</p>\n<ol>\n<li><p><strong>Calculate base plan proration</strong> using time-based formulas for the plan-level pricing difference.</p>\n</li>\n<li><p><strong>Calculate quantity adjustments</strong> using quantity-based formulas for any seat or limit changes.</p>\n</li>\n<li><p><strong>Sum all proration components</strong> to determine the total adjustment amount.</p>\n</li>\n<li><p><strong>Validate the total amount</strong> against business rules such as maximum single-transaction limits or credit balance caps.</p>\n</li>\n</ol>\n<h4 id=\"currency-and-precision-handling\">Currency and Precision Handling</h4>\n<p>Proration calculations must maintain financial precision to prevent accumulated errors across thousands of transactions. The system stores all monetary values in the smallest currency unit (cents for USD) and performs all calculations using integer arithmetic.</p>\n<table>\n<thead>\n<tr>\n<th>Precision Rule</th>\n<th>Description</th>\n<th>Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Currency Storage</td>\n<td>Store amounts as integers in smallest unit</td>\n<td><code>amount_cents: int</code></td>\n</tr>\n<tr>\n<td>Division Rounding</td>\n<td>Use consistent rounding for fractional cents</td>\n<td>Round half up (0.5 → 1)</td>\n</tr>\n<tr>\n<td>Calculation Order</td>\n<td>Perform multiplication before division</td>\n<td><code>(price * days) / total_days</code></td>\n</tr>\n<tr>\n<td>Result Validation</td>\n<td>Verify totals match expected ranges</td>\n<td>Check against plan min/max prices</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Warning</strong>: Floating-point arithmetic can introduce rounding errors that accumulate across many customers. Always use integer arithmetic with the smallest currency unit to maintain exact precision in financial calculations.</p>\n</blockquote>\n<h3 id=\"adr-credit-balance-management\">ADR: Credit Balance Management</h3>\n<blockquote>\n<p><strong>Decision: Customer Credit Balance Architecture</strong></p>\n<p><strong>Context</strong>: When customers downgrade plans or receive refunds from proration calculations, the system must decide how to handle credit amounts. Credits could be applied immediately to reduce current invoices, stored as account balance for future use, or processed as direct refunds to the customer&#39;s payment method.</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Immediate Credit Application</strong>: Credits automatically reduce the next invoice amount</li>\n<li><strong>Account Credit Balance</strong>: Credits accumulate in customer account for flexible future use</li>\n<li><strong>Direct Refund Processing</strong>: Credits trigger immediate refunds to original payment method</li>\n</ol>\n<p><strong>Decision</strong>: Implement account credit balance with automatic application to future invoices</p>\n<p><strong>Rationale</strong>: Account credit balances provide the optimal balance between customer flexibility and operational simplicity. Immediate application works only when invoices are pending, missing opportunities for mid-cycle credits. Direct refunds create payment processing overhead and potential fraud concerns with frequent small refunds. Account balances handle all timing scenarios while maintaining customer transparency.</p>\n<p><strong>Consequences</strong>: Requires additional database storage for credit tracking, audit trail for credit movements, and customer portal visibility into credit balance. Enables superior customer experience with flexible credit usage and simplified customer service operations.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Immediate Credit Application</td>\n<td>Simple implementation, no additional storage</td>\n<td>Only works with pending invoices, loses mid-cycle credits</td>\n</tr>\n<tr>\n<td>Account Credit Balance</td>\n<td>Flexible timing, handles all scenarios, customer-friendly</td>\n<td>Requires credit management system, additional complexity</td>\n</tr>\n<tr>\n<td>Direct Refund Processing</td>\n<td>Immediate customer satisfaction, clean accounting</td>\n<td>Payment processing fees, fraud risks, operational overhead</td>\n</tr>\n</tbody></table>\n<p>The credit balance architecture implements these components:</p>\n<p><strong>Credit Balance Storage</strong>: Each <code>Customer</code> entity includes a <code>credit_balance_cents</code> field that tracks the accumulated credit amount. This balance persists across billing cycles and plan changes, providing continuity for customers with varying usage patterns.</p>\n<p><strong>Credit Transaction Logging</strong>: Every credit application, whether from proration calculations, manual adjustments, or promotional offers, generates an <code>AuditEvent</code> record with complete transaction details. This creates an immutable audit trail for financial reconciliation and customer service inquiries.</p>\n<p><strong>Automatic Credit Application</strong>: During invoice generation, the billing engine automatically applies available credit balance to reduce the invoice total. Credits apply before payment processing, reducing the amount charged to the customer&#39;s payment method.</p>\n<p><strong>Credit Balance Limits</strong>: The system enforces maximum credit balance limits per customer to prevent abuse and manage financial exposure. Excess credits beyond the limit trigger alternative handling such as direct refunds or promotional extensions.</p>\n<h4 id=\"credit-application-algorithm\">Credit Application Algorithm</h4>\n<p>The credit application process follows these steps during invoice generation:</p>\n<ol>\n<li><p><strong>Retrieve customer credit balance</strong> from the database with row-level locking to prevent concurrent modifications during the application process.</p>\n</li>\n<li><p><strong>Calculate applicable credit amount</strong> as the minimum of available credit balance and outstanding invoice amount. This ensures credits never create negative invoice totals.</p>\n</li>\n<li><p><strong>Update customer credit balance</strong> by subtracting the applied amount using atomic database operations to maintain consistency.</p>\n</li>\n<li><p><strong>Apply credit to invoice</strong> by adding a credit line item that reduces the total amount due before payment processing.</p>\n</li>\n<li><p><strong>Log credit application transaction</strong> with complete details for audit trail and customer visibility.</p>\n</li>\n<li><p><strong>Handle remaining balance</strong> by either charging the customer for any remaining invoice amount or noting full payment via credit if the balance covers the entire invoice.</p>\n</li>\n</ol>\n<h3 id=\"common-proration-pitfalls\">Common Proration Pitfalls</h3>\n<p>Proration calculations contain numerous edge cases that can cause billing errors, customer complaints, and revenue discrepancies. Understanding these pitfalls helps developers build robust billing systems that handle real-world complexity gracefully.</p>\n<h4 id=\"-pitfall-calendar-month-variations\">⚠️ <strong>Pitfall: Calendar Month Variations</strong></h4>\n<p><strong>Description</strong>: Calculating proration based on &quot;days in month&quot; without considering calendar variations leads to inconsistent billing amounts. A customer who upgrades on January 15th (31-day month) receives different proration than one who upgrades on February 15th (28-day month), even though both upgrade mid-cycle.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Customers expect consistent proration logic regardless of calendar quirks. Variable month lengths create apparent unfairness where identical timing produces different charges.</p>\n<p><strong>How to Fix</strong>: Use billing cycle anchor dates rather than calendar months. If a customer&#39;s billing cycle runs from the 15th to the 14th each month, always calculate proration based on that specific cycle period, regardless of underlying calendar days.</p>\n<h4 id=\"-pitfall-timezone-confusion-in-proration-timing\">⚠️ <strong>Pitfall: Timezone Confusion in Proration Timing</strong></h4>\n<p><strong>Description</strong>: Using server timezone or customer timezone inconsistently when determining proration effective dates. A customer who upgrades at 11:59 PM in their timezone might be processed as upgrading the next day in server timezone, affecting proration calculations.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Proration amounts can change significantly based on which day the system considers the &quot;upgrade date.&quot; This creates unpredictable billing behavior and customer service issues.</p>\n<p><strong>How to Fix</strong>: Always use the customer&#39;s account timezone for billing calculations and store the timezone-aware timestamp with each plan change event. Convert to UTC for database storage but perform all billing logic in customer timezone.</p>\n<h4 id=\"-pitfall-double-counting-credits-during-multiple-plan-changes\">⚠️ <strong>Pitfall: Double-Counting Credits During Multiple Plan Changes</strong></h4>\n<p><strong>Description</strong>: When customers make multiple plan changes within a single billing cycle, each change calculation might include credits from previous changes, leading to compound credit errors.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Customers receive excessive credits that reduce revenue and create accounting discrepancies. Multiple plan changes should calculate proration based on actual service periods, not overlapping credit calculations.</p>\n<p><strong>How to Fix</strong>: Track plan change effective dates precisely and calculate proration only for the actual service period under each plan. Use a sequential approach where each plan change starts from the effective date of the previous change.</p>\n<h4 id=\"-pitfall-rounding-errors-accumulating-across-customers\">⚠️ <strong>Pitfall: Rounding Errors Accumulating Across Customers</strong></h4>\n<p><strong>Description</strong>: Inconsistent rounding of fractional cents across proration calculations creates systematic bias that can add up to significant amounts across thousands of customers.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Even small rounding inconsistencies can result in meaningful revenue differences when applied across a large customer base. Regulatory and accounting requirements demand consistent financial precision.</p>\n<p><strong>How to Fix</strong>: Implement standardized rounding rules (typically &quot;round half up&quot; for financial calculations) and apply them consistently across all proration scenarios. Document the rounding approach and verify it meets local financial regulations.</p>\n<h4 id=\"-pitfall-proration-on-trial-periods\">⚠️ <strong>Pitfall: Proration on Trial Periods</strong></h4>\n<p><strong>Description</strong>: Applying proration calculations to customers who are still in trial periods, especially when trials have zero cost. The system might attempt to calculate credits or charges for &quot;upgrading&quot; from a free trial.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Trial periods should not generate proration charges since customers haven&#39;t paid for the trial service. Proration logic designed for paid plans doesn&#39;t apply to trial scenarios.</p>\n<p><strong>How to Fix</strong>: Check subscription status before applying proration logic. For trial subscriptions, treat plan changes as immediate switches without proration. Begin proration calculations only after the trial period ends and paid billing begins.</p>\n<h4 id=\"-pitfall-currency-conversion-during-proration\">⚠️ <strong>Pitfall: Currency Conversion During Proration</strong></h4>\n<p><strong>Description</strong>: Performing currency conversion before or during proration calculations when customers change plans that involve different currencies. Exchange rate fluctuations can affect proration accuracy.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Currency conversion rates change continuously, making proration calculations non-deterministic. The same plan change processed at different times might yield different amounts due to exchange rate variations.</p>\n<p><strong>How to Fix</strong>: Perform all proration calculations in the customer&#39;s account currency without conversion. If plan changes involve currency switches, treat them as separate operations: complete proration in the original currency, then apply the currency change for future billing cycles.</p>\n<h4 id=\"-pitfall-negative-credit-balances\">⚠️ <strong>Pitfall: Negative Credit Balances</strong></h4>\n<p><strong>Description</strong>: Allowing customer credit balances to become negative due to calculation errors, failed credit applications, or manual adjustments without proper validation.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Negative credit balances represent debt owed by customers but tracked in the credit system rather than through normal invoice processes. This creates accounting confusion and collection challenges.</p>\n<p><strong>How to Fix</strong>: Implement credit balance constraints that prevent negative values. When operations would result in negative credits, handle them through the regular billing process by generating invoices for the additional amounts owed.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The proration and credit management system requires careful implementation to handle the mathematical complexity and edge cases inherent in mid-cycle billing adjustments. This implementation focuses on accuracy, auditability, and performance for high-volume billing operations.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Calculation Engine</td>\n<td>Python Decimal with basic rounding</td>\n<td>Custom financial arithmetic library</td>\n</tr>\n<tr>\n<td>Credit Storage</td>\n<td>PostgreSQL with ACID transactions</td>\n<td>Event-sourced credit ledger</td>\n</tr>\n<tr>\n<td>Currency Handling</td>\n<td>Single currency with integer cents</td>\n<td>Multi-currency with exchange rate API</td>\n</tr>\n<tr>\n<td>Audit Logging</td>\n<td>Database audit table</td>\n<td>Dedicated audit service with immutable log</td>\n</tr>\n<tr>\n<td>Proration Rules</td>\n<td>Static configuration in code</td>\n<td>Dynamic rule engine with business rules</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>subscription-billing/\n  src/\n    billing/\n      proration/\n        __init__.py\n        calculator.py           ← Core proration calculation engine\n        credit_manager.py       ← Customer credit balance management\n        plan_change_handler.py  ← Orchestrates plan changes with proration\n        exceptions.py           ← Proration-specific error types\n        models.py              ← Proration data structures\n      core/\n        money.py               ← Money type with currency handling\n        audit.py               ← Audit event logging\n        database.py            ← Database manager\n      tests/\n        test_proration.py      ← Proration calculation tests\n        test_credit_manager.py ← Credit management tests\n        test_plan_changes.py   ← End-to-end plan change tests</code></pre></div>\n\n<h4 id=\"core-money-and-currency-infrastructure\">Core Money and Currency Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># billing/core/money.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal, </span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DECIMAL_PRECISION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#9ECBFF\">'0.01'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_CURRENCY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'USD'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">SUPPORTED_CURRENCIES</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'USD'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'$'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'minor_unit'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'EUR'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'€'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'minor_unit'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'GBP'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'symbol'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'£'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'decimal_places'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'minor_unit'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Immutable money type that maintains financial precision.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, amount_cents: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, currency_code: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(amount_cents, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Amount must be an integer representing cents\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> currency_code </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unsupported currency: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">currency_code</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> amount_cents</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> currency_code</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_decimal</span><span style=\"color:#E1E4E8\">(cls, amount: Decimal, currency: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create Money from decimal amount with proper rounding.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> currency </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unsupported currency: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">currency</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        minor_unit </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">[currency][</span><span style=\"color:#9ECBFF\">'minor_unit'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">((amount </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> minor_unit).quantize(Decimal(</span><span style=\"color:#9ECBFF\">'1'</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(cents, currency)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_decimal</span><span style=\"color:#E1E4E8\">(self) -> Decimal:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert Money to decimal representation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        minor_unit </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> SUPPORTED_CURRENCIES</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code][</span><span style=\"color:#9ECBFF\">'minor_unit'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> minor_unit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __add__</span><span style=\"color:#E1E4E8\">(self, other: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.currency_code:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cannot add money with different currencies\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Money(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> other.amount_cents, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __sub__</span><span style=\"color:#E1E4E8\">(self, other: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.currency_code:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cannot subtract money with different currencies\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Money(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> other.amount_cents, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __mul__</span><span style=\"color:#E1E4E8\">(self, factor: Decimal) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Multiply money by decimal factor with proper rounding.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result_cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (Decimal(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> factor).quantize(Decimal(</span><span style=\"color:#9ECBFF\">'1'</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Money(</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">(result_cents), </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __eq__</span><span style=\"color:#E1E4E8\">(self, other) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(other, Money):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.amount_cents </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.currency_code)</span></span></code></pre></div>\n\n<h4 id=\"proration-calculation-engine-skeleton\">Proration Calculation Engine Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># billing/proration/calculator.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, date</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.money </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Money, </span><span style=\"color:#79B8FF\">DECIMAL_PRECISION</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ProrationResult, ProrationContext</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ProrationError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ProrationResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Result of a proration calculation with detailed breakdown.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    credit_amount: Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    charge_amount: Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    net_amount: Money  </span><span style=\"color:#6A737D\"># positive = charge, negative = credit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    calculation_details: Dict</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    effective_date: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ProrationCalculator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Calculates prorated charges and credits for plan changes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> calculate_plan_change_proration</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        old_plan: </span><span style=\"color:#9ECBFF\">'Plan'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_plan: </span><span style=\"color:#9ECBFF\">'Plan'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        change_date: datetime,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        billing_cycle_start: datetime,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        billing_cycle_end: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> ProrationResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Calculate proration for mid-cycle plan changes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            old_plan: Current subscription plan</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            new_plan: Target plan after change</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            change_date: When the change becomes effective</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            billing_cycle_start: Start of current billing period</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            billing_cycle_end: End of current billing period</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ProrationResult with charge/credit amounts and calculation details</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate that change_date falls within the current billing cycle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Raise ProrationError if change_date is outside cycle boundaries</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Calculate total days in billing cycle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Use (billing_cycle_end - billing_cycle_start).days</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Handle timezone-aware datetime objects properly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate days remaining from change_date to cycle end</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Use (billing_cycle_end - change_date).days</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Ensure result is not negative</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Calculate usage factor as Decimal(days_remaining) / Decimal(total_cycle_days)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         This represents the fraction of cycle using the new plan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Calculate unused value from old plan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         unused_value = old_plan.base_price * usage_factor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         This is credit owed for unused time on old plan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Calculate new plan cost for remaining period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         new_plan_cost = new_plan.base_price * usage_factor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         This is charge for new plan during remaining time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Calculate net proration amount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         net_amount = new_plan_cost - unused_value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Positive = customer owes money, Negative = customer gets credit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Create ProrationResult with calculated amounts and details dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Include calculation breakdown for audit trail and customer transparency</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: All Money arithmetic should use the currency from old_plan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Store intermediate calculations in calculation_details dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> calculate_quantity_proration</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        plan: </span><span style=\"color:#9ECBFF\">'Plan'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        old_quantity: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_quantity: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        change_date: datetime,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        billing_cycle_start: datetime,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        billing_cycle_end: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> ProrationResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Calculate proration for quantity changes (seats, storage, etc.).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate quantity change parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Ensure new_quantity meets plan minimum and maximum limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Verify change_date is within billing cycle</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Calculate quantity difference (new_quantity - old_quantity)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         This can be positive (increase) or negative (decrease)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate time factor using same logic as plan change proration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         time_factor = days_remaining / total_cycle_days</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Get per-unit price for the plan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Check if plan uses per-seat, per-GB, or other unit pricing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Calculate unit cost for remaining period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         unit_cost = per_unit_price * time_factor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Calculate total proration amount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         total_amount = quantity_difference * unit_cost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Create ProrationResult with quantity-based calculation details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Include unit pricing and quantity change information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"credit-balance-manager-skeleton\">Credit Balance Manager Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># billing/proration/credit_manager.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> uuid </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> UUID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.money </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Money</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.audit </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> AuditEventType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.database </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> DatabaseManager</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CreditBalanceManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages customer credit balances and applications.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, db_manager: DatabaseManager):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> db_manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> apply_credit</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        customer_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        amount: Money, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        source: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        reference_id: Optional[</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        actor_id: Optional[</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add credit to customer's account balance.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            customer_id: Customer receiving credit</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            amount: Credit amount to add</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            source: Description of credit source (e.g., \"plan_downgrade\", \"refund\")</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            reference_id: Related transaction ID for audit trail</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            actor_id: ID of user/system making the change</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if credit applied successfully</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Start database transaction with SERIALIZABLE isolation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Use self.db.transaction(ISOLATION_LEVEL_SERIALIZABLE)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Lock customer record for update to prevent concurrent modifications</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         SELECT customer credit_balance_cents FOR UPDATE WHERE customer_id = ?</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate credit amount is positive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Raise ValueError if amount is negative or zero</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Update customer credit balance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         new_balance = current_balance + credit_amount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         UPDATE customers SET credit_balance_cents = ? WHERE customer_id = ?</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create audit event for credit application</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Use AuditEventType.CREDIT_APPLIED with amount and source details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Call self.log_event() with complete transaction details</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Commit transaction and return success status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Handle database errors and rollback on failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> consume_credit</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        customer_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        amount_needed: Money,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        actor_id: Optional[</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Money:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Apply customer credit to reduce an amount owed.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            customer_id: Customer using credit</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            amount_needed: Total amount that could be reduced by credit</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            actor_id: ID of user/system applying credit</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Money representing actual credit amount applied (may be less than requested)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Start database transaction with proper isolation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Lock customer record to prevent concurrent credit usage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Get current customer credit balance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         SELECT credit_balance_cents FROM customers WHERE customer_id = ?</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate applicable credit amount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         applied_credit = min(available_credit, amount_needed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Cannot apply more credit than customer has or needs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Update customer credit balance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         new_balance = current_balance - applied_credit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Ensure balance never goes negative</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create audit event for credit consumption</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Log the credit usage with before/after balances</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return the actual credit amount applied</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         This may be less than amount_needed if insufficient credit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_credit_balance</span><span style=\"color:#E1E4E8\">(self, customer_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">) -> Money:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get current credit balance for customer.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Query customer credit balance from database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Handle case where customer doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Convert stored cents to Money object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Use customer's default currency from account settings</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"plan-change-handler-skeleton\">Plan Change Handler Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># billing/proration/plan_change_handler.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> uuid </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> UUID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .calculator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ProrationCalculator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .credit_manager </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CreditBalanceManager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.money </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Money</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ProrationError, PlanChangeError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PlanChangeHandler</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Orchestrates plan changes with proration calculations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, proration_calc: ProrationCalculator, credit_manager: CreditBalanceManager):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.proration_calc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proration_calc</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.credit_manager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> credit_manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_plan_upgrade</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        subscription_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_plan_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        effective_date: Optional[datetime] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        actor_id: Optional[</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process subscription upgrade with proration charges.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load subscription and validate current state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Ensure subscription is active and not cancelled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Verify new_plan_id exists and is available for customer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Load current and target plans</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Validate that target plan is actually an upgrade (higher tier/price)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Check plan compatibility and upgrade path rules</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Determine effective date for change</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Default to current datetime if not specified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Validate effective_date is not in the past</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Calculate proration using ProrationCalculator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Get current billing cycle boundaries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Call calculate_plan_change_proration with all parameters</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Process proration charges</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         If net_amount > 0, create invoice for additional charge</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         If net_amount &#x3C; 0, apply credit to customer account</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Update subscription with new plan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Change subscription.plan_id to new_plan_id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Record plan change event with effective date</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return plan change summary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Include proration details, new plan info, and effective date</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_plan_downgrade</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        subscription_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_plan_id: </span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        effective_date: Optional[datetime] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        actor_id: Optional[</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process subscription downgrade with proration credits.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load and validate subscription and plans similar to upgrade</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Verify new plan is actually a downgrade</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Calculate proration (will typically result in credit)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Use same ProrationCalculator.calculate_plan_change_proration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Apply credit to customer account</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Use CreditBalanceManager.apply_credit for proration amount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Record credit source as \"plan_downgrade\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle feature access changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Immediately restrict access to features not in new plan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Update feature entitlements in subscription record</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Update subscription and log downgrade event</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         Record reason for downgrade if provided</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the proration system, verify functionality with these tests:</p>\n<p><strong>Unit Tests</strong>: Run <code>python -m pytest tests/test_proration.py -v</code>\nExpected output should show all proration calculation tests passing, including edge cases for calendar months, timezone handling, and currency precision.</p>\n<p><strong>Integration Tests</strong>: Test complete plan change workflows:</p>\n<ol>\n<li>Create subscription with monthly plan ($30/month)</li>\n<li>Upgrade to premium plan ($60/month) on day 15 of 30-day cycle</li>\n<li>Verify proration charge of $15 (half month difference)</li>\n<li>Check customer credit balance remains unchanged</li>\n<li>Confirm subscription reflects new plan and features</li>\n</ol>\n<p><strong>Manual Verification</strong>:</p>\n<ul>\n<li>Use billing admin interface to trigger plan change</li>\n<li>Verify proration calculation shows detailed breakdown</li>\n<li>Confirm audit events recorded for all balance changes</li>\n<li>Test edge cases: month boundaries, leap years, timezone differences</li>\n</ul>\n<p><strong>Common Issues to Check</strong>:</p>\n<ul>\n<li>Proration amounts should always be deterministic for same inputs</li>\n<li>Currency precision should maintain cent accuracy</li>\n<li>Credit balances should never become negative without explicit business logic</li>\n<li>All plan changes should generate complete audit trails</li>\n</ul>\n<h2 id=\"usage-based-billing-engine\">Usage-Based Billing Engine</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 4 (Usage-Based Billing) - implements metered billing with usage tracking, aggregation, and reporting</p>\n</blockquote>\n<h3 id=\"mental-model-utility-metering\">Mental Model: Utility Metering</h3>\n<p>Think of usage-based billing like your electricity meter at home. Every time you turn on a light, run the dishwasher, or charge your laptop, the meter records consumption. At the end of the month, the utility company reads your meter, calculates your total usage, applies their tiered pricing structure (first 500 kWh at $0.10, next 500 kWh at $0.12, etc.), and generates your bill.</p>\n<p>The usage-based billing engine works exactly the same way. Instead of measuring kilowatt-hours, we might be measuring API calls, storage gigabytes, or video transcoding minutes. Instead of a physical meter, we have software that captures usage events. Instead of a meter reader visiting your house, we have automated aggregation processes that sum up consumption. And instead of utility rate schedules, we have pricing tiers defined in our subscription plans.</p>\n<p>Just like utility billing, the key challenges are accuracy (every usage event must be counted exactly once), timing (usage must be attributed to the correct billing period), and pricing complexity (different rates for different usage levels). The meter never lies, and neither should our usage tracking system.</p>\n<p>This mental model helps us understand why certain architectural decisions matter. Just as utility companies need redundant meter readings and audit trails for regulatory compliance, we need idempotent event processing and complete usage records. Just as utilities batch-process millions of meter readings efficiently, we need scalable aggregation systems. And just as your electricity bill shows detailed breakdowns of usage and charges, our invoicing system must clearly explain usage-based fees to customers.</p>\n<h3 id=\"usage-event-ingestion\">Usage Event Ingestion</h3>\n<p>The foundation of any usage-based billing system is reliable event ingestion. Usage events represent discrete measurable activities that customers perform within your service. These might be API requests, data processing jobs, storage operations, or any other billable activity. The ingestion system must handle high volumes of events while ensuring perfect accuracy and preventing duplicate charges.</p>\n<p><strong>Event Structure and Validation</strong></p>\n<p>Every usage event follows a standardized structure that captures the essential billing information. The event must identify the customer, specify what type of activity occurred, record the quantity consumed, and timestamp when the activity took place. Additional metadata helps with debugging and provides context for customer support scenarios.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>event_id</td>\n<td>UUID</td>\n<td>Globally unique identifier for this specific event</td>\n</tr>\n<tr>\n<td>customer_id</td>\n<td>UUID</td>\n<td>Foreign key linking to the customer who performed this activity</td>\n</tr>\n<tr>\n<td>subscription_id</td>\n<td>UUID</td>\n<td>Optional foreign key to the specific subscription being billed</td>\n</tr>\n<tr>\n<td>event_type</td>\n<td>str</td>\n<td>Categorizes the type of billable activity (e.g., &quot;api_call&quot;, &quot;storage_gb_hour&quot;)</td>\n</tr>\n<tr>\n<td>quantity</td>\n<td>Decimal</td>\n<td>Precise measurement of consumption using arbitrary precision arithmetic</td>\n</tr>\n<tr>\n<td>timestamp</td>\n<td>datetime</td>\n<td>Server-side timestamp when the event was recorded (UTC)</td>\n</tr>\n<tr>\n<td>idempotency_key</td>\n<td>str</td>\n<td>Client-provided key for preventing duplicate event submission</td>\n</tr>\n<tr>\n<td>metadata</td>\n<td>Dict</td>\n<td>Additional context like user agent, IP address, or feature flags</td>\n</tr>\n<tr>\n<td>source_service</td>\n<td>str</td>\n<td>Which internal service generated this event for debugging</td>\n</tr>\n</tbody></table>\n<p>The ingestion API validates every field before accepting events. Customer IDs must reference existing customers. Event types must match configured billable metrics. Quantities must be positive numbers with reasonable precision limits. Timestamps must fall within acceptable ranges (not too far in the past or future). Metadata must conform to size limits to prevent database bloat.</p>\n<p><strong>Idempotency and Deduplication Strategies</strong></p>\n<p>The most critical requirement for usage event ingestion is preventing duplicate charges. Network retries, client-side bugs, and distributed system failures can all cause the same usage event to be submitted multiple times. Charging customers twice for the same API call or storage operation destroys trust and creates billing disputes.</p>\n<blockquote>\n<p><strong>Decision: Client-Provided Idempotency Keys</strong></p>\n<ul>\n<li><strong>Context</strong>: Usage events may be submitted multiple times due to network failures, client retries, or distributed system issues</li>\n<li><strong>Options Considered</strong>: Server-generated deduplication, client-provided idempotency keys, event fingerprinting</li>\n<li><strong>Decision</strong>: Require clients to provide idempotency keys with event submission</li>\n<li><strong>Rationale</strong>: Client-provided keys give the event source control over deduplication semantics and work across service restarts</li>\n<li><strong>Consequences</strong>: Clients must implement idempotency key generation, but we get reliable duplicate prevention</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Server-generated deduplication</td>\n<td>Simple client implementation</td>\n<td>Cannot handle retries across service restarts</td>\n</tr>\n<tr>\n<td>Client-provided idempotency keys</td>\n<td>Reliable across all failure modes</td>\n<td>Requires client-side key management</td>\n</tr>\n<tr>\n<td>Event fingerprinting</td>\n<td>Transparent to clients</td>\n<td>Complex edge cases with similar events</td>\n</tr>\n</tbody></table>\n<p>The idempotency key should be deterministic based on the usage activity itself. For example, an API request might use a combination of request ID, endpoint, and timestamp. A file upload might use the file hash and user ID. The key must uniquely identify the specific billable activity, not just the client request.</p>\n<p>When the ingestion service receives an event, it first checks if an event with the same idempotency key already exists. If found, it returns success without creating a duplicate record. If not found, it inserts the new event atomically. This check-and-insert operation must be atomic to handle concurrent submissions of the same event.</p>\n<p><strong>Event Processing Pipeline</strong></p>\n<p>Usage events flow through a multi-stage processing pipeline that validates, enriches, and prepares them for aggregation. Each stage has specific responsibilities and error handling requirements.</p>\n<p>The validation stage ensures data quality and business rule compliance. It verifies that the customer has an active subscription that includes the billable metric. It checks that the event timestamp falls within acceptable bounds. It validates that the quantity is reasonable for the event type (e.g., API calls should have quantity 1, storage events might have fractional quantities).</p>\n<p>The enrichment stage adds derived fields that simplify downstream processing. It calculates which billing period the event belongs to based on the customer&#39;s subscription cycle. It looks up pricing information for the event type. It adds geographic or regulatory metadata that affects billing calculations. It resolves the subscription plan version that was active when the event occurred.</p>\n<p>The normalization stage converts events into a standardized format for aggregation. It handles unit conversions (e.g., bytes to gigabytes, milliseconds to hours). It applies any business logic for event grouping or categorization. It adds partition keys that optimize aggregation queries. It ensures consistent precision for decimal quantities.</p>\n<p><strong>Real-Time vs Batch Processing</strong></p>\n<p>Usage events can be processed immediately as they arrive or collected into batches for bulk processing. Each approach has different trade-offs for latency, throughput, and resource utilization.</p>\n<p>Real-time processing provides immediate feedback to customers about their usage and remaining quotas. It enables real-time rate limiting and usage alerts. It distributes processing load evenly over time rather than creating periodic spikes. However, it requires more complex infrastructure to handle traffic bursts and may have higher per-event overhead.</p>\n<p>Batch processing achieves higher throughput by amortizing processing costs across many events. It simplifies error handling and retry logic. It enables more sophisticated aggregation algorithms that consider the entire batch. However, it introduces processing delays and creates periodic resource spikes that must be provisioned for.</p>\n<p>Most production systems use a hybrid approach where high-priority events (quotas, alerts) are processed in real-time while bulk aggregation happens in periodic batches. This provides responsive user experience while maintaining processing efficiency.</p>\n<p><strong>Error Handling and Event Recovery</strong></p>\n<p>Usage event ingestion must handle various failure scenarios gracefully while preserving data integrity. Network timeouts, database connection failures, and validation errors all require different recovery strategies.</p>\n<p>Transient failures like network timeouts or temporary database unavailability should trigger automatic retries with exponential backoff. The retry logic must preserve idempotency by using the same idempotency key across all attempts. Clients should also implement retries with the same idempotency key to ensure end-to-end reliability.</p>\n<p>Validation errors like invalid customer IDs or malformed event types should be logged and returned immediately to the client. These events should not be retried automatically since they will continue to fail until the client fixes the data. However, they should be stored in a dead letter queue for debugging and potential manual recovery.</p>\n<p>Processing failures during enrichment or normalization stages should be retried since they often involve temporary issues with external services. Failed events should be quarantined and processed separately to avoid blocking the healthy event stream. Processing delays should be monitored and alerted since they can affect billing accuracy.</p>\n<h3 id=\"adr-usage-aggregation-architecture\">ADR: Usage Aggregation Architecture</h3>\n<p>Usage events must be aggregated into billing periods to calculate charges for each customer. The aggregation system processes potentially millions of individual events and produces summary records that feed into invoice generation. The architecture must balance processing efficiency, data consistency, and query performance.</p>\n<blockquote>\n<p><strong>Decision: Batch Aggregation with Real-Time Approximation</strong></p>\n<ul>\n<li><strong>Context</strong>: Usage events arrive continuously but billing calculations happen monthly, requiring efficient aggregation of large event volumes</li>\n<li><strong>Options Considered</strong>: Pure real-time aggregation, pure batch aggregation, hybrid batch + real-time approximation</li>\n<li><strong>Decision</strong>: Primary batch aggregation with real-time approximation for customer dashboards and quota enforcement</li>\n<li><strong>Rationale</strong>: Batch processing handles billing-scale volumes efficiently while real-time approximation provides responsive user experience</li>\n<li><strong>Consequences</strong>: More complex architecture but optimal for both billing accuracy and user experience</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pure real-time aggregation</td>\n<td>Immediate accuracy, simple architecture</td>\n<td>Poor performance at billing scale, expensive infrastructure</td>\n</tr>\n<tr>\n<td>Pure batch aggregation</td>\n<td>Excellent throughput, cost-effective</td>\n<td>Poor user experience, delayed quota enforcement</td>\n</tr>\n<tr>\n<td>Hybrid batch + real-time</td>\n<td>Best of both approaches</td>\n<td>Complex architecture, data consistency challenges</td>\n</tr>\n</tbody></table>\n<p><strong>Batch Aggregation Design</strong></p>\n<p>The primary aggregation system processes usage events in scheduled batches, typically every few hours or daily. This approach maximizes throughput by processing large numbers of events together using optimized database queries and parallel processing techniques.</p>\n<p>The batch processor groups events by customer, subscription, event type, and billing period. It calculates sum, count, maximum, and other aggregate functions depending on the billable metric. For example, API call events are summed to get total calls, while concurrent user events might use maximum values to determine peak usage.</p>\n<p>Aggregation windows align with billing period boundaries to ensure accurate monthly totals. The processor maintains checkpoint records to track which events have been aggregated, enabling incremental processing and recovery from failures. It handles events that arrive late (after their billing period has ended) by updating historical aggregations and triggering billing corrections if necessary.</p>\n<p>The output of batch aggregation feeds directly into invoice generation. These records represent the official usage totals used for billing calculations and must be completely accurate. They include detailed breakdowns by event type and time period to support customer inquiries and billing disputes.</p>\n<p><strong>Real-Time Approximation System</strong></p>\n<p>A separate real-time system provides approximate usage totals for customer dashboards and quota enforcement. This system prioritizes responsiveness over perfect accuracy, using techniques like sampling, estimation, and eventual consistency.</p>\n<p>Real-time aggregation maintains rolling windows of recent usage events using in-memory data structures. It provides fast lookups for current billing period totals and usage trends. The data may be slightly stale or approximate, but it updates within seconds of new events arriving.</p>\n<p>For quota enforcement, the real-time system errs on the side of caution by overestimating usage when in doubt. This prevents customers from accidentally exceeding their limits while the approximation catches up. Periodic reconciliation with batch aggregation results corrects any overestimations.</p>\n<p>Customer-facing dashboards clearly indicate when they&#39;re showing estimated vs final usage totals. During the billing period, customers see real-time estimates. After billing closes, they see the final calculated amounts that appear on their invoices.</p>\n<p><strong>Data Consistency and Reconciliation</strong></p>\n<p>The hybrid architecture introduces potential inconsistencies between real-time approximations and batch aggregation results. The system must detect and resolve these discrepancies to maintain data integrity.</p>\n<p>Reconciliation jobs compare real-time and batch totals for completed billing periods. Small differences (within expected tolerances) are logged but not acted upon. Larger discrepancies trigger investigation workflows that examine the underlying event data to identify the source of disagreement.</p>\n<p>When inconsistencies are detected, the batch aggregation results take precedence for billing purposes since they process complete event sets with full consistency guarantees. The real-time system updates its models and estimates based on the authoritative batch results.</p>\n<p>Historical usage data remains immutable once billing closes to ensure audit trail integrity. Any corrections due to late-arriving events or processing errors are recorded as separate adjustment records rather than modifying original totals.</p>\n<h3 id=\"overage-and-tiered-usage-billing\">Overage and Tiered Usage Billing</h3>\n<p>Most usage-based pricing models include base allowances with overage charges when customers exceed their plan limits. These pricing structures require sophisticated calculation logic that considers plan entitlements, usage tiers, and billing period boundaries.</p>\n<p><strong>Usage Allowances and Quota Management</strong></p>\n<p>Each subscription plan defines base allowances for various usage metrics. For example, a &quot;Professional&quot; plan might include 10,000 API calls, 100 GB of storage, and 50 hours of video transcoding per month. These allowances are included in the base subscription fee without additional charges.</p>\n<table>\n<thead>\n<tr>\n<th>Plan Component</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>base_allowance</td>\n<td>int</td>\n<td>Included quantity for this usage metric</td>\n</tr>\n<tr>\n<td>overage_rate_cents</td>\n<td>int</td>\n<td>Per-unit charge when usage exceeds allowance</td>\n</tr>\n<tr>\n<td>usage_metric</td>\n<td>str</td>\n<td>Specific billable activity this allowance covers</td>\n</tr>\n<tr>\n<td>reset_frequency</td>\n<td>BillingInterval</td>\n<td>How often the allowance resets (monthly, annually)</td>\n</tr>\n<tr>\n<td>soft_limit_threshold</td>\n<td>float</td>\n<td>Percentage of allowance that triggers usage warnings</td>\n</tr>\n<tr>\n<td>hard_limit_enabled</td>\n<td>bool</td>\n<td>Whether to block usage when allowance is exhausted</td>\n</tr>\n</tbody></table>\n<p>The system tracks current usage against these allowances throughout the billing period. When customers approach their limits (typically at 80% and 95% thresholds), the system sends usage alert notifications. These alerts help customers manage their consumption and avoid unexpected overage charges.</p>\n<p>Some plans implement hard limits that prevent additional usage once allowances are exhausted. Others allow unlimited overage with per-unit billing. The quota management system enforces these policies in real-time using the approximation data while ensuring accurate billing using the batch aggregation results.</p>\n<p><strong>Tiered Overage Pricing</strong></p>\n<p>Overage charges often use tiered pricing structures where different usage levels have different per-unit rates. This mirrors utility billing models where higher consumption levels have higher marginal costs.</p>\n<p>For example, API call overages might be priced as:</p>\n<ul>\n<li>First 5,000 overage calls: $0.002 per call</li>\n<li>Next 20,000 overage calls: $0.0015 per call  </li>\n<li>Additional overage calls: $0.001 per call</li>\n</ul>\n<p>The calculation engine processes usage through each tier sequentially. If a customer uses 30,000 overage calls, they pay the first-tier rate for the first 5,000 calls, the second-tier rate for the next 20,000 calls, and the third-tier rate for the remaining 5,000 calls.</p>\n<table>\n<thead>\n<tr>\n<th>Tier Definition</th>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tier_number</td>\n<td>int</td>\n<td>Sequential tier ordering (1, 2, 3, ...)</td>\n<td></td>\n</tr>\n<tr>\n<td>min_quantity</td>\n<td>int</td>\n<td>Minimum usage level for this tier (inclusive)</td>\n<td></td>\n</tr>\n<tr>\n<td>max_quantity</td>\n<td>Optional[int]</td>\n<td>Maximum usage level for this tier (None for unlimited)</td>\n<td></td>\n</tr>\n<tr>\n<td>price_per_unit_cents</td>\n<td>int</td>\n<td>Per-unit charge for usage in this tier</td>\n<td></td>\n</tr>\n<tr>\n<td>flat_fee_cents</td>\n<td>int</td>\n<td>One-time charge when entering this tier</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>The tiered calculation logic must handle edge cases like partial tier usage, multiple billing periods, and plan changes mid-cycle. It maintains precision using integer arithmetic and the smallest currency units to avoid floating-point rounding errors.</p>\n<p><strong>Cross-Metric Dependencies and Bundling</strong></p>\n<p>Some pricing models include dependencies between different usage metrics. For example, a plan might bundle API calls and storage together, or provide discounts when customers use multiple services simultaneously.</p>\n<p>Bundled allowances share usage quotas across multiple metrics. A customer might have &quot;10,000 combined API calls and webhook deliveries&quot; rather than separate allowances for each. The system tracks total usage across all bundled metrics and applies overage charges when the combined total exceeds the bundle allowance.</p>\n<p>Tiered discounts apply different rates based on total spending or usage volume across all metrics. High-volume customers might receive better overage rates as they move into higher spending tiers. These calculations require aggregate usage data across all billable metrics for the customer.</p>\n<p>Cross-metric calculations add complexity to the aggregation system since it must consider usage relationships rather than processing each metric independently. The calculation engine evaluates these dependencies after individual metric aggregation but before final invoice generation.</p>\n<p><strong>Billing Period Boundary Handling</strong></p>\n<p>Usage allowances and overage calculations must account for billing period boundaries, especially when customers change plans mid-cycle or when events arrive after billing has closed.</p>\n<p>Plan changes during a billing period require prorated allowance calculations. If a customer upgrades from a plan with 5,000 API call allowance to a plan with 15,000 allowance halfway through the month, they get 5,000 + (15,000 / 2) = 12,500 total allowance for that billing period. The overage calculation uses the higher tier rates for the entire period.</p>\n<p>Late-arriving events can affect overage calculations for closed billing periods. If events arrive after invoices are generated, the system must determine whether to issue credit adjustments or carry the usage forward to the next billing period. Most systems apply a grace period (e.g., 72 hours) for late events and generate credit adjustments for material changes.</p>\n<p>Multi-period aggregation handles customers with annual plans or custom billing cycles. The system maintains running totals across the entire subscription period while providing monthly breakdowns for customer reporting. Allowance resets and overage calculations align with the customer&#39;s specific billing cycle rather than calendar months.</p>\n<p><strong>Usage-Based Pricing Psychology</strong></p>\n<p>Effective usage-based pricing considers customer psychology and billing predictability. Customers prefer pricing models they can understand and budget for, even if those models are more expensive than purely usage-based alternatives.</p>\n<p>Generous base allowances reduce billing anxiety by covering typical usage patterns without overage charges. Most customers should fall within their plan allowances most months. This makes the subscription feel predictable while still allowing monetization of high-usage customers through overage fees.</p>\n<p>Clear usage monitoring and alerts help customers manage their consumption proactively. Real-time dashboards show current usage, remaining allowances, and projected monthly totals. Usage trend analysis helps customers understand their consumption patterns and choose appropriate plans.</p>\n<p>Graduated overage pricing with reasonable first-tier rates reduces sticker shock when customers first exceed their allowances. The highest overage rates should only apply to extremely high usage levels where customers clearly derive significant value from the service.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The usage-based billing engine requires careful attention to data precision, event reliability, and scalable aggregation. The following implementation provides a foundation for accurate usage tracking while maintaining high throughput and low latency for customer-facing features.</p>\n<p><strong>Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Event Ingestion</td>\n<td>HTTP REST API with JSON</td>\n<td>Apache Kafka with schema registry</td>\n</tr>\n<tr>\n<td>Event Storage</td>\n<td>PostgreSQL with partitioning</td>\n<td>Apache Cassandra or ClickHouse</td>\n</tr>\n<tr>\n<td>Real-time Aggregation</td>\n<td>Redis with rolling windows</td>\n<td>Apache Flink or Kafka Streams</td>\n</tr>\n<tr>\n<td>Batch Processing</td>\n<td>Python with pandas</td>\n<td>Apache Spark or Airflow</td>\n</tr>\n<tr>\n<td>Metrics and Monitoring</td>\n<td>Prometheus with Grafana</td>\n<td>DataDog or New Relic</td>\n</tr>\n<tr>\n<td>Queue Management</td>\n<td>PostgreSQL-based queues</td>\n<td>Redis Streams or Amazon SQS</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>subscription-billing/\n  usage/\n    __init__.py\n    models.py              ← UsageEvent, PricingTier, UsageAggregation\n    ingestion.py           ← Event ingestion API and validation\n    aggregation.py         ← Batch aggregation engine\n    realtime.py            ← Real-time approximation system\n    pricing.py             ← Overage and tiered pricing calculations\n    quota.py               ← Quota enforcement and usage limits\n    events.py              ← Event publishing for usage alerts\n  tests/\n    test_usage_ingestion.py\n    test_aggregation.py\n    test_pricing_tiers.py</code></pre></div>\n\n<p><strong>Core Data Models</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal, </span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> UsageMetricType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    API_CALLS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"api_calls\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    STORAGE_GB_HOURS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"storage_gb_hours\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BANDWIDTH_GB</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"bandwidth_gb\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TRANSCODING_MINUTES</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"transcoding_minutes\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ACTIVE_USERS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"active_users\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> UsageEvent</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Single usage event representing billable activity.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    customer_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subscription_id: Optional[uuid.</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    quantity: Decimal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idempotency_key: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metadata: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    source_service: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    billing_period_start: Optional[datetime] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    billing_period_end: Optional[datetime] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    processed_at: Optional[datetime] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.timestamp.tzinfo </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.timestamp </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.timestamp.replace(</span><span style=\"color:#FFAB70\">tzinfo</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">timezone.utc)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PricingTier</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Usage pricing tier with quantity ranges and rates.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tier_number: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    min_quantity: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_quantity: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># None for unlimited</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    price_per_unit_cents: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flat_fee_cents: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> contains_quantity</span><span style=\"color:#E1E4E8\">(self, quantity: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> quantity </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.min_quantity:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.max_quantity </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#F97583\"> and</span><span style=\"color:#E1E4E8\"> quantity </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.max_quantity:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> calculate_tier_charge</span><span style=\"color:#E1E4E8\">(self, quantity: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Calculate total charge for quantity within this tier.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.contains_quantity(quantity):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Quantity </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">quantity</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> not in tier range\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tier_quantity </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> min</span><span style=\"color:#E1E4E8\">(quantity, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.max_quantity </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> quantity) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.min_quantity </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.flat_fee_cents </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> (tier_quantity </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.price_per_unit_cents)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> UsageAggregation</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Aggregated usage totals for billing period.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    aggregation_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    customer_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subscription_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    billing_period_start: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    billing_period_end: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    total_quantity: Decimal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event_count: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    first_event_at: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    last_event_at: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_at: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_billing_quantity</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert decimal quantity to integer for billing calculations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.total_quantity.quantize(Decimal(</span><span style=\"color:#9ECBFF\">'1'</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">rounding</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span><span style=\"color:#E1E4E8\">))</span></span></code></pre></div>\n\n<p><strong>Usage Event Ingestion Service</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal, InvalidOperation</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> UsageIngestionService</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Service for receiving and validating usage events.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, db_manager, event_publisher, subscription_service):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> db_manager</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.events </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> event_publisher</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.subscriptions </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> subscription_service</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> submit_usage_event</span><span style=\"color:#E1E4E8\">(self, event_data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> UsageEvent:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Submit a single usage event with idempotency protection.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns existing event if idempotency key matches.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate event_data contains required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check for existing event with same idempotency_key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate customer_id exists and has active subscription</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate event_type is supported billable metric</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Validate quantity is positive decimal with reasonable precision</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Enrich event with billing period information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Insert event record atomically with idempotency check</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Publish event for real-time aggregation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Return created or existing event</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> submit_usage_batch</span><span style=\"color:#E1E4E8\">(self, events: List[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]]) -> List[UsageEvent]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Submit multiple usage events in a single transaction.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate all events in batch before processing any</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Group events by idempotency key to detect duplicates within batch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Start database transaction with appropriate isolation level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Process each event using submit_usage_event logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Collect results and rollback transaction on any failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Publish batch event notification for monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return list of created/existing events</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_event_data</span><span style=\"color:#E1E4E8\">(self, event_data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate event data structure and business rules.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        required_fields </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'customer_id'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'event_type'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'quantity'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'idempotency_key'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> field </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> required_fields:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> field </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> event_data:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Missing required field: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">field</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Validate UUID fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            uuid.UUID(event_data[</span><span style=\"color:#9ECBFF\">'customer_id'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#9ECBFF\"> 'subscription_id'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> event_data:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                uuid.UUID(event_data[</span><span style=\"color:#9ECBFF\">'subscription_id'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">ValueError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">TypeError</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Invalid UUID format: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Validate quantity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            quantity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(event_data[</span><span style=\"color:#9ECBFF\">'quantity'</span><span style=\"color:#E1E4E8\">]))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> quantity </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Quantity must be positive\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> quantity.as_tuple().exponent </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># Max 6 decimal places</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Quantity precision too high\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> (InvalidOperation, </span><span style=\"color:#79B8FF\">TypeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Invalid quantity format\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _enrich_event_data</span><span style=\"color:#E1E4E8\">(self, event_data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add derived fields for downstream processing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        enriched </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> event_data.copy()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Add server timestamp if not provided</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#9ECBFF\"> 'timestamp'</span><span style=\"color:#F97583\"> not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> enriched:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            enriched[</span><span style=\"color:#9ECBFF\">'timestamp'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> datetime.now(timezone.utc)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Look up billing period boundaries from subscription</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add pricing tier information for this event type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add customer segment or region for regulatory requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate partition key for efficient storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> enriched</span></span></code></pre></div>\n\n<p><strong>Usage Aggregation Engine</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> collections </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> defaultdict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> UsageAggregationEngine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Batch processing engine for usage event aggregation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, db_manager, metrics_client):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> db_manager</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.metrics </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> metrics_client</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._aggregation_functions </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'sum'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._sum_aggregation,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'count'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._count_aggregation,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'max'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._max_aggregation,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'last_value'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._last_value_aggregation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> aggregate_billing_period</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                billing_period_start: datetime, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                billing_period_end: datetime) -> List[UsageAggregation]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Aggregate all usage events for the specified billing period.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns list of aggregation records for invoice generation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Query all usage events in billing period range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Group events by (customer_id, subscription_id, event_type)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate aggregations for each group using appropriate function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create UsageAggregation records with calculated totals</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Store aggregation records atomically</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Update aggregation checkpoint for incremental processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Publish aggregation completed events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Return list of aggregation records</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_incremental_aggregation</span><span style=\"color:#E1E4E8\">(self, checkpoint_timestamp: datetime) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process events since last checkpoint for real-time updates.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Query events newer than checkpoint_timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Group events and calculate incremental aggregations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Update existing aggregation records or create new ones</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle late-arriving events for closed billing periods</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Update checkpoint timestamp atomically</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return count of processed events</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _group_events_for_aggregation</span><span style=\"color:#E1E4E8\">(self, events: List[UsageEvent]) -> Dict[Tuple, List[UsageEvent]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Group events by aggregation key (customer, subscription, event_type).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        groups </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> defaultdict(</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> event </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> events:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (event.customer_id, event.subscription_id, event.event_type)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            groups[key].append(event)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> dict</span><span style=\"color:#E1E4E8\">(groups)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _sum_aggregation</span><span style=\"color:#E1E4E8\">(self, events: List[UsageEvent]) -> Decimal:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Sum all event quantities.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> sum</span><span style=\"color:#E1E4E8\">(event.quantity </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> event </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> events)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _count_aggregation</span><span style=\"color:#E1E4E8\">(self, events: List[UsageEvent]) -> Decimal:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Count number of events.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(events))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _max_aggregation</span><span style=\"color:#E1E4E8\">(self, events: List[UsageEvent]) -> Decimal:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return maximum quantity across all events.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> max</span><span style=\"color:#E1E4E8\">(event.quantity </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> event </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> events) </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> events </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#9ECBFF\">'0'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _last_value_aggregation</span><span style=\"color:#E1E4E8\">(self, events: List[UsageEvent]) -> Decimal:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return quantity from most recent event.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> events:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#9ECBFF\">'0'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        latest_event </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> max</span><span style=\"color:#E1E4E8\">(events, </span><span style=\"color:#FFAB70\">key</span><span style=\"color:#F97583\">=lambda</span><span style=\"color:#E1E4E8\"> e: e.timestamp)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> latest_event.quantity</span></span></code></pre></div>\n\n<p><strong>Tiered Pricing Calculator</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TieredPricingCalculator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Calculates usage charges using tiered pricing models.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, db_manager):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> db_manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> calculate_usage_charge</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              customer_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              event_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              total_quantity: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              base_allowance: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Calculate tiered usage charge for quantity beyond base allowance.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns detailed charge breakdown with tier-by-tier calculations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load pricing tiers for this event_type from plan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Calculate overage quantity (total - base_allowance)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Apply tiered pricing calculation to overage quantity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Build detailed breakdown of charges by tier</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Calculate total charge amount with proper rounding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return charge details for invoice line items</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _apply_tiered_pricing</span><span style=\"color:#E1E4E8\">(self, quantity: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, tiers: List[PricingTier]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Apply tiered pricing structure to calculate total charges.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> quantity </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'total_charge_cents'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'tier_breakdown'</span><span style=\"color:#E1E4E8\">: [],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'effective_rate_cents'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_charge </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tier_breakdown </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        remaining_quantity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> quantity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> tier </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> sorted</span><span style=\"color:#E1E4E8\">(tiers, </span><span style=\"color:#FFAB70\">key</span><span style=\"color:#F97583\">=lambda</span><span style=\"color:#E1E4E8\"> t: t.tier_number):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> remaining_quantity </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Calculate quantity that falls in this tier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tier_min </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tier.min_quantity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tier_max </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tier.max_quantity </span><span style=\"color:#F97583\">or</span><span style=\"color:#79B8FF\"> float</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'inf'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tier_quantity </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> min</span><span style=\"color:#E1E4E8\">(remaining_quantity, tier_max </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> tier_min </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> tier_quantity </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Calculate charge for this tier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                tier_charge </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tier.flat_fee_cents </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> (tier_quantity </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> tier.price_per_unit_cents)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                total_charge </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> tier_charge</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                tier_breakdown.append({</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'tier_number'</span><span style=\"color:#E1E4E8\">: tier.tier_number,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'quantity'</span><span style=\"color:#E1E4E8\">: tier_quantity,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'rate_cents'</span><span style=\"color:#E1E4E8\">: tier.price_per_unit_cents,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'flat_fee_cents'</span><span style=\"color:#E1E4E8\">: tier.flat_fee_cents,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'tier_charge_cents'</span><span style=\"color:#E1E4E8\">: tier_charge</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                remaining_quantity </span><span style=\"color:#F97583\">-=</span><span style=\"color:#E1E4E8\"> tier_quantity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        effective_rate </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> total_charge </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> quantity </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> quantity </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> else</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'total_charge_cents'</span><span style=\"color:#E1E4E8\">: total_charge,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'tier_breakdown'</span><span style=\"color:#E1E4E8\">: tier_breakdown,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'effective_rate_cents'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">round</span><span style=\"color:#E1E4E8\">(effective_rate, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span></code></pre></div>\n\n<p><strong>Real-Time Usage Approximation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> redis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RealTimeUsageTracker</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provides approximate real-time usage totals for dashboards and quotas.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, redis_client: redis.Redis, window_hours: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 24</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.redis </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> redis_client</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.window_hours </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> window_hours</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.window_seconds </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> window_hours </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 3600</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> record_usage_event</span><span style=\"color:#E1E4E8\">(self, event: UsageEvent) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record usage event in real-time approximation system.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create time-bucketed key for this customer/event_type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add event quantity to running total for current time bucket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Set expiration on time bucket keys for automatic cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Update customer's current billing period total</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Check if customer is approaching usage quotas</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Publish usage alert if quota thresholds exceeded</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_current_usage</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                         customer_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                         event_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                         billing_period_start: datetime) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get approximate current usage for customer billing period.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate time buckets covering billing period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Sum usage across all relevant time buckets</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Apply smoothing factor for late-arriving events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return usage estimate with confidence interval</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> check_usage_quotas</span><span style=\"color:#E1E4E8\">(self, customer_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">) -> List[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if customer is approaching or exceeding usage quotas.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get current usage estimates for all event types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Load plan allowances and quota limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate usage percentage for each metric</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Identify metrics approaching warning thresholds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return list of quota status for each metric</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _get_time_bucket_key</span><span style=\"color:#E1E4E8\">(self, customer_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">, event_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, timestamp: datetime) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate Redis key for time-bucketed usage data.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bucket_hour </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timestamp.replace(</span><span style=\"color:#FFAB70\">minute</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">second</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">microsecond</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"usage:</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">customer_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">event_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">bucket_hour.isoformat()</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoints</strong></p>\n<p>After implementing the usage-based billing engine, verify the following functionality:</p>\n<ol>\n<li><p><strong>Event Ingestion Validation</strong>: Submit duplicate events with the same idempotency key. Verify only one event is recorded and the API returns success for both submissions.</p>\n</li>\n<li><p><strong>Usage Aggregation Accuracy</strong>: Submit a known set of usage events spanning multiple days. Run batch aggregation and verify the totals match expected calculations.</p>\n</li>\n<li><p><strong>Tiered Pricing Calculations</strong>: Create a plan with tiered overage pricing (e.g., first 1000 units at $0.01, next 5000 at $0.008). Submit usage that spans multiple tiers and verify charge calculations.</p>\n</li>\n<li><p><strong>Real-Time Approximation</strong>: Submit usage events and verify they appear in real-time usage dashboards within seconds. Compare real-time totals to batch aggregation results for accuracy.</p>\n</li>\n<li><p><strong>Quota Enforcement</strong>: Configure usage limits and submit events that approach quotas. Verify usage alerts are sent and hard limits are enforced when configured.</p>\n</li>\n</ol>\n<p>Expected behavior: Usage events should be processed idempotently with perfect accuracy in batch mode and approximate accuracy in real-time mode. Pricing calculations should handle complex tiered structures without rounding errors. The system should scale to thousands of events per second while maintaining data consistency.</p>\n<h2 id=\"invoicing-and-payment-processing\">Invoicing and Payment Processing</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all milestones - generates invoices from subscription charges, usage, and credits, then processes payments through the payment gateway integration</p>\n</blockquote>\n<h3 id=\"mental-model-restaurant-check-generation-and-payment\">Mental Model: Restaurant Check Generation and Payment</h3>\n<p>Think of invoice generation like a restaurant preparing your final check at the end of a meal. The waiter (Invoice Generation Engine) walks through your table&#39;s activity: the base meal price (subscription charges), any extra appetizers you ordered during dinner (usage overages), and any comp drinks the manager gave you (credit applications). They itemize everything on a single receipt with clear line items, calculate tax, and present a total amount due.</p>\n<p>The payment processing is like the credit card terminal at your table. Once you approve the charge, the terminal (Payment Gateway Integration) communicates with your bank behind the scenes. The restaurant doesn&#39;t handle your banking directly - they just send the charge amount and receive back a simple &quot;approved&quot; or &quot;declined&quot; response. If your card is declined, the system might automatically retry with a different payment method you have on file.</p>\n<p>This separation of concerns - invoice generation versus payment processing - mirrors how billing systems work. The invoice engine focuses on accurately calculating what&#39;s owed based on subscription activity, while the payment processor handles the mechanics of actually collecting money through external financial networks.</p>\n<h3 id=\"invoice-generation-engine\">Invoice Generation Engine</h3>\n<p>The <strong>Invoice Generation Engine</strong> serves as the financial consolidation point for all subscription-related charges, credits, and adjustments. This component transforms raw billing data from subscriptions, usage events, and proration calculations into structured invoices that customers can understand and payment systems can process.</p>\n<p>The invoice generation process follows a specific sequence that ensures mathematical accuracy and maintains a complete audit trail. The engine operates on a <strong>billing period boundary</strong> principle, where it collects all chargeable events that occurred within a defined time window, applies any outstanding credits, and produces a net amount due. This approach prevents double-billing and ensures that every cent is accounted for across billing cycles.</p>\n<h4 id=\"invoice-line-item-calculation\">Invoice Line Item Calculation</h4>\n<p>Each invoice contains multiple line items that represent different types of charges and credits. The engine processes these in a specific order to ensure consistent application of business rules:</p>\n<table>\n<thead>\n<tr>\n<th>Line Item Type</th>\n<th>Source</th>\n<th>Calculation Method</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Base Subscription</td>\n<td>Plan recurring charge</td>\n<td>Fixed amount from plan definition</td>\n<td>$29.99/month Pro Plan</td>\n</tr>\n<tr>\n<td>Usage Overage</td>\n<td>Aggregated usage events</td>\n<td>Tiered pricing beyond allowance</td>\n<td>1,000 API calls × $0.01 = $10.00</td>\n</tr>\n<tr>\n<td>Plan Change Proration</td>\n<td>Mid-cycle upgrades</td>\n<td>Prorated charge for remaining days</td>\n<td>$15.00 upgrade × 15/30 days = $7.50</td>\n</tr>\n<tr>\n<td>Credit Application</td>\n<td>Customer credit balance</td>\n<td>Applied against positive charges</td>\n<td>-$5.00 account credit</td>\n</tr>\n<tr>\n<td>Tax Calculation</td>\n<td>Jurisdiction rules</td>\n<td>Applied to taxable line items</td>\n<td>$4.20 sales tax (10%)</td>\n</tr>\n</tbody></table>\n<p>The engine implements <strong>financial precision</strong> by performing all calculations in the smallest currency unit (cents for USD) to avoid floating-point rounding errors. Each line item stores both the calculation method and the raw inputs used, enabling complete auditability of every charge.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: Invoice line items are immutable once generated. If an error is discovered after invoice creation, the system generates a credit note (negative invoice) rather than modifying the original invoice. This maintains financial audit integrity and matches accounting best practices.</p>\n</blockquote>\n<h4 id=\"invoice-status-state-machine\">Invoice Status State Machine</h4>\n<p>Invoices progress through a well-defined lifecycle that coordinates with payment processing and dunning management:</p>\n<table>\n<thead>\n<tr>\n<th>Current Status</th>\n<th>Trigger Event</th>\n<th>Next Status</th>\n<th>Actions Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>draft</code></td>\n<td>Complete line item calculation</td>\n<td><code>open</code></td>\n<td>Mark invoice as ready for payment</td>\n</tr>\n<tr>\n<td><code>open</code></td>\n<td>Payment received successfully</td>\n<td><code>paid</code></td>\n<td>Update customer balance, mark subscription current</td>\n</tr>\n<tr>\n<td><code>open</code></td>\n<td>Payment attempt failed</td>\n<td><code>past_due</code></td>\n<td>Start dunning process, set retry schedule</td>\n</tr>\n<tr>\n<td><code>open</code></td>\n<td>Invoice voided by admin</td>\n<td><code>void</code></td>\n<td>Cancel payment attempts, apply credit</td>\n</tr>\n<tr>\n<td><code>past_due</code></td>\n<td>Payment retry succeeded</td>\n<td><code>paid</code></td>\n<td>Complete payment flow, stop dunning</td>\n</tr>\n<tr>\n<td><code>past_due</code></td>\n<td>All retries exhausted</td>\n<td><code>uncollectible</code></td>\n<td>Suspend subscription, write off balance</td>\n</tr>\n<tr>\n<td><code>paid</code></td>\n<td>Refund processed</td>\n<td><code>refunded</code></td>\n<td>Update customer credit balance</td>\n</tr>\n</tbody></table>\n<p>The invoice status directly influences subscription state transitions. A subscription cannot remain <code>active</code> with <code>past_due</code> invoices beyond the configured grace period. This tight coupling ensures that billing status accurately reflects service access.</p>\n<h4 id=\"invoice-generation-algorithms\">Invoice Generation Algorithms</h4>\n<p>The core invoice generation algorithm processes multiple data sources and applies business rules to produce accurate billing:</p>\n<ol>\n<li><strong>Billing Period Determination</strong>: Calculate the start and end dates for the current billing cycle based on the subscription&#39;s billing anchor date and interval</li>\n<li><strong>Base Charge Calculation</strong>: Retrieve the subscription&#39;s current plan and calculate the recurring charge for the billing period</li>\n<li><strong>Usage Event Aggregation</strong>: Sum all usage events for the customer within the billing period, grouped by event type</li>\n<li><strong>Usage Charge Calculation</strong>: Apply the plan&#39;s usage tiers to determine overage charges beyond included allowances</li>\n<li><strong>Proration Processing</strong>: Include any mid-cycle plan changes or subscription modifications that occurred during the billing period</li>\n<li><strong>Credit Application</strong>: Apply available customer credits to reduce the total amount due</li>\n<li><strong>Tax Calculation</strong>: Apply jurisdiction-specific tax rules to taxable line items</li>\n<li><strong>Invoice Finalization</strong>: Lock the invoice calculations, assign a sequential invoice number, and transition to <code>open</code> status</li>\n<li><strong>Payment Initiation</strong>: Trigger payment processing for the final invoice amount</li>\n<li><strong>Audit Trail Recording</strong>: Log all calculation steps and data sources for compliance and debugging</li>\n</ol>\n<p>Each step in this algorithm includes validation checks to ensure data consistency. For example, the usage event aggregation step verifies that all events fall within the billing period boundaries and that no duplicate events are processed.</p>\n<h4 id=\"common-invoice-generation-pitfalls\">Common Invoice Generation Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Timezone Confusion in Billing Period Boundaries</strong><br>Many developers incorrectly calculate billing periods by using server local time instead of the customer&#39;s billing timezone. This can cause usage events to be attributed to the wrong billing cycle, leading to under-billing or over-billing. Always store billing anchor dates in UTC but perform billing period calculations in the customer&#39;s configured timezone, then convert event timestamps accordingly.</p>\n<p>⚠️ <strong>Pitfall: Floating Point Currency Calculations</strong><br>Using floating-point arithmetic for monetary calculations introduces rounding errors that compound over many invoices. A $0.001 rounding error across 100,000 customers results in $100 of unaccounted variance. Always perform calculations in integer cents and use the <code>Money</code> type&#39;s <code>from_decimal()</code> method for conversions.</p>\n<p>⚠️ <strong>Pitfall: Credit Application Order Dependency</strong><br>Applying customer credits before calculating taxes can result in incorrect tax amounts, while applying credits after taxes can reduce the customer&#39;s available credit balance unnecessarily. The correct order is: calculate base charges, calculate taxes, then apply credits to the total amount including taxes.</p>\n<p>⚠️ <strong>Pitfall: Invoice Immutability Violations</strong><br>Modifying invoice line items after the invoice status changes to <code>open</code> breaks audit trails and can create payment inconsistencies. If an error is discovered, generate a separate credit invoice rather than modifying the original. This preserves the historical record and follows standard accounting practices.</p>\n<h3 id=\"payment-gateway-integration\">Payment Gateway Integration</h3>\n<p>The <strong>Payment Gateway Integration</strong> component provides a clean abstraction layer between the subscription billing system and external payment processors. This integration handles payment method storage, charge processing, webhook management, and failure recovery while maintaining PCI compliance boundaries.</p>\n<p>The integration operates on an <strong>asynchronous payment model</strong> where payment initiation and completion are separate operations. When an invoice becomes due, the system initiates a payment request with the gateway and receives an immediate response indicating whether the request was accepted for processing. The actual payment result arrives later via webhook notifications, which update the invoice status and trigger downstream actions.</p>\n<h4 id=\"payment-method-management\">Payment Method Management</h4>\n<p>Customer payment methods are stored and managed entirely within the payment gateway&#39;s secure vault to maintain PCI compliance. The billing system only stores tokenized references that can be used to initiate charges without handling sensitive payment data:</p>\n<table>\n<thead>\n<tr>\n<th>Payment Method Attribute</th>\n<th>Storage Location</th>\n<th>Purpose</th>\n<th>Example Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Gateway Token ID</td>\n<td>Billing system database</td>\n<td>Reference for charge requests</td>\n<td><code>pm_1ABC123xyz</code></td>\n</tr>\n<tr>\n<td>Payment Type</td>\n<td>Billing system database</td>\n<td>Display and routing logic</td>\n<td><code>card</code>, <code>bank_account</code>, <code>wallet</code></td>\n</tr>\n<tr>\n<td>Last Four Digits</td>\n<td>Billing system database</td>\n<td>Customer identification</td>\n<td><code>4242</code></td>\n</tr>\n<tr>\n<td>Expiration Date</td>\n<td>Billing system database</td>\n<td>Proactive replacement</td>\n<td><code>12/2025</code></td>\n</tr>\n<tr>\n<td>Is Default</td>\n<td>Billing system database</td>\n<td>Primary payment selection</td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td>Gateway Customer ID</td>\n<td>Billing system database</td>\n<td>Customer grouping</td>\n<td><code>cus_ABC123</code></td>\n</tr>\n</tbody></table>\n<p>The system supports <strong>payment method hierarchy</strong> where customers can configure primary and backup payment methods. If the primary method fails, the system automatically retries with backup methods before entering the dunning process.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: The billing system never stores raw payment information - not even temporarily. All payment data flows directly from the customer&#39;s browser to the payment gateway using tokenization. This architectural decision simplifies PCI compliance and reduces security risk.</p>\n</blockquote>\n<h4 id=\"charge-processing-flow\">Charge Processing Flow</h4>\n<p>Payment charges follow a standardized flow that handles both synchronous and asynchronous response patterns:</p>\n<ol>\n<li><strong>Invoice Payment Trigger</strong>: Invoice generation completes and triggers payment processing for the final amount due</li>\n<li><strong>Payment Method Selection</strong>: Select the customer&#39;s default payment method, or fall back to backup methods if primary fails</li>\n<li><strong>Idempotency Key Generation</strong>: Generate a unique key combining customer ID, invoice ID, and attempt number to prevent duplicate charges</li>\n<li><strong>Gateway Charge Request</strong>: Submit charge request to payment gateway with amount, payment method token, and metadata</li>\n<li><strong>Immediate Response Handling</strong>: Process gateway&#39;s immediate response (accepted, declined, requires_action, processing)</li>\n<li><strong>Status Update</strong>: Update invoice status based on immediate response (remains <code>open</code> for async processing)</li>\n<li><strong>Webhook Processing</strong>: Receive asynchronous webhook with final charge result</li>\n<li><strong>Invoice Completion</strong>: Update invoice to <code>paid</code> or <code>past_due</code> based on final charge result</li>\n<li><strong>Subscription Impact</strong>: Update subscription status and access levels based on payment outcome</li>\n<li><strong>Notification Dispatch</strong>: Send customer notifications for payment success or failure</li>\n</ol>\n<p>The charge processing includes <strong>automatic retry logic</strong> for transient failures. Network timeouts, gateway maintenance, and temporary declines trigger retry attempts with exponential backoff before marking the payment as failed.</p>\n<h4 id=\"webhook-event-processing\">Webhook Event Processing</h4>\n<p>Payment gateway webhooks provide authoritative updates about charge status, payment method changes, and dispute notifications. The webhook processing system ensures reliable event handling even under high load or temporary system outages:</p>\n<table>\n<thead>\n<tr>\n<th>Webhook Event Type</th>\n<th>Triggered By</th>\n<th>System Response</th>\n<th>Example Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>payment_intent.succeeded</code></td>\n<td>Successful charge completion</td>\n<td>Update invoice to <code>paid</code> status</td>\n<td>Activate subscription access</td>\n</tr>\n<tr>\n<td><code>payment_intent.payment_failed</code></td>\n<td>Charge failure after retries</td>\n<td>Update invoice to <code>past_due</code></td>\n<td>Start dunning sequence</td>\n</tr>\n<tr>\n<td><code>payment_method.updated</code></td>\n<td>Customer updates card details</td>\n<td>Refresh stored payment metadata</td>\n<td>Update expiration date display</td>\n</tr>\n<tr>\n<td><code>invoice.payment_action_required</code></td>\n<td>3D Secure authentication needed</td>\n<td>Notify customer of required action</td>\n<td>Send authentication link</td>\n</tr>\n<tr>\n<td><code>chargeback.created</code></td>\n<td>Bank dispute initiated</td>\n<td>Freeze related subscription</td>\n<td>Suspend service, gather evidence</td>\n</tr>\n</tbody></table>\n<p>Webhook processing implements <strong>exactly-once delivery semantics</strong> using idempotency keys stored in the webhook payload. The system deduplicates webhook events and ensures that each event is processed only once, even if the gateway sends duplicate notifications.</p>\n<blockquote>\n<p><strong>Critical Design Decision</strong>: Webhook processing is separated from real-time payment flows. Webhooks update system state asynchronously, while immediate payment responses handle user experience. This separation ensures that gateway latency doesn&#39;t impact customer-facing operations.</p>\n</blockquote>\n<h3 id=\"adr-payment-webhook-processing\">ADR: Payment Webhook Processing</h3>\n<blockquote>\n<p><strong>Decision: Asynchronous Webhook Processing with Event Queue</strong></p>\n<ul>\n<li><strong>Context</strong>: Payment gateways send webhook notifications for charge status updates, but these webhooks can arrive out of order, be duplicated, or fail during processing. The system must reliably process these events to maintain accurate billing state while handling high webhook volumes without blocking user-facing operations.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Synchronous webhook processing with immediate database updates</li>\n<li>Asynchronous processing with message queue and worker processes</li>\n<li>Hybrid approach with immediate critical updates and queued background processing</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement fully asynchronous webhook processing using a reliable message queue with dead letter handling and idempotency protection</li>\n<li><strong>Rationale</strong>: Payment webhooks are not latency-sensitive and require reliable processing more than immediate processing. Queue-based processing provides natural retry mechanisms, handles traffic spikes, and prevents webhook failures from impacting payment gateway relationships. The slight delay in status updates is acceptable since customers receive immediate feedback from the synchronous payment initiation response.</li>\n<li><strong>Consequences</strong>: Enables horizontal scaling of webhook processing, provides built-in retry and dead letter handling, and maintains webhook endpoint reliability. Trade-off is eventual consistency in payment status updates, requiring careful handling of race conditions where customers might see temporary status mismatches.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Processing Option</th>\n<th>Reliability</th>\n<th>Latency</th>\n<th>Scalability</th>\n<th>Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Synchronous Processing</td>\n<td>Medium (no retry)</td>\n<td>Low</td>\n<td>Limited</td>\n<td>Low</td>\n</tr>\n<tr>\n<td><strong>Async Queue (Chosen)</strong></td>\n<td><strong>High (built-in retry)</strong></td>\n<td><strong>Medium</strong></td>\n<td><strong>High</strong></td>\n<td><strong>Medium</strong></td>\n</tr>\n<tr>\n<td>Hybrid Approach</td>\n<td>High</td>\n<td>Variable</td>\n<td>Medium</td>\n<td>High</td>\n</tr>\n</tbody></table>\n<p>The asynchronous queue approach provides the best balance of reliability and scalability. Critical payment status updates can still be handled synchronously during payment initiation, while webhook processing handles the authoritative state reconciliation asynchronously.</p>\n<h4 id=\"webhook-idempotency-and-deduplication\">Webhook Idempotency and Deduplication</h4>\n<p>Payment gateways may send duplicate webhook events due to network issues, timeouts, or internal retry logic. The webhook processing system implements <strong>idempotency protection</strong> to ensure each event is processed exactly once:</p>\n<ol>\n<li><strong>Idempotency Key Extraction</strong>: Extract the gateway-provided idempotency key from the webhook payload header</li>\n<li><strong>Duplicate Detection</strong>: Check if this idempotency key has been processed before by querying the webhook event log</li>\n<li><strong>Atomic Processing</strong>: If not a duplicate, process the webhook and record the idempotency key in a single database transaction</li>\n<li><strong>Idempotent Response</strong>: Return success immediately for duplicate webhooks without reprocessing</li>\n<li><strong>Event Ordering</strong>: Handle out-of-order webhooks by comparing event timestamps and only applying newer updates</li>\n</ol>\n<p>The idempotency system maintains a webhook event log that serves both as duplicate protection and as an audit trail for debugging payment issues.</p>\n<h4 id=\"payment-failure-recovery\">Payment Failure Recovery</h4>\n<p>When payment charges fail, the system implements a <strong>graduated dunning process</strong> that balances customer retention with payment collection. The recovery process includes multiple retry attempts with different strategies:</p>\n<table>\n<thead>\n<tr>\n<th>Retry Stage</th>\n<th>Timing</th>\n<th>Action Taken</th>\n<th>Success Rate</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Immediate Retry</td>\n<td>1 hour after failure</td>\n<td>Same payment method</td>\n<td>~15% recovery</td>\n</tr>\n<tr>\n<td>Backup Method</td>\n<td>24 hours</td>\n<td>Try backup payment method</td>\n<td>~25% recovery</td>\n</tr>\n<tr>\n<td>Customer Notification</td>\n<td>3 days</td>\n<td>Email with payment update link</td>\n<td>~35% recovery</td>\n</tr>\n<tr>\n<td>Account Suspension Warning</td>\n<td>7 days</td>\n<td>Final notice before suspension</td>\n<td>~20% recovery</td>\n</tr>\n<tr>\n<td>Service Suspension</td>\n<td>14 days</td>\n<td>Restrict account access</td>\n<td>Payment required for restoration</td>\n</tr>\n</tbody></table>\n<p>Each retry attempt generates a new idempotency key to prevent conflicts with previous attempts. The system tracks retry history and automatically escalates through the dunning stages based on configurable business rules.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The invoice generation and payment processing components require careful attention to financial accuracy, error handling, and integration patterns. The implementation balances real-time responsiveness with reliable background processing.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<p>| Component | Simple Option | Advanced Option |\n|---|---|---|---|\n| Invoice Generation | SQLite with JSON fields | PostgreSQL with JSONB and triggers |\n| Payment Gateway SDK | Stripe Python SDK | Multi-gateway abstraction layer |\n| Webhook Processing | Flask + Celery | FastAPI + Apache Kafka |\n| Currency Handling | Python Decimal with custom Money class | Babel + currency exchange APIs |\n| PDF Generation | ReportLab Python library | Headless Chrome with HTML templates |\n| Audit Logging | Structured JSON logging | Dedicated audit database |</p>\n<p>The simple options provide rapid development velocity for proof-of-concept implementations, while advanced options support production-scale requirements with better performance and observability.</p>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>billing_system/\n  invoicing/\n    __init__.py\n    invoice_generator.py      ← Core invoice generation logic\n    line_item_calculator.py   ← Individual charge calculations\n    invoice_models.py         ← Invoice and LineItem data structures\n    invoice_repository.py     ← Database operations\n    invoice_service.py        ← High-level orchestration\n    \n  payments/\n    __init__.py\n    payment_gateway.py        ← Gateway abstraction interface\n    stripe_gateway.py         ← Stripe-specific implementation\n    webhook_handler.py        ← Webhook processing logic\n    payment_models.py         ← Payment and Transaction structures\n    payment_service.py        ← Payment orchestration\n    \n  shared/\n    money.py                  ← Currency and precision utilities\n    audit_logger.py           ← Financial audit trail\n    idempotency.py           ← Duplicate request protection\n    \n  tests/\n    test_invoice_generation.py\n    test_payment_processing.py\n    test_webhook_handling.py</code></pre></div>\n\n<p>This structure separates invoice generation concerns from payment processing while providing shared utilities for financial operations. The clear separation enables independent testing and deployment of billing versus payment functionality.</p>\n<h4 id=\"core-invoice-generation-infrastructure\">Core Invoice Generation Infrastructure</h4>\n<p>The invoice generation system requires robust infrastructure for financial calculations and audit trails:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal, </span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    amount_cents: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currency_code: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_decimal</span><span style=\"color:#E1E4E8\">(cls, amount: Decimal, currency: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Convert decimal to cents with proper rounding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(amount.quantize(Decimal(</span><span style=\"color:#9ECBFF\">'0.01'</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">rounding</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">amount_cents</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">cents, </span><span style=\"color:#FFAB70\">currency_code</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">currency)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_decimal</span><span style=\"color:#E1E4E8\">(self) -> Decimal:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#9ECBFF\">'100'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __add__</span><span style=\"color:#E1E4E8\">(self, other: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.currency_code:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cannot add different currencies\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Money(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> other.amount_cents, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __sub__</span><span style=\"color:#E1E4E8\">(self, other: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.currency_code </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.currency_code:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cannot subtract different currencies\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Money(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.amount_cents </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> other.amount_cents, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.currency_code)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvoiceStatus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DRAFT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"draft\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OPEN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"open\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"paid\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAST_DUE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"past_due\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    VOID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"void\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UNCOLLECTIBLE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"uncollectible\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LineItemType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUBSCRIPTION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"subscription\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    USAGE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"usage\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PRORATION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"proration\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CREDIT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"credit\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TAX</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"tax\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LineItem</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line_item_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    item_type: LineItemType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    description: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    quantity: Decimal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    unit_price: Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    total_amount: Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tax_amount: Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metadata: Dict </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_at: datetime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=lambda</span><span style=\"color:#E1E4E8\">: datetime.now(timezone.utc))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Invoice</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    invoice_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    customer_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subscription_id: Optional[uuid.</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status: InvoiceStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line_items: List[LineItem]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subtotal_amount: Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tax_amount: Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    credit_applied: Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    total_amount: Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    billing_period_start: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    billing_period_end: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    due_date: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_at: datetime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=lambda</span><span style=\"color:#E1E4E8\">: datetime.now(timezone.utc))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    updated_at: datetime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=lambda</span><span style=\"color:#E1E4E8\">: datetime.now(timezone.utc))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metadata: Dict </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuditEventType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVOICE_CREATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"invoice_created\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVOICE_FINALIZED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"invoice_finalized\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAYMENT_INITIATED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"payment_initiated\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAYMENT_SUCCEEDED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"payment_succeeded\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAYMENT_FAILED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"payment_failed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CREDIT_APPLIED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"credit_applied\"</span></span></code></pre></div>\n\n<p>This infrastructure provides type-safe financial operations with proper decimal precision and comprehensive audit trails. The <code>Money</code> class ensures all calculations maintain cent-level accuracy.</p>\n<h4 id=\"payment-gateway-integration-skeleton\">Payment Gateway Integration Skeleton</h4>\n<p>The payment gateway integration requires careful abstraction to support multiple payment providers:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PaymentStatus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PENDING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"pending\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PROCESSING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"processing\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUCCEEDED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"succeeded\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FAILED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"failed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    REQUIRES_ACTION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"requires_action\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PaymentMethod</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payment_method_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    customer_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payment_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    last_four: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expiration_month: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expiration_year: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_default: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metadata: Dict </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PaymentResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payment_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status: PaymentStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    amount: Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payment_method_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gateway_transaction_id: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failure_reason: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    requires_action: Optional[Dict] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metadata: Dict </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PaymentGatewayInterface</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Abstract interface for payment gateway implementations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_charge</span><span style=\"color:#E1E4E8\">(self, amount: Money, payment_method_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     idempotency_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, metadata: Dict) -> PaymentResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Initiate a payment charge.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate payment amount is positive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Retrieve payment method details from gateway</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create charge request with gateway-specific parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle immediate gateway response (success/failure/processing)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return standardized PaymentResult</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> retrieve_charge</span><span style=\"color:#E1E4E8\">(self, charge_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> PaymentResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get current status of an existing charge.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Make gateway API call to retrieve charge details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Map gateway response to standardized PaymentResult</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle gateway errors and timeouts gracefully</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_webhook</span><span style=\"color:#E1E4E8\">(self, webhook_payload: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, signature: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[Dict]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process incoming webhook from payment gateway.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Verify webhook signature for security</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Parse webhook payload and extract event type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate event structure and required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return standardized event data or None if invalid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_customer_payment_methods</span><span style=\"color:#E1E4E8\">(self, customer_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span><span style=\"color:#E1E4E8\">) -> List[PaymentMethod]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Retrieve all payment methods for a customer.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Look up gateway customer ID from local mapping</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Fetch payment methods from gateway API</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Convert gateway response to PaymentMethod objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> StripeGateway</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PaymentGatewayInterface</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Stripe-specific implementation of payment gateway interface.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, api_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, webhook_secret: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.api_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> api_key</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.webhook_secret </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> webhook_secret</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize Stripe SDK with API key</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_charge</span><span style=\"color:#E1E4E8\">(self, amount: Money, payment_method_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     idempotency_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, metadata: Dict) -> PaymentResult:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Convert Money amount to Stripe's expected integer cents</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Build Stripe PaymentIntent creation request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Include idempotency key in request headers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle Stripe-specific response format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Map Stripe status to PaymentStatus enum</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use stripe.PaymentIntent.create() with confirm=True for immediate processing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p>The gateway abstraction enables testing with mock implementations and simplifies switching between payment providers. Each concrete implementation handles provider-specific API details while maintaining consistent interfaces.</p>\n<h4 id=\"webhook-processing-service\">Webhook Processing Service</h4>\n<p>Reliable webhook processing requires careful handling of authentication, deduplication, and failure recovery:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hmac</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> WebhookEvent</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gateway_event_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    processed_at: Optional[datetime]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idempotency_key: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    processing_attempts: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_at: datetime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=lambda</span><span style=\"color:#E1E4E8\">: datetime.now(timezone.utc))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> WebhookProcessor</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Handles payment gateway webhook processing with idempotency and retry logic.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, payment_gateway: PaymentGatewayInterface, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 database_manager: DatabaseManager):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.payment_gateway </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> payment_gateway</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> database_manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_webhook</span><span style=\"color:#E1E4E8\">(self, raw_payload: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, signature: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process incoming webhook with full error handling and deduplication.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Verify webhook signature using payment gateway</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Parse payload and extract gateway event ID for idempotency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check if this webhook has been processed before</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If duplicate, return success without processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Process webhook event and update relevant entities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Record successful processing in webhook event log</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Handle processing failures with appropriate error responses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use payment_gateway.process_webhook() for signature verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_payment_succeeded</span><span style=\"color:#E1E4E8\">(self, event_data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle successful payment webhook events.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract payment intent ID and amount from event data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Find corresponding invoice by payment intent reference</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Update invoice status to PAID in database transaction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Update subscription status to active if payment resolves past due</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Apply any remaining credit balance to customer account</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Log audit event for payment completion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Trigger customer notification for successful payment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_payment_failed</span><span style=\"color:#E1E4E8\">(self, event_data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle failed payment webhook events.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract payment failure details and error codes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Find corresponding invoice and update status to PAST_DUE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Determine if failure is retryable or permanent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Schedule dunning retry if appropriate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Update subscription status based on dunning policy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Log failure reason and next retry time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Notify customer of payment failure with resolution options</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_webhook_signature</span><span style=\"color:#E1E4E8\">(self, payload: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, signature: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify webhook authenticity using HMAC signature.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract timestamp and signature from header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Build expected signature using webhook secret and payload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Compare signatures using constant-time comparison</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check timestamp to prevent replay attacks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return True only if signature and timestamp are valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use hmac.compare_digest() for constant-time comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p>The webhook processor handles the complex orchestration between payment events and billing system state. Proper idempotency protection prevents duplicate processing even under high webhook volumes.</p>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing the invoicing and payment processing components, verify functionality with these checkpoints:</p>\n<p><strong>Invoice Generation Verification:</strong></p>\n<ol>\n<li>Create a subscription with usage events and run invoice generation</li>\n<li>Verify invoice contains correct line items for base subscription, usage overages, and credits</li>\n<li>Check that all monetary calculations use integer cents and sum correctly</li>\n<li>Confirm invoice status transitions from <code>draft</code> to <code>open</code> after finalization</li>\n<li>Test proration calculations by changing plans mid-cycle</li>\n</ol>\n<p><strong>Payment Processing Verification:</strong></p>\n<ol>\n<li>Submit a charge request and verify immediate response handling</li>\n<li>Simulate webhook events using payment gateway&#39;s testing tools</li>\n<li>Confirm webhook deduplication by sending the same event twice</li>\n<li>Test payment failure handling and dunning process initiation</li>\n<li>Verify subscription status updates correctly based on payment outcomes</li>\n</ol>\n<p><strong>Integration Testing:</strong></p>\n<ol>\n<li>Run complete billing cycle from subscription renewal to payment completion</li>\n<li>Test webhook processing under simulated network delays and failures</li>\n<li>Verify audit trail captures all financial operations with proper attribution</li>\n<li>Confirm currency precision maintained throughout all calculation steps</li>\n</ol>\n<p>Expected behavior: Invoices should generate deterministically with identical line items for the same input data. Payment processing should handle both synchronous and asynchronous flows gracefully. All webhook events should process exactly once even under adverse network conditions.</p>\n<p><img src=\"/api/project/subscription-billing/architecture-doc/asset?path=diagrams%2Fbilling-cycle-sequence.svg\" alt=\"Monthly Billing Cycle Sequence\"></p>\n<p><img src=\"/api/project/subscription-billing/architecture-doc/asset?path=diagrams%2Fpayment-webhook-sequence.svg\" alt=\"Payment Webhook Processing\"></p>\n<h2 id=\"component-interactions-and-data-flow\">Component Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - describes how components from plan management (Milestone 1), subscription lifecycle (Milestone 2), proration (Milestone 3), and usage-based billing (Milestone 4) work together</p>\n</blockquote>\n<h3 id=\"mental-model-orchestra-coordination\">Mental Model: Orchestra Coordination</h3>\n<p>Think of the subscription billing system like a symphony orchestra performing a complex piece. Each component is a section of musicians (strings, brass, woodwinds, percussion) with their own specialized skills, but they must coordinate precisely to create beautiful music. The conductor (our event orchestration layer) ensures each section comes in at the right time with the right volume. When a customer upgrades their plan, it&#39;s like a musical transition where the strings fade out while the brass section crescendos - multiple components must work together seamlessly to create the desired effect without jarring the audience (our customers).</p>\n<p>Just as musicians pass musical phrases between sections, our billing components pass data and events between each other. The subscription lifecycle component might start a &quot;melody&quot; by creating a new subscription, which the plan management component harmonizes by applying pricing rules, while the usage tracker adds percussion by measuring consumption, and finally the invoice generator brings it all together in the finale. When something goes wrong - like a musician missing their cue - the other sections must adapt gracefully to maintain the performance.</p>\n<p>This mental model helps us understand that component interactions aren&#39;t just technical plumbing - they&#39;re choreographed workflows where timing, sequencing, and error handling are critical to delivering a smooth customer experience.</p>\n<p><img src=\"/api/project/subscription-billing/architecture-doc/asset?path=diagrams%2Fsystem-architecture.svg\" alt=\"System Component Architecture\"></p>\n<p>The subscription billing system orchestrates complex interactions between multiple specialized components. Each component has clear responsibilities, but they must coordinate precisely during key operations like subscription creation, monthly billing cycles, and plan changes. Understanding these interaction patterns is crucial for building a reliable billing system that maintains data consistency and provides a smooth customer experience.</p>\n<h3 id=\"subscription-creation-flow\">Subscription Creation Flow</h3>\n<p>The subscription creation flow represents one of the most critical workflows in the billing system. It involves coordinating between plan management, payment processing, usage tracking initialization, and subscription state management. This flow must handle complex scenarios like trial periods, immediate charges, proration for mid-month starts, and graceful error recovery if any step fails.</p>\n<h4 id=\"end-to-end-process-flow\">End-to-End Process Flow</h4>\n<p>The subscription creation process follows a carefully orchestrated sequence that ensures data consistency and proper financial accounting. The flow begins when a customer selects a plan and provides payment information, and concludes with an active subscription that&#39;s ready for billing and usage tracking.</p>\n<p><strong>Step 1: Plan Validation and Feature Resolution</strong>\nThe process starts with the Plan Management Component validating the selected plan and resolving all pricing and feature information. This includes checking plan availability, ensuring the plan supports the requested billing interval, and loading the complete feature entitlement matrix. The component also determines if the plan includes trial periods or requires immediate payment.</p>\n<p><strong>Step 2: Customer Credit Check and Payment Method Validation</strong>\nThe system checks the customer&#39;s existing credit balance and validates the provided payment method through the Payment Gateway integration. This step ensures the customer has sufficient funds or valid payment instruments before proceeding with subscription creation. The payment method is tokenized for future recurring charges.</p>\n<p><strong>Step 3: Proration Calculation for Mid-Cycle Start</strong>\nIf the subscription starts mid-cycle (not on the standard billing anchor day), the Proration Calculator determines the prorated charge for the partial billing period. This calculation considers the plan&#39;s billing interval, the current date, and the customer&#39;s preferred billing anchor day to ensure fair charging for partial periods.</p>\n<p><strong>Step 4: Initial Invoice Generation</strong>\nThe Invoice Generator creates the first invoice for the subscription, including any trial period handling, prorated charges, setup fees, and applicable taxes. If the customer has existing credit balance, it&#39;s automatically applied to reduce the invoice amount. The invoice includes detailed line items showing exactly what the customer is being charged for.</p>\n<p><strong>Step 5: Payment Processing and Authorization</strong>\nThe Payment Processor attempts to charge the customer&#39;s payment method for any immediate amounts due. For trial subscriptions, this might only authorize the payment method without charging. The system handles various payment scenarios including successful charges, failed payments, and payment methods requiring additional authentication.</p>\n<p><strong>Step 6: Subscription Record Creation and State Initialization</strong>\nUpon successful payment (or trial authorization), the Subscription Engine creates the subscription record with the appropriate initial state. Trial subscriptions start in <code>trialing</code> status, while paid subscriptions begin in <code>active</code> status. The subscription includes billing anchor calculation, next billing date determination, and feature entitlement activation.</p>\n<p><strong>Step 7: Usage Tracking Initialization</strong>\nThe Usage-Based Billing Engine initializes usage tracking for the new subscription. This includes setting up usage allowances based on the plan, creating initial usage aggregation records, and configuring any quota limits. The system prepares to track metered usage from the subscription start date.</p>\n<p><strong>Step 8: Welcome Communications and Service Provisioning</strong>\nFinally, the system triggers welcome communications to the customer and provisions access to subscribed services. This includes sending confirmation emails, updating customer portal access, and notifying downstream services about the new subscription and its feature entitlements.</p>\n<h4 id=\"component-interaction-patterns\">Component Interaction Patterns</h4>\n<p>The subscription creation flow demonstrates several important interaction patterns that appear throughout the billing system. Understanding these patterns helps developers build consistent and reliable workflows.</p>\n<p><img src=\"/api/project/subscription-billing/architecture-doc/asset?path=diagrams%2Fbilling-cycle-sequence.svg\" alt=\"Monthly Billing Cycle Sequence\"></p>\n<table>\n<thead>\n<tr>\n<th>Interaction Pattern</th>\n<th>Description</th>\n<th>Components Involved</th>\n<th>Data Exchanged</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Synchronous Validation</td>\n<td>Immediate validation with error response</td>\n<td>Plan Management, Payment Gateway</td>\n<td>Plan details, payment method validation</td>\n</tr>\n<tr>\n<td>Asynchronous Processing</td>\n<td>Background tasks triggered by events</td>\n<td>Invoice Generator, Email Service</td>\n<td>Subscription events, notification requests</td>\n</tr>\n<tr>\n<td>Transactional Coordination</td>\n<td>Multi-step operations with rollback capability</td>\n<td>Database Manager, All Components</td>\n<td>Entity creation, state changes</td>\n</tr>\n<tr>\n<td>Event-Driven Updates</td>\n<td>Components react to subscription lifecycle events</td>\n<td>Event Bus, Usage Tracker, Audit Logger</td>\n<td>Subscription events, audit records</td>\n</tr>\n<tr>\n<td>Credit Application</td>\n<td>Automatic credit consumption during billing</td>\n<td>Credit Balance Manager, Invoice Generator</td>\n<td>Credit amounts, invoice adjustments</td>\n</tr>\n</tbody></table>\n<p><strong>Error Handling and Rollback Scenarios</strong></p>\n<p>The subscription creation flow must handle various failure modes gracefully. Each step in the process includes specific error handling and rollback procedures to ensure the system remains in a consistent state.</p>\n<p>If payment processing fails after the subscription record is created, the system automatically transitions the subscription to <code>incomplete</code> status and schedules payment retry attempts. The customer retains access to trial features but cannot access paid features until payment succeeds.</p>\n<p>When plan validation fails due to plan unavailability or pricing errors, the system returns detailed error messages to help customers select alternative plans. No subscription record is created, and no charges are attempted.</p>\n<p>Database transaction failures during subscription creation trigger automatic rollback of all related records, including invoice line items, usage tracking setup, and payment authorizations. The system logs detailed error information for debugging while providing user-friendly error messages to customers.</p>\n<h4 id=\"data-consistency-guarantees\">Data Consistency Guarantees</h4>\n<p>The subscription creation flow maintains strict data consistency through several mechanisms. All financial operations occur within database transactions with serializable isolation levels to prevent race conditions. The system uses idempotency keys to ensure duplicate subscription creation requests don&#39;t result in multiple charges or subscriptions.</p>\n<p>Event publishing follows the transactional outbox pattern, where events are written to the database as part of the same transaction that creates the subscription, then published asynchronously. This ensures that downstream systems receive notifications about all successfully created subscriptions without missing events due to system failures.</p>\n<p>The flow also implements compensation patterns for distributed operations. If payment succeeds but subscription creation fails, the system automatically initiates refund processing to prevent charging customers for non-existent subscriptions.</p>\n<h3 id=\"monthly-billing-cycle-flow\">Monthly Billing Cycle Flow</h3>\n<p>The monthly billing cycle represents the heartbeat of the subscription system. This process runs automatically for all active subscriptions, calculating charges, applying usage-based billing, processing payments, and handling failures. The billing cycle must process potentially thousands of subscriptions reliably while maintaining strict financial accuracy and providing detailed audit trails.</p>\n<h4 id=\"billing-cycle-orchestration\">Billing Cycle Orchestration</h4>\n<p>The billing cycle operates as a distributed workflow that processes subscriptions in carefully coordinated stages. The system uses a combination of scheduled triggers and event-driven processing to ensure reliable execution even during high-volume periods or system failures.</p>\n<p><strong>Stage 1: Billing Period Identification and Subscription Selection</strong>\nThe billing process begins by identifying all subscriptions due for renewal on the current date. The system queries subscriptions where the next billing date matches the current date and the subscription status allows billing (active, trialing with trial ending). This selection process considers timezone differences to ensure customers are billed at the appropriate time in their local timezone.</p>\n<p>The system also identifies subscriptions transitioning from trial to paid status on the current date. These subscriptions require special handling to activate paid features and process the first recurring charge.</p>\n<p><strong>Stage 2: Usage Aggregation and Overage Calculation</strong>\nFor each subscription due for billing, the Usage-Based Billing Engine aggregates all usage events from the previous billing period. This aggregation process totals consumption by usage type and compares against plan allowances to calculate any overage charges.</p>\n<p>The aggregation uses precise billing period boundaries, starting from the last billing date (inclusive) to the current billing date (exclusive). This ensures usage is attributed to the correct billing period even when usage events arrive with slight timestamp delays.</p>\n<p><strong>Stage 3: Invoice Generation with Line Item Breakdown</strong>\nThe Invoice Generator creates detailed invoices for each subscription, including multiple line item types. Base subscription charges appear as recurring line items, while usage overages create separate metered line items with quantity and rate breakdowns.</p>\n<p>The invoice generation process automatically applies any existing customer credit balance, reducing the total amount due. Credits are consumed on a first-in-first-out basis, with detailed line items showing credit application amounts and remaining balances.</p>\n<p><strong>Stage 4: Payment Processing and Retry Logic</strong>\nThe Payment Processor attempts to charge each customer&#39;s default payment method for the invoice total. The system implements intelligent retry logic for failed payments, using exponential backoff and multiple payment method fallback.</p>\n<p>Successful payments immediately mark invoices as paid and maintain subscription active status. Failed payments trigger the dunning management process, transitioning subscriptions to <code>past_due</code> status and scheduling retry attempts.</p>\n<p><strong>Stage 5: Subscription Renewal and Next Billing Date Calculation</strong>\nSuccessfully billed subscriptions have their subscription records updated with new billing period information. The system calculates the next billing date based on the subscription&#39;s billing interval and billing anchor day, handling edge cases like month-end dates and leap years.</p>\n<p>The subscription&#39;s feature entitlements are refreshed based on the current plan version, and usage allowances are reset for the new billing period. Any plan changes scheduled for the renewal date are applied at this stage.</p>\n<p><strong>Stage 6: Usage Tracking Reset and Quota Reactivation</strong>\nThe Usage-Based Billing Engine resets usage tracking for the new billing period. Previous period usage is archived for reporting purposes, while current period counters are zeroed out. Any quota restrictions imposed due to overage in the previous period are lifted if payment succeeded.</p>\n<p>The system also recalculates usage limits based on any plan changes that took effect during renewal, ensuring customers have access to their updated usage allowances immediately.</p>\n<h4 id=\"failure-handling-and-recovery\">Failure Handling and Recovery</h4>\n<p>The monthly billing cycle implements comprehensive failure handling to ensure financial accuracy and customer satisfaction. Each stage of the billing process includes specific failure modes and recovery procedures.</p>\n<p><strong>Payment Failure Recovery</strong>\nWhen payment processing fails, the system distinguishes between temporary failures (insufficient funds, network issues) and permanent failures (expired cards, closed accounts). Temporary failures trigger automatic retry attempts with increasing delays, while permanent failures require customer intervention to update payment methods.</p>\n<p>The dunning management system sends progressively more urgent communications to customers about failed payments, while maintaining service access for a grace period. Customers retain access to their subscribed services but may have certain features restricted until payment succeeds.</p>\n<p><strong>Usage Aggregation Failures</strong>\nIf usage aggregation fails for a subscription, the billing cycle continues with base subscription charges while marking the usage calculation for manual review. This ensures customers aren&#39;t blocked from service due to usage tracking issues, while finance teams can resolve discrepancies later.</p>\n<p>The system maintains detailed logs of aggregation failures, including which usage events couldn&#39;t be processed and why. This information enables rapid resolution of billing disputes and usage tracking bugs.</p>\n<p><strong>Database Consistency During High Volume</strong>\nDuring peak billing periods, the system uses optimistic locking and retry mechanisms to handle database contention. Each subscription&#39;s billing operation occurs within its own transaction to prevent failures in one subscription from affecting others.</p>\n<p>The billing process can be safely restarted at any stage, using idempotency keys and billing status flags to resume from the last successful checkpoint. This allows the system to recover quickly from infrastructure failures during critical billing windows.</p>\n<h4 id=\"performance-and-scalability-considerations\">Performance and Scalability Considerations</h4>\n<p>The monthly billing cycle must handle varying loads efficiently, from systems with hundreds of subscriptions to enterprise platforms processing millions of renewals. The system uses several techniques to maintain performance at scale.</p>\n<p><strong>Batch Processing with Parallel Execution</strong>\nSubscriptions are processed in configurable batch sizes, with multiple batches running in parallel. The batch size balances memory usage against processing efficiency, while parallel execution utilizes available system resources effectively.</p>\n<p>Each batch processes subscriptions independently, allowing the system to scale horizontally by adding more worker processes or servers. Failed batches can be retried independently without affecting successful processing.</p>\n<p><strong>Database Query Optimization</strong>\nThe billing process uses optimized database queries with appropriate indexes on billing-related fields. Usage aggregation queries use time-range partitioning to scan only relevant data, while subscription selection queries use compound indexes on status and next billing date.</p>\n<p>The system pre-loads related data (plans, payment methods, customer information) in batch queries to minimize database round-trips during processing. This approach significantly reduces the per-subscription processing time.</p>\n<p><strong>Memory Management and Resource Cleanup</strong>\nLarge-scale billing operations carefully manage memory usage to prevent out-of-memory errors during peak periods. Usage aggregation results are processed in streaming fashion rather than loading entire datasets into memory.</p>\n<p>The system includes monitoring and alerting for billing cycle performance, tracking metrics like processing time per subscription, memory usage, and error rates. This visibility enables proactive capacity planning and performance optimization.</p>\n<h3 id=\"plan-change-and-proration-flow\">Plan Change and Proration Flow</h3>\n<p>Plan changes represent some of the most complex operations in subscription billing, requiring careful coordination between multiple components to ensure accurate financial calculations and smooth customer experience. The process must handle upgrades, downgrades, immediate changes, scheduled changes, and various edge cases while maintaining strict financial accuracy.</p>\n<p><img src=\"/api/project/subscription-billing/architecture-doc/asset?path=diagrams%2Fplan-change-flow.svg\" alt=\"Plan Change and Proration Flow\"></p>\n<h4 id=\"plan-change-orchestration-workflow\">Plan Change Orchestration Workflow</h4>\n<p>The plan change process follows a sophisticated workflow that balances customer expectations with financial precision. Customers expect plan changes to take effect immediately or at predictable times, while the billing system must ensure accurate proration and proper credit handling.</p>\n<p><strong>Phase 1: Plan Change Validation and Authorization</strong>\nThe process begins with comprehensive validation of the requested plan change. The Plan Management Component verifies that the target plan is available, supports the customer&#39;s billing preferences, and allows the specific transition from the current plan.</p>\n<p>The system checks whether the change represents an upgrade (higher cost) or downgrade (lower cost) to determine the appropriate proration and payment handling. Upgrade validations include verifying the customer&#39;s payment method can handle additional charges, while downgrades require checking refund policies and credit balance limits.</p>\n<p>Authorization checks ensure the customer has permission to make plan changes and hasn&#39;t exceeded any change frequency limits. Some businesses restrict plan changes to prevent abuse or reduce support complexity.</p>\n<p><strong>Phase 2: Proration Calculation and Financial Impact Analysis</strong>\nThe Proration Calculator performs detailed financial analysis of the plan change, determining exactly how much the customer should be charged or credited. This calculation considers the time remaining in the current billing period, the difference between old and new plan pricing, and any usage-based charges that need adjustment.</p>\n<p>For upgrades, the system calculates the prorated charge for the remaining days in the billing cycle at the new plan rate, minus the value of unused time at the old rate. For downgrades, it calculates credits for the unused portion of the higher-priced plan.</p>\n<p>The calculation also considers usage allowances and overages. If the new plan has different usage limits, the system recalculates overage charges based on current period usage and the new plan&#39;s allowances.</p>\n<p><strong>Phase 3: Invoice Adjustment and Credit Processing</strong>\nBased on the proration calculation, the Invoice Generator creates adjustment line items for the customer&#39;s next invoice or generates an immediate invoice for upgrades requiring payment. Credit adjustments are processed through the Credit Balance Manager to ensure proper accounting and audit trails.</p>\n<p>Upgrades typically result in immediate charges for the prorated difference, while downgrades create credits applied to future invoices. The system generates detailed line items explaining each adjustment to provide transparency to customers and support teams.</p>\n<p><strong>Phase 4: Subscription Record Updates and Feature Activation</strong>\nThe Subscription Engine updates the subscription record with the new plan information, adjusting feature entitlements immediately. Customers gain access to new features right away, even if the financial adjustments are processed asynchronously.</p>\n<p>The subscription&#39;s next billing date remains unchanged to maintain the existing billing cycle anchor. However, the system records the plan change effective date for accurate future billing calculations.</p>\n<p><strong>Phase 5: Usage Tracking Adjustment and Quota Updates</strong>\nThe Usage-Based Billing Engine adjusts usage tracking for the new plan&#39;s allowances and quotas. If the new plan includes higher usage limits, those become available immediately. If the new plan has lower limits and current usage exceeds them, the system applies appropriate overage charges or quota restrictions.</p>\n<p>Usage tracking maintains historical records of plan changes to ensure accurate aggregation and billing at the end of the billing period. Each usage event is associated with the plan that was active when the usage occurred.</p>\n<p><strong>Phase 6: Downstream Service Notifications and Access Updates</strong>\nFinally, the system notifies all downstream services about the plan change and updated feature entitlements. This includes updating customer portal access, API rate limits, storage quotas, and any other plan-dependent service configurations.</p>\n<p>These notifications use the event-driven architecture to ensure all services receive updates without requiring direct coupling between the billing system and service implementations.</p>\n<h4 id=\"complex-proration-scenarios\">Complex Proration Scenarios</h4>\n<p>The plan change flow must handle numerous complex scenarios that arise in real-world billing operations. Each scenario requires specific handling to ensure fairness and accuracy.</p>\n<p><strong>Multiple Plan Changes Within a Billing Period</strong>\nWhen customers make multiple plan changes within a single billing period, the system maintains a chronological record of all changes and calculates cumulative proration effects. Each change is treated as a separate proration calculation, with the effective date determining how much of the billing period applies to each plan.</p>\n<p>The system prevents proration gaming by tracking change frequency and applying business rules about minimum time between changes or maximum changes per period. This protects against customers attempting to exploit proration calculations.</p>\n<p><strong>Plan Changes with Different Billing Intervals</strong>\nChanging from monthly to annual billing (or vice versa) requires special handling since the billing cycles don&#39;t align. The system calculates proration for the remainder of the current billing cycle, then schedules the subscription for renewal on the new billing interval.</p>\n<p>These changes often involve significant proration amounts, either charging for several months upfront (monthly to annual) or crediting unused annual subscription time (annual to monthly). The system provides clear explanations of these calculations to customers.</p>\n<p><strong>Usage-Based Plan Changes with Existing Consumption</strong>\nWhen changing plans mid-cycle with existing usage consumption, the system must recalculate overage charges based on each plan&#39;s allowances and rates. Usage that was within allowances under the old plan might become overage under a new plan with lower limits.</p>\n<p>The system applies a fairness algorithm that ensures customers aren&#39;t double-charged for usage but also aren&#39;t given unfair advantages by switching plans to avoid overage charges they&#39;ve already incurred.</p>\n<h4 id=\"error-handling-and-rollback-mechanisms\">Error Handling and Rollback Mechanisms</h4>\n<p>Plan changes involve multiple financial and operational systems, creating numerous potential failure points. The system implements comprehensive error handling and rollback capabilities to maintain consistency.</p>\n<p><strong>Financial Rollback for Payment Failures</strong>\nIf a plan upgrade requires immediate payment and the charge fails, the system automatically rolls back the plan change, restoring the previous plan and feature entitlements. Any credits or adjustments created during the change process are reversed.</p>\n<p>The rollback process maintains audit trails of both the attempted change and the rollback, ensuring complete transparency for customer service and accounting teams.</p>\n<p><strong>Partial Failure Recovery</strong>\nWhen some aspects of a plan change succeed (like updating the subscription record) but others fail (like processing payments or updating downstream services), the system uses compensation patterns to restore consistency.</p>\n<p>The system maintains a plan change state machine that tracks the progress of each change operation, enabling automatic retry of failed steps or manual intervention when necessary.</p>\n<p><strong>Data Consistency During Concurrent Operations</strong>\nPlan changes use optimistic locking to prevent conflicts when multiple operations target the same subscription simultaneously. If a plan change conflicts with billing cycle processing or other operations, the system queues the change for execution after the conflicting operation completes.</p>\n<p>This approach ensures that plan changes don&#39;t interfere with critical billing operations while still providing responsive plan change processing for customers.</p>\n<blockquote>\n<p><strong>Key Design Insight</strong>: The component interaction patterns in subscription billing mirror those found in distributed financial systems - they require careful coordination, comprehensive error handling, and strong consistency guarantees. The complexity arises not from individual operations but from the interactions between components that must maintain financial accuracy while providing responsive customer experiences.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The component interaction flows represent the most complex aspects of subscription billing implementation. These workflows coordinate multiple specialized components and require careful attention to error handling, data consistency, and performance. The following guidance provides concrete starting points for implementing these critical system workflows.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Workflow Orchestration</td>\n<td>Direct function calls with try/catch</td>\n<td>Temporal.io or Conductor workflow engine</td>\n</tr>\n<tr>\n<td>Event Publishing</td>\n<td>In-memory event bus with immediate processing</td>\n<td>Apache Kafka with persistent message queues</td>\n</tr>\n<tr>\n<td>Database Transactions</td>\n<td>Single database with ACID transactions</td>\n<td>Distributed transactions with saga pattern</td>\n</tr>\n<tr>\n<td>Error Recovery</td>\n<td>Manual retry with exponential backoff</td>\n<td>Circuit breaker pattern with automatic failover</td>\n</tr>\n<tr>\n<td>Monitoring</td>\n<td>Structured logging with correlation IDs</td>\n<td>Distributed tracing with OpenTelemetry</td>\n</tr>\n<tr>\n<td>State Management</td>\n<td>Database-backed state machines</td>\n<td>Redis-based distributed state with TTL</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>subscription-billing/\n├── internal/\n│   ├── workflows/                    ← component interaction orchestration\n│   │   ├── subscription_creation.py  ← subscription creation workflow\n│   │   ├── billing_cycle.py         ← monthly billing cycle workflow\n│   │   ├── plan_change.py           ← plan change and proration workflow\n│   │   └── workflow_base.py         ← common workflow infrastructure\n│   ├── events/                      ← event-driven communication\n│   │   ├── event_bus.py             ← event publishing and subscription\n│   │   ├── event_types.py           ← event type definitions\n│   │   └── handlers/                ← event handler implementations\n│   │       ├── audit_handler.py     ← audit trail event handler\n│   │       ├── notification_handler.py ← customer notification handler\n│   │       └── analytics_handler.py  ← usage analytics handler\n│   ├── coordinators/                ← workflow coordination logic\n│   │   ├── billing_coordinator.py   ← coordinates billing cycle operations\n│   │   ├── payment_coordinator.py   ← coordinates payment processing\n│   │   └── proration_coordinator.py ← coordinates proration calculations\n│   └── state_machines/              ← subscription state management\n│       ├── subscription_state.py    ← subscription lifecycle state machine\n│       ├── invoice_state.py         ← invoice processing state machine\n│       └── payment_state.py         ← payment processing state machine\n├── tests/\n│   ├── integration/                 ← end-to-end workflow tests\n│   │   ├── test_subscription_creation_flow.py\n│   │   ├── test_billing_cycle_flow.py\n│   │   └── test_plan_change_flow.py\n│   └── workflows/                   ← workflow unit tests\n└── scripts/\n    ├── run_billing_cycle.py         ← manual billing cycle trigger\n    └── fix_failed_subscriptions.py  ← recovery script for failed operations</code></pre></div>\n\n<h4 id=\"workflow-infrastructure-starter-code\">Workflow Infrastructure Starter Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># internal/workflows/workflow_base.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> WorkflowStatus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PENDING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"pending\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RUNNING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"running\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    COMPLETED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"completed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FAILED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"failed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    COMPENSATING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"compensating\"</span><span style=\"color:#6A737D\">  # rolling back due to failure</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> WorkflowStep</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    step_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status: WorkflowStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    input_data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    output_data: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    error_message: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    started_at: Optional[datetime] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    completed_at: Optional[datetime] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retry_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> WorkflowExecution</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    execution_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    workflow_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status: WorkflowStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    input_data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    steps: List[WorkflowStep]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_at: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    updated_at: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    correlation_id: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> WorkflowExecutor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all workflow executors that coordinate component interactions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, db_manager: DatabaseManager, event_bus: EventBus):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db_manager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> db_manager</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.event_bus </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> event_bus</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_retries </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_workflow_steps</span><span style=\"color:#E1E4E8\">(self) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return ordered list of step names for this workflow.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> execute_step</span><span style=\"color:#E1E4E8\">(self, step_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, step_input: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          execution: WorkflowExecution) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute a single workflow step and return output data.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> compensate_step</span><span style=\"color:#E1E4E8\">(self, step_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, step_output: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                             execution: WorkflowExecution) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Rollback/compensate for a completed step during failure recovery.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> execute_workflow</span><span style=\"color:#E1E4E8\">(self, input_data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              correlation_id: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> WorkflowExecution:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute complete workflow with error handling and compensation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        execution_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(uuid.uuid4())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        execution </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> WorkflowExecution(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            execution_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">execution_id,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            workflow_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__class__</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            status</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">WorkflowStatus.</span><span style=\"color:#79B8FF\">PENDING</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            input_data</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">input_data,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            steps</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            created_at</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">datetime.utcnow(),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            updated_at</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">datetime.utcnow(),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            correlation_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">correlation_id</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Initialize workflow steps</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> step_name </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.get_workflow_steps():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            step </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> WorkflowStep(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                step_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(uuid.uuid4()),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                name</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">step_name, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                status</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">WorkflowStatus.</span><span style=\"color:#79B8FF\">PENDING</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                input_data</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            execution.steps.append(step)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Persist initial workflow state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._save_execution(execution)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            execution.status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> WorkflowStatus.</span><span style=\"color:#79B8FF\">RUNNING</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._save_execution(execution)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Execute each step in sequence</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            step_input </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> input_data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> step </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> execution.steps:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                step.input_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> step_input</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                step.status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> WorkflowStatus.</span><span style=\"color:#79B8FF\">RUNNING</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                step.started_at </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> datetime.utcnow()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._save_execution(execution)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    step_output </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.execute_step(step.name, step_input, execution)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    step.output_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> step_output</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    step.status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> WorkflowStatus.</span><span style=\"color:#79B8FF\">COMPLETED</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    step.completed_at </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> datetime.utcnow()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    step_input </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> step_output  </span><span style=\"color:#6A737D\"># Output becomes input for next step</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    step.status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> WorkflowStatus.</span><span style=\"color:#79B8FF\">FAILED</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    step.error_message </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(e)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    step.completed_at </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> datetime.utcnow()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._save_execution(execution)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Trigger compensation workflow</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._compensate_workflow(execution)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    raise</span><span style=\"color:#E1E4E8\"> e</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._save_execution(execution)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            execution.status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> WorkflowStatus.</span><span style=\"color:#79B8FF\">COMPLETED</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            execution.updated_at </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> datetime.utcnow()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._save_execution(execution)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Publish workflow completion event</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.event_bus.publish(SubscriptionEvent(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                event_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">uuid.uuid4(),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                event_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">SubscriptionEventType.</span><span style=\"color:#79B8FF\">WORKFLOW_COMPLETED</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                subscription_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">input_data.get(</span><span style=\"color:#9ECBFF\">'subscription_id'</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                data</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">'execution_id'</span><span style=\"color:#E1E4E8\">: execution_id, </span><span style=\"color:#9ECBFF\">'workflow_type'</span><span style=\"color:#E1E4E8\">: execution.workflow_type},</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                idempotency_key</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"workflow_completed_</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">execution_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                created_at</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">datetime.utcnow()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> execution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            execution.status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> WorkflowStatus.</span><span style=\"color:#79B8FF\">FAILED</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            execution.updated_at </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> datetime.utcnow()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._save_execution(execution)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Workflow </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">execution_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> failed: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _compensate_workflow</span><span style=\"color:#E1E4E8\">(self, execution: WorkflowExecution) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute compensation steps in reverse order for failed workflow.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        execution.status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> WorkflowStatus.</span><span style=\"color:#79B8FF\">COMPENSATING</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._save_execution(execution)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Compensate completed steps in reverse order</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        completed_steps </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [s </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> s </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> reversed</span><span style=\"color:#E1E4E8\">(execution.steps) </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                          if</span><span style=\"color:#E1E4E8\"> s.status </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> WorkflowStatus.</span><span style=\"color:#79B8FF\">COMPLETED</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> step </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> completed_steps:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.compensate_step(step.name, step.output_data </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}, execution)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                logger.info(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Compensated step </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">step.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> for workflow </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">execution.execution_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Failed to compensate step </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">step.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Continue compensation of other steps even if one fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _save_execution</span><span style=\"color:#E1E4E8\">(self, execution: WorkflowExecution) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Persist workflow execution state to database.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement workflow execution persistence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # This should save the complete execution state including all steps</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # to allow for workflow recovery and monitoring</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"event-driven-communication-infrastructure\">Event-Driven Communication Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># internal/events/event_bus.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Callable, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event_id: uuid.</span><span style=\"color:#79B8FF\">UUID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    correlation_id: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idempotency_key: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EventBus</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Event bus for component communication with guaranteed delivery and deduplication.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, db_manager: DatabaseManager):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db_manager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> db_manager</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.handlers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[Callable]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.processed_events: </span><span style=\"color:#79B8FF\">set</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">()  </span><span style=\"color:#6A737D\"># For idempotency</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> subscribe</span><span style=\"color:#E1E4E8\">(self, event_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, handler: Callable[[Event], </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Subscribe handler function to specific event type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> event_type </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.handlers:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.handlers[event_type] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.handlers[event_type].append(handler)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> publish</span><span style=\"color:#E1E4E8\">(self, event: Event) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Publish event to all registered handlers with idempotency protection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check idempotency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> event.idempotency_key </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> event.idempotency_key </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.processed_events:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logger.info(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Skipping duplicate event </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">event.idempotency_key</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Persist event using transactional outbox pattern</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.db_manager.transaction(</span><span style=\"color:#FFAB70\">isolation_level</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">ISOLATION_LEVEL_SERIALIZABLE</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._persist_event(event)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Mark as processed for idempotency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> event.idempotency_key:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">.processed_events.add(event.idempotency_key)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Publish to handlers asynchronously</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._notify_handlers(event)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Failed to publish event </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">event.event_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _persist_event</span><span style=\"color:#E1E4E8\">(self, event: Event) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Persist event to outbox table for guaranteed delivery.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Insert event into outbox table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # This ensures events are never lost even if handler processing fails</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _notify_handlers</span><span style=\"color:#E1E4E8\">(self, event: Event) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Notify all registered handlers for event type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> event.event_type </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.handlers:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tasks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> handler </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.handlers[event.event_type]:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            task </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.create_task(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._safe_handler_call(handler, event))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tasks.append(task)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> tasks:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#E1E4E8\"> asyncio.gather(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">tasks, </span><span style=\"color:#FFAB70\">return_exceptions</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _safe_handler_call</span><span style=\"color:#E1E4E8\">(self, handler: Callable, event: Event) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Call event handler with error isolation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> asyncio.iscoroutinefunction(handler):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                await</span><span style=\"color:#E1E4E8\"> handler(event)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                handler(event)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Event handler </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">handler.</span><span style=\"color:#79B8FF\">__name__}</span><span style=\"color:#9ECBFF\"> failed for event </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">event.event_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Handler failures don't prevent other handlers from running</span></span></code></pre></div>\n\n<h4 id=\"subscription-creation-workflow-implementation\">Subscription Creation Workflow Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># internal/workflows/subscription_creation.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> internal.workflows.workflow_base </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> WorkflowExecutor, WorkflowStep</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> internal.plan_management </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PlanManager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> internal.subscription_engine </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SubscriptionEngine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> internal.proration </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ProrationCalculator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> internal.invoice_generator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> InvoiceGenerator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> internal.payment_processor </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PaymentProcessor</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> internal.usage_tracking </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> UsageTracker</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SubscriptionCreationWorkflow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">WorkflowExecutor</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Orchestrates subscription creation across multiple components.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, db_manager: DatabaseManager, event_bus: EventBus,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 plan_manager: PlanManager, subscription_engine: SubscriptionEngine,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 proration_calculator: ProrationCalculator, invoice_generator: InvoiceGenerator,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 payment_processor: PaymentProcessor, usage_tracker: UsageTracker):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(db_manager, event_bus)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.plan_manager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> plan_manager</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.subscription_engine </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> subscription_engine</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.proration_calculator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proration_calculator</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.invoice_generator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> invoice_generator</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.payment_processor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> payment_processor</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.usage_tracker </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> usage_tracker</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_workflow_steps</span><span style=\"color:#E1E4E8\">(self) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"validate_plan\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"check_customer_credit\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"calculate_proration\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"generate_invoice\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"process_payment\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"create_subscription\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"initialize_usage_tracking\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> execute_step</span><span style=\"color:#E1E4E8\">(self, step_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, step_input: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          execution: WorkflowExecution) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute individual workflow step.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> step_name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"validate_plan\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract plan_id from step_input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call self.plan_manager.get_plan(plan_id) to load plan details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate plan is available and supports requested billing_interval</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check if plan has trial_period_days > 0 for trial handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return dict with plan details, is_trial flag, and validation status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> step_name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"check_customer_credit\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract customer_id from step_input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Get customer credit balance using credit_balance_manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate payment_method_id through payment processor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check if customer has sufficient credit to cover setup fees</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return dict with credit_balance_cents and payment_method_valid flag</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> step_name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"calculate_proration\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract plan details and start_date from step_input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If start_date is mid-cycle, calculate prorated charge using proration_calculator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate billing_cycle_anchor based on customer preference or plan default</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Determine first_billing_date considering trial periods</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return dict with prorated_amount, billing_anchor, first_billing_date</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> step_name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"generate_invoice\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create invoice line items for prorated charges, setup fees, trial periods</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Apply customer credit balance if available using credit_balance_manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate taxes if applicable based on customer location</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Generate invoice using invoice_generator.create_invoice()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return dict with invoice_id, total_amount_cents, and line_item_details</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> step_name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"process_payment\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract invoice total and payment_method_id from step_input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For trial subscriptions, authorize payment method without charging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For paid subscriptions, charge payment method for invoice total</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle payment failures with appropriate error codes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return dict with payment_result, transaction_id, and payment_status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> step_name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"create_subscription\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract all subscription details from previous step outputs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Determine initial subscription status (trialing, active, incomplete)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create subscription record using subscription_engine.create_subscription()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Set next_billing_date based on trial period or billing cycle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return dict with subscription_id, status, and next_billing_date</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> step_name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"initialize_usage_tracking\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract subscription_id and plan details from step_input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Initialize usage allowances based on plan.usage_allowances</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Set up usage quotas and rate limiting if configured</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create initial usage aggregation records for current billing period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return dict with usage_tracking_initialized flag and quota_details</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unknown workflow step: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">step_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> compensate_step</span><span style=\"color:#E1E4E8\">(self, step_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, step_output: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                             execution: WorkflowExecution) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Rollback completed steps during failure recovery.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> step_name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"create_subscription\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Cancel created subscription and mark as incomplete</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            subscription_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> step_output.get(</span><span style=\"color:#9ECBFF\">'subscription_id'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> subscription_id:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.subscription_engine.cancel_subscription(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    subscription_id, </span><span style=\"color:#FFAB70\">immediate</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"workflow_rollback\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> step_name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"process_payment\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Refund any charges that were processed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            payment_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> step_output.get(</span><span style=\"color:#9ECBFF\">'payment_result'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> payment_result </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> payment_result.status </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> PaymentStatus.</span><span style=\"color:#79B8FF\">SUCCEEDED</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.payment_processor.refund_payment(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    payment_result.payment_id, payment_result.amount, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    reason</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"subscription_creation_failed\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> step_name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"generate_invoice\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Mark invoice as void to prevent collection attempts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            invoice_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> step_output.get(</span><span style=\"color:#9ECBFF\">'invoice_id'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> invoice_id:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.invoice_generator.void_invoice(invoice_id, </span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"workflow_failed\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"billing-cycle-workflow-skeleton\">Billing Cycle Workflow Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># internal/workflows/billing_cycle.py  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BillingCycleWorkflow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">WorkflowExecutor</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Orchestrates monthly billing cycle processing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_workflow_steps</span><span style=\"color:#E1E4E8\">(self) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"identify_due_subscriptions\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"aggregate_usage_data\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"calculate_charges\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"generate_invoices\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"process_payments\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"update_subscriptions\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"reset_usage_tracking\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> execute_step</span><span style=\"color:#E1E4E8\">(self, step_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, step_input: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          execution: WorkflowExecution) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> step_name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"identify_due_subscriptions\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Query subscriptions where next_billing_date = current_date</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Filter by status in [active, trialing] and exclude paused/cancelled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Group by customer timezone for accurate billing timing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check for trial subscriptions ending today requiring activation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return dict with subscription_ids list and timezone_groups</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> step_name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"aggregate_usage_data\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: For each subscription, get last_billing_date and current billing date</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call usage_tracker.aggregate_billing_period() for date range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate overage amounts for usage exceeding plan allowances</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle timezone-specific aggregation windows correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return dict with usage_aggregations keyed by subscription_id</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Additional steps follow same pattern...</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Subscription Creation Flow Checkpoint:</strong>\nAfter implementing the subscription creation workflow, verify functionality with these tests:</p>\n<ol>\n<li><p><strong>Successful Creation Test</strong>: Create subscription with valid plan and payment method</p>\n<ul>\n<li>Expected: Subscription in <code>active</code> status, invoice generated and paid, usage tracking initialized</li>\n<li>Command: <code>python -m pytest tests/integration/test_subscription_creation_flow.py::test_successful_creation</code></li>\n</ul>\n</li>\n<li><p><strong>Trial Subscription Test</strong>: Create subscription with trial period</p>\n<ul>\n<li>Expected: Subscription in <code>trialing</code> status, payment method authorized but not charged</li>\n<li>Command: <code>python -m pytest tests/integration/test_subscription_creation_flow.py::test_trial_creation</code></li>\n</ul>\n</li>\n<li><p><strong>Payment Failure Recovery</strong>: Test subscription creation with failed payment</p>\n<ul>\n<li>Expected: Subscription in <code>incomplete</code> status, no access granted, retry scheduled</li>\n<li>Command: <code>python -m pytest tests/integration/test_subscription_creation_flow.py::test_payment_failure</code></li>\n</ul>\n</li>\n</ol>\n<p><strong>Billing Cycle Flow Checkpoint:</strong>\nVerify billing cycle processing with these scenarios:</p>\n<ol>\n<li><p><strong>Standard Renewal</strong>: Process renewal for active subscription with usage</p>\n<ul>\n<li>Expected: New invoice generated, payment processed, next billing date updated</li>\n<li>Command: <code>python scripts/run_billing_cycle.py --subscription-id &lt;test_id&gt;</code></li>\n</ul>\n</li>\n<li><p><strong>Usage Overage Billing</strong>: Process subscription with usage exceeding allowances</p>\n<ul>\n<li>Expected: Base charge plus overage charges, detailed line items in invoice</li>\n<li>Command: <code>python -m pytest tests/integration/test_billing_cycle_flow.py::test_usage_overage</code></li>\n</ul>\n</li>\n</ol>\n<p><strong>Plan Change Flow Checkpoint:</strong>\nTest plan change scenarios thoroughly:</p>\n<ol>\n<li><p><strong>Immediate Upgrade</strong>: Change to higher-tier plan with immediate effect</p>\n<ul>\n<li>Expected: Prorated charge applied, features activated immediately, next billing unchanged</li>\n<li>Command: <code>python -m pytest tests/integration/test_plan_change_flow.py::test_immediate_upgrade</code></li>\n</ul>\n</li>\n<li><p><strong>Downgrade with Credit</strong>: Change to lower-tier plan with credit calculation</p>\n<ul>\n<li>Expected: Credit applied to customer balance, features adjusted, future invoices reduced</li>\n<li>Command: <code>python -m pytest tests/integration/test_plan_change_flow.py::test_downgrade_with_credit</code></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"common-integration-issues\">Common Integration Issues</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Subscription creation hangs</td>\n<td>Payment gateway timeout</td>\n<td>Check payment processor logs for network timeouts</td>\n<td>Add timeout configuration and retry logic</td>\n</tr>\n<tr>\n<td>Billing cycle processes same subscription twice</td>\n<td>Missing idempotency key or duplicate billing dates</td>\n<td>Check for null idempotency_key in billing_executions table</td>\n<td>Implement unique constraints on billing execution</td>\n</tr>\n<tr>\n<td>Plan changes lose feature access</td>\n<td>Race condition between plan update and feature check</td>\n<td>Check timestamp ordering of plan_change and access_check events</td>\n<td>Add version numbers to subscription feature cache</td>\n</tr>\n<tr>\n<td>Usage aggregation returns zero</td>\n<td>Timezone mismatch in billing period boundaries</td>\n<td>Compare usage_event timestamps with billing_period_start/end</td>\n<td>Normalize all timestamps to UTC in database</td>\n</tr>\n<tr>\n<td>Proration calculations drift over time</td>\n<td>Rounding errors accumulating across multiple changes</td>\n<td>Track total_adjustments_cents field and check for drift</td>\n<td>Use banker&#39;s rounding and periodic reconciliation</td>\n</tr>\n</tbody></table>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - provides robust failure recovery, consistency guarantees, and edge case handling essential for production billing operations across plan management (Milestone 1), subscription lifecycle (Milestone 2), proration (Milestone 3), and usage-based billing (Milestone 4)</p>\n</blockquote>\n<h3 id=\"mental-model-financial-fault-tolerance\">Mental Model: Financial Fault Tolerance</h3>\n<p>Think of error handling in a subscription billing system like the safety systems in a nuclear power plant. In a power plant, every critical operation has multiple layers of protection: automatic shutdown systems, backup power supplies, containment structures, and emergency response procedures. Similarly, billing systems need multiple layers of protection because financial errors can be catastrophic - a single bug could overcharge thousands of customers or lose millions in revenue.</p>\n<p>Just as a nuclear engineer designs for &quot;defense in depth&quot; with multiple independent safety systems, we must design billing systems with layered error handling: input validation prevents bad data from entering, transaction boundaries ensure atomicity, idempotency keys prevent duplicate operations, retry mechanisms handle transient failures, and compensation workflows can roll back complex multi-step operations. The goal is that no single point of failure can compromise the financial integrity of the system.</p>\n<p>Like emergency response teams that regularly drill disaster scenarios, billing systems must be tested against failure modes that seem unlikely but would be devastating if they occurred. This means thinking through edge cases like leap years affecting billing dates, timezone changes during daylight saving transitions, and what happens when external payment systems become unavailable during peak billing periods.</p>\n<h3 id=\"payment-failure-recovery\">Payment Failure Recovery</h3>\n<p>Payment failures are inevitable in subscription billing - credit cards expire, bank accounts run out of funds, and payment processors experience outages. The key to graceful payment failure recovery is implementing a systematic <strong>dunning management</strong> process that maximizes revenue recovery while maintaining positive customer relationships.</p>\n<p>The foundation of payment failure recovery is the <strong>grace period</strong> concept. When a payment fails, the subscription doesn&#39;t immediately terminate. Instead, it transitions to a <code>past_due</code> status where the customer retains access to the service while the system attempts recovery. This approach recognizes that many payment failures are temporary - a declined card might work again in a few hours after the customer resolves a temporary hold.</p>\n<blockquote>\n<p><strong>Decision: Dunning Management Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Payment failures require systematic retry logic with escalating actions to maximize recovery while avoiding customer frustration</li>\n<li><strong>Options Considered</strong>: Immediate cancellation, fixed retry schedule, exponential backoff with customer communication</li>\n<li><strong>Decision</strong>: Multi-stage dunning with smart retry timing and proactive customer communication</li>\n<li><strong>Rationale</strong>: Balances revenue recovery (fixed schedules recover more revenue) with customer experience (exponential backoff reduces payment spam)</li>\n<li><strong>Consequences</strong>: Requires complex state management but significantly improves payment recovery rates and customer satisfaction</li>\n</ul>\n</blockquote>\n<p>The dunning process follows a structured escalation pattern designed around customer psychology and payment system behaviors:</p>\n<table>\n<thead>\n<tr>\n<th>Dunning Stage</th>\n<th>Timing</th>\n<th>Action</th>\n<th>Purpose</th>\n<th>Success Rate</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Immediate Retry</td>\n<td>1 hour after failure</td>\n<td>Retry payment with same method</td>\n<td>Catch temporary declines</td>\n<td>15-20%</td>\n</tr>\n<tr>\n<td>Early Recovery</td>\n<td>Day 1, 3, 5</td>\n<td>Retry + email notification</td>\n<td>Allow customer self-service</td>\n<td>25-30%</td>\n</tr>\n<tr>\n<td>Active Recovery</td>\n<td>Day 7, 10</td>\n<td>Retry + access restriction warnings</td>\n<td>Create urgency</td>\n<td>20-25%</td>\n</tr>\n<tr>\n<td>Final Recovery</td>\n<td>Day 14</td>\n<td>Final retry + suspension notice</td>\n<td>Last chance recovery</td>\n<td>10-15%</td>\n</tr>\n<tr>\n<td>Suspension</td>\n<td>Day 17</td>\n<td>Suspend service, retain data</td>\n<td>Minimize churn</td>\n<td>5-10% monthly recovery</td>\n</tr>\n</tbody></table>\n<p>Smart retry timing adapts to failure types because different decline reasons have different optimal retry patterns. A &quot;insufficient funds&quot; decline might succeed after payday, while &quot;card expired&quot; requires customer action. The system tracks decline codes from the payment gateway and adjusts retry schedules accordingly:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Decline Code Analysis:\n- Insufficient Funds → Retry after 3-5 days (payday cycle)\n- Expired Card → Email immediately, retry weekly\n- Fraud Prevention → Retry hourly for first day, then daily\n- Processing Error → Exponential backoff starting at 1 hour</code></pre></div>\n\n<p><strong>Dunning Action</strong> execution must be idempotent because network failures can cause duplicate webhook deliveries. Each dunning attempt receives a unique idempotency key combining the subscription ID, invoice ID, and attempt number. The system tracks all dunning attempts in an audit trail to prevent duplicate charges and ensure compliance with payment regulations.</p>\n<p>Customer communication during dunning is critical for maintaining relationships. The system generates contextual messages based on the failure reason and customer history. High-value customers might receive phone call triggers, while newer customers get educational emails about updating payment methods. The key insight is that dunning is a customer success opportunity, not just a revenue recovery mechanism.</p>\n<blockquote>\n<p>The critical principle in payment failure recovery is graduated response - start gently with technical retries, escalate to customer communication, and only restrict access as a last resort. Customers often don&#39;t realize their payment failed until they receive a notification.</p>\n</blockquote>\n<p>Payment method fallback provides an additional recovery layer. When a customer has multiple payment methods on file, the system automatically attempts the secondary method after the primary fails. This requires careful sequencing to avoid double-charging if the primary payment succeeds on retry after the secondary was already charged.</p>\n<h3 id=\"data-consistency-and-concurrency\">Data Consistency and Concurrency</h3>\n<p>Subscription billing systems must maintain strict <strong>financial precision</strong> across distributed operations while handling concurrent access from multiple sources: customer self-service portals, admin interfaces, automated billing cycles, and webhook processing from payment gateways. The challenge is ensuring that financial state remains consistent even when multiple operations attempt to modify the same subscription simultaneously.</p>\n<p>The foundation of consistency in billing systems is the <strong>transactional outbox</strong> pattern. Every financial operation - subscription creation, plan changes, usage recording, payment processing - executes within a single database transaction that both updates business entities and writes events to an outbox table. This ensures that the business state change and the corresponding event publication are atomic, preventing the common failure mode where a database update succeeds but the downstream notification fails.</p>\n<table>\n<thead>\n<tr>\n<th>Operation Type</th>\n<th>Consistency Requirements</th>\n<th>Isolation Level</th>\n<th>Concurrent Conflicts</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Subscription Creation</td>\n<td>Customer must exist, plan must be valid</td>\n<td><code>SERIALIZABLE</code></td>\n<td>Duplicate customer subscriptions</td>\n</tr>\n<tr>\n<td>Plan Changes</td>\n<td>No overlapping changes in billing cycle</td>\n<td><code>SERIALIZABLE</code></td>\n<td>Mid-cycle plan change races</td>\n</tr>\n<tr>\n<td>Usage Recording</td>\n<td>Idempotent event ingestion</td>\n<td><code>READ_COMMITTED</code></td>\n<td>Duplicate event submission</td>\n</tr>\n<tr>\n<td>Payment Processing</td>\n<td>Invoice amount must match charges</td>\n<td><code>SERIALIZABLE</code></td>\n<td>Concurrent payment attempts</td>\n</tr>\n<tr>\n<td>Credit Application</td>\n<td>Balance must not go negative</td>\n<td><code>SERIALIZABLE</code></td>\n<td>Credit balance races</td>\n</tr>\n</tbody></table>\n<p><strong>Optimistic concurrency control</strong> prevents lost updates when multiple processes modify subscription state simultaneously. Each financial entity includes a version number that increments with every update. Operations read the current version, perform their calculations, and attempt to update only if the version matches. If the version has changed, indicating another process modified the entity, the operation retries with fresh data.</p>\n<p>The subscription state machine enforces valid transitions through database constraints and application logic. Concurrent state changes are serialized using database row locks on the subscription record. For example, if an automated renewal process attempts to transition a subscription from <code>active</code> to <code>past_due</code> due to payment failure, while simultaneously an admin user tries to cancel the subscription, the database ensures only one transition succeeds and the other receives a conflict error that triggers retry logic.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Concurrency Control Example:\n1. Billing cycle starts renewal for subscription_123 (version 15)\n2. Admin user starts cancellation for subscription_123 (version 15)  \n3. Billing update: SET status='past_due', version=16 WHERE id='123' AND version=15\n4. Admin update: SET status='cancelled', version=16 WHERE id='123' AND version=15\n5. First update succeeds, second fails (version already 16)\n6. Admin operation retries with version 16, sees past_due status\n7. Admin logic decides: cancel past_due subscription immediately</code></pre></div>\n\n<p><strong>Credit balance management</strong> requires special attention to race conditions because credits can be applied and consumed concurrently. The system uses database-level atomic operations for credit adjustments, implemented through stored procedures or application-level locking. Credit consumption operations always check available balance within the same transaction that applies the credit to prevent negative balances.</p>\n<p>Event ordering and idempotency prevent duplicate processing when webhook deliveries arrive out of order or multiple times. Each webhook event includes a gateway-provided event ID and timestamp. The system maintains a processed events table with unique constraints on the gateway event ID, ensuring duplicate webhook deliveries are silently ignored rather than causing double-processing.</p>\n<blockquote>\n<p><strong>Decision: Event Processing Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Webhook events can arrive out of order, be delivered multiple times, or be lost entirely, requiring robust event processing</li>\n<li><strong>Options Considered</strong>: Direct processing, event sourcing with replay, transactional outbox with deduplication</li>\n<li><strong>Decision</strong>: Transactional outbox with idempotency keys and event ordering by timestamp</li>\n<li><strong>Rationale</strong>: Provides exactly-once processing guarantees while maintaining audit trail and enabling replay for debugging</li>\n<li><strong>Consequences</strong>: Additional storage overhead but eliminates duplicate payment processing and enables reliable event replay</li>\n</ul>\n</blockquote>\n<p><strong>Distributed transaction management</strong> across multiple services uses the <strong>saga pattern</strong> rather than two-phase commit. Complex operations like subscription creation span multiple components: customer validation, plan entitlement setup, payment method verification, and initial invoice generation. Each step in the saga can complete independently, with compensation actions defined to roll back completed steps if later steps fail.</p>\n<p>The saga coordinator tracks workflow progress and handles partial failures by executing compensation steps in reverse order. For example, if subscription creation fails during payment method verification after successfully creating the subscription record and setting up entitlements, the compensation workflow removes the entitlements and marks the subscription as <code>incomplete</code> rather than leaving it in an inconsistent state.</p>\n<h3 id=\"billing-edge-cases\">Billing Edge Cases</h3>\n<p>Billing systems encounter numerous edge cases related to time, calendar arithmetic, and timezone handling that can cause subtle but expensive bugs. These edge cases often surface during specific calendar events like leap years, daylight saving transitions, and month-end billing cycles, making them difficult to catch in normal testing but critical to handle correctly in production.</p>\n<p><strong>Calendar arithmetic</strong> presents the most common source of billing edge cases. The <strong>billing anchor</strong> concept helps maintain consistent billing dates, but month overflow situations require careful handling. When a subscription starts on January 31st with monthly billing, the naive approach of adding one month results in February 31st, which doesn&#39;t exist. The system must define consistent rules for handling these overflows:</p>\n<table>\n<thead>\n<tr>\n<th>Billing Anchor</th>\n<th>Next Billing Date</th>\n<th>Rule Applied</th>\n<th>Alternative Approaches</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>January 31</td>\n<td>February 28 (non-leap), February 29 (leap)</td>\n<td>End-of-month clamping</td>\n<td>Use February 28 always, Use March 3</td>\n</tr>\n<tr>\n<td>March 31</td>\n<td>April 30</td>\n<td>Month-end clamping</td>\n<td>Use April 31 → May 1</td>\n</tr>\n<tr>\n<td>February 29 (leap year)</td>\n<td>March 29 (following year)</td>\n<td>Day preservation when possible</td>\n<td>Always use March 28, Use March 1</td>\n</tr>\n</tbody></table>\n<p>The chosen approach is <strong>anchor day preservation</strong> with end-of-month clamping. If the anchor day exists in the target month, use it. If not, use the last day of the target month. This provides predictable billing dates that customers can understand while avoiding the complexity of variable-length billing periods.</p>\n<p><strong>Timezone handling</strong> becomes complex when customers can change their billing timezone or when daylight saving transitions affect billing schedules. The system stores all timestamps in UTC and converts to customer timezone only for display purposes. Billing calculations always use UTC to ensure consistency, but customer communication uses local time to avoid confusion.</p>\n<p>Daylight saving transitions can cause apparent billing time shifts. A customer in New York with 9 AM billing might see their next bill generated at 8 AM local time after the spring forward transition. To avoid customer confusion, the system communicates billing times in terms of &quot;billing date&quot; rather than specific times, and processes all billing for a given date in a single batch operation.</p>\n<blockquote>\n<p>The cardinal rule of billing timezone handling is: store in UTC, calculate in UTC, display in customer timezone. Never perform financial calculations using local time - daylight saving transitions can cause billing to run twice or be skipped entirely.</p>\n</blockquote>\n<p><strong>Leap year handling</strong> affects annual billing cycles and usage aggregation periods. February 29th poses special challenges for anniversary-based billing. A customer who subscribes on February 29th during a leap year needs a consistent anniversary date in non-leap years. The system uses February 28th as the anniversary in non-leap years, with clear customer communication about this adjustment.</p>\n<p>Usage aggregation during leap years must account for the extra day in February when calculating monthly averages or comparing year-over-year usage patterns. The system normalizes usage metrics by billing period length to ensure fair comparisons across different month lengths.</p>\n<p><strong>Currency precision and rounding</strong> requires careful attention to avoid accumulating errors across many customers. The system uses integer arithmetic with the smallest currency unit (cents for USD, pence for GBP) to avoid floating-point precision issues. All monetary calculations use the <code>Money</code> type with explicit rounding rules applied at specific points in the calculation pipeline.</p>\n<p>Proration calculations are particularly susceptible to rounding errors because they involve division operations. The system applies rounding only at the final step of each calculation, maintaining full precision through intermediate steps. When proration results in fractional cents, the system uses &quot;round half to even&quot; (banker&#39;s rounding) to prevent systematic bias in either customer or company favor.</p>\n<table>\n<thead>\n<tr>\n<th>Rounding Scenario</th>\n<th>Amount Before Rounding</th>\n<th>Rounded Amount</th>\n<th>Rule Applied</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Monthly proration</td>\n<td>$29.996666...</td>\n<td>$30.00</td>\n<td>Round up at 0.5 cents</td>\n</tr>\n<tr>\n<td>Daily proration</td>\n<td>$1.235</td>\n<td>$1.24</td>\n<td>Round half to even (odd result)</td>\n</tr>\n<tr>\n<td>Quantity-based proration</td>\n<td>$15.245</td>\n<td>$15.24</td>\n<td>Round half to even (even result)</td>\n</tr>\n<tr>\n<td>Usage overage</td>\n<td>$0.001234</td>\n<td>$0.00</td>\n<td>Minimum charge threshold</td>\n</tr>\n</tbody></table>\n<p><strong>Cross-month billing cycles</strong> create edge cases when subscription events occur near month boundaries. A subscription cancelled on the last day of the month might have its final invoice generated in the following month, affecting revenue reporting and customer communication timing. The system maintains strict separation between billing period boundaries and invoice generation dates to ensure accurate financial reporting.</p>\n<p><strong>Retroactive adjustments</strong> handle situations where billing corrections must be applied after invoices have been generated. This occurs when usage data arrives late, pricing errors are discovered, or customer service approves billing adjustments. The system creates adjustment line items on future invoices rather than modifying historical invoices, maintaining audit trail integrity while ensuring customers see the corrections.</p>\n<p>Usage event late arrival requires special handling because aggregation windows must close to generate invoices, but some events may arrive after the window closes. The system defines a &quot;late arrival window&quot; (typically 7 days) during which late events are accepted and applied as adjustments to the following invoice. Events arriving after this window are logged but not applied to avoid indefinite billing uncertainty.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Tracking</td>\n<td>Python logging + file rotation</td>\n<td>Sentry or Datadog APM with structured logging</td>\n</tr>\n<tr>\n<td>Circuit Breaker</td>\n<td>Custom retry with exponential backoff</td>\n<td>Tenacity library with circuit breaker patterns</td>\n</tr>\n<tr>\n<td>Database Transactions</td>\n<td>PostgreSQL with explicit transaction blocks</td>\n<td>SQLAlchemy with session management and savepoints</td>\n</tr>\n<tr>\n<td>Webhook Processing</td>\n<td>Flask/FastAPI with request validation</td>\n<td>Celery task queue with Redis for webhook processing</td>\n</tr>\n<tr>\n<td>Event Outbox</td>\n<td>Database table with background polling</td>\n<td>Debezium CDC with Kafka for reliable event streaming</td>\n</tr>\n<tr>\n<td>Concurrency Control</td>\n<td>Database row locks with version columns</td>\n<td>Distributed locks with Redis or ZooKeeper</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>billing_system/\n  src/\n    error_handling/\n      __init__.py\n      exceptions.py              ← Custom exception hierarchy\n      retry_policies.py          ← Retry strategies and circuit breakers\n      transaction_manager.py     ← Database transaction utilities\n    dunning/\n      __init__.py\n      dunning_engine.py         ← Payment failure recovery logic  \n      dunning_actions.py        ← Email, restriction, retry actions\n      dunning_scheduler.py      ← Retry timing and escalation\n    concurrency/\n      __init__.py\n      locks.py                  ← Optimistic concurrency control\n      outbox.py                 ← Transactional outbox pattern\n      saga_coordinator.py       ← Distributed transaction management\n    edge_cases/\n      __init__.py\n      calendar_utils.py         ← Timezone and date arithmetic\n      currency_precision.py     ← Money handling and rounding\n      billing_calendar.py       ← Billing anchor and cycle calculation\n  tests/\n    test_error_scenarios/       ← Payment failure simulation tests\n    test_concurrency/          ← Race condition and deadlock tests  \n    test_edge_cases/           ← Calendar edge case test suite</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Custom Exception Hierarchy</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/error_handling/exceptions.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BillingErrorType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PAYMENT_FAILED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"payment_failed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INSUFFICIENT_CREDIT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"insufficient_credit\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INVALID_SUBSCRIPTION_STATE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"invalid_subscription_state\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PRORATION_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"proration_error\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    USAGE_VALIDATION_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"usage_validation_error\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CONCURRENCY_CONFLICT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"concurrency_conflict\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EXTERNAL_SERVICE_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"external_service_error\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BillingException</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for all billing system errors with structured error information.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        error_type: BillingErrorType,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        entity_id: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        metadata: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cause: Optional[</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.error_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> error_type</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.entity_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> entity_id</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.metadata </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> metadata </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cause </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cause</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"error_type\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.error_type.value,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"message\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"entity_id\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.entity_id,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"metadata\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.metadata</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PaymentFailedException</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BillingException</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, payment_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, decline_code: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        metadata </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"payment_id\"</span><span style=\"color:#E1E4E8\">: payment_id}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> decline_code:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            metadata[</span><span style=\"color:#9ECBFF\">\"decline_code\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> decline_code</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, BillingErrorType.</span><span style=\"color:#79B8FF\">PAYMENT_FAILED</span><span style=\"color:#E1E4E8\">, payment_id, metadata)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ConcurrencyConflictException</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BillingException</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, entity_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, entity_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, expected_version: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, actual_version: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        metadata </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"entity_type\"</span><span style=\"color:#E1E4E8\">: entity_type,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"expected_version\"</span><span style=\"color:#E1E4E8\">: expected_version,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"actual_version\"</span><span style=\"color:#E1E4E8\">: actual_version</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, BillingErrorType.</span><span style=\"color:#79B8FF\">CONCURRENCY_CONFLICT</span><span style=\"color:#E1E4E8\">, entity_id, metadata)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SubscriptionStateException</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BillingException</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, subscription_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, current_state: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, attempted_transition: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        metadata </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"current_state\"</span><span style=\"color:#E1E4E8\">: current_state,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"attempted_transition\"</span><span style=\"color:#E1E4E8\">: attempted_transition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, BillingErrorType.</span><span style=\"color:#79B8FF\">INVALID_SUBSCRIPTION_STATE</span><span style=\"color:#E1E4E8\">, subscription_id, metadata)</span></span></code></pre></div>\n\n<p><strong>Retry Policy Implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/error_handling/retry_policies.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> random</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Callable, Type, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> functools </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> wraps</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BillingException, BillingErrorType</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RetryConfig</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_attempts: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    base_delay: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_delay: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 60.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exponential_base: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jitter: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retryable_exceptions: Tuple[Type[</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">...</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">,)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    non_retryable_error_types: Tuple[BillingErrorType, </span><span style=\"color:#79B8FF\">...</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BillingErrorType.</span><span style=\"color:#79B8FF\">INVALID_SUBSCRIPTION_STATE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BillingErrorType.</span><span style=\"color:#79B8FF\">INSUFFICIENT_CREDIT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CircuitBreaker</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Circuit breaker implementation to prevent cascading failures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, failure_threshold: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">, timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 60.0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.failure_threshold </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> failure_threshold</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.timeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timeout</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.failure_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.last_failure_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"closed\"</span><span style=\"color:#6A737D\">  # closed, open, half_open</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_available</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"closed\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"open\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.last_failure_time </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.timeout:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"half_open\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># half_open</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> record_success</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.failure_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"closed\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> record_failure</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.failure_count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.last_failure_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.failure_count </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.failure_threshold:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"open\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> retry_with_backoff</span><span style=\"color:#E1E4E8\">(config: RetryConfig </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Decorator for automatic retry with exponential backoff.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> RetryConfig()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> decorator</span><span style=\"color:#E1E4E8\">(func):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        @wraps</span><span style=\"color:#E1E4E8\">(func)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#B392F0\"> wrapper</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            last_exception </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> attempt </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(config.max_attempts):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#E1E4E8\"> func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    last_exception </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> e</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Check if exception is retryable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(e, config.retryable_exceptions):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        raise</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Check if billing error type is non-retryable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(e, BillingException) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> e.error_type </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> config.non_retryable_error_types:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        raise</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Don't sleep on last attempt</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> attempt </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> config.max_attempts </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Calculate delay with exponential backoff and jitter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    delay </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> min</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        config.base_delay </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (config.exponential_base </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\"> attempt),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        config.max_delay</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> config.jitter:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        delay </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> delay </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">0.5</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> random.random() </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    logging.warning(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Attempt </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">attempt </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1}</span><span style=\"color:#9ECBFF\"> failed, retrying in </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">delay</span><span style=\"color:#F97583\">:.2f</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">s: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    time.sleep(delay)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> last_exception</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> wrapper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> decorator</span></span></code></pre></div>\n\n<p><strong>Transaction Manager</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/error_handling/transaction_manager.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> contextlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Any, Dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> create_engine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy.orm </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sessionmaker, Session</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy.exc </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SQLAlchemyError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BillingException, BillingErrorType</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TransactionManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages database transactions with proper error handling and rollback.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, database_url: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.engine </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_engine(database_url)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.SessionLocal </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sessionmaker(</span><span style=\"color:#FFAB70\">bind</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.engine)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> transaction</span><span style=\"color:#E1E4E8\">(self, isolation_level: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Database transaction context manager with automatic rollback on errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        session </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.SessionLocal()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> isolation_level:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            session.connection(</span><span style=\"color:#FFAB70\">execution_options</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"isolation_level\"</span><span style=\"color:#E1E4E8\">: isolation_level})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            yield</span><span style=\"color:#E1E4E8\"> session</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            session.commit()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logging.info(</span><span style=\"color:#9ECBFF\">\"Transaction committed successfully\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> SQLAlchemyError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            session.rollback()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logging.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Database error, transaction rolled back: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> BillingException(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                f</span><span style=\"color:#9ECBFF\">\"Database transaction failed: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                BillingErrorType.</span><span style=\"color:#79B8FF\">EXTERNAL_SERVICE_ERROR</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                cause</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">e</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            session.rollback()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logging.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unexpected error, transaction rolled back: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        finally</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            session.close()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_savepoint</span><span style=\"color:#E1E4E8\">(self, session: Session, savepoint_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create named savepoint for partial rollback within transaction.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            session.begin_nested()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> savepoint_name</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> SQLAlchemyError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> BillingException(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                f</span><span style=\"color:#9ECBFF\">\"Failed to create savepoint </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">savepoint_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                BillingErrorType.</span><span style=\"color:#79B8FF\">EXTERNAL_SERVICE_ERROR</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                cause</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">e</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Dunning Engine Implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/dunning/dunning_engine.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Subscription, Invoice, Payment, PaymentStatus</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..error_handling.exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BillingException, BillingErrorType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..error_handling.retry_policies </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> retry_with_backoff, RetryConfig</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DunningStage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    IMMEDIATE_RETRY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"immediate_retry\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EARLY_RECOVERY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"early_recovery\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ACTIVE_RECOVERY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"active_recovery\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FINAL_RECOVERY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"final_recovery\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUSPENDED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"suspended\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DunningAttempt</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    attempt_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subscription_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    invoice_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stage: DunningStage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scheduled_at: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    completed_at: Optional[datetime]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    success: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    decline_code: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    next_attempt_at: Optional[datetime]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DunningEngine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages payment failure recovery with graduated escalation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, payment_processor, notification_service, transaction_manager):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.payment_processor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> payment_processor</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.notification_service </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> notification_service</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.transaction_manager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> transaction_manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_payment_failure</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        subscription_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        invoice_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        failure_reason: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        idempotency_key: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Initiate dunning process for failed payment.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if dunning already started for this invoice (idempotency)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Analyze failure reason to determine appropriate retry strategy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Transition subscription to past_due status with grace period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Schedule immediate retry attempt based on decline code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Send initial customer notification about payment failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Create dunning attempt record with tracking information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Different decline codes need different retry timing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_dunning_retry</span><span style=\"color:#E1E4E8\">(self, subscription_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute next dunning attempt for subscription.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load current dunning state and determine next stage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check if subscription is still eligible for dunning</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Attempt payment retry using stored payment method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Process retry result and update dunning state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Schedule next attempt or escalate based on result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Send appropriate customer communication for stage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Update subscription status if recovery successful</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use exponential backoff for technical failures, fixed schedule for customer issues</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> escalate_dunning_stage</span><span style=\"color:#E1E4E8\">(self, subscription_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, current_stage: DunningStage) -> DunningStage:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Determine next dunning stage based on current stage and elapsed time.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate days since initial payment failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Apply dunning policy rules to determine next stage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check for any customer-specific dunning overrides</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return appropriate next stage or suspension</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Different customer tiers may have different dunning schedules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @retry_with_backoff</span><span style=\"color:#E1E4E8\">(RetryConfig(</span><span style=\"color:#FFAB70\">max_attempts</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">base_delay</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2.0</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> attempt_payment_recovery</span><span style=\"color:#E1E4E8\">(self, subscription_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, payment_method_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Attempt payment retry with the customer's payment method.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate subscription is in past_due status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Calculate amount due including any late fees</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Call payment processor with idempotency protection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle payment success/failure and update records</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Apply any credits or adjustments to the payment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Always use unique idempotency keys for each retry attempt</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Concurrency Control Implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/concurrency/locks.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Any, Dict, Type, TypeVar</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy.orm </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Session</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> sqlalchemy.exc </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> IntegrityError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BaseEntity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..error_handling.exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ConcurrencyConflictException</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">T </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TypeVar(</span><span style=\"color:#9ECBFF\">'T'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">bound</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">BaseEntity)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> OptimisticLockManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages optimistic concurrency control using entity version numbers.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, session: Session):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.session </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> session</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> load_with_lock</span><span style=\"color:#E1E4E8\">(self, entity_class: Type[T], entity_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[T]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Load entity with current version for optimistic locking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Query entity by ID and return with current version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return None if entity doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Log entity load for debugging concurrency issues</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Always load the version column for comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> save_with_version_check</span><span style=\"color:#E1E4E8\">(self, entity: T) -> T:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Save entity with optimistic lock version checking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Increment entity version number before save</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Attempt database update with WHERE version = old_version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check if update affected any rows (version conflict)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Raise ConcurrencyConflictException if version mismatch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return updated entity with new version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle database constraint violations gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use UPDATE ... WHERE id = ? AND version = ? to detect conflicts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> retry_on_conflict</span><span style=\"color:#E1E4E8\">(self, operation_func, max_retries: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Retry operation on optimistic lock conflicts.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Execute operation function with fresh entity load</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Catch ConcurrencyConflictException and retry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Implement exponential backoff between retries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Re-raise exception after max retries exceeded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Log retry attempts for monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Reload entity data before each retry attempt</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Billing Edge Case Utilities</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/edge_cases/billing_calendar.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, date, timedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dateutil.relativedelta </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> relativedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytz</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BillingInterval</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BillingCalendar</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Handles billing date calculations with proper edge case handling.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> calculate_next_billing_date</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_date: date,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        billing_interval: BillingInterval,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        billing_anchor: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timezone: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> date:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Calculate next billing date handling month overflow and leap years.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Handle timezone conversion from UTC to customer timezone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Apply billing interval (monthly, yearly) using relativedelta</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle month overflow (Jan 31 + 1 month = Feb 28/29)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle leap year edge cases for February 29 anchors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Ensure billing date doesn't go backwards due to DST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Convert result back to UTC for storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use end-of-month clamping for month overflow situations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> calculate_proration_factor</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        change_date: datetime,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        period_start: datetime,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        period_end: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Calculate time-based proration factor for partial billing periods.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate that change_date falls within billing period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Calculate total period length in seconds for precision</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate remaining period length from change date</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return factor as remaining_time / total_time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle edge case where change_date equals period boundaries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Ensure factor is between 0.0 and 1.0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use seconds for calculation to avoid leap second issues</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_leap_year_anniversary</span><span style=\"color:#E1E4E8\">(self, original_date: date, target_year: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> date:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle leap year edge cases for annual billing anniversaries.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if original date is February 29</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check if target year is a leap year</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If Feb 29 -> non-leap year, use Feb 28</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If Feb 29 -> leap year, preserve Feb 29</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle other leap year boundary conditions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return adjusted anniversary date</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use calendar.isleap() to check leap year status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Payment Failure Recovery Validation:</strong></p>\n<ul>\n<li>Start subscription with valid payment method</li>\n<li>Simulate payment failure by marking payment method as declined</li>\n<li>Verify subscription transitions to <code>past_due</code> status within grace period</li>\n<li>Check that retry attempts are scheduled according to dunning policy</li>\n<li>Confirm customer notifications are sent at appropriate intervals</li>\n<li>Validate that successful retry restores subscription to <code>active</code> status</li>\n</ul>\n<p><strong>Concurrency Control Testing:</strong></p>\n<ul>\n<li>Start two concurrent plan change operations on same subscription</li>\n<li>Verify that only one operation succeeds and other receives conflict error</li>\n<li>Check that failed operation retries with fresh entity version</li>\n<li>Confirm that final state is consistent with last successful operation</li>\n<li>Test credit balance race conditions with concurrent consumption</li>\n</ul>\n<p><strong>Edge Case Handling Verification:</strong></p>\n<ul>\n<li>Create subscription with January 31 billing anchor</li>\n<li>Verify February billing date is February 28 (or 29 in leap year)</li>\n<li>Test timezone changes during daylight saving transitions</li>\n<li>Confirm proration calculations handle fractional cents correctly</li>\n<li>Validate leap year anniversary handling for February 29 subscriptions</li>\n</ul>\n<h4 id=\"common-pitfalls-and-debugging\">Common Pitfalls and Debugging</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Duplicate payment charges</td>\n<td>Webhook processing without idempotency</td>\n<td>Check payment_events table for duplicate gateway_event_id</td>\n<td>Add unique constraint on gateway_event_id</td>\n</tr>\n<tr>\n<td>Subscription stuck in past_due</td>\n<td>Dunning retry logic not scheduling</td>\n<td>Check dunning_attempts table for next_attempt_at values</td>\n<td>Fix dunning scheduler cron job</td>\n</tr>\n<tr>\n<td>Proration amounts off by cents</td>\n<td>Floating point precision errors</td>\n<td>Log intermediate calculation values</td>\n<td>Use integer cent arithmetic throughout</td>\n</tr>\n<tr>\n<td>Billing dates drift over time</td>\n<td>Month overflow not handled consistently</td>\n<td>Compare expected vs actual billing dates</td>\n<td>Implement end-of-month clamping rule</td>\n</tr>\n<tr>\n<td>Credit balance goes negative</td>\n<td>Race condition in credit consumption</td>\n<td>Check for concurrent credit applications</td>\n<td>Add database constraint on credit balance &gt;= 0</td>\n</tr>\n<tr>\n<td>Payment retries spam customer</td>\n<td>Circuit breaker not working</td>\n<td>Monitor payment attempt frequency</td>\n<td>Implement exponential backoff with max delay</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Payment Webhook Replay</strong>\nProcessing the same webhook event multiple times can cause duplicate charges or state transitions. Always check for existing processing records using the gateway event ID before processing webhook data.</p>\n<p>⚠️ <strong>Pitfall: Timezone Arithmetic in Billing</strong>\nPerforming billing date calculations in customer timezone can cause billing to run twice or be skipped during daylight saving transitions. Always calculate in UTC and convert only for display.</p>\n<p>⚠️ <strong>Pitfall: Optimistic Lock Retry Storms</strong>\nUnder high concurrency, optimistic lock conflicts can cause retry storms. Implement exponential backoff and maximum retry limits to prevent system overload.</p>\n<h2 id=\"testing-strategy-and-validation\">Testing Strategy and Validation</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - defines comprehensive testing approaches to validate billing logic correctness, integration reliability, and milestone completion across plan management (Milestone 1), subscription lifecycle (Milestone 2), proration calculations (Milestone 3), and usage-based billing (Milestone 4)</p>\n</blockquote>\n<h3 id=\"mental-model-the-financial-audit-trail\">Mental Model: The Financial Audit Trail</h3>\n<p>Think of testing a subscription billing system like conducting a financial audit of a complex business. Just as an auditor must verify every transaction, reconcile every account, and trace money flows from source to destination, billing system testing requires meticulous validation at multiple levels. Unit tests are like checking individual ledger entries for mathematical accuracy - ensuring each proration calculation, usage aggregation, and pricing computation produces the correct result down to the cent. Integration tests resemble departmental audits, verifying that when the billing department sends an invoice to accounts receivable, the payment flows correctly through the entire organization. End-to-end tests are like full company audits, following a customer&#39;s entire financial journey from subscription signup through monthly billing cycles to final cancellation.</p>\n<p>The stakes are equally high in both scenarios. A single rounding error in proration calculations, multiplied across thousands of customers, can result in significant revenue loss or regulatory violations. A failed payment webhook that goes unnoticed can leave subscriptions in inconsistent states, causing customer service nightmares. Just as auditors use sampling techniques to validate large datasets, our testing strategy employs property-based testing to verify billing logic across thousands of generated scenarios, catching edge cases that manual test writing might miss.</p>\n<h3 id=\"billing-logic-unit-tests\">Billing Logic Unit Tests</h3>\n<p>Unit testing billing logic requires mathematical precision and comprehensive edge case coverage. Unlike typical application logic that might tolerate minor inconsistencies, billing calculations must be absolutely correct - every penny must be accounted for, and rounding must be deterministic and consistent across all operations.</p>\n<h4 id=\"proration-calculation-testing\">Proration Calculation Testing</h4>\n<p><strong>Proration testing</strong> focuses on the mathematical accuracy of partial billing calculations. These tests must verify that time-based proration produces correct results across various billing intervals, calendar edge cases, and currency precision requirements.</p>\n<p>The core proration test suite validates the fundamental mathematical properties that all proration calculations must satisfy:</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Test Cases</th>\n<th>Validation Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Basic Time Proration</td>\n<td>Full period, half period, single day</td>\n<td>Proration factor calculation accuracy</td>\n</tr>\n<tr>\n<td>Currency Precision</td>\n<td>Multiple currencies, rounding edge cases</td>\n<td>No precision loss, consistent rounding</td>\n</tr>\n<tr>\n<td>Calendar Edge Cases</td>\n<td>Month overflow, leap years, timezone boundaries</td>\n<td>Correct day counting, timezone handling</td>\n</tr>\n<tr>\n<td>Plan Change Scenarios</td>\n<td>Upgrade, downgrade, same-tier changes</td>\n<td>Credit/charge amounts match expected</td>\n</tr>\n<tr>\n<td>Quantity-Based Changes</td>\n<td>Seat increases, usage tier changes</td>\n<td>Per-unit proration accuracy</td>\n</tr>\n</tbody></table>\n<p><strong>Property-based testing</strong> proves invaluable for proration validation. Rather than manually crafting test cases, property-based tests generate thousands of random scenarios and verify that mathematical invariants hold:</p>\n<ul>\n<li><strong>Symmetry Property</strong>: Upgrading then immediately downgrading should result in zero net charge (minus any rounding)</li>\n<li><strong>Additivity Property</strong>: Proration for multiple changes within a period should equal the sum of individual prorations</li>\n<li><strong>Monotonicity Property</strong>: Larger plan changes should never result in smaller absolute proration amounts</li>\n<li><strong>Boundary Property</strong>: Proration at period start should equal full charge, proration at period end should equal zero charge</li>\n</ul>\n<p>The test data generation must cover realistic business scenarios while exploring mathematical edge cases. Time periods should span various billing intervals (monthly, quarterly, annual), change dates should include first/last days of billing cycles, and currency amounts should test precision boundaries.</p>\n<h4 id=\"usage-aggregation-testing\">Usage Aggregation Testing</h4>\n<p><strong>Usage aggregation testing</strong> validates the mathematical accuracy of usage event processing and billing calculations. These tests must ensure that usage events aggregate correctly across time boundaries, duplicate events are properly deduplicated, and overage charges calculate accurately.</p>\n<table>\n<thead>\n<tr>\n<th>Aggregation Scenario</th>\n<th>Test Coverage</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Event Deduplication</td>\n<td>Duplicate events with same idempotency key</td>\n<td>Only single event counted</td>\n</tr>\n<tr>\n<td>Time Boundary Handling</td>\n<td>Events at billing period edges</td>\n<td>Correct period assignment</td>\n</tr>\n<tr>\n<td>Usage Type Separation</td>\n<td>Multiple metric types per customer</td>\n<td>Isolated aggregation per metric</td>\n</tr>\n<tr>\n<td>Quantity Precision</td>\n<td>Fractional usage quantities</td>\n<td>Accurate decimal handling</td>\n</tr>\n<tr>\n<td>Overage Calculations</td>\n<td>Usage beyond plan allowances</td>\n<td>Correct tiered rate application</td>\n</tr>\n</tbody></table>\n<p><strong>Time series testing</strong> validates usage aggregation across billing period boundaries. These tests generate usage events with carefully controlled timestamps to verify that aggregation windows capture the correct events. Edge cases include events submitted exactly at billing period boundaries, events with future timestamps (clock skew), and events submitted after billing period close.</p>\n<p><strong>Idempotency verification</strong> ensures that reprocessing usage events produces identical aggregation results. Tests submit the same usage batch multiple times with identical idempotency keys and verify that total usage quantities remain unchanged. This validation protects against double-billing scenarios in production.</p>\n<h4 id=\"pricing-model-testing\">Pricing Model Testing</h4>\n<p><strong>Pricing model testing</strong> validates the mathematical accuracy of charge calculations across different pricing structures. Each pricing model (flat-rate, tiered, volume-based) has distinct calculation logic that requires specialized test coverage.</p>\n<table>\n<thead>\n<tr>\n<th>Pricing Model</th>\n<th>Test Scenarios</th>\n<th>Mathematical Validation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Flat-Rate</td>\n<td>Base charges, currency conversion</td>\n<td>Fixed amount accuracy</td>\n</tr>\n<tr>\n<td>Tiered Pricing</td>\n<td>Single tier, multi-tier, boundary cases</td>\n<td>Per-tier calculation accuracy</td>\n</tr>\n<tr>\n<td>Volume Pricing</td>\n<td>Usage below/above thresholds</td>\n<td>Rate change threshold accuracy</td>\n</tr>\n<tr>\n<td>Per-Seat Pricing</td>\n<td>Seat changes, proration</td>\n<td>Quantity-based calculation</td>\n</tr>\n<tr>\n<td>Usage-Based</td>\n<td>Allowances, overages, tier boundaries</td>\n<td>Complex usage charge accuracy</td>\n</tr>\n</tbody></table>\n<p><strong>Tiered pricing edge cases</strong> require special attention because they involve complex mathematical logic. Tests must verify calculations when usage spans multiple pricing tiers, ensuring that each tier applies its rate only to the usage quantity within that tier&#39;s boundaries. Boundary conditions (usage exactly at tier thresholds) must be tested exhaustively.</p>\n<h4 id=\"feature-entitlement-testing\">Feature Entitlement Testing</h4>\n<p><strong>Feature entitlement testing</strong> validates the business logic that determines customer access to features based on their subscription plan. These tests ensure that feature flags, usage quotas, and access controls operate correctly across plan changes and subscription state transitions.</p>\n<table>\n<thead>\n<tr>\n<th>Entitlement Type</th>\n<th>Test Coverage</th>\n<th>Validation Points</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Boolean Features</td>\n<td>Feature enabled/disabled by plan</td>\n<td>Correct true/false determination</td>\n</tr>\n<tr>\n<td>Quota Limits</td>\n<td>Usage tracking against plan limits</td>\n<td>Accurate quota enforcement</td>\n</tr>\n<tr>\n<td>Plan Hierarchies</td>\n<td>Feature inheritance in plan families</td>\n<td>Correct access level determination</td>\n</tr>\n<tr>\n<td>Time-Based Access</td>\n<td>Trial periods, grace periods</td>\n<td>Time-sensitive feature access</td>\n</tr>\n</tbody></table>\n<h3 id=\"integration-and-end-to-end-tests\">Integration and End-to-End Tests</h3>\n<p>Integration testing validates the interaction between billing system components and external services. Unlike unit tests that isolate individual calculations, integration tests verify that data flows correctly between components and that system-wide business processes complete successfully.</p>\n<h4 id=\"payment-gateway-integration-testing\">Payment Gateway Integration Testing</h4>\n<p><strong>Payment gateway integration testing</strong> validates the complete payment flow from charge creation through webhook processing. These tests must handle asynchronous payment processing, webhook delivery reliability, and failure scenario recovery.</p>\n<p>The integration test environment requires a payment gateway test mode that simulates various payment scenarios without processing real money. Test cases must cover successful payments, failed payments with different decline reasons, and webhook delivery edge cases.</p>\n<table>\n<thead>\n<tr>\n<th>Integration Scenario</th>\n<th>Test Setup</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Successful Payment Flow</td>\n<td>Valid payment method, sufficient funds</td>\n<td>Payment completed, subscription activated</td>\n</tr>\n<tr>\n<td>Payment Failure Handling</td>\n<td>Invalid payment method or declined card</td>\n<td>Dunning process initiated, customer notified</td>\n</tr>\n<tr>\n<td>Webhook Processing</td>\n<td>Payment status change webhooks</td>\n<td>Subscription state updated correctly</td>\n</tr>\n<tr>\n<td>Idempotency Protection</td>\n<td>Duplicate webhook delivery</td>\n<td>No duplicate processing occurred</td>\n</tr>\n<tr>\n<td>Timeout Scenarios</td>\n<td>Delayed webhook delivery</td>\n<td>Proper retry and recovery behavior</td>\n</tr>\n</tbody></table>\n<p><strong>Webhook reliability testing</strong> focuses on the asynchronous nature of payment notifications. Tests must simulate webhook delivery failures, duplicate deliveries, and out-of-order delivery to ensure the system maintains consistency under adverse network conditions.</p>\n<p>The test suite uses webhook simulation rather than depending on actual payment gateway webhook delivery. This approach provides deterministic test execution while covering the same code paths that process production webhooks.</p>\n<h4 id=\"subscription-lifecycle-integration-testing\">Subscription Lifecycle Integration Testing</h4>\n<p><strong>Subscription lifecycle integration testing</strong> validates end-to-end subscription operations that span multiple system components. These tests verify that subscription state changes trigger appropriate downstream actions and maintain data consistency across components.</p>\n<table>\n<thead>\n<tr>\n<th>Lifecycle Operation</th>\n<th>Component Integration</th>\n<th>Validation Points</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Subscription Creation</td>\n<td>Plan validation, payment setup, activation</td>\n<td>All components reflect active subscription</td>\n</tr>\n<tr>\n<td>Plan Changes</td>\n<td>Proration calculation, billing adjustment</td>\n<td>Correct charges applied to next invoice</td>\n</tr>\n<tr>\n<td>Renewal Processing</td>\n<td>Usage aggregation, invoice generation</td>\n<td>Complete billing cycle execution</td>\n</tr>\n<tr>\n<td>Cancellation</td>\n<td>Service termination, final billing</td>\n<td>Proper cleanup and final charges</td>\n</tr>\n</tbody></table>\n<p><strong>Billing cycle integration testing</strong> validates the monthly billing process that aggregates usage, applies proration adjustments, generates invoices, and processes payments. This complex workflow requires coordination between multiple components and represents the most critical business process.</p>\n<p>The test creates a controlled billing scenario with known usage events, plan changes, and payment methods. It then executes the complete billing cycle and validates that the generated invoice contains the correct line items with accurate amounts.</p>\n<h4 id=\"database-transaction-testing\">Database Transaction Testing</h4>\n<p><strong>Database transaction testing</strong> validates the consistency guarantees provided by the system&#39;s transaction management. These tests verify that multi-step operations either complete entirely or roll back completely, preventing partial state corruption.</p>\n<table>\n<thead>\n<tr>\n<th>Transaction Scenario</th>\n<th>Test Coverage</th>\n<th>Consistency Validation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Plan Change Rollback</td>\n<td>Payment failure during upgrade</td>\n<td>Original plan remains active</td>\n</tr>\n<tr>\n<td>Invoice Generation Failure</td>\n<td>Partial line item creation</td>\n<td>No incomplete invoices created</td>\n</tr>\n<tr>\n<td>Usage Event Processing</td>\n<td>Batch processing with failures</td>\n<td>Either all events processed or none</td>\n</tr>\n<tr>\n<td>Concurrent Plan Changes</td>\n<td>Multiple simultaneous changes</td>\n<td>Serializable execution order</td>\n</tr>\n</tbody></table>\n<p><strong>Concurrency testing</strong> validates the system&#39;s behavior under concurrent load. These tests simulate multiple users performing subscription operations simultaneously to ensure that optimistic locking prevents data corruption and that retry logic handles version conflicts correctly.</p>\n<h4 id=\"cross-component-data-flow-testing\">Cross-Component Data Flow Testing</h4>\n<p><strong>Cross-component data flow testing</strong> validates that events and data propagate correctly through the system&#39;s event-driven architecture. These tests verify that state changes in one component trigger appropriate actions in dependent components.</p>\n<p>The test framework publishes domain events and verifies that all registered event handlers execute correctly and that the system reaches a consistent final state. This validation ensures that the loosely-coupled architecture maintains strong consistency guarantees.</p>\n<table>\n<thead>\n<tr>\n<th>Data Flow</th>\n<th>Event Triggers</th>\n<th>Expected Propagation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Plan Change Event</td>\n<td>Proration calculation completion</td>\n<td>Invoice line item creation</td>\n</tr>\n<tr>\n<td>Usage Event Submission</td>\n<td>Batch aggregation completion</td>\n<td>Overage charge calculation</td>\n</tr>\n<tr>\n<td>Payment Success Event</td>\n<td>Gateway webhook processing</td>\n<td>Subscription activation</td>\n</tr>\n<tr>\n<td>Dunning Escalation</td>\n<td>Payment retry failure</td>\n<td>Customer notification trigger</td>\n</tr>\n</tbody></table>\n<h3 id=\"milestone-validation-checkpoints\">Milestone Validation Checkpoints</h3>\n<p>Each project milestone requires specific validation checkpoints that verify the implemented functionality meets the acceptance criteria. These checkpoints combine automated testing with manual verification procedures to ensure comprehensive validation.</p>\n<h4 id=\"milestone-1-plans-amp-pricing-validation\">Milestone 1: Plans &amp; Pricing Validation</h4>\n<p><strong>Plan Management Validation</strong> focuses on the flexible pricing plan definition and feature entitlement systems. The validation process ensures that plans support multiple pricing models, handle currency conversion correctly, and maintain proper versioning for existing customers.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Area</th>\n<th>Automated Tests</th>\n<th>Manual Verification</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Plan Definition</td>\n<td>Schema validation, pricing model tests</td>\n<td>Admin interface plan creation</td>\n</tr>\n<tr>\n<td>Currency Support</td>\n<td>Multi-currency pricing calculations</td>\n<td>Currency display and conversion</td>\n</tr>\n<tr>\n<td>Feature Entitlements</td>\n<td>Access control logic testing</td>\n<td>Feature flag behavior verification</td>\n</tr>\n<tr>\n<td>Plan Versioning</td>\n<td>Grandfathering logic validation</td>\n<td>Existing customer protection testing</td>\n</tr>\n</tbody></table>\n<p><strong>Pricing Model Validation</strong> requires mathematical verification across all supported pricing structures. The validation process generates test scenarios for flat-rate, tiered, and volume-based pricing to ensure accurate charge calculations.</p>\n<p>The checkpoint procedure involves creating test plans with known pricing parameters, then validating that charge calculations produce expected results across various usage quantities and time periods. Property-based testing generates additional scenarios to verify mathematical invariants.</p>\n<p><strong>Acceptance Criteria Validation</strong>:</p>\n<ol>\n<li><strong>Plan Definition Schema</strong>: Create plans with different intervals, currencies, and feature lists through the management API</li>\n<li><strong>Pricing Model Support</strong>: Validate flat-rate, per-unit, and tiered pricing calculations with known test cases</li>\n<li><strong>Feature Entitlement Matrix</strong>: Verify that plan tiers correctly enable/disable feature flags</li>\n<li><strong>Plan Versioning</strong>: Confirm that plan updates create new versions while preserving existing subscriber access</li>\n</ol>\n<h4 id=\"milestone-2-subscription-lifecycle-validation\">Milestone 2: Subscription Lifecycle Validation</h4>\n<p><strong>Subscription State Machine Validation</strong> verifies that subscription state transitions follow business rules and that invalid transitions are properly rejected. The validation process tests each valid state transition and confirms that appropriate actions are triggered.</p>\n<table>\n<thead>\n<tr>\n<th>State Transition</th>\n<th>Validation Test</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Trial to Active</td>\n<td>Payment method validation</td>\n<td>Automatic conversion on trial expiry</td>\n</tr>\n<tr>\n<td>Active to Past Due</td>\n<td>Payment failure simulation</td>\n<td>Dunning process initiation</td>\n</tr>\n<tr>\n<td>Past Due to Unpaid</td>\n<td>Retry exhaustion</td>\n<td>Service suspension</td>\n</tr>\n<tr>\n<td>Active to Cancelled</td>\n<td>Customer-initiated cancellation</td>\n<td>Service termination scheduling</td>\n</tr>\n</tbody></table>\n<p><strong>Renewal Processing Validation</strong> ensures that the billing cycle engine correctly generates recurring charges, processes payments, and handles failures appropriately. The validation creates test subscriptions with known billing parameters and verifies invoice generation accuracy.</p>\n<p><strong>Dunning Management Validation</strong> tests the payment failure recovery system by simulating various payment decline scenarios and verifying that retry attempts follow the configured dunning schedule.</p>\n<p><strong>Acceptance Criteria Validation</strong>:</p>\n<ol>\n<li><strong>Subscription Creation</strong>: Provision new subscriptions with selected plans and payment methods</li>\n<li><strong>Plan Change Processing</strong>: Execute upgrades/downgrades with correct effective date logic</li>\n<li><strong>Cancellation Handling</strong>: Process cancellations with reason recording and termination scheduling</li>\n<li><strong>Pause/Resume Functionality</strong>: Handle subscription pausing with prorated billing adjustments</li>\n</ol>\n<h4 id=\"milestone-3-proration-amp-plan-changes-validation\">Milestone 3: Proration &amp; Plan Changes Validation</h4>\n<p><strong>Proration Calculation Validation</strong> focuses on mathematical accuracy of partial billing calculations. The validation process tests proration scenarios across different billing intervals, plan types, and change timing to ensure consistent results.</p>\n<table>\n<thead>\n<tr>\n<th>Proration Scenario</th>\n<th>Test Data</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Mid-cycle Upgrade</td>\n<td>Known plan prices, change date</td>\n<td>Mathematical verification of charges</td>\n</tr>\n<tr>\n<td>Downgrade Credits</td>\n<td>Higher-tier plan, remaining days</td>\n<td>Credit calculation accuracy</td>\n</tr>\n<tr>\n<td>Quantity Changes</td>\n<td>Seat-based plans, usage changes</td>\n<td>Per-unit proration validation</td>\n</tr>\n<tr>\n<td>Currency Handling</td>\n<td>Multi-currency plans</td>\n<td>Precision and rounding verification</td>\n</tr>\n</tbody></table>\n<p><strong>Credit Balance Management Validation</strong> ensures that customer credits are properly tracked, applied automatically to invoices, and maintained across billing cycles. The validation process creates scenarios with various credit sources and verifies correct application order.</p>\n<p><strong>Plan Change Orchestration Validation</strong> tests the end-to-end plan change process, from customer request through proration calculation to service level adjustment. This validation ensures that complex plan changes maintain system consistency.</p>\n<p><strong>Acceptance Criteria Validation</strong>:</p>\n<ol>\n<li><strong>Proration Accuracy</strong>: Calculate prorated charges for upgrades based on remaining cycle days</li>\n<li><strong>Credit Application</strong>: Apply downgrade credits for unused portions of higher-tier plans</li>\n<li><strong>Mid-cycle Changes</strong>: Handle plan changes with correct effective dates and amounts</li>\n<li><strong>Change Scheduling</strong>: Support immediate vs end-of-cycle plan change options</li>\n</ol>\n<h4 id=\"milestone-4-usage-based-billing-validation\">Milestone 4: Usage-Based Billing Validation</h4>\n<p><strong>Usage Event Processing Validation</strong> verifies that metered usage events are correctly ingested, deduplicated, and aggregated for billing purposes. The validation process submits known usage quantities and verifies accurate aggregation across billing periods.</p>\n<table>\n<thead>\n<tr>\n<th>Usage Validation</th>\n<th>Test Scenario</th>\n<th>Expected Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Event Deduplication</td>\n<td>Duplicate submission with same idempotency key</td>\n<td>Single event counted</td>\n</tr>\n<tr>\n<td>Billing Period Aggregation</td>\n<td>Events across multiple periods</td>\n<td>Correct period assignment</td>\n</tr>\n<tr>\n<td>Usage Type Isolation</td>\n<td>Multiple metrics per customer</td>\n<td>Separate aggregation per metric</td>\n</tr>\n<tr>\n<td>Overage Calculation</td>\n<td>Usage exceeding plan allowances</td>\n<td>Accurate tiered rate application</td>\n</tr>\n</tbody></table>\n<p><strong>Overage Billing Validation</strong> ensures that usage beyond plan allowances is correctly calculated using tiered pricing structures. The validation creates usage scenarios that span multiple pricing tiers and verifies accurate charge calculation.</p>\n<p><strong>Usage Quota Enforcement Validation</strong> tests the real-time quota checking system that prevents customers from exceeding plan allowances. The validation verifies that quota checks return accurate current usage and remaining allowances.</p>\n<p><strong>Acceptance Criteria Validation</strong>:</p>\n<ol>\n<li><strong>Idempotent Event Ingestion</strong>: Submit usage events with deduplication protection</li>\n<li><strong>Billing Period Aggregation</strong>: Aggregate usage across correct billing boundaries</li>\n<li><strong>Tiered Usage Charges</strong>: Calculate charges based on usage tier structures</li>\n<li><strong>Overage Rate Application</strong>: Apply correct per-unit overage rates when usage exceeds allowances</li>\n</ol>\n<h3 id=\"common-testing-pitfalls\">Common Testing Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Currency Precision Testing</strong></p>\n<p>Many developers test billing calculations using floating-point arithmetic, which introduces precision errors that compound across many transactions. For example, testing a $9.99 monthly subscription with a 33% proration might use <code>9.99 * 0.33</code> in the test, yielding <code>3.2967</code> which doesn&#39;t represent any valid currency amount.</p>\n<p>The correct approach stores all monetary values as integer cents and performs calculations in integer arithmetic. Test assertions should compare exact cent amounts: <code>assert proration.amount_cents == 329</code> rather than floating-point approximations.</p>\n<p>⚠️ <strong>Pitfall: Time Zone Inconsistency in Testing</strong></p>\n<p>Billing systems operate across multiple time zones, but tests often use local system time, creating inconsistent results when run in different environments. A test that works in EST might fail in PST due to billing period boundary calculations.</p>\n<p>All tests must use UTC timestamps consistently and explicitly test time zone edge cases. Test data should include customers in various time zones to verify that billing anchor dates are calculated correctly regardless of system time zone.</p>\n<p>⚠️ <strong>Pitfall: Inadequate Idempotency Testing</strong></p>\n<p>Developers often test the &quot;happy path&quot; for idempotent operations but fail to test edge cases like partial failures, network timeouts, and retry scenarios. Testing idempotency with simple duplicate requests misses the complex scenarios that occur in production.</p>\n<p>Comprehensive idempotency testing must simulate network failures, database timeouts, and system crashes at various points in request processing. Tests should verify that operations remain idempotent even when internal state changes between retry attempts.</p>\n<p>⚠️ <strong>Pitfall: Missing Webhook Timing Tests</strong></p>\n<p>Payment webhook testing often assumes immediate delivery and processing, but production webhooks can be delayed, delivered out of order, or arrive after timeouts have occurred. Tests that don&#39;t account for webhook timing issues fail to catch state machine edge cases.</p>\n<p>Webhook tests must simulate delayed delivery, duplicate webhooks, and out-of-order processing. The test framework should control webhook timing independently from payment processing to verify that the system handles all temporal orderings correctly.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Error State Testing</strong></p>\n<p>Many billing tests focus on successful operations but provide inadequate coverage of error states and recovery scenarios. Testing only successful plan changes misses the complex rollback logic required when payments fail mid-process.</p>\n<p>Error state testing must cover every point where operations can fail and verify that the system maintains consistency. This includes testing partial failures, timeout scenarios, and concurrent modification conflicts that can occur in production environments.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The testing implementation provides comprehensive validation tools for all billing system components. The test suite combines mathematical precision testing for calculations with robust integration testing for component interactions.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unit Testing Framework</td>\n<td><code>pytest</code> with fixtures</td>\n<td><code>pytest</code> with <code>hypothesis</code> for property testing</td>\n</tr>\n<tr>\n<td>Database Testing</td>\n<td>SQLite in-memory database</td>\n<td>PostgreSQL test containers with transaction rollback</td>\n</tr>\n<tr>\n<td>HTTP Testing</td>\n<td><code>requests</code> with mock responses</td>\n<td><code>wiremock</code> for full HTTP simulation</td>\n</tr>\n<tr>\n<td>Property-Based Testing</td>\n<td>Manual test case generation</td>\n<td><code>hypothesis</code> for automated test generation</td>\n</tr>\n<tr>\n<td>Time Testing</td>\n<td>Fixed datetime mocking</td>\n<td><code>freezegun</code> for temporal scenario control</td>\n</tr>\n<tr>\n<td>Currency Testing</td>\n<td>Manual decimal calculations</td>\n<td><code>babel</code> for multi-currency test data</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-test-structure\">Recommended Test Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>tests/\n  unit/\n    billing/\n      test_proration_calculator.py      ← Mathematical calculation tests\n      test_usage_aggregator.py          ← Usage event processing tests\n      test_pricing_models.py            ← Pricing calculation tests\n      test_feature_entitlements.py      ← Access control tests\n    subscription/\n      test_lifecycle_manager.py         ← State machine tests\n      test_renewal_processor.py         ← Billing cycle tests\n      test_dunning_engine.py            ← Payment failure recovery tests\n  integration/\n    test_billing_workflows.py           ← End-to-end billing processes\n    test_payment_gateway.py             ← Payment integration tests\n    test_webhook_processing.py          ← Asynchronous event tests\n  fixtures/\n    billing_test_data.py                ← Test data generation utilities\n    payment_gateway_mock.py             ← Payment simulation infrastructure\n    database_fixtures.py               ← Database state setup utilities\n  milestone_validation/\n    test_milestone_1_plans.py           ← Plan management validation\n    test_milestone_2_lifecycle.py       ← Subscription lifecycle validation\n    test_milestone_3_proration.py       ← Plan change validation\n    test_milestone_4_usage.py           ← Usage-based billing validation</code></pre></div>\n\n<h4 id=\"core-testing-infrastructure\">Core Testing Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># fixtures/billing_test_data.py - Test data generation utilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestScenario</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a billing test scenario with known inputs and expected outputs.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    setup_data: Dict</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_result: Dict</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    validation_rules: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BillingTestDataGenerator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Generates realistic test data for billing calculations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_test_plan</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        plan_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"flat_rate\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        base_price_cents: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 999</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currency: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"USD\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        billing_interval: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"month\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create test plan with specified parameters.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate plan_id and set basic plan attributes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create pricing_tiers based on plan_type parameter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Define feature_entitlements for test scenarios</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Set billing_interval and currency_code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return complete plan dictionary for test usage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_test_customer</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        credit_balance_cents: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timezone: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"UTC\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create test customer with specified credit balance.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate customer_id and basic customer data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Set credit_balance_cents and timezone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create default payment method for testing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return customer dictionary with payment method</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_billing_scenario</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        scenario_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        plan_data: Dict,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        customer_data: Dict</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> TestScenario:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate complete test scenario with expected results.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create subscription linking customer to plan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Generate usage events based on scenario_type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate expected proration or usage charges</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Define validation rules for test assertions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return TestScenario with all test data and expectations</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ProrationTestGenerator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Specialized test data for proration calculations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_plan_change_scenarios</span><span style=\"color:#E1E4E8\">(self) -> List[TestScenario]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate comprehensive plan change test cases.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create upgrade scenarios with various timing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create downgrade scenarios with credit calculations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create quantity change scenarios for seat-based plans</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add edge cases for billing period boundaries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Include multi-currency scenarios</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return list of all generated test scenarios</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_calendar_edge_cases</span><span style=\"color:#E1E4E8\">(self) -> List[TestScenario]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate calendar edge case scenarios for proration.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create leap year scenarios (Feb 29 billing anchor)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create month overflow scenarios (Jan 31 + 1 month)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create timezone transition scenarios (DST changes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create end-of-month billing scenarios</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return comprehensive calendar edge case scenarios</span></span></code></pre></div>\n\n<h4 id=\"property-based-testing-framework\">Property-Based Testing Framework</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/unit/billing/test_proration_properties.py - Property-based proration testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> hypothesis </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> given, strategies </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> st, assume</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> date, timedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ProrationPropertyTests</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Property-based tests for proration mathematical invariants.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @given</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        old_price</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.integers(</span><span style=\"color:#FFAB70\">min_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#E1E4E8\">),  </span><span style=\"color:#6A737D\"># $1-$1000 in cents</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        new_price</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.integers(</span><span style=\"color:#FFAB70\">min_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        change_date</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.dates(</span><span style=\"color:#FFAB70\">min_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">date(</span><span style=\"color:#79B8FF\">2024</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">max_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">date(</span><span style=\"color:#79B8FF\">2024</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">31</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        billing_start</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.dates(</span><span style=\"color:#FFAB70\">min_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">date(</span><span style=\"color:#79B8FF\">2024</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">max_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">date(</span><span style=\"color:#79B8FF\">2024</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_proration_symmetry_property</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self, old_price: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, new_price: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, change_date: date, billing_start: date</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify that upgrade followed by immediate downgrade nets to zero.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Ensure change_date is within billing period</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        billing_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> billing_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> timedelta(</span><span style=\"color:#FFAB70\">days</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assume(billing_start </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> change_date </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> billing_end)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate proration for upgrade from old_price to new_price</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Calculate proration for immediate downgrade back to old_price</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify that net proration amount is zero (within rounding tolerance)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify that both calculations use same time factor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use ProrationCalculator.calculate_plan_change_proration for both calculations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @given</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        base_price</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.integers(</span><span style=\"color:#FFAB70\">min_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">500</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        period_days</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.integers(</span><span style=\"color:#FFAB70\">min_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">28</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">31</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        change_day</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.integers(</span><span style=\"color:#FFAB70\">min_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">31</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_proration_monotonicity</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self, base_price: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, period_days: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, change_day: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify that later change dates result in smaller proration amounts.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        assume(change_day </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> period_days)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate proration for change on change_day</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Calculate proration for change one day later (if within period)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify that later change has smaller absolute proration amount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle edge case where change_day is last day of period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Proration amount should decrease as change_date approaches period_end</span></span></code></pre></div>\n\n<h4 id=\"integration-test-infrastructure\">Integration Test Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/integration/test_billing_workflows.py - End-to-end billing workflow testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> unittest.mock </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Mock, patch</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BillingWorkflowIntegrationTests</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Integration tests for complete billing workflows.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> billing_test_environment</span><span style=\"color:#E1E4E8\">(self, db_session):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set up complete test environment with all components.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create test database with all billing tables</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Initialize mock payment gateway with test responses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Set up event bus with test event handlers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create test customers, plans, and subscriptions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return configured test environment object</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_complete_subscription_lifecycle</span><span style=\"color:#E1E4E8\">(self, billing_test_environment):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test complete customer journey from signup to cancellation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> billing_test_environment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create customer with payment method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create subscription with trial period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Process trial expiration and first payment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Generate usage events and process monthly billing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Process plan upgrade with proration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Cancel subscription and verify final billing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Validate all audit events and state transitions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Validation points</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Verify subscription state progression is correct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Verify all invoices have accurate line items</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 10: Verify payment processing completed successfully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 11: Verify audit trail captures all operations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_payment_failure_recovery</span><span style=\"color:#E1E4E8\">(self, billing_test_environment):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test complete dunning process for failed payments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> billing_test_environment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create active subscription with invalid payment method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Trigger billing cycle and simulate payment failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify dunning process initiates correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Process multiple retry attempts with continued failures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Verify subscription transitions to unpaid status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Test payment method update and recovery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Verify subscription reactivates after successful payment</span></span></code></pre></div>\n\n<h4 id=\"milestone-validation-scripts\">Milestone Validation Scripts</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/milestone_validation/test_milestone_1_plans.py - Plan management milestone validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Milestone1ValidationTests</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Comprehensive validation for Milestone 1: Plans &#x26; Pricing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_plan_definition_schema</span><span style=\"color:#E1E4E8\">(self, plan_manager):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate plan definition supports required schema elements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Acceptance Criteria: Define subscription plans with tiers, intervals, and pricing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create flat-rate plan with monthly billing interval</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create tiered plan with multiple pricing tiers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create per-seat plan with quantity-based pricing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify all plans store correctly with complete schema</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Test plan retrieval and validation of all fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Expected behaviors:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Plan creation returns valid plan_id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - All pricing tiers store with correct boundaries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Feature entitlements associate correctly with plans</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Currency and interval settings persist accurately</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_pricing_model_calculations</span><span style=\"color:#E1E4E8\">(self, plan_manager):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate pricing model charge calculations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Acceptance Criteria: Support multiple pricing models (flat, tiered)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Test flat-rate pricing calculation for various quantities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Test tiered pricing with usage spanning multiple tiers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Test volume pricing with rate changes at thresholds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify currency conversion maintains precision</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Test edge cases at tier boundaries</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Mathematical validation:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Flat-rate: charge = base_price * quantity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Tiered: charge = sum(tier_rate * tier_quantity for each tier)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Volume: charge = total_quantity * applicable_rate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_plan_versioning_protection</span><span style=\"color:#E1E4E8\">(self, plan_manager):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate plan versioning protects existing customers.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Acceptance Criteria: Handle plan versioning for existing subscribers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create plan and subscribe test customer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Update plan pricing and create new version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify existing customer retains original pricing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify new customers receive updated pricing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Test plan deprecation and grandfather protection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Validation checkpoints:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ Plan creation and versioning\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ Existing customer price protection\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ New customer updated pricing\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ Feature entitlement inheritance\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"debugging-test-utilities\">Debugging Test Utilities</h4>\n<table>\n<thead>\n<tr>\n<th>Test Failure Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Command</th>\n<th>Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Proration calculation mismatch</td>\n<td>Floating point precision error</td>\n<td>Check test uses integer cents</td>\n<td>Convert all amounts to integer cents</td>\n</tr>\n<tr>\n<td>Webhook test timing out</td>\n<td>Mock gateway not configured</td>\n<td>Verify mock responses set up</td>\n<td>Initialize payment gateway mock properly</td>\n</tr>\n<tr>\n<td>Database constraint violation</td>\n<td>Test data conflicts with existing</td>\n<td>Use transaction rollback fixtures</td>\n<td>Isolate tests with database transactions</td>\n</tr>\n<tr>\n<td>Property test failure</td>\n<td>Edge case not handled</td>\n<td>Run test with <code>--hypothesis-verbose</code></td>\n<td>Add assume() statements for valid inputs</td>\n</tr>\n<tr>\n<td>Integration test flakiness</td>\n<td>Race condition in async processing</td>\n<td>Add explicit event synchronization</td>\n<td>Use event bus sync points in tests</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-checkpoint-validation\">Milestone Checkpoint Validation</h4>\n<p><strong>Milestone 1 Checkpoint</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run plan management validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/milestone_validation/test_milestone_1_plans.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ✓ test_plan_definition_schema - PASSED</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ✓ test_pricing_model_calculations - PASSED  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ✓ test_plan_versioning_protection - PASSED</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ✓ test_feature_entitlements - PASSED</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 1. Create plan via API: POST /api/plans with plan data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 2. Verify response includes plan_id and all specified fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 3. Retrieve plan: GET /api/plans/{plan_id}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 4. Confirm pricing tiers and features are correct</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Checkpoint</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run subscription lifecycle validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/milestone_validation/test_milestone_2_lifecycle.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behaviors to verify:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 1. Subscription creation provisions customer access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 2. Renewal processing generates accurate invoices</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 3. Cancellation respects end-of-period vs immediate options</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 4. State transitions follow business rules</span></span></code></pre></div>\n\n<p><strong>Milestone 3 Checkpoint</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run proration calculation validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/milestone_validation/test_milestone_3_proration.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Mathematical verification:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 1. Mid-cycle upgrade: charge = (new_price - old_price) * time_factor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 2. Downgrade credit: credit = (old_price - new_price) * time_factor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 3. Time factor: remaining_days / total_period_days</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 4. Currency precision: all calculations in integer cents</span></span></code></pre></div>\n\n<p><strong>Milestone 4 Checkpoint</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run usage-based billing validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/milestone_validation/test_milestone_4_usage.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Usage processing verification:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 1. Submit usage events with idempotency keys</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 2. Verify aggregation across billing periods</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 3. Calculate overage charges for usage beyond allowances</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 4. Test quota enforcement and limit checking</span></span></code></pre></div>\n\n<p>The testing strategy provides comprehensive validation across all billing system components, ensuring mathematical accuracy, integration reliability, and milestone completion verification. The property-based testing approach catches edge cases that manual test writing might miss, while the milestone validation checkpoints provide clear success criteria for each development phase.</p>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - provides diagnostic techniques and troubleshooting approaches essential for identifying and resolving issues across plan management (Milestone 1), subscription lifecycle (Milestone 2), proration calculations (Milestone 3), and usage-based billing (Milestone 4)</p>\n</blockquote>\n<h3 id=\"mental-model-detective-work-for-financial-systems\">Mental Model: Detective Work for Financial Systems</h3>\n<p>Think of debugging a billing system like being a financial detective investigating discrepancies in a complex accounting operation. Just as a detective follows the money trail through bank records, receipts, and transaction logs, billing system debugging requires tracing data flow through multiple components, examining audit trails, and understanding the sequence of events that led to incorrect calculations or inconsistent states.</p>\n<p>Unlike debugging typical web applications where the worst outcome might be a 500 error, billing system bugs directly impact revenue and customer trust. A proration calculation error could overcharge thousands of customers, while a webhook processing failure might leave subscriptions in inconsistent states. The debugging approach must be systematic, thorough, and focused on financial accuracy and data consistency.</p>\n<p>The debugging process mirrors forensic accounting: start with the symptom (incorrect invoice amount, stuck subscription), trace backwards through the audit trail (events, state changes, calculations), identify the root cause (rounding error, race condition, webhook duplication), and implement fixes that prevent recurrence. Every financial operation must be explainable and recoverable.</p>\n<h3 id=\"billing-calculation-issues\">Billing Calculation Issues</h3>\n<p>Billing calculation debugging requires understanding the mathematical precision, currency handling, and complex interaction between base charges, usage fees, proration, and credits. These issues often manifest as subtle discrepancies that compound over time or edge cases that only occur under specific conditions.</p>\n<h4 id=\"currency-precision-and-rounding-errors\">Currency Precision and Rounding Errors</h4>\n<p>Currency precision errors are among the most common and dangerous billing calculation issues. These problems typically stem from mixing floating-point arithmetic with financial calculations or incorrect rounding when converting between different currency representations.</p>\n<p><strong>Common Currency Precision Problems:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Problem Type</th>\n<th>Symptom</th>\n<th>Root Cause</th>\n<th>Detection Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Floating Point Drift</td>\n<td>Invoice totals off by 1-2 cents</td>\n<td>Using <code>float</code> instead of integer cents</td>\n<td>Compare sum of line items vs total amount</td>\n</tr>\n<tr>\n<td>Rounding Inconsistency</td>\n<td>Line item totals don&#39;t match invoice total</td>\n<td>Different rounding at each calculation step</td>\n<td>Recalculate invoice from scratch and compare</td>\n</tr>\n<tr>\n<td>Currency Conversion Precision</td>\n<td>Multi-currency invoices with tiny discrepancies</td>\n<td>Exchange rate precision loss</td>\n<td>Check conversion rate precision and intermediate values</td>\n</tr>\n<tr>\n<td>Aggregate Rounding</td>\n<td>Usage charges incorrect for high quantities</td>\n<td>Rounding per-unit vs rounding total</td>\n<td>Compare unit-by-unit vs bulk calculation methods</td>\n</tr>\n</tbody></table>\n<p>The fundamental principle for currency debugging is that all monetary values must be stored and calculated using the smallest currency unit (cents for USD). Any conversion to decimal representation should happen only at the display layer, never during calculations.</p>\n<p><strong>Proration Calculation Debugging:</strong></p>\n<p>Proration errors are particularly insidious because they involve both time-based calculations and currency precision. The debugging approach requires validating both the time fraction calculation and the monetary arithmetic.</p>\n<table>\n<thead>\n<tr>\n<th>Proration Issue</th>\n<th>Diagnostic Steps</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Incorrect Time Fraction</td>\n<td>Log change date, period start, period end</td>\n<td>Calculate days manually: <code>(period_end - change_date) / (period_end - period_start)</code></td>\n</tr>\n<tr>\n<td>Asymmetric Proration</td>\n<td>Upgrade charge doesn&#39;t match downgrade credit</td>\n<td>Test upgrade followed by immediate downgrade - net should be zero</td>\n</tr>\n<tr>\n<td>Calendar Edge Cases</td>\n<td>Wrong proration on month boundaries</td>\n<td>Test month-end changes, leap year scenarios, timezone boundaries</td>\n</tr>\n<tr>\n<td>Multiple Plan Changes</td>\n<td>Cumulative proration errors</td>\n<td>Sum all proration amounts for billing period - should equal net plan difference</td>\n</tr>\n</tbody></table>\n<p>The proration debugging process should always start with validating the time calculations before examining monetary arithmetic. A common mistake is debugging currency precision when the actual issue is incorrect date handling or timezone problems.</p>\n<p><strong>Usage Aggregation and Tiered Pricing Issues:</strong></p>\n<p>Usage-based billing introduces additional complexity because charges depend on both quantity calculations and tier boundary logic. Debugging requires understanding the aggregation methodology and tier calculation algorithms.</p>\n<table>\n<thead>\n<tr>\n<th>Usage Billing Problem</th>\n<th>Investigation Approach</th>\n<th>Key Validation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Incorrect Usage Totals</td>\n<td>Trace individual events to final aggregation</td>\n<td>Manual sum of events vs aggregated quantity</td>\n</tr>\n<tr>\n<td>Wrong Tier Application</td>\n<td>Examine tier boundary conditions</td>\n<td>Test quantities at tier boundaries (999, 1000, 1001)</td>\n</tr>\n<tr>\n<td>Duplicate Event Charging</td>\n<td>Check idempotency key handling</td>\n<td>Search for duplicate <code>idempotency_key</code> values</td>\n</tr>\n<tr>\n<td>Missing Overage Charges</td>\n<td>Validate allowance vs actual usage</td>\n<td>Compare plan allowance against aggregated usage</td>\n</tr>\n<tr>\n<td>Cross-Period Event Attribution</td>\n<td>Check event timestamps vs billing periods</td>\n<td>Verify events assigned to correct billing cycle</td>\n</tr>\n</tbody></table>\n<p>Usage debugging often requires examining the raw event data and manually recalculating aggregations. The <code>UsageEvent</code> table should be treated as the source of truth, and all aggregated values should be derivable from this base data.</p>\n<h4 id=\"credit-balance-and-application-errors\">Credit Balance and Application Errors</h4>\n<p>Credit balance issues occur when customer credits aren&#39;t applied correctly to invoices, or when credit calculations don&#39;t match the corresponding charges. These problems often involve incorrect sequencing of credit operations or failure to handle partial credit applications.</p>\n<p><strong>Credit Balance Debugging Matrix:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Credit Issue Type</th>\n<th>Symptoms</th>\n<th>Diagnostic Query</th>\n<th>Expected Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Credits Not Applied</td>\n<td>Invoice amount ignores available credit</td>\n<td><code>SELECT * FROM customer WHERE customer_id = ? AND credit_balance_cents &gt; 0</code></td>\n<td>Credit balance should decrease after invoice</td>\n</tr>\n<tr>\n<td>Partial Credit Application</td>\n<td>Credit partially consumed but amount wrong</td>\n<td>Trace credit consumption in audit logs</td>\n<td>Credit reduction should equal amount applied</td>\n</tr>\n<tr>\n<td>Negative Credit Balance</td>\n<td>Customer credit balance below zero</td>\n<td>Check for concurrent credit consumption</td>\n<td>Credit operations should be atomic</td>\n</tr>\n<tr>\n<td>Orphaned Credits</td>\n<td>Credits exist but never applied to invoices</td>\n<td>Find credits without corresponding invoice line items</td>\n<td>All credits should have application records</td>\n</tr>\n</tbody></table>\n<p>The credit debugging process requires examining both the current credit balance and the complete history of credit applications through the audit trail. Every credit operation should be traceable through the <code>AuditEvent</code> records.</p>\n<h3 id=\"state-consistency-problems\">State Consistency Problems</h3>\n<p>State consistency issues in billing systems typically involve subscription states becoming misaligned with payment states, invoice states, or usage tracking states. These problems often result from partial failures in distributed operations or race conditions between concurrent processes.</p>\n<h4 id=\"subscription-state-inconsistencies\">Subscription State Inconsistencies</h4>\n<p>Subscription state debugging requires understanding the valid state transitions and identifying how the subscription reached an invalid or unexpected state. The subscription state machine provides the framework for validating state consistency.</p>\n<p><strong>Subscription State Validation Checklist:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Required Conditions</th>\n<th>Inconsistency Indicators</th>\n<th>Recovery Actions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>active</code></td>\n<td>Valid payment method, current invoice paid</td>\n<td>No payment method or unpaid invoice</td>\n<td>Check payment status and payment method validity</td>\n</tr>\n<tr>\n<td><code>past_due</code></td>\n<td>Active dunning process, unpaid invoice exists</td>\n<td>No dunning attempts or no unpaid invoices</td>\n<td>Verify dunning engine status and invoice generation</td>\n</tr>\n<tr>\n<td><code>cancelled</code></td>\n<td>Cancellation event exists, no future invoices</td>\n<td>Active invoices scheduled for future</td>\n<td>Cancel future invoices and verify cancellation timestamp</td>\n</tr>\n<tr>\n<td><code>paused</code></td>\n<td>Pause event exists, billing suspended</td>\n<td>Recent invoices or payments</td>\n<td>Check pause effective date and billing suspension</td>\n</tr>\n</tbody></table>\n<p>The key to subscription state debugging is examining the sequence of <code>SubscriptionEvent</code> records that led to the current state. Every state transition should correspond to a specific event with proper authorization and business justification.</p>\n<p><strong>Concurrent Modification Detection:</strong></p>\n<p>Race conditions in subscription updates can lead to lost state changes or invalid state transitions. The optimistic locking mechanism using version numbers provides protection against concurrent modifications.</p>\n<table>\n<thead>\n<tr>\n<th>Concurrency Problem</th>\n<th>Detection Method</th>\n<th>Prevention Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lost State Updates</td>\n<td>Version mismatch exceptions in logs</td>\n<td>Retry with fresh entity load</td>\n</tr>\n<tr>\n<td>Invalid State Transitions</td>\n<td>State machine violations</td>\n<td>Validate transitions before persisting</td>\n</tr>\n<tr>\n<td>Duplicate Event Processing</td>\n<td>Multiple events with same idempotency key</td>\n<td>Check idempotency key uniqueness</td>\n</tr>\n<tr>\n<td>Timeline Ordering Issues</td>\n<td>Events processed out of sequence</td>\n<td>Use event timestamp ordering for replay</td>\n</tr>\n</tbody></table>\n<p>When debugging concurrency issues, examine the <code>WorkflowExecution</code> records to understand which operations were running simultaneously and whether any workflow steps failed due to conflicts.</p>\n<h4 id=\"invoice-and-payment-state-alignment\">Invoice and Payment State Alignment</h4>\n<p>Invoice states must remain consistent with payment states and subscription states. Misalignment often occurs when webhook processing fails or when manual interventions bypass the normal workflow.</p>\n<p><strong>Invoice-Payment Consistency Matrix:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Invoice Status</th>\n<th>Expected Payment Status</th>\n<th>Inconsistency Pattern</th>\n<th>Resolution Steps</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>draft</code></td>\n<td>No payments exist</td>\n<td>Payments exist for draft invoice</td>\n<td>Investigate manual payment creation</td>\n</tr>\n<tr>\n<td><code>open</code></td>\n<td><code>pending</code> or no payment</td>\n<td><code>succeeded</code> payment but invoice still open</td>\n<td>Process payment success webhook</td>\n</tr>\n<tr>\n<td><code>paid</code></td>\n<td><code>succeeded</code> payment</td>\n<td>No successful payment found</td>\n<td>Check for manual payment recording</td>\n</tr>\n<tr>\n<td><code>past_due</code></td>\n<td><code>failed</code> payment</td>\n<td><code>succeeded</code> payment</td>\n<td>Investigate webhook processing delay</td>\n</tr>\n</tbody></table>\n<p>Invoice state debugging requires correlating invoice records with payment records using the <code>invoice_id</code> foreign key. Every paid invoice should have exactly one successful payment, and every successful payment should correspond to a paid invoice.</p>\n<p><strong>Payment Gateway Synchronization Issues:</strong></p>\n<p>Billing system state can become inconsistent with payment gateway state when webhooks fail to process or when manual operations occur in the gateway without corresponding system updates.</p>\n<table>\n<thead>\n<tr>\n<th>Synchronization Issue</th>\n<th>Detection Strategy</th>\n<th>Reconciliation Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Missing Webhook Processing</td>\n<td>Gateway payment exists, no system payment</td>\n<td>Compare gateway transactions with system payments</td>\n</tr>\n<tr>\n<td>Duplicate Payment Recording</td>\n<td>Multiple system payments for single gateway charge</td>\n<td>Search for payments with same <code>gateway_transaction_id</code></td>\n</tr>\n<tr>\n<td>Amount Mismatches</td>\n<td>System payment amount differs from gateway</td>\n<td>Compare <code>amount_cents</code> with gateway charge amount</td>\n</tr>\n<tr>\n<td>Status Lag</td>\n<td>Gateway shows success, system shows pending</td>\n<td>Check webhook event processing timestamps</td>\n</tr>\n</tbody></table>\n<p>Payment gateway debugging often requires accessing the gateway&#39;s dashboard or API to compare transaction states with internal system records. The <code>WebhookEvent</code> table provides an audit trail of all webhook processing attempts.</p>\n<h3 id=\"webhook-and-integration-debugging\">Webhook and Integration Debugging</h3>\n<p>Webhook processing failures can leave the billing system in inconsistent states because external payment events aren&#39;t properly reflected in system state. Debugging webhook issues requires understanding both the technical integration mechanisms and the business implications of processing delays or failures.</p>\n<h4 id=\"webhook-processing-reliability\">Webhook Processing Reliability</h4>\n<p>Webhook reliability debugging focuses on ensuring that payment gateway events are consistently processed and applied to the appropriate billing entities. This involves examining the webhook ingestion pipeline, idempotency protection, and error handling.</p>\n<p><strong>Webhook Processing Diagnostic Flow:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Processing Stage</th>\n<th>Success Indicators</th>\n<th>Failure Symptoms</th>\n<th>Debug Actions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Webhook Reception</td>\n<td>Request logged with valid signature</td>\n<td>400/500 errors in webhook endpoint</td>\n<td>Check webhook URL configuration and signature validation</td>\n</tr>\n<tr>\n<td>Event Parsing</td>\n<td><code>WebhookEvent</code> record created</td>\n<td>JSON parsing errors in logs</td>\n<td>Validate webhook payload structure against gateway documentation</td>\n</tr>\n<tr>\n<td>Idempotency Check</td>\n<td>Duplicate events ignored gracefully</td>\n<td>Same event processed multiple times</td>\n<td>Verify <code>idempotency_key</code> uniqueness enforcement</td>\n</tr>\n<tr>\n<td>Business Logic Application</td>\n<td>Entity states updated correctly</td>\n<td>State inconsistencies after webhook</td>\n<td>Trace event processing through business logic</td>\n</tr>\n</tbody></table>\n<p>The webhook debugging process should start by confirming that webhooks are being received by the system. Check the webhook endpoint logs for incoming requests and verify that the payment gateway is configured with the correct URL and credentials.</p>\n<p><strong>Webhook Event Deduplication Issues:</strong></p>\n<p>Payment gateways may send duplicate webhooks due to network retries or internal processing issues. The idempotency protection mechanism must correctly identify and ignore duplicate events without losing legitimate updates.</p>\n<table>\n<thead>\n<tr>\n<th>Deduplication Problem</th>\n<th>Identification Method</th>\n<th>Root Cause Analysis</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Duplicate Processing</td>\n<td>Same payment updated multiple times</td>\n<td>Check <code>idempotency_key</code> uniqueness in <code>WebhookEvent</code> table</td>\n</tr>\n<tr>\n<td>False Duplicate Detection</td>\n<td>Legitimate events ignored</td>\n<td>Examine idempotency key generation logic</td>\n</tr>\n<tr>\n<td>Race Condition in Deduplication</td>\n<td>Intermittent duplicate processing</td>\n<td>Check concurrent webhook processing timing</td>\n</tr>\n<tr>\n<td>Cross-Event Type Conflicts</td>\n<td>Different event types sharing idempotency keys</td>\n<td>Validate idempotency key scoping strategy</td>\n</tr>\n</tbody></table>\n<p>Effective webhook deduplication debugging requires examining both the incoming webhook payloads and the generated idempotency keys. The idempotency key should uniquely identify each business event, not just each HTTP request.</p>\n<h4 id=\"payment-method-and-subscription-synchronization\">Payment Method and Subscription Synchronization</h4>\n<p>Payment method updates in the gateway must be reflected in subscription billing configurations to ensure future payments succeed. Debugging these synchronization issues involves tracing payment method lifecycle events through both systems.</p>\n<p><strong>Payment Method Sync Debugging:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Sync Issue</th>\n<th>System Impact</th>\n<th>Debugging Approach</th>\n<th>Resolution Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Outdated Payment Method</td>\n<td>Recurring payments fail</td>\n<td>Compare system vs gateway payment method status</td>\n<td>Refresh payment method from gateway API</td>\n</tr>\n<tr>\n<td>Missing Payment Method Updates</td>\n<td>Card expiration not reflected</td>\n<td>Check webhook processing for payment method events</td>\n<td>Implement payment method webhook handlers</td>\n</tr>\n<tr>\n<td>Customer Payment Method Misalignment</td>\n<td>Payments charged to wrong method</td>\n<td>Validate customer-payment method associations</td>\n<td>Reconcile customer records between systems</td>\n</tr>\n<tr>\n<td>Default Payment Method Conflicts</td>\n<td>Multiple methods marked as default</td>\n<td>Query payment methods for customer</td>\n<td>Implement default payment method enforcement</td>\n</tr>\n</tbody></table>\n<p>Payment method debugging often requires cross-referencing data between the billing system and payment gateway. The <code>PaymentMethod</code> table should maintain accurate references to gateway payment method tokens and their current status.</p>\n<p><strong>Integration Circuit Breaker and Retry Logic:</strong></p>\n<p>When external integrations fail repeatedly, circuit breakers prevent cascading failures while retry logic attempts to recover from transient issues. Debugging these mechanisms helps identify when external services are degraded and how the system responds.</p>\n<table>\n<thead>\n<tr>\n<th>Integration Health Issue</th>\n<th>Circuit Breaker State</th>\n<th>Debug Information</th>\n<th>Recovery Actions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Gateway API Timeouts</td>\n<td>Circuit opening frequently</td>\n<td>Check response time metrics and failure rates</td>\n<td>Increase timeout values or investigate gateway performance</td>\n</tr>\n<tr>\n<td>Authentication Failures</td>\n<td>Circuit stuck open</td>\n<td>Examine API key validity and rotation</td>\n<td>Refresh authentication credentials</td>\n</tr>\n<tr>\n<td>Rate Limiting</td>\n<td>Requests failing with 429 errors</td>\n<td>Check request volume and rate limit headers</td>\n<td>Implement exponential backoff with jitter</td>\n</tr>\n<tr>\n<td>Webhook Endpoint Unreachable</td>\n<td>Gateway shows delivery failures</td>\n<td>Verify webhook endpoint availability and SSL certificate</td>\n<td>Fix infrastructure issues and re-register webhook URL</td>\n</tr>\n</tbody></table>\n<p>Circuit breaker debugging requires examining both the current circuit state and the historical failure patterns that triggered the protection mechanism. The <code>CircuitBreaker</code> component should provide visibility into failure thresholds and recovery timing.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The debugging implementation focuses on providing comprehensive diagnostic tools, structured logging, and automated consistency checks that help identify and resolve billing system issues efficiently.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Debugging Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Logging Framework</td>\n<td>Python <code>logging</code> with structured JSON</td>\n<td>ELK Stack (Elasticsearch, Logstash, Kibana)</td>\n</tr>\n<tr>\n<td>Metrics Collection</td>\n<td>Python <code>prometheus_client</code></td>\n<td>Datadog or New Relic APM</td>\n</tr>\n<tr>\n<td>Database Debugging</td>\n<td>Direct SQL queries with psql/mysql</td>\n<td>Database query analysis tools</td>\n</tr>\n<tr>\n<td>API Testing</td>\n<td><code>curl</code> and <code>pytest</code></td>\n<td>Postman collections with test automation</td>\n</tr>\n<tr>\n<td>Error Tracking</td>\n<td>Python <code>traceback</code> with file output</td>\n<td>Sentry error tracking and alerting</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure for Debugging Tools:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  src/\n    billing/\n      debug/\n        __init__.py\n        calculation_validator.py      ← billing calculation verification\n        state_consistency_checker.py  ← subscription state validation\n        webhook_debugger.py           ← webhook processing diagnostics\n        audit_trail_analyzer.py      ← audit event investigation tools\n        billing_reconciliation.py    ← system vs gateway comparison\n        test_data_generator.py       ← synthetic data for testing scenarios\n      monitoring/\n        __init__.py\n        billing_metrics.py           ← prometheus metrics collection\n        health_checks.py             ← system health validation\n        circuit_breaker_monitor.py   ← integration health monitoring\n  tools/\n    debug_billing_issue.py          ← command-line debugging utility\n    reconcile_payments.py           ← payment gateway synchronization\n    validate_billing_period.py     ← billing cycle validation script\n  tests/\n    debug_tools/\n      test_calculation_validator.py\n      test_state_consistency.py\n      test_webhook_debugger.py</code></pre></div>\n\n<p><strong>Infrastructure Starter Code - Billing Calculation Validator:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal, </span><span style=\"color:#79B8FF\">ROUND_HALF_UP</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CURRENCY_PRECISION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"currency_precision\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PRORATION_ASYMMETRY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"proration_asymmetry\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    USAGE_AGGREGATION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"usage_aggregation\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CREDIT_APPLICATION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"credit_application\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TIER_CALCULATION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"tier_calculation\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_valid: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    error_type: Optional[ValidationError]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_value: Any</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    actual_value: Any</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    details: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BillingCalculationValidator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Validates billing calculations for correctness and consistency.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Provides detailed diagnostics for calculation errors.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, decimal_precision: Decimal </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Decimal(</span><span style=\"color:#9ECBFF\">'0.01'</span><span style=\"color:#E1E4E8\">)):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.decimal_precision </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> decimal_precision</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_currency_precision</span><span style=\"color:#E1E4E8\">(self, money_amount: </span><span style=\"color:#9ECBFF\">'Money'</span><span style=\"color:#E1E4E8\">) -> ValidationResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Validates that monetary amounts maintain proper precision.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Checks for floating-point drift and rounding consistency.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Convert to decimal and back to check for precision loss</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        decimal_amount </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> money_amount.to_decimal()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        reconstructed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Money.from_decimal(decimal_amount, money_amount.currency_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> reconstructed.amount_cents </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> money_amount.amount_cents:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> ValidationResult(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                is_valid</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                error_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">ValidationError.</span><span style=\"color:#79B8FF\">CURRENCY_PRECISION</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                expected_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">money_amount.amount_cents,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                actual_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">reconstructed.amount_cents,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                details</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'original_cents'</span><span style=\"color:#E1E4E8\">: money_amount.amount_cents,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'decimal_representation'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(decimal_amount),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'reconstructed_cents'</span><span style=\"color:#E1E4E8\">: reconstructed.amount_cents,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'precision_loss'</span><span style=\"color:#E1E4E8\">: money_amount.amount_cents </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> reconstructed.amount_cents</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ValidationResult(</span><span style=\"color:#FFAB70\">is_valid</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">error_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">expected_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">actual_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">details</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_proration_symmetry</span><span style=\"color:#E1E4E8\">(self, old_plan: </span><span style=\"color:#9ECBFF\">'Plan'</span><span style=\"color:#E1E4E8\">, new_plan: </span><span style=\"color:#9ECBFF\">'Plan'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  change_date: datetime, billing_period_start: datetime,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  billing_period_end: datetime) -> ValidationResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Validates that upgrade followed by immediate downgrade results in zero net charge.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Tests proration calculation symmetry and consistency.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Calculate upgrade proration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        upgrade_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ProrationCalculator().calculate_plan_change_proration(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            old_plan, new_plan, change_date, billing_period_start, billing_period_end</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Calculate immediate downgrade proration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        downgrade_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ProrationCalculator().calculate_plan_change_proration(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            new_plan, old_plan, change_date, billing_period_start, billing_period_end</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Net amount should be zero (within precision tolerance)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        net_charge </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> upgrade_result.net_amount.amount_cents </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> downgrade_result.net_amount.amount_cents</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tolerance_cents </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#6A737D\">  # Allow 1 cent tolerance for rounding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> abs</span><span style=\"color:#E1E4E8\">(net_charge) </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> tolerance_cents:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> ValidationResult(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                is_valid</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                error_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">ValidationError.</span><span style=\"color:#79B8FF\">PRORATION_ASYMMETRY</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                expected_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                actual_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">net_charge,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                details</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'upgrade_net_cents'</span><span style=\"color:#E1E4E8\">: upgrade_result.net_amount.amount_cents,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'downgrade_net_cents'</span><span style=\"color:#E1E4E8\">: downgrade_result.net_amount.amount_cents,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'total_net_cents'</span><span style=\"color:#E1E4E8\">: net_charge,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'tolerance_cents'</span><span style=\"color:#E1E4E8\">: tolerance_cents,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'upgrade_details'</span><span style=\"color:#E1E4E8\">: upgrade_result.calculation_details,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'downgrade_details'</span><span style=\"color:#E1E4E8\">: downgrade_result.calculation_details</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ValidationResult(</span><span style=\"color:#FFAB70\">is_valid</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">error_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">expected_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">actual_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">details</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{})</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> StateConsistencyChecker</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Validates subscription and billing state consistency.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Identifies state machine violations and data synchronization issues.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, database_manager: </span><span style=\"color:#9ECBFF\">'DatabaseManager'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> database_manager</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> check_subscription_state_consistency</span><span style=\"color:#E1E4E8\">(self, subscription_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[ValidationResult]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Comprehensive subscription state validation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Checks state machine compliance and business rule adherence.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.db.transaction() </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> session:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            subscription </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> session.query(Subscription).filter_by(</span><span style=\"color:#FFAB70\">subscription_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">subscription_id).first()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> subscription:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> [ValidationResult(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    is_valid</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    error_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">ValidationError.</span><span style=\"color:#79B8FF\">CONSISTENCY</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    expected_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"subscription exists\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    actual_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"subscription not found\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    details</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">'subscription_id'</span><span style=\"color:#E1E4E8\">: subscription_id}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                )]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Validate state-specific conditions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            results.extend(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._validate_active_subscription_requirements(subscription, session))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            results.extend(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._validate_past_due_subscription_requirements(subscription, session))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            results.extend(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._validate_cancelled_subscription_requirements(subscription, session))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_active_subscription_requirements</span><span style=\"color:#E1E4E8\">(self, subscription: </span><span style=\"color:#9ECBFF\">'Subscription'</span><span style=\"color:#E1E4E8\">, session) -> List[ValidationResult]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate requirements for active subscription status.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> subscription.status </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> SubscriptionStatus.active:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Active subscription must have valid payment method</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        payment_methods </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> session.query(PaymentMethod).filter_by(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            customer_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">subscription.customer_id,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            is_default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ).all()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> payment_methods:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            results.append(ValidationResult(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                is_valid</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                error_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">ValidationError.</span><span style=\"color:#79B8FF\">STATE_CONSISTENCY</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                expected_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"active subscription has default payment method\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                actual_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"no default payment method found\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                details</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">'subscription_id'</span><span style=\"color:#E1E4E8\">: subscription.subscription_id, </span><span style=\"color:#9ECBFF\">'customer_id'</span><span style=\"color:#E1E4E8\">: subscription.customer_id}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> results</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> WebhookDebugger</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Diagnoses webhook processing issues and payment gateway synchronization problems.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Provides detailed analysis of webhook event flow and processing status.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, database_manager: </span><span style=\"color:#9ECBFF\">'DatabaseManager'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> database_manager</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> analyze_webhook_processing</span><span style=\"color:#E1E4E8\">(self, gateway_event_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Comprehensive webhook processing analysis.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Traces event from gateway through system processing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        analysis </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'gateway_event_id'</span><span style=\"color:#E1E4E8\">: gateway_event_id,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'processing_status'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'unknown'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'processing_attempts'</span><span style=\"color:#E1E4E8\">: [],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'business_impact'</span><span style=\"color:#E1E4E8\">: {},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'recommendations'</span><span style=\"color:#E1E4E8\">: []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.db.transaction() </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> session:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Find webhook event records</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            webhook_events </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> session.query(WebhookEvent).filter_by(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                gateway_event_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">gateway_event_id</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ).order_by(WebhookEvent.created_at).all()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> webhook_events:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                analysis[</span><span style=\"color:#9ECBFF\">'processing_status'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'not_received'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                analysis[</span><span style=\"color:#9ECBFF\">'recommendations'</span><span style=\"color:#E1E4E8\">].append(</span><span style=\"color:#9ECBFF\">'Verify webhook URL configuration in payment gateway'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> analysis</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Analyze processing attempts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> event </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> webhook_events:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                attempt_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'event_id'</span><span style=\"color:#E1E4E8\">: event.event_id,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'received_at'</span><span style=\"color:#E1E4E8\">: event.created_at.isoformat(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'processed_at'</span><span style=\"color:#E1E4E8\">: event.processed_at.isoformat() </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> event.processed_at </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'idempotency_key'</span><span style=\"color:#E1E4E8\">: event.idempotency_key,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'event_type'</span><span style=\"color:#E1E4E8\">: event.event_type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                analysis[</span><span style=\"color:#9ECBFF\">'processing_attempts'</span><span style=\"color:#E1E4E8\">].append(attempt_info)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Check for successful processing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            processed_events </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [e </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> e </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> webhook_events </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> e.processed_at </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> processed_events:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                analysis[</span><span style=\"color:#9ECBFF\">'processing_status'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'processed'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                analysis[</span><span style=\"color:#9ECBFF\">'business_impact'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._analyze_business_impact(processed_events[</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], session)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                analysis[</span><span style=\"color:#9ECBFF\">'processing_status'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'failed'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                analysis[</span><span style=\"color:#9ECBFF\">'recommendations'</span><span style=\"color:#E1E4E8\">].extend([</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'Check application logs for processing errors'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'Verify webhook payload structure matches expected format'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'Confirm database connectivity during processing window'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                ])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> analysis</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton - Billing Issue Diagnostic Tool:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BillingIssueDiagnostic</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Command-line tool for diagnosing billing system issues.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Provides structured investigation workflow for common problems.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, database_manager: </span><span style=\"color:#9ECBFF\">'DatabaseManager'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.db </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> database_manager</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.validator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BillingCalculationValidator()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.consistency_checker </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> StateConsistencyChecker(database_manager)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.webhook_debugger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> WebhookDebugger(database_manager)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> diagnose_invoice_discrepancy</span><span style=\"color:#E1E4E8\">(self, invoice_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Comprehensive invoice discrepancy diagnosis.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Validates all calculations and identifies source of errors.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load invoice and related entities (subscription, customer, line items)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Recalculate invoice total from line items and compare</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate each line item calculation (subscription, usage, proration, credits)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check for currency precision issues in calculations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Verify credit application logic and amounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Generate detailed discrepancy report with recommendations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> diagnose_subscription_state_issue</span><span style=\"color:#E1E4E8\">(self, subscription_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Subscription state diagnostic workflow.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Identifies invalid states and recommends correction steps.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load subscription and validate current state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Trace subscription event history for state transitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate state machine compliance for each transition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check for concurrent modification conflicts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Verify payment method and invoice alignment with state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Generate state correction recommendations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> diagnose_payment_processing_issue</span><span style=\"color:#E1E4E8\">(self, payment_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Payment processing diagnostic workflow.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Traces payment through gateway integration and webhook processing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load payment record and related invoice/subscription</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check payment gateway for corresponding transaction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Analyze webhook processing for payment events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate payment state consistency with gateway</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Check for duplicate payment processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Generate synchronization and recovery recommendations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Command-line interface for billing system debugging.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> argparse</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> argparse.ArgumentParser(</span><span style=\"color:#FFAB70\">description</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Billing System Diagnostic Tool'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser.add_argument(</span><span style=\"color:#9ECBFF\">'issue_type'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">choices</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#9ECBFF\">'invoice'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'subscription'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'payment'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'webhook'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser.add_argument(</span><span style=\"color:#9ECBFF\">'entity_id'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'ID of entity to investigate'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser.add_argument(</span><span style=\"color:#9ECBFF\">'--verbose'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">action</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'store_true'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Enable detailed logging'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    args </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parser.parse_args()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> args.verbose:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logging.basicConfig(</span><span style=\"color:#FFAB70\">level</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">logging.</span><span style=\"color:#79B8FF\">DEBUG</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db_manager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DatabaseManager()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    diagnostic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BillingIssueDiagnostic(db_manager)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> args.issue_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'invoice'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> diagnostic.diagnose_invoice_discrepancy(args.entity_id)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#E1E4E8\"> args.issue_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'subscription'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> diagnostic.diagnose_subscription_state_issue(args.entity_id)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#E1E4E8\"> args.issue_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'payment'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> diagnostic.diagnose_payment_processing_issue(args.entity_id)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#E1E4E8\"> args.issue_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'webhook'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> diagnostic.webhook_debugger.analyze_webhook_processing(args.entity_id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(json.dumps(result, </span><span style=\"color:#FFAB70\">indent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> __name__</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#9ECBFF\"> '__main__'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    main()</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint - Debugging Tool Validation:</strong></p>\n<p>After implementing the debugging tools, validate their effectiveness with these checkpoints:</p>\n<ol>\n<li><p><strong>Currency Precision Validation</strong>: Run <code>python -m billing.debug.calculation_validator</code> with test invoices containing known precision issues. The validator should identify floating-point drift and rounding inconsistencies.</p>\n</li>\n<li><p><strong>State Consistency Checks</strong>: Execute <code>python tools/debug_billing_issue.py subscription &lt;subscription_id&gt;</code> for subscriptions in various states. The tool should identify state machine violations and business rule inconsistencies.</p>\n</li>\n<li><p><strong>Webhook Processing Analysis</strong>: Use <code>python tools/debug_billing_issue.py webhook &lt;gateway_event_id&gt;</code> to trace webhook events from payment gateway through system processing. The analysis should show processing status and business impact.</p>\n</li>\n<li><p><strong>Proration Symmetry Tests</strong>: Execute proration validation tests that perform upgrade followed by immediate downgrade. The net charge should be zero within rounding tolerance.</p>\n</li>\n</ol>\n<p><strong>Common Debugging Pitfalls:</strong></p>\n<p>⚠️ <strong>Pitfall: Debugging Symptoms Instead of Root Causes</strong>\nMany developers focus on fixing the immediate symptom (wrong invoice amount) without identifying the underlying issue (currency precision loss in calculations). Always trace the problem back to its source through the audit trail and recalculate values from scratch.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Timezone Issues in Date Calculations</strong>\nBilling calculations often involve date arithmetic that can be affected by timezone conversions and daylight saving time changes. Always store timestamps in UTC and convert to local time only for display purposes.</p>\n<p>⚠️ <strong>Pitfall: Assuming Webhook Processing is Synchronous</strong>\nWebhook processing is inherently asynchronous, and debugging must account for processing delays, retries, and out-of-order delivery. Check webhook processing timestamps and correlate with business entity state changes.</p>\n<h2 id=\"future-extensions-and-scalability\">Future Extensions and Scalability</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - outlines scalability considerations and future enhancements that build upon the foundation established in plan management (Milestone 1), subscription lifecycle (Milestone 2), proration (Milestone 3), and usage-based billing (Milestone 4)</p>\n</blockquote>\n<h3 id=\"mental-model-evolution-of-a-growing-business\">Mental Model: Evolution of a Growing Business</h3>\n<p>Think of the subscription billing system as a growing city&#39;s infrastructure. Initially, you build a water system that serves a few thousand residents with simple pipes and a single treatment plant. As the city grows, you need to add multiple treatment facilities (multi-tenant architecture), accommodate different types of buildings with varying water needs (advanced pricing models), and build comprehensive monitoring systems to track usage patterns and optimize distribution (analytics and revenue reporting).</p>\n<p>The key architectural principle is that your foundational infrastructure must be designed to support this growth without requiring complete reconstruction. Just as a well-planned city leaves room for expansion and upgrades existing utilities rather than replacing them entirely, your billing system&#39;s core components must be extensible and composable to support future business requirements.</p>\n<h3 id=\"advanced-pricing-models\">Advanced Pricing Models</h3>\n<p>The current system supports flat-rate, tiered, and volume-based pricing through the <code>PricingModel</code> enum and <code>PricingTier</code> structures. However, modern B2B SaaS businesses often require more sophisticated pricing models that adapt to complex customer requirements and business relationships.</p>\n<p><strong>Seat-Based Billing Implementation</strong></p>\n<p>Seat-based billing represents a significant extension where charges scale based on the number of active users or licenses within a customer&#39;s organization. This model requires tracking user activation and deactivation events throughout the billing cycle, calculating mid-cycle adjustments when users are added or removed, and handling the complexity of different user types with varying pricing.</p>\n<p>The extension begins with enhancing the <code>Plan</code> entity to support seat-based pricing configurations. This involves adding fields for base seat count, additional seat pricing, and seat type definitions. The system must track seat usage through dedicated usage events that capture user activation, deactivation, and role changes with precise timestamps.</p>\n<table>\n<thead>\n<tr>\n<th>Component Enhancement</th>\n<th>Current State</th>\n<th>Seat-Based Extension</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Plan Definition</td>\n<td>Fixed pricing tiers</td>\n<td>Dynamic seat multipliers with base counts</td>\n</tr>\n<tr>\n<td>Usage Tracking</td>\n<td>Generic <code>UsageEvent</code></td>\n<td>Specialized seat activation/deactivation events</td>\n</tr>\n<tr>\n<td>Proration Logic</td>\n<td>Time-based only</td>\n<td>Combination of time and quantity-based proration</td>\n</tr>\n<tr>\n<td>Invoice Generation</td>\n<td>Static line items</td>\n<td>Dynamic seat count calculations per billing period</td>\n</tr>\n</tbody></table>\n<p>The proration calculations become significantly more complex as they must handle both time-based and quantity-based changes. When a customer adds five users mid-cycle, the system calculates the prorated charge based on the remaining days in the billing period multiplied by the per-seat rate for those five additional users.</p>\n<p><strong>Custom Contract Support Architecture</strong></p>\n<p>Enterprise customers often negotiate custom pricing terms that don&#39;t fit standard plan structures. Supporting custom contracts requires a flexible pricing engine that can handle negotiated rates, volume commitments, and custom billing schedules while maintaining the integrity of the standard billing workflows.</p>\n<blockquote>\n<p><strong>Decision: Contract-Based Pricing Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Enterprise customers require custom pricing terms, volume commitments, and specialized billing arrangements that exceed standard plan capabilities</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Extend existing plan system with custom fields</li>\n<li>Create parallel contract management system</li>\n<li>Build flexible pricing rule engine</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement a flexible pricing rule engine with contract overrides</li>\n<li><strong>Rationale</strong>: Rule engine provides maximum flexibility while maintaining consistency with existing billing workflows, allows gradual migration of complex pricing logic</li>\n<li><strong>Consequences</strong>: Increased system complexity but enables unlimited pricing model combinations, requires careful testing of rule interactions</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Contract Feature</th>\n<th>Implementation Approach</th>\n<th>Integration Point</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Volume Commitments</td>\n<td>Minimum usage guarantees with true-up invoicing</td>\n<td>Usage aggregation engine</td>\n</tr>\n<tr>\n<td>Negotiated Rates</td>\n<td>Custom pricing tiers per contract</td>\n<td>Proration calculator</td>\n</tr>\n<tr>\n<td>Custom Billing Cycles</td>\n<td>Flexible billing anchor dates</td>\n<td>Renewal processing engine</td>\n</tr>\n<tr>\n<td>Revenue Recognition</td>\n<td>Deferred revenue allocation</td>\n<td>Invoice generation</td>\n</tr>\n</tbody></table>\n<p>The contract management system introduces a <code>Contract</code> entity that references the base <code>Plan</code> but overrides specific pricing components. The billing engine checks for contract overrides at each calculation point, applying custom rates while maintaining the standard billing workflow structure.</p>\n<p><strong>Dynamic Pricing and Market-Based Adjustments</strong></p>\n<p>Advanced pricing models increasingly incorporate dynamic elements that respond to market conditions, usage patterns, or customer behavior. This might include seasonal pricing adjustments, loyalty discounts based on tenure, or usage-based discounts that reward high-volume customers.</p>\n<p>The implementation requires extending the pricing calculation engine to support conditional logic and temporal pricing rules. The system must evaluate pricing conditions at billing time, apply appropriate adjustments, and maintain an audit trail of pricing decisions for compliance and customer transparency.</p>\n<table>\n<thead>\n<tr>\n<th>Dynamic Pricing Type</th>\n<th>Trigger Condition</th>\n<th>Calculation Method</th>\n<th>Persistence Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Seasonal Adjustments</td>\n<td>Date-based rules</td>\n<td>Percentage modifier on base price</td>\n<td>Versioned pricing rules</td>\n</tr>\n<tr>\n<td>Loyalty Discounts</td>\n<td>Customer tenure calculation</td>\n<td>Tiered discount percentage</td>\n<td>Customer pricing history</td>\n</tr>\n<tr>\n<td>Volume Incentives</td>\n<td>Usage threshold analysis</td>\n<td>Progressive discount rates</td>\n<td>Usage milestone tracking</td>\n</tr>\n<tr>\n<td>Market Adjustments</td>\n<td>External data feeds</td>\n<td>Algorithm-based price optimization</td>\n<td>Real-time pricing cache</td>\n</tr>\n</tbody></table>\n<h3 id=\"multi-tenant-architecture\">Multi-Tenant Architecture</h3>\n<p>As the subscription billing system scales to serve multiple organizations or business units, the architecture must support tenant isolation, data segregation, and resource allocation while maintaining operational efficiency and cost-effectiveness.</p>\n<p><strong>Tenant Isolation Strategies</strong></p>\n<p>The current single-tenant design stores all customer data in shared tables with global unique identifiers. Multi-tenant architecture requires careful consideration of data isolation levels, from shared databases with tenant identifiers to completely separate infrastructure per tenant.</p>\n<blockquote>\n<p><strong>Decision: Schema-Per-Tenant with Shared Infrastructure</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to support multiple tenant organizations with strict data isolation requirements while maintaining operational efficiency</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Shared tables with tenant ID columns</li>\n<li>Separate database schema per tenant</li>\n<li>Completely isolated infrastructure per tenant</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Separate database schema per tenant with shared application infrastructure</li>\n<li><strong>Rationale</strong>: Provides strong data isolation without infrastructure multiplication costs, enables tenant-specific customizations while sharing application logic</li>\n<li><strong>Consequences</strong>: Database connection pooling complexity increases, tenant provisioning requires schema creation, backup and migration strategies become more complex</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Isolation Level</th>\n<th>Data Security</th>\n<th>Operational Complexity</th>\n<th>Cost Efficiency</th>\n<th>Customization Flexibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Shared Tables</td>\n<td>Medium - relies on application logic</td>\n<td>Low</td>\n<td>High</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Schema Per Tenant</td>\n<td>High - database-level isolation</td>\n<td>Medium</td>\n<td>Medium</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Infrastructure Per Tenant</td>\n<td>Highest - complete isolation</td>\n<td>High</td>\n<td>Low</td>\n<td>High</td>\n</tr>\n</tbody></table>\n<p>The schema-per-tenant approach requires enhancing the <code>DatabaseManager</code> to support dynamic schema selection based on request context. Each database operation must include tenant context, ensuring queries execute against the correct schema. The system maintains a tenant registry that maps tenant identifiers to their corresponding database schemas.</p>\n<p><strong>Tenant Provisioning Workflow</strong></p>\n<p>Creating new tenants involves provisioning database schemas, initializing default configurations, and setting up billing parameters specific to the tenant&#39;s requirements. This process must be automated and reliable to support rapid tenant onboarding.</p>\n<p>The tenant provisioning workflow includes several critical steps:</p>\n<ol>\n<li><strong>Schema Creation</strong>: Generate a new database schema with all required tables, indexes, and constraints based on the standard billing system structure</li>\n<li><strong>Configuration Initialization</strong>: Create default billing settings, supported currencies, and system parameters appropriate for the tenant&#39;s geographic location and business model</li>\n<li><strong>Administrative User Setup</strong>: Provision initial administrative users with appropriate permissions for tenant management</li>\n<li><strong>Integration Configuration</strong>: Set up connections to the tenant&#39;s payment gateways, accounting systems, and other external services</li>\n<li><strong>Data Migration</strong>: If applicable, import existing customer and subscription data from legacy systems with proper validation and reconciliation</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Provisioning Step</th>\n<th>Duration Estimate</th>\n<th>Failure Recovery</th>\n<th>Validation Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Schema Creation</td>\n<td>30 seconds</td>\n<td>Drop and recreate</td>\n<td>Table count and constraint verification</td>\n</tr>\n<tr>\n<td>Configuration Setup</td>\n<td>15 seconds</td>\n<td>Configuration rollback</td>\n<td>Currency and timezone validation</td>\n</tr>\n<tr>\n<td>User Provisioning</td>\n<td>10 seconds</td>\n<td>User deletion</td>\n<td>Authentication system integration</td>\n</tr>\n<tr>\n<td>Integration Testing</td>\n<td>2 minutes</td>\n<td>Configuration reset</td>\n<td>Payment gateway connectivity</td>\n</tr>\n<tr>\n<td>Data Migration</td>\n<td>Variable</td>\n<td>Partial rollback options</td>\n<td>Data integrity checksums</td>\n</tr>\n</tbody></table>\n<p><strong>Cross-Tenant Resource Management</strong></p>\n<p>Multi-tenant architecture introduces challenges in resource allocation, performance isolation, and cost attribution. The system must prevent one tenant&#39;s heavy usage from impacting others while providing fair resource distribution and accurate cost allocation.</p>\n<p>The resource management system implements tenant-aware quotas and rate limiting at multiple levels. Database connection pools maintain per-tenant limits to prevent connection exhaustion. API rate limiting applies tenant-specific thresholds based on their subscription tier or negotiated limits. Background processing queues use tenant-aware scheduling to ensure fair processing distribution.</p>\n<p><strong>Tenant-Specific Customizations</strong></p>\n<p>Different tenant organizations often require customizations in billing logic, invoice formatting, payment processing workflows, or integration requirements. The multi-tenant architecture must support these customizations without creating maintenance complexity or security vulnerabilities.</p>\n<p>The customization framework uses a plugin architecture where tenant-specific logic extends standard billing workflows. Custom pricing calculators, invoice formatters, and payment processors implement standard interfaces while providing tenant-specific behavior. The system loads appropriate customizations based on tenant context during request processing.</p>\n<table>\n<thead>\n<tr>\n<th>Customization Type</th>\n<th>Implementation Pattern</th>\n<th>Isolation Method</th>\n<th>Version Management</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pricing Logic</td>\n<td>Strategy pattern with tenant plugins</td>\n<td>Interface-based isolation</td>\n<td>Plugin versioning with compatibility checks</td>\n</tr>\n<tr>\n<td>Invoice Templates</td>\n<td>Template engine with tenant themes</td>\n<td>Resource namespace separation</td>\n<td>Template version control</td>\n</tr>\n<tr>\n<td>Payment Workflows</td>\n<td>Workflow step overrides</td>\n<td>Tenant-specific workflow definitions</td>\n<td>Workflow schema validation</td>\n</tr>\n<tr>\n<td>Integration Endpoints</td>\n<td>Tenant-specific adapters</td>\n<td>Configuration-driven routing</td>\n<td>Adapter version compatibility</td>\n</tr>\n</tbody></table>\n<h3 id=\"analytics-and-revenue-reporting\">Analytics and Revenue Reporting</h3>\n<p>The billing system generates vast amounts of financial and operational data that provides valuable insights into business performance, customer behavior, and revenue trends. Building comprehensive analytics capabilities transforms raw billing data into actionable business intelligence.</p>\n<p><strong>Revenue Recognition and Financial Reporting</strong></p>\n<p>Modern subscription businesses must comply with accounting standards like ASC 606 that require careful revenue recognition practices. The system must track deferred revenue for prepaid subscriptions, recognize revenue over service delivery periods, and handle complex scenarios like plan changes and cancellations.</p>\n<p>Revenue recognition begins with the invoice generation process but extends far beyond simple cash collection. When a customer pays for an annual subscription, the system must defer the revenue recognition and allocate it monthly over the service delivery period. Plan upgrades and downgrades require pro-rata revenue adjustments that comply with accounting standards.</p>\n<table>\n<thead>\n<tr>\n<th>Revenue Recognition Scenario</th>\n<th>Accounting Treatment</th>\n<th>System Implementation</th>\n<th>Compliance Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Annual Prepayment</td>\n<td>Deferred revenue with monthly recognition</td>\n<td>Scheduled revenue allocation jobs</td>\n<td>ASC 606 performance obligation tracking</td>\n</tr>\n<tr>\n<td>Mid-Cycle Upgrades</td>\n<td>Immediate recognition of incremental value</td>\n<td>Prorated revenue adjustment calculations</td>\n<td>Revenue allocation between performance periods</td>\n</tr>\n<tr>\n<td>Service Cancellations</td>\n<td>Immediate recognition of earned revenue</td>\n<td>Revenue recognition acceleration</td>\n<td>Refund liability accounting</td>\n</tr>\n<tr>\n<td>Usage-Based Charges</td>\n<td>Recognition upon service delivery</td>\n<td>Real-time revenue recognition for metered usage</td>\n<td>Variable consideration estimation</td>\n</tr>\n</tbody></table>\n<p>The revenue recognition engine maintains detailed records of performance obligations, contract modifications, and revenue allocation schedules. Monthly revenue recognition jobs process deferred revenue balances and generate accounting entries that integrate with external financial systems.</p>\n<p><strong>Customer Lifecycle Analytics</strong></p>\n<p>Understanding customer behavior patterns, churn predictors, and growth opportunities requires comprehensive analysis of subscription lifecycle data. The analytics system must track customer journey metrics, cohort analysis, and predictive indicators that inform business strategy.</p>\n<p>Customer lifecycle analytics begin with subscription creation and continue through the entire customer relationship. The system tracks key metrics including customer acquisition cost, lifetime value, monthly recurring revenue, churn rates, and expansion revenue from upgrades and additional usage.</p>\n<blockquote>\n<p><strong>Decision: Real-Time Analytics with Batch Aggregation</strong></p>\n<ul>\n<li><strong>Context</strong>: Business users need both real-time dashboard updates and complex historical analysis requiring different performance and consistency characteristics</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Pure real-time analytics with stream processing</li>\n<li>Batch-only analytics with daily updates</li>\n<li>Hybrid real-time dashboards with batch analytical processing</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement hybrid architecture with real-time metrics and batch analytical processing</li>\n<li><strong>Rationale</strong>: Real-time dashboards provide operational visibility while batch processing enables complex analytical queries without impacting billing system performance</li>\n<li><strong>Consequences</strong>: Increased system complexity but optimal performance characteristics for different use cases, requires data consistency management between real-time and batch systems</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Analytics Category</th>\n<th>Update Frequency</th>\n<th>Data Source</th>\n<th>Storage System</th>\n<th>Query Patterns</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Operational Metrics</td>\n<td>Real-time</td>\n<td>Transaction logs</td>\n<td>Time-series database</td>\n<td>Simple aggregations</td>\n</tr>\n<tr>\n<td>Cohort Analysis</td>\n<td>Daily batch</td>\n<td>Customer database</td>\n<td>Analytical warehouse</td>\n<td>Complex joins and pivots</td>\n</tr>\n<tr>\n<td>Revenue Forecasting</td>\n<td>Weekly batch</td>\n<td>Subscription and usage data</td>\n<td>Analytical warehouse</td>\n<td>Statistical modeling</td>\n</tr>\n<tr>\n<td>Churn Prediction</td>\n<td>Daily batch</td>\n<td>Customer behavior data</td>\n<td>Machine learning platform</td>\n<td>Predictive modeling</td>\n</tr>\n</tbody></table>\n<p><strong>Usage Pattern Analysis and Optimization</strong></p>\n<p>Usage-based billing generates detailed consumption data that reveals customer behavior patterns, feature adoption rates, and optimization opportunities. The analytics system must process high-volume usage events and extract meaningful insights about customer engagement and system utilization.</p>\n<p>Usage pattern analysis identifies customers approaching plan limits, features with low adoption rates, and optimization opportunities for both customers and the service provider. The system tracks usage trends over time, compares actual usage against purchased allowances, and identifies customers who might benefit from plan changes.</p>\n<p>The usage analytics pipeline processes raw usage events through multiple aggregation stages. Real-time aggregation provides current usage dashboards and quota enforcement. Daily batch processing generates comprehensive usage reports and trend analysis. Weekly analytical jobs perform cohort analysis and usage pattern recognition.</p>\n<p><strong>Business Intelligence and Reporting Framework</strong></p>\n<p>The comprehensive reporting framework must serve diverse stakeholder needs, from executive revenue dashboards to detailed customer success team reports. The system must balance query performance, data freshness, and analytical flexibility while maintaining data accuracy and security.</p>\n<p>The reporting framework uses a layered architecture with operational data stores, analytical warehouses, and specialized reporting databases. Data flows from the transactional billing system through ETL pipelines that clean, transform, and aggregate information for analytical consumption.</p>\n<table>\n<thead>\n<tr>\n<th>Report Category</th>\n<th>Target Audience</th>\n<th>Update Frequency</th>\n<th>Data Requirements</th>\n<th>Performance Characteristics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Executive Dashboards</td>\n<td>Leadership team</td>\n<td>Real-time</td>\n<td>High-level KPIs and trends</td>\n<td>Fast loading, simple visualizations</td>\n</tr>\n<tr>\n<td>Financial Reports</td>\n<td>Finance team</td>\n<td>Daily</td>\n<td>Detailed revenue and cost data</td>\n<td>Complex calculations, audit trails</td>\n</tr>\n<tr>\n<td>Customer Success</td>\n<td>Account managers</td>\n<td>Real-time</td>\n<td>Individual customer metrics</td>\n<td>Drill-down capabilities, alert integration</td>\n</tr>\n<tr>\n<td>Product Analytics</td>\n<td>Product team</td>\n<td>Weekly</td>\n<td>Feature usage and adoption</td>\n<td>Statistical analysis, cohort comparisons</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Multi-Tenant Database</td>\n<td>PostgreSQL with schemas</td>\n<td>Amazon RDS with cross-region replication</td>\n</tr>\n<tr>\n<td>Analytics Engine</td>\n<td>PostgreSQL analytical queries</td>\n<td>Apache Spark with Delta Lake</td>\n</tr>\n<tr>\n<td>Real-Time Metrics</td>\n<td>Redis with time-series data</td>\n<td>InfluxDB with Grafana dashboards</td>\n</tr>\n<tr>\n<td>Data Pipeline</td>\n<td>Python ETL scripts</td>\n<td>Apache Airflow with dbt transformations</td>\n</tr>\n<tr>\n<td>Reporting Layer</td>\n<td>Django admin with custom views</td>\n<td>Tableau or Looker integration</td>\n</tr>\n<tr>\n<td>Contract Management</td>\n<td>JSON configuration in database</td>\n<td>Dedicated contract service with approval workflows</td>\n</tr>\n</tbody></table>\n<p><strong>File Structure for Extensions</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>subscription-system/\n├── core/\n│   ├── billing/                    # Existing billing components\n│   ├── usage/                      # Existing usage tracking\n│   └── invoicing/                  # Existing invoice generation\n├── extensions/\n│   ├── advanced_pricing/\n│   │   ├── seat_based_billing.py   # Seat-based pricing engine\n│   │   ├── contract_manager.py     # Custom contract support\n│   │   └── dynamic_pricing.py      # Market-based pricing\n│   ├── multi_tenant/\n│   │   ├── tenant_manager.py       # Tenant provisioning and management\n│   │   ├── schema_manager.py       # Database schema management\n│   │   └── resource_manager.py     # Cross-tenant resource allocation\n│   └── analytics/\n│       ├── revenue_recognition.py  # ASC 606 compliant revenue tracking\n│       ├── customer_analytics.py   # Lifecycle and churn analysis\n│       └── usage_analytics.py      # Usage pattern analysis\n├── reporting/\n│   ├── dashboards/                 # Real-time dashboard components\n│   ├── etl/                        # Data pipeline jobs\n│   └── exports/                    # Report generation and export\n└── migrations/\n    ├── multi_tenant_setup/         # Schema setup for multi-tenancy\n    └── analytics_tables/           # Analytical warehouse setup</code></pre></div>\n\n<p><strong>Advanced Pricing Infrastructure</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Advanced pricing engine supporting seat-based billing and custom contracts.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Extends the existing PricingModel enum and PricingTier structure.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Decimal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, date</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AdvancedPricingModel</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SEAT_BASED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"seat_based\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CONTRACT_CUSTOM</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"contract_custom\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DYNAMIC_PRICING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"dynamic_pricing\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    VOLUME_COMMITMENT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"volume_commitment\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SeatConfiguration</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Configuration for seat-based billing plans\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    base_seat_count: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    base_price_cents: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    additional_seat_price_cents: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    seat_types: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># seat_type -> price_per_seat_cents</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proration_behavior: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # \"immediate\", \"next_cycle\", \"anniversary\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    minimum_seats: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maximum_seats: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ContractTerms</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Custom contract pricing terms that override standard plans\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    contract_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    customer_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    base_plan_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    effective_date: date</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expiration_date: Optional[date]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    custom_pricing_rules: List[Dict]  </span><span style=\"color:#6A737D\"># Flexible rule definitions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    volume_commitments: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Decimal]  </span><span style=\"color:#6A737D\"># usage_type -> minimum_quantity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    billing_schedule: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # \"monthly\", \"quarterly\", \"annual\", \"custom\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    revenue_recognition_method: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AdvancedPricingEngine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Extends the existing pricing engine to support advanced pricing models.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Integrates with existing Plan and PricingTier structures.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, base_pricing_engine, contract_manager, seat_tracker):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize with existing pricing engine for fallback</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Store references to contract manager and seat tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> calculate_subscription_charge</span><span style=\"color:#E1E4E8\">(self, subscription_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                    billing_period_start: datetime,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                    billing_period_end: datetime) -> Money:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Calculate total subscription charge including advanced pricing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Load subscription and determine pricing model type</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Check for custom contract overrides</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Apply appropriate pricing calculation method</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Handle seat-based calculations if applicable</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Apply any dynamic pricing adjustments</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        6. Return final calculated amount</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement seat-based calculation logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check for contract overrides</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Apply dynamic pricing rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Integrate with existing proration logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> calculate_seat_based_charge</span><span style=\"color:#E1E4E8\">(self, subscription, seat_config: SeatConfiguration,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  current_seats: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, billing_days: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Money:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Calculate charges for seat-based billing model.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Calculate base seat charge (included seats)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Calculate additional seat charges</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Apply seat type specific pricing</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Handle mid-cycle seat changes with proration</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Apply minimum/maximum seat constraints</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement seat-based pricing calculation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle different seat types with different rates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate proration for mid-cycle seat changes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> apply_contract_pricing</span><span style=\"color:#E1E4E8\">(self, base_amount: Money, contract: ContractTerms) -> Money:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Apply custom contract pricing rules to override standard pricing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Evaluate contract rule conditions</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Apply percentage discounts or fixed amounts</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Handle volume commitment calculations</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Validate pricing against contract terms</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Generate audit trail for contract pricing</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement contract rule evaluation engine</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle volume commitment true-up calculations  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Apply custom billing schedule adjustments</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Multi-Tenant Infrastructure</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Multi-tenant architecture supporting schema-per-tenant isolation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">with shared application infrastructure.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> contextlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TenantConfiguration</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Configuration settings specific to a tenant\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tenant_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    schema_name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    database_url: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    supported_currencies: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    default_currency: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timezone: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    billing_settings: Dict</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payment_gateway_config: Dict</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    feature_flags: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TenantContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Thread-local tenant context for request processing\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _local </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> threading.local()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> set_current_tenant</span><span style=\"color:#E1E4E8\">(cls, tenant_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Set thread-local tenant context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Load tenant configuration from cache</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate tenant is active and accessible</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_current_tenant</span><span style=\"color:#E1E4E8\">(cls) -> Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return current thread-local tenant ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Raise exception if no tenant context set</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_tenant_config</span><span style=\"color:#E1E4E8\">(cls) -> TenantConfiguration:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return configuration for current tenant</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Cache configuration for performance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TenantDatabaseManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Manages database connections and schema routing for multi-tenant architecture.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Extends the existing DatabaseManager with tenant-aware operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, base_database_manager):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Store reference to base database manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize tenant schema registry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Setup connection pooling per tenant</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> tenant_transaction</span><span style=\"color:#E1E4E8\">(self, isolation_level</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create database transaction for current tenant schema.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Get current tenant context</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Select appropriate database connection</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Set schema search path for tenant</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Begin transaction with specified isolation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Yield session to caller</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        6. Commit or rollback based on exceptions</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        7. Reset connection state</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement tenant-aware transaction management</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle schema switching and connection pooling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure proper cleanup on success or failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> provision_tenant_schema</span><span style=\"color:#E1E4E8\">(self, tenant_config: TenantConfiguration) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create database schema and initial setup for new tenant.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Create database schema with tenant name</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Run all migration scripts in new schema</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Insert default configuration data</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Create initial admin user</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Validate schema creation success</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        6. Register tenant in tenant registry</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement schema creation and migration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle rollback on provision failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate schema integrity after creation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> deprovision_tenant_schema</span><span style=\"color:#E1E4E8\">(self, tenant_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Safely remove tenant schema and all associated data.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Validate tenant can be safely removed</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Export tenant data for backup if required</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Drop tenant schema and all objects</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Remove tenant from registry</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Clean up connection pool resources</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement safe tenant removal with backup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate no active connections to tenant schema</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle cleanup of related resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TenantResourceManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Manages resource allocation and limits across tenants.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize resource tracking and limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Setup tenant quota configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> check_tenant_quota</span><span style=\"color:#E1E4E8\">(self, tenant_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, resource_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          requested_amount: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Check if tenant can consume additional resources.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Load tenant resource quotas and current usage</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Check if requested amount exceeds remaining quota</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Apply any burst allowances or temporary increases</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Log quota check for monitoring and billing</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Return availability decision</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement quota checking with burst handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Track resource usage per tenant</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle quota enforcement and alerting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Analytics and Reporting Infrastructure</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Analytics and revenue reporting system with real-time metrics</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">and batch analytical processing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, date, timedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> decimal </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Decimal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RevenueRecognitionSchedule</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Schedule for recognizing deferred revenue over time\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subscription_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    invoice_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    total_amount_cents: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recognition_start_date: date</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recognition_end_date: date</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    monthly_recognition_cents: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recognized_to_date_cents: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    remaining_deferred_cents: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RevenueRecognitionEngine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    ASC 606 compliant revenue recognition for subscription billing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Handles deferred revenue allocation and recognition scheduling.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, billing_engine, accounting_integration):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize with billing engine and accounting system</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Load revenue recognition policies and schedules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_recognition_schedule</span><span style=\"color:#E1E4E8\">(self, invoice: Invoice) -> List[RevenueRecognitionSchedule]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create revenue recognition schedule for invoice line items.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Analyze each line item for revenue recognition requirements</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Determine performance obligation periods</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Calculate monthly recognition amounts</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Handle proration for partial periods</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Create recognition schedule entries</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        6. Integrate with accounting system journal entries</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement ASC 606 compliant revenue recognition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle different line item types (subscription, usage, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create deferred revenue liability accounts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_monthly_recognition</span><span style=\"color:#E1E4E8\">(self, recognition_date: date) -> List[Dict]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Process monthly revenue recognition for all active schedules.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Load all active recognition schedules for the month</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Calculate recognition amounts for each schedule</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Generate accounting journal entries</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Update recognition schedule progress</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Handle schedule modifications for plan changes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        6. Export entries to accounting system</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement monthly revenue recognition batch job</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle plan changes and cancellations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate accounting system integration data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CustomerAnalyticsEngine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Customer lifecycle analytics including cohort analysis and churn prediction.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, subscription_engine, usage_engine):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize with data sources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Setup analytical data pipeline connections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> calculate_customer_lifetime_metrics</span><span style=\"color:#E1E4E8\">(self, customer_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Calculate comprehensive customer lifetime value and behavior metrics.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Load customer subscription and payment history</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Calculate total revenue and average monthly revenue</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Determine customer tenure and renewal rates</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Analyze usage patterns and feature adoption</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Calculate customer acquisition cost attribution</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        6. Generate churn risk indicators</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement LTV calculation with usage correlation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate customer health scores</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate expansion opportunity indicators</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_cohort_analysis</span><span style=\"color:#E1E4E8\">(self, cohort_period: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               analysis_date: date) -> List[Dict]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generate cohort retention and revenue analysis.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Group customers by acquisition period (monthly cohorts)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Track retention rates over subsequent periods</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Calculate revenue per cohort over time</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Identify cohort behavior patterns</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Generate expansion and contraction metrics</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        6. Export analysis for business intelligence tools</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement cohort analysis with revenue tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle different cohort definitions (acquisition, upgrade, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate actionable insights and recommendations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> UsageAnalyticsEngine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Usage pattern analysis and optimization recommendations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, usage_tracker, plan_manager):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize with usage tracking and plan data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Setup usage trend analysis pipelines</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> analyze_usage_patterns</span><span style=\"color:#E1E4E8\">(self, customer_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                             analysis_period_days: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Analyze customer usage patterns and optimization opportunities.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Load usage events for analysis period</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Calculate usage trends and seasonality</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. Compare against plan allowances and limits</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. Identify optimization opportunities (plan changes)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Generate usage forecasts and recommendations</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        6. Calculate potential cost savings or revenue expansion</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement usage trend analysis with forecasting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate plan optimization recommendations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Identify customers approaching limits for upselling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoints</strong></p>\n<p><strong>Advanced Pricing Validation:</strong></p>\n<ol>\n<li><strong>Seat-Based Billing Test</strong>: Create a seat-based plan and add/remove users mid-cycle. Verify prorated charges calculate correctly: <code>python test_seat_based_billing.py</code></li>\n<li><strong>Contract Override Test</strong>: Configure a custom contract with negotiated rates. Verify billing engine applies contract pricing instead of standard plan rates</li>\n<li><strong>Dynamic Pricing Test</strong>: Setup seasonal pricing rules and verify they apply correctly during the effective periods</li>\n</ol>\n<p><strong>Multi-Tenant Validation:</strong></p>\n<ol>\n<li><strong>Schema Isolation Test</strong>: Create multiple tenants and verify data isolation. Query from one tenant should never return another tenant&#39;s data</li>\n<li><strong>Resource Quota Test</strong>: Configure tenant quotas and verify enforcement. Exceeding quotas should block additional resource consumption</li>\n<li><strong>Tenant Provisioning Test</strong>: Provision a new tenant and verify complete setup including schema creation, configuration, and user access</li>\n</ol>\n<p><strong>Analytics Validation:</strong></p>\n<ol>\n<li><strong>Revenue Recognition Test</strong>: Create subscriptions with deferred revenue and verify recognition schedule accuracy over multiple months</li>\n<li><strong>Customer Analytics Test</strong>: Generate cohort analysis reports and verify retention/revenue calculations match manual verification</li>\n<li><strong>Usage Pattern Test</strong>: Submit usage events and verify analytical aggregations match real-time tracking within acceptable variance</li>\n</ol>\n<p><strong>Common Pitfalls and Solutions</strong></p>\n<p>⚠️ <strong>Pitfall: Seat Change Proration Complexity</strong>\nSeat-based billing introduces complex proration scenarios where quantity and time-based proration interact. Adding 5 seats mid-cycle requires calculating the prorated charge for the remaining billing period, but the calculation must account for different seat types and pricing tiers.</p>\n<p>Solution: Implement seat change proration as a specialized case of the general proration engine, treating seat additions as quantity-based plan changes with time-based proration factors.</p>\n<p>⚠️ <strong>Pitfall: Multi-Tenant Data Leakage</strong>\nThe most critical risk in multi-tenant architecture is data leakage between tenants. A missing tenant context check or incorrect schema routing could expose one tenant&#39;s sensitive financial data to another tenant.</p>\n<p>Solution: Implement defense-in-depth with multiple isolation layers: middleware-level tenant validation, database-level schema enforcement, and application-level data access controls. Every database query must include tenant context validation.</p>\n<p>⚠️ <strong>Pitfall: Revenue Recognition Complexity</strong>\nASC 606 compliance requires detailed tracking of performance obligations and revenue allocation. Plan changes, cancellations, and usage-based billing create complex scenarios where revenue recognition schedules must be modified mid-stream.</p>\n<p>Solution: Treat revenue recognition as an event-driven process where subscription changes trigger recognition schedule updates. Maintain detailed audit trails for all recognition adjustments to support compliance requirements.</p>\n<p>⚠️ <strong>Pitfall: Analytics Performance Impact</strong>\nReal-time analytics queries can impact billing system performance, especially complex analytical queries that scan large datasets. Running cohort analysis during peak billing periods could slow invoice generation.</p>\n<p>Solution: Implement read replicas for analytical workloads and use batch processing for complex analysis. Provide real-time metrics through pre-computed aggregations and time-series databases optimized for analytical queries.</p>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - provides comprehensive definitions of billing terminology, technical concepts, and domain-specific vocabulary used throughout the subscription billing system implementation</p>\n</blockquote>\n<h3 id=\"mental-model-building-a-shared-language\">Mental Model: Building a Shared Language</h3>\n<p>Think of this glossary as the <strong>shared dictionary</strong> for your billing system team. Just as a successful engineering team develops common terminology for complex concepts, a billing system requires precise vocabulary to prevent costly misunderstandings. When someone says &quot;proration,&quot; everyone must understand whether they mean time-based partial charges, quantity-based adjustments, or both. When discussing &quot;dunning,&quot; the team needs to know exactly which payment recovery stage is being referenced.</p>\n<p>This shared language becomes critical during incident response. When a customer reports a billing discrepancy at 2 AM, the on-call engineer needs to quickly understand whether the issue involves &quot;usage aggregation boundaries,&quot; &quot;proration symmetry violations,&quot; or &quot;webhook idempotency failures.&quot; Clear terminology accelerates both development and operational troubleshooting.</p>\n<p>The terminology is organized into logical groupings: core billing concepts that form the foundation, technical implementation terms that describe how the system works, and operational vocabulary used during monitoring and support. Each term includes context about when and why it&#39;s used, helping engineers understand not just what terms mean but when to apply them correctly.</p>\n<h3 id=\"core-billing-and-subscription-terminology\">Core Billing and Subscription Terminology</h3>\n<p>These terms form the fundamental vocabulary of subscription billing systems. Understanding these concepts is essential for anyone working with recurring revenue models, whether in product management, engineering, or customer support roles.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context and Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>subscription billing</strong></td>\n<td>Recurring payment system with lifecycle management that automatically charges customers at regular intervals for ongoing service access</td>\n<td>The foundational concept encompassing all aspects of recurring revenue collection, from plan selection through renewal cycles</td>\n</tr>\n<tr>\n<td><strong>billing anchor</strong></td>\n<td>Fixed day for recurring subscription charges, typically set when the subscription is created and maintained throughout its lifecycle</td>\n<td>Critical for consistent customer expectations - a subscription created on January 15th should always bill on the 15th of each month</td>\n</tr>\n<tr>\n<td><strong>proration</strong></td>\n<td>Partial charge calculation for mid-cycle changes, ensuring customers pay only for the portion of service they actually receive</td>\n<td>Applied during plan upgrades, downgrades, or partial billing periods; must maintain mathematical precision to avoid customer disputes</td>\n</tr>\n<tr>\n<td><strong>grandfathering</strong></td>\n<td>Protecting existing customers from plan changes by allowing them to maintain their original pricing and terms indefinitely</td>\n<td>Essential for customer retention when updating pricing models; requires plan versioning to maintain legacy terms</td>\n</tr>\n<tr>\n<td><strong>plan versioning</strong></td>\n<td>Creating new plan versions while maintaining old ones, allowing existing subscribers to keep their original terms</td>\n<td>Enables product evolution without disrupting existing customer agreements; prevents forced migrations that could cause churn</td>\n</tr>\n<tr>\n<td><strong>feature entitlements</strong></td>\n<td>Capabilities unlocked by subscription plans, defining what functionality each tier provides to subscribers</td>\n<td>Controls access to premium features, API rate limits, storage quotas, and other plan-specific benefits</td>\n</tr>\n<tr>\n<td><strong>dunning management</strong></td>\n<td>Systematic payment failure recovery process that attempts to collect overdue payments through escalating actions</td>\n<td>Automated workflow typically including payment retries, email notifications, service restrictions, and eventual cancellation</td>\n</tr>\n<tr>\n<td><strong>grace period</strong></td>\n<td>Time window maintaining service access after payment failure, providing customers opportunity to resolve payment issues</td>\n<td>Balances business needs (revenue collection) with customer experience (avoiding service disruption during temporary payment issues)</td>\n</tr>\n<tr>\n<td><strong>usage-based billing</strong></td>\n<td>Charges based on metered consumption, where customers pay for actual usage beyond their plan&#39;s included allowances</td>\n<td>Common in SaaS for API calls, storage, bandwidth, or processing time; requires robust usage tracking and aggregation systems</td>\n</tr>\n<tr>\n<td><strong>credit balance</strong></td>\n<td>Accumulated customer credits available for future use, typically from downgrades, refunds, or promotional credits</td>\n<td>Must be applied automatically to reduce invoice amounts; requires careful tracking to prevent revenue recognition issues</td>\n</tr>\n<tr>\n<td><strong>billing period boundaries</strong></td>\n<td>Start and end dates for usage calculations and recurring charges, ensuring consistent aggregation windows</td>\n<td>Critical for usage-based billing accuracy; typically aligned with subscription anniversary dates to simplify customer understanding</td>\n</tr>\n</tbody></table>\n<h3 id=\"pricing-and-plan-management-terms\">Pricing and Plan Management Terms</h3>\n<p>These terms relate to the flexible pricing structures and plan configurations that support diverse business models. They&#39;re particularly relevant during Milestone 1 implementation and ongoing plan management operations.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context and Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>pricing tiers</strong></td>\n<td>Usage brackets with different rates, allowing volume discounts or premium pricing for high consumption</td>\n<td>Enables sophisticated pricing strategies like volume discounts; requires careful tier boundary calculations to avoid customer confusion</td>\n</tr>\n<tr>\n<td><strong>tiered pricing</strong></td>\n<td>Different rates for different usage levels within a single billing period, with each tier charged separately</td>\n<td>Each usage tier has its own rate - first 1000 API calls at $0.10 each, next 5000 at $0.08 each, etc.</td>\n</tr>\n<tr>\n<td><strong>volume pricing</strong></td>\n<td>Single rate applied to total usage once a threshold is reached, typically offering better rates for higher volumes</td>\n<td>Simpler than tiered - once you hit 1000 API calls, your entire usage is charged at the volume rate</td>\n</tr>\n<tr>\n<td><strong>seat-based billing</strong></td>\n<td>Pricing model that scales with number of active users or licenses allocated to the customer account</td>\n<td>Common in B2B SaaS; requires tracking active user counts and handling seat additions/removals with appropriate proration</td>\n</tr>\n<tr>\n<td><strong>usage allowances</strong></td>\n<td>Included quantities in subscription plans before overage charges apply</td>\n<td>Base plan might include 10,000 API calls per month; additional usage incurs overage charges at specified rates</td>\n</tr>\n<tr>\n<td><strong>overage charges</strong></td>\n<td>Fees for usage beyond plan allowances, calculated using tiered or volume pricing structures</td>\n<td>Applied monthly during invoice generation; customers should receive usage alerts before reaching overage thresholds</td>\n</tr>\n<tr>\n<td><strong>usage metrics</strong></td>\n<td>Measurable activities that can be billed, such as API calls, storage consumption, or processing time</td>\n<td>Must be clearly defined and consistently measured; forms the basis for usage-based billing calculations</td>\n</tr>\n<tr>\n<td><strong>quota enforcement</strong></td>\n<td>Limiting usage based on plan allowances to prevent unexpected charges or system abuse</td>\n<td>Can be soft limits (allow overage with charges) or hard limits (block usage at threshold)</td>\n</tr>\n<tr>\n<td><strong>contract-based pricing</strong></td>\n<td>Custom pricing terms negotiated for enterprise customers, overriding standard plan rates</td>\n<td>Requires special handling in billing logic to apply negotiated discounts or custom rate structures</td>\n</tr>\n<tr>\n<td><strong>dynamic pricing</strong></td>\n<td>Market-responsive pricing adjustments based on demand, usage patterns, or external conditions</td>\n<td>Advanced feature requiring careful implementation to maintain customer trust and billing predictability</td>\n</tr>\n</tbody></table>\n<h3 id=\"technical-implementation-vocabulary\">Technical Implementation Vocabulary</h3>\n<p>These terms describe the technical architecture and implementation patterns used to build reliable billing systems. They&#39;re essential for engineering teams working on system design, implementation, and maintenance.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context and Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>financial precision</strong></td>\n<td>Accurate monetary calculations using integer cents to avoid floating-point rounding errors</td>\n<td>Always store money amounts as integers (cents, pence, etc.) and use <code>Money</code> types for all financial operations</td>\n</tr>\n<tr>\n<td><strong>currency precision</strong></td>\n<td>Using smallest currency unit to avoid rounding errors in international billing scenarios</td>\n<td>Essential for multi-currency support; different currencies have different precision requirements (yen has no fractional units)</td>\n</tr>\n<tr>\n<td><strong>idempotency</strong></td>\n<td>Ensuring operations can be safely retried without causing duplicate charges or state changes</td>\n<td>Critical for webhook processing, payment operations, and any operation that might be retried during failures</td>\n</tr>\n<tr>\n<td><strong>state machine</strong></td>\n<td>Defined states and transitions for subscription lifecycle management with validation rules</td>\n<td>Prevents invalid state transitions and ensures consistent subscription behavior across all system components</td>\n</tr>\n<tr>\n<td><strong>audit trail</strong></td>\n<td>Complete record of financial operations and state changes for compliance and debugging</td>\n<td>Required for financial systems; every billing operation must be logged with timestamp, actor, and change details</td>\n</tr>\n<tr>\n<td><strong>optimistic concurrency control</strong></td>\n<td>Version-based conflict detection for concurrent updates to prevent data corruption</td>\n<td>Uses version numbers to detect when two operations attempt to modify the same entity simultaneously</td>\n</tr>\n<tr>\n<td><strong>workflow orchestration</strong></td>\n<td>Coordinating multi-step business processes across components with compensation and retry logic</td>\n<td>Essential for complex operations like subscription creation, plan changes, and billing cycles</td>\n</tr>\n<tr>\n<td><strong>event-driven architecture</strong></td>\n<td>System design using asynchronous event communication between loosely coupled components</td>\n<td>Enables scalability and resilience; billing events trigger downstream processing without tight coupling</td>\n</tr>\n<tr>\n<td><strong>transactional outbox</strong></td>\n<td>Pattern for reliable event publishing with database transactions to ensure consistency</td>\n<td>Guarantees that database changes and event publications succeed or fail together</td>\n</tr>\n<tr>\n<td><strong>compensation pattern</strong></td>\n<td>Rollback strategy for distributed operations when part of a multi-step process fails</td>\n<td>Implements &quot;saga pattern&quot; for distributed transactions; each step must have a corresponding compensation action</td>\n</tr>\n<tr>\n<td><strong>circuit breaker</strong></td>\n<td>Failure prevention pattern for external service calls that opens when failure thresholds are exceeded</td>\n<td>Protects billing system from cascading failures when payment gateways or other external services become unavailable</td>\n</tr>\n<tr>\n<td><strong>eventual consistency</strong></td>\n<td>Data consistency model allowing temporary inconsistencies that resolve over time</td>\n<td>Acceptable for some billing scenarios where immediate consistency isn&#39;t required, such as usage reporting dashboards</td>\n</tr>\n</tbody></table>\n<h3 id=\"data-and-storage-concepts\">Data and Storage Concepts</h3>\n<p>These terms relate to data modeling, persistence, and consistency requirements specific to billing systems. They&#39;re crucial for understanding data architecture decisions and debugging data-related issues.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context and Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>usage factor</strong></td>\n<td>Fraction of billing cycle remaining, used in proration calculations for time-based adjustments</td>\n<td>Calculated as (days_remaining / total_days_in_cycle); critical for accurate proration math</td>\n</tr>\n<tr>\n<td><strong>proration symmetry</strong></td>\n<td>Mathematical property that upgrade followed by downgrade should net to zero charge</td>\n<td>Essential invariant for testing proration logic; prevents customer disputes over billing accuracy</td>\n</tr>\n<tr>\n<td><strong>billing cycle integration</strong></td>\n<td>Coordination between subscription renewals, usage aggregation, and invoice generation</td>\n<td>Ensures all charges for a billing period are captured in the correct invoice</td>\n</tr>\n<tr>\n<td><strong>real-time approximation</strong></td>\n<td>Fast estimates for dashboards and quotas without full aggregation accuracy</td>\n<td>Provides immediate feedback for usage-based services while batch processes calculate precise billing amounts</td>\n</tr>\n<tr>\n<td><strong>batch aggregation</strong></td>\n<td>Scheduled processing for complex analytical computations and precise billing calculations</td>\n<td>Runs during off-peak hours to perform expensive usage aggregation and generate accurate invoices</td>\n</tr>\n<tr>\n<td><strong>event deduplication</strong></td>\n<td>Preventing duplicate charges for same activity when usage events are reported multiple times</td>\n<td>Uses idempotency keys or event IDs to identify and skip duplicate usage reports</td>\n</tr>\n<tr>\n<td><strong>time zone consistency</strong></td>\n<td>UTC timestamp handling across different time zones to ensure consistent billing periods</td>\n<td>All internal processing uses UTC; timezone conversion only for customer-facing displays</td>\n</tr>\n<tr>\n<td><strong>calendar arithmetic</strong></td>\n<td>Date calculations handling month overflow and leap years in billing cycle calculations</td>\n<td>February billing cycles, leap years, and month-end subscriptions require special handling</td>\n</tr>\n<tr>\n<td><strong>schema-per-tenant</strong></td>\n<td>Database isolation strategy with separate schemas per tenant in multi-tenant systems</td>\n<td>Provides strong data isolation while sharing underlying database infrastructure</td>\n</tr>\n<tr>\n<td><strong>tenant isolation</strong></td>\n<td>Preventing data leakage between tenant organizations in multi-tenant billing systems</td>\n<td>Critical for SaaS platforms serving multiple organizations; includes data, processing, and access isolation</td>\n</tr>\n</tbody></table>\n<h3 id=\"payment-and-financial-processing-terms\">Payment and Financial Processing Terms</h3>\n<p>These terms cover payment processing, financial compliance, and revenue recognition aspects of billing systems. They&#39;re particularly important for payment gateway integration and financial reporting.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context and Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>payment gateway integration</strong></td>\n<td>Connecting to external payment processors like Stripe, PayPal, or Braintree for charge processing</td>\n<td>Requires webhook handling, idempotency protection, and proper error handling for payment failures</td>\n</tr>\n<tr>\n<td><strong>webhook processing</strong></td>\n<td>Handling asynchronous payment status updates from payment gateways reliably</td>\n<td>Must include signature verification, idempotency protection, and retry logic for processing failures</td>\n</tr>\n<tr>\n<td><strong>idempotency protection</strong></td>\n<td>Preventing duplicate operation processing when webhooks or API calls are retried</td>\n<td>Uses idempotency keys to identify and skip operations that have already been processed</td>\n</tr>\n<tr>\n<td><strong>payment method tokenization</strong></td>\n<td>Storing secure references to payment instruments without handling sensitive card data</td>\n<td>PCI compliance requirement; payment processors provide tokens that reference stored payment methods</td>\n</tr>\n<tr>\n<td><strong>dunning escalation</strong></td>\n<td>Progression through increasingly severe actions during payment failure recovery</td>\n<td>Typical stages: retry payment → email notification → service restriction → account suspension → cancellation</td>\n</tr>\n<tr>\n<td><strong>revenue recognition</strong></td>\n<td>ASC 606 compliant allocation of revenue over service delivery periods for financial reporting</td>\n<td>Required for public companies; subscription revenue is typically recognized ratably over the service period</td>\n</tr>\n<tr>\n<td><strong>deferred revenue</strong></td>\n<td>Liability for services not yet delivered on prepaid subscriptions</td>\n<td>Annual subscription payments create deferred revenue that&#39;s recognized monthly as service is delivered</td>\n</tr>\n<tr>\n<td><strong>churn prediction</strong></td>\n<td>Analytical model identifying customers at risk of cancellation for retention efforts</td>\n<td>Uses billing history, usage patterns, and support interactions to predict cancellation probability</td>\n</tr>\n<tr>\n<td><strong>customer lifetime value</strong></td>\n<td>Total revenue expected from customer relationship over its entire duration</td>\n<td>Key metric for subscription businesses; influences customer acquisition spending and retention investments</td>\n</tr>\n<tr>\n<td><strong>cohort analysis</strong></td>\n<td>Grouping customers by acquisition period for retention analysis and business planning</td>\n<td>Tracks how customer groups behave over time; essential for understanding business health and growth trends</td>\n</tr>\n</tbody></table>\n<h3 id=\"error-handling-and-debugging-terminology\">Error Handling and Debugging Terminology</h3>\n<p>These terms are essential for troubleshooting billing issues, handling edge cases, and maintaining system reliability in production environments.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context and Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>billing calculation debugging</strong></td>\n<td>Systematic approach to identifying and resolving mathematical errors in subscription billing</td>\n<td>Involves tracing calculation inputs, intermediate steps, and final outputs to identify discrepancies</td>\n</tr>\n<tr>\n<td><strong>state consistency</strong></td>\n<td>Alignment between subscription states and related entity states like invoices and payments</td>\n<td>Prevents scenarios where subscription shows active but last payment failed; requires cross-entity validation</td>\n</tr>\n<tr>\n<td><strong>webhook reliability</strong></td>\n<td>Ensuring payment gateway events are consistently processed despite network issues or system failures</td>\n<td>Requires idempotency, retry logic, and dead letter queues for failed webhook processing</td>\n</tr>\n<tr>\n<td><strong>mathematical invariants</strong></td>\n<td>Properties that must hold true across all test scenarios, such as proration symmetry</td>\n<td>Used in property-based testing to verify billing logic correctness across many input combinations</td>\n</tr>\n<tr>\n<td><strong>currency precision testing</strong></td>\n<td>Validation of monetary calculations using integer cents to prevent rounding errors</td>\n<td>Ensures all money operations maintain precision and avoid accumulation of rounding errors</td>\n</tr>\n<tr>\n<td><strong>billing logic unit tests</strong></td>\n<td>Mathematical validation of calculation accuracy for proration, usage charges, and pricing tiers</td>\n<td>Tests individual calculation functions with known inputs and expected outputs</td>\n</tr>\n<tr>\n<td><strong>integration testing</strong></td>\n<td>Validation of component interaction and data flow across system boundaries</td>\n<td>Ensures components work correctly together and data flows properly through complete workflows</td>\n</tr>\n<tr>\n<td><strong>property-based testing</strong></td>\n<td>Automated test generation verifying mathematical invariants across many random inputs</td>\n<td>Particularly valuable for billing systems where mathematical correctness is critical</td>\n</tr>\n<tr>\n<td><strong>milestone validation checkpoints</strong></td>\n<td>Verification criteria for development phase completion with specific acceptance tests</td>\n<td>Defines what must work correctly before proceeding to next development milestone</td>\n</tr>\n<tr>\n<td><strong>webhook processing reliability</strong></td>\n<td>Ensuring payment gateway webhooks are processed exactly once despite retries or failures</td>\n<td>Critical for payment status updates; failures can lead to service disruptions or revenue loss</td>\n</tr>\n</tbody></table>\n<h3 id=\"advanced-architecture-and-scalability-terms\">Advanced Architecture and Scalability Terms</h3>\n<p>These terms relate to sophisticated architectural patterns and scalability considerations for large-scale billing systems serving many customers and high transaction volumes.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context and Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>multi-tenant architecture</strong></td>\n<td>System design supporting multiple isolated tenant organizations with shared infrastructure</td>\n<td>Enables SaaS platforms to serve many customer organizations while maintaining data isolation and security</td>\n</tr>\n<tr>\n<td><strong>resource allocation</strong></td>\n<td>Fair distribution of system resources across tenants to prevent noisy neighbor problems</td>\n<td>Includes CPU, memory, database connections, and API rate limits; ensures tenant isolation</td>\n</tr>\n<tr>\n<td><strong>performance obligation</strong></td>\n<td>Distinct service commitment requiring revenue recognition under ASC 606 accounting standards</td>\n<td>Each separately identifiable service component may require separate revenue recognition treatment</td>\n</tr>\n<tr>\n<td><strong>usage pattern analysis</strong></td>\n<td>Examination of consumption trends for optimization opportunities and capacity planning</td>\n<td>Identifies customers approaching plan limits, unusual usage spikes, or opportunities for plan upgrades</td>\n</tr>\n<tr>\n<td><strong>real-time analytics</strong></td>\n<td>Immediate data processing for operational dashboards and customer-facing usage displays</td>\n<td>Provides current usage information while batch processes handle precise billing calculations</td>\n</tr>\n<tr>\n<td><strong>distributed transaction management</strong></td>\n<td>Coordinating consistency across multiple services and databases in billing operations</td>\n<td>Uses saga patterns and compensation logic to maintain consistency without distributed locks</td>\n</tr>\n<tr>\n<td><strong>eventual consistency patterns</strong></td>\n<td>Designing for temporary inconsistencies that resolve through background synchronization</td>\n<td>Acceptable for some billing scenarios where immediate consistency isn&#39;t required</td>\n</tr>\n<tr>\n<td><strong>horizontal scaling strategies</strong></td>\n<td>Techniques for scaling billing systems across multiple servers and database shards</td>\n<td>Includes sharding by customer ID, tenant isolation, and distributed processing patterns</td>\n</tr>\n<tr>\n<td><strong>capacity planning</strong></td>\n<td>Forecasting resource requirements based on customer growth and usage patterns</td>\n<td>Critical for handling billing cycles, usage processing spikes, and payment processing loads</td>\n</tr>\n<tr>\n<td><strong>disaster recovery</strong></td>\n<td>Business continuity planning for billing system failures and data center outages</td>\n<td>Includes backup strategies, failover procedures, and recovery time objectives for financial systems</td>\n</tr>\n</tbody></table>\n<h3 id=\"compliance-and-regulatory-terms\">Compliance and Regulatory Terms</h3>\n<p>These terms cover legal, regulatory, and compliance requirements that billing systems must address, particularly in regulated industries or international markets.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context and Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>PCI compliance</strong></td>\n<td>Payment Card Industry security standards for handling credit card information</td>\n<td>Required when processing payments; affects system architecture and data handling procedures</td>\n</tr>\n<tr>\n<td><strong>data residency</strong></td>\n<td>Legal requirements for where customer data must be stored and processed geographically</td>\n<td>Important for international billing systems serving customers in regulated jurisdictions</td>\n</tr>\n<tr>\n<td><strong>audit compliance</strong></td>\n<td>Meeting requirements for financial record keeping and audit trail maintenance</td>\n<td>Includes immutable audit logs, change tracking, and retention policies for financial transactions</td>\n</tr>\n<tr>\n<td><strong>tax calculation</strong></td>\n<td>Computing appropriate taxes based on customer location and applicable tax rates</td>\n<td>Complex in international contexts; often requires integration with tax calculation services</td>\n</tr>\n<tr>\n<td><strong>regulatory reporting</strong></td>\n<td>Meeting requirements for financial reporting to regulatory authorities</td>\n<td>Includes revenue recognition, tax reporting, and anti-money laundering compliance</td>\n</tr>\n<tr>\n<td><strong>customer data protection</strong></td>\n<td>Implementing GDPR, CCPA, and other privacy regulations in billing systems</td>\n<td>Affects data collection, storage, processing, and customer rights to access and deletion</td>\n</tr>\n<tr>\n<td><strong>financial controls</strong></td>\n<td>Internal processes ensuring accuracy and preventing fraud in billing operations</td>\n<td>Includes segregation of duties, approval workflows, and reconciliation procedures</td>\n</tr>\n<tr>\n<td><strong>retention policies</strong></td>\n<td>Legal requirements for how long financial records must be maintained</td>\n<td>Varies by jurisdiction and industry; affects database design and archival strategies</td>\n</tr>\n<tr>\n<td><strong>cross-border payments</strong></td>\n<td>Handling international transactions with currency conversion and regulatory compliance</td>\n<td>Includes foreign exchange rates, international banking regulations, and tax implications</td>\n</tr>\n<tr>\n<td><strong>subscription cancellation rights</strong></td>\n<td>Legal requirements for customer cancellation processes and refund policies</td>\n<td>Varies by jurisdiction; affects subscription lifecycle design and refund processing</td>\n</tr>\n</tbody></table>\n<h3 id=\"testing-and-quality-assurance-vocabulary\">Testing and Quality Assurance Vocabulary</h3>\n<p>These terms describe testing strategies, quality assurance practices, and validation approaches specific to billing systems where accuracy and reliability are paramount.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context and Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>end-to-end testing</strong></td>\n<td>Complete workflow validation from customer signup through payment processing and service delivery</td>\n<td>Ensures entire billing process works correctly including external integrations</td>\n</tr>\n<tr>\n<td><strong>load testing</strong></td>\n<td>Validating system performance under expected and peak transaction volumes</td>\n<td>Critical for billing cycles when many customers are processed simultaneously</td>\n</tr>\n<tr>\n<td><strong>chaos engineering</strong></td>\n<td>Deliberately introducing failures to test system resilience and recovery procedures</td>\n<td>Important for billing systems where failures can impact revenue and customer trust</td>\n</tr>\n<tr>\n<td><strong>regression testing</strong></td>\n<td>Ensuring changes don&#39;t break existing billing calculations or customer agreements</td>\n<td>Critical when updating pricing logic or adding new features to billing system</td>\n</tr>\n<tr>\n<td><strong>A/B testing</strong></td>\n<td>Comparing different pricing strategies or billing flows to optimize conversion and retention</td>\n<td>Requires careful implementation to avoid billing inconsistencies or customer confusion</td>\n</tr>\n<tr>\n<td><strong>canary deployment</strong></td>\n<td>Gradual rollout of billing system changes to detect issues before full deployment</td>\n<td>Essential for billing systems where bugs can cause widespread customer impact</td>\n</tr>\n<tr>\n<td><strong>synthetic monitoring</strong></td>\n<td>Automated testing of critical billing workflows in production to detect issues quickly</td>\n<td>Includes test transactions, payment processing, and webhook delivery validation</td>\n</tr>\n<tr>\n<td><strong>data quality monitoring</strong></td>\n<td>Continuous validation of billing data accuracy and consistency</td>\n<td>Detects issues like duplicate charges, missing usage events, or calculation errors</td>\n</tr>\n<tr>\n<td><strong>reconciliation testing</strong></td>\n<td>Comparing system calculations with external sources to ensure accuracy</td>\n<td>Includes payment gateway reconciliation, usage source validation, and tax calculation verification</td>\n</tr>\n<tr>\n<td><strong>boundary testing</strong></td>\n<td>Validating system behavior at edge cases like month boundaries, leap years, and timezone changes</td>\n<td>Critical for billing systems where edge cases can cause calculation errors or service disruptions</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This implementation section provides practical resources for maintaining consistent terminology and building shared understanding across your billing system team.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Terminology Management</td>\n<td>Shared Markdown glossary in repository</td>\n<td>Confluence or Notion with search and cross-references</td>\n</tr>\n<tr>\n<td>Code Documentation</td>\n<td>Inline comments with term definitions</td>\n<td>Generated API documentation with glossary links</td>\n</tr>\n<tr>\n<td>Team Communication</td>\n<td>Slack channel for terminology questions</td>\n<td>Dedicated wiki with examples and usage guidelines</td>\n</tr>\n<tr>\n<td>Customer Communication</td>\n<td>Simple glossary page on website</td>\n<td>Interactive help system with contextual definitions</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  docs/\n    glossary.md                    ← comprehensive term definitions\n    terminology-guide.md           ← usage guidelines for team\n    customer-glossary.md          ← customer-facing definitions\n  src/\n    shared/\n      types/\n        billing_types.py          ← standardized type definitions\n        money.py                  ← Money type with precise arithmetic\n      constants/\n        billing_constants.py      ← standard enum values and constants\n      exceptions/\n        billing_exceptions.py     ← standardized error types</code></pre></div>\n\n<h4 id=\"terminology-validation-tools\">Terminology Validation Tools</h4>\n<p><strong>Automated Terminology Checker:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TerminologyValidator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validates consistent term usage across codebase and documentation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, glossary_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Load glossary terms and approved aliases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Build term validation rules and patterns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize spell checker with billing vocabulary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_code_comments</span><span style=\"color:#E1E4E8\">(self, file_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[ValidationResult]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check code comments for consistent terminology usage.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Parse code comments and docstrings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check against glossary terms and flag inconsistencies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Suggest correct terms for common misspellings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return validation results with line numbers and suggestions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_documentation</span><span style=\"color:#E1E4E8\">(self, doc_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[ValidationResult]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check documentation for terminology consistency.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Parse markdown/text content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Identify billing terminology usage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Flag undefined terms or inconsistent usage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Suggest approved alternatives from glossary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Team Communication Templates:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Standard comment template for complex billing logic</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Calculates proration for subscription plan changes.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Billing Terms:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">- proration: partial charge calculation for mid-cycle changes  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">- usage factor: fraction of billing cycle remaining</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">- billing anchor: fixed day for recurring subscription charges</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    old_plan: Current subscription plan with pricing</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    new_plan: Target plan for upgrade/downgrade</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    change_date: When plan change becomes effective</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    ProrationResult with charge_amount, credit_amount, net_amount</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Invariants:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    - Maintains proration symmetry (upgrade then downgrade nets zero)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    - Preserves billing anchor date throughout plan changes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span></code></pre></div>\n\n<h4 id=\"common-terminology-mistakes\">Common Terminology Mistakes</h4>\n<p>⚠️ <strong>Pitfall: Inconsistent Money Terminology</strong>\nTeams often mix &quot;amount,&quot; &quot;price,&quot; and &quot;cost&quot; inconsistently. Establish clear conventions: use &quot;amount&quot; for customer-owed money, &quot;price&quot; for plan rates, and &quot;cost&quot; for business expenses. This prevents confusion in code reviews and customer communication.</p>\n<p>⚠️ <strong>Pitfall: Overloaded State Terms</strong> \nTerms like &quot;active,&quot; &quot;enabled,&quot; and &quot;running&quot; get used interchangeably for subscription states. Use the exact <code>SubscriptionStatus</code> enum values (<code>active</code>, <code>past_due</code>, <code>cancelled</code>) consistently across all contexts to prevent state machine bugs.</p>\n<p>⚠️ <strong>Pitfall: Vague Usage Terminology</strong>\nDistinguishing between &quot;usage events,&quot; &quot;usage metrics,&quot; and &quot;usage aggregations&quot; is critical for usage-based billing. Usage events are raw activity records, metrics are measurable quantities, and aggregations are billing-period summaries.</p>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Terminology Consistency Validation:</strong></p>\n<ul>\n<li>Run terminology checker across codebase: <code>python scripts/check_terminology.py</code></li>\n<li>Expected: No inconsistent term usage, all billing terms match glossary</li>\n<li>Manual verification: Code reviews should reference specific glossary terms</li>\n<li>Signs of issues: Mixed terminology in related functions, undefined terms in comments</li>\n</ul>\n<p><strong>Customer-Facing Language Validation:</strong>  </p>\n<ul>\n<li>Review API error messages and documentation for consistent terminology</li>\n<li>Expected: All customer communications use approved terms from customer glossary</li>\n<li>Manual verification: Support team can explain any billing term using glossary definitions</li>\n<li>Signs of issues: Customer questions about unclear billing terminology</li>\n</ul>\n<p>This comprehensive glossary serves as the authoritative reference for all billing system terminology. Teams should reference it during code reviews, architectural discussions, and customer communication to maintain consistency and clarity throughout the system lifecycle.</p>\n","toc":[{"level":1,"text":"Subscription &amp; Billing System: Design Document","id":"subscription-amp-billing-system-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: The Digital Subscription Economy","id":"mental-model-the-digital-subscription-economy"},{"level":3,"text":"Existing Approaches and Trade-offs","id":"existing-approaches-and-trade-offs"},{"level":4,"text":"Third-Party Billing Platforms","id":"third-party-billing-platforms"},{"level":4,"text":"Custom Solution Trade-offs","id":"custom-solution-trade-offs"},{"level":4,"text":"Hybrid Approaches","id":"hybrid-approaches"},{"level":4,"text":"Technical Challenges in Custom Billing Systems","id":"technical-challenges-in-custom-billing-systems"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Project Structure","id":"recommended-project-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core System Configuration","id":"core-system-configuration"},{"level":4,"text":"Development and Testing Setup","id":"development-and-testing-setup"},{"level":4,"text":"Key Development Patterns","id":"key-development-patterns"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Mental Model: Building a Financial Operating System","id":"mental-model-building-a-financial-operating-system"},{"level":3,"text":"Functional Requirements","id":"functional-requirements"},{"level":4,"text":"Core Subscription Management","id":"core-subscription-management"},{"level":4,"text":"Plan and Pricing Flexibility","id":"plan-and-pricing-flexibility"},{"level":4,"text":"Subscription Lifecycle Transitions","id":"subscription-lifecycle-transitions"},{"level":4,"text":"Proration and Plan Changes","id":"proration-and-plan-changes"},{"level":4,"text":"Usage-Based Billing Integration","id":"usage-based-billing-integration"},{"level":3,"text":"Non-Functional Requirements","id":"non-functional-requirements"},{"level":4,"text":"Financial Precision and Data Integrity","id":"financial-precision-and-data-integrity"},{"level":4,"text":"Performance and Scalability Targets","id":"performance-and-scalability-targets"},{"level":4,"text":"Reliability and Fault Tolerance","id":"reliability-and-fault-tolerance"},{"level":4,"text":"Security and Compliance Standards","id":"security-and-compliance-standards"},{"level":3,"text":"Explicit Non-Goals","id":"explicit-non-goals"},{"level":4,"text":"Payment Processing Infrastructure","id":"payment-processing-infrastructure"},{"level":4,"text":"Advanced Revenue Recognition","id":"advanced-revenue-recognition"},{"level":4,"text":"Complex Tax Calculation","id":"complex-tax-calculation"},{"level":4,"text":"Enterprise Contract Management","id":"enterprise-contract-management"},{"level":4,"text":"Multi-Tenant Architecture","id":"multi-tenant-architecture"},{"level":4,"text":"Real-Time Analytics and Business Intelligence","id":"real-time-analytics-and-business-intelligence"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Project Structure","id":"recommended-project-structure"},{"level":4,"text":"Core Infrastructure Components","id":"core-infrastructure-components"},{"level":4,"text":"Configuration Management","id":"configuration-management"},{"level":4,"text":"Milestone Validation Checkpoints","id":"milestone-validation-checkpoints"},{"level":4,"text":"Common Configuration Pitfalls","id":"common-configuration-pitfalls"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Overview","id":"component-overview"},{"level":4,"text":"Mental Model: The Financial Operations Center","id":"mental-model-the-financial-operations-center"},{"level":4,"text":"Core System Components","id":"core-system-components"},{"level":4,"text":"Component Interaction Patterns","id":"component-interaction-patterns"},{"level":3,"text":"Integration Patterns","id":"integration-patterns"},{"level":4,"text":"Mental Model: The Banking Network","id":"mental-model-the-banking-network"},{"level":4,"text":"Payment Gateway Integration","id":"payment-gateway-integration"},{"level":4,"text":"Customer Management Integration","id":"customer-management-integration"},{"level":4,"text":"Tax Calculation Integration","id":"tax-calculation-integration"},{"level":4,"text":"Business Intelligence Integration","id":"business-intelligence-integration"},{"level":4,"text":"External Service Error Handling","id":"external-service-error-handling"},{"level":3,"text":"Recommended Codebase Structure","id":"recommended-codebase-structure"},{"level":4,"text":"Mental Model: The Corporate Organizational Chart","id":"mental-model-the-corporate-organizational-chart"},{"level":4,"text":"Directory Structure Organization","id":"directory-structure-organization"},{"level":4,"text":"Architecture Layer Responsibilities","id":"architecture-layer-responsibilities"},{"level":4,"text":"Configuration and Deployment Structure","id":"configuration-and-deployment-structure"},{"level":4,"text":"Development Workflow Support","id":"development-workflow-support"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Core Infrastructure Setup","id":"core-infrastructure-setup"},{"level":4,"text":"Component Service Skeletons","id":"component-service-skeletons"},{"level":4,"text":"File Structure Implementation","id":"file-structure-implementation"},{"level":4,"text":"Milestone Validation Checkpoints","id":"milestone-validation-checkpoints"},{"level":2,"text":"Data Model and Core Entities","id":"data-model-and-core-entities"},{"level":3,"text":"Mental Model: The Financial Ledger System","id":"mental-model-the-financial-ledger-system"},{"level":3,"text":"Core Business Entities","id":"core-business-entities"},{"level":4,"text":"Customer Entity","id":"customer-entity"},{"level":4,"text":"Plan Entity","id":"plan-entity"},{"level":4,"text":"Subscription Entity","id":"subscription-entity"},{"level":4,"text":"Invoice Entity","id":"invoice-entity"},{"level":4,"text":"Invoice Line Item Entity","id":"invoice-line-item-entity"},{"level":4,"text":"Payment Entity","id":"payment-entity"},{"level":3,"text":"Entity Relationships and Constraints","id":"entity-relationships-and-constraints"},{"level":4,"text":"Primary Relationships","id":"primary-relationships"},{"level":4,"text":"Business Rule Constraints","id":"business-rule-constraints"},{"level":4,"text":"Data Integrity Rules","id":"data-integrity-rules"},{"level":3,"text":"Usage Tracking Data Model","id":"usage-tracking-data-model"},{"level":4,"text":"Usage Event Entity","id":"usage-event-entity"},{"level":4,"text":"Usage Aggregation Entity","id":"usage-aggregation-entity"},{"level":4,"text":"Usage Billing Entity","id":"usage-billing-entity"},{"level":4,"text":"Usage Event Processing Flow","id":"usage-event-processing-flow"},{"level":4,"text":"Common Usage Tracking Pitfalls","id":"common-usage-tracking-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Types Implementation","id":"core-types-implementation"},{"level":4,"text":"Core Entity Skeletons","id":"core-entity-skeletons"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Plan Management Component","id":"plan-management-component"},{"level":3,"text":"Mental Model: Product Catalog Design","id":"mental-model-product-catalog-design"},{"level":3,"text":"Pricing Model Implementation","id":"pricing-model-implementation"},{"level":3,"text":"ADR: Plan Versioning Strategy","id":"adr-plan-versioning-strategy"},{"level":3,"text":"Common Pitfalls in Plan Management","id":"common-pitfalls-in-plan-management"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Subscription Lifecycle Management","id":"subscription-lifecycle-management"},{"level":3,"text":"Mental Model: Membership Lifecycle","id":"mental-model-membership-lifecycle"},{"level":3,"text":"Subscription State Machine","id":"subscription-state-machine"},{"level":3,"text":"ADR: Renewal Processing Architecture","id":"adr-renewal-processing-architecture"},{"level":3,"text":"Dunning and Grace Period Policies","id":"dunning-and-grace-period-policies"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Proration and Plan Changes","id":"proration-and-plan-changes"},{"level":3,"text":"Mental Model: Partial Refunds and Charges","id":"mental-model-partial-refunds-and-charges"},{"level":3,"text":"Proration Calculation Algorithms","id":"proration-calculation-algorithms"},{"level":4,"text":"Time-Based Proration Formula","id":"time-based-proration-formula"},{"level":4,"text":"Quantity-Based Proration Formula","id":"quantity-based-proration-formula"},{"level":4,"text":"Combined Proration Scenarios","id":"combined-proration-scenarios"},{"level":4,"text":"Currency and Precision Handling","id":"currency-and-precision-handling"},{"level":3,"text":"ADR: Credit Balance Management","id":"adr-credit-balance-management"},{"level":4,"text":"Credit Application Algorithm","id":"credit-application-algorithm"},{"level":3,"text":"Common Proration Pitfalls","id":"common-proration-pitfalls"},{"level":4,"text":"⚠️ Pitfall: Calendar Month Variations","id":"-pitfall-calendar-month-variations"},{"level":4,"text":"⚠️ Pitfall: Timezone Confusion in Proration Timing","id":"-pitfall-timezone-confusion-in-proration-timing"},{"level":4,"text":"⚠️ Pitfall: Double-Counting Credits During Multiple Plan Changes","id":"-pitfall-double-counting-credits-during-multiple-plan-changes"},{"level":4,"text":"⚠️ Pitfall: Rounding Errors Accumulating Across Customers","id":"-pitfall-rounding-errors-accumulating-across-customers"},{"level":4,"text":"⚠️ Pitfall: Proration on Trial Periods","id":"-pitfall-proration-on-trial-periods"},{"level":4,"text":"⚠️ Pitfall: Currency Conversion During Proration","id":"-pitfall-currency-conversion-during-proration"},{"level":4,"text":"⚠️ Pitfall: Negative Credit Balances","id":"-pitfall-negative-credit-balances"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Money and Currency Infrastructure","id":"core-money-and-currency-infrastructure"},{"level":4,"text":"Proration Calculation Engine Skeleton","id":"proration-calculation-engine-skeleton"},{"level":4,"text":"Credit Balance Manager Skeleton","id":"credit-balance-manager-skeleton"},{"level":4,"text":"Plan Change Handler Skeleton","id":"plan-change-handler-skeleton"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Usage-Based Billing Engine","id":"usage-based-billing-engine"},{"level":3,"text":"Mental Model: Utility Metering","id":"mental-model-utility-metering"},{"level":3,"text":"Usage Event Ingestion","id":"usage-event-ingestion"},{"level":3,"text":"ADR: Usage Aggregation Architecture","id":"adr-usage-aggregation-architecture"},{"level":3,"text":"Overage and Tiered Usage Billing","id":"overage-and-tiered-usage-billing"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Invoicing and Payment Processing","id":"invoicing-and-payment-processing"},{"level":3,"text":"Mental Model: Restaurant Check Generation and Payment","id":"mental-model-restaurant-check-generation-and-payment"},{"level":3,"text":"Invoice Generation Engine","id":"invoice-generation-engine"},{"level":4,"text":"Invoice Line Item Calculation","id":"invoice-line-item-calculation"},{"level":4,"text":"Invoice Status State Machine","id":"invoice-status-state-machine"},{"level":4,"text":"Invoice Generation Algorithms","id":"invoice-generation-algorithms"},{"level":4,"text":"Common Invoice Generation Pitfalls","id":"common-invoice-generation-pitfalls"},{"level":3,"text":"Payment Gateway Integration","id":"payment-gateway-integration"},{"level":4,"text":"Payment Method Management","id":"payment-method-management"},{"level":4,"text":"Charge Processing Flow","id":"charge-processing-flow"},{"level":4,"text":"Webhook Event Processing","id":"webhook-event-processing"},{"level":3,"text":"ADR: Payment Webhook Processing","id":"adr-payment-webhook-processing"},{"level":4,"text":"Webhook Idempotency and Deduplication","id":"webhook-idempotency-and-deduplication"},{"level":4,"text":"Payment Failure Recovery","id":"payment-failure-recovery"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Invoice Generation Infrastructure","id":"core-invoice-generation-infrastructure"},{"level":4,"text":"Payment Gateway Integration Skeleton","id":"payment-gateway-integration-skeleton"},{"level":4,"text":"Webhook Processing Service","id":"webhook-processing-service"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Component Interactions and Data Flow","id":"component-interactions-and-data-flow"},{"level":3,"text":"Mental Model: Orchestra Coordination","id":"mental-model-orchestra-coordination"},{"level":3,"text":"Subscription Creation Flow","id":"subscription-creation-flow"},{"level":4,"text":"End-to-End Process Flow","id":"end-to-end-process-flow"},{"level":4,"text":"Component Interaction Patterns","id":"component-interaction-patterns"},{"level":4,"text":"Data Consistency Guarantees","id":"data-consistency-guarantees"},{"level":3,"text":"Monthly Billing Cycle Flow","id":"monthly-billing-cycle-flow"},{"level":4,"text":"Billing Cycle Orchestration","id":"billing-cycle-orchestration"},{"level":4,"text":"Failure Handling and Recovery","id":"failure-handling-and-recovery"},{"level":4,"text":"Performance and Scalability Considerations","id":"performance-and-scalability-considerations"},{"level":3,"text":"Plan Change and Proration Flow","id":"plan-change-and-proration-flow"},{"level":4,"text":"Plan Change Orchestration Workflow","id":"plan-change-orchestration-workflow"},{"level":4,"text":"Complex Proration Scenarios","id":"complex-proration-scenarios"},{"level":4,"text":"Error Handling and Rollback Mechanisms","id":"error-handling-and-rollback-mechanisms"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Workflow Infrastructure Starter Code","id":"workflow-infrastructure-starter-code"},{"level":4,"text":"Event-Driven Communication Infrastructure","id":"event-driven-communication-infrastructure"},{"level":4,"text":"Subscription Creation Workflow Implementation","id":"subscription-creation-workflow-implementation"},{"level":4,"text":"Billing Cycle Workflow Skeleton","id":"billing-cycle-workflow-skeleton"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Common Integration Issues","id":"common-integration-issues"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Mental Model: Financial Fault Tolerance","id":"mental-model-financial-fault-tolerance"},{"level":3,"text":"Payment Failure Recovery","id":"payment-failure-recovery"},{"level":3,"text":"Data Consistency and Concurrency","id":"data-consistency-and-concurrency"},{"level":3,"text":"Billing Edge Cases","id":"billing-edge-cases"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Common Pitfalls and Debugging","id":"common-pitfalls-and-debugging"},{"level":2,"text":"Testing Strategy and Validation","id":"testing-strategy-and-validation"},{"level":3,"text":"Mental Model: The Financial Audit Trail","id":"mental-model-the-financial-audit-trail"},{"level":3,"text":"Billing Logic Unit Tests","id":"billing-logic-unit-tests"},{"level":4,"text":"Proration Calculation Testing","id":"proration-calculation-testing"},{"level":4,"text":"Usage Aggregation Testing","id":"usage-aggregation-testing"},{"level":4,"text":"Pricing Model Testing","id":"pricing-model-testing"},{"level":4,"text":"Feature Entitlement Testing","id":"feature-entitlement-testing"},{"level":3,"text":"Integration and End-to-End Tests","id":"integration-and-end-to-end-tests"},{"level":4,"text":"Payment Gateway Integration Testing","id":"payment-gateway-integration-testing"},{"level":4,"text":"Subscription Lifecycle Integration Testing","id":"subscription-lifecycle-integration-testing"},{"level":4,"text":"Database Transaction Testing","id":"database-transaction-testing"},{"level":4,"text":"Cross-Component Data Flow Testing","id":"cross-component-data-flow-testing"},{"level":3,"text":"Milestone Validation Checkpoints","id":"milestone-validation-checkpoints"},{"level":4,"text":"Milestone 1: Plans &amp; Pricing Validation","id":"milestone-1-plans-amp-pricing-validation"},{"level":4,"text":"Milestone 2: Subscription Lifecycle Validation","id":"milestone-2-subscription-lifecycle-validation"},{"level":4,"text":"Milestone 3: Proration &amp; Plan Changes Validation","id":"milestone-3-proration-amp-plan-changes-validation"},{"level":4,"text":"Milestone 4: Usage-Based Billing Validation","id":"milestone-4-usage-based-billing-validation"},{"level":3,"text":"Common Testing Pitfalls","id":"common-testing-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Test Structure","id":"recommended-test-structure"},{"level":4,"text":"Core Testing Infrastructure","id":"core-testing-infrastructure"},{"level":4,"text":"Property-Based Testing Framework","id":"property-based-testing-framework"},{"level":4,"text":"Integration Test Infrastructure","id":"integration-test-infrastructure"},{"level":4,"text":"Milestone Validation Scripts","id":"milestone-validation-scripts"},{"level":4,"text":"Debugging Test Utilities","id":"debugging-test-utilities"},{"level":4,"text":"Milestone Checkpoint Validation","id":"milestone-checkpoint-validation"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Mental Model: Detective Work for Financial Systems","id":"mental-model-detective-work-for-financial-systems"},{"level":3,"text":"Billing Calculation Issues","id":"billing-calculation-issues"},{"level":4,"text":"Currency Precision and Rounding Errors","id":"currency-precision-and-rounding-errors"},{"level":4,"text":"Credit Balance and Application Errors","id":"credit-balance-and-application-errors"},{"level":3,"text":"State Consistency Problems","id":"state-consistency-problems"},{"level":4,"text":"Subscription State Inconsistencies","id":"subscription-state-inconsistencies"},{"level":4,"text":"Invoice and Payment State Alignment","id":"invoice-and-payment-state-alignment"},{"level":3,"text":"Webhook and Integration Debugging","id":"webhook-and-integration-debugging"},{"level":4,"text":"Webhook Processing Reliability","id":"webhook-processing-reliability"},{"level":4,"text":"Payment Method and Subscription Synchronization","id":"payment-method-and-subscription-synchronization"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Future Extensions and Scalability","id":"future-extensions-and-scalability"},{"level":3,"text":"Mental Model: Evolution of a Growing Business","id":"mental-model-evolution-of-a-growing-business"},{"level":3,"text":"Advanced Pricing Models","id":"advanced-pricing-models"},{"level":3,"text":"Multi-Tenant Architecture","id":"multi-tenant-architecture"},{"level":3,"text":"Analytics and Revenue Reporting","id":"analytics-and-revenue-reporting"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Mental Model: Building a Shared Language","id":"mental-model-building-a-shared-language"},{"level":3,"text":"Core Billing and Subscription Terminology","id":"core-billing-and-subscription-terminology"},{"level":3,"text":"Pricing and Plan Management Terms","id":"pricing-and-plan-management-terms"},{"level":3,"text":"Technical Implementation Vocabulary","id":"technical-implementation-vocabulary"},{"level":3,"text":"Data and Storage Concepts","id":"data-and-storage-concepts"},{"level":3,"text":"Payment and Financial Processing Terms","id":"payment-and-financial-processing-terms"},{"level":3,"text":"Error Handling and Debugging Terminology","id":"error-handling-and-debugging-terminology"},{"level":3,"text":"Advanced Architecture and Scalability Terms","id":"advanced-architecture-and-scalability-terms"},{"level":3,"text":"Compliance and Regulatory Terms","id":"compliance-and-regulatory-terms"},{"level":3,"text":"Testing and Quality Assurance Vocabulary","id":"testing-and-quality-assurance-vocabulary"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Terminology Validation Tools","id":"terminology-validation-tools"},{"level":4,"text":"Common Terminology Mistakes","id":"common-terminology-mistakes"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"}],"title":"Subscription & Billing System: Design Document","markdown":"# Subscription & Billing System: Design Document\n\n\n## Overview\n\nA comprehensive subscription management platform that handles recurring billing, usage tracking, and customer lifecycle management. The key architectural challenge is maintaining consistency across distributed billing operations while supporting complex pricing models, proration calculations, and real-time usage metering.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** Foundation for all milestones - establishes the business and technical context\n\n### Mental Model: The Digital Subscription Economy\n\nThink of subscription billing like running a **premium gym with multiple membership tiers**. In the physical world, a gym might offer basic access, premium classes, and VIP concierge services at different monthly rates. Members can upgrade from basic to premium mid-month (paying the difference), pause their membership during vacation, or cancel at the end of their billing cycle. The gym needs to track who has access to which facilities, when payments are due, how much to charge for partial months, and what happens when a member's credit card expires.\n\nNow imagine this gym operates across multiple time zones, serves millions of members simultaneously, never closes for maintenance, and offers hundreds of different membership combinations. The digital subscription economy amplifies every complexity of physical membership management by orders of magnitude.\n\n**Subscription billing systems** are the digital equivalent of that gym's membership office, but they must handle several additional layers of complexity that don't exist in physical businesses:\n\n1. **Instant Global Scale**: A software product can acquire thousands of customers overnight across different countries, currencies, and regulatory environments. Unlike a physical gym that grows gradually, digital products can experience explosive growth that breaks traditional billing approaches.\n\n2. **Complex Usage Patterns**: Digital services often combine fixed monthly fees with variable usage charges. Think of it like a gym membership that includes basic access but charges extra per personal training session, except the \"sessions\" might be API calls, storage gigabytes, or processed transactions measured in real-time.\n\n3. **Continuous Service Delivery**: Physical gyms can temporarily restrict access for non-payment, but digital services face the challenge of real-time entitlement decisions. When a customer's payment fails, the system must instantly determine what features to disable while maintaining a path to service restoration.\n\n4. **Microscopic Financial Precision**: Digital billing operates at scales where rounding errors of a few cents, multiplied across millions of customers and thousands of plan changes, can result in significant revenue leakage or compliance violations.\n\nThe mental model throughout this design will be that we're building **a fully automated membership management system** for a service that never sleeps, serves global customers, and must make split-second decisions about service access based on complex financial calculations.\n\n### Existing Approaches and Trade-offs\n\nWhen building subscription billing capabilities, engineering teams face a fundamental **build-versus-buy decision** that significantly impacts development velocity, operational complexity, and long-term business flexibility. The landscape includes several mature third-party solutions alongside the option of building a custom system.\n\n#### Third-Party Billing Platforms\n\n**Stripe Billing** represents the most popular third-party approach, offering a comprehensive subscription management layer on top of Stripe's payment processing infrastructure. The platform provides pre-built subscription lifecycle management, automatic proration calculations, and extensive webhook integration for real-time billing events.\n\n| Capability | Stripe Billing | Custom Solution |\n|------------|----------------|------------------|\n| Time to Market | 2-4 weeks integration | 6-12 months development |\n| Proration Logic | Pre-built, battle-tested | Must implement and debug |\n| Payment Failures | Automatic retry policies | Custom dunning management |\n| Tax Compliance | Built-in tax calculation | Manual tax service integration |\n| Multi-currency | Native support | Exchange rate management needed |\n| Usage Metering | Basic usage reporting | Full control over aggregation |\n| Complex Pricing | Limited to Stripe's models | Unlimited customization |\n| Vendor Lock-in | High - data and logic coupling | None - full ownership |\n| Monthly Cost | $0.5% of revenue + payment fees | Infrastructure + development costs |\n\n**Chargebee** and **Recurly** offer similar comprehensive billing platforms with slightly different feature emphases. Chargebee excels at complex pricing models and revenue recognition, while Recurly focuses on subscription analytics and churn reduction features.\n\n**Specialized Platforms** like Lago, Metronome, and Togai have emerged specifically for usage-based billing scenarios. These platforms excel at high-volume event ingestion and complex usage aggregation but may lack the subscription lifecycle sophistication of general-purpose billing platforms.\n\n#### Custom Solution Trade-offs\n\nBuilding a custom subscription billing system offers complete control over business logic and data ownership, but introduces significant engineering complexity and ongoing maintenance responsibilities.\n\n> **Key Insight**: The decision isn't just about initial development effort - it's about accepting long-term responsibility for financial accuracy, compliance, and operational reliability in a domain where mistakes directly impact revenue.\n\n**Advantages of Custom Development:**\n\n- **Business Logic Flexibility**: Complete control over pricing models, proration algorithms, and subscription lifecycle policies. This becomes crucial for businesses with unique pricing strategies or complex B2B arrangements that don't fit standard platform templates.\n\n- **Data Ownership and Integration**: Direct access to all billing and usage data without API limitations. This enables sophisticated analytics, machine learning applications, and seamless integration with existing business systems.\n\n- **Cost Predictability**: Fixed infrastructure costs rather than percentage-based fees that scale with revenue. For high-volume businesses, this can represent significant savings compared to platform fees.\n\n- **Performance Optimization**: Ability to optimize database schemas, caching strategies, and processing pipelines for specific usage patterns and scale requirements.\n\n**Disadvantages of Custom Development:**\n\n- **Domain Complexity Underestimation**: Subscription billing appears straightforward but contains numerous edge cases around calendar calculations, timezone handling, currency precision, and regulatory compliance. Teams consistently underestimate the effort required to handle these correctly.\n\n- **Financial Accuracy Responsibility**: Custom systems must achieve the same level of financial precision and audit compliance as established platforms, but without the benefit of years of production hardening and edge case discovery.\n\n- **Ongoing Maintenance Burden**: Billing systems require continuous updates for payment processor changes, tax regulation updates, currency support, and security compliance requirements.\n\n- **Expertise Requirements**: Building reliable billing systems requires deep understanding of payment processing, financial regulations, tax compliance, and accounting principles - expertise that may not exist within typical engineering teams.\n\n#### Hybrid Approaches\n\nMany successful implementations combine third-party platforms for core payment processing and basic subscription management with custom systems for business-specific logic and advanced analytics.\n\n**Payment Gateway + Custom Billing Logic**: Use established payment processors (Stripe, Braintree) for payment collection and PCI compliance while building custom subscription management, proration, and usage tracking systems. This approach provides payment reliability while maintaining business logic control.\n\n**Platform Integration with Custom Extensions**: Implement core billing through platforms like Stripe or Chargebee while building custom systems for specialized requirements like complex usage aggregation, custom pricing models, or advanced analytics that exceed platform capabilities.\n\n> **Architecture Decision: Custom System with Payment Gateway Integration**\n> - **Context**: This design document focuses on building a custom subscription billing system that integrates with an existing payment gateway (from the prerequisite payment-gateway project). This represents a middle-ground approach that maintains control over business logic while leveraging proven payment processing infrastructure.\n> - **Options Considered**: \n>   1. Full third-party platform (Stripe Billing)\n>   2. Hybrid payment platform with custom subscription logic\n>   3. Completely custom payment and billing system\n> - **Decision**: Custom billing system with payment gateway integration (Option 2)\n> - **Rationale**: Provides maximum business logic flexibility and data ownership while avoiding the complexity and compliance burden of payment processing. Enables sophisticated usage-based billing and custom proration logic that may not fit platform constraints.\n> - **Consequences**: Requires building and maintaining complex billing logic, but enables unlimited customization and direct data access. Development timeline extends 6-12 months compared to platform integration, but eliminates ongoing percentage-based fees and vendor lock-in.\n\n#### Technical Challenges in Custom Billing Systems\n\nBuilding reliable subscription billing systems presents several technical challenges that don't exist in typical CRUD applications:\n\n**Financial Precision and Consistency**: Billing calculations must maintain perfect accuracy across concurrent operations, system failures, and data migrations. Unlike other domains where eventual consistency may be acceptable, financial systems require immediate consistency with full audit trails.\n\n**Complex State Management**: Subscriptions, invoices, and payment states interact in intricate ways that create potential race conditions and inconsistent state scenarios. The system must handle concurrent plan changes, payment processing, and usage updates without compromising data integrity.\n\n**Time-Sensitive Processing**: Billing cycles, trial expirations, and payment retries operate on strict time schedules that cannot be missed. The system must reliably process time-sensitive events even during high load periods or infrastructure failures.\n\n**Multi-Tenant Data Isolation**: Billing systems often serve multiple business entities or customer segments with different pricing rules, tax requirements, and compliance needs. The architecture must ensure complete data isolation while maintaining operational efficiency.\n\n**Integration Complexity**: Modern billing systems integrate with payment processors, tax calculation services, accounting systems, CRM platforms, and business intelligence tools. Each integration introduces potential failure modes and data synchronization challenges.\n\n**Regulatory Compliance**: Subscription billing systems must comply with financial regulations, data privacy laws, and industry-specific requirements that vary by geography and business model. These requirements often change over time, requiring system flexibility.\n\n> **Critical Design Principle**: In billing systems, correctness is more important than performance, but the system must be designed to achieve both. Financial accuracy cannot be compromised for faster processing, but slow billing operations create poor customer experiences and operational challenges.\n\nThe remainder of this design document provides detailed guidance for building a custom subscription billing system that addresses these challenges while maintaining the flexibility advantages that justify custom development over third-party platforms.\n\n### Implementation Guidance\n\nThe implementation approach for this subscription billing system prioritizes **financial accuracy and auditability** over development speed. The technology choices reflect the need for strong consistency, precise decimal calculations, and reliable event processing.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Database | PostgreSQL with ACID transactions | PostgreSQL + Redis for session data |\n| Decimal Precision | Python `decimal.Decimal` library | Custom fixed-point arithmetic |\n| Task Scheduling | APScheduler for billing cycles | Celery + Redis for distributed tasks |\n| API Framework | FastAPI with Pydantic validation | Django REST Framework |\n| Event Processing | Direct database triggers | Event sourcing with Kafka |\n| Monitoring | Structured logging + Prometheus | Full observability stack (traces, metrics, logs) |\n| Testing | pytest with factory-boy | Property-based testing with Hypothesis |\n\n#### Recommended Project Structure\n\nThe codebase organization separates business domain logic from infrastructure concerns, enabling easier testing and future scaling decisions:\n\n```\nsubscription-billing/\n├── src/billing/\n│   ├── __init__.py\n│   ├── domain/                    # Core business logic\n│   │   ├── __init__.py\n│   │   ├── models/                # Business entities\n│   │   │   ├── customer.py\n│   │   │   ├── plan.py\n│   │   │   ├── subscription.py\n│   │   │   └── invoice.py\n│   │   ├── services/              # Business operations\n│   │   │   ├── plan_manager.py\n│   │   │   ├── subscription_engine.py\n│   │   │   ├── proration_calculator.py\n│   │   │   └── usage_tracker.py\n│   │   └── exceptions.py\n│   ├── infrastructure/            # External integrations\n│   │   ├── database/\n│   │   │   ├── repositories.py\n│   │   │   └── migrations/\n│   │   ├── payment_gateway/\n│   │   │   └── gateway_client.py\n│   │   ├── events/\n│   │   │   └── webhook_handlers.py\n│   │   └── tasks/\n│   │       └── billing_jobs.py\n│   ├── api/                       # HTTP interface\n│   │   ├── __init__.py\n│   │   ├── routers/\n│   │   │   ├── plans.py\n│   │   │   ├── subscriptions.py\n│   │   │   └── usage.py\n│   │   ├── schemas/               # Request/response models\n│   │   └── dependencies.py\n│   └── config/\n│       ├── settings.py\n│       └── logging.py\n├── tests/\n│   ├── unit/\n│   ├── integration/\n│   └── fixtures/\n├── scripts/\n│   ├── migrate_data.py\n│   └── billing_reconciliation.py\n├── docker-compose.yml\n├── requirements.txt\n└── README.md\n```\n\n#### Infrastructure Starter Code\n\n**Database Connection and Transaction Management** (`infrastructure/database/connection.py`):\n\n```python\nimport contextlib\nimport logging\nfrom decimal import Decimal\nfrom typing import Generator\nimport psycopg2\nfrom psycopg2.extras import RealDictCursor\nfrom psycopg2.extensions import ISOLATION_LEVEL_SERIALIZABLE\n\nlogger = logging.getLogger(__name__)\n\nclass DatabaseManager:\n    \"\"\"Manages database connections with transaction support for billing operations.\"\"\"\n    \n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n        self._setup_decimal_adapter()\n    \n    def _setup_decimal_adapter(self):\n        \"\"\"Configure psycopg2 to handle Python Decimal objects properly.\"\"\"\n        from psycopg2.extensions import register_adapter\n        from psycopg2 import sql\n        \n        def adapt_decimal(decimal_obj):\n            return sql.Literal(str(decimal_obj))\n        \n        register_adapter(Decimal, adapt_decimal)\n    \n    @contextlib.contextmanager\n    def transaction(self, isolation_level=ISOLATION_LEVEL_SERIALIZABLE) -> Generator:\n        \"\"\"\n        Provides transactional context for billing operations.\n        Uses SERIALIZABLE isolation to prevent financial inconsistencies.\n        \"\"\"\n        conn = psycopg2.connect(\n            self.connection_string,\n            cursor_factory=RealDictCursor\n        )\n        conn.set_isolation_level(isolation_level)\n        \n        try:\n            yield conn\n            conn.commit()\n            logger.info(\"Transaction committed successfully\")\n        except Exception as e:\n            conn.rollback()\n            logger.error(f\"Transaction rolled back due to error: {e}\")\n            raise\n        finally:\n            conn.close()\n    \n    def execute_query(self, query: str, params=None):\n        \"\"\"Execute a read-only query and return results.\"\"\"\n        with self.transaction() as conn:\n            cursor = conn.cursor()\n            cursor.execute(query, params)\n            return cursor.fetchall()\n\n# Global database instance\ndb = DatabaseManager(\"postgresql://billing:password@localhost/billing_db\")\n```\n\n**Money and Currency Handling** (`domain/value_objects.py`):\n\n```python\nfrom decimal import Decimal, ROUND_HALF_UP\nfrom dataclasses import dataclass\nfrom typing import Union\nimport re\n\n@dataclass(frozen=True)\nclass Money:\n    \"\"\"\n    Immutable money value that maintains precision and currency information.\n    Always stores amounts in the smallest currency unit (e.g., cents for USD).\n    \"\"\"\n    amount_cents: int\n    currency_code: str\n    \n    def __post_init__(self):\n        if not re.match(r'^[A-Z]{3}$', self.currency_code):\n            raise ValueError(f\"Invalid currency code: {self.currency_code}\")\n        if not isinstance(self.amount_cents, int):\n            raise ValueError(\"Amount must be stored as integer cents\")\n    \n    @classmethod\n    def from_decimal(cls, amount: Union[Decimal, float, str], currency: str) -> 'Money':\n        \"\"\"Create Money from decimal amount (e.g., 19.99 USD).\"\"\"\n        decimal_amount = Decimal(str(amount))\n        cents = int(decimal_amount.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP) * 100)\n        return cls(cents, currency.upper())\n    \n    def to_decimal(self) -> Decimal:\n        \"\"\"Convert to decimal representation (e.g., 1999 cents -> 19.99).\"\"\"\n        return Decimal(self.amount_cents) / 100\n    \n    def __add__(self, other: 'Money') -> 'Money':\n        if self.currency_code != other.currency_code:\n            raise ValueError(f\"Cannot add {self.currency_code} and {other.currency_code}\")\n        return Money(self.amount_cents + other.amount_cents, self.currency_code)\n    \n    def __sub__(self, other: 'Money') -> 'Money':\n        if self.currency_code != other.currency_code:\n            raise ValueError(f\"Cannot subtract {self.currency_code} and {other.currency_code}\")\n        return Money(self.amount_cents - other.amount_cents, self.currency_code)\n    \n    def __mul__(self, factor: Union[int, Decimal]) -> 'Money':\n        \"\"\"Multiply money by a factor, rounding to nearest cent.\"\"\"\n        if isinstance(factor, int):\n            return Money(self.amount_cents * factor, self.currency_code)\n        \n        decimal_result = Decimal(self.amount_cents) * Decimal(str(factor))\n        rounded_cents = int(decimal_result.quantize(Decimal('1'), rounding=ROUND_HALF_UP))\n        return Money(rounded_cents, self.currency_code)\n    \n    def is_zero(self) -> bool:\n        return self.amount_cents == 0\n    \n    def is_positive(self) -> bool:\n        return self.amount_cents > 0\n    \n    def is_negative(self) -> bool:\n        return self.amount_cents < 0\n\n# Currency definitions for validation\nSUPPORTED_CURRENCIES = {\n    'USD': {'name': 'US Dollar', 'symbol': '$'},\n    'EUR': {'name': 'Euro', 'symbol': '€'},\n    'GBP': {'name': 'British Pound', 'symbol': '£'},\n}\n\ndef validate_currency(currency_code: str) -> bool:\n    \"\"\"Validate that currency is supported by the system.\"\"\"\n    return currency_code.upper() in SUPPORTED_CURRENCIES\n```\n\n**Event Logging for Audit Trails** (`infrastructure/audit/event_logger.py`):\n\n```python\nimport json\nimport logging\nfrom datetime import datetime, timezone\nfrom typing import Any, Dict, Optional\nfrom enum import Enum\n\nclass AuditEventType(Enum):\n    SUBSCRIPTION_CREATED = \"subscription_created\"\n    SUBSCRIPTION_UPDATED = \"subscription_updated\"\n    PLAN_CHANGED = \"plan_changed\"\n    PAYMENT_PROCESSED = \"payment_processed\"\n    USAGE_RECORDED = \"usage_recorded\"\n    INVOICE_GENERATED = \"invoice_generated\"\n\nclass AuditLogger:\n    \"\"\"\n    Immutable audit trail for all billing operations.\n    Required for compliance and debugging billing issues.\n    \"\"\"\n    \n    def __init__(self, database_manager):\n        self.db = database_manager\n        self.logger = logging.getLogger(f\"{__name__}.audit\")\n    \n    def log_event(\n        self,\n        event_type: AuditEventType,\n        entity_id: str,\n        entity_type: str,\n        changes: Optional[Dict[str, Any]] = None,\n        actor_id: Optional[str] = None,\n        metadata: Optional[Dict[str, Any]] = None\n    ):\n        \"\"\"\n        Log a billing operation event with complete context.\n        All events are immutable and permanently stored.\n        \"\"\"\n        event_data = {\n            'event_id': self._generate_event_id(),\n            'timestamp': datetime.now(timezone.utc).isoformat(),\n            'event_type': event_type.value,\n            'entity_id': entity_id,\n            'entity_type': entity_type,\n            'actor_id': actor_id,\n            'changes': changes or {},\n            'metadata': metadata or {}\n        }\n        \n        # Log to application logs for immediate visibility\n        self.logger.info(f\"Audit Event: {event_type.value}\", extra=event_data)\n        \n        # Store in database for permanent audit trail\n        self._store_audit_event(event_data)\n    \n    def _generate_event_id(self) -> str:\n        \"\"\"Generate unique event identifier.\"\"\"\n        import uuid\n        return str(uuid.uuid4())\n    \n    def _store_audit_event(self, event_data: Dict[str, Any]):\n        \"\"\"Store audit event in database audit table.\"\"\"\n        query = \"\"\"\n        INSERT INTO audit_events (\n            event_id, timestamp, event_type, entity_id, entity_type,\n            actor_id, changes, metadata\n        ) VALUES (\n            %(event_id)s, %(timestamp)s, %(event_type)s, %(entity_id)s,\n            %(entity_type)s, %(actor_id)s, %(changes)s, %(metadata)s\n        )\n        \"\"\"\n        \n        # Convert dictionaries to JSON strings for storage\n        params = event_data.copy()\n        params['changes'] = json.dumps(params['changes'])\n        params['metadata'] = json.dumps(params['metadata'])\n        \n        try:\n            with self.db.transaction() as conn:\n                cursor = conn.cursor()\n                cursor.execute(query, params)\n        except Exception as e:\n            # Audit logging failure should not break business operations\n            self.logger.error(f\"Failed to store audit event: {e}\")\n\n# Global audit logger instance\naudit_logger = AuditLogger(db)\n```\n\n#### Core System Configuration\n\n**Application Settings** (`config/settings.py`):\n\n```python\nfrom decimal import Decimal\nfrom typing import Dict, Any\nimport os\n\nclass BillingSettings:\n    \"\"\"Central configuration for billing system behavior.\"\"\"\n    \n    # Database configuration\n    DATABASE_URL = os.getenv('DATABASE_URL', 'postgresql://billing:password@localhost/billing_db')\n    \n    # Payment gateway integration\n    PAYMENT_GATEWAY_URL = os.getenv('PAYMENT_GATEWAY_URL', 'http://localhost:8001')\n    PAYMENT_GATEWAY_API_KEY = os.getenv('PAYMENT_GATEWAY_API_KEY')\n    \n    # Billing cycle configuration\n    DEFAULT_BILLING_ANCHOR = 1  # Day of month for monthly billing\n    BILLING_GRACE_PERIOD_DAYS = 3\n    MAX_PAYMENT_RETRIES = 3\n    PAYMENT_RETRY_DELAYS = [1, 3, 7]  # Days between retry attempts\n    \n    # Currency and precision settings\n    DEFAULT_CURRENCY = 'USD'\n    SUPPORTED_CURRENCIES = ['USD', 'EUR', 'GBP']\n    DECIMAL_PRECISION = Decimal('0.01')  # Cent precision\n    \n    # Usage billing configuration\n    USAGE_AGGREGATION_WINDOW = 3600  # Seconds (1 hour)\n    MAX_USAGE_EVENTS_PER_REQUEST = 1000\n    USAGE_IDEMPOTENCY_WINDOW_HOURS = 24\n    \n    # Trial and subscription defaults\n    DEFAULT_TRIAL_DAYS = 14\n    SUBSCRIPTION_REACTIVATION_GRACE_DAYS = 30\n    \n    # System limits\n    MAX_PLAN_FEATURES = 50\n    MAX_PRICING_TIERS = 10\n    \n    # Webhook configuration\n    WEBHOOK_TIMEOUT_SECONDS = 30\n    WEBHOOK_RETRY_ATTEMPTS = 5\n    \n    @classmethod\n    def get_currency_config(cls, currency_code: str) -> Dict[str, Any]:\n        \"\"\"Get configuration for specific currency.\"\"\"\n        currency_configs = {\n            'USD': {'symbol': '$', 'decimal_places': 2},\n            'EUR': {'symbol': '€', 'decimal_places': 2},\n            'GBP': {'symbol': '£', 'decimal_places': 2},\n        }\n        return currency_configs.get(currency_code, currency_configs['USD'])\n\nsettings = BillingSettings()\n```\n\n#### Development and Testing Setup\n\n**Docker Compose for Local Development** (`docker-compose.yml`):\n\n```yaml\nversion: '3.8'\n\nservices:\n  postgres:\n    image: postgres:15\n    environment:\n      POSTGRES_DB: billing_db\n      POSTGRES_USER: billing\n      POSTGRES_PASSWORD: password\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - billing_postgres_data:/var/lib/postgresql/data\n      - ./scripts/init_db.sql:/docker-entrypoint-initdb.d/init_db.sql\n\n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n\n  billing_api:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      DATABASE_URL: postgresql://billing:password@postgres:5432/billing_db\n      REDIS_URL: redis://redis:6379\n    depends_on:\n      - postgres\n      - redis\n    volumes:\n      - .:/app\n    command: python -m uvicorn src.billing.api.main:app --host 0.0.0.0 --reload\n\nvolumes:\n  billing_postgres_data:\n```\n\n#### Key Development Patterns\n\n**Error Handling Strategy**: The billing system implements a **fail-fast with detailed context** approach. Financial operations either complete successfully with full audit trails or fail immediately with sufficient information for debugging and customer communication.\n\n**Testing Philosophy**: Every financial calculation includes property-based tests that verify mathematical properties (e.g., `upgrade_charge + downgrade_credit = 0` for immediate plan switches). Unit tests cover edge cases while integration tests validate complete billing workflows.\n\n**Monitoring and Alerting**: The system logs all financial operations at INFO level with structured data, enabling real-time monitoring of billing accuracy and performance. Critical financial discrepancies trigger immediate alerts.\n\n> **Development Checkpoint**: After setting up this infrastructure, you should be able to start the application with `docker-compose up` and see a healthy PostgreSQL connection with proper decimal handling. Test the Money class with various currency calculations to verify precision handling works correctly.\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** Foundation for all milestones - establishes scope and requirements for the subscription billing system\n\n### Mental Model: Building a Financial Operating System\n\nThink of the subscription billing system as a **financial operating system** for digital businesses. Just like how your computer's operating system manages resources, schedules tasks, and provides services to applications, our billing system manages financial resources, schedules recurring payments, and provides billing services to business applications.\n\nConsider Netflix's subscription model. When you sign up, the system must track your plan selection, manage your free trial period, automatically charge your payment method each month on your billing anniversary, handle plan upgrades when you switch from Basic to Premium, calculate prorated charges if you upgrade mid-month, track your viewing hours for potential usage-based features, generate invoices with proper tax calculations, retry failed payments with smart dunning logic, and gracefully handle cancellations while maintaining data integrity. This complexity multiplied across millions of subscribers requires a robust, reliable financial operating system.\n\nThe key insight is that subscription billing is not just about charging credit cards monthly. It's about managing complex financial relationships over time, handling state transitions reliably, maintaining audit trails for compliance, and ensuring every cent is accounted for with mathematical precision. Like an operating system, it must be reliable, performant, and extensible while hiding complexity from the applications that use it.\n\n### Functional Requirements\n\nThe subscription billing system must provide comprehensive lifecycle management capabilities that handle every aspect of the customer's financial journey from trial signup through cancellation and beyond.\n\n#### Core Subscription Management\n\nThe system must support flexible subscription creation with multiple plan tiers and pricing models. Every customer must be able to select from available plans, with the system automatically provisioning their subscription with the correct billing cycle, feature entitlements, and payment schedule. The platform must handle multiple billing intervals including monthly, quarterly, and annual cycles, with proper calendar handling for edge cases like month-end dates.\n\n| Capability | Description | Business Rules |\n|------------|-------------|----------------|\n| Plan Selection | Customer chooses from available subscription tiers | Must validate plan availability and currency support |\n| Trial Management | Free trial periods with automatic conversion | Trial length configurable per plan, requires payment method on file |\n| Billing Cycles | Multiple billing intervals (monthly, quarterly, annual) | Billing anchor date preserved across cycles, handle calendar edge cases |\n| Feature Provisioning | Grant access based on subscription tier | Real-time feature flag updates, immediate access changes |\n| Multi-Currency Support | Global customer base with local currencies | Support major currencies, handle exchange rate fluctuations |\n\n#### Plan and Pricing Flexibility\n\nThe system must accommodate diverse pricing strategies that businesses use to optimize revenue. This includes flat-rate subscriptions, per-seat pricing for team plans, tiered usage allowances, and volume-based discounts. Plan management must support versioning to protect existing customers while allowing businesses to evolve their pricing strategies.\n\n| Pricing Model | Implementation Requirements | Edge Cases |\n|---------------|----------------------------|------------|\n| Flat-Rate | Fixed monthly/annual fee | Handle currency precision, tax calculations |\n| Per-Seat | Base price plus per-user charges | Seat additions/removals mid-cycle, minimum seat requirements |\n| Tiered Usage | Included allowance plus overage rates | Usage tracking accuracy, billing period boundaries |\n| Volume Discounts | Price breaks at usage thresholds | Retroactive discounts vs progressive pricing |\n| Custom Contracts | Enterprise-specific pricing terms | Contract versioning, approval workflows |\n\n#### Subscription Lifecycle Transitions\n\nThe system must handle every possible subscription state change with proper validation, audit logging, and downstream effects. State transitions must be atomic to prevent inconsistent states, and all changes must trigger appropriate notifications and integrations.\n\n| State Transition | Trigger Conditions | Required Actions |\n|------------------|--------------------|--------------------|\n| Trial → Active | Trial period expires, valid payment method | Process first payment, activate features, send welcome email |\n| Active → Past Due | Payment failure | Disable features based on grace period policy, start dunning sequence |\n| Past Due → Active | Successful payment retry | Restore full access, clear past due status, update billing cycle |\n| Active → Cancelled | Customer or admin cancellation | Calculate final charges, schedule termination, retain data per policy |\n| Cancelled → Active | Reactivation within grace period | Restore subscription state, recalculate billing, reactivate features |\n\n#### Proration and Plan Changes\n\nMid-cycle plan changes require sophisticated proration calculations that account for time remaining in the billing period, feature usage to date, and credit management. The system must support both immediate and scheduled plan changes, with proper financial reconciliation in all cases.\n\n> **Critical Design Principle**: Proration calculations must be deterministic and auditable. The same inputs must always produce identical outputs, and every calculation step must be logged for customer service and compliance purposes.\n\n| Change Type | Calculation Method | Credit Handling |\n|-------------|-------------------|------------------|\n| Upgrade | Prorated charge for price difference | Immediate charge to payment method |\n| Downgrade | Credit for unused higher-tier value | Apply credit to customer balance for future invoices |\n| Quantity Increase | Prorated charge for additional seats/units | Immediate charge based on remaining billing period |\n| Quantity Decrease | Credit for removed seats/units | Credit application with configurable timing |\n\n#### Usage-Based Billing Integration\n\nFor products with consumption-based pricing, the system must accurately track usage events, aggregate them across billing periods, and convert usage into billable charges. Usage tracking must be idempotent to handle duplicate events, and aggregation must be mathematically precise to prevent revenue leakage or customer disputes.\n\nThe usage engine must support multiple aggregation methods including sum (total API calls), count (number of transactions), maximum (peak concurrent users), and last-value (storage at end of period). Each aggregation method serves different billing models and requires different handling of late-arriving data.\n\n| Usage Pattern | Aggregation Method | Billing Calculation |\n|---------------|-------------------|---------------------|\n| API Calls | Sum across billing period | Total calls × per-call rate + overage tiers |\n| Storage | Last value in period | GB-months × storage rate |\n| Concurrent Users | Maximum daily peak | Peak users × per-user rate |\n| Transactions | Count with deduplication | Transaction count × per-transaction fee |\n| Bandwidth | Sum with time weighting | Total GB × bandwidth rate + burst charges |\n\n### Non-Functional Requirements\n\nThe billing system operates in a high-stakes environment where errors directly impact revenue and customer trust. Non-functional requirements are not optional nice-to-haves but essential characteristics that determine system success.\n\n#### Financial Precision and Data Integrity\n\nAll monetary calculations must maintain cent-level precision throughout the system lifecycle. The system must use the `Money` value object with fixed-point arithmetic to eliminate floating-point precision errors that could accumulate into significant revenue discrepancies over millions of transactions.\n\n| Precision Requirement | Implementation Standard | Validation Method |\n|----------------------|------------------------|-------------------|\n| Currency Calculations | Store all amounts in smallest currency unit (cents) | Automated reconciliation against payment processor |\n| Proration Math | Use `DECIMAL_PRECISION` constant for rounding | Unit tests with known edge cases, property-based testing |\n| Tax Calculations | Round per jurisdiction rules | Integration tests with tax service providers |\n| Exchange Rates | Daily rate updates with historical tracking | Compare against multiple rate sources |\n| Audit Trail | Every calculation step logged | End-to-end audit reports match transaction details |\n\n#### Performance and Scalability Targets\n\nThe system must handle enterprise-scale workloads with predictable performance characteristics. Billing operations have natural batch processing windows (monthly cycles) but also require real-time responsiveness for customer-facing operations like plan changes and usage queries.\n\n| Operation Type | Performance Target | Scalability Requirement |\n|----------------|-------------------|------------------------|\n| Plan Changes | < 2 seconds end-to-end | Handle 1000 concurrent plan changes |\n| Usage Event Ingestion | < 100ms per event, 10K events/second | Linear scaling with processing nodes |\n| Monthly Billing Run | Process 100K subscriptions in 4 hours | Parallel processing with progress tracking |\n| Invoice Generation | < 5 seconds per invoice | Support 1M+ invoices per billing cycle |\n| Payment Processing | < 10 seconds including gateway roundtrip | Graceful degradation during gateway issues |\n\n#### Reliability and Fault Tolerance\n\nBilling system failures can result in lost revenue, duplicate charges, or compliance violations. The system must be designed for high availability with comprehensive error recovery and graceful degradation capabilities.\n\n> **Reliability Principle**: Every billing operation must be either fully completed or safely rolled back. Partial states that could result in financial discrepancies are unacceptable.\n\n| Failure Scenario | Detection Method | Recovery Strategy |\n|------------------|------------------|-------------------|\n| Database Connection Loss | Health checks every 30 seconds | Automatic failover to read replica, queue writes |\n| Payment Gateway Timeout | Request timeout after 30 seconds | Retry with exponential backoff, manual reconciliation queue |\n| Proration Calculation Error | Input validation and range checks | Fallback to manual approval workflow |\n| Usage Data Corruption | Checksum validation on aggregation | Rebuild from raw events, alert operations team |\n| Billing Cycle Processing Failure | Progress tracking and heartbeat monitoring | Resume from last checkpoint, skip completed records |\n\n#### Security and Compliance Standards\n\nThe billing system handles sensitive financial data and must meet stringent security requirements including PCI DSS Level 1 compliance for payment card data handling. All financial operations must maintain comprehensive audit trails for regulatory compliance and customer dispute resolution.\n\n| Security Domain | Requirement | Implementation |\n|-----------------|-------------|----------------|\n| Data Encryption | All PII and financial data encrypted at rest and in transit | AES-256 encryption, TLS 1.3 for transport |\n| Access Control | Role-based permissions with principle of least privilege | Integration with identity provider, session management |\n| Audit Logging | Every billing operation logged with actor identification | Immutable audit log, tamper detection |\n| PCI Compliance | Never store payment card data in billing database | Token-based payment references, annual compliance audit |\n| Data Retention | Customer data retention per privacy regulations | Automated data lifecycle management, right to deletion |\n\n### Explicit Non-Goals\n\nClearly defining what the subscription billing system will **not** handle is crucial for maintaining focus and preventing scope creep. These exclusions represent deliberate architectural decisions that keep the system focused on its core competencies.\n\n#### Payment Processing Infrastructure\n\nThe billing system will **not** implement direct payment processing capabilities such as credit card authorization, fraud detection, or PCI-compliant card data storage. These capabilities are provided by the prerequisite payment gateway system, which handles all sensitive payment operations and compliance requirements.\n\n| Excluded Capability | Rationale | Alternative Approach |\n|---------------------|-----------|---------------------|\n| Credit Card Processing | Requires PCI Level 1 compliance infrastructure | Integrate with existing payment gateway |\n| Fraud Detection | Specialized domain requiring ML models and risk databases | Use payment processor's fraud services |\n| Payment Method Storage | Complex PCI compliance and security requirements | Store tokenized references only |\n| Chargeback Management | Requires specialized dispute handling processes | Payment gateway handles disputes |\n| Bank Account Verification | Complex regulatory requirements vary by jurisdiction | Use payment processor's ACH services |\n\n#### Advanced Revenue Recognition\n\nThe system will not implement complex revenue recognition rules required for GAAP or IFRS financial reporting. While the system tracks subscription revenue and provides basic reporting, sophisticated revenue recognition with contract modifications, performance obligations, and accounting standard compliance is outside scope.\n\n> **Boundary Decision**: The billing system focuses on operational billing accuracy rather than accounting compliance. Financial reporting requirements should be handled by dedicated accounting systems that consume billing data.\n\n#### Complex Tax Calculation\n\nThe system will not implement comprehensive tax calculation engines for sales tax, VAT, or other jurisdiction-specific tax requirements. Basic tax rate application is supported, but complex tax scenarios such as tax nexus determination, exemption certificate management, and regulatory filing are handled by specialized tax services.\n\n| Tax Complexity | System Support | External Integration |\n|----------------|----------------|---------------------|\n| Simple Tax Rates | Apply configured rates per jurisdiction | Built-in capability |\n| Tax Nexus Rules | Not supported | Integrate with tax calculation service |\n| Exemption Certificates | Not supported | Use tax service certificate management |\n| Regulatory Filing | Not supported | Export data to tax compliance system |\n| Multi-jurisdictional Compliance | Not supported | Tax service handles compliance |\n\n#### Enterprise Contract Management\n\nThe system will not support complex enterprise contract features such as custom approval workflows, contract negotiation tracking, or sophisticated discount approval chains. While the system supports flexible pricing and custom plans, it assumes these configurations are managed through administrative interfaces rather than complex contract lifecycle management.\n\n#### Multi-Tenant Architecture\n\nThe initial system design assumes a single-tenant deployment model. While the data model and service architecture are designed to be tenant-aware for future extension, the system will not initially support multiple isolated customer organizations within a single deployment instance.\n\n#### Real-Time Analytics and Business Intelligence\n\nThe system will not include sophisticated analytics dashboards, revenue forecasting, or business intelligence capabilities. While basic subscription metrics and billing reports are provided, advanced analytics should be handled by dedicated business intelligence systems that consume billing data through APIs.\n\n| Analytics Type | System Capability | External Tool Required |\n|----------------|-------------------|------------------------|\n| Basic Subscription Metrics | Count active subscriptions, MRR calculation | Built-in reporting |\n| Customer Lifecycle Analysis | Not supported | Business intelligence platform |\n| Revenue Forecasting | Not supported | Analytics platform |\n| Cohort Analysis | Not supported | Data warehouse and BI tools |\n| Churn Prediction | Not supported | Machine learning platform |\n\n### Implementation Guidance\n\nThe subscription billing system requires careful technology selection to handle the demanding requirements of financial precision, high availability, and regulatory compliance.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|------------------|\n| Web Framework | Flask with SQLAlchemy | FastAPI with async database drivers |\n| Database | PostgreSQL with financial precision types | PostgreSQL with read replicas and connection pooling |\n| Message Queue | Redis with pub/sub | Apache Kafka for high-throughput event streaming |\n| Caching | Redis with TTL-based invalidation | Redis Cluster with consistent hashing |\n| API Documentation | OpenAPI/Swagger auto-generation | AsyncAPI for event-driven APIs |\n| Testing Framework | pytest with factory patterns | pytest with property-based testing (Hypothesis) |\n| Monitoring | Prometheus with custom business metrics | Datadog with financial reconciliation dashboards |\n\n#### Recommended Project Structure\n\n```\nsubscription-billing/\n├── src/\n│   ├── billing/\n│   │   ├── __init__.py\n│   │   ├── domain/                    ← Core business entities\n│   │   │   ├── entities/\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── money.py          ← Money value object\n│   │   │   │   ├── customer.py\n│   │   │   │   ├── plan.py\n│   │   │   │   └── subscription.py\n│   │   │   ├── services/             ← Business logic services\n│   │   │   │   ├── plan_manager.py\n│   │   │   │   ├── subscription_engine.py\n│   │   │   │   ├── proration_calculator.py\n│   │   │   │   └── usage_tracker.py\n│   │   │   └── repositories/         ← Data access abstractions\n│   │   ├── infrastructure/           ← External integrations\n│   │   │   ├── database/\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── models.py         ← SQLAlchemy models\n│   │   │   │   └── migrations/\n│   │   │   ├── payment_gateway/\n│   │   │   └── notifications/\n│   │   ├── api/                      ← HTTP API layer\n│   │   │   ├── __init__.py\n│   │   │   ├── routes/\n│   │   │   └── schemas/\n│   │   └── tasks/                    ← Background job processing\n│   │       ├── billing_cycle.py\n│   │       └── usage_aggregation.py\n├── tests/\n│   ├── unit/\n│   ├── integration/\n│   └── fixtures/\n├── migrations/                       ← Database schema evolution\n├── config/\n│   ├── development.py\n│   ├── production.py\n│   └── test.py\n├── requirements/\n│   ├── base.txt\n│   ├── development.txt\n│   └── production.txt\n└── docker/\n    ├── Dockerfile\n    └── docker-compose.yml\n```\n\n#### Core Infrastructure Components\n\n**Money Value Object Implementation:**\n\n```python\n# src/billing/domain/entities/money.py\nfrom decimal import Decimal, ROUND_HALF_UP\nfrom typing import Dict\nimport attr\n\n# Financial precision constant - always round to nearest cent\nDECIMAL_PRECISION = Decimal('0.01')\nDEFAULT_CURRENCY = 'USD'\n\n# Supported currencies with metadata\nSUPPORTED_CURRENCIES = {\n    'USD': {'symbol': '$', 'decimal_places': 2, 'name': 'US Dollar'},\n    'EUR': {'symbol': '€', 'decimal_places': 2, 'name': 'Euro'},\n    'GBP': {'symbol': '£', 'decimal_places': 2, 'name': 'British Pound'},\n    'CAD': {'symbol': 'C$', 'decimal_places': 2, 'name': 'Canadian Dollar'},\n    'JPY': {'symbol': '¥', 'decimal_places': 0, 'name': 'Japanese Yen'},\n}\n\n@attr.s(frozen=True, auto_attribs=True)\nclass Money:\n    \"\"\"Immutable value object for financial amounts.\n    \n    Stores amounts as integer cents to avoid floating-point precision issues.\n    All arithmetic operations return new Money instances.\n    \"\"\"\n    amount_cents: int\n    currency_code: str = DEFAULT_CURRENCY\n    \n    def __attrs_post_init__(self):\n        if self.currency_code not in SUPPORTED_CURRENCIES:\n            raise ValueError(f\"Unsupported currency: {self.currency_code}\")\n        if not isinstance(self.amount_cents, int):\n            raise TypeError(\"Amount must be stored as integer cents\")\n    \n    @classmethod\n    def from_decimal(cls, amount: Decimal, currency: str = DEFAULT_CURRENCY) -> 'Money':\n        \"\"\"Create Money from decimal amount, converting to cents.\"\"\"\n        # TODO: Round to appropriate precision for currency\n        # TODO: Convert to integer cents (multiply by 100 for most currencies)\n        # TODO: Handle zero-decimal currencies like JPY\n        # TODO: Validate amount is not negative for billing purposes\n        pass\n    \n    def to_decimal(self) -> Decimal:\n        \"\"\"Convert to decimal representation for display and calculations.\"\"\"\n        # TODO: Divide cents by appropriate factor based on currency\n        # TODO: Return Decimal with proper precision\n        # TODO: Handle zero-decimal currencies\n        pass\n    \n    def add(self, other: 'Money') -> 'Money':\n        \"\"\"Add two Money amounts, must be same currency.\"\"\"\n        # TODO: Validate currencies match\n        # TODO: Add amounts in cents\n        # TODO: Return new Money instance\n        pass\n    \n    def subtract(self, other: 'Money') -> 'Money':\n        \"\"\"Subtract other from this amount.\"\"\"\n        # TODO: Validate currencies match\n        # TODO: Subtract in cents\n        # TODO: Allow negative results for credits/refunds\n        pass\n    \n    def multiply(self, factor: Decimal) -> 'Money':\n        \"\"\"Multiply amount by decimal factor, used for proration.\"\"\"\n        # TODO: Multiply cents by factor\n        # TODO: Round to nearest cent using ROUND_HALF_UP\n        # TODO: Return new Money instance\n        pass\n```\n\n**Database Transaction Management:**\n\n```python\n# src/billing/infrastructure/database/__init__.py\nfrom contextlib import contextmanager\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n# Serializable isolation for financial operations\nISOLATION_LEVEL_SERIALIZABLE = 'SERIALIZABLE'\n\nclass DatabaseManager:\n    \"\"\"Manages database connections and transactions for billing operations.\"\"\"\n    \n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n        self.engine = None\n        self.SessionFactory = None\n        # TODO: Initialize SQLAlchemy engine with connection pooling\n        # TODO: Configure session factory with appropriate defaults\n        # TODO: Set up connection health checking\n    \n    @contextmanager\n    def transaction(self, isolation_level: str = None):\n        \"\"\"Provide transactional context for billing operations.\n        \n        Args:\n            isolation_level: Database isolation level, defaults to READ_COMMITTED\n                           Use ISOLATION_LEVEL_SERIALIZABLE for financial operations\n        \"\"\"\n        session = self.SessionFactory()\n        if isolation_level:\n            session.connection(execution_options={\"isolation_level\": isolation_level})\n        \n        try:\n            # TODO: Begin transaction\n            # TODO: Yield session to calling code\n            # TODO: Commit transaction on success\n            # TODO: Log successful transaction for audit\n            pass\n        except Exception as e:\n            # TODO: Rollback transaction on any error\n            # TODO: Log rollback details for debugging\n            # TODO: Re-raise exception for handling by calling code\n            pass\n        finally:\n            # TODO: Always close session to return to pool\n            pass\n```\n\n**Audit Logging Infrastructure:**\n\n```python\n# src/billing/domain/services/audit_logger.py\nfrom enum import Enum\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\nimport json\n\nclass AuditEventType(Enum):\n    \"\"\"Categories for billing system audit events.\"\"\"\n    SUBSCRIPTION_CREATED = \"subscription_created\"\n    SUBSCRIPTION_CANCELLED = \"subscription_cancelled\"\n    PLAN_CHANGED = \"plan_changed\"\n    PAYMENT_PROCESSED = \"payment_processed\"\n    PRORATION_CALCULATED = \"proration_calculated\"\n    USAGE_RECORDED = \"usage_recorded\"\n    INVOICE_GENERATED = \"invoice_generated\"\n    \nclass AuditLogger:\n    \"\"\"Records immutable audit trail for all billing operations.\"\"\"\n    \n    def __init__(self, database_manager: DatabaseManager):\n        self.db = database_manager\n    \n    def log_event(\n        self,\n        event_type: AuditEventType,\n        entity_id: str,\n        entity_type: str,\n        changes: Dict[str, Any],\n        actor_id: str,\n        metadata: Optional[Dict[str, Any]] = None\n    ) -> None:\n        \"\"\"Record audit event for billing operation.\n        \n        Args:\n            event_type: Type of operation being audited\n            entity_id: ID of the entity being modified\n            entity_type: Type of entity (subscription, invoice, etc.)\n            changes: Before/after values for the operation\n            actor_id: ID of user or system performing the operation\n            metadata: Additional context for the operation\n        \"\"\"\n        # TODO: Create audit record with timestamp and unique ID\n        # TODO: Serialize changes and metadata to JSON\n        # TODO: Insert into audit_events table using serializable transaction\n        # TODO: Handle any insertion errors without affecting main operation\n        # TODO: Log audit record creation for debugging\n        pass\n```\n\n#### Configuration Management\n\n```python\n# src/billing/config.py\nfrom decimal import Decimal\nimport os\n\nclass BillingSettings:\n    \"\"\"Configuration settings for the billing system.\"\"\"\n    \n    # Financial precision settings\n    DECIMAL_PRECISION = Decimal('0.01')\n    DEFAULT_CURRENCY = 'USD'\n    \n    # Billing cycle settings\n    BILLING_GRACE_PERIOD_DAYS = 7\n    DUNNING_RETRY_ATTEMPTS = 3\n    PRORATION_ROUNDING_METHOD = 'ROUND_HALF_UP'\n    \n    # Performance settings\n    USAGE_BATCH_SIZE = 1000\n    BILLING_PROCESSING_CHUNK_SIZE = 500\n    \n    # Integration settings\n    PAYMENT_GATEWAY_TIMEOUT = 30\n    WEBHOOK_RETRY_ATTEMPTS = 5\n    \n    @classmethod\n    def from_environment(cls) -> 'BillingSettings':\n        \"\"\"Load settings from environment variables.\"\"\"\n        settings = cls()\n        # TODO: Override defaults with environment variables\n        # TODO: Validate required settings are present\n        # TODO: Type conversion and validation for numeric settings\n        # TODO: Return configured settings instance\n        return settings\n```\n\n#### Milestone Validation Checkpoints\n\n**Checkpoint 1 - Core Infrastructure:**\nRun `python -m pytest tests/unit/test_money.py -v` to verify the `Money` value object handles all currency operations correctly. Expected output should show all precision tests passing, including edge cases like currency conversion and proration calculations.\n\n**Checkpoint 2 - Database Setup:**\nExecute `python -m billing.infrastructure.database.setup_test_data` to create sample plans and subscriptions. Verify you can query the database and see properly formatted monetary values stored as integers.\n\n**Checkpoint 3 - Requirements Validation:**\nCreate a simple test subscription through the API and verify all functional requirements are testable:\n- Plan selection creates subscription with correct billing cycle\n- Trial period is properly configured and tracked\n- Payment method is tokenized and stored securely\n- Audit events are created for all operations\n\n#### Common Configuration Pitfalls\n\n⚠️ **Pitfall: Floating-Point Currency Storage**\nNever store monetary amounts as floating-point numbers in the database. Use integer cents or decimal types with fixed precision. Floating-point arithmetic can introduce rounding errors that compound over thousands of transactions.\n\n⚠️ **Pitfall: Insufficient Audit Logging**\nBilling systems require comprehensive audit trails for compliance and dispute resolution. Log every state change, calculation, and external API call with sufficient detail to reconstruct the operation later.\n\n⚠️ **Pitfall: Inadequate Error Handling**\nBilling operations must be atomic - either fully completed or fully rolled back. Partial states where money has been charged but subscription hasn't been activated can result in customer disputes and revenue recognition issues.\n\n⚠️ **Pitfall: Time Zone Confusion**\nAlways store timestamps in UTC and convert to customer's local timezone for display only. Billing cycles based on local times can create confusion when customers travel or daylight saving time changes occur.\n\n\n## High-Level Architecture\n\n> **Milestone(s):** Foundation for all milestones - provides the overall system structure that supports plan management, subscription lifecycle, proration, and usage-based billing\n\n### Component Overview\n\n#### Mental Model: The Financial Operations Center\n\nThink of the subscription billing system like a modern financial operations center at a major bank. Just as a bank has specialized departments—customer accounts, loan processing, transaction monitoring, payment clearing, and audit—our billing system divides complex financial operations into focused, specialized components that work together seamlessly.\n\nThe **Plan Management** component acts like the bank's product catalog department, defining what financial products (subscription plans) are available, their terms, and who can access them. The **Subscription Engine** functions like the account management department, tracking each customer's relationship with the bank, their account status, and lifecycle events. The **Usage Tracker** operates like the transaction monitoring system, recording every billable event in real-time. The **Invoice Generator** works like the billing department, calculating what each customer owes and producing formal billing statements. Finally, the **Payment Processor** acts like the payment clearing house, handling the actual movement of money.\n\nEach department has clear responsibilities and communicates through well-defined channels, but they're all orchestrated to create a seamless customer experience. When a customer upgrades their plan, multiple departments coordinate: product catalog validates the new plan, account management updates the relationship, billing calculates proration, and payment processing handles any immediate charges.\n\nThe subscription billing system follows this same pattern of specialized components with clear boundaries but coordinated workflows.\n\n#### Core System Components\n\n![System Component Architecture](./diagrams/system-architecture.svg)\n\nThe subscription billing system consists of six major components, each with distinct responsibilities and clear interfaces:\n\n**Plan Management Component**\n\nThe Plan Management component serves as the product catalog and pricing engine for the entire system. It maintains the canonical definition of all subscription plans, their pricing tiers, feature entitlements, and billing parameters. This component handles plan versioning to ensure existing customers retain their original terms while new customers receive updated plans. It validates plan configurations for consistency and provides the pricing logic used throughout the system.\n\n| Responsibility | Description | Data Owned |\n|---|---|---|\n| Plan Definition | Maintains subscription plans with pricing, features, and terms | Plan configurations, pricing tiers, feature matrices |\n| Pricing Logic | Calculates base charges for different plan types and billing intervals | Pricing formulas, currency conversions, discount rules |\n| Feature Entitlements | Maps plan tiers to accessible features and usage limits | Feature flags, quota definitions, access control lists |\n| Plan Versioning | Manages plan changes while protecting existing customer terms | Plan versions, deprecation schedules, grandfathering rules |\n\n**Subscription Engine**\n\nThe Subscription Engine manages the complete customer subscription lifecycle from creation through cancellation. It maintains the subscription state machine, processes lifecycle events like renewals and cancellations, and coordinates with other components during plan changes. This component serves as the system of record for all subscription relationships and their current status.\n\n| Responsibility | Description | Data Owned |\n|---|---|---|\n| Lifecycle Management | Handles subscription creation, renewal, cancellation, and reactivation | Subscription records, state transitions, lifecycle events |\n| State Machine | Enforces valid subscription state transitions and business rules | Current states, transition logs, business rule validations |\n| Billing Orchestration | Coordinates billing cycles and triggers invoice generation | Billing schedules, anniversary dates, renewal triggers |\n| Plan Changes | Processes upgrades and downgrades with effective date management | Change requests, effective dates, approval workflows |\n\n**Usage Tracker**\n\nThe Usage Tracker implements event-based metering for usage-based billing scenarios. It ingests usage events with idempotent processing, aggregates consumption data over billing periods, and calculates usage-based charges according to plan terms. This component ensures accurate usage measurement and prevents double-billing through robust deduplication.\n\n| Responsibility | Description | Data Owned |\n|---|---|---|\n| Event Ingestion | Accepts and validates usage events with idempotency protection | Usage events, deduplication keys, ingestion timestamps |\n| Usage Aggregation | Sums, counts, or calculates max usage over billing periods | Aggregated usage totals, billing period boundaries, calculation results |\n| Overage Calculation | Determines charges when usage exceeds plan allowances | Usage limits, overage rates, tiered pricing calculations |\n| Real-time Quotas | Tracks current usage against plan limits for quota enforcement | Current usage counters, quota thresholds, limit enforcement |\n\n**Proration Calculator**\n\nThe Proration Calculator handles all partial charge and credit calculations when subscriptions change mid-cycle. It implements precise financial calculations for time-based and quantity-based proration, manages customer credit balances, and ensures accurate billing during plan transitions. This component is critical for maintaining customer trust through transparent and accurate billing adjustments.\n\n| Responsibility | Description | Data Owned |\n|---|---|---|\n| Proration Logic | Calculates partial charges and credits for mid-cycle changes | Proration formulas, time calculations, rounding rules |\n| Credit Management | Tracks and applies customer credit balances | Credit balances, credit applications, expiration policies |\n| Change Processing | Handles immediate and scheduled plan changes with correct timing | Change schedules, effective dates, processing queues |\n| Financial Precision | Ensures accurate monetary calculations with proper rounding | Precision settings, rounding algorithms, audit trails |\n\n**Invoice Generator**\n\nThe Invoice Generator creates formal billing statements by combining subscription charges, usage fees, proration adjustments, and credit applications. It produces invoices in multiple formats, handles tax calculations, and maintains a complete audit trail of all billing activity. This component ensures compliance with accounting standards and provides customers with clear, detailed billing statements.\n\n| Responsibility | Description | Data Owned |\n|---|---|---|\n| Invoice Creation | Generates invoices from subscription charges, usage, and adjustments | Invoice templates, line items, tax calculations |\n| Line Item Assembly | Combines base charges, usage fees, proration, and credits into invoice lines | Charge breakdowns, itemized billing, descriptive labels |\n| Tax Calculation | Applies appropriate tax rates based on customer location and plan type | Tax rates, jurisdiction rules, exemption handling |\n| Audit Trail | Maintains complete financial audit trail for compliance | Invoice history, change logs, financial reconciliation data |\n\n**Payment Processor**\n\nThe Payment Processor integrates with the prerequisite payment gateway system to handle actual money movement. It processes recurring charges, manages payment methods, handles payment failures with retry logic, and processes webhooks from payment providers. This component abstracts payment complexity and provides consistent payment handling across the billing system.\n\n| Responsibility | Description | Data Owned |\n|---|---|---|\n| Payment Execution | Processes charges through payment gateways with retry logic | Payment attempts, transaction records, retry schedules |\n| Method Management | Handles customer payment methods and updates | Payment methods, expiration tracking, update notifications |\n| Webhook Processing | Processes payment gateway webhooks with idempotency | Webhook events, processing status, duplicate prevention |\n| Failure Handling | Manages payment failures with dunning and grace periods | Failure reasons, retry attempts, dunning workflows |\n\n#### Component Interaction Patterns\n\nThe components interact through well-defined interfaces using event-driven and synchronous communication patterns. Each component publishes domain events when significant state changes occur, allowing other components to react appropriately without tight coupling.\n\n**Event-Driven Communication**\n\nComponents publish events for major state changes that other components need to know about. This ensures loose coupling while maintaining system consistency. Events are processed asynchronously with at-least-once delivery guarantees.\n\n| Event Type | Publisher | Subscribers | Purpose |\n|---|---|---|---|\n| `SubscriptionCreated` | Subscription Engine | Usage Tracker, Invoice Generator | Initialize tracking and billing for new subscription |\n| `SubscriptionCancelled` | Subscription Engine | Usage Tracker, Payment Processor | Stop usage tracking and cancel recurring payments |\n| `PlanChanged` | Subscription Engine | Proration Calculator, Usage Tracker | Trigger proration and update usage limits |\n| `UsageReported` | Usage Tracker | Invoice Generator | Include usage charges in next billing cycle |\n| `PaymentFailed` | Payment Processor | Subscription Engine | Trigger dunning process and state changes |\n| `InvoiceGenerated` | Invoice Generator | Payment Processor | Trigger payment processing for new invoices |\n\n**Synchronous API Communication**\n\nFor operations requiring immediate consistency or validation, components communicate through synchronous APIs. These interactions are typically read-only queries or validation requests that need immediate responses.\n\n| API Call | Caller | Provider | Purpose |\n|---|---|---|---|\n| `ValidatePlanChange` | Subscription Engine | Plan Management | Validate plan upgrade/downgrade before processing |\n| `CalculateProration` | Subscription Engine | Proration Calculator | Get proration amounts for plan changes |\n| `GetUsageTotal` | Invoice Generator | Usage Tracker | Retrieve usage charges for invoice generation |\n| `GetCreditBalance` | Invoice Generator | Proration Calculator | Include customer credits in invoice |\n| `ProcessPayment` | Invoice Generator | Payment Processor | Execute payment for new invoice |\n\n### Integration Patterns\n\n#### Mental Model: The Banking Network\n\nThink of how banks integrate with each other and external financial systems. Your local bank doesn't operate in isolation—it connects to credit card networks, clearing houses, federal reserve systems, and other banks through standardized protocols and interfaces. Each connection has specific purposes, security requirements, and failure handling procedures.\n\nSimilarly, our subscription billing system must integrate with external payment providers, tax calculation services, customer management systems, and business intelligence tools. Each integration requires careful design of interfaces, error handling, and data consistency guarantees.\n\nJust as banks use different communication methods for different purposes—real-time wire transfers use secure direct connections while batch processing uses file transfers—our billing system uses different integration patterns based on the requirements of each external system.\n\n#### Payment Gateway Integration\n\nThe subscription billing system integrates with the prerequisite payment gateway system through both API calls and webhook processing. This integration handles the actual movement of money while the billing system focuses on subscription logic and financial calculations.\n\n> **Decision: Payment Gateway Integration Architecture**\n> - **Context**: The billing system needs to process payments but should not handle sensitive payment data directly due to PCI compliance requirements\n> - **Options Considered**: \n>   1. Direct payment processing with PCI compliance\n>   2. Integration with existing payment gateway\n>   3. Third-party billing service integration\n> - **Decision**: Integrate with the prerequisite payment gateway system\n> - **Rationale**: Leverages existing payment infrastructure, maintains PCI compliance, and focuses billing system on subscription-specific logic rather than payment processing\n> - **Consequences**: Enables faster development and better security but creates dependency on payment gateway availability and capabilities\n\n**API Integration Pattern**\n\nThe Payment Processor component communicates with the payment gateway through RESTful APIs for payment method management, charge processing, and customer management. All API calls include idempotency keys to prevent duplicate processing during retries.\n\n| Operation | Method | Purpose | Idempotency |\n|---|---|---|---|\n| Create Customer | POST /customers | Create gateway customer record | Customer ID as idempotency key |\n| Add Payment Method | POST /customers/{id}/payment-methods | Attach payment method to customer | Method fingerprint as key |\n| Process Charge | POST /charges | Execute one-time or recurring payment | Internal transaction ID as key |\n| Refund Payment | POST /refunds | Process refunds for plan downgrades | Refund request ID as key |\n\n**Webhook Integration Pattern**\n\nThe payment gateway sends webhooks for asynchronous events like payment success, failure, and disputes. The billing system processes these webhooks with careful attention to idempotency, ordering, and failure handling.\n\n```\nPayment Gateway → Webhook Endpoint → Event Queue → Payment Processor → Subscription Engine\n```\n\nThe webhook processing follows a reliable pattern:\n\n1. **Immediate Acknowledgment**: Webhook endpoint immediately returns 200 OK after basic validation\n2. **Event Queuing**: Valid webhooks are queued for asynchronous processing\n3. **Idempotent Processing**: Each webhook event is processed exactly once using event IDs\n4. **State Reconciliation**: Processing updates subscription states based on payment outcomes\n5. **Retry Logic**: Failed webhook processing retries with exponential backoff\n\n#### Customer Management Integration\n\nThe billing system integrates with existing customer management systems to maintain consistent customer data and avoid duplicating customer information. This integration typically follows an event-driven pattern where customer changes trigger updates in the billing system.\n\n**Customer Data Synchronization**\n\n| Integration Type | Direction | Data Synchronized | Trigger |\n|---|---|---|---|\n| Customer Creation | CRM → Billing | Customer ID, contact info, billing address | New customer signup |\n| Profile Updates | CRM → Billing | Address changes, contact updates | Customer profile modification |\n| Subscription Events | Billing → CRM | Subscription status, plan changes | Billing lifecycle events |\n| Usage Analytics | Billing → CRM | Usage patterns, billing history | Reporting and analytics needs |\n\n#### Tax Calculation Integration\n\nFor businesses operating in multiple jurisdictions, the billing system integrates with tax calculation services to ensure compliance with local tax regulations. This integration is particularly important for usage-based billing where tax calculations may be complex.\n\n**Tax Service Integration Pattern**\n\nThe Invoice Generator component calls tax calculation services during invoice generation to determine appropriate tax amounts based on customer location, product type, and billing amounts.\n\n| Tax Scenario | Integration Point | Data Sent | Data Received |\n|---|---|---|---|\n| Subscription Charges | Invoice generation | Customer address, plan type, charge amount | Tax rate, tax amount, tax jurisdiction |\n| Usage Charges | Usage billing | Usage type, consumption amount, customer location | Applicable tax rates and amounts |\n| Proration Adjustments | Plan changes | Original charge, prorated amount, effective dates | Adjusted tax calculations |\n| Refunds | Cancellations | Original tax amount, refund reason, jurisdiction | Tax refund amount and handling |\n\n#### Business Intelligence Integration\n\nThe billing system provides data to business intelligence and analytics platforms through both real-time events and batch data exports. This enables revenue reporting, customer analytics, and business performance monitoring.\n\n**Analytics Data Flow**\n\n| Data Type | Export Method | Frequency | Contents |\n|---|---|---|---|\n| Revenue Events | Real-time streaming | Immediate | Invoice generation, payment success, refunds |\n| Usage Metrics | Batch export | Daily | Aggregated usage by customer, plan, and feature |\n| Subscription Analytics | Batch export | Daily | Churn analysis, upgrade/downgrade patterns, lifecycle metrics |\n| Financial Reconciliation | Batch export | Monthly | Complete financial audit trail for accounting |\n\n#### External Service Error Handling\n\nAll external integrations implement robust error handling and fallback strategies to ensure billing operations continue even when external services are unavailable.\n\n> **Critical Design Principle**: External service failures should degrade functionality gracefully rather than preventing core billing operations\n\n**Error Handling Strategy**\n\n| Service | Error Type | Immediate Action | Fallback Strategy | Recovery Action |\n|---|---|---|---|---|\n| Payment Gateway | Network timeout | Retry with exponential backoff | Queue payment for later processing | Process when service recovers |\n| Tax Service | Service unavailable | Use cached tax rates | Apply default tax rate with adjustment flag | Recalculate when service returns |\n| Customer Service | Data sync failure | Log inconsistency | Continue with local customer data | Sync when connectivity restored |\n| Analytics | Export failure | Queue events locally | Continue billing operations | Replay events when service available |\n\n### Recommended Codebase Structure\n\n#### Mental Model: The Corporate Organizational Chart\n\nThink of a well-organized corporation with clear departments, reporting structures, and communication channels. The accounting department doesn't directly manage customer service, but they work together through defined processes. Similarly, our codebase structure reflects the business domain organization while maintaining clean separation of concerns.\n\nJust as a company has shared services (IT, legal, facilities) that support all departments, our codebase has common infrastructure (database, logging, configuration) that supports all business components. The directory structure should make it immediately clear which code handles which business responsibility, just like an organizational chart shows who handles which business function.\n\n#### Directory Structure Organization\n\nThe codebase follows a domain-driven design approach with clear separation between business logic, infrastructure concerns, and external interfaces. This structure supports both the current requirements and future scalability needs.\n\n```\nsubscription-billing-system/\n├── cmd/                           # Application entry points\n│   ├── billing-server/           # Main billing API server\n│   │   └── main.py\n│   ├── usage-ingestion/          # Usage event ingestion service\n│   │   └── main.py\n│   └── billing-scheduler/        # Batch billing operations\n│       └── main.py\n├── internal/                     # Internal business logic (not importable)\n│   ├── domain/                   # Core business entities and rules\n│   │   ├── customer/\n│   │   │   ├── __init__.py\n│   │   │   ├── models.py        # Customer entity and value objects\n│   │   │   └── repository.py    # Customer data access interface\n│   │   ├── plan/\n│   │   │   ├── __init__.py\n│   │   │   ├── models.py        # Plan entities and pricing logic\n│   │   │   ├── repository.py    # Plan data access interface\n│   │   │   └── service.py       # Plan management business logic\n│   │   ├── subscription/\n│   │   │   ├── __init__.py\n│   │   │   ├── models.py        # Subscription state machine and lifecycle\n│   │   │   ├── repository.py    # Subscription persistence interface\n│   │   │   └── service.py       # Subscription lifecycle management\n│   │   ├── usage/\n│   │   │   ├── __init__.py\n│   │   │   ├── models.py        # Usage events and aggregation\n│   │   │   ├── repository.py    # Usage data storage interface\n│   │   │   └── service.py       # Usage tracking and aggregation logic\n│   │   ├── billing/\n│   │   │   ├── __init__.py\n│   │   │   ├── models.py        # Invoice and payment entities\n│   │   │   ├── proration.py     # Proration calculation logic\n│   │   │   ├── invoice.py       # Invoice generation service\n│   │   │   └── payment.py       # Payment processing coordination\n│   │   └── shared/\n│   │       ├── __init__.py\n│   │       ├── money.py         # Money value object and currency handling\n│   │       ├── events.py        # Domain event definitions\n│   │       └── errors.py        # Business exception definitions\n│   ├── infrastructure/           # External system integrations and technical concerns\n│   │   ├── database/\n│   │   │   ├── __init__.py\n│   │   │   ├── connection.py    # DatabaseManager and transaction handling\n│   │   │   ├── migrations/      # Database schema migrations\n│   │   │   └── repositories/    # Concrete repository implementations\n│   │   │       ├── customer_repository.py\n│   │   │       ├── plan_repository.py\n│   │   │       ├── subscription_repository.py\n│   │   │       ├── usage_repository.py\n│   │   │       └── billing_repository.py\n│   │   ├── payment_gateway/\n│   │   │   ├── __init__.py\n│   │   │   ├── client.py        # Payment gateway API client\n│   │   │   ├── webhook_handler.py # Webhook processing\n│   │   │   └── models.py        # Payment gateway data models\n│   │   ├── messaging/\n│   │   │   ├── __init__.py\n│   │   │   ├── event_bus.py     # Domain event publishing and subscription\n│   │   │   └── queue_manager.py # Message queue integration\n│   │   ├── external_services/\n│   │   │   ├── __init__.py\n│   │   │   ├── tax_service.py   # Tax calculation service integration\n│   │   │   └── analytics_service.py # Business intelligence integration\n│   │   └── monitoring/\n│   │       ├── __init__.py\n│   │       ├── audit_logger.py  # Audit trail implementation\n│   │       └── metrics.py       # Performance and business metrics\n│   └── api/                     # HTTP API layer\n│       ├── __init__.py\n│       ├── handlers/            # HTTP request handlers\n│       │   ├── plan_handlers.py\n│       │   ├── subscription_handlers.py\n│       │   ├── usage_handlers.py\n│       │   ├── billing_handlers.py\n│       │   └── webhook_handlers.py\n│       ├── middleware/          # HTTP middleware\n│       │   ├── authentication.py\n│       │   ├── rate_limiting.py\n│       │   └── error_handling.py\n│       └── serializers/         # Request/response serialization\n│           ├── plan_serializers.py\n│           ├── subscription_serializers.py\n│           └── billing_serializers.py\n├── config/                      # Configuration management\n│   ├── __init__.py\n│   ├── settings.py             # BillingSettings and configuration loading\n│   ├── database.py             # Database configuration\n│   └── environments/           # Environment-specific configurations\n│       ├── development.py\n│       ├── staging.py\n│       └── production.py\n├── tests/                      # Test suites\n│   ├── unit/                   # Unit tests for business logic\n│   │   ├── domain/\n│   │   └── infrastructure/\n│   ├── integration/            # Integration tests\n│   │   ├── database/\n│   │   ├── payment_gateway/\n│   │   └── api/\n│   ├── end_to_end/            # Full workflow tests\n│   │   ├── subscription_lifecycle/\n│   │   ├── billing_cycles/\n│   │   └── plan_changes/\n│   └── fixtures/              # Test data and mocks\n│       ├── customers.py\n│       ├── plans.py\n│       └── usage_events.py\n├── scripts/                   # Operational and development scripts\n│   ├── migrate_database.py   # Database migration runner\n│   ├── seed_test_data.py     # Development data seeding\n│   └── billing_reconciliation.py # Financial reconciliation utilities\n├── docs/                     # Documentation\n│   ├── api/                  # API documentation\n│   ├── deployment/          # Deployment guides\n│   └── troubleshooting/     # Operational guides\n├── requirements.txt         # Python dependencies\n├── setup.py                # Package configuration\n└── README.md               # Project overview and setup\n```\n\n#### Architecture Layer Responsibilities\n\nThe codebase structure enforces clear architectural boundaries and dependencies through its organization:\n\n**Domain Layer (`internal/domain/`)**\n\nThe domain layer contains pure business logic with no external dependencies. This layer defines the core business entities, their behavior, and the rules that govern the subscription billing domain. It should be possible to test this layer without any external systems.\n\n| Directory | Responsibility | Dependencies | Key Artifacts |\n|---|---|---|---|\n| `customer/` | Customer entity and customer-related business rules | None (pure business logic) | Customer model, validation rules |\n| `plan/` | Plan definitions, pricing logic, feature entitlements | Domain shared types only | Plan hierarchy, pricing calculators |\n| `subscription/` | Subscription lifecycle, state machine, business rules | Customer and Plan domains | State machine, lifecycle events |\n| `usage/` | Usage tracking, aggregation, quota enforcement | Subscription domain | Usage events, aggregation rules |\n| `billing/` | Invoice generation, proration, payment coordination | All other domains | Proration algorithms, invoice logic |\n| `shared/` | Cross-domain value objects and domain events | None | `Money` type, domain events, exceptions |\n\n**Infrastructure Layer (`internal/infrastructure/`)**\n\nThe infrastructure layer handles all external system concerns including databases, payment gateways, message queues, and monitoring systems. This layer implements the interfaces defined in the domain layer and provides concrete implementations for external integrations.\n\n| Directory | Responsibility | Dependencies | Key Artifacts |\n|---|---|---|---|\n| `database/` | Data persistence, transaction management, migrations | Domain repository interfaces | `DatabaseManager`, concrete repositories |\n| `payment_gateway/` | Payment processing, webhook handling | Domain payment interfaces | Gateway client, webhook processor |\n| `messaging/` | Event publishing, message queuing | Domain events | Event bus, queue managers |\n| `external_services/` | Tax calculation, analytics, customer sync | Domain service interfaces | Service clients, data adapters |\n| `monitoring/` | Audit logging, metrics, observability | Domain events and entities | Audit logger, metrics collectors |\n\n**API Layer (`internal/api/`)**\n\nThe API layer provides HTTP interfaces for external clients and handles request/response serialization, authentication, and error handling. This layer coordinates between HTTP requests and domain services but contains no business logic itself.\n\n| Directory | Responsibility | Dependencies | Key Artifacts |\n|---|---|---|---|\n| `handlers/` | HTTP request processing, response formatting | Domain services | Request handlers, response builders |\n| `middleware/` | Cross-cutting HTTP concerns | Infrastructure services | Auth middleware, rate limiters |\n| `serializers/` | Request/response data transformation | Domain models | Data serializers, validators |\n\n#### Configuration and Deployment Structure\n\n**Configuration Management (`config/`)**\n\nThe configuration system supports multiple environments while maintaining security best practices for sensitive configuration data like database credentials and API keys.\n\n| File | Purpose | Content Type | Environment Sensitivity |\n|---|---|---|---|\n| `settings.py` | `BillingSettings` class and configuration loading logic | Python code | Non-sensitive defaults |\n| `database.py` | Database connection configuration | Python code | Environment-dependent |\n| `environments/development.py` | Development environment overrides | Python code | Development-specific settings |\n| `environments/staging.py` | Staging environment configuration | Python code | Staging-specific settings |\n| `environments/production.py` | Production environment configuration | Python code | Production settings (no secrets) |\n\n**Testing Strategy Organization (`tests/`)**\n\nThe testing structure mirrors the application architecture to ensure comprehensive coverage at all levels while maintaining test isolation and fast feedback loops.\n\n| Test Type | Directory | Purpose | Dependencies | Execution Speed |\n|---|---|---|---|---|\n| Unit Tests | `tests/unit/domain/` | Test business logic in isolation | None (mocked dependencies) | Fast (< 1s) |\n| Integration Tests | `tests/integration/` | Test component integration | Real databases, test services | Medium (1-10s) |\n| End-to-End Tests | `tests/end_to_end/` | Test complete workflows | Full system deployment | Slow (10s+) |\n| Test Fixtures | `tests/fixtures/` | Shared test data and mocks | Test utilities only | N/A |\n\n#### Development Workflow Support\n\n**Scripts and Utilities (`scripts/`)**\n\nThe scripts directory provides operational tools that developers and operators need for managing the billing system throughout its lifecycle.\n\n| Script | Purpose | Usage Context | Dependencies |\n|---|---|---|---|\n| `migrate_database.py` | Apply database schema migrations | Development, deployment | Database connection, migration files |\n| `seed_test_data.py` | Create realistic test data for development | Development, testing | Domain models, repositories |\n| `billing_reconciliation.py` | Verify billing accuracy and detect discrepancies | Operations, financial auditing | Full system access |\n\nThis codebase structure provides several key benefits for development teams:\n\n1. **Clear Separation of Concerns**: Business logic is isolated from infrastructure concerns, making the code easier to test and modify\n2. **Dependency Direction**: Dependencies flow from infrastructure toward domain, never the reverse, ensuring business logic remains independent\n3. **Test Strategy Alignment**: Test organization mirrors code organization, making it easy to find and write appropriate tests\n4. **Scalability Support**: Structure supports adding new components or splitting services without major reorganization\n5. **Operational Readiness**: Configuration and deployment structure supports multiple environments and operational needs\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\nThe following technology choices provide a solid foundation for implementing the subscription billing system while maintaining flexibility for future enhancements:\n\n| Component | Simple Option | Advanced Option | Rationale |\n|---|---|---|---|\n| Web Framework | **Flask** with Flask-RESTful | **FastAPI** with Pydantic | FastAPI provides automatic API documentation and better async support |\n| Database | **PostgreSQL** with SQLAlchemy | **PostgreSQL** with async SQLAlchemy | PostgreSQL offers strong consistency guarantees for financial data |\n| Message Queue | **Redis** with Python RQ | **RabbitMQ** with Celery | Redis provides simple setup; RabbitMQ offers better reliability guarantees |\n| Caching | **Redis** (same instance as queue) | **Redis Cluster** | Redis handles both caching and simple queuing needs |\n| HTTP Client | **requests** library | **httpx** with async support | httpx provides better async support for payment gateway integration |\n| Database Migrations | **Alembic** (SQLAlchemy migrations) | **Alembic** with custom migration scripts | Alembic integrates well with SQLAlchemy ORM |\n| Configuration | **Python-decouple** | **Pydantic Settings** | Pydantic provides type-safe configuration with validation |\n| Testing Framework | **pytest** with fixtures | **pytest** with factories and mocks | pytest offers excellent fixture support for complex test scenarios |\n| API Documentation | **Flask-RESTX** (automatic docs) | **FastAPI** (built-in OpenAPI) | Automatic API documentation reduces maintenance overhead |\n\n#### Core Infrastructure Setup\n\nHere's the foundational infrastructure code that supports all billing components. This code handles cross-cutting concerns like database transactions, audit logging, and financial precision:\n\n**Money Value Object (`internal/domain/shared/money.py`)**\n\n```python\nfrom decimal import Decimal, ROUND_HALF_UP\nfrom typing import Dict, Optional\nfrom dataclasses import dataclass\n\n# Financial precision configuration\nDECIMAL_PRECISION = Decimal('0.01')  # Cent precision for financial calculations\nDEFAULT_CURRENCY = 'USD'\n\n# Supported currencies with display information\nSUPPORTED_CURRENCIES = {\n    'USD': {'symbol': '$', 'decimal_places': 2, 'name': 'US Dollar'},\n    'EUR': {'symbol': '€', 'decimal_places': 2, 'name': 'Euro'},\n    'GBP': {'symbol': '£', 'decimal_places': 2, 'name': 'British Pound'},\n    'JPY': {'symbol': '¥', 'decimal_places': 0, 'name': 'Japanese Yen'},\n}\n\n@dataclass(frozen=True)\nclass Money:\n    \"\"\"\n    Immutable value object for financial amounts.\n    Stores amounts in smallest currency unit (cents) to avoid floating point errors.\n    \"\"\"\n    amount_cents: int\n    currency_code: str\n    \n    def __post_init__(self):\n        if self.currency_code not in SUPPORTED_CURRENCIES:\n            raise ValueError(f\"Unsupported currency: {self.currency_code}\")\n        if self.amount_cents < 0:\n            raise ValueError(\"Money amounts cannot be negative\")\n    \n    @classmethod\n    def from_decimal(cls, amount: Decimal, currency: str = DEFAULT_CURRENCY) -> 'Money':\n        \"\"\"Create Money from decimal amount (e.g., 10.50 -> Money(1050, 'USD'))\"\"\"\n        currency_info = SUPPORTED_CURRENCIES[currency]\n        if currency_info['decimal_places'] == 0:\n            # Currencies like JPY don't have decimal places\n            amount_cents = int(amount.quantize(Decimal('1'), rounding=ROUND_HALF_UP))\n        else:\n            # Most currencies use cents\n            multiplier = Decimal(10 ** currency_info['decimal_places'])\n            amount_cents = int((amount * multiplier).quantize(Decimal('1'), rounding=ROUND_HALF_UP))\n        \n        return cls(amount_cents=amount_cents, currency_code=currency)\n    \n    def to_decimal(self) -> Decimal:\n        \"\"\"Convert Money to decimal amount (e.g., Money(1050, 'USD') -> Decimal('10.50'))\"\"\"\n        currency_info = SUPPORTED_CURRENCIES[self.currency_code]\n        if currency_info['decimal_places'] == 0:\n            return Decimal(self.amount_cents)\n        else:\n            divisor = Decimal(10 ** currency_info['decimal_places'])\n            return Decimal(self.amount_cents) / divisor\n    \n    def __add__(self, other: 'Money') -> 'Money':\n        self._check_same_currency(other)\n        return Money(self.amount_cents + other.amount_cents, self.currency_code)\n    \n    def __sub__(self, other: 'Money') -> 'Money':\n        self._check_same_currency(other)\n        result_cents = self.amount_cents - other.amount_cents\n        if result_cents < 0:\n            raise ValueError(\"Cannot subtract to negative money amount\")\n        return Money(result_cents, self.currency_code)\n    \n    def _check_same_currency(self, other: 'Money'):\n        if self.currency_code != other.currency_code:\n            raise ValueError(f\"Cannot operate on different currencies: {self.currency_code} and {other.currency_code}\")\n```\n\n**Database Transaction Manager (`internal/infrastructure/database/connection.py`)**\n\n```python\nimport logging\nfrom contextlib import contextmanager\nfrom typing import Optional, Any\nfrom sqlalchemy import create_engine, text\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom sqlalchemy.engine import Engine\n\n# Database isolation levels for different operation types\nISOLATION_LEVEL_SERIALIZABLE = \"SERIALIZABLE\"\nISOLATION_LEVEL_READ_COMMITTED = \"READ_COMMITTED\"\n\nlogger = logging.getLogger(__name__)\n\nclass DatabaseManager:\n    \"\"\"\n    Manages database connections, transactions, and ensures proper isolation\n    for financial operations that require strong consistency.\n    \"\"\"\n    \n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n        self.engine: Engine = create_engine(\n            connection_string,\n            pool_pre_ping=True,  # Verify connections before use\n            pool_recycle=3600,   # Recycle connections every hour\n            echo=False           # Set to True for SQL debugging\n        )\n        self.SessionLocal = sessionmaker(bind=self.engine)\n    \n    @contextmanager\n    def transaction(self, isolation_level: str = ISOLATION_LEVEL_READ_COMMITTED):\n        \"\"\"\n        Provide database transaction with specified isolation level.\n        Use SERIALIZABLE for financial operations to prevent race conditions.\n        \"\"\"\n        session = self.SessionLocal()\n        try:\n            # Set transaction isolation level\n            session.execute(text(f\"SET TRANSACTION ISOLATION LEVEL {isolation_level}\"))\n            \n            yield session\n            session.commit()\n            logger.debug(f\"Transaction committed with isolation level {isolation_level}\")\n            \n        except Exception as e:\n            session.rollback()\n            logger.error(f\"Transaction rolled back due to error: {str(e)}\")\n            raise\n        finally:\n            session.close()\n    \n    def health_check(self) -> bool:\n        \"\"\"Check if database connection is healthy\"\"\"\n        try:\n            with self.transaction() as session:\n                session.execute(text(\"SELECT 1\"))\n                return True\n        except Exception as e:\n            logger.error(f\"Database health check failed: {str(e)}\")\n            return False\n```\n\n**Audit Event Logger (`internal/infrastructure/monitoring/audit_logger.py`)**\n\n```python\nimport json\nimport logging\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Dict, Any, Optional\nfrom dataclasses import dataclass, asdict\n\nlogger = logging.getLogger(__name__)\n\nclass AuditEventType(Enum):\n    \"\"\"Categories for different types of billing operations\"\"\"\n    SUBSCRIPTION_CREATED = \"subscription_created\"\n    SUBSCRIPTION_CHANGED = \"subscription_changed\"\n    SUBSCRIPTION_CANCELLED = \"subscription_cancelled\"\n    PLAN_CREATED = \"plan_created\"\n    PLAN_MODIFIED = \"plan_modified\"\n    INVOICE_GENERATED = \"invoice_generated\"\n    PAYMENT_PROCESSED = \"payment_processed\"\n    PAYMENT_FAILED = \"payment_failed\"\n    USAGE_REPORTED = \"usage_reported\"\n    PRORATION_CALCULATED = \"proration_calculated\"\n\n@dataclass\nclass AuditEvent:\n    \"\"\"Audit trail event for billing operations\"\"\"\n    event_type: AuditEventType\n    entity_id: str\n    entity_type: str\n    changes: Dict[str, Any]\n    actor_id: Optional[str]\n    timestamp: datetime\n    metadata: Dict[str, Any]\n\nclass AuditLogger:\n    \"\"\"\n    Records audit trail for all billing operations to ensure\n    compliance and enable financial reconciliation.\n    \"\"\"\n    \n    def __init__(self, database_manager):\n        self.database_manager = database_manager\n    \n    def log_event(\n        self, \n        event_type: AuditEventType, \n        entity_id: str, \n        entity_type: str, \n        changes: Dict[str, Any],\n        actor_id: Optional[str] = None,\n        metadata: Optional[Dict[str, Any]] = None\n    ):\n        \"\"\"\n        Record an audit event for billing operations.\n        This creates an immutable record of what changed, when, and who made the change.\n        \"\"\"\n        event = AuditEvent(\n            event_type=event_type,\n            entity_id=entity_id,\n            entity_type=entity_type,\n            changes=changes,\n            actor_id=actor_id,\n            timestamp=datetime.utcnow(),\n            metadata=metadata or {}\n        )\n        \n        try:\n            with self.database_manager.transaction() as session:\n                # Insert audit event into audit_events table\n                # Implementation would insert event data into database\n                logger.info(f\"Audit event recorded: {event_type.value} for {entity_type} {entity_id}\")\n                \n        except Exception as e:\n            logger.error(f\"Failed to record audit event: {str(e)}\")\n            # Audit failures should not break business operations\n            # but should be monitored and alerted on\n```\n\n**Configuration Management (`config/settings.py`)**\n\n```python\nimport os\nfrom typing import List, Dict, Any\nfrom dataclasses import dataclass\nfrom decimal import Decimal\n\n@dataclass\nclass BillingSettings:\n    \"\"\"\n    Central configuration for the billing system.\n    Supports environment-specific overrides while maintaining security.\n    \"\"\"\n    \n    # Database configuration\n    database_url: str\n    database_pool_size: int = 10\n    \n    # Payment gateway settings\n    payment_gateway_url: str\n    payment_gateway_api_key: str  # Should come from environment variables\n    payment_webhook_secret: str   # Should come from environment variables\n    \n    # Billing behavior configuration  \n    default_currency: str = \"USD\"\n    trial_period_days: int = 14\n    grace_period_days: int = 7\n    max_retry_attempts: int = 3\n    \n    # Usage tracking settings\n    usage_aggregation_batch_size: int = 1000\n    usage_retention_days: int = 365\n    \n    # Financial precision\n    rounding_precision: Decimal = Decimal('0.01')\n    \n    # External service timeouts\n    payment_gateway_timeout: int = 30  # seconds\n    tax_service_timeout: int = 10      # seconds\n    \n    @classmethod\n    def from_environment(cls) -> 'BillingSettings':\n        \"\"\"Load configuration from environment variables with validation\"\"\"\n        return cls(\n            database_url=os.getenv('DATABASE_URL', 'postgresql://localhost/billing'),\n            database_pool_size=int(os.getenv('DATABASE_POOL_SIZE', '10')),\n            payment_gateway_url=os.getenv('PAYMENT_GATEWAY_URL', 'https://api.stripe.com'),\n            payment_gateway_api_key=os.getenv('PAYMENT_GATEWAY_API_KEY', ''),\n            payment_webhook_secret=os.getenv('PAYMENT_WEBHOOK_SECRET', ''),\n            trial_period_days=int(os.getenv('TRIAL_PERIOD_DAYS', '14')),\n            grace_period_days=int(os.getenv('GRACE_PERIOD_DAYS', '7')),\n        )\n```\n\n#### Component Service Skeletons\n\nHere are the core service interfaces that implement the main billing components. These provide the structure for implementing each milestone:\n\n**Plan Management Service (`internal/domain/plan/service.py`)**\n\n```python\nfrom typing import List, Optional\nfrom .models import Plan, PlanVersion\nfrom .repository import PlanRepository\n\nclass PlanManagementService:\n    \"\"\"\n    Handles subscription plan creation, modification, and versioning.\n    Corresponds to Milestone 1: Plans & Pricing.\n    \"\"\"\n    \n    def __init__(self, plan_repository: PlanRepository, audit_logger):\n        self.plan_repository = plan_repository\n        self.audit_logger = audit_logger\n    \n    def create_plan(self, plan_data: dict) -> Plan:\n        \"\"\"\n        Create new subscription plan with pricing and feature configuration.\n        \n        TODO 1: Validate plan data structure and pricing configuration\n        TODO 2: Check for plan name uniqueness within organization\n        TODO 3: Create Plan entity with initial version\n        TODO 4: Validate pricing tiers and feature entitlements\n        TODO 5: Persist plan and log audit event\n        TODO 6: Return created plan with generated ID\n        \"\"\"\n        pass\n    \n    def modify_plan(self, plan_id: str, changes: dict) -> PlanVersion:\n        \"\"\"\n        Create new version of existing plan while preserving existing subscriptions.\n        \n        TODO 1: Load existing plan and validate modification permissions\n        TODO 2: Create new plan version with changes applied\n        TODO 3: Validate new version maintains backward compatibility\n        TODO 4: Archive old version and activate new version\n        TODO 5: Log plan modification audit event\n        TODO 6: Return new plan version\n        \"\"\"\n        pass\n    \n    def calculate_plan_price(self, plan_id: str, quantity: int = 1) -> 'Money':\n        \"\"\"\n        Calculate pricing for plan based on quantity and pricing model.\n        \n        TODO 1: Load plan pricing configuration\n        TODO 2: Determine pricing model (flat, per-seat, tiered, volume)\n        TODO 3: Apply quantity to pricing calculation\n        TODO 4: Handle tiered vs volume pricing correctly\n        TODO 5: Return Money object with calculated amount\n        \"\"\"\n        pass\n```\n\n**Subscription Lifecycle Service (`internal/domain/subscription/service.py`)**\n\n```python\nfrom typing import Optional\nfrom datetime import datetime\nfrom .models import Subscription, SubscriptionState\nfrom .repository import SubscriptionRepository\n\nclass SubscriptionLifecycleService:\n    \"\"\"\n    Manages complete subscription lifecycle from creation to cancellation.\n    Corresponds to Milestone 2: Subscription Lifecycle.\n    \"\"\"\n    \n    def __init__(self, subscription_repository: SubscriptionRepository, \n                 plan_service, audit_logger):\n        self.subscription_repository = subscription_repository\n        self.plan_service = plan_service\n        self.audit_logger = audit_logger\n    \n    def create_subscription(self, customer_id: str, plan_id: str, \n                          payment_method_id: str, trial_end: Optional[datetime] = None) -> Subscription:\n        \"\"\"\n        Create new subscription with trial or immediate activation.\n        \n        TODO 1: Validate customer exists and has valid payment method\n        TODO 2: Load and validate plan is available for new subscriptions\n        TODO 3: Calculate billing anchor date and first billing date\n        TODO 4: Create subscription entity with appropriate initial state\n        TODO 5: Set up trial period if specified or plan includes trial\n        TODO 6: Persist subscription and publish SubscriptionCreated event\n        TODO 7: Return created subscription with all details\n        \"\"\"\n        pass\n    \n    def process_renewal(self, subscription_id: str) -> bool:\n        \"\"\"\n        Process subscription renewal at end of billing period.\n        \n        TODO 1: Load subscription and verify it's due for renewal\n        TODO 2: Check subscription is in renewable state (active, past_due)\n        TODO 3: Generate invoice for upcoming billing period\n        TODO 4: Attempt payment processing through payment service\n        TODO 5: Update subscription state based on payment result\n        TODO 6: Schedule next renewal date if payment succeeded\n        TODO 7: Return success/failure status\n        \"\"\"\n        pass\n    \n    def cancel_subscription(self, subscription_id: str, \n                          cancel_at_period_end: bool = True, reason: str = None) -> Subscription:\n        \"\"\"\n        Cancel subscription immediately or at end of current billing period.\n        \n        TODO 1: Load subscription and validate it can be cancelled\n        TODO 2: Calculate effective cancellation date based on cancel_at_period_end\n        TODO 3: Update subscription state to cancelled or scheduled for cancellation\n        TODO 4: Process any refunds if cancelling mid-period\n        TODO 5: Clean up recurring payment schedules\n        TODO 6: Log cancellation audit event with reason\n        TODO 7: Return updated subscription\n        \"\"\"\n        pass\n```\n\n#### File Structure Implementation\n\nHere's how to organize the initial project structure with key files:\n\n**Project Initialization Script (`setup_project.py`)**\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nScript to initialize the subscription billing system project structure.\nRun this to create all necessary directories and placeholder files.\n\"\"\"\n\nimport os\nfrom pathlib import Path\n\ndef create_directory_structure():\n    \"\"\"Create the complete project directory structure\"\"\"\n    \n    directories = [\n        'cmd/billing-server',\n        'cmd/usage-ingestion', \n        'cmd/billing-scheduler',\n        'internal/domain/customer',\n        'internal/domain/plan',\n        'internal/domain/subscription',\n        'internal/domain/usage',\n        'internal/domain/billing',\n        'internal/domain/shared',\n        'internal/infrastructure/database',\n        'internal/infrastructure/database/repositories',\n        'internal/infrastructure/database/migrations',\n        'internal/infrastructure/payment_gateway',\n        'internal/infrastructure/messaging',\n        'internal/infrastructure/external_services',\n        'internal/infrastructure/monitoring',\n        'internal/api/handlers',\n        'internal/api/middleware',\n        'internal/api/serializers',\n        'config/environments',\n        'tests/unit/domain',\n        'tests/integration',\n        'tests/end_to_end',\n        'tests/fixtures',\n        'scripts',\n        'docs/api',\n        'docs/deployment',\n        'docs/troubleshooting'\n    ]\n    \n    for directory in directories:\n        Path(directory).mkdir(parents=True, exist_ok=True)\n        # Create __init__.py files for Python packages\n        if 'internal' in directory or 'config' in directory or 'tests' in directory:\n            (Path(directory) / '__init__.py').touch()\n    \n    print(\"✅ Project directory structure created successfully\")\n\nif __name__ == '__main__':\n    create_directory_structure()\n```\n\n#### Milestone Validation Checkpoints\n\nAfter implementing each component, use these checkpoints to verify functionality:\n\n**Milestone 1 Checkpoint: Plan Management**\n\n```bash\n# Test plan creation and pricing calculation\npython -m pytest tests/unit/domain/plan/ -v\npython -c \"\nfrom internal.domain.plan.service import PlanManagementService\n# Verify plan creation works with sample data\nprint('✅ Plan management component ready')\n\"\n```\n\n**Milestone 2 Checkpoint: Subscription Lifecycle**\n\n```bash\n# Test subscription state machine and lifecycle\npython -m pytest tests/unit/domain/subscription/ -v\npython -c \"\nfrom internal.domain.subscription.service import SubscriptionLifecycleService\n# Verify subscription creation and state transitions\nprint('✅ Subscription lifecycle component ready')\n\"\n```\n\n**Integration Checkpoint: Database and Payment Gateway**\n\n```bash\n# Test database connectivity and payment integration\npython -c \"\nfrom config.settings import BillingSettings\nfrom internal.infrastructure.database.connection import DatabaseManager\n\nsettings = BillingSettings.from_environment()\ndb = DatabaseManager(settings.database_url)\n\nif db.health_check():\n    print('✅ Database connection working')\nelse:\n    print('❌ Database connection failed')\n\"\n```\n\nThis implementation guidance provides the foundation for building the subscription billing system with proper separation of concerns, financial precision, and scalability. The structure supports both current requirements and future enhancements while maintaining clean architectural boundaries.\n\n\n## Data Model and Core Entities\n\n> **Milestone(s):** Foundation for all milestones - provides the data structures and relationships that support plan management (Milestone 1), subscription lifecycle (Milestone 2), proration calculations (Milestone 3), and usage-based billing (Milestone 4)\n\n### Mental Model: The Financial Ledger System\n\nThink of the subscription billing data model like a traditional accounting ledger system that a bank might use. Each customer is like an account holder with a unique account number. Subscription plans are like different types of banking products (checking accounts, savings accounts, credit cards) - each with specific terms, fees, and features. Active subscriptions are like opened accounts that generate recurring transactions. Invoices are like monthly statements that itemize all charges and payments. Usage events are like individual transaction records that get aggregated into summary line items on the statement.\n\nJust as a bank must maintain perfect accuracy in financial records and preserve complete audit trails, our billing system must ensure every monetary amount is precise to the cent, every state change is tracked, and every calculation can be verified. The data model serves as the foundation for financial integrity - any errors or inconsistencies at this level cascade into billing disputes, revenue leakage, and compliance violations.\n\nThe key insight is that subscription billing is fundamentally an event-sourced financial system. Every significant business event (subscription creation, plan changes, usage consumption, payments) generates immutable records that collectively define the current state. This approach ensures we can always reconstruct how we arrived at any billing amount and provides the auditability that financial systems require.\n\n### Core Business Entities\n\nThe subscription billing system is built around five core entities that represent the fundamental business concepts. Each entity captures specific aspects of the customer relationship and billing lifecycle, with carefully designed relationships that maintain referential integrity and support complex billing scenarios.\n\n![Core Entity Relationship Diagram](./diagrams/data-model-relationships.svg)\n\n#### Customer Entity\n\nThe `Customer` entity represents the billing account holder and serves as the root aggregate for all subscription-related activities. A customer can have multiple subscriptions but maintains unified billing settings and credit balances across all their services.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `customer_id` | UUID | Primary key, immutable unique identifier for the customer |\n| `external_id` | String | Optional external system identifier for integration purposes |\n| `email` | String | Primary email address for billing communications and account recovery |\n| `name` | String | Full name or company name for invoice display |\n| `billing_address` | JSON | Structured address object with street, city, state, postal_code, country |\n| `tax_id` | String | Tax identification number for tax calculation and compliance |\n| `currency` | String | Preferred currency code (ISO 4217) for all billing in this account |\n| `credit_balance_cents` | Integer | Current credit balance in smallest currency unit (cents) |\n| `payment_method_id` | UUID | Reference to default payment method in payment gateway |\n| `billing_email` | String | Optional separate email for billing notifications |\n| `account_status` | Enum | Current account status: active, suspended, closed |\n| `created_at` | Timestamp | Account creation date for analytics and lifecycle tracking |\n| `updated_at` | Timestamp | Last modification timestamp for change tracking |\n| `metadata` | JSON | Extensible field for custom attributes and integration data |\n\nThe customer entity includes a `credit_balance_cents` field that accumulates credits from downgrades, refunds, and promotional credits. This balance is automatically applied to future invoices, providing a seamless experience for customers receiving credits. The `billing_address` and `tax_id` fields support tax calculation requirements and compliance with regional billing regulations.\n\n#### Plan Entity\n\nThe `Plan` entity defines the pricing structure, billing terms, and feature entitlements for subscription offerings. Plans are versioned to ensure existing subscribers maintain their original terms while allowing the business to evolve pricing over time.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `plan_id` | UUID | Primary key, immutable unique identifier for this plan version |\n| `plan_code` | String | Human-readable identifier (e.g., \"pro-monthly-v2\") |\n| `name` | String | Display name for customer-facing interfaces |\n| `description` | String | Detailed description of plan features and benefits |\n| `status` | Enum | Plan status: active, deprecated, archived |\n| `billing_interval` | Enum | Recurring billing period: monthly, quarterly, annual |\n| `billing_interval_count` | Integer | Number of intervals between charges (e.g., 2 for bi-monthly) |\n| `pricing_model` | Enum | Pricing structure: flat_rate, per_seat, tiered, volume |\n| `base_price_cents` | Integer | Base recurring charge in smallest currency unit |\n| `currency` | String | Currency code (ISO 4217) for all pricing in this plan |\n| `trial_period_days` | Integer | Length of free trial period, null if no trial offered |\n| `setup_fee_cents` | Integer | One-time setup charge applied at subscription creation |\n| `features` | JSON | Array of feature flags and entitlements included in this plan |\n| `usage_limits` | JSON | Monthly usage quotas for metered features |\n| `pricing_tiers` | JSON | Tiered pricing structure for usage-based billing |\n| `created_at` | Timestamp | Plan creation date for lifecycle tracking |\n| `updated_at` | Timestamp | Last modification timestamp |\n| `deprecated_at` | Timestamp | Date when plan was deprecated (null if still active) |\n| `metadata` | JSON | Extensible field for custom plan attributes |\n\nThe `pricing_tiers` field supports complex usage-based billing scenarios. For example, an API plan might have tiers like: \"First 1,000 calls free, next 9,000 calls at $0.001 each, additional calls at $0.0005 each.\" The `features` field contains an array of feature flags that the entitlement system uses to control access to application functionality.\n\n> **Decision: Plan Versioning Strategy**\n> - **Context**: When businesses need to change pricing or features, they must decide whether to update existing plans or create new versions\n> - **Options Considered**: \n>   1. Update plans in-place (simple but breaks existing customer terms)\n>   2. Create new plan versions and deprecate old ones\n>   3. Full plan history with temporal validity periods\n> - **Decision**: Create new plan versions and deprecate old ones\n> - **Rationale**: Preserves existing customer terms (critical for trust), provides clear upgrade paths, and maintains audit trail while avoiding the complexity of temporal data management\n> - **Consequences**: Requires plan migration workflows and slightly more complex plan selection logic, but ensures customer contract integrity\n\n#### Subscription Entity\n\nThe `Subscription` entity represents an active customer enrollment in a specific plan. It tracks the subscription lifecycle, billing schedule, and current state while maintaining complete history of plan changes and modifications.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `subscription_id` | UUID | Primary key, immutable unique identifier |\n| `customer_id` | UUID | Foreign key reference to customer entity |\n| `plan_id` | UUID | Foreign key reference to current plan |\n| `status` | Enum | Current state: trial, active, past_due, cancelled, expired |\n| `billing_cycle_anchor` | Integer | Day of month for recurring billing (1-31) |\n| `current_period_start` | Date | Start date of current billing period |\n| `current_period_end` | Date | End date of current billing period |\n| `trial_start` | Date | Trial period start date (null if no trial) |\n| `trial_end` | Date | Trial period end date (null if no trial) |\n| `cancelled_at` | Timestamp | Cancellation request timestamp (null if not cancelled) |\n| `cancel_at_period_end` | Boolean | Whether cancellation takes effect at period end |\n| `ended_at` | Timestamp | Actual subscription termination timestamp |\n| `quantity` | Integer | Number of seats or units for per-seat pricing |\n| `proration_behavior` | Enum | How to handle mid-cycle changes: immediate, next_cycle |\n| `collection_method` | Enum | Payment timing: charge_automatically, send_invoice |\n| `days_until_due` | Integer | Payment terms for invoice-based collection |\n| `created_at` | Timestamp | Subscription creation timestamp |\n| `updated_at` | Timestamp | Last modification timestamp |\n| `metadata` | JSON | Custom attributes and integration data |\n\nThe `billing_cycle_anchor` field ensures consistent billing dates. For example, a subscription created on January 31st with a monthly billing interval will bill on the last day of each month (February 28th, March 31st, etc.) rather than causing month overflow issues. The `proration_behavior` setting controls whether plan changes take effect immediately with prorated charges or wait until the next billing cycle.\n\n#### Invoice Entity\n\nThe `Invoice` entity represents a billing statement that itemizes charges, credits, and payment details for a specific billing period. Invoices are immutable once finalized to ensure financial accuracy and audit compliance.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `invoice_id` | UUID | Primary key, immutable unique identifier |\n| `customer_id` | UUID | Foreign key reference to customer |\n| `subscription_id` | UUID | Primary subscription for this invoice (nullable for one-off charges) |\n| `invoice_number` | String | Sequential human-readable identifier (e.g., \"INV-2024-001234\") |\n| `status` | Enum | Invoice state: draft, open, paid, void, uncollectible |\n| `period_start` | Date | Billing period start date |\n| `period_end` | Date | Billing period end date |\n| `subtotal_cents` | Integer | Total charges before credits and taxes |\n| `credit_applied_cents` | Integer | Credits applied from customer balance |\n| `tax_cents` | Integer | Tax amount calculated based on customer location |\n| `total_cents` | Integer | Final amount due after credits and taxes |\n| `amount_paid_cents` | Integer | Amount actually collected |\n| `amount_remaining_cents` | Integer | Outstanding balance (total - paid) |\n| `currency` | String | Currency code for all amounts on this invoice |\n| `due_date` | Date | Payment due date for collection |\n| `paid_at` | Timestamp | Payment completion timestamp (null if unpaid) |\n| `voided_at` | Timestamp | Void timestamp (null if not voided) |\n| `payment_attempt_count` | Integer | Number of payment collection attempts |\n| `next_payment_attempt` | Timestamp | Scheduled retry timestamp for failed payments |\n| `created_at` | Timestamp | Invoice generation timestamp |\n| `finalized_at` | Timestamp | When invoice became immutable |\n| `metadata` | JSON | Additional invoice attributes |\n\nThe invoice tracks separate amounts for charges, credits, taxes, and payments to provide complete transparency in billing calculations. The `payment_attempt_count` and `next_payment_attempt` fields support dunning management by tracking retry attempts and scheduling future collection efforts.\n\n#### Invoice Line Item Entity\n\nInvoice line items provide detailed breakdown of charges and credits on each invoice. This granular structure supports complex billing scenarios including proration, usage charges, and plan changes.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `line_item_id` | UUID | Primary key, immutable unique identifier |\n| `invoice_id` | UUID | Foreign key reference to parent invoice |\n| `subscription_id` | UUID | Subscription generating this line item (nullable) |\n| `type` | Enum | Line item type: subscription, usage, proration_credit, setup_fee |\n| `description` | String | Human-readable description of the charge |\n| `period_start` | Date | Service period start date for this line item |\n| `period_end` | Date | Service period end date for this line item |\n| `quantity` | Decimal | Units being charged (e.g., seats, API calls) |\n| `unit_amount_cents` | Integer | Price per unit in smallest currency unit |\n| `amount_cents` | Integer | Total amount for this line item (quantity × unit_amount) |\n| `proration_factor` | Decimal | Percentage of billing period (e.g., 0.5 for half month) |\n| `plan_id` | UUID | Plan associated with this charge (nullable) |\n| `usage_summary` | JSON | Aggregated usage data for usage-based line items |\n| `created_at` | Timestamp | Line item creation timestamp |\n| `metadata` | JSON | Additional line item attributes |\n\nThe `proration_factor` field captures the exact percentage of a billing period that a charge covers, enabling precise proration calculations. For example, a mid-month upgrade from a $10 plan to a $20 plan with 15 days remaining would generate a proration credit line item with factor 0.5 (15/30 days) for -$5.\n\n#### Payment Entity\n\nThe `Payment` entity records payment attempts and their results, integrating with the external payment gateway while maintaining local records for reconciliation and reporting.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `payment_id` | UUID | Primary key, immutable unique identifier |\n| `customer_id` | UUID | Foreign key reference to customer |\n| `invoice_id` | UUID | Foreign key reference to invoice being paid |\n| `payment_intent_id` | String | External payment gateway transaction identifier |\n| `amount_cents` | Integer | Payment amount in smallest currency unit |\n| `currency` | String | Payment currency code |\n| `status` | Enum | Payment state: pending, succeeded, failed, cancelled, refunded |\n| `payment_method_type` | String | Payment method used (card, bank_transfer, etc.) |\n| `failure_code` | String | Error code from payment gateway (null if successful) |\n| `failure_message` | String | Human-readable failure description |\n| `gateway_response` | JSON | Complete response from payment processor |\n| `captured_at` | Timestamp | When payment was captured (null if pending) |\n| `refunded_at` | Timestamp | Refund timestamp (null if not refunded) |\n| `refunded_amount_cents` | Integer | Amount refunded (null if no refund) |\n| `created_at` | Timestamp | Payment attempt timestamp |\n| `metadata` | JSON | Additional payment attributes |\n\n### Entity Relationships and Constraints\n\nThe relationships between entities enforce business rules and maintain data integrity across the subscription lifecycle. These constraints prevent invalid states and ensure consistent billing behavior.\n\n#### Primary Relationships\n\nThe core entity relationships follow a hierarchical structure where customers own subscriptions, subscriptions generate invoices, and invoices are settled by payments. This design supports both simple single-subscription customers and complex enterprise accounts with multiple subscriptions and consolidated billing.\n\n| Relationship | Cardinality | Foreign Key | Constraint Description |\n|--------------|-------------|-------------|------------------------|\n| Customer → Subscription | One to Many | `subscription.customer_id` | Each customer can have multiple active subscriptions |\n| Plan → Subscription | One to Many | `subscription.plan_id` | Multiple subscriptions can use the same plan |\n| Customer → Invoice | One to Many | `invoice.customer_id` | All invoices belong to a specific customer |\n| Subscription → Invoice | One to Many | `invoice.subscription_id` | Subscriptions generate recurring invoices |\n| Invoice → Line Item | One to Many | `line_item.invoice_id` | Each invoice contains one or more line items |\n| Invoice → Payment | One to Many | `payment.invoice_id` | Invoices may require multiple payment attempts |\n\n> **Decision: Subscription-Invoice Relationship**\n> - **Context**: Some billing systems link invoices directly to billing periods, others to specific subscriptions\n> - **Options Considered**:\n>   1. Link invoices to subscriptions (enables subscription-specific billing)\n>   2. Link invoices to customers only (enables consolidated billing)\n>   3. Support both models with nullable subscription references\n> - **Decision**: Support both models with nullable subscription references\n> - **Rationale**: Provides flexibility for enterprise customers who need consolidated billing while maintaining subscription-specific invoices for simpler use cases\n> - **Consequences**: Requires conditional logic in billing workflows but supports both B2B and B2C billing patterns\n\n#### Business Rule Constraints\n\nThe subscription billing system enforces several critical business rules through database constraints and application logic. These rules prevent data corruption and ensure billing accuracy.\n\n| Constraint | Entity | Rule Description | Enforcement Method |\n|------------|--------|------------------|-------------------|\n| Currency Consistency | Customer, Plan, Subscription | All entities in a billing relationship must use the same currency | Application validation |\n| Billing Period Validity | Subscription | `current_period_end` must be after `current_period_start` | Database check constraint |\n| Trial Period Logic | Subscription | Trial end must be before or equal to first billing date | Application validation |\n| Invoice Immutability | Invoice | Finalized invoices cannot be modified | Application logic |\n| Payment Amount Validation | Payment | Payment amount cannot exceed invoice total | Application validation |\n| Status Transitions | Subscription, Invoice | Only valid state transitions are allowed | Application state machine |\n| Credit Balance Consistency | Customer | Credit balance cannot be negative after applying credits | Database check constraint |\n| Plan Version Integrity | Plan | Deprecated plans cannot be assigned to new subscriptions | Application validation |\n\nThe currency consistency constraint prevents billing errors that could occur when mixing currencies within a customer account. For example, a customer with USD billing cannot be assigned a plan priced in EUR without explicit currency conversion.\n\n#### Data Integrity Rules\n\nFinancial systems require additional integrity safeguards beyond standard relational constraints. These rules ensure monetary calculations are accurate and auditable.\n\n**Money Amount Precision**: All monetary amounts are stored as integers representing the smallest currency unit (cents for USD). This eliminates floating-point precision errors that could accumulate across many billing cycles. The system uses a `Money` type that encapsulates amount and currency to prevent mixing currencies in calculations.\n\n**Idempotent Operations**: Critical operations like invoice generation and payment processing must be idempotent to prevent duplicate charges. Each operation includes an idempotency key that prevents duplicate execution if requests are retried.\n\n**Audit Trail Requirements**: Every modification to subscription state, plan assignments, and billing amounts generates an audit event. This provides complete traceability for compliance and customer service purposes.\n\n**Referential Integrity**: Foreign key relationships are enforced at the database level where possible, with application-level validation for complex business rules. Cascade delete operations are restricted to prevent accidental data loss.\n\n### Usage Tracking Data Model\n\nUsage-based billing requires a separate data model optimized for high-volume event ingestion and efficient aggregation. This model supports real-time usage tracking while providing the performance needed for billing calculations across large customer bases.\n\n#### Usage Event Entity\n\nThe `UsageEvent` entity captures individual metered activities that contribute to usage-based charges. Events are designed to be immutable and idempotent to ensure accurate billing regardless of retry behavior or duplicate submissions.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `event_id` | UUID | Primary key, immutable unique identifier |\n| `idempotency_key` | String | Client-provided key for duplicate detection |\n| `customer_id` | UUID | Foreign key reference to customer |\n| `subscription_id` | UUID | Foreign key reference to subscription |\n| `event_type` | String | Meter name (e.g., \"api_calls\", \"storage_gb\") |\n| `quantity` | Decimal | Amount consumed in this event |\n| `unit` | String | Unit of measurement (calls, GB, hours) |\n| `timestamp` | Timestamp | When the usage occurred (client-reported) |\n| `processed_at` | Timestamp | When the event was received and validated |\n| `billing_period` | String | Billing period this event contributes to (YYYY-MM format) |\n| `properties` | JSON | Additional event metadata and dimensions |\n| `source_system` | String | System that generated this usage event |\n| `aggregated` | Boolean | Whether this event has been included in billing calculations |\n| `created_at` | Timestamp | Event record creation timestamp |\n\nThe `idempotency_key` field prevents double-counting when client systems retry usage submissions. The billing system checks for existing events with the same idempotency key and customer before creating new records. The `billing_period` field enables efficient querying for aggregation without complex date range calculations.\n\n> **Decision: Usage Event Aggregation Strategy**\n> - **Context**: Usage events can accumulate to millions of records per month, requiring efficient aggregation for billing\n> - **Options Considered**:\n>   1. Real-time aggregation into running totals (fast billing but complex consistency)\n>   2. Batch aggregation during billing cycle (simple but potential delays)\n>   3. Hybrid approach with periodic pre-aggregation and billing-time finalization\n> - **Decision**: Hybrid approach with periodic pre-aggregation\n> - **Rationale**: Balances billing speed with system complexity while providing near real-time usage visibility for customers\n> - **Consequences**: Requires background aggregation jobs and eventual consistency handling, but enables responsive usage dashboards and fast billing\n\n#### Usage Aggregation Entity\n\nThe `UsageAggregation` entity stores pre-computed usage totals for efficient billing calculations. Aggregations are updated periodically and finalized during billing to ensure accuracy.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `aggregation_id` | UUID | Primary key, immutable unique identifier |\n| `customer_id` | UUID | Foreign key reference to customer |\n| `subscription_id` | UUID | Foreign key reference to subscription |\n| `event_type` | String | Meter name being aggregated |\n| `billing_period` | String | Billing period for this aggregation (YYYY-MM format) |\n| `period_start` | Date | Start date of the billing period |\n| `period_end` | Date | End date of the billing period |\n| `total_quantity` | Decimal | Total usage amount for this period |\n| `event_count` | Integer | Number of events included in aggregation |\n| `last_event_timestamp` | Timestamp | Timestamp of most recent event included |\n| `is_finalized` | Boolean | Whether aggregation is complete for billing |\n| `finalized_at` | Timestamp | When aggregation was finalized |\n| `updated_at` | Timestamp | Last aggregation update timestamp |\n\n#### Usage Billing Entity\n\nThe `UsageBilling` entity calculates billable amounts from usage aggregations based on plan pricing tiers and limits. This separation allows for complex usage billing scenarios and provides transparency in billing calculations.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `usage_billing_id` | UUID | Primary key, immutable unique identifier |\n| `aggregation_id` | UUID | Foreign key reference to usage aggregation |\n| `plan_id` | UUID | Plan used for billing calculation |\n| `event_type` | String | Meter name being billed |\n| `billing_period` | String | Billing period for this calculation |\n| `included_quantity` | Decimal | Usage amount included in plan (free tier) |\n| `billable_quantity` | Decimal | Usage amount subject to charges |\n| `total_amount_cents` | Integer | Total charges for this usage type |\n| `tier_breakdown` | JSON | Detailed calculation showing each pricing tier |\n| `calculated_at` | Timestamp | When billing calculation was performed |\n| `invoice_line_item_id` | UUID | Reference to generated invoice line item |\n\nThe `tier_breakdown` field contains a detailed calculation showing how usage was allocated across pricing tiers. For example: `{\"tiers\": [{\"range\": \"0-1000\", \"quantity\": 1000, \"rate_cents\": 0, \"amount_cents\": 0}, {\"range\": \"1001-5000\", \"quantity\": 2500, \"rate_cents\": 1, \"amount_cents\": 2500}]}`\n\n#### Usage Event Processing Flow\n\nUsage events flow through several processing stages to ensure accuracy and performance in high-volume scenarios. This pipeline architecture supports real-time ingestion while maintaining billing accuracy.\n\n![Usage Event Processing and Aggregation](./diagrams/usage-aggregation-flow.svg)\n\n1. **Event Ingestion**: Client systems submit usage events via API with idempotency keys. Events are validated for required fields, reasonable quantities, and timestamp constraints.\n\n2. **Deduplication**: The system checks `idempotency_key` and `customer_id` combinations to prevent duplicate events. Duplicate submissions return the original event ID without creating new records.\n\n3. **Temporal Assignment**: Events are assigned to billing periods based on the customer's subscription billing cycle, not calendar months. This ensures usage aligns with subscription billing boundaries.\n\n4. **Aggregation**: Background processes periodically aggregate events into usage totals, updating the `aggregated` flag to prevent double-counting in future runs.\n\n5. **Billing Calculation**: During invoice generation, usage aggregations are converted to billable amounts using current plan pricing. This separation allows for plan changes without re-processing historical events.\n\n6. **Audit and Reconciliation**: Usage totals are validated against event counts and quantities to detect processing errors or data corruption.\n\n#### Common Usage Tracking Pitfalls\n\n⚠️ **Pitfall: Clock Skew in Event Timestamps**\nWhen client systems report usage events with their local timestamps, clock differences can cause events to appear in the wrong billing period. This leads to usage being credited to the wrong invoice.\n\n*Why it's wrong*: A client system with a fast clock might report usage events with timestamps in the next billing period, causing them to be excluded from the current invoice.\n\n*How to fix*: Use server-side processing timestamps for billing period assignment while preserving client timestamps for audit purposes. Implement reasonable timestamp validation to reject events with timestamps too far in the future or past.\n\n⚠️ **Pitfall: Aggregation Boundary Errors**\nIncorrect billing period boundaries can cause usage to be split across multiple invoices or excluded entirely. This is especially problematic for subscriptions with non-standard billing anchors.\n\n*Why it's wrong*: Using calendar month boundaries instead of subscription-specific billing periods causes usage to be prorated incorrectly or appear on the wrong invoice.\n\n*How to fix*: Calculate billing periods using the subscription's `billing_cycle_anchor` and `current_period_start`/`current_period_end` dates. Store the computed billing period with each event to avoid recalculation errors.\n\n⚠️ **Pitfall: Usage Tier Calculation Errors**\nComplex pricing tiers can be implemented incorrectly, leading to overcharges or undercharges. Tiered pricing (each tier priced separately) is often confused with volume pricing (single rate based on total usage).\n\n*Why it's wrong*: Applying a single rate to total usage instead of calculating each tier separately can dramatically overcharge customers in higher usage tiers.\n\n*How to fix*: Implement tier calculations that iterate through each pricing tier, calculating charges for usage within that tier's range, and sum the results. Store the tier breakdown for transparency and debugging.\n\n### Implementation Guidance\n\nThis section provides the foundational code structure and starter implementations for the core data model. The focus is on creating robust, type-safe implementations that prevent common billing errors.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Database | PostgreSQL with SQLAlchemy ORM | PostgreSQL with async SQLAlchemy + connection pooling |\n| Money Handling | Custom Money class with Decimal | Money library (py-money) with currency validation |\n| UUID Generation | uuid.uuid4() | shortuuid for human-readable IDs |\n| Timestamp Handling | datetime with UTC timezone | pendulum library for robust datetime operations |\n| JSON Validation | Manual validation | Pydantic models for structured JSON fields |\n| Database Migrations | Alembic (included with SQLAlchemy) | Alembic with custom migration templates |\n\n#### Recommended File Structure\n\n```\nsubscription-billing/\n├── src/\n│   ├── models/\n│   │   ├── __init__.py           ← Export all entities\n│   │   ├── base.py               ← Base model with common fields\n│   │   ├── customer.py           ← Customer entity and related models\n│   │   ├── plan.py               ← Plan and pricing models\n│   │   ├── subscription.py       ← Subscription lifecycle models\n│   │   ├── invoice.py            ← Invoice and line item models\n│   │   ├── payment.py            ← Payment tracking models\n│   │   └── usage.py              ← Usage tracking models\n│   ├── types/\n│   │   ├── __init__.py\n│   │   ├── money.py              ← Money type with currency handling\n│   │   ├── enums.py              ← All system enums\n│   │   └── audit.py              ← Audit event types and logging\n│   ├── database/\n│   │   ├── __init__.py\n│   │   ├── connection.py         ← Database connection management\n│   │   └── migrations/           ← Alembic migration files\n│   └── config/\n│       ├── __init__.py\n│       └── settings.py           ← Database and system configuration\n├── tests/\n│   ├── test_models/              ← Unit tests for each entity\n│   └── test_integration/         ← Database integration tests\n└── requirements.txt\n```\n\n#### Core Types Implementation\n\n**Complete Money Type Implementation:**\n\n```python\n# src/types/money.py\nfrom decimal import Decimal, ROUND_HALF_UP\nfrom typing import Dict, Optional\nimport json\n\n# Currency configuration with precision and display information\nSUPPORTED_CURRENCIES: Dict[str, Dict[str, any]] = {\n    'USD': {'name': 'US Dollar', 'symbol': '$', 'decimal_places': 2},\n    'EUR': {'name': 'Euro', 'symbol': '€', 'decimal_places': 2},\n    'GBP': {'name': 'British Pound', 'symbol': '£', 'decimal_places': 2},\n    'JPY': {'name': 'Japanese Yen', 'symbol': '¥', 'decimal_places': 0},\n}\n\nDEFAULT_CURRENCY = 'USD'\nDECIMAL_PRECISION = Decimal('0.01')\n\nclass Money:\n    \"\"\"\n    Immutable money type that stores amounts in smallest currency unit (cents)\n    to avoid floating-point precision errors in financial calculations.\n    \"\"\"\n    \n    def __init__(self, amount_cents: int, currency_code: str):\n        if currency_code not in SUPPORTED_CURRENCIES:\n            raise ValueError(f\"Unsupported currency: {currency_code}\")\n        \n        self.amount_cents = amount_cents\n        self.currency_code = currency_code.upper()\n    \n    @classmethod\n    def from_decimal(cls, amount: Decimal, currency: str) -> 'Money':\n        \"\"\"\n        Create Money instance from decimal amount (e.g., 19.99 USD).\n        Rounds to appropriate precision for the currency.\n        \"\"\"\n        currency_info = SUPPORTED_CURRENCIES[currency.upper()]\n        decimal_places = currency_info['decimal_places']\n        \n        # Convert to smallest unit (e.g., cents for USD)\n        multiplier = Decimal(10 ** decimal_places)\n        amount_cents = int((amount * multiplier).quantize(Decimal('1'), rounding=ROUND_HALF_UP))\n        \n        return cls(amount_cents, currency)\n    \n    def to_decimal(self) -> Decimal:\n        \"\"\"\n        Convert to decimal representation (e.g., 1999 cents -> 19.99).\n        \"\"\"\n        currency_info = SUPPORTED_CURRENCIES[self.currency_code]\n        decimal_places = currency_info['decimal_places']\n        divisor = Decimal(10 ** decimal_places)\n        \n        return Decimal(self.amount_cents) / divisor\n    \n    def __add__(self, other: 'Money') -> 'Money':\n        if self.currency_code != other.currency_code:\n            raise ValueError(\"Cannot add different currencies\")\n        return Money(self.amount_cents + other.amount_cents, self.currency_code)\n    \n    def __sub__(self, other: 'Money') -> 'Money':\n        if self.currency_code != other.currency_code:\n            raise ValueError(\"Cannot subtract different currencies\")\n        return Money(self.amount_cents - other.amount_cents, self.currency_code)\n    \n    def __eq__(self, other: 'Money') -> bool:\n        return (self.amount_cents == other.amount_cents and \n                self.currency_code == other.currency_code)\n    \n    def __repr__(self) -> str:\n        return f\"Money({self.amount_cents}, '{self.currency_code}')\"\n    \n    def __str__(self) -> str:\n        currency_info = SUPPORTED_CURRENCIES[self.currency_code]\n        symbol = currency_info['symbol']\n        amount = self.to_decimal()\n        return f\"{symbol}{amount}\"\n```\n\n**Enum Definitions:**\n\n```python\n# src/types/enums.py\nfrom enum import Enum\n\nclass SubscriptionStatus(Enum):\n    TRIAL = \"trial\"\n    ACTIVE = \"active\"\n    PAST_DUE = \"past_due\"\n    CANCELLED = \"cancelled\"\n    EXPIRED = \"expired\"\n\nclass PlanStatus(Enum):\n    ACTIVE = \"active\"\n    DEPRECATED = \"deprecated\"\n    ARCHIVED = \"archived\"\n\nclass PricingModel(Enum):\n    FLAT_RATE = \"flat_rate\"\n    PER_SEAT = \"per_seat\"\n    TIERED = \"tiered\"\n    VOLUME = \"volume\"\n\nclass BillingInterval(Enum):\n    MONTHLY = \"monthly\"\n    QUARTERLY = \"quarterly\"\n    ANNUAL = \"annual\"\n\nclass InvoiceStatus(Enum):\n    DRAFT = \"draft\"\n    OPEN = \"open\"\n    PAID = \"paid\"\n    VOID = \"void\"\n    UNCOLLECTIBLE = \"uncollectible\"\n\nclass PaymentStatus(Enum):\n    PENDING = \"pending\"\n    SUCCEEDED = \"succeeded\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\n    REFUNDED = \"refunded\"\n\nclass AuditEventType(Enum):\n    SUBSCRIPTION_CREATED = \"subscription_created\"\n    SUBSCRIPTION_CANCELLED = \"subscription_cancelled\"\n    PLAN_CHANGED = \"plan_changed\"\n    INVOICE_GENERATED = \"invoice_generated\"\n    PAYMENT_PROCESSED = \"payment_processed\"\n    USAGE_RECORDED = \"usage_recorded\"\n```\n\n**Database Connection Management:**\n\n```python\n# src/database/connection.py\nfrom sqlalchemy import create_engine, event\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom contextlib import contextmanager\nfrom typing import Generator\nimport os\n\n# Database isolation levels for financial operations\nISOLATION_LEVEL_SERIALIZABLE = \"SERIALIZABLE\"\n\nclass DatabaseManager:\n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n        self.engine = create_engine(\n            connection_string,\n            echo=os.getenv(\"DEBUG_SQL\", \"false\").lower() == \"true\",\n            pool_pre_ping=True,  # Validate connections before use\n            pool_recycle=3600,   # Refresh connections hourly\n        )\n        self.SessionLocal = sessionmaker(bind=self.engine)\n    \n    @contextmanager\n    def transaction(self, isolation_level: str = ISOLATION_LEVEL_SERIALIZABLE) -> Generator[Session, None, None]:\n        \"\"\"\n        Provide database transaction with specified isolation level.\n        Financial operations should use SERIALIZABLE to prevent race conditions.\n        \"\"\"\n        session = self.SessionLocal()\n        session.connection(execution_options={\"isolation_level\": isolation_level})\n        \n        try:\n            yield session\n            session.commit()\n        except Exception:\n            session.rollback()\n            raise\n        finally:\n            session.close()\n\n# Base model with common fields\nBase = declarative_base()\n\n# Global database manager instance\ndb_manager = DatabaseManager(os.getenv(\"DATABASE_URL\", \"postgresql://localhost/billing\"))\n```\n\n**Base Model with Audit Trail:**\n\n```python\n# src/models/base.py\nfrom sqlalchemy import Column, DateTime, String, Text\nfrom sqlalchemy.dialects.postgresql import UUID, JSONB\nfrom sqlalchemy.sql import func\nfrom database.connection import Base\nfrom types.audit import AuditEventType\nimport uuid\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\n\nclass BaseModel(Base):\n    __abstract__ = True\n    \n    # Common fields for all entities\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)\n    metadata = Column(JSONB, default=dict, nullable=False)\n\ndef log_event(\n    event_type: AuditEventType,\n    entity_id: str,\n    entity_type: str,\n    changes: Dict[str, Any],\n    actor_id: Optional[str] = None,\n    metadata: Optional[Dict[str, Any]] = None\n) -> None:\n    \"\"\"\n    Record audit trail event for billing operations.\n    This is a placeholder - implement with your audit logging system.\n    \"\"\"\n    audit_record = {\n        \"event_type\": event_type.value,\n        \"entity_id\": entity_id,\n        \"entity_type\": entity_type,\n        \"changes\": changes,\n        \"actor_id\": actor_id,\n        \"metadata\": metadata or {},\n        \"timestamp\": datetime.utcnow().isoformat(),\n    }\n    \n    # TODO: Implement actual audit logging\n    # Options: database table, external audit service, structured logs\n    print(f\"AUDIT: {audit_record}\")\n```\n\n#### Core Entity Skeletons\n\n**Customer Model:**\n\n```python\n# src/models/customer.py\nfrom sqlalchemy import Column, String, Integer, Boolean\nfrom sqlalchemy.dialects.postgresql import UUID, JSONB\nfrom models.base import BaseModel\nfrom types.enums import AccountStatus\nimport uuid\n\nclass Customer(BaseModel):\n    __tablename__ = 'customers'\n    \n    customer_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    external_id = Column(String(255), unique=True, nullable=True)\n    email = Column(String(255), nullable=False, index=True)\n    name = Column(String(255), nullable=False)\n    \n    # TODO: Implement billing address as structured JSON\n    billing_address = Column(JSONB, nullable=True)\n    \n    # TODO: Add tax_id field with validation\n    tax_id = Column(String(50), nullable=True)\n    \n    currency = Column(String(3), nullable=False, default='USD')\n    credit_balance_cents = Column(Integer, nullable=False, default=0)\n    \n    # TODO: Integrate with payment gateway for payment method storage\n    payment_method_id = Column(String(255), nullable=True)\n    \n    billing_email = Column(String(255), nullable=True)\n    account_status = Column(String(20), nullable=False, default='active')\n    \n    def apply_credit(self, amount_cents: int) -> None:\n        \"\"\"\n        Add credit to customer balance. Used for refunds and downgrades.\n        \"\"\"\n        # TODO: Validate amount is positive\n        # TODO: Log credit application event\n        # TODO: Update credit_balance_cents\n        pass\n    \n    def consume_credit(self, amount_cents: int) -> int:\n        \"\"\"\n        Apply available credit to reduce invoice amount.\n        Returns amount of credit actually applied.\n        \"\"\"\n        # TODO: Calculate available credit to apply (min of requested and available)\n        # TODO: Update credit balance\n        # TODO: Log credit consumption event\n        # TODO: Return amount applied\n        pass\n```\n\n**Plan Model:**\n\n```python\n# src/models/plan.py\nfrom sqlalchemy import Column, String, Integer, Text, Boolean\nfrom sqlalchemy.dialects.postgresql import UUID, JSONB\nfrom models.base import BaseModel\nfrom types.enums import PlanStatus, BillingInterval, PricingModel\nimport uuid\n\nclass Plan(BaseModel):\n    __tablename__ = 'plans'\n    \n    plan_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    plan_code = Column(String(100), nullable=False, unique=True)\n    name = Column(String(255), nullable=False)\n    description = Column(Text, nullable=True)\n    \n    status = Column(String(20), nullable=False, default=PlanStatus.ACTIVE.value)\n    \n    billing_interval = Column(String(20), nullable=False)\n    billing_interval_count = Column(Integer, nullable=False, default=1)\n    \n    pricing_model = Column(String(20), nullable=False)\n    base_price_cents = Column(Integer, nullable=False)\n    currency = Column(String(3), nullable=False, default='USD')\n    \n    trial_period_days = Column(Integer, nullable=True)\n    setup_fee_cents = Column(Integer, nullable=False, default=0)\n    \n    # Structured data for features and pricing\n    features = Column(JSONB, default=list, nullable=False)\n    usage_limits = Column(JSONB, default=dict, nullable=False)\n    pricing_tiers = Column(JSONB, default=list, nullable=False)\n    \n    def calculate_usage_charge(self, usage_type: str, quantity: float) -> int:\n        \"\"\"\n        Calculate charges for usage beyond plan limits.\n        Returns charge amount in cents.\n        \"\"\"\n        # TODO: Get usage limit for this usage_type from usage_limits\n        # TODO: Calculate overage quantity (usage - limit)\n        # TODO: Apply tiered pricing from pricing_tiers\n        # TODO: Return total charge in cents\n        pass\n    \n    def has_feature(self, feature_name: str) -> bool:\n        \"\"\"\n        Check if plan includes specified feature.\n        \"\"\"\n        # TODO: Check if feature_name exists in features list\n        pass\n    \n    def is_available_for_signup(self) -> bool:\n        \"\"\"\n        Check if plan can be used for new subscriptions.\n        \"\"\"\n        # TODO: Return True only if status is ACTIVE\n        pass\n```\n\n#### Milestone Checkpoints\n\n**Checkpoint 1: Basic Entity Creation**\nAfter implementing the core entities, verify the data model works correctly:\n\n```bash\n# Run basic model tests\npython -m pytest tests/test_models/ -v\n\n# Test money type operations\npython -c \"\nfrom src.types.money import Money\nfrom decimal import Decimal\n\n# Create money instances\nusd_19_99 = Money.from_decimal(Decimal('19.99'), 'USD')\nusd_5_00 = Money.from_decimal(Decimal('5.00'), 'USD')\n\n# Test arithmetic\ntotal = usd_19_99 + usd_5_00\nprint(f'Total: {total}')  # Should print: $24.99\n\n# Test precision\ncents_1999 = Money(1999, 'USD')\nprint(f'From cents: {cents_1999}')  # Should print: $19.99\n\"\n```\n\nExpected output shows proper money arithmetic without precision errors.\n\n**Checkpoint 2: Database Schema Creation**\nVerify the database schema generates correctly:\n\n```bash\n# Generate migration for core entities\nalembic revision --autogenerate -m \"Add core billing entities\"\n\n# Apply migration\nalembic upgrade head\n\n# Verify tables were created\npsql $DATABASE_URL -c \"\\dt\"\n```\n\nYou should see tables for customers, plans, subscriptions, invoices, invoice_line_items, payments, usage_events, usage_aggregations, and usage_billing.\n\n**Checkpoint 3: Entity Relationship Validation**\nTest that foreign key relationships work correctly:\n\n```python\n# Test script to verify relationships\nfrom src.models import Customer, Plan, Subscription\nfrom src.database.connection import db_manager\nfrom src.types.money import Money\nfrom decimal import Decimal\n\nwith db_manager.transaction() as session:\n    # Create test customer\n    customer = Customer(\n        email=\"test@example.com\",\n        name=\"Test Customer\",\n        currency=\"USD\"\n    )\n    session.add(customer)\n    \n    # Create test plan\n    plan = Plan(\n        plan_code=\"test-monthly\",\n        name=\"Test Monthly Plan\",\n        billing_interval=\"monthly\",\n        pricing_model=\"flat_rate\",\n        base_price_cents=1999,  # $19.99\n        currency=\"USD\"\n    )\n    session.add(plan)\n    session.flush()  # Get IDs before creating subscription\n    \n    # Create subscription linking customer and plan\n    subscription = Subscription(\n        customer_id=customer.customer_id,\n        plan_id=plan.plan_id,\n        status=\"active\"\n    )\n    session.add(subscription)\n    \n    print(\"✓ Successfully created related entities\")\n```\n\nThis checkpoint confirms that the core data model supports the relationships needed for subscription billing workflows.\n\n\n## Plan Management Component\n\n> **Milestone(s):** Milestone 1 (Plans & Pricing) - implements flexible pricing plans with tiers, features, and currencies\n\n### Mental Model: Product Catalog Design\n\nThink of plan management like designing a product catalog for a large retail chain. Just as a store needs a master catalog that defines each product's price, features, and availability across different locations, a subscription system needs a plan catalog that defines pricing models, feature entitlements, and billing terms across different customer segments.\n\nConsider how Apple manages its iPhone product line. They maintain multiple models (iPhone 15, iPhone 15 Pro, iPhone 15 Pro Max) with different storage tiers (128GB, 256GB, 512GB, 1TB). Each combination has a specific price point and set of features. When Apple releases the iPhone 16, they don't delete the iPhone 15 from existence - existing customers keep their devices and support contracts. Similarly, when you deprecate a subscription plan, existing subscribers must be \"grandfathered\" into their original terms.\n\nThe catalog also defines what features each product tier unlocks. An iPhone 15 Pro includes features that the base iPhone 15 doesn't have (ProRAW photography, macro lens, etc.). In subscription systems, this translates to feature entitlements - a Premium plan might include API access limits of 10,000 requests per month, while a Basic plan only allows 1,000 requests.\n\nJust as retailers need to handle currency conversion for international customers (a $999 iPhone costs €1,129 in Europe due to taxes and exchange rates), subscription plans must support multiple currencies with appropriate regional pricing. The key insight is that you're not just storing prices - you're building a comprehensive product management system that governs what customers can access and how much they pay.\n\n### Pricing Model Implementation\n\nThe plan management system must support three fundamental pricing models, each serving different business use cases and customer preferences. Understanding these models is crucial because each requires different calculation logic, validation rules, and upgrade/downgrade behavior.\n\n**Flat-Rate Pricing** represents the simplest subscription model where customers pay a fixed amount regardless of usage. Think of Netflix's monthly subscription - whether you watch one movie or fifty, you pay the same $15.99. This model provides predictable revenue for the business and predictable costs for customers. The implementation stores a single `base_price_cents` value per plan, and billing calculations are straightforward multiplication based on the billing interval.\n\n**Tiered Pricing** creates multiple usage brackets with different rates per bracket, similar to progressive tax systems. Consider a cloud storage service where the first 100GB costs $5, the next 400GB costs $0.03 per GB, and anything beyond 500GB costs $0.02 per GB. A customer using 750GB would pay: $5 (first tier) + $12 (400GB × $0.03) + $5 (250GB × $0.02) = $22 total. Each usage unit is charged at the rate of its respective tier.\n\n**Volume Pricing** applies a single rate to the entire usage amount based on which tier the total usage falls into. Using the same cloud storage example, if a customer uses 750GB, they would pay the entire 750GB at the $0.02 rate (since they're in the highest tier), resulting in a $15 charge. This model rewards higher usage with better rates across all consumption.\n\nThe distinction between tiered and volume pricing is critical and frequently misunderstood. Tiered pricing charges each bracket separately (like tax brackets), while volume pricing applies one rate to the entire amount (like bulk discounts). The Plan entity must clearly specify which model applies to avoid billing errors.\n\n| Pricing Model | Description | Calculation Method | Use Case Example |\n|---------------|-------------|-------------------|------------------|\n| Flat-Rate | Fixed charge per billing period | `base_price_cents × billing_periods` | Netflix subscription |\n| Tiered | Different rates per usage bracket | Sum of (bracket_usage × bracket_rate) | Progressive API pricing |\n| Volume | Single rate based on total usage tier | `total_usage × applicable_tier_rate` | Bulk storage discounts |\n\n**Feature Entitlements** represent what capabilities each plan unlocks for subscribers. Unlike pricing, which determines charges, entitlements determine access control throughout your application. A plan defines both what a customer pays and what they can do.\n\nFeature entitlements should be designed as a flexible key-value system where each plan maps to a set of feature flags and their corresponding limits. For example, a \"Starter\" plan might include `api_requests_per_month: 1000`, `max_team_members: 5`, `advanced_analytics: false`, while a \"Professional\" plan might include `api_requests_per_month: 10000`, `max_team_members: 25`, `advanced_analytics: true`.\n\nThe Plan entity structure must accommodate all these pricing models while maintaining clarity about which model applies:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `plan_id` | UUID | Unique identifier for the plan |\n| `plan_code` | str | Human-readable code (e.g., \"starter-monthly\") |\n| `name` | str | Display name (e.g., \"Starter Plan\") |\n| `description` | str | Marketing description of the plan |\n| `billing_interval` | str | Frequency of charges (monthly, yearly, quarterly) |\n| `pricing_model` | str | Type of pricing (flat_rate, tiered, volume) |\n| `base_price_cents` | int | Base price in smallest currency unit |\n| `currency` | str | Currency code (USD, EUR, GBP) |\n| `trial_period_days` | int | Number of free trial days (0 if no trial) |\n| `feature_entitlements` | JSON | Key-value mapping of features to limits |\n| `pricing_tiers` | JSON | Array of tier definitions for tiered/volume pricing |\n| `is_active` | bool | Whether new subscriptions can use this plan |\n| `created_at` | timestamp | Plan creation time |\n| `deprecated_at` | timestamp | When plan was deprecated (null if active) |\n\nThe `pricing_tiers` field for tiered and volume pricing contains an array of tier objects:\n\n| Tier Field | Type | Description |\n|------------|------|-------------|\n| `tier_number` | int | Order of the tier (1, 2, 3, etc.) |\n| `min_quantity` | int | Minimum usage for this tier |\n| `max_quantity` | int | Maximum usage for this tier (null for unlimited) |\n| `price_per_unit_cents` | int | Cost per unit in this tier |\n| `flat_fee_cents` | int | Fixed fee for entering this tier |\n\n### ADR: Plan Versioning Strategy\n\n> **Decision: Immutable Plan Versioning with Grandfathering**\n> \n> - **Context**: When businesses need to change plan pricing or features, they face a dilemma. Updating existing plans affects current subscribers, potentially violating their original agreement or creating customer dissatisfaction. However, maintaining multiple plan versions creates complexity in the system and administrative overhead.\n> \n> - **Options Considered**: \n>   1. Mutable plans with forced migrations\n>   2. Plan versioning with optional migrations  \n>   3. Immutable plans with grandfathering\n> \n> - **Decision**: Implement immutable plan versioning where plan changes create new versions, and existing subscribers remain on their original plan version unless they explicitly choose to migrate.\n> \n> - **Rationale**: This approach honors existing customer agreements while allowing business flexibility to adjust pricing and features for new customers. It prevents unexpected billing changes that could damage customer relationships and ensures legal compliance with subscription terms.\n> \n> - **Consequences**: Increases system complexity as multiple plan versions must be maintained. Customer support must understand which customers are on which plan versions. Reporting and analytics become more complex when aggregating across plan versions.\n\n| Option | Pros | Cons |\n|--------|------|------|\n| Mutable Plans | Simple data model, single plan per type | Breaks existing customer agreements, potential legal issues |\n| Optional Migrations | Balanced approach, customer choice | Complex migration logic, unclear customer experience |\n| Immutable Versioning | Honors agreements, clear audit trail | Multiple versions to maintain, complex reporting |\n\nThe immutable versioning strategy requires extending the Plan entity to support version tracking. When a plan needs modification, the system creates a new plan record with an incremented version number, marking the previous version as deprecated for new subscriptions while keeping it available for existing subscribers.\n\n**Plan Version Management** introduces additional fields to track the relationship between plan versions:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `plan_family_id` | UUID | Groups all versions of the same logical plan |\n| `version_number` | int | Sequential version within the plan family |\n| `supersedes_plan_id` | UUID | Previous version this plan replaces |\n| `migration_eligible` | bool | Whether existing subscribers can upgrade to this version |\n| `migration_incentive` | JSON | Special offers for customers who migrate |\n\nThe plan family concept allows grouping related plan versions while maintaining clear lineage. For example, all versions of the \"Professional Plan\" share the same `plan_family_id` but have different `version_number` values. This enables reporting across all Professional subscribers while maintaining version-specific billing logic.\n\n**Grandfathering Rules** define how existing subscribers interact with plan changes:\n\n1. **Price Protection**: Existing subscribers maintain their original pricing unless they voluntarily change plans\n2. **Feature Evolution**: New features may be added to all versions of a plan family, but existing features cannot be removed\n3. **Billing Interval Lock**: Subscribers cannot be forced to change from monthly to yearly billing or vice versa\n4. **Migration Windows**: When offering upgrades, provide limited-time migration opportunities with clear terms\n\n### Common Pitfalls in Plan Management\n\n⚠️ **Pitfall: Currency Float Arithmetic**\nUsing floating-point arithmetic for currency calculations introduces rounding errors that accumulate over many transactions. A plan priced at $9.99 might be stored as 9.989999... internally, leading to billing discrepancies. Always store prices as integers in the smallest currency unit (cents for USD, pence for GBP). Use the `Money` type consistently throughout the system and convert to decimal representation only for display purposes.\n\n⚠️ **Pitfall: Plan Deletion Instead of Deprecation**\nDeleting old plans breaks the referential integrity of existing subscriptions and makes historical reporting impossible. Instead of deletion, mark plans as deprecated with a timestamp. Deprecated plans should not be available for new subscriptions but must remain queryable for existing subscribers. This maintains data consistency and supports customer service inquiries about historical billing.\n\n⚠️ **Pitfall: Inconsistent Feature Entitlement Checking**\nChecking subscription status (`active`) instead of plan features (`has_feature`) leads to incorrect access control. An active subscription to a Basic plan should not grant access to Premium features, even if the subscription is current on payments. Always check the specific feature entitlement rather than subscription status alone. This prevents feature access bugs and ensures proper plan enforcement.\n\n⚠️ **Pitfall: Timezone-Naive Billing Intervals**\nStoring billing intervals as simple strings like \"monthly\" without considering timezone effects creates ambiguity about when billing occurs. A customer in Tokyo subscribing on January 31st might have their billing date shift unexpectedly due to timezone calculations. Store billing anchor dates as UTC timestamps and perform timezone conversion only for display purposes.\n\n⚠️ **Pitfall: Hard-Coded Feature Lists**\nEmbedding feature names directly in application code makes plan management inflexible and requires code deployments to add new features. Instead, use a dynamic feature entitlement system where plans reference configurable feature keys. This allows business users to create new plans and modify feature access without engineering involvement.\n\n### Implementation Guidance\n\n**Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Plan Storage | SQLite with JSON columns | PostgreSQL with JSONB indexing |\n| Feature Flags | Simple key-value in plan JSON | Redis with feature flag service |\n| Currency Handling | Python Decimal with hardcoded rates | Integration with currency exchange API |\n| Plan Validation | Pydantic models with basic validation | Marshmallow with custom business rules |\n| Caching | In-memory Python dict | Redis with TTL-based invalidation |\n\n**Recommended File Structure**\n\n```\nsubscription_system/\n  core/\n    models/\n      plan.py              ← Plan entity and validation\n      money.py             ← Money type and currency handling\n    services/\n      plan_service.py      ← Plan management business logic\n      feature_service.py   ← Feature entitlement checking\n    repositories/\n      plan_repository.py   ← Plan data access layer\n  api/\n    plan_api.py           ← REST endpoints for plan management\n  migrations/\n    001_create_plans.sql  ← Database schema creation\n  tests/\n    test_plan_models.py   ← Unit tests for plan logic\n    test_plan_service.py  ← Service layer tests\n```\n\n**Infrastructure Starter Code**\n\n```python\n# core/models/money.py\nfrom decimal import Decimal, ROUND_HALF_UP\nfrom typing import Dict\n\nSUPPORTED_CURRENCIES: Dict[str, Dict[str, str]] = {\n    'USD': {'symbol': '$', 'name': 'US Dollar', 'decimal_places': 2},\n    'EUR': {'symbol': '€', 'name': 'Euro', 'decimal_places': 2},\n    'GBP': {'symbol': '£', 'name': 'British Pound', 'decimal_places': 2},\n    'JPY': {'symbol': '¥', 'name': 'Japanese Yen', 'decimal_places': 0},\n}\n\nDEFAULT_CURRENCY = 'USD'\nDECIMAL_PRECISION = Decimal('0.01')\n\nclass Money:\n    \"\"\"Represents a monetary amount with currency, stored as integer cents.\"\"\"\n    \n    def __init__(self, amount_cents: int, currency_code: str):\n        if currency_code not in SUPPORTED_CURRENCIES:\n            raise ValueError(f\"Unsupported currency: {currency_code}\")\n        self.amount_cents = amount_cents\n        self.currency_code = currency_code\n    \n    @classmethod\n    def from_decimal(cls, amount: Decimal, currency: str) -> 'Money':\n        \"\"\"Create Money from decimal amount, converting to cents.\"\"\"\n        if currency not in SUPPORTED_CURRENCIES:\n            raise ValueError(f\"Unsupported currency: {currency}\")\n        \n        decimal_places = SUPPORTED_CURRENCIES[currency]['decimal_places']\n        multiplier = Decimal(10 ** decimal_places)\n        amount_cents = int(amount.quantize(DECIMAL_PRECISION, rounding=ROUND_HALF_UP) * multiplier)\n        return cls(amount_cents, currency)\n    \n    def to_decimal(self) -> Decimal:\n        \"\"\"Convert Money to decimal representation for display.\"\"\"\n        decimal_places = SUPPORTED_CURRENCIES[self.currency_code]['decimal_places']\n        divisor = Decimal(10 ** decimal_places)\n        return Decimal(self.amount_cents) / divisor\n    \n    def __add__(self, other: 'Money') -> 'Money':\n        if self.currency_code != other.currency_code:\n            raise ValueError(\"Cannot add different currencies\")\n        return Money(self.amount_cents + other.amount_cents, self.currency_code)\n    \n    def __str__(self) -> str:\n        symbol = SUPPORTED_CURRENCIES[self.currency_code]['symbol']\n        return f\"{symbol}{self.to_decimal()}\"\n\n# core/models/plan.py\nfrom uuid import UUID, uuid4\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Any\nfrom enum import Enum\nfrom dataclasses import dataclass, field\n\nclass PricingModel(Enum):\n    FLAT_RATE = \"flat_rate\"\n    TIERED = \"tiered\"\n    VOLUME = \"volume\"\n\nclass BillingInterval(Enum):\n    MONTHLY = \"monthly\"\n    YEARLY = \"yearly\"\n    QUARTERLY = \"quarterly\"\n\n@dataclass\nclass PricingTier:\n    \"\"\"Represents a single tier in tiered or volume pricing.\"\"\"\n    tier_number: int\n    min_quantity: int\n    max_quantity: Optional[int]  # None for unlimited\n    price_per_unit_cents: int\n    flat_fee_cents: int = 0\n\n@dataclass\nclass Plan:\n    \"\"\"Core plan entity with pricing and feature information.\"\"\"\n    plan_id: UUID = field(default_factory=uuid4)\n    plan_code: str = \"\"\n    name: str = \"\"\n    description: str = \"\"\n    billing_interval: str = BillingInterval.MONTHLY.value\n    pricing_model: str = PricingModel.FLAT_RATE.value\n    base_price_cents: int = 0\n    currency: str = DEFAULT_CURRENCY\n    trial_period_days: int = 0\n    feature_entitlements: Dict[str, Any] = field(default_factory=dict)\n    pricing_tiers: List[PricingTier] = field(default_factory=list)\n    is_active: bool = True\n    plan_family_id: Optional[UUID] = None\n    version_number: int = 1\n    supersedes_plan_id: Optional[UUID] = None\n    migration_eligible: bool = True\n    created_at: datetime = field(default_factory=datetime.utcnow)\n    deprecated_at: Optional[datetime] = None\n    \n    def has_feature(self, feature_name: str) -> bool:\n        \"\"\"Check if this plan includes the specified feature.\"\"\"\n        # TODO: Implement feature checking logic\n        # TODO: Handle boolean features (return feature_entitlements.get(feature_name, False))\n        # TODO: Handle numeric limits (return feature_entitlements.get(feature_name, 0) > 0)\n        # TODO: Consider feature inheritance from plan family\n        pass\n    \n    def get_feature_limit(self, feature_name: str) -> Optional[int]:\n        \"\"\"Get the numeric limit for a feature, or None if unlimited.\"\"\"\n        # TODO: Extract numeric limits from feature_entitlements\n        # TODO: Handle special case of -1 or None meaning unlimited\n        # TODO: Return 0 if feature is not included in this plan\n        pass\n    \n    def calculate_base_charge(self) -> Money:\n        \"\"\"Calculate the base recurring charge for this plan.\"\"\"\n        # TODO: Return Money object with base_price_cents and currency\n        # TODO: Handle case where pricing_model is not flat_rate (should return 0)\n        pass\n\n# Database repository implementation\nclass PlanRepository:\n    \"\"\"Data access layer for plan operations.\"\"\"\n    \n    def __init__(self, db_manager):\n        self.db = db_manager\n    \n    def create_plan(self, plan: Plan) -> Plan:\n        \"\"\"Create a new plan in the database.\"\"\"\n        # TODO: Validate plan data before insertion\n        # TODO: Check for unique plan_code within plan_family\n        # TODO: Insert plan record with all fields\n        # TODO: Handle database constraints and return created plan\n        pass\n    \n    def get_plan_by_id(self, plan_id: UUID) -> Optional[Plan]:\n        \"\"\"Retrieve a plan by its ID.\"\"\"\n        # TODO: Query database for plan with given ID\n        # TODO: Convert database row to Plan object\n        # TODO: Handle case where plan is not found\n        pass\n    \n    def get_active_plans(self) -> List[Plan]:\n        \"\"\"Get all plans available for new subscriptions.\"\"\"\n        # TODO: Query for plans where is_active = True and deprecated_at IS NULL\n        # TODO: Convert database rows to Plan objects\n        # TODO: Order by plan_family_id and version_number\n        pass\n    \n    def deprecate_plan(self, plan_id: UUID) -> bool:\n        \"\"\"Mark a plan as deprecated, preventing new subscriptions.\"\"\"\n        # TODO: Set deprecated_at timestamp to current time\n        # TODO: Set is_active to False\n        # TODO: Ensure existing subscriptions are not affected\n        # TODO: Return True if plan was found and updated\n        pass\n```\n\n**Core Logic Skeleton**\n\n```python\n# core/services/plan_service.py\nfrom typing import List, Optional\nfrom uuid import UUID\nfrom core.models.plan import Plan, PricingModel, Money\nfrom core.repositories.plan_repository import PlanRepository\n\nclass PlanService:\n    \"\"\"Business logic for plan management operations.\"\"\"\n    \n    def __init__(self, plan_repo: PlanRepository):\n        self.plan_repo = plan_repo\n    \n    def create_plan_family(self, plan_data: dict) -> Plan:\n        \"\"\"Create the first version of a new plan family.\"\"\"\n        # TODO: Validate required fields (name, plan_code, pricing_model, etc.)\n        # TODO: Generate new plan_family_id (same as plan_id for first version)\n        # TODO: Set version_number to 1\n        # TODO: Validate pricing_model and ensure required pricing data exists\n        # TODO: Create Plan object and save via repository\n        # TODO: Return created plan\n        pass\n    \n    def create_plan_version(self, plan_family_id: UUID, updated_data: dict) -> Plan:\n        \"\"\"Create a new version of an existing plan family.\"\"\"\n        # TODO: Get latest version of the plan family\n        # TODO: Validate that changes warrant a new version\n        # TODO: Increment version_number\n        # TODO: Set supersedes_plan_id to previous version\n        # TODO: Deprecate previous version if specified\n        # TODO: Create and save new plan version\n        pass\n    \n    def calculate_plan_charge(self, plan: Plan, usage_quantity: int = 0) -> Money:\n        \"\"\"Calculate total charge for a plan given usage quantity.\"\"\"\n        # TODO: Handle flat_rate pricing (return base_price_cents)\n        # TODO: Handle tiered pricing (sum charges across tiers)\n        # TODO: Handle volume pricing (find tier and apply rate to total)\n        # TODO: Add any flat fees from pricing tiers\n        # TODO: Return Money object with calculated amount\n        pass\n    \n    def validate_plan_upgrade(self, from_plan_id: UUID, to_plan_id: UUID) -> bool:\n        \"\"\"Validate that a plan change is allowed.\"\"\"\n        # TODO: Check that both plans exist and are in same family OR different families\n        # TODO: Verify to_plan allows migrations (migration_eligible = True)\n        # TODO: Ensure currency compatibility\n        # TODO: Check business rules (e.g., no downgrades, version restrictions)\n        # TODO: Return True if upgrade is valid\n        pass\n\n# core/services/feature_service.py\nclass FeatureService:\n    \"\"\"Service for checking feature entitlements and usage limits.\"\"\"\n    \n    def __init__(self, plan_repo: PlanRepository):\n        self.plan_repo = plan_repo\n    \n    def check_feature_access(self, plan_id: UUID, feature_name: str) -> bool:\n        \"\"\"Check if a plan grants access to a specific feature.\"\"\"\n        # TODO: Retrieve plan from repository\n        # TODO: Call plan.has_feature(feature_name)\n        # TODO: Handle case where plan is not found (return False)\n        # TODO: Log access check for auditing purposes\n        pass\n    \n    def get_feature_usage_limit(self, plan_id: UUID, feature_name: str) -> Optional[int]:\n        \"\"\"Get the usage limit for a feature, or None if unlimited.\"\"\"\n        # TODO: Retrieve plan from repository\n        # TODO: Call plan.get_feature_limit(feature_name)\n        # TODO: Handle inheritance from plan family if configured\n        # TODO: Return limit or None for unlimited access\n        pass\n    \n    def validate_feature_usage(self, plan_id: UUID, feature_name: str, proposed_usage: int) -> bool:\n        \"\"\"Check if proposed usage is within plan limits.\"\"\"\n        # TODO: Get feature limit for the plan\n        # TODO: Handle unlimited access (limit is None)\n        # TODO: Compare proposed_usage against limit\n        # TODO: Return True if usage is within limits\n        pass\n```\n\n**Milestone Checkpoint**\n\nAfter implementing the plan management component, verify the following functionality:\n\n**Test Commands:**\n```bash\n# Run unit tests for plan models and services\npython -m pytest tests/test_plan_models.py -v\npython -m pytest tests/test_plan_service.py -v\n\n# Test plan creation via API\ncurl -X POST http://localhost:8000/api/plans \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"plan_code\": \"starter-monthly\",\n    \"name\": \"Starter Plan\",\n    \"billing_interval\": \"monthly\",\n    \"base_price_cents\": 999,\n    \"currency\": \"USD\",\n    \"feature_entitlements\": {\n      \"api_requests_per_month\": 1000,\n      \"max_team_members\": 5\n    }\n  }'\n```\n\n**Expected Behavior:**\n1. Plan creation should return a complete Plan object with generated `plan_id` and `plan_family_id`\n2. Feature checking should correctly identify which features are included in each plan\n3. Pricing calculations should handle different pricing models accurately\n4. Plan versioning should create new versions without affecting existing plans\n5. Currency handling should maintain precision without floating-point errors\n\n**Signs of Issues:**\n- **Plan creation fails**: Check required field validation and database constraints\n- **Currency precision errors**: Verify all prices are stored as integers in cents\n- **Feature access bugs**: Ensure feature checking uses plan entitlements, not subscription status\n- **Version conflicts**: Check that plan_family_id relationships are maintained correctly\n\n\n## Subscription Lifecycle Management\n\n> **Milestone(s):** Milestone 2 (Subscription Lifecycle) - implements subscription creation, activation, renewal, and cancellation with appropriate state transitions and billing cycle management\n\n### Mental Model: Membership Lifecycle\n\nThink of subscription management like running a premium fitness club with sophisticated membership tiers. When someone joins your gym, they don't just pay once and disappear - they enter into an ongoing relationship with predictable patterns and lifecycle events.\n\nConsider how gym memberships work in the real world. A new member might start with a free trial week to test the facilities. During this trial, they have access to basic equipment but can't use premium services like personal training or spa facilities. If they don't cancel before the trial ends, their membership automatically converts to a paid plan - perhaps a monthly membership at $50 per month.\n\nOnce they're an active paying member, several things can happen. They might upgrade to a premium plan to access the spa and personal training. They could downgrade to a basic plan if money gets tight. They might go on vacation and pause their membership for a month. Eventually, they might cancel - either immediately (forfeiting any prepaid time) or at the end of their current billing period.\n\nThroughout this lifecycle, the gym must track payment status carefully. If a member's credit card fails, they don't immediately lose access - there's a grace period where the gym tries to collect payment while the member can still use facilities. Only after multiple failed attempts does the membership move to a suspended state.\n\nThis is exactly how subscription billing works. Each **subscription** represents an ongoing relationship between a customer and a service, with predictable state transitions, billing cycles, and lifecycle events. The subscription moves through various states (trial, active, past_due, cancelled) based on payment success, customer actions, and business rules.\n\nThe key insight is that subscriptions are not just payment records - they're stateful entities that evolve over time according to business logic. Managing this lifecycle correctly ensures customers have a smooth experience while protecting business revenue through proper dunning management and retention policies.\n\n### Subscription State Machine\n\nA subscription's journey follows a well-defined state machine where each state represents a distinct phase of the customer relationship. Understanding these states and their transitions is crucial for implementing reliable billing logic and providing clear customer communication.\n\nThe subscription lifecycle begins when a customer selects a plan and provides payment information. Unlike simple e-commerce transactions, subscriptions must track ongoing state because the relationship extends far beyond the initial purchase. Each state change triggers specific business logic, from provisioning access to sending dunning emails.\n\n![Subscription Lifecycle State Machine](./diagrams/subscription-state-machine.svg)\n\nHere are the core subscription states and their business meaning:\n\n| State | Description | Customer Access | Billing Status | Duration |\n|-------|-------------|-----------------|----------------|----------|\n| `incomplete` | Subscription created but payment method not yet confirmed | No access | Payment pending | Until payment succeeds/fails |\n| `trialing` | Free trial period active | Limited access per plan | No charges | Until trial_end_date |\n| `active` | Paying subscription in good standing | Full access | Charges successfully | Until next billing event |\n| `past_due` | Payment failed but still retrying | Access per grace policy | Retry attempts active | Until payment succeeds or retry limit |\n| `unpaid` | Payment retries exhausted, subscription suspended | No access | No further retries | Until manual intervention |\n| `cancelled` | Subscription terminated by customer or system | No access (or until period_end) | No future charges | Permanent |\n| `paused` | Temporarily suspended by customer request | No access | No charges during pause | Until resume_date |\n\nThe state transitions are governed by specific events and business rules:\n\n| Current State | Event | Next State | Action Taken | Conditions |\n|---------------|-------|------------|--------------|------------|\n| `incomplete` | Payment succeeds | `active` or `trialing` | Provision access, start trial if configured | Valid payment method confirmed |\n| `incomplete` | Payment fails | `cancelled` | Send failure notification | After maximum retry attempts |\n| `trialing` | Trial expires | `active` | Charge first payment, continue service | Successful payment collection |\n| `trialing` | Trial expires | `past_due` | Start dunning process | Payment collection fails |\n| `trialing` | Customer cancels | `cancelled` | Terminate access immediately | No refund due (trial was free) |\n| `active` | Renewal payment succeeds | `active` | Extend billing period, continue access | Normal billing cycle |\n| `active` | Renewal payment fails | `past_due` | Start retry sequence, maintain access | Begin grace period |\n| `active` | Customer cancels | `cancelled` or `active` | Schedule termination | Immediate vs end-of-period |\n| `active` | Customer pauses | `paused` | Suspend access, stop billing | If pause feature enabled |\n| `past_due` | Payment succeeds | `active` | Restore full access, extend period | During retry window |\n| `past_due` | Retry limit exceeded | `unpaid` | Suspend access, stop retries | After final dunning attempt |\n| `unpaid` | Payment method updated | `active` | Charge outstanding amount, restore access | Manual intervention successful |\n| `unpaid` | Extended grace period | `cancelled` | Permanent termination | Business decision to close account |\n| `paused` | Resume requested | `active` | Restore access, resume billing | Customer-initiated resume |\n| `paused` | Resume date reached | `active` | Automatic restoration | Scheduled resume |\n| `cancelled` | Reactivation requested | `active` | Create new subscription | Within reactivation window |\n\n> **Critical Design Principle**: State transitions must be atomic and auditable. Every state change should be recorded with a timestamp, triggering event, and actor (system, customer, admin). This audit trail is essential for customer support, revenue recognition, and debugging billing issues.\n\nThe state machine enforces important business invariants that prevent data corruption and revenue leakage:\n\n**Access Control Invariants**: Only `active` and `trialing` subscriptions grant feature access. The `past_due` state may grant continued access during a grace period, but this must be explicitly configured per business policy.\n\n**Billing Invariants**: Charges only occur for `active` subscriptions or when transitioning from `trialing` to `active`. Past due subscriptions do not generate new charges - they only retry collecting existing outstanding amounts.\n\n**Cancellation Invariants**: Once a subscription reaches `cancelled` state, it cannot directly transition back to `active`. Reactivation must create a new subscription entity to maintain clear audit trails and prevent accidental billing.\n\n**Temporal Invariants**: State transitions must respect billing cycle boundaries. For example, a cancellation with `at_period_end=true` should not immediately change state - instead, it schedules a future transition.\n\n### ADR: Renewal Processing Architecture\n\nThe subscription billing system must process thousands of renewals daily with precise timing and reliable failure handling. This architectural decision determines how we schedule and execute recurring billing operations across the entire customer base.\n\n> **Decision: Event-Driven Renewal Processing with Cron Trigger**\n> - **Context**: We need to process subscription renewals reliably at specific dates and times, handle failures gracefully, and support both immediate and scheduled billing operations. Traditional cron-based systems can miss renewals if the system is down, while purely event-driven systems need careful orchestration for time-based triggers.\n> - **Options Considered**: \n>   1. **Pure Cron-Based Processing**: Traditional scheduled jobs that query for due renewals\n>   2. **Pure Event-Driven Processing**: All renewals triggered by timer events or external signals  \n>   3. **Hybrid Event-Driven with Cron Bootstrap**: Cron triggers event publishing, events drive actual processing\n> - **Decision**: Hybrid approach with cron-triggered event publishing and event-driven renewal processing\n> - **Rationale**: Combines reliable scheduling with robust failure handling and clear separation of concerns between scheduling and processing logic\n> - **Consequences**: Enables retry logic, audit trails, and distributed processing while maintaining predictable renewal timing\n\n| Option | Pros | Cons | Complexity |\n|--------|------|------|------------|\n| Pure Cron | Simple implementation, predictable timing, easy debugging | No retry logic, single point of failure, difficult to scale | Low |\n| Pure Event-Driven | Excellent failure handling, scalable, testable | Complex time-based triggering, harder to ensure coverage | High |\n| Hybrid Approach | Best of both worlds, robust failure handling, scalable | Moderate complexity, two systems to maintain | Medium |\n\nThe hybrid architecture works through a clear separation of responsibilities:\n\n**Cron Scheduler Component**: Runs every hour and identifies subscriptions with `billing_cycle_anchor` dates that fall within the next processing window. For each eligible subscription, it publishes a `BillingDueEvent` to the event queue with the subscription ID and intended billing date.\n\n**Renewal Processing Engine**: Consumes `BillingDueEvent` messages and executes the actual billing logic. Each event is processed independently with full retry semantics, error handling, and transaction isolation. If processing fails, the event remains in the queue for retry with exponential backoff.\n\n**Idempotency Protection**: Each billing event includes an idempotency key based on the subscription ID and billing period start date. This prevents duplicate charges if the same renewal is processed multiple times due to retries or system issues.\n\nThe processing flow follows these steps:\n\n1. **Cron Query Phase**: Every hour, query subscriptions where `next_billing_date <= now() + 1 hour` and `status IN ('active', 'trialing')`\n2. **Event Publishing Phase**: For each eligible subscription, publish `BillingDueEvent{subscription_id, billing_date, idempotency_key}` to the renewal queue\n3. **Processing Phase**: Renewal workers consume events and execute billing logic within database transactions\n4. **Completion Phase**: Update subscription's `next_billing_date` and `last_billing_date` fields, record audit events\n5. **Failure Handling Phase**: Failed events retry with exponential backoff, with alerts after multiple failures\n\nThis architecture provides several key benefits for subscription billing reliability:\n\n**Exactly-Once Processing**: The combination of idempotency keys and event-driven processing ensures each billing cycle is charged exactly once, even with system failures or retries.\n\n**Graceful Failure Handling**: Individual renewal failures don't impact other customers. Failed renewals automatically retry while successful ones proceed normally.\n\n**Audit Trail**: Every billing event is recorded with timestamps, processing results, and failure reasons. This audit trail is crucial for customer support and financial reconciliation.\n\n**Horizontal Scaling**: Multiple renewal workers can process events in parallel, allowing the system to scale renewal processing capacity independently from the scheduling component.\n\n### Dunning and Grace Period Policies\n\nWhen subscription payments fail, the system enters a carefully orchestrated dunning process designed to recover revenue while maintaining positive customer relationships. Dunning management balances aggressive payment collection with customer retention, using progressively escalating communication and access restrictions.\n\nThink of dunning like a library's approach to overdue books. The library doesn't immediately ban patrons when books are late - instead, they start with gentle email reminders, then firmer notices, and finally restrict borrowing privileges only after extended non-compliance. Throughout this process, patrons can restore good standing by simply returning books and paying modest late fees.\n\nSubscription dunning follows similar principles but with more sophisticated timing and communication strategies. The goal is to recover failed payments while preserving long-term customer value and minimizing involuntary churn.\n\n**Grace Period Configuration**: The grace period defines how long customers retain service access after payment failure. This policy varies significantly based on business model and customer segment:\n\n| Customer Segment | Grace Period | Access Policy | Rationale |\n|------------------|--------------|---------------|-----------|\n| Enterprise Plans | 7-14 days | Full access maintained | High LTV, complex procurement processes |\n| Annual Subscribers | 5-7 days | Full access maintained | Strong commitment signal, seasonal payment issues |\n| Monthly Consumer | 3-5 days | Limited access or full restriction | Higher churn rate, faster resolution needed |\n| Trial Conversions | 1-2 days | Immediate restriction | Lower engagement, price-sensitive segment |\n\nDuring the grace period, the system implements a structured retry schedule that balances collection success with customer experience:\n\n**Immediate Retry (T+0)**: Attempt payment collection within 1 hour of initial failure. Many payment failures are temporary (insufficient funds that resolve quickly, temporary network issues) and succeed on immediate retry.\n\n**Short-Term Retries (T+1 to T+3 days)**: Retry payment every 24 hours during the first three days. This catches customers who need time to update payment methods or resolve banking issues.\n\n**Extended Retries (T+4 to T+7 days)**: Retry every 48-72 hours during the extended grace period. At this point, also escalate to email and in-app notifications requesting payment method updates.\n\n**Final Attempt (T+7 days)**: Make final payment attempt before transitioning subscription to `unpaid` status. Send clear communication about impending service suspension and provide easy payment recovery options.\n\nThe dunning communication strategy escalates in tone and urgency while maintaining professional, helpful messaging:\n\n| Retry Attempt | Communication Type | Message Tone | Call-to-Action |\n|---------------|-------------------|--------------|----------------|\n| 1st Failure | Email notification | Informational | \"Update payment method\" |\n| 2nd Attempt | Email + In-app banner | Concerned | \"Avoid service interruption\" |\n| 3rd Attempt | Email + Account restriction | Urgent | \"Immediate action required\" |\n| Final Notice | Email + SMS (if enabled) | Final warning | \"Service suspended in 24 hours\" |\n\n**Smart Retry Logic**: Modern dunning systems implement intelligent retry timing based on failure codes from payment processors. Different failure types suggest different retry strategies:\n\n```\nInsufficient Funds (decline_code: insufficient_funds):\n  - Retry after 3 days (payday timing)\n  - Retry after 7 days (next payday)\n  - Higher success rate on Fridays and first of month\n\nCard Expired (decline_code: expired_card):\n  - Immediate retry (customer may have updated)\n  - Email notification to update payment method\n  - No point in automatic retries without customer action\n\nNetwork Error (decline_code: processing_error):\n  - Immediate retry\n  - Retry after 1 hour\n  - Treat as temporary technical issue\n```\n\n**Revenue Recovery Optimization**: Effective dunning processes can recover 15-40% of initially failed payments through strategic timing and communication. The key metrics to track include:\n\n- **Recovery Rate**: Percentage of failed payments ultimately collected during dunning period\n- **Recovery Time**: Average days between failure and successful collection  \n- **Involuntary Churn Rate**: Percentage of customers lost due to payment failures (vs voluntary cancellations)\n- **Customer Satisfaction**: Support ticket volume and satisfaction scores during dunning periods\n\n**Dunning Automation Rules**: The system should automatically adjust dunning behavior based on customer history and payment patterns:\n\n**Good Payment History**: Customers with 12+ months of successful payments receive extended grace periods and gentler communication, recognizing that payment failures are likely temporary issues rather than inability to pay.\n\n**New Customers**: Recent subscribers receive accelerated dunning with proactive support outreach, as payment failures often indicate setup issues rather than financial problems.\n\n**High-Value Customers**: Accounts with high monthly values or annual contracts trigger immediate human intervention alongside automated dunning, ensuring personalized support for revenue-critical relationships.\n\n> **Dunning Best Practice**: Always provide customers with clear self-service options to resolve payment issues. Include direct links to update payment methods, view current balances, and contact support. Many customers want to resolve payment issues quickly but need easy paths to do so.\n\n### Implementation Guidance\n\nThe subscription lifecycle management system requires careful coordination between state management, payment processing, and customer communication. This implementation guidance provides the foundational code structure and core logic patterns needed to build reliable subscription billing.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option | Rationale |\n|-----------|---------------|-----------------|-----------|\n| State Machine | Enum + switch statements | State pattern with transition validation | Start simple, refactor as complexity grows |\n| Background Jobs | APScheduler (Python) | Celery + Redis | APScheduler sufficient for moderate scale |\n| Event Queue | Database table + polling | Redis/RabbitMQ message queue | Database approach simpler for MVP |\n| Retry Logic | Custom exponential backoff | Tenacity library | Tenacity provides robust retry patterns |\n| Audit Logging | Structured logging to files | Centralized logging (ELK stack) | File logging adequate for single instance |\n\n**Recommended Project Structure:**\n\n```\nsubscription_billing/\n  subscription/\n    __init__.py\n    models.py              # Subscription entity and state definitions\n    lifecycle.py           # State machine and transition logic\n    renewal_processor.py   # Billing cycle processing\n    dunning_manager.py     # Failed payment handling\n    state_machine.py       # State transition validation\n  billing/\n    invoice_generator.py   # Invoice creation (next section)\n    payment_processor.py   # Payment gateway integration\n  events/\n    __init__.py\n    event_publisher.py     # Event publishing infrastructure\n    handlers.py            # Event handlers for lifecycle events\n  jobs/\n    __init__.py\n    renewal_scheduler.py   # Cron job for identifying due renewals\n    dunning_scheduler.py   # Scheduled dunning operations\n```\n\n**Core Infrastructure - Event System:**\n\n```python\nfrom enum import Enum\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, Optional\nfrom uuid import UUID\nimport logging\n\nclass SubscriptionEventType(Enum):\n    CREATED = \"subscription.created\"\n    ACTIVATED = \"subscription.activated\" \n    RENEWED = \"subscription.renewed\"\n    PAYMENT_FAILED = \"subscription.payment_failed\"\n    CANCELLED = \"subscription.cancelled\"\n    PAUSED = \"subscription.paused\"\n    RESUMED = \"subscription.resumed\"\n\nclass SubscriptionEvent:\n    def __init__(self, event_type: SubscriptionEventType, subscription_id: UUID, \n                 data: Dict[str, Any], idempotency_key: Optional[str] = None):\n        self.event_id = UUID.generate()\n        self.event_type = event_type\n        self.subscription_id = subscription_id\n        self.data = data\n        self.idempotency_key = idempotency_key or f\"{subscription_id}_{event_type.value}_{int(datetime.utcnow().timestamp())}\"\n        self.created_at = datetime.utcnow()\n\nclass EventPublisher:\n    def __init__(self, database_manager: DatabaseManager):\n        self.db = database_manager\n        self.logger = logging.getLogger(__name__)\n\n    def publish(self, event: SubscriptionEvent) -> bool:\n        \"\"\"Publish event to event store with idempotency protection\"\"\"\n        with self.db.transaction(ISOLATION_LEVEL_SERIALIZABLE):\n            # Check for duplicate events\n            existing = self.db.execute(\n                \"SELECT event_id FROM subscription_events WHERE idempotency_key = %s\",\n                (event.idempotency_key,)\n            ).fetchone()\n            \n            if existing:\n                self.logger.info(f\"Duplicate event {event.idempotency_key} ignored\")\n                return False\n            \n            # Insert new event\n            self.db.execute(\"\"\"\n                INSERT INTO subscription_events (event_id, event_type, subscription_id, \n                                               data, idempotency_key, created_at)\n                VALUES (%s, %s, %s, %s, %s, %s)\n            \"\"\", (event.event_id, event.event_type.value, event.subscription_id,\n                  json.dumps(event.data), event.idempotency_key, event.created_at))\n            \n            return True\n```\n\n**Core Infrastructure - Audit Logging:**\n\n```python\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom typing import Optional, Dict, Any\n\nclass AuditEventType(Enum):\n    SUBSCRIPTION_STATE_CHANGE = \"subscription.state_change\"\n    PAYMENT_ATTEMPT = \"payment.attempt\"\n    BILLING_CYCLE_PROCESSED = \"billing.cycle_processed\"\n    DUNNING_ACTION = \"dunning.action\"\n\n@dataclass\nclass AuditEvent:\n    event_type: AuditEventType\n    entity_id: UUID\n    entity_type: str\n    changes: Dict[str, Any]\n    actor_id: Optional[UUID]\n    metadata: Dict[str, Any]\n    timestamp: datetime\n\nclass AuditLogger:\n    def __init__(self, database_manager: DatabaseManager):\n        self.db = database_manager\n\n    def log_event(self, event_type: AuditEventType, entity_id: UUID, \n                  entity_type: str, changes: Dict[str, Any], \n                  actor_id: Optional[UUID] = None, \n                  metadata: Dict[str, Any] = None) -> None:\n        \"\"\"Record audit event for compliance and debugging\"\"\"\n        audit_event = AuditEvent(\n            event_type=event_type,\n            entity_id=entity_id, \n            entity_type=entity_type,\n            changes=changes,\n            actor_id=actor_id,\n            metadata=metadata or {},\n            timestamp=datetime.utcnow()\n        )\n        \n        with self.db.transaction(ISOLATION_LEVEL_SERIALIZABLE):\n            self.db.execute(\"\"\"\n                INSERT INTO audit_log (event_type, entity_id, entity_type, changes,\n                                     actor_id, metadata, timestamp)\n                VALUES (%s, %s, %s, %s, %s, %s, %s)\n            \"\"\", (audit_event.event_type.value, audit_event.entity_id,\n                  audit_event.entity_type, json.dumps(audit_event.changes),\n                  audit_event.actor_id, json.dumps(audit_event.metadata),\n                  audit_event.timestamp))\n```\n\n**Core Logic Skeleton - Subscription Lifecycle Manager:**\n\n```python\nfrom enum import Enum\nfrom datetime import datetime, timedelta\nfrom typing import Optional, Dict, Any\nfrom decimal import Decimal\n\nclass SubscriptionStatus(Enum):\n    INCOMPLETE = \"incomplete\"\n    TRIALING = \"trialing\" \n    ACTIVE = \"active\"\n    PAST_DUE = \"past_due\"\n    UNPAID = \"unpaid\"\n    CANCELLED = \"cancelled\"\n    PAUSED = \"paused\"\n\nclass SubscriptionLifecycleManager:\n    def __init__(self, database_manager: DatabaseManager, \n                 event_publisher: EventPublisher,\n                 audit_logger: AuditLogger):\n        self.db = database_manager\n        self.events = event_publisher\n        self.audit = audit_logger\n\n    def create_subscription(self, customer_id: UUID, plan_id: UUID, \n                          payment_method_id: UUID, trial_end_date: Optional[datetime] = None) -> Subscription:\n        \"\"\"Create new subscription for customer with specified plan\"\"\"\n        with self.db.transaction(ISOLATION_LEVEL_SERIALIZABLE):\n            # TODO 1: Load plan details to determine trial period and billing interval\n            # TODO 2: Calculate billing_cycle_anchor based on plan interval (monthly = day of month, yearly = day of year)\n            # TODO 3: Set initial status (trialing if trial period, incomplete if payment setup needed)\n            # TODO 4: Calculate next_billing_date based on trial_end_date or immediate billing\n            # TODO 5: Insert subscription record with all calculated fields\n            # TODO 6: Publish SUBSCRIPTION_CREATED event with plan and customer details\n            # TODO 7: Log audit event for subscription creation\n            # TODO 8: Return created subscription object\n            pass\n\n    def transition_state(self, subscription_id: UUID, new_status: SubscriptionStatus, \n                        reason: str, actor_id: Optional[UUID] = None) -> bool:\n        \"\"\"Transition subscription to new state with validation and audit trail\"\"\"\n        with self.db.transaction(ISOLATION_LEVEL_SERIALIZABLE):\n            # TODO 1: Load current subscription with row-level lock (SELECT FOR UPDATE)\n            # TODO 2: Validate state transition is allowed (use transition matrix)\n            # TODO 3: Update subscription status and transition timestamp\n            # TODO 4: Record state change in audit log with old/new status and reason  \n            # TODO 5: Publish appropriate event based on new state\n            # TODO 6: Execute state-specific side effects (provision access, send notifications)\n            # Hint: Use a transition validation table to check current_state -> new_state is valid\n            pass\n\n    def process_renewal(self, subscription_id: UUID, billing_date: datetime, \n                       idempotency_key: str) -> bool:\n        \"\"\"Process recurring billing for active subscription\"\"\"\n        with self.db.transaction(ISOLATION_LEVEL_SERIALIZABLE):\n            # TODO 1: Check idempotency - return True if already processed this billing cycle\n            # TODO 2: Load subscription and verify it's in renewable state (active, trialing)\n            # TODO 3: Calculate billing period (start_date = last_billing_date, end_date = next_billing_date)\n            # TODO 4: Generate invoice for base plan charges (delegate to invoice generator)\n            # TODO 5: Attempt payment collection (delegate to payment processor)\n            # TODO 6: Handle payment result - update next_billing_date if successful, start dunning if failed\n            # TODO 7: Update subscription's last_billing_date and billing cycle count\n            # TODO 8: Publish SUBSCRIPTION_RENEWED event with billing details\n            # Hint: Use idempotency_key = f\"{subscription_id}_{billing_date.strftime('%Y-%m-%d')}\"\n            pass\n\n    def cancel_subscription(self, subscription_id: UUID, cancel_at_period_end: bool = True,\n                          reason: str = \"customer_request\", actor_id: Optional[UUID] = None) -> bool:\n        \"\"\"Cancel subscription immediately or at end of current billing period\"\"\"\n        with self.db.transaction(ISOLATION_LEVEL_SERIALIZABLE):\n            # TODO 1: Load subscription and verify it's cancellable (not already cancelled)\n            # TODO 2: If cancel_at_period_end=False, transition to cancelled immediately\n            # TODO 3: If cancel_at_period_end=True, set cancelled_at = current_period_end, keep status active\n            # TODO 4: Record cancellation reason and schedule termination job if needed\n            # TODO 5: Publish SUBSCRIPTION_CANCELLED event with cancellation details\n            # TODO 6: Log audit event with cancellation reason and effective date\n            # Hint: Use a separate cancelled_at field rather than changing status immediately\n            pass\n```\n\n**Core Logic Skeleton - Dunning Manager:**\n\n```python\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Any\nimport time\n\nclass DunningAction(Enum):\n    RETRY_PAYMENT = \"retry_payment\"\n    SEND_EMAIL = \"send_email\" \n    RESTRICT_ACCESS = \"restrict_access\"\n    SUSPEND_SUBSCRIPTION = \"suspend_subscription\"\n\nclass DunningManager:\n    def __init__(self, database_manager: DatabaseManager,\n                 payment_processor: PaymentProcessor,\n                 notification_service: NotificationService):\n        self.db = database_manager\n        self.payment_processor = payment_processor\n        self.notifications = notification_service\n\n    def handle_payment_failure(self, subscription_id: UUID, invoice_id: UUID, \n                              failure_reason: str) -> None:\n        \"\"\"Initialize dunning process for failed payment\"\"\"\n        with self.db.transaction(ISOLATION_LEVEL_SERIALIZABLE):\n            # TODO 1: Transition subscription to past_due status if currently active\n            # TODO 2: Create dunning_attempts record with failure details and retry schedule\n            # TODO 3: Schedule immediate retry attempt (many failures are temporary)\n            # TODO 4: Send initial payment failure notification to customer\n            # TODO 5: Log audit event for dunning process start\n            # Hint: Store retry_count and next_retry_date in dunning_attempts table\n            pass\n\n    def process_dunning_retry(self, subscription_id: UUID) -> bool:\n        \"\"\"Execute scheduled dunning retry attempt\"\"\"\n        with self.db.transaction(ISOLATION_LEVEL_SERIALIZABLE):\n            # TODO 1: Load subscription and outstanding invoice details\n            # TODO 2: Check if still within dunning window (not exceeded max retry count)\n            # TODO 3: Attempt payment collection using stored payment method\n            # TODO 4: If successful: transition to active, clear dunning state, extend billing period\n            # TODO 5: If failed: increment retry count, schedule next attempt with backoff\n            # TODO 6: If retry limit exceeded: transition to unpaid status, suspend access\n            # TODO 7: Send appropriate notification based on retry result\n            # TODO 8: Log audit event for dunning attempt\n            # Hint: Use exponential backoff - day 1, 3, 7, 14 for retry timing\n            pass\n\n    def calculate_next_retry_date(self, retry_count: int, last_attempt: datetime) -> datetime:\n        \"\"\"Calculate next retry date using exponential backoff with jitter\"\"\"\n        # TODO 1: Define base retry intervals [1, 3, 7, 14] days for attempts 1-4\n        # TODO 2: Add random jitter (±2 hours) to prevent thundering herd\n        # TODO 3: Respect business hours - schedule retries during 9AM-5PM customer timezone\n        # TODO 4: Return calculated datetime for next retry attempt\n        # Hint: Use random.uniform(-2, 2) for jitter in hours\n        pass\n```\n\n**Milestone Checkpoint:**\n\nAfter implementing the subscription lifecycle management:\n\n1. **Unit Test Coverage**: Run `python -m pytest subscription/test_lifecycle.py -v` and verify:\n   - All state transitions are validated correctly\n   - Renewal processing handles idempotency \n   - Dunning retries follow exponential backoff\n   - Audit events are created for all state changes\n\n2. **Integration Test**: Create a test subscription and verify:\n   - New subscription starts in correct state (trialing or active)\n   - Trial expiration triggers billing attempt\n   - Payment failures initiate dunning process\n   - Successful dunning recovery restores active status\n   - Cancellation respects at_period_end setting\n\n3. **Manual Verification**: \n   - Check database - subscription state changes should have corresponding audit_log entries\n   - Verify idempotency - processing the same renewal twice should not create duplicate charges\n   - Test dunning - failed payments should schedule retry attempts with correct timing\n\n**Common Issues and Debugging:**\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---------|--------------|-----------|-----|\n| Duplicate renewals | Missing idempotency check | Check subscription_events table for duplicate idempotency_key | Add unique constraint on idempotency_key |\n| State transitions fail | Invalid transition attempted | Check audit_log for rejected transitions | Add transition validation matrix |\n| Dunning not triggering | Cron job not running or query incorrect | Check dunning_attempts table creation | Verify scheduler configuration and SQL query |\n| Payment retries too aggressive | Incorrect backoff calculation | Log retry_count and next_retry_date | Implement exponential backoff correctly |\n\n\n## Proration and Plan Changes\n\n> **Milestone(s):** Milestone 3 (Proration & Plan Changes) - implements upgrade/downgrade with prorated charges and credits for mid-cycle plan changes\n\n### Mental Model: Partial Refunds and Charges\n\nThink of proration like your monthly gym membership that you upgrade mid-month from Basic ($30) to Premium ($60). When you upgrade on day 15 of a 30-day billing cycle, you've already paid for the full month of Basic service, but now you want Premium for the remaining 15 days. The gym needs to figure out: \"How much extra should we charge for the upgrade?\" They calculate that you used half your Basic membership (15 days worth = $15), so you have $15 of unused Basic time. Premium costs $60, so for 15 days it's $30. The additional charge is $30 - $15 = $15.\n\nThis same logic applies when you downgrade. If you switch from Premium to Basic mid-cycle, you've overpaid and deserve a credit for the difference. The gym calculates how much Premium time you have left, converts it to Basic pricing, and either refunds the difference or applies it as credit to your account.\n\n**Proration** is this fair calculation system that ensures customers pay exactly for what they use, even when they change plans mid-cycle. It prevents both customer frustration (\"Why am I paying for features I'm not using?\") and business revenue leakage (\"Why are we giving away premium features for basic pricing?\").\n\nThe mathematical challenge is handling edge cases: What happens during February with 28 days when your billing cycle started on a 31-day month? What about timezone differences when a customer upgrades at 11:59 PM? How do you round fractions of cents fairly across thousands of customers? These details can make or break the fairness and accuracy of your billing system.\n\n![Plan Change and Proration Flow](./diagrams/plan-change-flow.svg)\n\n### Proration Calculation Algorithms\n\nProration calculations form the mathematical foundation for fair billing when customers change their subscription plans mid-cycle. The core principle is proportional allocation: customers should pay for exactly the service they receive, regardless of when they make changes during their billing period.\n\n#### Time-Based Proration Formula\n\nTime-based proration calculates charges based on the remaining days in the current billing cycle. This is the most common proration method for subscription billing systems.\n\n| Variable | Description | Example Value |\n|----------|-------------|---------------|\n| `days_remaining` | Days left in current billing cycle | 15 |\n| `total_cycle_days` | Total days in current billing period | 30 |\n| `old_plan_price` | Monthly price of current plan | $30.00 |\n| `new_plan_price` | Monthly price of target plan | $60.00 |\n| `usage_factor` | Fraction of cycle remaining | 0.5 (15/30) |\n\nThe proration algorithm follows these steps:\n\n1. **Calculate the usage factor** by dividing remaining days by total cycle days. This gives the proportion of the billing cycle that will use the new plan.\n\n2. **Determine unused value from the old plan** by multiplying the old plan price by the usage factor. This represents the monetary value of service time the customer has already paid for but won't receive.\n\n3. **Calculate new plan cost for remaining period** by multiplying the new plan price by the usage factor. This represents the cost of providing the new service level for the remaining time.\n\n4. **Compute the proration amount** as the difference between new plan cost and unused old plan value. Positive values indicate additional charges; negative values indicate credits owed.\n\n5. **Handle currency precision** by rounding to the smallest currency unit (cents) using consistent rounding rules across all calculations.\n\n> **Key Insight**: The proration calculation must be deterministic and repeatable. Running the same calculation multiple times with identical inputs must always produce the same result, even if processed days apart.\n\n#### Quantity-Based Proration Formula\n\nQuantity-based proration applies when plan changes involve user seats, storage limits, or other measurable quantities rather than time periods.\n\n| Variable | Description | Example Value |\n|----------|-------------|---------------|\n| `old_quantity` | Current quantity (seats, GB, etc.) | 5 seats |\n| `new_quantity` | Target quantity after change | 8 seats |\n| `unit_price` | Price per unit for remaining period | $10/seat |\n| `days_remaining` | Days left in billing cycle | 15 |\n| `total_cycle_days` | Total days in billing period | 30 |\n\nQuantity-based proration follows this algorithm:\n\n1. **Calculate the quantity difference** between new and old quantities. This determines how many additional units require billing.\n\n2. **Determine the time factor** using the same method as time-based proration (remaining days divided by total cycle days).\n\n3. **Calculate unit cost for remaining period** by multiplying the unit price by the time factor.\n\n4. **Compute total proration charge** by multiplying the quantity difference by the unit cost for the remaining period.\n\n5. **Apply minimum and maximum quantity constraints** as defined by the plan rules to ensure the change is within allowed boundaries.\n\n#### Combined Proration Scenarios\n\nReal-world plan changes often involve both time and quantity adjustments simultaneously. For example, upgrading from a Basic plan (5 seats, $50/month) to a Professional plan (unlimited seats, $100/month) mid-cycle requires calculating both the base plan change and any quantity adjustments.\n\nThe combined algorithm processes these changes in sequence:\n\n1. **Calculate base plan proration** using time-based formulas for the plan-level pricing difference.\n\n2. **Calculate quantity adjustments** using quantity-based formulas for any seat or limit changes.\n\n3. **Sum all proration components** to determine the total adjustment amount.\n\n4. **Validate the total amount** against business rules such as maximum single-transaction limits or credit balance caps.\n\n#### Currency and Precision Handling\n\nProration calculations must maintain financial precision to prevent accumulated errors across thousands of transactions. The system stores all monetary values in the smallest currency unit (cents for USD) and performs all calculations using integer arithmetic.\n\n| Precision Rule | Description | Implementation |\n|----------------|-------------|----------------|\n| Currency Storage | Store amounts as integers in smallest unit | `amount_cents: int` |\n| Division Rounding | Use consistent rounding for fractional cents | Round half up (0.5 → 1) |\n| Calculation Order | Perform multiplication before division | `(price * days) / total_days` |\n| Result Validation | Verify totals match expected ranges | Check against plan min/max prices |\n\n> **Critical Warning**: Floating-point arithmetic can introduce rounding errors that accumulate across many customers. Always use integer arithmetic with the smallest currency unit to maintain exact precision in financial calculations.\n\n### ADR: Credit Balance Management\n\n> **Decision: Customer Credit Balance Architecture**\n> \n> **Context**: When customers downgrade plans or receive refunds from proration calculations, the system must decide how to handle credit amounts. Credits could be applied immediately to reduce current invoices, stored as account balance for future use, or processed as direct refunds to the customer's payment method.\n> \n> **Options Considered**:\n> 1. **Immediate Credit Application**: Credits automatically reduce the next invoice amount\n> 2. **Account Credit Balance**: Credits accumulate in customer account for flexible future use\n> 3. **Direct Refund Processing**: Credits trigger immediate refunds to original payment method\n> \n> **Decision**: Implement account credit balance with automatic application to future invoices\n> \n> **Rationale**: Account credit balances provide the optimal balance between customer flexibility and operational simplicity. Immediate application works only when invoices are pending, missing opportunities for mid-cycle credits. Direct refunds create payment processing overhead and potential fraud concerns with frequent small refunds. Account balances handle all timing scenarios while maintaining customer transparency.\n> \n> **Consequences**: Requires additional database storage for credit tracking, audit trail for credit movements, and customer portal visibility into credit balance. Enables superior customer experience with flexible credit usage and simplified customer service operations.\n\n| Option | Pros | Cons |\n|--------|------|------|\n| Immediate Credit Application | Simple implementation, no additional storage | Only works with pending invoices, loses mid-cycle credits |\n| Account Credit Balance | Flexible timing, handles all scenarios, customer-friendly | Requires credit management system, additional complexity |\n| Direct Refund Processing | Immediate customer satisfaction, clean accounting | Payment processing fees, fraud risks, operational overhead |\n\nThe credit balance architecture implements these components:\n\n**Credit Balance Storage**: Each `Customer` entity includes a `credit_balance_cents` field that tracks the accumulated credit amount. This balance persists across billing cycles and plan changes, providing continuity for customers with varying usage patterns.\n\n**Credit Transaction Logging**: Every credit application, whether from proration calculations, manual adjustments, or promotional offers, generates an `AuditEvent` record with complete transaction details. This creates an immutable audit trail for financial reconciliation and customer service inquiries.\n\n**Automatic Credit Application**: During invoice generation, the billing engine automatically applies available credit balance to reduce the invoice total. Credits apply before payment processing, reducing the amount charged to the customer's payment method.\n\n**Credit Balance Limits**: The system enforces maximum credit balance limits per customer to prevent abuse and manage financial exposure. Excess credits beyond the limit trigger alternative handling such as direct refunds or promotional extensions.\n\n#### Credit Application Algorithm\n\nThe credit application process follows these steps during invoice generation:\n\n1. **Retrieve customer credit balance** from the database with row-level locking to prevent concurrent modifications during the application process.\n\n2. **Calculate applicable credit amount** as the minimum of available credit balance and outstanding invoice amount. This ensures credits never create negative invoice totals.\n\n3. **Update customer credit balance** by subtracting the applied amount using atomic database operations to maintain consistency.\n\n4. **Apply credit to invoice** by adding a credit line item that reduces the total amount due before payment processing.\n\n5. **Log credit application transaction** with complete details for audit trail and customer visibility.\n\n6. **Handle remaining balance** by either charging the customer for any remaining invoice amount or noting full payment via credit if the balance covers the entire invoice.\n\n### Common Proration Pitfalls\n\nProration calculations contain numerous edge cases that can cause billing errors, customer complaints, and revenue discrepancies. Understanding these pitfalls helps developers build robust billing systems that handle real-world complexity gracefully.\n\n#### ⚠️ **Pitfall: Calendar Month Variations**\n\n**Description**: Calculating proration based on \"days in month\" without considering calendar variations leads to inconsistent billing amounts. A customer who upgrades on January 15th (31-day month) receives different proration than one who upgrades on February 15th (28-day month), even though both upgrade mid-cycle.\n\n**Why It's Wrong**: Customers expect consistent proration logic regardless of calendar quirks. Variable month lengths create apparent unfairness where identical timing produces different charges.\n\n**How to Fix**: Use billing cycle anchor dates rather than calendar months. If a customer's billing cycle runs from the 15th to the 14th each month, always calculate proration based on that specific cycle period, regardless of underlying calendar days.\n\n#### ⚠️ **Pitfall: Timezone Confusion in Proration Timing**\n\n**Description**: Using server timezone or customer timezone inconsistently when determining proration effective dates. A customer who upgrades at 11:59 PM in their timezone might be processed as upgrading the next day in server timezone, affecting proration calculations.\n\n**Why It's Wrong**: Proration amounts can change significantly based on which day the system considers the \"upgrade date.\" This creates unpredictable billing behavior and customer service issues.\n\n**How to Fix**: Always use the customer's account timezone for billing calculations and store the timezone-aware timestamp with each plan change event. Convert to UTC for database storage but perform all billing logic in customer timezone.\n\n#### ⚠️ **Pitfall: Double-Counting Credits During Multiple Plan Changes**\n\n**Description**: When customers make multiple plan changes within a single billing cycle, each change calculation might include credits from previous changes, leading to compound credit errors.\n\n**Why It's Wrong**: Customers receive excessive credits that reduce revenue and create accounting discrepancies. Multiple plan changes should calculate proration based on actual service periods, not overlapping credit calculations.\n\n**How to Fix**: Track plan change effective dates precisely and calculate proration only for the actual service period under each plan. Use a sequential approach where each plan change starts from the effective date of the previous change.\n\n#### ⚠️ **Pitfall: Rounding Errors Accumulating Across Customers**\n\n**Description**: Inconsistent rounding of fractional cents across proration calculations creates systematic bias that can add up to significant amounts across thousands of customers.\n\n**Why It's Wrong**: Even small rounding inconsistencies can result in meaningful revenue differences when applied across a large customer base. Regulatory and accounting requirements demand consistent financial precision.\n\n**How to Fix**: Implement standardized rounding rules (typically \"round half up\" for financial calculations) and apply them consistently across all proration scenarios. Document the rounding approach and verify it meets local financial regulations.\n\n#### ⚠️ **Pitfall: Proration on Trial Periods**\n\n**Description**: Applying proration calculations to customers who are still in trial periods, especially when trials have zero cost. The system might attempt to calculate credits or charges for \"upgrading\" from a free trial.\n\n**Why It's Wrong**: Trial periods should not generate proration charges since customers haven't paid for the trial service. Proration logic designed for paid plans doesn't apply to trial scenarios.\n\n**How to Fix**: Check subscription status before applying proration logic. For trial subscriptions, treat plan changes as immediate switches without proration. Begin proration calculations only after the trial period ends and paid billing begins.\n\n#### ⚠️ **Pitfall: Currency Conversion During Proration**\n\n**Description**: Performing currency conversion before or during proration calculations when customers change plans that involve different currencies. Exchange rate fluctuations can affect proration accuracy.\n\n**Why It's Wrong**: Currency conversion rates change continuously, making proration calculations non-deterministic. The same plan change processed at different times might yield different amounts due to exchange rate variations.\n\n**How to Fix**: Perform all proration calculations in the customer's account currency without conversion. If plan changes involve currency switches, treat them as separate operations: complete proration in the original currency, then apply the currency change for future billing cycles.\n\n#### ⚠️ **Pitfall: Negative Credit Balances**\n\n**Description**: Allowing customer credit balances to become negative due to calculation errors, failed credit applications, or manual adjustments without proper validation.\n\n**Why It's Wrong**: Negative credit balances represent debt owed by customers but tracked in the credit system rather than through normal invoice processes. This creates accounting confusion and collection challenges.\n\n**How to Fix**: Implement credit balance constraints that prevent negative values. When operations would result in negative credits, handle them through the regular billing process by generating invoices for the additional amounts owed.\n\n### Implementation Guidance\n\nThe proration and credit management system requires careful implementation to handle the mathematical complexity and edge cases inherent in mid-cycle billing adjustments. This implementation focuses on accuracy, auditability, and performance for high-volume billing operations.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Calculation Engine | Python Decimal with basic rounding | Custom financial arithmetic library |\n| Credit Storage | PostgreSQL with ACID transactions | Event-sourced credit ledger |\n| Currency Handling | Single currency with integer cents | Multi-currency with exchange rate API |\n| Audit Logging | Database audit table | Dedicated audit service with immutable log |\n| Proration Rules | Static configuration in code | Dynamic rule engine with business rules |\n\n#### Recommended File Structure\n\n```\nsubscription-billing/\n  src/\n    billing/\n      proration/\n        __init__.py\n        calculator.py           ← Core proration calculation engine\n        credit_manager.py       ← Customer credit balance management\n        plan_change_handler.py  ← Orchestrates plan changes with proration\n        exceptions.py           ← Proration-specific error types\n        models.py              ← Proration data structures\n      core/\n        money.py               ← Money type with currency handling\n        audit.py               ← Audit event logging\n        database.py            ← Database manager\n      tests/\n        test_proration.py      ← Proration calculation tests\n        test_credit_manager.py ← Credit management tests\n        test_plan_changes.py   ← End-to-end plan change tests\n```\n\n#### Core Money and Currency Infrastructure\n\n```python\n# billing/core/money.py\nfrom decimal import Decimal, ROUND_HALF_UP\nfrom typing import Optional\nimport re\n\nDECIMAL_PRECISION = Decimal('0.01')\nDEFAULT_CURRENCY = 'USD'\n\nSUPPORTED_CURRENCIES = {\n    'USD': {'symbol': '$', 'decimal_places': 2, 'minor_unit': 100},\n    'EUR': {'symbol': '€', 'decimal_places': 2, 'minor_unit': 100},\n    'GBP': {'symbol': '£', 'decimal_places': 2, 'minor_unit': 100},\n}\n\nclass Money:\n    \"\"\"Immutable money type that maintains financial precision.\"\"\"\n    \n    def __init__(self, amount_cents: int, currency_code: str):\n        if not isinstance(amount_cents, int):\n            raise ValueError(\"Amount must be an integer representing cents\")\n        if currency_code not in SUPPORTED_CURRENCIES:\n            raise ValueError(f\"Unsupported currency: {currency_code}\")\n        \n        self.amount_cents = amount_cents\n        self.currency_code = currency_code\n    \n    @classmethod\n    def from_decimal(cls, amount: Decimal, currency: str) -> 'Money':\n        \"\"\"Create Money from decimal amount with proper rounding.\"\"\"\n        if currency not in SUPPORTED_CURRENCIES:\n            raise ValueError(f\"Unsupported currency: {currency}\")\n        \n        minor_unit = SUPPORTED_CURRENCIES[currency]['minor_unit']\n        cents = int((amount * minor_unit).quantize(Decimal('1'), ROUND_HALF_UP))\n        return cls(cents, currency)\n    \n    def to_decimal(self) -> Decimal:\n        \"\"\"Convert Money to decimal representation.\"\"\"\n        minor_unit = SUPPORTED_CURRENCIES[self.currency_code]['minor_unit']\n        return Decimal(self.amount_cents) / minor_unit\n    \n    def __add__(self, other: 'Money') -> 'Money':\n        if self.currency_code != other.currency_code:\n            raise ValueError(\"Cannot add money with different currencies\")\n        return Money(self.amount_cents + other.amount_cents, self.currency_code)\n    \n    def __sub__(self, other: 'Money') -> 'Money':\n        if self.currency_code != other.currency_code:\n            raise ValueError(\"Cannot subtract money with different currencies\")\n        return Money(self.amount_cents - other.amount_cents, self.currency_code)\n    \n    def __mul__(self, factor: Decimal) -> 'Money':\n        \"\"\"Multiply money by decimal factor with proper rounding.\"\"\"\n        result_cents = (Decimal(self.amount_cents) * factor).quantize(Decimal('1'), ROUND_HALF_UP)\n        return Money(int(result_cents), self.currency_code)\n    \n    def __eq__(self, other) -> bool:\n        if not isinstance(other, Money):\n            return False\n        return (self.amount_cents == other.amount_cents and \n                self.currency_code == other.currency_code)\n```\n\n#### Proration Calculation Engine Skeleton\n\n```python\n# billing/proration/calculator.py\nfrom decimal import Decimal\nfrom datetime import datetime, date\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\n\nfrom ..core.money import Money, DECIMAL_PRECISION\nfrom .models import ProrationResult, ProrationContext\nfrom .exceptions import ProrationError\n\n@dataclass\nclass ProrationResult:\n    \"\"\"Result of a proration calculation with detailed breakdown.\"\"\"\n    credit_amount: Money\n    charge_amount: Money\n    net_amount: Money  # positive = charge, negative = credit\n    calculation_details: Dict\n    effective_date: datetime\n    \nclass ProrationCalculator:\n    \"\"\"Calculates prorated charges and credits for plan changes.\"\"\"\n    \n    def calculate_plan_change_proration(\n        self, \n        old_plan: 'Plan',\n        new_plan: 'Plan', \n        change_date: datetime,\n        billing_cycle_start: datetime,\n        billing_cycle_end: datetime\n    ) -> ProrationResult:\n        \"\"\"Calculate proration for mid-cycle plan changes.\n        \n        Args:\n            old_plan: Current subscription plan\n            new_plan: Target plan after change\n            change_date: When the change becomes effective\n            billing_cycle_start: Start of current billing period\n            billing_cycle_end: End of current billing period\n            \n        Returns:\n            ProrationResult with charge/credit amounts and calculation details\n        \"\"\"\n        # TODO 1: Validate that change_date falls within the current billing cycle\n        #         Raise ProrationError if change_date is outside cycle boundaries\n        \n        # TODO 2: Calculate total days in billing cycle\n        #         Use (billing_cycle_end - billing_cycle_start).days\n        #         Handle timezone-aware datetime objects properly\n        \n        # TODO 3: Calculate days remaining from change_date to cycle end\n        #         Use (billing_cycle_end - change_date).days\n        #         Ensure result is not negative\n        \n        # TODO 4: Calculate usage factor as Decimal(days_remaining) / Decimal(total_cycle_days)\n        #         This represents the fraction of cycle using the new plan\n        \n        # TODO 5: Calculate unused value from old plan\n        #         unused_value = old_plan.base_price * usage_factor\n        #         This is credit owed for unused time on old plan\n        \n        # TODO 6: Calculate new plan cost for remaining period\n        #         new_plan_cost = new_plan.base_price * usage_factor\n        #         This is charge for new plan during remaining time\n        \n        # TODO 7: Calculate net proration amount\n        #         net_amount = new_plan_cost - unused_value\n        #         Positive = customer owes money, Negative = customer gets credit\n        \n        # TODO 8: Create ProrationResult with calculated amounts and details dict\n        #         Include calculation breakdown for audit trail and customer transparency\n        \n        # Hint: All Money arithmetic should use the currency from old_plan\n        # Hint: Store intermediate calculations in calculation_details dict\n        pass\n    \n    def calculate_quantity_proration(\n        self,\n        plan: 'Plan',\n        old_quantity: int,\n        new_quantity: int,\n        change_date: datetime,\n        billing_cycle_start: datetime,\n        billing_cycle_end: datetime\n    ) -> ProrationResult:\n        \"\"\"Calculate proration for quantity changes (seats, storage, etc.).\"\"\"\n        # TODO 1: Validate quantity change parameters\n        #         Ensure new_quantity meets plan minimum and maximum limits\n        #         Verify change_date is within billing cycle\n        \n        # TODO 2: Calculate quantity difference (new_quantity - old_quantity)\n        #         This can be positive (increase) or negative (decrease)\n        \n        # TODO 3: Calculate time factor using same logic as plan change proration\n        #         time_factor = days_remaining / total_cycle_days\n        \n        # TODO 4: Get per-unit price for the plan\n        #         Check if plan uses per-seat, per-GB, or other unit pricing\n        \n        # TODO 5: Calculate unit cost for remaining period\n        #         unit_cost = per_unit_price * time_factor\n        \n        # TODO 6: Calculate total proration amount\n        #         total_amount = quantity_difference * unit_cost\n        \n        # TODO 7: Create ProrationResult with quantity-based calculation details\n        #         Include unit pricing and quantity change information\n        pass\n```\n\n#### Credit Balance Manager Skeleton\n\n```python\n# billing/proration/credit_manager.py\nfrom typing import Optional, List\nfrom uuid import UUID\nfrom datetime import datetime\n\nfrom ..core.money import Money\nfrom ..core.audit import AuditEventType\nfrom ..core.database import DatabaseManager\n\nclass CreditBalanceManager:\n    \"\"\"Manages customer credit balances and applications.\"\"\"\n    \n    def __init__(self, db_manager: DatabaseManager):\n        self.db = db_manager\n    \n    def apply_credit(\n        self, \n        customer_id: UUID, \n        amount: Money, \n        source: str, \n        reference_id: Optional[UUID] = None,\n        actor_id: Optional[UUID] = None\n    ) -> bool:\n        \"\"\"Add credit to customer's account balance.\n        \n        Args:\n            customer_id: Customer receiving credit\n            amount: Credit amount to add\n            source: Description of credit source (e.g., \"plan_downgrade\", \"refund\")\n            reference_id: Related transaction ID for audit trail\n            actor_id: ID of user/system making the change\n            \n        Returns:\n            True if credit applied successfully\n        \"\"\"\n        # TODO 1: Start database transaction with SERIALIZABLE isolation\n        #         Use self.db.transaction(ISOLATION_LEVEL_SERIALIZABLE)\n        \n        # TODO 2: Lock customer record for update to prevent concurrent modifications\n        #         SELECT customer credit_balance_cents FOR UPDATE WHERE customer_id = ?\n        \n        # TODO 3: Validate credit amount is positive\n        #         Raise ValueError if amount is negative or zero\n        \n        # TODO 4: Update customer credit balance\n        #         new_balance = current_balance + credit_amount\n        #         UPDATE customers SET credit_balance_cents = ? WHERE customer_id = ?\n        \n        # TODO 5: Create audit event for credit application\n        #         Use AuditEventType.CREDIT_APPLIED with amount and source details\n        #         Call self.log_event() with complete transaction details\n        \n        # TODO 6: Commit transaction and return success status\n        #         Handle database errors and rollback on failure\n        pass\n    \n    def consume_credit(\n        self, \n        customer_id: UUID, \n        amount_needed: Money,\n        actor_id: Optional[UUID] = None\n    ) -> Money:\n        \"\"\"Apply customer credit to reduce an amount owed.\n        \n        Args:\n            customer_id: Customer using credit\n            amount_needed: Total amount that could be reduced by credit\n            actor_id: ID of user/system applying credit\n            \n        Returns:\n            Money representing actual credit amount applied (may be less than requested)\n        \"\"\"\n        # TODO 1: Start database transaction with proper isolation\n        #         Lock customer record to prevent concurrent credit usage\n        \n        # TODO 2: Get current customer credit balance\n        #         SELECT credit_balance_cents FROM customers WHERE customer_id = ?\n        \n        # TODO 3: Calculate applicable credit amount\n        #         applied_credit = min(available_credit, amount_needed)\n        #         Cannot apply more credit than customer has or needs\n        \n        # TODO 4: Update customer credit balance\n        #         new_balance = current_balance - applied_credit\n        #         Ensure balance never goes negative\n        \n        # TODO 5: Create audit event for credit consumption\n        #         Log the credit usage with before/after balances\n        \n        # TODO 6: Return the actual credit amount applied\n        #         This may be less than amount_needed if insufficient credit\n        pass\n    \n    def get_credit_balance(self, customer_id: UUID) -> Money:\n        \"\"\"Get current credit balance for customer.\"\"\"\n        # TODO 1: Query customer credit balance from database\n        #         Handle case where customer doesn't exist\n        \n        # TODO 2: Convert stored cents to Money object\n        #         Use customer's default currency from account settings\n        pass\n```\n\n#### Plan Change Handler Skeleton\n\n```python\n# billing/proration/plan_change_handler.py\nfrom uuid import UUID\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom .calculator import ProrationCalculator\nfrom .credit_manager import CreditBalanceManager\nfrom ..core.money import Money\nfrom .exceptions import ProrationError, PlanChangeError\n\nclass PlanChangeHandler:\n    \"\"\"Orchestrates plan changes with proration calculations.\"\"\"\n    \n    def __init__(self, proration_calc: ProrationCalculator, credit_manager: CreditBalanceManager):\n        self.proration_calc = proration_calc\n        self.credit_manager = credit_manager\n    \n    def process_plan_upgrade(\n        self,\n        subscription_id: UUID,\n        new_plan_id: UUID,\n        effective_date: Optional[datetime] = None,\n        actor_id: Optional[UUID] = None\n    ) -> Dict:\n        \"\"\"Process subscription upgrade with proration charges.\"\"\"\n        # TODO 1: Load subscription and validate current state\n        #         Ensure subscription is active and not cancelled\n        #         Verify new_plan_id exists and is available for customer\n        \n        # TODO 2: Load current and target plans\n        #         Validate that target plan is actually an upgrade (higher tier/price)\n        #         Check plan compatibility and upgrade path rules\n        \n        # TODO 3: Determine effective date for change\n        #         Default to current datetime if not specified\n        #         Validate effective_date is not in the past\n        \n        # TODO 4: Calculate proration using ProrationCalculator\n        #         Get current billing cycle boundaries\n        #         Call calculate_plan_change_proration with all parameters\n        \n        # TODO 5: Process proration charges\n        #         If net_amount > 0, create invoice for additional charge\n        #         If net_amount < 0, apply credit to customer account\n        \n        # TODO 6: Update subscription with new plan\n        #         Change subscription.plan_id to new_plan_id\n        #         Record plan change event with effective date\n        \n        # TODO 7: Return plan change summary\n        #         Include proration details, new plan info, and effective date\n        pass\n    \n    def process_plan_downgrade(\n        self,\n        subscription_id: UUID,\n        new_plan_id: UUID,\n        effective_date: Optional[datetime] = None,\n        actor_id: Optional[UUID] = None\n    ) -> Dict:\n        \"\"\"Process subscription downgrade with proration credits.\"\"\"\n        # TODO 1: Load and validate subscription and plans similar to upgrade\n        #         Verify new plan is actually a downgrade\n        \n        # TODO 2: Calculate proration (will typically result in credit)\n        #         Use same ProrationCalculator.calculate_plan_change_proration\n        \n        # TODO 3: Apply credit to customer account\n        #         Use CreditBalanceManager.apply_credit for proration amount\n        #         Record credit source as \"plan_downgrade\"\n        \n        # TODO 4: Handle feature access changes\n        #         Immediately restrict access to features not in new plan\n        #         Update feature entitlements in subscription record\n        \n        # TODO 5: Update subscription and log downgrade event\n        #         Record reason for downgrade if provided\n        pass\n```\n\n#### Milestone Checkpoint\n\nAfter implementing the proration system, verify functionality with these tests:\n\n**Unit Tests**: Run `python -m pytest tests/test_proration.py -v`\nExpected output should show all proration calculation tests passing, including edge cases for calendar months, timezone handling, and currency precision.\n\n**Integration Tests**: Test complete plan change workflows:\n1. Create subscription with monthly plan ($30/month)\n2. Upgrade to premium plan ($60/month) on day 15 of 30-day cycle\n3. Verify proration charge of $15 (half month difference)\n4. Check customer credit balance remains unchanged\n5. Confirm subscription reflects new plan and features\n\n**Manual Verification**:\n- Use billing admin interface to trigger plan change\n- Verify proration calculation shows detailed breakdown\n- Confirm audit events recorded for all balance changes\n- Test edge cases: month boundaries, leap years, timezone differences\n\n**Common Issues to Check**:\n- Proration amounts should always be deterministic for same inputs\n- Currency precision should maintain cent accuracy\n- Credit balances should never become negative without explicit business logic\n- All plan changes should generate complete audit trails\n\n\n## Usage-Based Billing Engine\n\n> **Milestone(s):** Milestone 4 (Usage-Based Billing) - implements metered billing with usage tracking, aggregation, and reporting\n\n### Mental Model: Utility Metering\n\nThink of usage-based billing like your electricity meter at home. Every time you turn on a light, run the dishwasher, or charge your laptop, the meter records consumption. At the end of the month, the utility company reads your meter, calculates your total usage, applies their tiered pricing structure (first 500 kWh at $0.10, next 500 kWh at $0.12, etc.), and generates your bill.\n\nThe usage-based billing engine works exactly the same way. Instead of measuring kilowatt-hours, we might be measuring API calls, storage gigabytes, or video transcoding minutes. Instead of a physical meter, we have software that captures usage events. Instead of a meter reader visiting your house, we have automated aggregation processes that sum up consumption. And instead of utility rate schedules, we have pricing tiers defined in our subscription plans.\n\nJust like utility billing, the key challenges are accuracy (every usage event must be counted exactly once), timing (usage must be attributed to the correct billing period), and pricing complexity (different rates for different usage levels). The meter never lies, and neither should our usage tracking system.\n\nThis mental model helps us understand why certain architectural decisions matter. Just as utility companies need redundant meter readings and audit trails for regulatory compliance, we need idempotent event processing and complete usage records. Just as utilities batch-process millions of meter readings efficiently, we need scalable aggregation systems. And just as your electricity bill shows detailed breakdowns of usage and charges, our invoicing system must clearly explain usage-based fees to customers.\n\n### Usage Event Ingestion\n\nThe foundation of any usage-based billing system is reliable event ingestion. Usage events represent discrete measurable activities that customers perform within your service. These might be API requests, data processing jobs, storage operations, or any other billable activity. The ingestion system must handle high volumes of events while ensuring perfect accuracy and preventing duplicate charges.\n\n**Event Structure and Validation**\n\nEvery usage event follows a standardized structure that captures the essential billing information. The event must identify the customer, specify what type of activity occurred, record the quantity consumed, and timestamp when the activity took place. Additional metadata helps with debugging and provides context for customer support scenarios.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| event_id | UUID | Globally unique identifier for this specific event |\n| customer_id | UUID | Foreign key linking to the customer who performed this activity |\n| subscription_id | UUID | Optional foreign key to the specific subscription being billed |\n| event_type | str | Categorizes the type of billable activity (e.g., \"api_call\", \"storage_gb_hour\") |\n| quantity | Decimal | Precise measurement of consumption using arbitrary precision arithmetic |\n| timestamp | datetime | Server-side timestamp when the event was recorded (UTC) |\n| idempotency_key | str | Client-provided key for preventing duplicate event submission |\n| metadata | Dict | Additional context like user agent, IP address, or feature flags |\n| source_service | str | Which internal service generated this event for debugging |\n\nThe ingestion API validates every field before accepting events. Customer IDs must reference existing customers. Event types must match configured billable metrics. Quantities must be positive numbers with reasonable precision limits. Timestamps must fall within acceptable ranges (not too far in the past or future). Metadata must conform to size limits to prevent database bloat.\n\n**Idempotency and Deduplication Strategies**\n\nThe most critical requirement for usage event ingestion is preventing duplicate charges. Network retries, client-side bugs, and distributed system failures can all cause the same usage event to be submitted multiple times. Charging customers twice for the same API call or storage operation destroys trust and creates billing disputes.\n\n> **Decision: Client-Provided Idempotency Keys**\n> - **Context**: Usage events may be submitted multiple times due to network failures, client retries, or distributed system issues\n> - **Options Considered**: Server-generated deduplication, client-provided idempotency keys, event fingerprinting\n> - **Decision**: Require clients to provide idempotency keys with event submission\n> - **Rationale**: Client-provided keys give the event source control over deduplication semantics and work across service restarts\n> - **Consequences**: Clients must implement idempotency key generation, but we get reliable duplicate prevention\n\n| Option | Pros | Cons |\n|--------|------|------|\n| Server-generated deduplication | Simple client implementation | Cannot handle retries across service restarts |\n| Client-provided idempotency keys | Reliable across all failure modes | Requires client-side key management |\n| Event fingerprinting | Transparent to clients | Complex edge cases with similar events |\n\nThe idempotency key should be deterministic based on the usage activity itself. For example, an API request might use a combination of request ID, endpoint, and timestamp. A file upload might use the file hash and user ID. The key must uniquely identify the specific billable activity, not just the client request.\n\nWhen the ingestion service receives an event, it first checks if an event with the same idempotency key already exists. If found, it returns success without creating a duplicate record. If not found, it inserts the new event atomically. This check-and-insert operation must be atomic to handle concurrent submissions of the same event.\n\n**Event Processing Pipeline**\n\nUsage events flow through a multi-stage processing pipeline that validates, enriches, and prepares them for aggregation. Each stage has specific responsibilities and error handling requirements.\n\nThe validation stage ensures data quality and business rule compliance. It verifies that the customer has an active subscription that includes the billable metric. It checks that the event timestamp falls within acceptable bounds. It validates that the quantity is reasonable for the event type (e.g., API calls should have quantity 1, storage events might have fractional quantities).\n\nThe enrichment stage adds derived fields that simplify downstream processing. It calculates which billing period the event belongs to based on the customer's subscription cycle. It looks up pricing information for the event type. It adds geographic or regulatory metadata that affects billing calculations. It resolves the subscription plan version that was active when the event occurred.\n\nThe normalization stage converts events into a standardized format for aggregation. It handles unit conversions (e.g., bytes to gigabytes, milliseconds to hours). It applies any business logic for event grouping or categorization. It adds partition keys that optimize aggregation queries. It ensures consistent precision for decimal quantities.\n\n**Real-Time vs Batch Processing**\n\nUsage events can be processed immediately as they arrive or collected into batches for bulk processing. Each approach has different trade-offs for latency, throughput, and resource utilization.\n\nReal-time processing provides immediate feedback to customers about their usage and remaining quotas. It enables real-time rate limiting and usage alerts. It distributes processing load evenly over time rather than creating periodic spikes. However, it requires more complex infrastructure to handle traffic bursts and may have higher per-event overhead.\n\nBatch processing achieves higher throughput by amortizing processing costs across many events. It simplifies error handling and retry logic. It enables more sophisticated aggregation algorithms that consider the entire batch. However, it introduces processing delays and creates periodic resource spikes that must be provisioned for.\n\nMost production systems use a hybrid approach where high-priority events (quotas, alerts) are processed in real-time while bulk aggregation happens in periodic batches. This provides responsive user experience while maintaining processing efficiency.\n\n**Error Handling and Event Recovery**\n\nUsage event ingestion must handle various failure scenarios gracefully while preserving data integrity. Network timeouts, database connection failures, and validation errors all require different recovery strategies.\n\nTransient failures like network timeouts or temporary database unavailability should trigger automatic retries with exponential backoff. The retry logic must preserve idempotency by using the same idempotency key across all attempts. Clients should also implement retries with the same idempotency key to ensure end-to-end reliability.\n\nValidation errors like invalid customer IDs or malformed event types should be logged and returned immediately to the client. These events should not be retried automatically since they will continue to fail until the client fixes the data. However, they should be stored in a dead letter queue for debugging and potential manual recovery.\n\nProcessing failures during enrichment or normalization stages should be retried since they often involve temporary issues with external services. Failed events should be quarantined and processed separately to avoid blocking the healthy event stream. Processing delays should be monitored and alerted since they can affect billing accuracy.\n\n### ADR: Usage Aggregation Architecture\n\nUsage events must be aggregated into billing periods to calculate charges for each customer. The aggregation system processes potentially millions of individual events and produces summary records that feed into invoice generation. The architecture must balance processing efficiency, data consistency, and query performance.\n\n> **Decision: Batch Aggregation with Real-Time Approximation**\n> - **Context**: Usage events arrive continuously but billing calculations happen monthly, requiring efficient aggregation of large event volumes\n> - **Options Considered**: Pure real-time aggregation, pure batch aggregation, hybrid batch + real-time approximation\n> - **Decision**: Primary batch aggregation with real-time approximation for customer dashboards and quota enforcement\n> - **Rationale**: Batch processing handles billing-scale volumes efficiently while real-time approximation provides responsive user experience\n> - **Consequences**: More complex architecture but optimal for both billing accuracy and user experience\n\n| Option | Pros | Cons |\n|--------|------|------|\n| Pure real-time aggregation | Immediate accuracy, simple architecture | Poor performance at billing scale, expensive infrastructure |\n| Pure batch aggregation | Excellent throughput, cost-effective | Poor user experience, delayed quota enforcement |\n| Hybrid batch + real-time | Best of both approaches | Complex architecture, data consistency challenges |\n\n**Batch Aggregation Design**\n\nThe primary aggregation system processes usage events in scheduled batches, typically every few hours or daily. This approach maximizes throughput by processing large numbers of events together using optimized database queries and parallel processing techniques.\n\nThe batch processor groups events by customer, subscription, event type, and billing period. It calculates sum, count, maximum, and other aggregate functions depending on the billable metric. For example, API call events are summed to get total calls, while concurrent user events might use maximum values to determine peak usage.\n\nAggregation windows align with billing period boundaries to ensure accurate monthly totals. The processor maintains checkpoint records to track which events have been aggregated, enabling incremental processing and recovery from failures. It handles events that arrive late (after their billing period has ended) by updating historical aggregations and triggering billing corrections if necessary.\n\nThe output of batch aggregation feeds directly into invoice generation. These records represent the official usage totals used for billing calculations and must be completely accurate. They include detailed breakdowns by event type and time period to support customer inquiries and billing disputes.\n\n**Real-Time Approximation System**\n\nA separate real-time system provides approximate usage totals for customer dashboards and quota enforcement. This system prioritizes responsiveness over perfect accuracy, using techniques like sampling, estimation, and eventual consistency.\n\nReal-time aggregation maintains rolling windows of recent usage events using in-memory data structures. It provides fast lookups for current billing period totals and usage trends. The data may be slightly stale or approximate, but it updates within seconds of new events arriving.\n\nFor quota enforcement, the real-time system errs on the side of caution by overestimating usage when in doubt. This prevents customers from accidentally exceeding their limits while the approximation catches up. Periodic reconciliation with batch aggregation results corrects any overestimations.\n\nCustomer-facing dashboards clearly indicate when they're showing estimated vs final usage totals. During the billing period, customers see real-time estimates. After billing closes, they see the final calculated amounts that appear on their invoices.\n\n**Data Consistency and Reconciliation**\n\nThe hybrid architecture introduces potential inconsistencies between real-time approximations and batch aggregation results. The system must detect and resolve these discrepancies to maintain data integrity.\n\nReconciliation jobs compare real-time and batch totals for completed billing periods. Small differences (within expected tolerances) are logged but not acted upon. Larger discrepancies trigger investigation workflows that examine the underlying event data to identify the source of disagreement.\n\nWhen inconsistencies are detected, the batch aggregation results take precedence for billing purposes since they process complete event sets with full consistency guarantees. The real-time system updates its models and estimates based on the authoritative batch results.\n\nHistorical usage data remains immutable once billing closes to ensure audit trail integrity. Any corrections due to late-arriving events or processing errors are recorded as separate adjustment records rather than modifying original totals.\n\n### Overage and Tiered Usage Billing\n\nMost usage-based pricing models include base allowances with overage charges when customers exceed their plan limits. These pricing structures require sophisticated calculation logic that considers plan entitlements, usage tiers, and billing period boundaries.\n\n**Usage Allowances and Quota Management**\n\nEach subscription plan defines base allowances for various usage metrics. For example, a \"Professional\" plan might include 10,000 API calls, 100 GB of storage, and 50 hours of video transcoding per month. These allowances are included in the base subscription fee without additional charges.\n\n| Plan Component | Type | Description |\n|----------------|------|-------------|\n| base_allowance | int | Included quantity for this usage metric |\n| overage_rate_cents | int | Per-unit charge when usage exceeds allowance |\n| usage_metric | str | Specific billable activity this allowance covers |\n| reset_frequency | BillingInterval | How often the allowance resets (monthly, annually) |\n| soft_limit_threshold | float | Percentage of allowance that triggers usage warnings |\n| hard_limit_enabled | bool | Whether to block usage when allowance is exhausted |\n\nThe system tracks current usage against these allowances throughout the billing period. When customers approach their limits (typically at 80% and 95% thresholds), the system sends usage alert notifications. These alerts help customers manage their consumption and avoid unexpected overage charges.\n\nSome plans implement hard limits that prevent additional usage once allowances are exhausted. Others allow unlimited overage with per-unit billing. The quota management system enforces these policies in real-time using the approximation data while ensuring accurate billing using the batch aggregation results.\n\n**Tiered Overage Pricing**\n\nOverage charges often use tiered pricing structures where different usage levels have different per-unit rates. This mirrors utility billing models where higher consumption levels have higher marginal costs.\n\nFor example, API call overages might be priced as:\n- First 5,000 overage calls: $0.002 per call\n- Next 20,000 overage calls: $0.0015 per call  \n- Additional overage calls: $0.001 per call\n\nThe calculation engine processes usage through each tier sequentially. If a customer uses 30,000 overage calls, they pay the first-tier rate for the first 5,000 calls, the second-tier rate for the next 20,000 calls, and the third-tier rate for the remaining 5,000 calls.\n\n| Tier Definition | Field | Type | Description |\n|-----------------|-------|------|-------------|\n| tier_number | int | Sequential tier ordering (1, 2, 3, ...) |\n| min_quantity | int | Minimum usage level for this tier (inclusive) |\n| max_quantity | Optional[int] | Maximum usage level for this tier (None for unlimited) |\n| price_per_unit_cents | int | Per-unit charge for usage in this tier |\n| flat_fee_cents | int | One-time charge when entering this tier |\n\nThe tiered calculation logic must handle edge cases like partial tier usage, multiple billing periods, and plan changes mid-cycle. It maintains precision using integer arithmetic and the smallest currency units to avoid floating-point rounding errors.\n\n**Cross-Metric Dependencies and Bundling**\n\nSome pricing models include dependencies between different usage metrics. For example, a plan might bundle API calls and storage together, or provide discounts when customers use multiple services simultaneously.\n\nBundled allowances share usage quotas across multiple metrics. A customer might have \"10,000 combined API calls and webhook deliveries\" rather than separate allowances for each. The system tracks total usage across all bundled metrics and applies overage charges when the combined total exceeds the bundle allowance.\n\nTiered discounts apply different rates based on total spending or usage volume across all metrics. High-volume customers might receive better overage rates as they move into higher spending tiers. These calculations require aggregate usage data across all billable metrics for the customer.\n\nCross-metric calculations add complexity to the aggregation system since it must consider usage relationships rather than processing each metric independently. The calculation engine evaluates these dependencies after individual metric aggregation but before final invoice generation.\n\n**Billing Period Boundary Handling**\n\nUsage allowances and overage calculations must account for billing period boundaries, especially when customers change plans mid-cycle or when events arrive after billing has closed.\n\nPlan changes during a billing period require prorated allowance calculations. If a customer upgrades from a plan with 5,000 API call allowance to a plan with 15,000 allowance halfway through the month, they get 5,000 + (15,000 / 2) = 12,500 total allowance for that billing period. The overage calculation uses the higher tier rates for the entire period.\n\nLate-arriving events can affect overage calculations for closed billing periods. If events arrive after invoices are generated, the system must determine whether to issue credit adjustments or carry the usage forward to the next billing period. Most systems apply a grace period (e.g., 72 hours) for late events and generate credit adjustments for material changes.\n\nMulti-period aggregation handles customers with annual plans or custom billing cycles. The system maintains running totals across the entire subscription period while providing monthly breakdowns for customer reporting. Allowance resets and overage calculations align with the customer's specific billing cycle rather than calendar months.\n\n**Usage-Based Pricing Psychology**\n\nEffective usage-based pricing considers customer psychology and billing predictability. Customers prefer pricing models they can understand and budget for, even if those models are more expensive than purely usage-based alternatives.\n\nGenerous base allowances reduce billing anxiety by covering typical usage patterns without overage charges. Most customers should fall within their plan allowances most months. This makes the subscription feel predictable while still allowing monetization of high-usage customers through overage fees.\n\nClear usage monitoring and alerts help customers manage their consumption proactively. Real-time dashboards show current usage, remaining allowances, and projected monthly totals. Usage trend analysis helps customers understand their consumption patterns and choose appropriate plans.\n\nGraduated overage pricing with reasonable first-tier rates reduces sticker shock when customers first exceed their allowances. The highest overage rates should only apply to extremely high usage levels where customers clearly derive significant value from the service.\n\n### Implementation Guidance\n\nThe usage-based billing engine requires careful attention to data precision, event reliability, and scalable aggregation. The following implementation provides a foundation for accurate usage tracking while maintaining high throughput and low latency for customer-facing features.\n\n**Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Event Ingestion | HTTP REST API with JSON | Apache Kafka with schema registry |\n| Event Storage | PostgreSQL with partitioning | Apache Cassandra or ClickHouse |\n| Real-time Aggregation | Redis with rolling windows | Apache Flink or Kafka Streams |\n| Batch Processing | Python with pandas | Apache Spark or Airflow |\n| Metrics and Monitoring | Prometheus with Grafana | DataDog or New Relic |\n| Queue Management | PostgreSQL-based queues | Redis Streams or Amazon SQS |\n\n**Recommended File Structure**\n\n```\nsubscription-billing/\n  usage/\n    __init__.py\n    models.py              ← UsageEvent, PricingTier, UsageAggregation\n    ingestion.py           ← Event ingestion API and validation\n    aggregation.py         ← Batch aggregation engine\n    realtime.py            ← Real-time approximation system\n    pricing.py             ← Overage and tiered pricing calculations\n    quota.py               ← Quota enforcement and usage limits\n    events.py              ← Event publishing for usage alerts\n  tests/\n    test_usage_ingestion.py\n    test_aggregation.py\n    test_pricing_tiers.py\n```\n\n**Core Data Models**\n\n```python\nfrom decimal import Decimal, ROUND_HALF_UP\nfrom datetime import datetime, timezone\nfrom typing import Optional, Dict, Any\nimport uuid\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass UsageMetricType(Enum):\n    API_CALLS = \"api_calls\"\n    STORAGE_GB_HOURS = \"storage_gb_hours\"\n    BANDWIDTH_GB = \"bandwidth_gb\"\n    TRANSCODING_MINUTES = \"transcoding_minutes\"\n    ACTIVE_USERS = \"active_users\"\n\n@dataclass\nclass UsageEvent:\n    \"\"\"Single usage event representing billable activity.\"\"\"\n    event_id: uuid.UUID\n    customer_id: uuid.UUID\n    subscription_id: Optional[uuid.UUID]\n    event_type: str\n    quantity: Decimal\n    timestamp: datetime\n    idempotency_key: str\n    metadata: Dict[str, Any]\n    source_service: str\n    billing_period_start: Optional[datetime] = None\n    billing_period_end: Optional[datetime] = None\n    processed_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.timestamp.tzinfo is None:\n            self.timestamp = self.timestamp.replace(tzinfo=timezone.utc)\n\n@dataclass\nclass PricingTier:\n    \"\"\"Usage pricing tier with quantity ranges and rates.\"\"\"\n    tier_number: int\n    min_quantity: int\n    max_quantity: Optional[int]  # None for unlimited\n    price_per_unit_cents: int\n    flat_fee_cents: int = 0\n    \n    def contains_quantity(self, quantity: int) -> bool:\n        if quantity < self.min_quantity:\n            return False\n        if self.max_quantity is not None and quantity > self.max_quantity:\n            return False\n        return True\n    \n    def calculate_tier_charge(self, quantity: int) -> int:\n        \"\"\"Calculate total charge for quantity within this tier.\"\"\"\n        if not self.contains_quantity(quantity):\n            raise ValueError(f\"Quantity {quantity} not in tier range\")\n        \n        tier_quantity = min(quantity, self.max_quantity or quantity) - self.min_quantity + 1\n        return self.flat_fee_cents + (tier_quantity * self.price_per_unit_cents)\n\n@dataclass\nclass UsageAggregation:\n    \"\"\"Aggregated usage totals for billing period.\"\"\"\n    aggregation_id: uuid.UUID\n    customer_id: uuid.UUID\n    subscription_id: uuid.UUID\n    event_type: str\n    billing_period_start: datetime\n    billing_period_end: datetime\n    total_quantity: Decimal\n    event_count: int\n    first_event_at: datetime\n    last_event_at: datetime\n    created_at: datetime\n    \n    def to_billing_quantity(self) -> int:\n        \"\"\"Convert decimal quantity to integer for billing calculations.\"\"\"\n        return int(self.total_quantity.quantize(Decimal('1'), rounding=ROUND_HALF_UP))\n```\n\n**Usage Event Ingestion Service**\n\n```python\nfrom typing import List, Optional\nimport logging\nfrom datetime import datetime, timezone\nfrom decimal import Decimal, InvalidOperation\n\nlogger = logging.getLogger(__name__)\n\nclass UsageIngestionService:\n    \"\"\"Service for receiving and validating usage events.\"\"\"\n    \n    def __init__(self, db_manager, event_publisher, subscription_service):\n        self.db = db_manager\n        self.events = event_publisher\n        self.subscriptions = subscription_service\n    \n    def submit_usage_event(self, event_data: Dict[str, Any]) -> UsageEvent:\n        \"\"\"\n        Submit a single usage event with idempotency protection.\n        Returns existing event if idempotency key matches.\n        \"\"\"\n        # TODO 1: Validate event_data contains required fields\n        # TODO 2: Check for existing event with same idempotency_key\n        # TODO 3: Validate customer_id exists and has active subscription\n        # TODO 4: Validate event_type is supported billable metric\n        # TODO 5: Validate quantity is positive decimal with reasonable precision\n        # TODO 6: Enrich event with billing period information\n        # TODO 7: Insert event record atomically with idempotency check\n        # TODO 8: Publish event for real-time aggregation\n        # TODO 9: Return created or existing event\n        pass\n    \n    def submit_usage_batch(self, events: List[Dict[str, Any]]) -> List[UsageEvent]:\n        \"\"\"Submit multiple usage events in a single transaction.\"\"\"\n        # TODO 1: Validate all events in batch before processing any\n        # TODO 2: Group events by idempotency key to detect duplicates within batch\n        # TODO 3: Start database transaction with appropriate isolation level\n        # TODO 4: Process each event using submit_usage_event logic\n        # TODO 5: Collect results and rollback transaction on any failure\n        # TODO 6: Publish batch event notification for monitoring\n        # TODO 7: Return list of created/existing events\n        pass\n    \n    def _validate_event_data(self, event_data: Dict[str, Any]) -> None:\n        \"\"\"Validate event data structure and business rules.\"\"\"\n        required_fields = ['customer_id', 'event_type', 'quantity', 'idempotency_key']\n        for field in required_fields:\n            if field not in event_data:\n                raise ValueError(f\"Missing required field: {field}\")\n        \n        # Validate UUID fields\n        try:\n            uuid.UUID(event_data['customer_id'])\n            if 'subscription_id' in event_data:\n                uuid.UUID(event_data['subscription_id'])\n        except (ValueError, TypeError) as e:\n            raise ValueError(f\"Invalid UUID format: {e}\")\n        \n        # Validate quantity\n        try:\n            quantity = Decimal(str(event_data['quantity']))\n            if quantity <= 0:\n                raise ValueError(\"Quantity must be positive\")\n            if quantity.as_tuple().exponent < -6:  # Max 6 decimal places\n                raise ValueError(\"Quantity precision too high\")\n        except (InvalidOperation, TypeError):\n            raise ValueError(\"Invalid quantity format\")\n    \n    def _enrich_event_data(self, event_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Add derived fields for downstream processing.\"\"\"\n        enriched = event_data.copy()\n        \n        # Add server timestamp if not provided\n        if 'timestamp' not in enriched:\n            enriched['timestamp'] = datetime.now(timezone.utc)\n        \n        # TODO: Look up billing period boundaries from subscription\n        # TODO: Add pricing tier information for this event type\n        # TODO: Add customer segment or region for regulatory requirements\n        # TODO: Calculate partition key for efficient storage\n        \n        return enriched\n```\n\n**Usage Aggregation Engine**\n\n```python\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass UsageAggregationEngine:\n    \"\"\"Batch processing engine for usage event aggregation.\"\"\"\n    \n    def __init__(self, db_manager, metrics_client):\n        self.db = db_manager\n        self.metrics = metrics_client\n        self._aggregation_functions = {\n            'sum': self._sum_aggregation,\n            'count': self._count_aggregation,\n            'max': self._max_aggregation,\n            'last_value': self._last_value_aggregation\n        }\n    \n    def aggregate_billing_period(self, \n                                billing_period_start: datetime, \n                                billing_period_end: datetime) -> List[UsageAggregation]:\n        \"\"\"\n        Aggregate all usage events for the specified billing period.\n        Returns list of aggregation records for invoice generation.\n        \"\"\"\n        # TODO 1: Query all usage events in billing period range\n        # TODO 2: Group events by (customer_id, subscription_id, event_type)\n        # TODO 3: Calculate aggregations for each group using appropriate function\n        # TODO 4: Create UsageAggregation records with calculated totals\n        # TODO 5: Store aggregation records atomically\n        # TODO 6: Update aggregation checkpoint for incremental processing\n        # TODO 7: Publish aggregation completed events\n        # TODO 8: Return list of aggregation records\n        pass\n    \n    def process_incremental_aggregation(self, checkpoint_timestamp: datetime) -> int:\n        \"\"\"Process events since last checkpoint for real-time updates.\"\"\"\n        # TODO 1: Query events newer than checkpoint_timestamp\n        # TODO 2: Group events and calculate incremental aggregations\n        # TODO 3: Update existing aggregation records or create new ones\n        # TODO 4: Handle late-arriving events for closed billing periods\n        # TODO 5: Update checkpoint timestamp atomically\n        # TODO 6: Return count of processed events\n        pass\n    \n    def _group_events_for_aggregation(self, events: List[UsageEvent]) -> Dict[Tuple, List[UsageEvent]]:\n        \"\"\"Group events by aggregation key (customer, subscription, event_type).\"\"\"\n        groups = defaultdict(list)\n        for event in events:\n            key = (event.customer_id, event.subscription_id, event.event_type)\n            groups[key].append(event)\n        return dict(groups)\n    \n    def _sum_aggregation(self, events: List[UsageEvent]) -> Decimal:\n        \"\"\"Sum all event quantities.\"\"\"\n        return sum(event.quantity for event in events)\n    \n    def _count_aggregation(self, events: List[UsageEvent]) -> Decimal:\n        \"\"\"Count number of events.\"\"\"\n        return Decimal(len(events))\n    \n    def _max_aggregation(self, events: List[UsageEvent]) -> Decimal:\n        \"\"\"Return maximum quantity across all events.\"\"\"\n        return max(event.quantity for event in events) if events else Decimal('0')\n    \n    def _last_value_aggregation(self, events: List[UsageEvent]) -> Decimal:\n        \"\"\"Return quantity from most recent event.\"\"\"\n        if not events:\n            return Decimal('0')\n        latest_event = max(events, key=lambda e: e.timestamp)\n        return latest_event.quantity\n```\n\n**Tiered Pricing Calculator**\n\n```python\nfrom typing import List\nfrom decimal import Decimal\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass TieredPricingCalculator:\n    \"\"\"Calculates usage charges using tiered pricing models.\"\"\"\n    \n    def __init__(self, db_manager):\n        self.db = db_manager\n    \n    def calculate_usage_charge(self, \n                              customer_id: uuid.UUID,\n                              event_type: str, \n                              total_quantity: int,\n                              base_allowance: int = 0) -> Dict[str, Any]:\n        \"\"\"\n        Calculate tiered usage charge for quantity beyond base allowance.\n        Returns detailed charge breakdown with tier-by-tier calculations.\n        \"\"\"\n        # TODO 1: Load pricing tiers for this event_type from plan\n        # TODO 2: Calculate overage quantity (total - base_allowance)\n        # TODO 3: Apply tiered pricing calculation to overage quantity\n        # TODO 4: Build detailed breakdown of charges by tier\n        # TODO 5: Calculate total charge amount with proper rounding\n        # TODO 6: Return charge details for invoice line items\n        pass\n    \n    def _apply_tiered_pricing(self, quantity: int, tiers: List[PricingTier]) -> Dict[str, Any]:\n        \"\"\"Apply tiered pricing structure to calculate total charges.\"\"\"\n        if quantity <= 0:\n            return {\n                'total_charge_cents': 0,\n                'tier_breakdown': [],\n                'effective_rate_cents': 0\n            }\n        \n        total_charge = 0\n        tier_breakdown = []\n        remaining_quantity = quantity\n        \n        for tier in sorted(tiers, key=lambda t: t.tier_number):\n            if remaining_quantity <= 0:\n                break\n            \n            # Calculate quantity that falls in this tier\n            tier_min = tier.min_quantity\n            tier_max = tier.max_quantity or float('inf')\n            tier_quantity = min(remaining_quantity, tier_max - tier_min + 1)\n            \n            if tier_quantity > 0:\n                # Calculate charge for this tier\n                tier_charge = tier.flat_fee_cents + (tier_quantity * tier.price_per_unit_cents)\n                total_charge += tier_charge\n                \n                tier_breakdown.append({\n                    'tier_number': tier.tier_number,\n                    'quantity': tier_quantity,\n                    'rate_cents': tier.price_per_unit_cents,\n                    'flat_fee_cents': tier.flat_fee_cents,\n                    'tier_charge_cents': tier_charge\n                })\n                \n                remaining_quantity -= tier_quantity\n        \n        effective_rate = total_charge / quantity if quantity > 0 else 0\n        \n        return {\n            'total_charge_cents': total_charge,\n            'tier_breakdown': tier_breakdown,\n            'effective_rate_cents': round(effective_rate, 2)\n        }\n```\n\n**Real-Time Usage Approximation**\n\n```python\nimport redis\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Optional\nimport json\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass RealTimeUsageTracker:\n    \"\"\"Provides approximate real-time usage totals for dashboards and quotas.\"\"\"\n    \n    def __init__(self, redis_client: redis.Redis, window_hours: int = 24):\n        self.redis = redis_client\n        self.window_hours = window_hours\n        self.window_seconds = window_hours * 3600\n    \n    def record_usage_event(self, event: UsageEvent) -> None:\n        \"\"\"Record usage event in real-time approximation system.\"\"\"\n        # TODO 1: Create time-bucketed key for this customer/event_type\n        # TODO 2: Add event quantity to running total for current time bucket\n        # TODO 3: Set expiration on time bucket keys for automatic cleanup\n        # TODO 4: Update customer's current billing period total\n        # TODO 5: Check if customer is approaching usage quotas\n        # TODO 6: Publish usage alert if quota thresholds exceeded\n        pass\n    \n    def get_current_usage(self, \n                         customer_id: uuid.UUID, \n                         event_type: str,\n                         billing_period_start: datetime) -> Dict[str, Any]:\n        \"\"\"Get approximate current usage for customer billing period.\"\"\"\n        # TODO 1: Calculate time buckets covering billing period\n        # TODO 2: Sum usage across all relevant time buckets\n        # TODO 3: Apply smoothing factor for late-arriving events\n        # TODO 4: Return usage estimate with confidence interval\n        pass\n    \n    def check_usage_quotas(self, customer_id: uuid.UUID) -> List[Dict[str, Any]]:\n        \"\"\"Check if customer is approaching or exceeding usage quotas.\"\"\"\n        # TODO 1: Get current usage estimates for all event types\n        # TODO 2: Load plan allowances and quota limits\n        # TODO 3: Calculate usage percentage for each metric\n        # TODO 4: Identify metrics approaching warning thresholds\n        # TODO 5: Return list of quota status for each metric\n        pass\n    \n    def _get_time_bucket_key(self, customer_id: uuid.UUID, event_type: str, timestamp: datetime) -> str:\n        \"\"\"Generate Redis key for time-bucketed usage data.\"\"\"\n        bucket_hour = timestamp.replace(minute=0, second=0, microsecond=0)\n        return f\"usage:{customer_id}:{event_type}:{bucket_hour.isoformat()}\"\n```\n\n**Milestone Checkpoints**\n\nAfter implementing the usage-based billing engine, verify the following functionality:\n\n1. **Event Ingestion Validation**: Submit duplicate events with the same idempotency key. Verify only one event is recorded and the API returns success for both submissions.\n\n2. **Usage Aggregation Accuracy**: Submit a known set of usage events spanning multiple days. Run batch aggregation and verify the totals match expected calculations.\n\n3. **Tiered Pricing Calculations**: Create a plan with tiered overage pricing (e.g., first 1000 units at $0.01, next 5000 at $0.008). Submit usage that spans multiple tiers and verify charge calculations.\n\n4. **Real-Time Approximation**: Submit usage events and verify they appear in real-time usage dashboards within seconds. Compare real-time totals to batch aggregation results for accuracy.\n\n5. **Quota Enforcement**: Configure usage limits and submit events that approach quotas. Verify usage alerts are sent and hard limits are enforced when configured.\n\nExpected behavior: Usage events should be processed idempotently with perfect accuracy in batch mode and approximate accuracy in real-time mode. Pricing calculations should handle complex tiered structures without rounding errors. The system should scale to thousands of events per second while maintaining data consistency.\n\n\n## Invoicing and Payment Processing\n\n> **Milestone(s):** Foundation for all milestones - generates invoices from subscription charges, usage, and credits, then processes payments through the payment gateway integration\n\n### Mental Model: Restaurant Check Generation and Payment\n\nThink of invoice generation like a restaurant preparing your final check at the end of a meal. The waiter (Invoice Generation Engine) walks through your table's activity: the base meal price (subscription charges), any extra appetizers you ordered during dinner (usage overages), and any comp drinks the manager gave you (credit applications). They itemize everything on a single receipt with clear line items, calculate tax, and present a total amount due.\n\nThe payment processing is like the credit card terminal at your table. Once you approve the charge, the terminal (Payment Gateway Integration) communicates with your bank behind the scenes. The restaurant doesn't handle your banking directly - they just send the charge amount and receive back a simple \"approved\" or \"declined\" response. If your card is declined, the system might automatically retry with a different payment method you have on file.\n\nThis separation of concerns - invoice generation versus payment processing - mirrors how billing systems work. The invoice engine focuses on accurately calculating what's owed based on subscription activity, while the payment processor handles the mechanics of actually collecting money through external financial networks.\n\n### Invoice Generation Engine\n\nThe **Invoice Generation Engine** serves as the financial consolidation point for all subscription-related charges, credits, and adjustments. This component transforms raw billing data from subscriptions, usage events, and proration calculations into structured invoices that customers can understand and payment systems can process.\n\nThe invoice generation process follows a specific sequence that ensures mathematical accuracy and maintains a complete audit trail. The engine operates on a **billing period boundary** principle, where it collects all chargeable events that occurred within a defined time window, applies any outstanding credits, and produces a net amount due. This approach prevents double-billing and ensures that every cent is accounted for across billing cycles.\n\n#### Invoice Line Item Calculation\n\nEach invoice contains multiple line items that represent different types of charges and credits. The engine processes these in a specific order to ensure consistent application of business rules:\n\n| Line Item Type | Source | Calculation Method | Example |\n|---|---|---|---|\n| Base Subscription | Plan recurring charge | Fixed amount from plan definition | $29.99/month Pro Plan |\n| Usage Overage | Aggregated usage events | Tiered pricing beyond allowance | 1,000 API calls × $0.01 = $10.00 |\n| Plan Change Proration | Mid-cycle upgrades | Prorated charge for remaining days | $15.00 upgrade × 15/30 days = $7.50 |\n| Credit Application | Customer credit balance | Applied against positive charges | -$5.00 account credit |\n| Tax Calculation | Jurisdiction rules | Applied to taxable line items | $4.20 sales tax (10%) |\n\nThe engine implements **financial precision** by performing all calculations in the smallest currency unit (cents for USD) to avoid floating-point rounding errors. Each line item stores both the calculation method and the raw inputs used, enabling complete auditability of every charge.\n\n> **Design Insight**: Invoice line items are immutable once generated. If an error is discovered after invoice creation, the system generates a credit note (negative invoice) rather than modifying the original invoice. This maintains financial audit integrity and matches accounting best practices.\n\n#### Invoice Status State Machine\n\nInvoices progress through a well-defined lifecycle that coordinates with payment processing and dunning management:\n\n| Current Status | Trigger Event | Next Status | Actions Taken |\n|---|---|---|---|\n| `draft` | Complete line item calculation | `open` | Mark invoice as ready for payment |\n| `open` | Payment received successfully | `paid` | Update customer balance, mark subscription current |\n| `open` | Payment attempt failed | `past_due` | Start dunning process, set retry schedule |\n| `open` | Invoice voided by admin | `void` | Cancel payment attempts, apply credit |\n| `past_due` | Payment retry succeeded | `paid` | Complete payment flow, stop dunning |\n| `past_due` | All retries exhausted | `uncollectible` | Suspend subscription, write off balance |\n| `paid` | Refund processed | `refunded` | Update customer credit balance |\n\nThe invoice status directly influences subscription state transitions. A subscription cannot remain `active` with `past_due` invoices beyond the configured grace period. This tight coupling ensures that billing status accurately reflects service access.\n\n#### Invoice Generation Algorithms\n\nThe core invoice generation algorithm processes multiple data sources and applies business rules to produce accurate billing:\n\n1. **Billing Period Determination**: Calculate the start and end dates for the current billing cycle based on the subscription's billing anchor date and interval\n2. **Base Charge Calculation**: Retrieve the subscription's current plan and calculate the recurring charge for the billing period\n3. **Usage Event Aggregation**: Sum all usage events for the customer within the billing period, grouped by event type\n4. **Usage Charge Calculation**: Apply the plan's usage tiers to determine overage charges beyond included allowances\n5. **Proration Processing**: Include any mid-cycle plan changes or subscription modifications that occurred during the billing period\n6. **Credit Application**: Apply available customer credits to reduce the total amount due\n7. **Tax Calculation**: Apply jurisdiction-specific tax rules to taxable line items\n8. **Invoice Finalization**: Lock the invoice calculations, assign a sequential invoice number, and transition to `open` status\n9. **Payment Initiation**: Trigger payment processing for the final invoice amount\n10. **Audit Trail Recording**: Log all calculation steps and data sources for compliance and debugging\n\nEach step in this algorithm includes validation checks to ensure data consistency. For example, the usage event aggregation step verifies that all events fall within the billing period boundaries and that no duplicate events are processed.\n\n#### Common Invoice Generation Pitfalls\n\n⚠️ **Pitfall: Timezone Confusion in Billing Period Boundaries**  \nMany developers incorrectly calculate billing periods by using server local time instead of the customer's billing timezone. This can cause usage events to be attributed to the wrong billing cycle, leading to under-billing or over-billing. Always store billing anchor dates in UTC but perform billing period calculations in the customer's configured timezone, then convert event timestamps accordingly.\n\n⚠️ **Pitfall: Floating Point Currency Calculations**  \nUsing floating-point arithmetic for monetary calculations introduces rounding errors that compound over many invoices. A $0.001 rounding error across 100,000 customers results in $100 of unaccounted variance. Always perform calculations in integer cents and use the `Money` type's `from_decimal()` method for conversions.\n\n⚠️ **Pitfall: Credit Application Order Dependency**  \nApplying customer credits before calculating taxes can result in incorrect tax amounts, while applying credits after taxes can reduce the customer's available credit balance unnecessarily. The correct order is: calculate base charges, calculate taxes, then apply credits to the total amount including taxes.\n\n⚠️ **Pitfall: Invoice Immutability Violations**  \nModifying invoice line items after the invoice status changes to `open` breaks audit trails and can create payment inconsistencies. If an error is discovered, generate a separate credit invoice rather than modifying the original. This preserves the historical record and follows standard accounting practices.\n\n### Payment Gateway Integration\n\nThe **Payment Gateway Integration** component provides a clean abstraction layer between the subscription billing system and external payment processors. This integration handles payment method storage, charge processing, webhook management, and failure recovery while maintaining PCI compliance boundaries.\n\nThe integration operates on an **asynchronous payment model** where payment initiation and completion are separate operations. When an invoice becomes due, the system initiates a payment request with the gateway and receives an immediate response indicating whether the request was accepted for processing. The actual payment result arrives later via webhook notifications, which update the invoice status and trigger downstream actions.\n\n#### Payment Method Management\n\nCustomer payment methods are stored and managed entirely within the payment gateway's secure vault to maintain PCI compliance. The billing system only stores tokenized references that can be used to initiate charges without handling sensitive payment data:\n\n| Payment Method Attribute | Storage Location | Purpose | Example Value |\n|---|---|---|---|\n| Gateway Token ID | Billing system database | Reference for charge requests | `pm_1ABC123xyz` |\n| Payment Type | Billing system database | Display and routing logic | `card`, `bank_account`, `wallet` |\n| Last Four Digits | Billing system database | Customer identification | `4242` |\n| Expiration Date | Billing system database | Proactive replacement | `12/2025` |\n| Is Default | Billing system database | Primary payment selection | `true` |\n| Gateway Customer ID | Billing system database | Customer grouping | `cus_ABC123` |\n\nThe system supports **payment method hierarchy** where customers can configure primary and backup payment methods. If the primary method fails, the system automatically retries with backup methods before entering the dunning process.\n\n> **Design Insight**: The billing system never stores raw payment information - not even temporarily. All payment data flows directly from the customer's browser to the payment gateway using tokenization. This architectural decision simplifies PCI compliance and reduces security risk.\n\n#### Charge Processing Flow\n\nPayment charges follow a standardized flow that handles both synchronous and asynchronous response patterns:\n\n1. **Invoice Payment Trigger**: Invoice generation completes and triggers payment processing for the final amount due\n2. **Payment Method Selection**: Select the customer's default payment method, or fall back to backup methods if primary fails\n3. **Idempotency Key Generation**: Generate a unique key combining customer ID, invoice ID, and attempt number to prevent duplicate charges\n4. **Gateway Charge Request**: Submit charge request to payment gateway with amount, payment method token, and metadata\n5. **Immediate Response Handling**: Process gateway's immediate response (accepted, declined, requires_action, processing)\n6. **Status Update**: Update invoice status based on immediate response (remains `open` for async processing)\n7. **Webhook Processing**: Receive asynchronous webhook with final charge result\n8. **Invoice Completion**: Update invoice to `paid` or `past_due` based on final charge result\n9. **Subscription Impact**: Update subscription status and access levels based on payment outcome\n10. **Notification Dispatch**: Send customer notifications for payment success or failure\n\nThe charge processing includes **automatic retry logic** for transient failures. Network timeouts, gateway maintenance, and temporary declines trigger retry attempts with exponential backoff before marking the payment as failed.\n\n#### Webhook Event Processing\n\nPayment gateway webhooks provide authoritative updates about charge status, payment method changes, and dispute notifications. The webhook processing system ensures reliable event handling even under high load or temporary system outages:\n\n| Webhook Event Type | Triggered By | System Response | Example Action |\n|---|---|---|---|\n| `payment_intent.succeeded` | Successful charge completion | Update invoice to `paid` status | Activate subscription access |\n| `payment_intent.payment_failed` | Charge failure after retries | Update invoice to `past_due` | Start dunning sequence |\n| `payment_method.updated` | Customer updates card details | Refresh stored payment metadata | Update expiration date display |\n| `invoice.payment_action_required` | 3D Secure authentication needed | Notify customer of required action | Send authentication link |\n| `chargeback.created` | Bank dispute initiated | Freeze related subscription | Suspend service, gather evidence |\n\nWebhook processing implements **exactly-once delivery semantics** using idempotency keys stored in the webhook payload. The system deduplicates webhook events and ensures that each event is processed only once, even if the gateway sends duplicate notifications.\n\n> **Critical Design Decision**: Webhook processing is separated from real-time payment flows. Webhooks update system state asynchronously, while immediate payment responses handle user experience. This separation ensures that gateway latency doesn't impact customer-facing operations.\n\n### ADR: Payment Webhook Processing\n\n> **Decision: Asynchronous Webhook Processing with Event Queue**\n> - **Context**: Payment gateways send webhook notifications for charge status updates, but these webhooks can arrive out of order, be duplicated, or fail during processing. The system must reliably process these events to maintain accurate billing state while handling high webhook volumes without blocking user-facing operations.\n> - **Options Considered**: \n>   1. Synchronous webhook processing with immediate database updates\n>   2. Asynchronous processing with message queue and worker processes\n>   3. Hybrid approach with immediate critical updates and queued background processing\n> - **Decision**: Implement fully asynchronous webhook processing using a reliable message queue with dead letter handling and idempotency protection\n> - **Rationale**: Payment webhooks are not latency-sensitive and require reliable processing more than immediate processing. Queue-based processing provides natural retry mechanisms, handles traffic spikes, and prevents webhook failures from impacting payment gateway relationships. The slight delay in status updates is acceptable since customers receive immediate feedback from the synchronous payment initiation response.\n> - **Consequences**: Enables horizontal scaling of webhook processing, provides built-in retry and dead letter handling, and maintains webhook endpoint reliability. Trade-off is eventual consistency in payment status updates, requiring careful handling of race conditions where customers might see temporary status mismatches.\n\n| Processing Option | Reliability | Latency | Scalability | Complexity |\n|---|---|---|---|---|\n| Synchronous Processing | Medium (no retry) | Low | Limited | Low |\n| **Async Queue (Chosen)** | **High (built-in retry)** | **Medium** | **High** | **Medium** |\n| Hybrid Approach | High | Variable | Medium | High |\n\nThe asynchronous queue approach provides the best balance of reliability and scalability. Critical payment status updates can still be handled synchronously during payment initiation, while webhook processing handles the authoritative state reconciliation asynchronously.\n\n#### Webhook Idempotency and Deduplication\n\nPayment gateways may send duplicate webhook events due to network issues, timeouts, or internal retry logic. The webhook processing system implements **idempotency protection** to ensure each event is processed exactly once:\n\n1. **Idempotency Key Extraction**: Extract the gateway-provided idempotency key from the webhook payload header\n2. **Duplicate Detection**: Check if this idempotency key has been processed before by querying the webhook event log\n3. **Atomic Processing**: If not a duplicate, process the webhook and record the idempotency key in a single database transaction\n4. **Idempotent Response**: Return success immediately for duplicate webhooks without reprocessing\n5. **Event Ordering**: Handle out-of-order webhooks by comparing event timestamps and only applying newer updates\n\nThe idempotency system maintains a webhook event log that serves both as duplicate protection and as an audit trail for debugging payment issues.\n\n#### Payment Failure Recovery\n\nWhen payment charges fail, the system implements a **graduated dunning process** that balances customer retention with payment collection. The recovery process includes multiple retry attempts with different strategies:\n\n| Retry Stage | Timing | Action Taken | Success Rate |\n|---|---|---|---|\n| Immediate Retry | 1 hour after failure | Same payment method | ~15% recovery |\n| Backup Method | 24 hours | Try backup payment method | ~25% recovery |\n| Customer Notification | 3 days | Email with payment update link | ~35% recovery |\n| Account Suspension Warning | 7 days | Final notice before suspension | ~20% recovery |\n| Service Suspension | 14 days | Restrict account access | Payment required for restoration |\n\nEach retry attempt generates a new idempotency key to prevent conflicts with previous attempts. The system tracks retry history and automatically escalates through the dunning stages based on configurable business rules.\n\n### Implementation Guidance\n\nThe invoice generation and payment processing components require careful attention to financial accuracy, error handling, and integration patterns. The implementation balances real-time responsiveness with reliable background processing.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|---|---|---|---|\n| Invoice Generation | SQLite with JSON fields | PostgreSQL with JSONB and triggers |\n| Payment Gateway SDK | Stripe Python SDK | Multi-gateway abstraction layer |\n| Webhook Processing | Flask + Celery | FastAPI + Apache Kafka |\n| Currency Handling | Python Decimal with custom Money class | Babel + currency exchange APIs |\n| PDF Generation | ReportLab Python library | Headless Chrome with HTML templates |\n| Audit Logging | Structured JSON logging | Dedicated audit database |\n\nThe simple options provide rapid development velocity for proof-of-concept implementations, while advanced options support production-scale requirements with better performance and observability.\n\n#### Recommended File Structure\n\n```\nbilling_system/\n  invoicing/\n    __init__.py\n    invoice_generator.py      ← Core invoice generation logic\n    line_item_calculator.py   ← Individual charge calculations\n    invoice_models.py         ← Invoice and LineItem data structures\n    invoice_repository.py     ← Database operations\n    invoice_service.py        ← High-level orchestration\n    \n  payments/\n    __init__.py\n    payment_gateway.py        ← Gateway abstraction interface\n    stripe_gateway.py         ← Stripe-specific implementation\n    webhook_handler.py        ← Webhook processing logic\n    payment_models.py         ← Payment and Transaction structures\n    payment_service.py        ← Payment orchestration\n    \n  shared/\n    money.py                  ← Currency and precision utilities\n    audit_logger.py           ← Financial audit trail\n    idempotency.py           ← Duplicate request protection\n    \n  tests/\n    test_invoice_generation.py\n    test_payment_processing.py\n    test_webhook_handling.py\n```\n\nThis structure separates invoice generation concerns from payment processing while providing shared utilities for financial operations. The clear separation enables independent testing and deployment of billing versus payment functionality.\n\n#### Core Invoice Generation Infrastructure\n\nThe invoice generation system requires robust infrastructure for financial calculations and audit trails:\n\n```python\nfrom decimal import Decimal, ROUND_HALF_UP\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime, timezone\nfrom enum import Enum\nimport uuid\n\n@dataclass\nclass Money:\n    amount_cents: int\n    currency_code: str\n    \n    @classmethod\n    def from_decimal(cls, amount: Decimal, currency: str) -> 'Money':\n        # Convert decimal to cents with proper rounding\n        cents = int(amount.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP) * 100)\n        return cls(amount_cents=cents, currency_code=currency)\n    \n    def to_decimal(self) -> Decimal:\n        return Decimal(self.amount_cents) / Decimal('100')\n    \n    def __add__(self, other: 'Money') -> 'Money':\n        if self.currency_code != other.currency_code:\n            raise ValueError(\"Cannot add different currencies\")\n        return Money(self.amount_cents + other.amount_cents, self.currency_code)\n    \n    def __sub__(self, other: 'Money') -> 'Money':\n        if self.currency_code != other.currency_code:\n            raise ValueError(\"Cannot subtract different currencies\")\n        return Money(self.amount_cents - other.amount_cents, self.currency_code)\n\nclass InvoiceStatus(Enum):\n    DRAFT = \"draft\"\n    OPEN = \"open\"\n    PAID = \"paid\"\n    PAST_DUE = \"past_due\"\n    VOID = \"void\"\n    UNCOLLECTIBLE = \"uncollectible\"\n\nclass LineItemType(Enum):\n    SUBSCRIPTION = \"subscription\"\n    USAGE = \"usage\"\n    PRORATION = \"proration\"\n    CREDIT = \"credit\"\n    TAX = \"tax\"\n\n@dataclass\nclass LineItem:\n    line_item_id: uuid.UUID\n    item_type: LineItemType\n    description: str\n    quantity: Decimal\n    unit_price: Money\n    total_amount: Money\n    tax_amount: Money\n    metadata: Dict = field(default_factory=dict)\n    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n\n@dataclass\nclass Invoice:\n    invoice_id: uuid.UUID\n    customer_id: uuid.UUID\n    subscription_id: Optional[uuid.UUID]\n    status: InvoiceStatus\n    line_items: List[LineItem]\n    subtotal_amount: Money\n    tax_amount: Money\n    credit_applied: Money\n    total_amount: Money\n    billing_period_start: datetime\n    billing_period_end: datetime\n    due_date: datetime\n    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    updated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    metadata: Dict = field(default_factory=dict)\n\nclass AuditEventType(Enum):\n    INVOICE_CREATED = \"invoice_created\"\n    INVOICE_FINALIZED = \"invoice_finalized\"\n    PAYMENT_INITIATED = \"payment_initiated\"\n    PAYMENT_SUCCEEDED = \"payment_succeeded\"\n    PAYMENT_FAILED = \"payment_failed\"\n    CREDIT_APPLIED = \"credit_applied\"\n```\n\nThis infrastructure provides type-safe financial operations with proper decimal precision and comprehensive audit trails. The `Money` class ensures all calculations maintain cent-level accuracy.\n\n#### Payment Gateway Integration Skeleton\n\nThe payment gateway integration requires careful abstraction to support multiple payment providers:\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Optional, List\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport uuid\n\nclass PaymentStatus(Enum):\n    PENDING = \"pending\"\n    PROCESSING = \"processing\"\n    SUCCEEDED = \"succeeded\"\n    FAILED = \"failed\"\n    REQUIRES_ACTION = \"requires_action\"\n\n@dataclass\nclass PaymentMethod:\n    payment_method_id: str\n    customer_id: uuid.UUID\n    payment_type: str\n    last_four: str\n    expiration_month: Optional[int]\n    expiration_year: Optional[int]\n    is_default: bool\n    metadata: Dict = field(default_factory=dict)\n\n@dataclass\nclass PaymentResult:\n    payment_id: str\n    status: PaymentStatus\n    amount: Money\n    payment_method_id: str\n    gateway_transaction_id: Optional[str]\n    failure_reason: Optional[str]\n    requires_action: Optional[Dict] = None\n    metadata: Dict = field(default_factory=dict)\n\nclass PaymentGatewayInterface(ABC):\n    \"\"\"Abstract interface for payment gateway implementations.\"\"\"\n    \n    @abstractmethod\n    def create_charge(self, amount: Money, payment_method_id: str, \n                     idempotency_key: str, metadata: Dict) -> PaymentResult:\n        \"\"\"Initiate a payment charge.\"\"\"\n        # TODO 1: Validate payment amount is positive\n        # TODO 2: Retrieve payment method details from gateway\n        # TODO 3: Create charge request with gateway-specific parameters\n        # TODO 4: Handle immediate gateway response (success/failure/processing)\n        # TODO 5: Return standardized PaymentResult\n        pass\n    \n    @abstractmethod\n    def retrieve_charge(self, charge_id: str) -> PaymentResult:\n        \"\"\"Get current status of an existing charge.\"\"\"\n        # TODO 1: Make gateway API call to retrieve charge details\n        # TODO 2: Map gateway response to standardized PaymentResult\n        # TODO 3: Handle gateway errors and timeouts gracefully\n        pass\n    \n    @abstractmethod\n    def process_webhook(self, webhook_payload: str, signature: str) -> Optional[Dict]:\n        \"\"\"Process incoming webhook from payment gateway.\"\"\"\n        # TODO 1: Verify webhook signature for security\n        # TODO 2: Parse webhook payload and extract event type\n        # TODO 3: Validate event structure and required fields\n        # TODO 4: Return standardized event data or None if invalid\n        pass\n    \n    @abstractmethod\n    def get_customer_payment_methods(self, customer_id: uuid.UUID) -> List[PaymentMethod]:\n        \"\"\"Retrieve all payment methods for a customer.\"\"\"\n        # TODO 1: Look up gateway customer ID from local mapping\n        # TODO 2: Fetch payment methods from gateway API\n        # TODO 3: Convert gateway response to PaymentMethod objects\n        pass\n\nclass StripeGateway(PaymentGatewayInterface):\n    \"\"\"Stripe-specific implementation of payment gateway interface.\"\"\"\n    \n    def __init__(self, api_key: str, webhook_secret: str):\n        self.api_key = api_key\n        self.webhook_secret = webhook_secret\n        # TODO: Initialize Stripe SDK with API key\n    \n    def create_charge(self, amount: Money, payment_method_id: str, \n                     idempotency_key: str, metadata: Dict) -> PaymentResult:\n        # TODO 1: Convert Money amount to Stripe's expected integer cents\n        # TODO 2: Build Stripe PaymentIntent creation request\n        # TODO 3: Include idempotency key in request headers\n        # TODO 4: Handle Stripe-specific response format\n        # TODO 5: Map Stripe status to PaymentStatus enum\n        # Hint: Use stripe.PaymentIntent.create() with confirm=True for immediate processing\n        pass\n```\n\nThe gateway abstraction enables testing with mock implementations and simplifies switching between payment providers. Each concrete implementation handles provider-specific API details while maintaining consistent interfaces.\n\n#### Webhook Processing Service\n\nReliable webhook processing requires careful handling of authentication, deduplication, and failure recovery:\n\n```python\nimport json\nimport hmac\nimport hashlib\nfrom typing import Optional, Dict, Any\nfrom datetime import datetime, timezone\nfrom dataclasses import dataclass\nimport uuid\n\n@dataclass\nclass WebhookEvent:\n    event_id: uuid.UUID\n    gateway_event_id: str\n    event_type: str\n    processed_at: Optional[datetime]\n    idempotency_key: str\n    payload: Dict[str, Any]\n    processing_attempts: int = 0\n    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n\nclass WebhookProcessor:\n    \"\"\"Handles payment gateway webhook processing with idempotency and retry logic.\"\"\"\n    \n    def __init__(self, payment_gateway: PaymentGatewayInterface, \n                 database_manager: DatabaseManager):\n        self.payment_gateway = payment_gateway\n        self.db = database_manager\n    \n    def process_webhook(self, raw_payload: str, signature: str) -> Dict[str, Any]:\n        \"\"\"Process incoming webhook with full error handling and deduplication.\"\"\"\n        # TODO 1: Verify webhook signature using payment gateway\n        # TODO 2: Parse payload and extract gateway event ID for idempotency\n        # TODO 3: Check if this webhook has been processed before\n        # TODO 4: If duplicate, return success without processing\n        # TODO 5: Process webhook event and update relevant entities\n        # TODO 6: Record successful processing in webhook event log\n        # TODO 7: Handle processing failures with appropriate error responses\n        # Hint: Use payment_gateway.process_webhook() for signature verification\n        pass\n    \n    def handle_payment_succeeded(self, event_data: Dict[str, Any]) -> None:\n        \"\"\"Handle successful payment webhook events.\"\"\"\n        # TODO 1: Extract payment intent ID and amount from event data\n        # TODO 2: Find corresponding invoice by payment intent reference\n        # TODO 3: Update invoice status to PAID in database transaction\n        # TODO 4: Update subscription status to active if payment resolves past due\n        # TODO 5: Apply any remaining credit balance to customer account\n        # TODO 6: Log audit event for payment completion\n        # TODO 7: Trigger customer notification for successful payment\n        pass\n    \n    def handle_payment_failed(self, event_data: Dict[str, Any]) -> None:\n        \"\"\"Handle failed payment webhook events.\"\"\"\n        # TODO 1: Extract payment failure details and error codes\n        # TODO 2: Find corresponding invoice and update status to PAST_DUE\n        # TODO 3: Determine if failure is retryable or permanent\n        # TODO 4: Schedule dunning retry if appropriate\n        # TODO 5: Update subscription status based on dunning policy\n        # TODO 6: Log failure reason and next retry time\n        # TODO 7: Notify customer of payment failure with resolution options\n        pass\n    \n    def verify_webhook_signature(self, payload: str, signature: str) -> bool:\n        \"\"\"Verify webhook authenticity using HMAC signature.\"\"\"\n        # TODO 1: Extract timestamp and signature from header\n        # TODO 2: Build expected signature using webhook secret and payload\n        # TODO 3: Compare signatures using constant-time comparison\n        # TODO 4: Check timestamp to prevent replay attacks\n        # TODO 5: Return True only if signature and timestamp are valid\n        # Hint: Use hmac.compare_digest() for constant-time comparison\n        pass\n```\n\nThe webhook processor handles the complex orchestration between payment events and billing system state. Proper idempotency protection prevents duplicate processing even under high webhook volumes.\n\n#### Milestone Checkpoints\n\nAfter implementing the invoicing and payment processing components, verify functionality with these checkpoints:\n\n**Invoice Generation Verification:**\n1. Create a subscription with usage events and run invoice generation\n2. Verify invoice contains correct line items for base subscription, usage overages, and credits\n3. Check that all monetary calculations use integer cents and sum correctly\n4. Confirm invoice status transitions from `draft` to `open` after finalization\n5. Test proration calculations by changing plans mid-cycle\n\n**Payment Processing Verification:**\n1. Submit a charge request and verify immediate response handling\n2. Simulate webhook events using payment gateway's testing tools\n3. Confirm webhook deduplication by sending the same event twice\n4. Test payment failure handling and dunning process initiation\n5. Verify subscription status updates correctly based on payment outcomes\n\n**Integration Testing:**\n1. Run complete billing cycle from subscription renewal to payment completion\n2. Test webhook processing under simulated network delays and failures\n3. Verify audit trail captures all financial operations with proper attribution\n4. Confirm currency precision maintained throughout all calculation steps\n\nExpected behavior: Invoices should generate deterministically with identical line items for the same input data. Payment processing should handle both synchronous and asynchronous flows gracefully. All webhook events should process exactly once even under adverse network conditions.\n\n![Monthly Billing Cycle Sequence](./diagrams/billing-cycle-sequence.svg)\n\n![Payment Webhook Processing](./diagrams/payment-webhook-sequence.svg)\n\n\n## Component Interactions and Data Flow\n\n> **Milestone(s):** All milestones - describes how components from plan management (Milestone 1), subscription lifecycle (Milestone 2), proration (Milestone 3), and usage-based billing (Milestone 4) work together\n\n### Mental Model: Orchestra Coordination\n\nThink of the subscription billing system like a symphony orchestra performing a complex piece. Each component is a section of musicians (strings, brass, woodwinds, percussion) with their own specialized skills, but they must coordinate precisely to create beautiful music. The conductor (our event orchestration layer) ensures each section comes in at the right time with the right volume. When a customer upgrades their plan, it's like a musical transition where the strings fade out while the brass section crescendos - multiple components must work together seamlessly to create the desired effect without jarring the audience (our customers).\n\nJust as musicians pass musical phrases between sections, our billing components pass data and events between each other. The subscription lifecycle component might start a \"melody\" by creating a new subscription, which the plan management component harmonizes by applying pricing rules, while the usage tracker adds percussion by measuring consumption, and finally the invoice generator brings it all together in the finale. When something goes wrong - like a musician missing their cue - the other sections must adapt gracefully to maintain the performance.\n\nThis mental model helps us understand that component interactions aren't just technical plumbing - they're choreographed workflows where timing, sequencing, and error handling are critical to delivering a smooth customer experience.\n\n![System Component Architecture](./diagrams/system-architecture.svg)\n\nThe subscription billing system orchestrates complex interactions between multiple specialized components. Each component has clear responsibilities, but they must coordinate precisely during key operations like subscription creation, monthly billing cycles, and plan changes. Understanding these interaction patterns is crucial for building a reliable billing system that maintains data consistency and provides a smooth customer experience.\n\n### Subscription Creation Flow\n\nThe subscription creation flow represents one of the most critical workflows in the billing system. It involves coordinating between plan management, payment processing, usage tracking initialization, and subscription state management. This flow must handle complex scenarios like trial periods, immediate charges, proration for mid-month starts, and graceful error recovery if any step fails.\n\n#### End-to-End Process Flow\n\nThe subscription creation process follows a carefully orchestrated sequence that ensures data consistency and proper financial accounting. The flow begins when a customer selects a plan and provides payment information, and concludes with an active subscription that's ready for billing and usage tracking.\n\n**Step 1: Plan Validation and Feature Resolution**\nThe process starts with the Plan Management Component validating the selected plan and resolving all pricing and feature information. This includes checking plan availability, ensuring the plan supports the requested billing interval, and loading the complete feature entitlement matrix. The component also determines if the plan includes trial periods or requires immediate payment.\n\n**Step 2: Customer Credit Check and Payment Method Validation**\nThe system checks the customer's existing credit balance and validates the provided payment method through the Payment Gateway integration. This step ensures the customer has sufficient funds or valid payment instruments before proceeding with subscription creation. The payment method is tokenized for future recurring charges.\n\n**Step 3: Proration Calculation for Mid-Cycle Start**\nIf the subscription starts mid-cycle (not on the standard billing anchor day), the Proration Calculator determines the prorated charge for the partial billing period. This calculation considers the plan's billing interval, the current date, and the customer's preferred billing anchor day to ensure fair charging for partial periods.\n\n**Step 4: Initial Invoice Generation**\nThe Invoice Generator creates the first invoice for the subscription, including any trial period handling, prorated charges, setup fees, and applicable taxes. If the customer has existing credit balance, it's automatically applied to reduce the invoice amount. The invoice includes detailed line items showing exactly what the customer is being charged for.\n\n**Step 5: Payment Processing and Authorization**\nThe Payment Processor attempts to charge the customer's payment method for any immediate amounts due. For trial subscriptions, this might only authorize the payment method without charging. The system handles various payment scenarios including successful charges, failed payments, and payment methods requiring additional authentication.\n\n**Step 6: Subscription Record Creation and State Initialization**\nUpon successful payment (or trial authorization), the Subscription Engine creates the subscription record with the appropriate initial state. Trial subscriptions start in `trialing` status, while paid subscriptions begin in `active` status. The subscription includes billing anchor calculation, next billing date determination, and feature entitlement activation.\n\n**Step 7: Usage Tracking Initialization**\nThe Usage-Based Billing Engine initializes usage tracking for the new subscription. This includes setting up usage allowances based on the plan, creating initial usage aggregation records, and configuring any quota limits. The system prepares to track metered usage from the subscription start date.\n\n**Step 8: Welcome Communications and Service Provisioning**\nFinally, the system triggers welcome communications to the customer and provisions access to subscribed services. This includes sending confirmation emails, updating customer portal access, and notifying downstream services about the new subscription and its feature entitlements.\n\n#### Component Interaction Patterns\n\nThe subscription creation flow demonstrates several important interaction patterns that appear throughout the billing system. Understanding these patterns helps developers build consistent and reliable workflows.\n\n![Monthly Billing Cycle Sequence](./diagrams/billing-cycle-sequence.svg)\n\n| Interaction Pattern | Description | Components Involved | Data Exchanged |\n|---------------------|-------------|-------------------|----------------|\n| Synchronous Validation | Immediate validation with error response | Plan Management, Payment Gateway | Plan details, payment method validation |\n| Asynchronous Processing | Background tasks triggered by events | Invoice Generator, Email Service | Subscription events, notification requests |\n| Transactional Coordination | Multi-step operations with rollback capability | Database Manager, All Components | Entity creation, state changes |\n| Event-Driven Updates | Components react to subscription lifecycle events | Event Bus, Usage Tracker, Audit Logger | Subscription events, audit records |\n| Credit Application | Automatic credit consumption during billing | Credit Balance Manager, Invoice Generator | Credit amounts, invoice adjustments |\n\n**Error Handling and Rollback Scenarios**\n\nThe subscription creation flow must handle various failure modes gracefully. Each step in the process includes specific error handling and rollback procedures to ensure the system remains in a consistent state.\n\nIf payment processing fails after the subscription record is created, the system automatically transitions the subscription to `incomplete` status and schedules payment retry attempts. The customer retains access to trial features but cannot access paid features until payment succeeds.\n\nWhen plan validation fails due to plan unavailability or pricing errors, the system returns detailed error messages to help customers select alternative plans. No subscription record is created, and no charges are attempted.\n\nDatabase transaction failures during subscription creation trigger automatic rollback of all related records, including invoice line items, usage tracking setup, and payment authorizations. The system logs detailed error information for debugging while providing user-friendly error messages to customers.\n\n#### Data Consistency Guarantees\n\nThe subscription creation flow maintains strict data consistency through several mechanisms. All financial operations occur within database transactions with serializable isolation levels to prevent race conditions. The system uses idempotency keys to ensure duplicate subscription creation requests don't result in multiple charges or subscriptions.\n\nEvent publishing follows the transactional outbox pattern, where events are written to the database as part of the same transaction that creates the subscription, then published asynchronously. This ensures that downstream systems receive notifications about all successfully created subscriptions without missing events due to system failures.\n\nThe flow also implements compensation patterns for distributed operations. If payment succeeds but subscription creation fails, the system automatically initiates refund processing to prevent charging customers for non-existent subscriptions.\n\n### Monthly Billing Cycle Flow\n\nThe monthly billing cycle represents the heartbeat of the subscription system. This process runs automatically for all active subscriptions, calculating charges, applying usage-based billing, processing payments, and handling failures. The billing cycle must process potentially thousands of subscriptions reliably while maintaining strict financial accuracy and providing detailed audit trails.\n\n#### Billing Cycle Orchestration\n\nThe billing cycle operates as a distributed workflow that processes subscriptions in carefully coordinated stages. The system uses a combination of scheduled triggers and event-driven processing to ensure reliable execution even during high-volume periods or system failures.\n\n**Stage 1: Billing Period Identification and Subscription Selection**\nThe billing process begins by identifying all subscriptions due for renewal on the current date. The system queries subscriptions where the next billing date matches the current date and the subscription status allows billing (active, trialing with trial ending). This selection process considers timezone differences to ensure customers are billed at the appropriate time in their local timezone.\n\nThe system also identifies subscriptions transitioning from trial to paid status on the current date. These subscriptions require special handling to activate paid features and process the first recurring charge.\n\n**Stage 2: Usage Aggregation and Overage Calculation**\nFor each subscription due for billing, the Usage-Based Billing Engine aggregates all usage events from the previous billing period. This aggregation process totals consumption by usage type and compares against plan allowances to calculate any overage charges.\n\nThe aggregation uses precise billing period boundaries, starting from the last billing date (inclusive) to the current billing date (exclusive). This ensures usage is attributed to the correct billing period even when usage events arrive with slight timestamp delays.\n\n**Stage 3: Invoice Generation with Line Item Breakdown**\nThe Invoice Generator creates detailed invoices for each subscription, including multiple line item types. Base subscription charges appear as recurring line items, while usage overages create separate metered line items with quantity and rate breakdowns.\n\nThe invoice generation process automatically applies any existing customer credit balance, reducing the total amount due. Credits are consumed on a first-in-first-out basis, with detailed line items showing credit application amounts and remaining balances.\n\n**Stage 4: Payment Processing and Retry Logic**\nThe Payment Processor attempts to charge each customer's default payment method for the invoice total. The system implements intelligent retry logic for failed payments, using exponential backoff and multiple payment method fallback.\n\nSuccessful payments immediately mark invoices as paid and maintain subscription active status. Failed payments trigger the dunning management process, transitioning subscriptions to `past_due` status and scheduling retry attempts.\n\n**Stage 5: Subscription Renewal and Next Billing Date Calculation**\nSuccessfully billed subscriptions have their subscription records updated with new billing period information. The system calculates the next billing date based on the subscription's billing interval and billing anchor day, handling edge cases like month-end dates and leap years.\n\nThe subscription's feature entitlements are refreshed based on the current plan version, and usage allowances are reset for the new billing period. Any plan changes scheduled for the renewal date are applied at this stage.\n\n**Stage 6: Usage Tracking Reset and Quota Reactivation**\nThe Usage-Based Billing Engine resets usage tracking for the new billing period. Previous period usage is archived for reporting purposes, while current period counters are zeroed out. Any quota restrictions imposed due to overage in the previous period are lifted if payment succeeded.\n\nThe system also recalculates usage limits based on any plan changes that took effect during renewal, ensuring customers have access to their updated usage allowances immediately.\n\n#### Failure Handling and Recovery\n\nThe monthly billing cycle implements comprehensive failure handling to ensure financial accuracy and customer satisfaction. Each stage of the billing process includes specific failure modes and recovery procedures.\n\n**Payment Failure Recovery**\nWhen payment processing fails, the system distinguishes between temporary failures (insufficient funds, network issues) and permanent failures (expired cards, closed accounts). Temporary failures trigger automatic retry attempts with increasing delays, while permanent failures require customer intervention to update payment methods.\n\nThe dunning management system sends progressively more urgent communications to customers about failed payments, while maintaining service access for a grace period. Customers retain access to their subscribed services but may have certain features restricted until payment succeeds.\n\n**Usage Aggregation Failures**\nIf usage aggregation fails for a subscription, the billing cycle continues with base subscription charges while marking the usage calculation for manual review. This ensures customers aren't blocked from service due to usage tracking issues, while finance teams can resolve discrepancies later.\n\nThe system maintains detailed logs of aggregation failures, including which usage events couldn't be processed and why. This information enables rapid resolution of billing disputes and usage tracking bugs.\n\n**Database Consistency During High Volume**\nDuring peak billing periods, the system uses optimistic locking and retry mechanisms to handle database contention. Each subscription's billing operation occurs within its own transaction to prevent failures in one subscription from affecting others.\n\nThe billing process can be safely restarted at any stage, using idempotency keys and billing status flags to resume from the last successful checkpoint. This allows the system to recover quickly from infrastructure failures during critical billing windows.\n\n#### Performance and Scalability Considerations\n\nThe monthly billing cycle must handle varying loads efficiently, from systems with hundreds of subscriptions to enterprise platforms processing millions of renewals. The system uses several techniques to maintain performance at scale.\n\n**Batch Processing with Parallel Execution**\nSubscriptions are processed in configurable batch sizes, with multiple batches running in parallel. The batch size balances memory usage against processing efficiency, while parallel execution utilizes available system resources effectively.\n\nEach batch processes subscriptions independently, allowing the system to scale horizontally by adding more worker processes or servers. Failed batches can be retried independently without affecting successful processing.\n\n**Database Query Optimization**\nThe billing process uses optimized database queries with appropriate indexes on billing-related fields. Usage aggregation queries use time-range partitioning to scan only relevant data, while subscription selection queries use compound indexes on status and next billing date.\n\nThe system pre-loads related data (plans, payment methods, customer information) in batch queries to minimize database round-trips during processing. This approach significantly reduces the per-subscription processing time.\n\n**Memory Management and Resource Cleanup**\nLarge-scale billing operations carefully manage memory usage to prevent out-of-memory errors during peak periods. Usage aggregation results are processed in streaming fashion rather than loading entire datasets into memory.\n\nThe system includes monitoring and alerting for billing cycle performance, tracking metrics like processing time per subscription, memory usage, and error rates. This visibility enables proactive capacity planning and performance optimization.\n\n### Plan Change and Proration Flow\n\nPlan changes represent some of the most complex operations in subscription billing, requiring careful coordination between multiple components to ensure accurate financial calculations and smooth customer experience. The process must handle upgrades, downgrades, immediate changes, scheduled changes, and various edge cases while maintaining strict financial accuracy.\n\n![Plan Change and Proration Flow](./diagrams/plan-change-flow.svg)\n\n#### Plan Change Orchestration Workflow\n\nThe plan change process follows a sophisticated workflow that balances customer expectations with financial precision. Customers expect plan changes to take effect immediately or at predictable times, while the billing system must ensure accurate proration and proper credit handling.\n\n**Phase 1: Plan Change Validation and Authorization**\nThe process begins with comprehensive validation of the requested plan change. The Plan Management Component verifies that the target plan is available, supports the customer's billing preferences, and allows the specific transition from the current plan.\n\nThe system checks whether the change represents an upgrade (higher cost) or downgrade (lower cost) to determine the appropriate proration and payment handling. Upgrade validations include verifying the customer's payment method can handle additional charges, while downgrades require checking refund policies and credit balance limits.\n\nAuthorization checks ensure the customer has permission to make plan changes and hasn't exceeded any change frequency limits. Some businesses restrict plan changes to prevent abuse or reduce support complexity.\n\n**Phase 2: Proration Calculation and Financial Impact Analysis**\nThe Proration Calculator performs detailed financial analysis of the plan change, determining exactly how much the customer should be charged or credited. This calculation considers the time remaining in the current billing period, the difference between old and new plan pricing, and any usage-based charges that need adjustment.\n\nFor upgrades, the system calculates the prorated charge for the remaining days in the billing cycle at the new plan rate, minus the value of unused time at the old rate. For downgrades, it calculates credits for the unused portion of the higher-priced plan.\n\nThe calculation also considers usage allowances and overages. If the new plan has different usage limits, the system recalculates overage charges based on current period usage and the new plan's allowances.\n\n**Phase 3: Invoice Adjustment and Credit Processing**\nBased on the proration calculation, the Invoice Generator creates adjustment line items for the customer's next invoice or generates an immediate invoice for upgrades requiring payment. Credit adjustments are processed through the Credit Balance Manager to ensure proper accounting and audit trails.\n\nUpgrades typically result in immediate charges for the prorated difference, while downgrades create credits applied to future invoices. The system generates detailed line items explaining each adjustment to provide transparency to customers and support teams.\n\n**Phase 4: Subscription Record Updates and Feature Activation**\nThe Subscription Engine updates the subscription record with the new plan information, adjusting feature entitlements immediately. Customers gain access to new features right away, even if the financial adjustments are processed asynchronously.\n\nThe subscription's next billing date remains unchanged to maintain the existing billing cycle anchor. However, the system records the plan change effective date for accurate future billing calculations.\n\n**Phase 5: Usage Tracking Adjustment and Quota Updates**\nThe Usage-Based Billing Engine adjusts usage tracking for the new plan's allowances and quotas. If the new plan includes higher usage limits, those become available immediately. If the new plan has lower limits and current usage exceeds them, the system applies appropriate overage charges or quota restrictions.\n\nUsage tracking maintains historical records of plan changes to ensure accurate aggregation and billing at the end of the billing period. Each usage event is associated with the plan that was active when the usage occurred.\n\n**Phase 6: Downstream Service Notifications and Access Updates**\nFinally, the system notifies all downstream services about the plan change and updated feature entitlements. This includes updating customer portal access, API rate limits, storage quotas, and any other plan-dependent service configurations.\n\nThese notifications use the event-driven architecture to ensure all services receive updates without requiring direct coupling between the billing system and service implementations.\n\n#### Complex Proration Scenarios\n\nThe plan change flow must handle numerous complex scenarios that arise in real-world billing operations. Each scenario requires specific handling to ensure fairness and accuracy.\n\n**Multiple Plan Changes Within a Billing Period**\nWhen customers make multiple plan changes within a single billing period, the system maintains a chronological record of all changes and calculates cumulative proration effects. Each change is treated as a separate proration calculation, with the effective date determining how much of the billing period applies to each plan.\n\nThe system prevents proration gaming by tracking change frequency and applying business rules about minimum time between changes or maximum changes per period. This protects against customers attempting to exploit proration calculations.\n\n**Plan Changes with Different Billing Intervals**\nChanging from monthly to annual billing (or vice versa) requires special handling since the billing cycles don't align. The system calculates proration for the remainder of the current billing cycle, then schedules the subscription for renewal on the new billing interval.\n\nThese changes often involve significant proration amounts, either charging for several months upfront (monthly to annual) or crediting unused annual subscription time (annual to monthly). The system provides clear explanations of these calculations to customers.\n\n**Usage-Based Plan Changes with Existing Consumption**\nWhen changing plans mid-cycle with existing usage consumption, the system must recalculate overage charges based on each plan's allowances and rates. Usage that was within allowances under the old plan might become overage under a new plan with lower limits.\n\nThe system applies a fairness algorithm that ensures customers aren't double-charged for usage but also aren't given unfair advantages by switching plans to avoid overage charges they've already incurred.\n\n#### Error Handling and Rollback Mechanisms\n\nPlan changes involve multiple financial and operational systems, creating numerous potential failure points. The system implements comprehensive error handling and rollback capabilities to maintain consistency.\n\n**Financial Rollback for Payment Failures**\nIf a plan upgrade requires immediate payment and the charge fails, the system automatically rolls back the plan change, restoring the previous plan and feature entitlements. Any credits or adjustments created during the change process are reversed.\n\nThe rollback process maintains audit trails of both the attempted change and the rollback, ensuring complete transparency for customer service and accounting teams.\n\n**Partial Failure Recovery**\nWhen some aspects of a plan change succeed (like updating the subscription record) but others fail (like processing payments or updating downstream services), the system uses compensation patterns to restore consistency.\n\nThe system maintains a plan change state machine that tracks the progress of each change operation, enabling automatic retry of failed steps or manual intervention when necessary.\n\n**Data Consistency During Concurrent Operations**\nPlan changes use optimistic locking to prevent conflicts when multiple operations target the same subscription simultaneously. If a plan change conflicts with billing cycle processing or other operations, the system queues the change for execution after the conflicting operation completes.\n\nThis approach ensures that plan changes don't interfere with critical billing operations while still providing responsive plan change processing for customers.\n\n> **Key Design Insight**: The component interaction patterns in subscription billing mirror those found in distributed financial systems - they require careful coordination, comprehensive error handling, and strong consistency guarantees. The complexity arises not from individual operations but from the interactions between components that must maintain financial accuracy while providing responsive customer experiences.\n\n### Implementation Guidance\n\nThe component interaction flows represent the most complex aspects of subscription billing implementation. These workflows coordinate multiple specialized components and require careful attention to error handling, data consistency, and performance. The following guidance provides concrete starting points for implementing these critical system workflows.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Workflow Orchestration | Direct function calls with try/catch | Temporal.io or Conductor workflow engine |\n| Event Publishing | In-memory event bus with immediate processing | Apache Kafka with persistent message queues |\n| Database Transactions | Single database with ACID transactions | Distributed transactions with saga pattern |\n| Error Recovery | Manual retry with exponential backoff | Circuit breaker pattern with automatic failover |\n| Monitoring | Structured logging with correlation IDs | Distributed tracing with OpenTelemetry |\n| State Management | Database-backed state machines | Redis-based distributed state with TTL |\n\n#### Recommended File Structure\n\n```\nsubscription-billing/\n├── internal/\n│   ├── workflows/                    ← component interaction orchestration\n│   │   ├── subscription_creation.py  ← subscription creation workflow\n│   │   ├── billing_cycle.py         ← monthly billing cycle workflow\n│   │   ├── plan_change.py           ← plan change and proration workflow\n│   │   └── workflow_base.py         ← common workflow infrastructure\n│   ├── events/                      ← event-driven communication\n│   │   ├── event_bus.py             ← event publishing and subscription\n│   │   ├── event_types.py           ← event type definitions\n│   │   └── handlers/                ← event handler implementations\n│   │       ├── audit_handler.py     ← audit trail event handler\n│   │       ├── notification_handler.py ← customer notification handler\n│   │       └── analytics_handler.py  ← usage analytics handler\n│   ├── coordinators/                ← workflow coordination logic\n│   │   ├── billing_coordinator.py   ← coordinates billing cycle operations\n│   │   ├── payment_coordinator.py   ← coordinates payment processing\n│   │   └── proration_coordinator.py ← coordinates proration calculations\n│   └── state_machines/              ← subscription state management\n│       ├── subscription_state.py    ← subscription lifecycle state machine\n│       ├── invoice_state.py         ← invoice processing state machine\n│       └── payment_state.py         ← payment processing state machine\n├── tests/\n│   ├── integration/                 ← end-to-end workflow tests\n│   │   ├── test_subscription_creation_flow.py\n│   │   ├── test_billing_cycle_flow.py\n│   │   └── test_plan_change_flow.py\n│   └── workflows/                   ← workflow unit tests\n└── scripts/\n    ├── run_billing_cycle.py         ← manual billing cycle trigger\n    └── fix_failed_subscriptions.py  ← recovery script for failed operations\n```\n\n#### Workflow Infrastructure Starter Code\n\n```python\n# internal/workflows/workflow_base.py\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import Dict, Any, Optional, List\nfrom enum import Enum\nimport uuid\nfrom datetime import datetime\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass WorkflowStatus(Enum):\n    PENDING = \"pending\"\n    RUNNING = \"running\" \n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    COMPENSATING = \"compensating\"  # rolling back due to failure\n\n@dataclass\nclass WorkflowStep:\n    step_id: str\n    name: str\n    status: WorkflowStatus\n    input_data: Dict[str, Any]\n    output_data: Optional[Dict[str, Any]] = None\n    error_message: Optional[str] = None\n    started_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n    retry_count: int = 0\n\n@dataclass \nclass WorkflowExecution:\n    execution_id: str\n    workflow_type: str\n    status: WorkflowStatus\n    input_data: Dict[str, Any]\n    steps: List[WorkflowStep]\n    created_at: datetime\n    updated_at: datetime\n    correlation_id: Optional[str] = None\n\nclass WorkflowExecutor(ABC):\n    \"\"\"Base class for all workflow executors that coordinate component interactions.\"\"\"\n    \n    def __init__(self, db_manager: DatabaseManager, event_bus: EventBus):\n        self.db_manager = db_manager\n        self.event_bus = event_bus\n        self.max_retries = 3\n        \n    @abstractmethod\n    def get_workflow_steps(self) -> List[str]:\n        \"\"\"Return ordered list of step names for this workflow.\"\"\"\n        pass\n        \n    @abstractmethod \n    async def execute_step(self, step_name: str, step_input: Dict[str, Any], \n                          execution: WorkflowExecution) -> Dict[str, Any]:\n        \"\"\"Execute a single workflow step and return output data.\"\"\"\n        pass\n        \n    @abstractmethod\n    async def compensate_step(self, step_name: str, step_output: Dict[str, Any],\n                             execution: WorkflowExecution) -> None:\n        \"\"\"Rollback/compensate for a completed step during failure recovery.\"\"\"\n        pass\n\n    async def execute_workflow(self, input_data: Dict[str, Any], \n                              correlation_id: Optional[str] = None) -> WorkflowExecution:\n        \"\"\"Execute complete workflow with error handling and compensation.\"\"\"\n        execution_id = str(uuid.uuid4())\n        execution = WorkflowExecution(\n            execution_id=execution_id,\n            workflow_type=self.__class__.__name__,\n            status=WorkflowStatus.PENDING,\n            input_data=input_data,\n            steps=[],\n            created_at=datetime.utcnow(),\n            updated_at=datetime.utcnow(),\n            correlation_id=correlation_id\n        )\n        \n        # Initialize workflow steps\n        for step_name in self.get_workflow_steps():\n            step = WorkflowStep(\n                step_id=str(uuid.uuid4()),\n                name=step_name, \n                status=WorkflowStatus.PENDING,\n                input_data={}\n            )\n            execution.steps.append(step)\n            \n        # Persist initial workflow state\n        await self._save_execution(execution)\n        \n        try:\n            execution.status = WorkflowStatus.RUNNING\n            await self._save_execution(execution)\n            \n            # Execute each step in sequence\n            step_input = input_data\n            for step in execution.steps:\n                step.input_data = step_input\n                step.status = WorkflowStatus.RUNNING\n                step.started_at = datetime.utcnow()\n                await self._save_execution(execution)\n                \n                try:\n                    step_output = await self.execute_step(step.name, step_input, execution)\n                    step.output_data = step_output\n                    step.status = WorkflowStatus.COMPLETED\n                    step.completed_at = datetime.utcnow()\n                    step_input = step_output  # Output becomes input for next step\n                    \n                except Exception as e:\n                    step.status = WorkflowStatus.FAILED\n                    step.error_message = str(e)\n                    step.completed_at = datetime.utcnow()\n                    await self._save_execution(execution)\n                    \n                    # Trigger compensation workflow\n                    await self._compensate_workflow(execution)\n                    raise e\n                    \n                await self._save_execution(execution)\n                \n            execution.status = WorkflowStatus.COMPLETED\n            execution.updated_at = datetime.utcnow()\n            await self._save_execution(execution)\n            \n            # Publish workflow completion event\n            await self.event_bus.publish(SubscriptionEvent(\n                event_id=uuid.uuid4(),\n                event_type=SubscriptionEventType.WORKFLOW_COMPLETED,\n                subscription_id=input_data.get('subscription_id'),\n                data={'execution_id': execution_id, 'workflow_type': execution.workflow_type},\n                idempotency_key=f\"workflow_completed_{execution_id}\",\n                created_at=datetime.utcnow()\n            ))\n            \n            return execution\n            \n        except Exception as e:\n            execution.status = WorkflowStatus.FAILED\n            execution.updated_at = datetime.utcnow()\n            await self._save_execution(execution)\n            logger.error(f\"Workflow {execution_id} failed: {e}\")\n            raise\n            \n    async def _compensate_workflow(self, execution: WorkflowExecution) -> None:\n        \"\"\"Execute compensation steps in reverse order for failed workflow.\"\"\"\n        execution.status = WorkflowStatus.COMPENSATING\n        await self._save_execution(execution)\n        \n        # Compensate completed steps in reverse order\n        completed_steps = [s for s in reversed(execution.steps) \n                          if s.status == WorkflowStatus.COMPLETED]\n        \n        for step in completed_steps:\n            try:\n                await self.compensate_step(step.name, step.output_data or {}, execution)\n                logger.info(f\"Compensated step {step.name} for workflow {execution.execution_id}\")\n            except Exception as e:\n                logger.error(f\"Failed to compensate step {step.name}: {e}\")\n                # Continue compensation of other steps even if one fails\n                \n    async def _save_execution(self, execution: WorkflowExecution) -> None:\n        \"\"\"Persist workflow execution state to database.\"\"\"\n        # TODO: Implement workflow execution persistence\n        # This should save the complete execution state including all steps\n        # to allow for workflow recovery and monitoring\n        pass\n```\n\n#### Event-Driven Communication Infrastructure\n\n```python\n# internal/events/event_bus.py\nfrom typing import Dict, List, Callable, Any\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport uuid\nimport asyncio\nimport json\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Event:\n    event_id: uuid.UUID\n    event_type: str\n    data: Dict[str, Any]\n    timestamp: datetime\n    correlation_id: Optional[str] = None\n    idempotency_key: Optional[str] = None\n\nclass EventBus:\n    \"\"\"Event bus for component communication with guaranteed delivery and deduplication.\"\"\"\n    \n    def __init__(self, db_manager: DatabaseManager):\n        self.db_manager = db_manager\n        self.handlers: Dict[str, List[Callable]] = {}\n        self.processed_events: set = set()  # For idempotency\n        \n    def subscribe(self, event_type: str, handler: Callable[[Event], None]) -> None:\n        \"\"\"Subscribe handler function to specific event type.\"\"\"\n        if event_type not in self.handlers:\n            self.handlers[event_type] = []\n        self.handlers[event_type].append(handler)\n        \n    async def publish(self, event: Event) -> bool:\n        \"\"\"Publish event to all registered handlers with idempotency protection.\"\"\"\n        # Check idempotency\n        if event.idempotency_key and event.idempotency_key in self.processed_events:\n            logger.info(f\"Skipping duplicate event {event.idempotency_key}\")\n            return True\n            \n        try:\n            # Persist event using transactional outbox pattern\n            async with self.db_manager.transaction(isolation_level=ISOLATION_LEVEL_SERIALIZABLE):\n                await self._persist_event(event)\n                \n                # Mark as processed for idempotency\n                if event.idempotency_key:\n                    self.processed_events.add(event.idempotency_key)\n                    \n            # Publish to handlers asynchronously\n            await self._notify_handlers(event)\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to publish event {event.event_id}: {e}\")\n            return False\n            \n    async def _persist_event(self, event: Event) -> None:\n        \"\"\"Persist event to outbox table for guaranteed delivery.\"\"\"\n        # TODO: Insert event into outbox table\n        # This ensures events are never lost even if handler processing fails\n        pass\n        \n    async def _notify_handlers(self, event: Event) -> None:\n        \"\"\"Notify all registered handlers for event type.\"\"\"\n        if event.event_type not in self.handlers:\n            return\n            \n        tasks = []\n        for handler in self.handlers[event.event_type]:\n            task = asyncio.create_task(self._safe_handler_call(handler, event))\n            tasks.append(task)\n            \n        if tasks:\n            await asyncio.gather(*tasks, return_exceptions=True)\n            \n    async def _safe_handler_call(self, handler: Callable, event: Event) -> None:\n        \"\"\"Call event handler with error isolation.\"\"\"\n        try:\n            if asyncio.iscoroutinefunction(handler):\n                await handler(event)\n            else:\n                handler(event)\n        except Exception as e:\n            logger.error(f\"Event handler {handler.__name__} failed for event {event.event_id}: {e}\")\n            # Handler failures don't prevent other handlers from running\n```\n\n#### Subscription Creation Workflow Implementation\n\n```python\n# internal/workflows/subscription_creation.py\nfrom internal.workflows.workflow_base import WorkflowExecutor, WorkflowStep\nfrom internal.plan_management import PlanManager\nfrom internal.subscription_engine import SubscriptionEngine\nfrom internal.proration import ProrationCalculator\nfrom internal.invoice_generator import InvoiceGenerator\nfrom internal.payment_processor import PaymentProcessor\nfrom internal.usage_tracking import UsageTracker\n\nclass SubscriptionCreationWorkflow(WorkflowExecutor):\n    \"\"\"Orchestrates subscription creation across multiple components.\"\"\"\n    \n    def __init__(self, db_manager: DatabaseManager, event_bus: EventBus,\n                 plan_manager: PlanManager, subscription_engine: SubscriptionEngine,\n                 proration_calculator: ProrationCalculator, invoice_generator: InvoiceGenerator,\n                 payment_processor: PaymentProcessor, usage_tracker: UsageTracker):\n        super().__init__(db_manager, event_bus)\n        self.plan_manager = plan_manager\n        self.subscription_engine = subscription_engine\n        self.proration_calculator = proration_calculator\n        self.invoice_generator = invoice_generator\n        self.payment_processor = payment_processor\n        self.usage_tracker = usage_tracker\n        \n    def get_workflow_steps(self) -> List[str]:\n        return [\n            \"validate_plan\",\n            \"check_customer_credit\",\n            \"calculate_proration\", \n            \"generate_invoice\",\n            \"process_payment\",\n            \"create_subscription\",\n            \"initialize_usage_tracking\"\n        ]\n        \n    async def execute_step(self, step_name: str, step_input: Dict[str, Any],\n                          execution: WorkflowExecution) -> Dict[str, Any]:\n        \"\"\"Execute individual workflow step.\"\"\"\n        \n        if step_name == \"validate_plan\":\n            # TODO 1: Extract plan_id from step_input\n            # TODO 2: Call self.plan_manager.get_plan(plan_id) to load plan details\n            # TODO 3: Validate plan is available and supports requested billing_interval\n            # TODO 4: Check if plan has trial_period_days > 0 for trial handling\n            # TODO 5: Return dict with plan details, is_trial flag, and validation status\n            pass\n            \n        elif step_name == \"check_customer_credit\":\n            # TODO 1: Extract customer_id from step_input\n            # TODO 2: Get customer credit balance using credit_balance_manager\n            # TODO 3: Validate payment_method_id through payment processor\n            # TODO 4: Check if customer has sufficient credit to cover setup fees\n            # TODO 5: Return dict with credit_balance_cents and payment_method_valid flag\n            pass\n            \n        elif step_name == \"calculate_proration\":\n            # TODO 1: Extract plan details and start_date from step_input\n            # TODO 2: If start_date is mid-cycle, calculate prorated charge using proration_calculator\n            # TODO 3: Calculate billing_cycle_anchor based on customer preference or plan default\n            # TODO 4: Determine first_billing_date considering trial periods\n            # TODO 5: Return dict with prorated_amount, billing_anchor, first_billing_date\n            pass\n            \n        elif step_name == \"generate_invoice\":\n            # TODO 1: Create invoice line items for prorated charges, setup fees, trial periods\n            # TODO 2: Apply customer credit balance if available using credit_balance_manager\n            # TODO 3: Calculate taxes if applicable based on customer location\n            # TODO 4: Generate invoice using invoice_generator.create_invoice()\n            # TODO 5: Return dict with invoice_id, total_amount_cents, and line_item_details\n            pass\n            \n        elif step_name == \"process_payment\":\n            # TODO 1: Extract invoice total and payment_method_id from step_input\n            # TODO 2: For trial subscriptions, authorize payment method without charging\n            # TODO 3: For paid subscriptions, charge payment method for invoice total\n            # TODO 4: Handle payment failures with appropriate error codes\n            # TODO 5: Return dict with payment_result, transaction_id, and payment_status\n            pass\n            \n        elif step_name == \"create_subscription\":\n            # TODO 1: Extract all subscription details from previous step outputs\n            # TODO 2: Determine initial subscription status (trialing, active, incomplete)\n            # TODO 3: Create subscription record using subscription_engine.create_subscription()\n            # TODO 4: Set next_billing_date based on trial period or billing cycle\n            # TODO 5: Return dict with subscription_id, status, and next_billing_date\n            pass\n            \n        elif step_name == \"initialize_usage_tracking\":\n            # TODO 1: Extract subscription_id and plan details from step_input\n            # TODO 2: Initialize usage allowances based on plan.usage_allowances\n            # TODO 3: Set up usage quotas and rate limiting if configured\n            # TODO 4: Create initial usage aggregation records for current billing period\n            # TODO 5: Return dict with usage_tracking_initialized flag and quota_details\n            pass\n            \n        else:\n            raise ValueError(f\"Unknown workflow step: {step_name}\")\n            \n    async def compensate_step(self, step_name: str, step_output: Dict[str, Any],\n                             execution: WorkflowExecution) -> None:\n        \"\"\"Rollback completed steps during failure recovery.\"\"\"\n        \n        if step_name == \"create_subscription\":\n            # TODO: Cancel created subscription and mark as incomplete\n            subscription_id = step_output.get('subscription_id')\n            if subscription_id:\n                await self.subscription_engine.cancel_subscription(\n                    subscription_id, immediate=True, reason=\"workflow_rollback\"\n                )\n                \n        elif step_name == \"process_payment\":\n            # TODO: Refund any charges that were processed\n            payment_result = step_output.get('payment_result')\n            if payment_result and payment_result.status == PaymentStatus.SUCCEEDED:\n                await self.payment_processor.refund_payment(\n                    payment_result.payment_id, payment_result.amount, \n                    reason=\"subscription_creation_failed\"\n                )\n                \n        elif step_name == \"generate_invoice\":\n            # TODO: Mark invoice as void to prevent collection attempts\n            invoice_id = step_output.get('invoice_id')\n            if invoice_id:\n                await self.invoice_generator.void_invoice(invoice_id, reason=\"workflow_failed\")\n```\n\n#### Billing Cycle Workflow Skeleton\n\n```python\n# internal/workflows/billing_cycle.py  \nclass BillingCycleWorkflow(WorkflowExecutor):\n    \"\"\"Orchestrates monthly billing cycle processing.\"\"\"\n    \n    def get_workflow_steps(self) -> List[str]:\n        return [\n            \"identify_due_subscriptions\",\n            \"aggregate_usage_data\", \n            \"calculate_charges\",\n            \"generate_invoices\",\n            \"process_payments\",\n            \"update_subscriptions\",\n            \"reset_usage_tracking\"\n        ]\n        \n    async def execute_step(self, step_name: str, step_input: Dict[str, Any],\n                          execution: WorkflowExecution) -> Dict[str, Any]:\n        \n        if step_name == \"identify_due_subscriptions\":\n            # TODO 1: Query subscriptions where next_billing_date = current_date\n            # TODO 2: Filter by status in [active, trialing] and exclude paused/cancelled\n            # TODO 3: Group by customer timezone for accurate billing timing\n            # TODO 4: Check for trial subscriptions ending today requiring activation\n            # TODO 5: Return dict with subscription_ids list and timezone_groups\n            pass\n            \n        elif step_name == \"aggregate_usage_data\":\n            # TODO 1: For each subscription, get last_billing_date and current billing date\n            # TODO 2: Call usage_tracker.aggregate_billing_period() for date range\n            # TODO 3: Calculate overage amounts for usage exceeding plan allowances\n            # TODO 4: Handle timezone-specific aggregation windows correctly\n            # TODO 5: Return dict with usage_aggregations keyed by subscription_id\n            pass\n            \n        # Additional steps follow same pattern...\n```\n\n#### Milestone Checkpoints\n\n**Subscription Creation Flow Checkpoint:**\nAfter implementing the subscription creation workflow, verify functionality with these tests:\n\n1. **Successful Creation Test**: Create subscription with valid plan and payment method\n   - Expected: Subscription in `active` status, invoice generated and paid, usage tracking initialized\n   - Command: `python -m pytest tests/integration/test_subscription_creation_flow.py::test_successful_creation`\n\n2. **Trial Subscription Test**: Create subscription with trial period\n   - Expected: Subscription in `trialing` status, payment method authorized but not charged\n   - Command: `python -m pytest tests/integration/test_subscription_creation_flow.py::test_trial_creation`\n\n3. **Payment Failure Recovery**: Test subscription creation with failed payment\n   - Expected: Subscription in `incomplete` status, no access granted, retry scheduled\n   - Command: `python -m pytest tests/integration/test_subscription_creation_flow.py::test_payment_failure`\n\n**Billing Cycle Flow Checkpoint:**\nVerify billing cycle processing with these scenarios:\n\n1. **Standard Renewal**: Process renewal for active subscription with usage\n   - Expected: New invoice generated, payment processed, next billing date updated\n   - Command: `python scripts/run_billing_cycle.py --subscription-id <test_id>`\n\n2. **Usage Overage Billing**: Process subscription with usage exceeding allowances\n   - Expected: Base charge plus overage charges, detailed line items in invoice\n   - Command: `python -m pytest tests/integration/test_billing_cycle_flow.py::test_usage_overage`\n\n**Plan Change Flow Checkpoint:**\nTest plan change scenarios thoroughly:\n\n1. **Immediate Upgrade**: Change to higher-tier plan with immediate effect\n   - Expected: Prorated charge applied, features activated immediately, next billing unchanged\n   - Command: `python -m pytest tests/integration/test_plan_change_flow.py::test_immediate_upgrade`\n\n2. **Downgrade with Credit**: Change to lower-tier plan with credit calculation\n   - Expected: Credit applied to customer balance, features adjusted, future invoices reduced\n   - Command: `python -m pytest tests/integration/test_plan_change_flow.py::test_downgrade_with_credit`\n\n#### Common Integration Issues\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---------|-------------|-----------|-----|\n| Subscription creation hangs | Payment gateway timeout | Check payment processor logs for network timeouts | Add timeout configuration and retry logic |\n| Billing cycle processes same subscription twice | Missing idempotency key or duplicate billing dates | Check for null idempotency_key in billing_executions table | Implement unique constraints on billing execution |\n| Plan changes lose feature access | Race condition between plan update and feature check | Check timestamp ordering of plan_change and access_check events | Add version numbers to subscription feature cache |\n| Usage aggregation returns zero | Timezone mismatch in billing period boundaries | Compare usage_event timestamps with billing_period_start/end | Normalize all timestamps to UTC in database |\n| Proration calculations drift over time | Rounding errors accumulating across multiple changes | Track total_adjustments_cents field and check for drift | Use banker's rounding and periodic reconciliation |\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** All milestones - provides robust failure recovery, consistency guarantees, and edge case handling essential for production billing operations across plan management (Milestone 1), subscription lifecycle (Milestone 2), proration (Milestone 3), and usage-based billing (Milestone 4)\n\n### Mental Model: Financial Fault Tolerance\n\nThink of error handling in a subscription billing system like the safety systems in a nuclear power plant. In a power plant, every critical operation has multiple layers of protection: automatic shutdown systems, backup power supplies, containment structures, and emergency response procedures. Similarly, billing systems need multiple layers of protection because financial errors can be catastrophic - a single bug could overcharge thousands of customers or lose millions in revenue.\n\nJust as a nuclear engineer designs for \"defense in depth\" with multiple independent safety systems, we must design billing systems with layered error handling: input validation prevents bad data from entering, transaction boundaries ensure atomicity, idempotency keys prevent duplicate operations, retry mechanisms handle transient failures, and compensation workflows can roll back complex multi-step operations. The goal is that no single point of failure can compromise the financial integrity of the system.\n\nLike emergency response teams that regularly drill disaster scenarios, billing systems must be tested against failure modes that seem unlikely but would be devastating if they occurred. This means thinking through edge cases like leap years affecting billing dates, timezone changes during daylight saving transitions, and what happens when external payment systems become unavailable during peak billing periods.\n\n### Payment Failure Recovery\n\nPayment failures are inevitable in subscription billing - credit cards expire, bank accounts run out of funds, and payment processors experience outages. The key to graceful payment failure recovery is implementing a systematic **dunning management** process that maximizes revenue recovery while maintaining positive customer relationships.\n\nThe foundation of payment failure recovery is the **grace period** concept. When a payment fails, the subscription doesn't immediately terminate. Instead, it transitions to a `past_due` status where the customer retains access to the service while the system attempts recovery. This approach recognizes that many payment failures are temporary - a declined card might work again in a few hours after the customer resolves a temporary hold.\n\n> **Decision: Dunning Management Strategy**\n> - **Context**: Payment failures require systematic retry logic with escalating actions to maximize recovery while avoiding customer frustration\n> - **Options Considered**: Immediate cancellation, fixed retry schedule, exponential backoff with customer communication\n> - **Decision**: Multi-stage dunning with smart retry timing and proactive customer communication\n> - **Rationale**: Balances revenue recovery (fixed schedules recover more revenue) with customer experience (exponential backoff reduces payment spam)\n> - **Consequences**: Requires complex state management but significantly improves payment recovery rates and customer satisfaction\n\nThe dunning process follows a structured escalation pattern designed around customer psychology and payment system behaviors:\n\n| Dunning Stage | Timing | Action | Purpose | Success Rate |\n|---------------|--------|--------|---------|--------------|\n| Immediate Retry | 1 hour after failure | Retry payment with same method | Catch temporary declines | 15-20% |\n| Early Recovery | Day 1, 3, 5 | Retry + email notification | Allow customer self-service | 25-30% |\n| Active Recovery | Day 7, 10 | Retry + access restriction warnings | Create urgency | 20-25% |\n| Final Recovery | Day 14 | Final retry + suspension notice | Last chance recovery | 10-15% |\n| Suspension | Day 17 | Suspend service, retain data | Minimize churn | 5-10% monthly recovery |\n\nSmart retry timing adapts to failure types because different decline reasons have different optimal retry patterns. A \"insufficient funds\" decline might succeed after payday, while \"card expired\" requires customer action. The system tracks decline codes from the payment gateway and adjusts retry schedules accordingly:\n\n```\nDecline Code Analysis:\n- Insufficient Funds → Retry after 3-5 days (payday cycle)\n- Expired Card → Email immediately, retry weekly\n- Fraud Prevention → Retry hourly for first day, then daily\n- Processing Error → Exponential backoff starting at 1 hour\n```\n\n**Dunning Action** execution must be idempotent because network failures can cause duplicate webhook deliveries. Each dunning attempt receives a unique idempotency key combining the subscription ID, invoice ID, and attempt number. The system tracks all dunning attempts in an audit trail to prevent duplicate charges and ensure compliance with payment regulations.\n\nCustomer communication during dunning is critical for maintaining relationships. The system generates contextual messages based on the failure reason and customer history. High-value customers might receive phone call triggers, while newer customers get educational emails about updating payment methods. The key insight is that dunning is a customer success opportunity, not just a revenue recovery mechanism.\n\n> The critical principle in payment failure recovery is graduated response - start gently with technical retries, escalate to customer communication, and only restrict access as a last resort. Customers often don't realize their payment failed until they receive a notification.\n\nPayment method fallback provides an additional recovery layer. When a customer has multiple payment methods on file, the system automatically attempts the secondary method after the primary fails. This requires careful sequencing to avoid double-charging if the primary payment succeeds on retry after the secondary was already charged.\n\n### Data Consistency and Concurrency\n\nSubscription billing systems must maintain strict **financial precision** across distributed operations while handling concurrent access from multiple sources: customer self-service portals, admin interfaces, automated billing cycles, and webhook processing from payment gateways. The challenge is ensuring that financial state remains consistent even when multiple operations attempt to modify the same subscription simultaneously.\n\nThe foundation of consistency in billing systems is the **transactional outbox** pattern. Every financial operation - subscription creation, plan changes, usage recording, payment processing - executes within a single database transaction that both updates business entities and writes events to an outbox table. This ensures that the business state change and the corresponding event publication are atomic, preventing the common failure mode where a database update succeeds but the downstream notification fails.\n\n| Operation Type | Consistency Requirements | Isolation Level | Concurrent Conflicts |\n|----------------|-------------------------|-----------------|---------------------|\n| Subscription Creation | Customer must exist, plan must be valid | `SERIALIZABLE` | Duplicate customer subscriptions |\n| Plan Changes | No overlapping changes in billing cycle | `SERIALIZABLE` | Mid-cycle plan change races |\n| Usage Recording | Idempotent event ingestion | `READ_COMMITTED` | Duplicate event submission |\n| Payment Processing | Invoice amount must match charges | `SERIALIZABLE` | Concurrent payment attempts |\n| Credit Application | Balance must not go negative | `SERIALIZABLE` | Credit balance races |\n\n**Optimistic concurrency control** prevents lost updates when multiple processes modify subscription state simultaneously. Each financial entity includes a version number that increments with every update. Operations read the current version, perform their calculations, and attempt to update only if the version matches. If the version has changed, indicating another process modified the entity, the operation retries with fresh data.\n\nThe subscription state machine enforces valid transitions through database constraints and application logic. Concurrent state changes are serialized using database row locks on the subscription record. For example, if an automated renewal process attempts to transition a subscription from `active` to `past_due` due to payment failure, while simultaneously an admin user tries to cancel the subscription, the database ensures only one transition succeeds and the other receives a conflict error that triggers retry logic.\n\n```\nConcurrency Control Example:\n1. Billing cycle starts renewal for subscription_123 (version 15)\n2. Admin user starts cancellation for subscription_123 (version 15)  \n3. Billing update: SET status='past_due', version=16 WHERE id='123' AND version=15\n4. Admin update: SET status='cancelled', version=16 WHERE id='123' AND version=15\n5. First update succeeds, second fails (version already 16)\n6. Admin operation retries with version 16, sees past_due status\n7. Admin logic decides: cancel past_due subscription immediately\n```\n\n**Credit balance management** requires special attention to race conditions because credits can be applied and consumed concurrently. The system uses database-level atomic operations for credit adjustments, implemented through stored procedures or application-level locking. Credit consumption operations always check available balance within the same transaction that applies the credit to prevent negative balances.\n\nEvent ordering and idempotency prevent duplicate processing when webhook deliveries arrive out of order or multiple times. Each webhook event includes a gateway-provided event ID and timestamp. The system maintains a processed events table with unique constraints on the gateway event ID, ensuring duplicate webhook deliveries are silently ignored rather than causing double-processing.\n\n> **Decision: Event Processing Architecture**\n> - **Context**: Webhook events can arrive out of order, be delivered multiple times, or be lost entirely, requiring robust event processing\n> - **Options Considered**: Direct processing, event sourcing with replay, transactional outbox with deduplication\n> - **Decision**: Transactional outbox with idempotency keys and event ordering by timestamp\n> - **Rationale**: Provides exactly-once processing guarantees while maintaining audit trail and enabling replay for debugging\n> - **Consequences**: Additional storage overhead but eliminates duplicate payment processing and enables reliable event replay\n\n**Distributed transaction management** across multiple services uses the **saga pattern** rather than two-phase commit. Complex operations like subscription creation span multiple components: customer validation, plan entitlement setup, payment method verification, and initial invoice generation. Each step in the saga can complete independently, with compensation actions defined to roll back completed steps if later steps fail.\n\nThe saga coordinator tracks workflow progress and handles partial failures by executing compensation steps in reverse order. For example, if subscription creation fails during payment method verification after successfully creating the subscription record and setting up entitlements, the compensation workflow removes the entitlements and marks the subscription as `incomplete` rather than leaving it in an inconsistent state.\n\n### Billing Edge Cases\n\nBilling systems encounter numerous edge cases related to time, calendar arithmetic, and timezone handling that can cause subtle but expensive bugs. These edge cases often surface during specific calendar events like leap years, daylight saving transitions, and month-end billing cycles, making them difficult to catch in normal testing but critical to handle correctly in production.\n\n**Calendar arithmetic** presents the most common source of billing edge cases. The **billing anchor** concept helps maintain consistent billing dates, but month overflow situations require careful handling. When a subscription starts on January 31st with monthly billing, the naive approach of adding one month results in February 31st, which doesn't exist. The system must define consistent rules for handling these overflows:\n\n| Billing Anchor | Next Billing Date | Rule Applied | Alternative Approaches |\n|----------------|------------------|--------------|----------------------|\n| January 31 | February 28 (non-leap), February 29 (leap) | End-of-month clamping | Use February 28 always, Use March 3 |\n| March 31 | April 30 | Month-end clamping | Use April 31 → May 1 |\n| February 29 (leap year) | March 29 (following year) | Day preservation when possible | Always use March 28, Use March 1 |\n\nThe chosen approach is **anchor day preservation** with end-of-month clamping. If the anchor day exists in the target month, use it. If not, use the last day of the target month. This provides predictable billing dates that customers can understand while avoiding the complexity of variable-length billing periods.\n\n**Timezone handling** becomes complex when customers can change their billing timezone or when daylight saving transitions affect billing schedules. The system stores all timestamps in UTC and converts to customer timezone only for display purposes. Billing calculations always use UTC to ensure consistency, but customer communication uses local time to avoid confusion.\n\nDaylight saving transitions can cause apparent billing time shifts. A customer in New York with 9 AM billing might see their next bill generated at 8 AM local time after the spring forward transition. To avoid customer confusion, the system communicates billing times in terms of \"billing date\" rather than specific times, and processes all billing for a given date in a single batch operation.\n\n> The cardinal rule of billing timezone handling is: store in UTC, calculate in UTC, display in customer timezone. Never perform financial calculations using local time - daylight saving transitions can cause billing to run twice or be skipped entirely.\n\n**Leap year handling** affects annual billing cycles and usage aggregation periods. February 29th poses special challenges for anniversary-based billing. A customer who subscribes on February 29th during a leap year needs a consistent anniversary date in non-leap years. The system uses February 28th as the anniversary in non-leap years, with clear customer communication about this adjustment.\n\nUsage aggregation during leap years must account for the extra day in February when calculating monthly averages or comparing year-over-year usage patterns. The system normalizes usage metrics by billing period length to ensure fair comparisons across different month lengths.\n\n**Currency precision and rounding** requires careful attention to avoid accumulating errors across many customers. The system uses integer arithmetic with the smallest currency unit (cents for USD, pence for GBP) to avoid floating-point precision issues. All monetary calculations use the `Money` type with explicit rounding rules applied at specific points in the calculation pipeline.\n\nProration calculations are particularly susceptible to rounding errors because they involve division operations. The system applies rounding only at the final step of each calculation, maintaining full precision through intermediate steps. When proration results in fractional cents, the system uses \"round half to even\" (banker's rounding) to prevent systematic bias in either customer or company favor.\n\n| Rounding Scenario | Amount Before Rounding | Rounded Amount | Rule Applied |\n|------------------|----------------------|----------------|--------------|\n| Monthly proration | $29.996666... | $30.00 | Round up at 0.5 cents |\n| Daily proration | $1.235 | $1.24 | Round half to even (odd result) |\n| Quantity-based proration | $15.245 | $15.24 | Round half to even (even result) |\n| Usage overage | $0.001234 | $0.00 | Minimum charge threshold |\n\n**Cross-month billing cycles** create edge cases when subscription events occur near month boundaries. A subscription cancelled on the last day of the month might have its final invoice generated in the following month, affecting revenue reporting and customer communication timing. The system maintains strict separation between billing period boundaries and invoice generation dates to ensure accurate financial reporting.\n\n**Retroactive adjustments** handle situations where billing corrections must be applied after invoices have been generated. This occurs when usage data arrives late, pricing errors are discovered, or customer service approves billing adjustments. The system creates adjustment line items on future invoices rather than modifying historical invoices, maintaining audit trail integrity while ensuring customers see the corrections.\n\nUsage event late arrival requires special handling because aggregation windows must close to generate invoices, but some events may arrive after the window closes. The system defines a \"late arrival window\" (typically 7 days) during which late events are accepted and applied as adjustments to the following invoice. Events arriving after this window are logged but not applied to avoid indefinite billing uncertainty.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Error Tracking | Python logging + file rotation | Sentry or Datadog APM with structured logging |\n| Circuit Breaker | Custom retry with exponential backoff | Tenacity library with circuit breaker patterns |\n| Database Transactions | PostgreSQL with explicit transaction blocks | SQLAlchemy with session management and savepoints |\n| Webhook Processing | Flask/FastAPI with request validation | Celery task queue with Redis for webhook processing |\n| Event Outbox | Database table with background polling | Debezium CDC with Kafka for reliable event streaming |\n| Concurrency Control | Database row locks with version columns | Distributed locks with Redis or ZooKeeper |\n\n#### Recommended File Structure\n\n```\nbilling_system/\n  src/\n    error_handling/\n      __init__.py\n      exceptions.py              ← Custom exception hierarchy\n      retry_policies.py          ← Retry strategies and circuit breakers\n      transaction_manager.py     ← Database transaction utilities\n    dunning/\n      __init__.py\n      dunning_engine.py         ← Payment failure recovery logic  \n      dunning_actions.py        ← Email, restriction, retry actions\n      dunning_scheduler.py      ← Retry timing and escalation\n    concurrency/\n      __init__.py\n      locks.py                  ← Optimistic concurrency control\n      outbox.py                 ← Transactional outbox pattern\n      saga_coordinator.py       ← Distributed transaction management\n    edge_cases/\n      __init__.py\n      calendar_utils.py         ← Timezone and date arithmetic\n      currency_precision.py     ← Money handling and rounding\n      billing_calendar.py       ← Billing anchor and cycle calculation\n  tests/\n    test_error_scenarios/       ← Payment failure simulation tests\n    test_concurrency/          ← Race condition and deadlock tests  \n    test_edge_cases/           ← Calendar edge case test suite\n```\n\n#### Infrastructure Starter Code\n\n**Custom Exception Hierarchy**\n\n```python\n# src/error_handling/exceptions.py\nfrom typing import Optional, Dict, Any\nfrom enum import Enum\nimport logging\n\nclass BillingErrorType(Enum):\n    PAYMENT_FAILED = \"payment_failed\"\n    INSUFFICIENT_CREDIT = \"insufficient_credit\"\n    INVALID_SUBSCRIPTION_STATE = \"invalid_subscription_state\"\n    PRORATION_ERROR = \"proration_error\"\n    USAGE_VALIDATION_ERROR = \"usage_validation_error\"\n    CONCURRENCY_CONFLICT = \"concurrency_conflict\"\n    EXTERNAL_SERVICE_ERROR = \"external_service_error\"\n\nclass BillingException(Exception):\n    \"\"\"Base exception for all billing system errors with structured error information.\"\"\"\n    \n    def __init__(\n        self,\n        message: str,\n        error_type: BillingErrorType,\n        entity_id: Optional[str] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n        cause: Optional[Exception] = None\n    ):\n        super().__init__(message)\n        self.error_type = error_type\n        self.entity_id = entity_id\n        self.metadata = metadata or {}\n        self.cause = cause\n        \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"error_type\": self.error_type.value,\n            \"message\": str(self),\n            \"entity_id\": self.entity_id,\n            \"metadata\": self.metadata\n        }\n\nclass PaymentFailedException(BillingException):\n    def __init__(self, message: str, payment_id: str, decline_code: Optional[str] = None):\n        metadata = {\"payment_id\": payment_id}\n        if decline_code:\n            metadata[\"decline_code\"] = decline_code\n        super().__init__(message, BillingErrorType.PAYMENT_FAILED, payment_id, metadata)\n\nclass ConcurrencyConflictException(BillingException):\n    def __init__(self, message: str, entity_type: str, entity_id: str, expected_version: int, actual_version: int):\n        metadata = {\n            \"entity_type\": entity_type,\n            \"expected_version\": expected_version,\n            \"actual_version\": actual_version\n        }\n        super().__init__(message, BillingErrorType.CONCURRENCY_CONFLICT, entity_id, metadata)\n\nclass SubscriptionStateException(BillingException):\n    def __init__(self, message: str, subscription_id: str, current_state: str, attempted_transition: str):\n        metadata = {\n            \"current_state\": current_state,\n            \"attempted_transition\": attempted_transition\n        }\n        super().__init__(message, BillingErrorType.INVALID_SUBSCRIPTION_STATE, subscription_id, metadata)\n```\n\n**Retry Policy Implementation**\n\n```python\n# src/error_handling/retry_policies.py\nimport time\nimport random\nimport logging\nfrom typing import Optional, Callable, Type, Tuple\nfrom functools import wraps\nfrom dataclasses import dataclass\nfrom .exceptions import BillingException, BillingErrorType\n\n@dataclass\nclass RetryConfig:\n    max_attempts: int = 3\n    base_delay: float = 1.0\n    max_delay: float = 60.0\n    exponential_base: float = 2.0\n    jitter: bool = True\n    retryable_exceptions: Tuple[Type[Exception], ...] = (Exception,)\n    non_retryable_error_types: Tuple[BillingErrorType, ...] = (\n        BillingErrorType.INVALID_SUBSCRIPTION_STATE,\n        BillingErrorType.INSUFFICIENT_CREDIT\n    )\n\nclass CircuitBreaker:\n    \"\"\"Circuit breaker implementation to prevent cascading failures.\"\"\"\n    \n    def __init__(self, failure_threshold: int = 5, timeout: float = 60.0):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.failure_count = 0\n        self.last_failure_time = None\n        self.state = \"closed\"  # closed, open, half_open\n        \n    def is_available(self) -> bool:\n        if self.state == \"closed\":\n            return True\n        elif self.state == \"open\":\n            if time.time() - self.last_failure_time >= self.timeout:\n                self.state = \"half_open\"\n                return True\n            return False\n        else:  # half_open\n            return True\n    \n    def record_success(self):\n        self.failure_count = 0\n        self.state = \"closed\"\n        \n    def record_failure(self):\n        self.failure_count += 1\n        self.last_failure_time = time.time()\n        if self.failure_count >= self.failure_threshold:\n            self.state = \"open\"\n\ndef retry_with_backoff(config: RetryConfig = None):\n    \"\"\"Decorator for automatic retry with exponential backoff.\"\"\"\n    if config is None:\n        config = RetryConfig()\n        \n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            last_exception = None\n            \n            for attempt in range(config.max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    last_exception = e\n                    \n                    # Check if exception is retryable\n                    if not isinstance(e, config.retryable_exceptions):\n                        raise\n                    \n                    # Check if billing error type is non-retryable\n                    if isinstance(e, BillingException) and e.error_type in config.non_retryable_error_types:\n                        raise\n                    \n                    # Don't sleep on last attempt\n                    if attempt == config.max_attempts - 1:\n                        break\n                        \n                    # Calculate delay with exponential backoff and jitter\n                    delay = min(\n                        config.base_delay * (config.exponential_base ** attempt),\n                        config.max_delay\n                    )\n                    \n                    if config.jitter:\n                        delay = delay * (0.5 + random.random() * 0.5)\n                    \n                    logging.warning(f\"Attempt {attempt + 1} failed, retrying in {delay:.2f}s: {e}\")\n                    time.sleep(delay)\n            \n            raise last_exception\n        return wrapper\n    return decorator\n```\n\n**Transaction Manager**\n\n```python\n# src/error_handling/transaction_manager.py\nimport logging\nfrom contextlib import contextmanager\nfrom typing import Optional, Any, Dict\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom .exceptions import BillingException, BillingErrorType\n\nclass TransactionManager:\n    \"\"\"Manages database transactions with proper error handling and rollback.\"\"\"\n    \n    def __init__(self, database_url: str):\n        self.engine = create_engine(database_url)\n        self.SessionLocal = sessionmaker(bind=self.engine)\n        \n    @contextmanager\n    def transaction(self, isolation_level: Optional[str] = None):\n        \"\"\"Database transaction context manager with automatic rollback on errors.\"\"\"\n        session = self.SessionLocal()\n        \n        if isolation_level:\n            session.connection(execution_options={\"isolation_level\": isolation_level})\n            \n        try:\n            yield session\n            session.commit()\n            logging.info(\"Transaction committed successfully\")\n        except SQLAlchemyError as e:\n            session.rollback()\n            logging.error(f\"Database error, transaction rolled back: {e}\")\n            raise BillingException(\n                f\"Database transaction failed: {str(e)}\",\n                BillingErrorType.EXTERNAL_SERVICE_ERROR,\n                cause=e\n            )\n        except Exception as e:\n            session.rollback()\n            logging.error(f\"Unexpected error, transaction rolled back: {e}\")\n            raise\n        finally:\n            session.close()\n            \n    def create_savepoint(self, session: Session, savepoint_name: str):\n        \"\"\"Create named savepoint for partial rollback within transaction.\"\"\"\n        try:\n            session.begin_nested()\n            return savepoint_name\n        except SQLAlchemyError as e:\n            raise BillingException(\n                f\"Failed to create savepoint {savepoint_name}: {str(e)}\",\n                BillingErrorType.EXTERNAL_SERVICE_ERROR,\n                cause=e\n            )\n```\n\n#### Core Logic Skeleton Code\n\n**Dunning Engine Implementation**\n\n```python\n# src/dunning/dunning_engine.py\nfrom datetime import datetime, timedelta\nfrom typing import List, Optional, Dict, Any\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom ..models import Subscription, Invoice, Payment, PaymentStatus\nfrom ..error_handling.exceptions import BillingException, BillingErrorType\nfrom ..error_handling.retry_policies import retry_with_backoff, RetryConfig\n\nclass DunningStage(Enum):\n    IMMEDIATE_RETRY = \"immediate_retry\"\n    EARLY_RECOVERY = \"early_recovery\" \n    ACTIVE_RECOVERY = \"active_recovery\"\n    FINAL_RECOVERY = \"final_recovery\"\n    SUSPENDED = \"suspended\"\n\n@dataclass\nclass DunningAttempt:\n    attempt_id: str\n    subscription_id: str\n    invoice_id: str\n    stage: DunningStage\n    scheduled_at: datetime\n    completed_at: Optional[datetime]\n    success: bool\n    decline_code: Optional[str]\n    next_attempt_at: Optional[datetime]\n\nclass DunningEngine:\n    \"\"\"Manages payment failure recovery with graduated escalation.\"\"\"\n    \n    def __init__(self, payment_processor, notification_service, transaction_manager):\n        self.payment_processor = payment_processor\n        self.notification_service = notification_service\n        self.transaction_manager = transaction_manager\n        \n    def handle_payment_failure(\n        self,\n        subscription_id: str,\n        invoice_id: str,\n        failure_reason: str,\n        idempotency_key: str\n    ) -> None:\n        \"\"\"Initiate dunning process for failed payment.\"\"\"\n        # TODO 1: Check if dunning already started for this invoice (idempotency)\n        # TODO 2: Analyze failure reason to determine appropriate retry strategy\n        # TODO 3: Transition subscription to past_due status with grace period\n        # TODO 4: Schedule immediate retry attempt based on decline code\n        # TODO 5: Send initial customer notification about payment failure\n        # TODO 6: Create dunning attempt record with tracking information\n        # Hint: Different decline codes need different retry timing\n        pass\n        \n    def process_dunning_retry(self, subscription_id: str) -> bool:\n        \"\"\"Execute next dunning attempt for subscription.\"\"\"\n        # TODO 1: Load current dunning state and determine next stage\n        # TODO 2: Check if subscription is still eligible for dunning\n        # TODO 3: Attempt payment retry using stored payment method\n        # TODO 4: Process retry result and update dunning state\n        # TODO 5: Schedule next attempt or escalate based on result\n        # TODO 6: Send appropriate customer communication for stage\n        # TODO 7: Update subscription status if recovery successful\n        # Hint: Use exponential backoff for technical failures, fixed schedule for customer issues\n        pass\n        \n    def escalate_dunning_stage(self, subscription_id: str, current_stage: DunningStage) -> DunningStage:\n        \"\"\"Determine next dunning stage based on current stage and elapsed time.\"\"\"\n        # TODO 1: Calculate days since initial payment failure\n        # TODO 2: Apply dunning policy rules to determine next stage\n        # TODO 3: Check for any customer-specific dunning overrides\n        # TODO 4: Return appropriate next stage or suspension\n        # Hint: Different customer tiers may have different dunning schedules\n        pass\n        \n    @retry_with_backoff(RetryConfig(max_attempts=3, base_delay=2.0))\n    def attempt_payment_recovery(self, subscription_id: str, payment_method_id: str) -> bool:\n        \"\"\"Attempt payment retry with the customer's payment method.\"\"\"\n        # TODO 1: Validate subscription is in past_due status\n        # TODO 2: Calculate amount due including any late fees\n        # TODO 3: Call payment processor with idempotency protection\n        # TODO 4: Handle payment success/failure and update records\n        # TODO 5: Apply any credits or adjustments to the payment\n        # Hint: Always use unique idempotency keys for each retry attempt\n        pass\n```\n\n**Concurrency Control Implementation**\n\n```python\n# src/concurrency/locks.py\nfrom typing import Optional, Any, Dict, Type, TypeVar\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.exc import IntegrityError\nfrom ..models import BaseEntity\nfrom ..error_handling.exceptions import ConcurrencyConflictException\n\nT = TypeVar('T', bound=BaseEntity)\n\nclass OptimisticLockManager:\n    \"\"\"Manages optimistic concurrency control using entity version numbers.\"\"\"\n    \n    def __init__(self, session: Session):\n        self.session = session\n        \n    def load_with_lock(self, entity_class: Type[T], entity_id: str) -> Optional[T]:\n        \"\"\"Load entity with current version for optimistic locking.\"\"\"\n        # TODO 1: Query entity by ID and return with current version\n        # TODO 2: Return None if entity doesn't exist\n        # TODO 3: Log entity load for debugging concurrency issues\n        # Hint: Always load the version column for comparison\n        pass\n        \n    def save_with_version_check(self, entity: T) -> T:\n        \"\"\"Save entity with optimistic lock version checking.\"\"\"\n        # TODO 1: Increment entity version number before save\n        # TODO 2: Attempt database update with WHERE version = old_version\n        # TODO 3: Check if update affected any rows (version conflict)\n        # TODO 4: Raise ConcurrencyConflictException if version mismatch\n        # TODO 5: Return updated entity with new version\n        # TODO 6: Handle database constraint violations gracefully\n        # Hint: Use UPDATE ... WHERE id = ? AND version = ? to detect conflicts\n        pass\n        \n    def retry_on_conflict(self, operation_func, max_retries: int = 3):\n        \"\"\"Retry operation on optimistic lock conflicts.\"\"\"\n        # TODO 1: Execute operation function with fresh entity load\n        # TODO 2: Catch ConcurrencyConflictException and retry\n        # TODO 3: Implement exponential backoff between retries\n        # TODO 4: Re-raise exception after max retries exceeded\n        # TODO 5: Log retry attempts for monitoring\n        # Hint: Reload entity data before each retry attempt\n        pass\n```\n\n**Billing Edge Case Utilities**\n\n```python\n# src/edge_cases/billing_calendar.py\nfrom datetime import datetime, date, timedelta\nfrom typing import Optional\nfrom dateutil.relativedelta import relativedelta\nimport pytz\nfrom ..models import BillingInterval\n\nclass BillingCalendar:\n    \"\"\"Handles billing date calculations with proper edge case handling.\"\"\"\n    \n    def calculate_next_billing_date(\n        self,\n        current_date: date,\n        billing_interval: BillingInterval,\n        billing_anchor: int,\n        timezone: Optional[str] = None\n    ) -> date:\n        \"\"\"Calculate next billing date handling month overflow and leap years.\"\"\"\n        # TODO 1: Handle timezone conversion from UTC to customer timezone\n        # TODO 2: Apply billing interval (monthly, yearly) using relativedelta\n        # TODO 3: Handle month overflow (Jan 31 + 1 month = Feb 28/29)\n        # TODO 4: Handle leap year edge cases for February 29 anchors\n        # TODO 5: Ensure billing date doesn't go backwards due to DST\n        # TODO 6: Convert result back to UTC for storage\n        # Hint: Use end-of-month clamping for month overflow situations\n        pass\n        \n    def calculate_proration_factor(\n        self,\n        change_date: datetime,\n        period_start: datetime,\n        period_end: datetime\n    ) -> float:\n        \"\"\"Calculate time-based proration factor for partial billing periods.\"\"\"\n        # TODO 1: Validate that change_date falls within billing period\n        # TODO 2: Calculate total period length in seconds for precision\n        # TODO 3: Calculate remaining period length from change date\n        # TODO 4: Return factor as remaining_time / total_time\n        # TODO 5: Handle edge case where change_date equals period boundaries\n        # TODO 6: Ensure factor is between 0.0 and 1.0\n        # Hint: Use seconds for calculation to avoid leap second issues\n        pass\n        \n    def handle_leap_year_anniversary(self, original_date: date, target_year: int) -> date:\n        \"\"\"Handle leap year edge cases for annual billing anniversaries.\"\"\"\n        # TODO 1: Check if original date is February 29\n        # TODO 2: Check if target year is a leap year\n        # TODO 3: If Feb 29 -> non-leap year, use Feb 28\n        # TODO 4: If Feb 29 -> leap year, preserve Feb 29\n        # TODO 5: Handle other leap year boundary conditions\n        # TODO 6: Return adjusted anniversary date\n        # Hint: Use calendar.isleap() to check leap year status\n        pass\n```\n\n#### Milestone Checkpoints\n\n**Payment Failure Recovery Validation:**\n- Start subscription with valid payment method\n- Simulate payment failure by marking payment method as declined\n- Verify subscription transitions to `past_due` status within grace period\n- Check that retry attempts are scheduled according to dunning policy\n- Confirm customer notifications are sent at appropriate intervals\n- Validate that successful retry restores subscription to `active` status\n\n**Concurrency Control Testing:**\n- Start two concurrent plan change operations on same subscription\n- Verify that only one operation succeeds and other receives conflict error\n- Check that failed operation retries with fresh entity version\n- Confirm that final state is consistent with last successful operation\n- Test credit balance race conditions with concurrent consumption\n\n**Edge Case Handling Verification:**\n- Create subscription with January 31 billing anchor\n- Verify February billing date is February 28 (or 29 in leap year)\n- Test timezone changes during daylight saving transitions\n- Confirm proration calculations handle fractional cents correctly\n- Validate leap year anniversary handling for February 29 subscriptions\n\n#### Common Pitfalls and Debugging\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|-------------|-----------------|-----|\n| Duplicate payment charges | Webhook processing without idempotency | Check payment_events table for duplicate gateway_event_id | Add unique constraint on gateway_event_id |\n| Subscription stuck in past_due | Dunning retry logic not scheduling | Check dunning_attempts table for next_attempt_at values | Fix dunning scheduler cron job |\n| Proration amounts off by cents | Floating point precision errors | Log intermediate calculation values | Use integer cent arithmetic throughout |\n| Billing dates drift over time | Month overflow not handled consistently | Compare expected vs actual billing dates | Implement end-of-month clamping rule |\n| Credit balance goes negative | Race condition in credit consumption | Check for concurrent credit applications | Add database constraint on credit balance >= 0 |\n| Payment retries spam customer | Circuit breaker not working | Monitor payment attempt frequency | Implement exponential backoff with max delay |\n\n⚠️ **Pitfall: Payment Webhook Replay**\nProcessing the same webhook event multiple times can cause duplicate charges or state transitions. Always check for existing processing records using the gateway event ID before processing webhook data.\n\n⚠️ **Pitfall: Timezone Arithmetic in Billing**\nPerforming billing date calculations in customer timezone can cause billing to run twice or be skipped during daylight saving transitions. Always calculate in UTC and convert only for display.\n\n⚠️ **Pitfall: Optimistic Lock Retry Storms**\nUnder high concurrency, optimistic lock conflicts can cause retry storms. Implement exponential backoff and maximum retry limits to prevent system overload.\n\n\n## Testing Strategy and Validation\n\n> **Milestone(s):** All milestones - defines comprehensive testing approaches to validate billing logic correctness, integration reliability, and milestone completion across plan management (Milestone 1), subscription lifecycle (Milestone 2), proration calculations (Milestone 3), and usage-based billing (Milestone 4)\n\n### Mental Model: The Financial Audit Trail\n\nThink of testing a subscription billing system like conducting a financial audit of a complex business. Just as an auditor must verify every transaction, reconcile every account, and trace money flows from source to destination, billing system testing requires meticulous validation at multiple levels. Unit tests are like checking individual ledger entries for mathematical accuracy - ensuring each proration calculation, usage aggregation, and pricing computation produces the correct result down to the cent. Integration tests resemble departmental audits, verifying that when the billing department sends an invoice to accounts receivable, the payment flows correctly through the entire organization. End-to-end tests are like full company audits, following a customer's entire financial journey from subscription signup through monthly billing cycles to final cancellation.\n\nThe stakes are equally high in both scenarios. A single rounding error in proration calculations, multiplied across thousands of customers, can result in significant revenue loss or regulatory violations. A failed payment webhook that goes unnoticed can leave subscriptions in inconsistent states, causing customer service nightmares. Just as auditors use sampling techniques to validate large datasets, our testing strategy employs property-based testing to verify billing logic across thousands of generated scenarios, catching edge cases that manual test writing might miss.\n\n### Billing Logic Unit Tests\n\nUnit testing billing logic requires mathematical precision and comprehensive edge case coverage. Unlike typical application logic that might tolerate minor inconsistencies, billing calculations must be absolutely correct - every penny must be accounted for, and rounding must be deterministic and consistent across all operations.\n\n#### Proration Calculation Testing\n\n**Proration testing** focuses on the mathematical accuracy of partial billing calculations. These tests must verify that time-based proration produces correct results across various billing intervals, calendar edge cases, and currency precision requirements.\n\nThe core proration test suite validates the fundamental mathematical properties that all proration calculations must satisfy:\n\n| Test Category | Test Cases | Validation Criteria |\n|--------------|------------|-------------------|\n| Basic Time Proration | Full period, half period, single day | Proration factor calculation accuracy |\n| Currency Precision | Multiple currencies, rounding edge cases | No precision loss, consistent rounding |\n| Calendar Edge Cases | Month overflow, leap years, timezone boundaries | Correct day counting, timezone handling |\n| Plan Change Scenarios | Upgrade, downgrade, same-tier changes | Credit/charge amounts match expected |\n| Quantity-Based Changes | Seat increases, usage tier changes | Per-unit proration accuracy |\n\n**Property-based testing** proves invaluable for proration validation. Rather than manually crafting test cases, property-based tests generate thousands of random scenarios and verify that mathematical invariants hold:\n\n- **Symmetry Property**: Upgrading then immediately downgrading should result in zero net charge (minus any rounding)\n- **Additivity Property**: Proration for multiple changes within a period should equal the sum of individual prorations\n- **Monotonicity Property**: Larger plan changes should never result in smaller absolute proration amounts\n- **Boundary Property**: Proration at period start should equal full charge, proration at period end should equal zero charge\n\nThe test data generation must cover realistic business scenarios while exploring mathematical edge cases. Time periods should span various billing intervals (monthly, quarterly, annual), change dates should include first/last days of billing cycles, and currency amounts should test precision boundaries.\n\n#### Usage Aggregation Testing\n\n**Usage aggregation testing** validates the mathematical accuracy of usage event processing and billing calculations. These tests must ensure that usage events aggregate correctly across time boundaries, duplicate events are properly deduplicated, and overage charges calculate accurately.\n\n| Aggregation Scenario | Test Coverage | Expected Behavior |\n|---------------------|---------------|------------------|\n| Event Deduplication | Duplicate events with same idempotency key | Only single event counted |\n| Time Boundary Handling | Events at billing period edges | Correct period assignment |\n| Usage Type Separation | Multiple metric types per customer | Isolated aggregation per metric |\n| Quantity Precision | Fractional usage quantities | Accurate decimal handling |\n| Overage Calculations | Usage beyond plan allowances | Correct tiered rate application |\n\n**Time series testing** validates usage aggregation across billing period boundaries. These tests generate usage events with carefully controlled timestamps to verify that aggregation windows capture the correct events. Edge cases include events submitted exactly at billing period boundaries, events with future timestamps (clock skew), and events submitted after billing period close.\n\n**Idempotency verification** ensures that reprocessing usage events produces identical aggregation results. Tests submit the same usage batch multiple times with identical idempotency keys and verify that total usage quantities remain unchanged. This validation protects against double-billing scenarios in production.\n\n#### Pricing Model Testing\n\n**Pricing model testing** validates the mathematical accuracy of charge calculations across different pricing structures. Each pricing model (flat-rate, tiered, volume-based) has distinct calculation logic that requires specialized test coverage.\n\n| Pricing Model | Test Scenarios | Mathematical Validation |\n|--------------|----------------|------------------------|\n| Flat-Rate | Base charges, currency conversion | Fixed amount accuracy |\n| Tiered Pricing | Single tier, multi-tier, boundary cases | Per-tier calculation accuracy |\n| Volume Pricing | Usage below/above thresholds | Rate change threshold accuracy |\n| Per-Seat Pricing | Seat changes, proration | Quantity-based calculation |\n| Usage-Based | Allowances, overages, tier boundaries | Complex usage charge accuracy |\n\n**Tiered pricing edge cases** require special attention because they involve complex mathematical logic. Tests must verify calculations when usage spans multiple pricing tiers, ensuring that each tier applies its rate only to the usage quantity within that tier's boundaries. Boundary conditions (usage exactly at tier thresholds) must be tested exhaustively.\n\n#### Feature Entitlement Testing\n\n**Feature entitlement testing** validates the business logic that determines customer access to features based on their subscription plan. These tests ensure that feature flags, usage quotas, and access controls operate correctly across plan changes and subscription state transitions.\n\n| Entitlement Type | Test Coverage | Validation Points |\n|-----------------|---------------|------------------|\n| Boolean Features | Feature enabled/disabled by plan | Correct true/false determination |\n| Quota Limits | Usage tracking against plan limits | Accurate quota enforcement |\n| Plan Hierarchies | Feature inheritance in plan families | Correct access level determination |\n| Time-Based Access | Trial periods, grace periods | Time-sensitive feature access |\n\n### Integration and End-to-End Tests\n\nIntegration testing validates the interaction between billing system components and external services. Unlike unit tests that isolate individual calculations, integration tests verify that data flows correctly between components and that system-wide business processes complete successfully.\n\n#### Payment Gateway Integration Testing\n\n**Payment gateway integration testing** validates the complete payment flow from charge creation through webhook processing. These tests must handle asynchronous payment processing, webhook delivery reliability, and failure scenario recovery.\n\nThe integration test environment requires a payment gateway test mode that simulates various payment scenarios without processing real money. Test cases must cover successful payments, failed payments with different decline reasons, and webhook delivery edge cases.\n\n| Integration Scenario | Test Setup | Success Criteria |\n|---------------------|------------|------------------|\n| Successful Payment Flow | Valid payment method, sufficient funds | Payment completed, subscription activated |\n| Payment Failure Handling | Invalid payment method or declined card | Dunning process initiated, customer notified |\n| Webhook Processing | Payment status change webhooks | Subscription state updated correctly |\n| Idempotency Protection | Duplicate webhook delivery | No duplicate processing occurred |\n| Timeout Scenarios | Delayed webhook delivery | Proper retry and recovery behavior |\n\n**Webhook reliability testing** focuses on the asynchronous nature of payment notifications. Tests must simulate webhook delivery failures, duplicate deliveries, and out-of-order delivery to ensure the system maintains consistency under adverse network conditions.\n\nThe test suite uses webhook simulation rather than depending on actual payment gateway webhook delivery. This approach provides deterministic test execution while covering the same code paths that process production webhooks.\n\n#### Subscription Lifecycle Integration Testing\n\n**Subscription lifecycle integration testing** validates end-to-end subscription operations that span multiple system components. These tests verify that subscription state changes trigger appropriate downstream actions and maintain data consistency across components.\n\n| Lifecycle Operation | Component Integration | Validation Points |\n|--------------------|----------------------|------------------|\n| Subscription Creation | Plan validation, payment setup, activation | All components reflect active subscription |\n| Plan Changes | Proration calculation, billing adjustment | Correct charges applied to next invoice |\n| Renewal Processing | Usage aggregation, invoice generation | Complete billing cycle execution |\n| Cancellation | Service termination, final billing | Proper cleanup and final charges |\n\n**Billing cycle integration testing** validates the monthly billing process that aggregates usage, applies proration adjustments, generates invoices, and processes payments. This complex workflow requires coordination between multiple components and represents the most critical business process.\n\nThe test creates a controlled billing scenario with known usage events, plan changes, and payment methods. It then executes the complete billing cycle and validates that the generated invoice contains the correct line items with accurate amounts.\n\n#### Database Transaction Testing\n\n**Database transaction testing** validates the consistency guarantees provided by the system's transaction management. These tests verify that multi-step operations either complete entirely or roll back completely, preventing partial state corruption.\n\n| Transaction Scenario | Test Coverage | Consistency Validation |\n|---------------------|---------------|----------------------|\n| Plan Change Rollback | Payment failure during upgrade | Original plan remains active |\n| Invoice Generation Failure | Partial line item creation | No incomplete invoices created |\n| Usage Event Processing | Batch processing with failures | Either all events processed or none |\n| Concurrent Plan Changes | Multiple simultaneous changes | Serializable execution order |\n\n**Concurrency testing** validates the system's behavior under concurrent load. These tests simulate multiple users performing subscription operations simultaneously to ensure that optimistic locking prevents data corruption and that retry logic handles version conflicts correctly.\n\n#### Cross-Component Data Flow Testing\n\n**Cross-component data flow testing** validates that events and data propagate correctly through the system's event-driven architecture. These tests verify that state changes in one component trigger appropriate actions in dependent components.\n\nThe test framework publishes domain events and verifies that all registered event handlers execute correctly and that the system reaches a consistent final state. This validation ensures that the loosely-coupled architecture maintains strong consistency guarantees.\n\n| Data Flow | Event Triggers | Expected Propagation |\n|-----------|---------------|---------------------|\n| Plan Change Event | Proration calculation completion | Invoice line item creation |\n| Usage Event Submission | Batch aggregation completion | Overage charge calculation |\n| Payment Success Event | Gateway webhook processing | Subscription activation |\n| Dunning Escalation | Payment retry failure | Customer notification trigger |\n\n### Milestone Validation Checkpoints\n\nEach project milestone requires specific validation checkpoints that verify the implemented functionality meets the acceptance criteria. These checkpoints combine automated testing with manual verification procedures to ensure comprehensive validation.\n\n#### Milestone 1: Plans & Pricing Validation\n\n**Plan Management Validation** focuses on the flexible pricing plan definition and feature entitlement systems. The validation process ensures that plans support multiple pricing models, handle currency conversion correctly, and maintain proper versioning for existing customers.\n\n| Validation Area | Automated Tests | Manual Verification |\n|----------------|----------------|-------------------|\n| Plan Definition | Schema validation, pricing model tests | Admin interface plan creation |\n| Currency Support | Multi-currency pricing calculations | Currency display and conversion |\n| Feature Entitlements | Access control logic testing | Feature flag behavior verification |\n| Plan Versioning | Grandfathering logic validation | Existing customer protection testing |\n\n**Pricing Model Validation** requires mathematical verification across all supported pricing structures. The validation process generates test scenarios for flat-rate, tiered, and volume-based pricing to ensure accurate charge calculations.\n\nThe checkpoint procedure involves creating test plans with known pricing parameters, then validating that charge calculations produce expected results across various usage quantities and time periods. Property-based testing generates additional scenarios to verify mathematical invariants.\n\n**Acceptance Criteria Validation**:\n1. **Plan Definition Schema**: Create plans with different intervals, currencies, and feature lists through the management API\n2. **Pricing Model Support**: Validate flat-rate, per-unit, and tiered pricing calculations with known test cases\n3. **Feature Entitlement Matrix**: Verify that plan tiers correctly enable/disable feature flags\n4. **Plan Versioning**: Confirm that plan updates create new versions while preserving existing subscriber access\n\n#### Milestone 2: Subscription Lifecycle Validation\n\n**Subscription State Machine Validation** verifies that subscription state transitions follow business rules and that invalid transitions are properly rejected. The validation process tests each valid state transition and confirms that appropriate actions are triggered.\n\n| State Transition | Validation Test | Expected Behavior |\n|-----------------|----------------|------------------|\n| Trial to Active | Payment method validation | Automatic conversion on trial expiry |\n| Active to Past Due | Payment failure simulation | Dunning process initiation |\n| Past Due to Unpaid | Retry exhaustion | Service suspension |\n| Active to Cancelled | Customer-initiated cancellation | Service termination scheduling |\n\n**Renewal Processing Validation** ensures that the billing cycle engine correctly generates recurring charges, processes payments, and handles failures appropriately. The validation creates test subscriptions with known billing parameters and verifies invoice generation accuracy.\n\n**Dunning Management Validation** tests the payment failure recovery system by simulating various payment decline scenarios and verifying that retry attempts follow the configured dunning schedule.\n\n**Acceptance Criteria Validation**:\n1. **Subscription Creation**: Provision new subscriptions with selected plans and payment methods\n2. **Plan Change Processing**: Execute upgrades/downgrades with correct effective date logic\n3. **Cancellation Handling**: Process cancellations with reason recording and termination scheduling\n4. **Pause/Resume Functionality**: Handle subscription pausing with prorated billing adjustments\n\n#### Milestone 3: Proration & Plan Changes Validation\n\n**Proration Calculation Validation** focuses on mathematical accuracy of partial billing calculations. The validation process tests proration scenarios across different billing intervals, plan types, and change timing to ensure consistent results.\n\n| Proration Scenario | Test Data | Validation Method |\n|-------------------|-----------|------------------|\n| Mid-cycle Upgrade | Known plan prices, change date | Mathematical verification of charges |\n| Downgrade Credits | Higher-tier plan, remaining days | Credit calculation accuracy |\n| Quantity Changes | Seat-based plans, usage changes | Per-unit proration validation |\n| Currency Handling | Multi-currency plans | Precision and rounding verification |\n\n**Credit Balance Management Validation** ensures that customer credits are properly tracked, applied automatically to invoices, and maintained across billing cycles. The validation process creates scenarios with various credit sources and verifies correct application order.\n\n**Plan Change Orchestration Validation** tests the end-to-end plan change process, from customer request through proration calculation to service level adjustment. This validation ensures that complex plan changes maintain system consistency.\n\n**Acceptance Criteria Validation**:\n1. **Proration Accuracy**: Calculate prorated charges for upgrades based on remaining cycle days\n2. **Credit Application**: Apply downgrade credits for unused portions of higher-tier plans\n3. **Mid-cycle Changes**: Handle plan changes with correct effective dates and amounts\n4. **Change Scheduling**: Support immediate vs end-of-cycle plan change options\n\n#### Milestone 4: Usage-Based Billing Validation\n\n**Usage Event Processing Validation** verifies that metered usage events are correctly ingested, deduplicated, and aggregated for billing purposes. The validation process submits known usage quantities and verifies accurate aggregation across billing periods.\n\n| Usage Validation | Test Scenario | Expected Result |\n|------------------|---------------|----------------|\n| Event Deduplication | Duplicate submission with same idempotency key | Single event counted |\n| Billing Period Aggregation | Events across multiple periods | Correct period assignment |\n| Usage Type Isolation | Multiple metrics per customer | Separate aggregation per metric |\n| Overage Calculation | Usage exceeding plan allowances | Accurate tiered rate application |\n\n**Overage Billing Validation** ensures that usage beyond plan allowances is correctly calculated using tiered pricing structures. The validation creates usage scenarios that span multiple pricing tiers and verifies accurate charge calculation.\n\n**Usage Quota Enforcement Validation** tests the real-time quota checking system that prevents customers from exceeding plan allowances. The validation verifies that quota checks return accurate current usage and remaining allowances.\n\n**Acceptance Criteria Validation**:\n1. **Idempotent Event Ingestion**: Submit usage events with deduplication protection\n2. **Billing Period Aggregation**: Aggregate usage across correct billing boundaries\n3. **Tiered Usage Charges**: Calculate charges based on usage tier structures\n4. **Overage Rate Application**: Apply correct per-unit overage rates when usage exceeds allowances\n\n### Common Testing Pitfalls\n\n⚠️ **Pitfall: Currency Precision Testing**\n\nMany developers test billing calculations using floating-point arithmetic, which introduces precision errors that compound across many transactions. For example, testing a $9.99 monthly subscription with a 33% proration might use `9.99 * 0.33` in the test, yielding `3.2967` which doesn't represent any valid currency amount.\n\nThe correct approach stores all monetary values as integer cents and performs calculations in integer arithmetic. Test assertions should compare exact cent amounts: `assert proration.amount_cents == 329` rather than floating-point approximations.\n\n⚠️ **Pitfall: Time Zone Inconsistency in Testing**\n\nBilling systems operate across multiple time zones, but tests often use local system time, creating inconsistent results when run in different environments. A test that works in EST might fail in PST due to billing period boundary calculations.\n\nAll tests must use UTC timestamps consistently and explicitly test time zone edge cases. Test data should include customers in various time zones to verify that billing anchor dates are calculated correctly regardless of system time zone.\n\n⚠️ **Pitfall: Inadequate Idempotency Testing**\n\nDevelopers often test the \"happy path\" for idempotent operations but fail to test edge cases like partial failures, network timeouts, and retry scenarios. Testing idempotency with simple duplicate requests misses the complex scenarios that occur in production.\n\nComprehensive idempotency testing must simulate network failures, database timeouts, and system crashes at various points in request processing. Tests should verify that operations remain idempotent even when internal state changes between retry attempts.\n\n⚠️ **Pitfall: Missing Webhook Timing Tests**\n\nPayment webhook testing often assumes immediate delivery and processing, but production webhooks can be delayed, delivered out of order, or arrive after timeouts have occurred. Tests that don't account for webhook timing issues fail to catch state machine edge cases.\n\nWebhook tests must simulate delayed delivery, duplicate webhooks, and out-of-order processing. The test framework should control webhook timing independently from payment processing to verify that the system handles all temporal orderings correctly.\n\n⚠️ **Pitfall: Insufficient Error State Testing**\n\nMany billing tests focus on successful operations but provide inadequate coverage of error states and recovery scenarios. Testing only successful plan changes misses the complex rollback logic required when payments fail mid-process.\n\nError state testing must cover every point where operations can fail and verify that the system maintains consistency. This includes testing partial failures, timeout scenarios, and concurrent modification conflicts that can occur in production environments.\n\n### Implementation Guidance\n\nThe testing implementation provides comprehensive validation tools for all billing system components. The test suite combines mathematical precision testing for calculations with robust integration testing for component interactions.\n\n#### Technology Recommendations\n\n| Test Category | Simple Option | Advanced Option |\n|--------------|---------------|-----------------|\n| Unit Testing Framework | `pytest` with fixtures | `pytest` with `hypothesis` for property testing |\n| Database Testing | SQLite in-memory database | PostgreSQL test containers with transaction rollback |\n| HTTP Testing | `requests` with mock responses | `wiremock` for full HTTP simulation |\n| Property-Based Testing | Manual test case generation | `hypothesis` for automated test generation |\n| Time Testing | Fixed datetime mocking | `freezegun` for temporal scenario control |\n| Currency Testing | Manual decimal calculations | `babel` for multi-currency test data |\n\n#### Recommended Test Structure\n\n```\ntests/\n  unit/\n    billing/\n      test_proration_calculator.py      ← Mathematical calculation tests\n      test_usage_aggregator.py          ← Usage event processing tests\n      test_pricing_models.py            ← Pricing calculation tests\n      test_feature_entitlements.py      ← Access control tests\n    subscription/\n      test_lifecycle_manager.py         ← State machine tests\n      test_renewal_processor.py         ← Billing cycle tests\n      test_dunning_engine.py            ← Payment failure recovery tests\n  integration/\n    test_billing_workflows.py           ← End-to-end billing processes\n    test_payment_gateway.py             ← Payment integration tests\n    test_webhook_processing.py          ← Asynchronous event tests\n  fixtures/\n    billing_test_data.py                ← Test data generation utilities\n    payment_gateway_mock.py             ← Payment simulation infrastructure\n    database_fixtures.py               ← Database state setup utilities\n  milestone_validation/\n    test_milestone_1_plans.py           ← Plan management validation\n    test_milestone_2_lifecycle.py       ← Subscription lifecycle validation\n    test_milestone_3_proration.py       ← Plan change validation\n    test_milestone_4_usage.py           ← Usage-based billing validation\n```\n\n#### Core Testing Infrastructure\n\n```python\n# fixtures/billing_test_data.py - Test data generation utilities\nfrom decimal import Decimal\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional\nimport uuid\nfrom dataclasses import dataclass\n\n@dataclass\nclass TestScenario:\n    \"\"\"Represents a billing test scenario with known inputs and expected outputs.\"\"\"\n    name: str\n    setup_data: Dict\n    expected_result: Dict\n    validation_rules: List[str]\n\nclass BillingTestDataGenerator:\n    \"\"\"Generates realistic test data for billing calculations.\"\"\"\n    \n    def create_test_plan(\n        self,\n        plan_type: str = \"flat_rate\",\n        base_price_cents: int = 999,\n        currency: str = \"USD\",\n        billing_interval: str = \"month\"\n    ) -> Dict:\n        \"\"\"Create test plan with specified parameters.\"\"\"\n        # TODO 1: Generate plan_id and set basic plan attributes\n        # TODO 2: Create pricing_tiers based on plan_type parameter\n        # TODO 3: Define feature_entitlements for test scenarios\n        # TODO 4: Set billing_interval and currency_code\n        # TODO 5: Return complete plan dictionary for test usage\n    \n    def create_test_customer(\n        self,\n        credit_balance_cents: int = 0,\n        timezone: str = \"UTC\"\n    ) -> Dict:\n        \"\"\"Create test customer with specified credit balance.\"\"\"\n        # TODO 1: Generate customer_id and basic customer data\n        # TODO 2: Set credit_balance_cents and timezone\n        # TODO 3: Create default payment method for testing\n        # TODO 4: Return customer dictionary with payment method\n    \n    def create_billing_scenario(\n        self,\n        scenario_type: str,\n        plan_data: Dict,\n        customer_data: Dict\n    ) -> TestScenario:\n        \"\"\"Generate complete test scenario with expected results.\"\"\"\n        # TODO 1: Create subscription linking customer to plan\n        # TODO 2: Generate usage events based on scenario_type\n        # TODO 3: Calculate expected proration or usage charges\n        # TODO 4: Define validation rules for test assertions\n        # TODO 5: Return TestScenario with all test data and expectations\n\nclass ProrationTestGenerator:\n    \"\"\"Specialized test data for proration calculations.\"\"\"\n    \n    def generate_plan_change_scenarios(self) -> List[TestScenario]:\n        \"\"\"Generate comprehensive plan change test cases.\"\"\"\n        # TODO 1: Create upgrade scenarios with various timing\n        # TODO 2: Create downgrade scenarios with credit calculations\n        # TODO 3: Create quantity change scenarios for seat-based plans\n        # TODO 4: Add edge cases for billing period boundaries\n        # TODO 5: Include multi-currency scenarios\n        # TODO 6: Return list of all generated test scenarios\n\n    def generate_calendar_edge_cases(self) -> List[TestScenario]:\n        \"\"\"Generate calendar edge case scenarios for proration.\"\"\"\n        # TODO 1: Create leap year scenarios (Feb 29 billing anchor)\n        # TODO 2: Create month overflow scenarios (Jan 31 + 1 month)\n        # TODO 3: Create timezone transition scenarios (DST changes)\n        # TODO 4: Create end-of-month billing scenarios\n        # TODO 5: Return comprehensive calendar edge case scenarios\n```\n\n#### Property-Based Testing Framework\n\n```python\n# tests/unit/billing/test_proration_properties.py - Property-based proration testing\nfrom hypothesis import given, strategies as st, assume\nfrom decimal import Decimal\nfrom datetime import date, timedelta\nimport pytest\n\nclass ProrationPropertyTests:\n    \"\"\"Property-based tests for proration mathematical invariants.\"\"\"\n    \n    @given(\n        old_price=st.integers(min_value=100, max_value=100000),  # $1-$1000 in cents\n        new_price=st.integers(min_value=100, max_value=100000),\n        change_date=st.dates(min_value=date(2024, 1, 1), max_value=date(2024, 12, 31)),\n        billing_start=st.dates(min_value=date(2024, 1, 1), max_value=date(2024, 6, 30)),\n    )\n    def test_proration_symmetry_property(\n        self, old_price: int, new_price: int, change_date: date, billing_start: date\n    ):\n        \"\"\"Verify that upgrade followed by immediate downgrade nets to zero.\"\"\"\n        # Ensure change_date is within billing period\n        billing_end = billing_start + timedelta(days=30)\n        assume(billing_start <= change_date <= billing_end)\n        \n        # TODO 1: Calculate proration for upgrade from old_price to new_price\n        # TODO 2: Calculate proration for immediate downgrade back to old_price\n        # TODO 3: Verify that net proration amount is zero (within rounding tolerance)\n        # TODO 4: Verify that both calculations use same time factor\n        # Hint: Use ProrationCalculator.calculate_plan_change_proration for both calculations\n    \n    @given(\n        base_price=st.integers(min_value=500, max_value=10000),\n        period_days=st.integers(min_value=28, max_value=31),\n        change_day=st.integers(min_value=1, max_value=31),\n    )\n    def test_proration_monotonicity(\n        self, base_price: int, period_days: int, change_day: int\n    ):\n        \"\"\"Verify that later change dates result in smaller proration amounts.\"\"\"\n        assume(change_day <= period_days)\n        \n        # TODO 1: Calculate proration for change on change_day\n        # TODO 2: Calculate proration for change one day later (if within period)\n        # TODO 3: Verify that later change has smaller absolute proration amount\n        # TODO 4: Handle edge case where change_day is last day of period\n        # Hint: Proration amount should decrease as change_date approaches period_end\n```\n\n#### Integration Test Infrastructure\n\n```python\n# tests/integration/test_billing_workflows.py - End-to-end billing workflow testing\nimport pytest\nfrom datetime import datetime, timedelta\nfrom unittest.mock import Mock, patch\nimport json\n\nclass BillingWorkflowIntegrationTests:\n    \"\"\"Integration tests for complete billing workflows.\"\"\"\n    \n    @pytest.fixture\n    def billing_test_environment(self, db_session):\n        \"\"\"Set up complete test environment with all components.\"\"\"\n        # TODO 1: Create test database with all billing tables\n        # TODO 2: Initialize mock payment gateway with test responses\n        # TODO 3: Set up event bus with test event handlers\n        # TODO 4: Create test customers, plans, and subscriptions\n        # TODO 5: Return configured test environment object\n    \n    def test_complete_subscription_lifecycle(self, billing_test_environment):\n        \"\"\"Test complete customer journey from signup to cancellation.\"\"\"\n        env = billing_test_environment\n        \n        # TODO 1: Create customer with payment method\n        # TODO 2: Create subscription with trial period\n        # TODO 3: Process trial expiration and first payment\n        # TODO 4: Generate usage events and process monthly billing\n        # TODO 5: Process plan upgrade with proration\n        # TODO 6: Cancel subscription and verify final billing\n        # TODO 7: Validate all audit events and state transitions\n        \n        # Validation points\n        # TODO 8: Verify subscription state progression is correct\n        # TODO 9: Verify all invoices have accurate line items\n        # TODO 10: Verify payment processing completed successfully\n        # TODO 11: Verify audit trail captures all operations\n    \n    def test_payment_failure_recovery(self, billing_test_environment):\n        \"\"\"Test complete dunning process for failed payments.\"\"\"\n        env = billing_test_environment\n        \n        # TODO 1: Create active subscription with invalid payment method\n        # TODO 2: Trigger billing cycle and simulate payment failure\n        # TODO 3: Verify dunning process initiates correctly\n        # TODO 4: Process multiple retry attempts with continued failures\n        # TODO 5: Verify subscription transitions to unpaid status\n        # TODO 6: Test payment method update and recovery\n        # TODO 7: Verify subscription reactivates after successful payment\n```\n\n#### Milestone Validation Scripts\n\n```python\n# tests/milestone_validation/test_milestone_1_plans.py - Plan management milestone validation\nimport pytest\nfrom decimal import Decimal\n\nclass Milestone1ValidationTests:\n    \"\"\"Comprehensive validation for Milestone 1: Plans & Pricing.\"\"\"\n    \n    def test_plan_definition_schema(self, plan_manager):\n        \"\"\"Validate plan definition supports required schema elements.\"\"\"\n        # Acceptance Criteria: Define subscription plans with tiers, intervals, and pricing\n        # TODO 1: Create flat-rate plan with monthly billing interval\n        # TODO 2: Create tiered plan with multiple pricing tiers\n        # TODO 3: Create per-seat plan with quantity-based pricing\n        # TODO 4: Verify all plans store correctly with complete schema\n        # TODO 5: Test plan retrieval and validation of all fields\n        \n        # Expected behaviors:\n        # - Plan creation returns valid plan_id\n        # - All pricing tiers store with correct boundaries\n        # - Feature entitlements associate correctly with plans\n        # - Currency and interval settings persist accurately\n    \n    def test_pricing_model_calculations(self, plan_manager):\n        \"\"\"Validate pricing model charge calculations.\"\"\"\n        # Acceptance Criteria: Support multiple pricing models (flat, tiered)\n        # TODO 1: Test flat-rate pricing calculation for various quantities\n        # TODO 2: Test tiered pricing with usage spanning multiple tiers\n        # TODO 3: Test volume pricing with rate changes at thresholds\n        # TODO 4: Verify currency conversion maintains precision\n        # TODO 5: Test edge cases at tier boundaries\n        \n        # Mathematical validation:\n        # - Flat-rate: charge = base_price * quantity\n        # - Tiered: charge = sum(tier_rate * tier_quantity for each tier)\n        # - Volume: charge = total_quantity * applicable_rate\n    \n    def test_plan_versioning_protection(self, plan_manager):\n        \"\"\"Validate plan versioning protects existing customers.\"\"\"\n        # Acceptance Criteria: Handle plan versioning for existing subscribers\n        # TODO 1: Create plan and subscribe test customer\n        # TODO 2: Update plan pricing and create new version\n        # TODO 3: Verify existing customer retains original pricing\n        # TODO 4: Verify new customers receive updated pricing\n        # TODO 5: Test plan deprecation and grandfather protection\n        \n        # Validation checkpoints:\n        print(\"✓ Plan creation and versioning\")\n        print(\"✓ Existing customer price protection\")\n        print(\"✓ New customer updated pricing\")\n        print(\"✓ Feature entitlement inheritance\")\n```\n\n#### Debugging Test Utilities\n\n| Test Failure Symptom | Likely Cause | Diagnostic Command | Resolution |\n|----------------------|--------------|-------------------|------------|\n| Proration calculation mismatch | Floating point precision error | Check test uses integer cents | Convert all amounts to integer cents |\n| Webhook test timing out | Mock gateway not configured | Verify mock responses set up | Initialize payment gateway mock properly |\n| Database constraint violation | Test data conflicts with existing | Use transaction rollback fixtures | Isolate tests with database transactions |\n| Property test failure | Edge case not handled | Run test with `--hypothesis-verbose` | Add assume() statements for valid inputs |\n| Integration test flakiness | Race condition in async processing | Add explicit event synchronization | Use event bus sync points in tests |\n\n#### Milestone Checkpoint Validation\n\n**Milestone 1 Checkpoint**:\n```bash\n# Run plan management validation\npython -m pytest tests/milestone_validation/test_milestone_1_plans.py -v\n\n# Expected output:\n# ✓ test_plan_definition_schema - PASSED\n# ✓ test_pricing_model_calculations - PASSED  \n# ✓ test_plan_versioning_protection - PASSED\n# ✓ test_feature_entitlements - PASSED\n\n# Manual verification:\n# 1. Create plan via API: POST /api/plans with plan data\n# 2. Verify response includes plan_id and all specified fields\n# 3. Retrieve plan: GET /api/plans/{plan_id}\n# 4. Confirm pricing tiers and features are correct\n```\n\n**Milestone 2 Checkpoint**:\n```bash\n# Run subscription lifecycle validation\npython -m pytest tests/milestone_validation/test_milestone_2_lifecycle.py -v\n\n# Expected behaviors to verify:\n# 1. Subscription creation provisions customer access\n# 2. Renewal processing generates accurate invoices\n# 3. Cancellation respects end-of-period vs immediate options\n# 4. State transitions follow business rules\n```\n\n**Milestone 3 Checkpoint**:\n```bash\n# Run proration calculation validation\npython -m pytest tests/milestone_validation/test_milestone_3_proration.py -v\n\n# Mathematical verification:\n# 1. Mid-cycle upgrade: charge = (new_price - old_price) * time_factor\n# 2. Downgrade credit: credit = (old_price - new_price) * time_factor\n# 3. Time factor: remaining_days / total_period_days\n# 4. Currency precision: all calculations in integer cents\n```\n\n**Milestone 4 Checkpoint**:\n```bash\n# Run usage-based billing validation\npython -m pytest tests/milestone_validation/test_milestone_4_usage.py -v\n\n# Usage processing verification:\n# 1. Submit usage events with idempotency keys\n# 2. Verify aggregation across billing periods\n# 3. Calculate overage charges for usage beyond allowances\n# 4. Test quota enforcement and limit checking\n```\n\nThe testing strategy provides comprehensive validation across all billing system components, ensuring mathematical accuracy, integration reliability, and milestone completion verification. The property-based testing approach catches edge cases that manual test writing might miss, while the milestone validation checkpoints provide clear success criteria for each development phase.\n\n\n## Debugging Guide\n\n> **Milestone(s):** All milestones - provides diagnostic techniques and troubleshooting approaches essential for identifying and resolving issues across plan management (Milestone 1), subscription lifecycle (Milestone 2), proration calculations (Milestone 3), and usage-based billing (Milestone 4)\n\n### Mental Model: Detective Work for Financial Systems\n\nThink of debugging a billing system like being a financial detective investigating discrepancies in a complex accounting operation. Just as a detective follows the money trail through bank records, receipts, and transaction logs, billing system debugging requires tracing data flow through multiple components, examining audit trails, and understanding the sequence of events that led to incorrect calculations or inconsistent states.\n\nUnlike debugging typical web applications where the worst outcome might be a 500 error, billing system bugs directly impact revenue and customer trust. A proration calculation error could overcharge thousands of customers, while a webhook processing failure might leave subscriptions in inconsistent states. The debugging approach must be systematic, thorough, and focused on financial accuracy and data consistency.\n\nThe debugging process mirrors forensic accounting: start with the symptom (incorrect invoice amount, stuck subscription), trace backwards through the audit trail (events, state changes, calculations), identify the root cause (rounding error, race condition, webhook duplication), and implement fixes that prevent recurrence. Every financial operation must be explainable and recoverable.\n\n### Billing Calculation Issues\n\nBilling calculation debugging requires understanding the mathematical precision, currency handling, and complex interaction between base charges, usage fees, proration, and credits. These issues often manifest as subtle discrepancies that compound over time or edge cases that only occur under specific conditions.\n\n#### Currency Precision and Rounding Errors\n\nCurrency precision errors are among the most common and dangerous billing calculation issues. These problems typically stem from mixing floating-point arithmetic with financial calculations or incorrect rounding when converting between different currency representations.\n\n**Common Currency Precision Problems:**\n\n| Problem Type | Symptom | Root Cause | Detection Method |\n|--------------|---------|------------|------------------|\n| Floating Point Drift | Invoice totals off by 1-2 cents | Using `float` instead of integer cents | Compare sum of line items vs total amount |\n| Rounding Inconsistency | Line item totals don't match invoice total | Different rounding at each calculation step | Recalculate invoice from scratch and compare |\n| Currency Conversion Precision | Multi-currency invoices with tiny discrepancies | Exchange rate precision loss | Check conversion rate precision and intermediate values |\n| Aggregate Rounding | Usage charges incorrect for high quantities | Rounding per-unit vs rounding total | Compare unit-by-unit vs bulk calculation methods |\n\nThe fundamental principle for currency debugging is that all monetary values must be stored and calculated using the smallest currency unit (cents for USD). Any conversion to decimal representation should happen only at the display layer, never during calculations.\n\n**Proration Calculation Debugging:**\n\nProration errors are particularly insidious because they involve both time-based calculations and currency precision. The debugging approach requires validating both the time fraction calculation and the monetary arithmetic.\n\n| Proration Issue | Diagnostic Steps | Validation Method |\n|----------------|------------------|-------------------|\n| Incorrect Time Fraction | Log change date, period start, period end | Calculate days manually: `(period_end - change_date) / (period_end - period_start)` |\n| Asymmetric Proration | Upgrade charge doesn't match downgrade credit | Test upgrade followed by immediate downgrade - net should be zero |\n| Calendar Edge Cases | Wrong proration on month boundaries | Test month-end changes, leap year scenarios, timezone boundaries |\n| Multiple Plan Changes | Cumulative proration errors | Sum all proration amounts for billing period - should equal net plan difference |\n\nThe proration debugging process should always start with validating the time calculations before examining monetary arithmetic. A common mistake is debugging currency precision when the actual issue is incorrect date handling or timezone problems.\n\n**Usage Aggregation and Tiered Pricing Issues:**\n\nUsage-based billing introduces additional complexity because charges depend on both quantity calculations and tier boundary logic. Debugging requires understanding the aggregation methodology and tier calculation algorithms.\n\n| Usage Billing Problem | Investigation Approach | Key Validation |\n|----------------------|------------------------|----------------|\n| Incorrect Usage Totals | Trace individual events to final aggregation | Manual sum of events vs aggregated quantity |\n| Wrong Tier Application | Examine tier boundary conditions | Test quantities at tier boundaries (999, 1000, 1001) |\n| Duplicate Event Charging | Check idempotency key handling | Search for duplicate `idempotency_key` values |\n| Missing Overage Charges | Validate allowance vs actual usage | Compare plan allowance against aggregated usage |\n| Cross-Period Event Attribution | Check event timestamps vs billing periods | Verify events assigned to correct billing cycle |\n\nUsage debugging often requires examining the raw event data and manually recalculating aggregations. The `UsageEvent` table should be treated as the source of truth, and all aggregated values should be derivable from this base data.\n\n#### Credit Balance and Application Errors\n\nCredit balance issues occur when customer credits aren't applied correctly to invoices, or when credit calculations don't match the corresponding charges. These problems often involve incorrect sequencing of credit operations or failure to handle partial credit applications.\n\n**Credit Balance Debugging Matrix:**\n\n| Credit Issue Type | Symptoms | Diagnostic Query | Expected Result |\n|------------------|----------|-----------------|-----------------|\n| Credits Not Applied | Invoice amount ignores available credit | `SELECT * FROM customer WHERE customer_id = ? AND credit_balance_cents > 0` | Credit balance should decrease after invoice |\n| Partial Credit Application | Credit partially consumed but amount wrong | Trace credit consumption in audit logs | Credit reduction should equal amount applied |\n| Negative Credit Balance | Customer credit balance below zero | Check for concurrent credit consumption | Credit operations should be atomic |\n| Orphaned Credits | Credits exist but never applied to invoices | Find credits without corresponding invoice line items | All credits should have application records |\n\nThe credit debugging process requires examining both the current credit balance and the complete history of credit applications through the audit trail. Every credit operation should be traceable through the `AuditEvent` records.\n\n### State Consistency Problems\n\nState consistency issues in billing systems typically involve subscription states becoming misaligned with payment states, invoice states, or usage tracking states. These problems often result from partial failures in distributed operations or race conditions between concurrent processes.\n\n#### Subscription State Inconsistencies\n\nSubscription state debugging requires understanding the valid state transitions and identifying how the subscription reached an invalid or unexpected state. The subscription state machine provides the framework for validating state consistency.\n\n**Subscription State Validation Checklist:**\n\n| Current State | Required Conditions | Inconsistency Indicators | Recovery Actions |\n|--------------|-------------------|-------------------------|------------------|\n| `active` | Valid payment method, current invoice paid | No payment method or unpaid invoice | Check payment status and payment method validity |\n| `past_due` | Active dunning process, unpaid invoice exists | No dunning attempts or no unpaid invoices | Verify dunning engine status and invoice generation |\n| `cancelled` | Cancellation event exists, no future invoices | Active invoices scheduled for future | Cancel future invoices and verify cancellation timestamp |\n| `paused` | Pause event exists, billing suspended | Recent invoices or payments | Check pause effective date and billing suspension |\n\nThe key to subscription state debugging is examining the sequence of `SubscriptionEvent` records that led to the current state. Every state transition should correspond to a specific event with proper authorization and business justification.\n\n**Concurrent Modification Detection:**\n\nRace conditions in subscription updates can lead to lost state changes or invalid state transitions. The optimistic locking mechanism using version numbers provides protection against concurrent modifications.\n\n| Concurrency Problem | Detection Method | Prevention Strategy |\n|--------------------|------------------|-------------------|\n| Lost State Updates | Version mismatch exceptions in logs | Retry with fresh entity load |\n| Invalid State Transitions | State machine violations | Validate transitions before persisting |\n| Duplicate Event Processing | Multiple events with same idempotency key | Check idempotency key uniqueness |\n| Timeline Ordering Issues | Events processed out of sequence | Use event timestamp ordering for replay |\n\nWhen debugging concurrency issues, examine the `WorkflowExecution` records to understand which operations were running simultaneously and whether any workflow steps failed due to conflicts.\n\n#### Invoice and Payment State Alignment\n\nInvoice states must remain consistent with payment states and subscription states. Misalignment often occurs when webhook processing fails or when manual interventions bypass the normal workflow.\n\n**Invoice-Payment Consistency Matrix:**\n\n| Invoice Status | Expected Payment Status | Inconsistency Pattern | Resolution Steps |\n|---------------|------------------------|---------------------|------------------|\n| `draft` | No payments exist | Payments exist for draft invoice | Investigate manual payment creation |\n| `open` | `pending` or no payment | `succeeded` payment but invoice still open | Process payment success webhook |\n| `paid` | `succeeded` payment | No successful payment found | Check for manual payment recording |\n| `past_due` | `failed` payment | `succeeded` payment | Investigate webhook processing delay |\n\nInvoice state debugging requires correlating invoice records with payment records using the `invoice_id` foreign key. Every paid invoice should have exactly one successful payment, and every successful payment should correspond to a paid invoice.\n\n**Payment Gateway Synchronization Issues:**\n\nBilling system state can become inconsistent with payment gateway state when webhooks fail to process or when manual operations occur in the gateway without corresponding system updates.\n\n| Synchronization Issue | Detection Strategy | Reconciliation Approach |\n|----------------------|-------------------|------------------------|\n| Missing Webhook Processing | Gateway payment exists, no system payment | Compare gateway transactions with system payments |\n| Duplicate Payment Recording | Multiple system payments for single gateway charge | Search for payments with same `gateway_transaction_id` |\n| Amount Mismatches | System payment amount differs from gateway | Compare `amount_cents` with gateway charge amount |\n| Status Lag | Gateway shows success, system shows pending | Check webhook event processing timestamps |\n\nPayment gateway debugging often requires accessing the gateway's dashboard or API to compare transaction states with internal system records. The `WebhookEvent` table provides an audit trail of all webhook processing attempts.\n\n### Webhook and Integration Debugging\n\nWebhook processing failures can leave the billing system in inconsistent states because external payment events aren't properly reflected in system state. Debugging webhook issues requires understanding both the technical integration mechanisms and the business implications of processing delays or failures.\n\n#### Webhook Processing Reliability\n\nWebhook reliability debugging focuses on ensuring that payment gateway events are consistently processed and applied to the appropriate billing entities. This involves examining the webhook ingestion pipeline, idempotency protection, and error handling.\n\n**Webhook Processing Diagnostic Flow:**\n\n| Processing Stage | Success Indicators | Failure Symptoms | Debug Actions |\n|-----------------|-------------------|------------------|---------------|\n| Webhook Reception | Request logged with valid signature | 400/500 errors in webhook endpoint | Check webhook URL configuration and signature validation |\n| Event Parsing | `WebhookEvent` record created | JSON parsing errors in logs | Validate webhook payload structure against gateway documentation |\n| Idempotency Check | Duplicate events ignored gracefully | Same event processed multiple times | Verify `idempotency_key` uniqueness enforcement |\n| Business Logic Application | Entity states updated correctly | State inconsistencies after webhook | Trace event processing through business logic |\n\nThe webhook debugging process should start by confirming that webhooks are being received by the system. Check the webhook endpoint logs for incoming requests and verify that the payment gateway is configured with the correct URL and credentials.\n\n**Webhook Event Deduplication Issues:**\n\nPayment gateways may send duplicate webhooks due to network retries or internal processing issues. The idempotency protection mechanism must correctly identify and ignore duplicate events without losing legitimate updates.\n\n| Deduplication Problem | Identification Method | Root Cause Analysis |\n|---------------------|---------------------|-------------------|\n| Duplicate Processing | Same payment updated multiple times | Check `idempotency_key` uniqueness in `WebhookEvent` table |\n| False Duplicate Detection | Legitimate events ignored | Examine idempotency key generation logic |\n| Race Condition in Deduplication | Intermittent duplicate processing | Check concurrent webhook processing timing |\n| Cross-Event Type Conflicts | Different event types sharing idempotency keys | Validate idempotency key scoping strategy |\n\nEffective webhook deduplication debugging requires examining both the incoming webhook payloads and the generated idempotency keys. The idempotency key should uniquely identify each business event, not just each HTTP request.\n\n#### Payment Method and Subscription Synchronization\n\nPayment method updates in the gateway must be reflected in subscription billing configurations to ensure future payments succeed. Debugging these synchronization issues involves tracing payment method lifecycle events through both systems.\n\n**Payment Method Sync Debugging:**\n\n| Sync Issue | System Impact | Debugging Approach | Resolution Strategy |\n|------------|---------------|-------------------|-------------------|\n| Outdated Payment Method | Recurring payments fail | Compare system vs gateway payment method status | Refresh payment method from gateway API |\n| Missing Payment Method Updates | Card expiration not reflected | Check webhook processing for payment method events | Implement payment method webhook handlers |\n| Customer Payment Method Misalignment | Payments charged to wrong method | Validate customer-payment method associations | Reconcile customer records between systems |\n| Default Payment Method Conflicts | Multiple methods marked as default | Query payment methods for customer | Implement default payment method enforcement |\n\nPayment method debugging often requires cross-referencing data between the billing system and payment gateway. The `PaymentMethod` table should maintain accurate references to gateway payment method tokens and their current status.\n\n**Integration Circuit Breaker and Retry Logic:**\n\nWhen external integrations fail repeatedly, circuit breakers prevent cascading failures while retry logic attempts to recover from transient issues. Debugging these mechanisms helps identify when external services are degraded and how the system responds.\n\n| Integration Health Issue | Circuit Breaker State | Debug Information | Recovery Actions |\n|-------------------------|---------------------|------------------|------------------|\n| Gateway API Timeouts | Circuit opening frequently | Check response time metrics and failure rates | Increase timeout values or investigate gateway performance |\n| Authentication Failures | Circuit stuck open | Examine API key validity and rotation | Refresh authentication credentials |\n| Rate Limiting | Requests failing with 429 errors | Check request volume and rate limit headers | Implement exponential backoff with jitter |\n| Webhook Endpoint Unreachable | Gateway shows delivery failures | Verify webhook endpoint availability and SSL certificate | Fix infrastructure issues and re-register webhook URL |\n\nCircuit breaker debugging requires examining both the current circuit state and the historical failure patterns that triggered the protection mechanism. The `CircuitBreaker` component should provide visibility into failure thresholds and recovery timing.\n\n### Implementation Guidance\n\nThe debugging implementation focuses on providing comprehensive diagnostic tools, structured logging, and automated consistency checks that help identify and resolve billing system issues efficiently.\n\n**Technology Recommendations:**\n\n| Debugging Component | Simple Option | Advanced Option |\n|-------------------|---------------|-----------------|\n| Logging Framework | Python `logging` with structured JSON | ELK Stack (Elasticsearch, Logstash, Kibana) |\n| Metrics Collection | Python `prometheus_client` | Datadog or New Relic APM |\n| Database Debugging | Direct SQL queries with psql/mysql | Database query analysis tools |\n| API Testing | `curl` and `pytest` | Postman collections with test automation |\n| Error Tracking | Python `traceback` with file output | Sentry error tracking and alerting |\n\n**Recommended File Structure for Debugging Tools:**\n\n```\nproject-root/\n  src/\n    billing/\n      debug/\n        __init__.py\n        calculation_validator.py      ← billing calculation verification\n        state_consistency_checker.py  ← subscription state validation\n        webhook_debugger.py           ← webhook processing diagnostics\n        audit_trail_analyzer.py      ← audit event investigation tools\n        billing_reconciliation.py    ← system vs gateway comparison\n        test_data_generator.py       ← synthetic data for testing scenarios\n      monitoring/\n        __init__.py\n        billing_metrics.py           ← prometheus metrics collection\n        health_checks.py             ← system health validation\n        circuit_breaker_monitor.py   ← integration health monitoring\n  tools/\n    debug_billing_issue.py          ← command-line debugging utility\n    reconcile_payments.py           ← payment gateway synchronization\n    validate_billing_period.py     ← billing cycle validation script\n  tests/\n    debug_tools/\n      test_calculation_validator.py\n      test_state_consistency.py\n      test_webhook_debugger.py\n```\n\n**Infrastructure Starter Code - Billing Calculation Validator:**\n\n```python\nimport logging\nfrom decimal import Decimal, ROUND_HALF_UP\nfrom typing import Dict, List, Optional, Any\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass ValidationError(Enum):\n    CURRENCY_PRECISION = \"currency_precision\"\n    PRORATION_ASYMMETRY = \"proration_asymmetry\"\n    USAGE_AGGREGATION = \"usage_aggregation\"\n    CREDIT_APPLICATION = \"credit_application\"\n    TIER_CALCULATION = \"tier_calculation\"\n\n@dataclass\nclass ValidationResult:\n    is_valid: bool\n    error_type: Optional[ValidationError]\n    expected_value: Any\n    actual_value: Any\n    details: Dict[str, Any]\n\nclass BillingCalculationValidator:\n    \"\"\"\n    Validates billing calculations for correctness and consistency.\n    Provides detailed diagnostics for calculation errors.\n    \"\"\"\n    \n    def __init__(self, decimal_precision: Decimal = Decimal('0.01')):\n        self.decimal_precision = decimal_precision\n        self.logger = logging.getLogger(__name__)\n    \n    def validate_currency_precision(self, money_amount: 'Money') -> ValidationResult:\n        \"\"\"\n        Validates that monetary amounts maintain proper precision.\n        Checks for floating-point drift and rounding consistency.\n        \"\"\"\n        # Convert to decimal and back to check for precision loss\n        decimal_amount = money_amount.to_decimal()\n        reconstructed = Money.from_decimal(decimal_amount, money_amount.currency_code)\n        \n        if reconstructed.amount_cents != money_amount.amount_cents:\n            return ValidationResult(\n                is_valid=False,\n                error_type=ValidationError.CURRENCY_PRECISION,\n                expected_value=money_amount.amount_cents,\n                actual_value=reconstructed.amount_cents,\n                details={\n                    'original_cents': money_amount.amount_cents,\n                    'decimal_representation': str(decimal_amount),\n                    'reconstructed_cents': reconstructed.amount_cents,\n                    'precision_loss': money_amount.amount_cents - reconstructed.amount_cents\n                }\n            )\n        \n        return ValidationResult(is_valid=True, error_type=None, expected_value=None, actual_value=None, details={})\n    \n    def validate_proration_symmetry(self, old_plan: 'Plan', new_plan: 'Plan', \n                                  change_date: datetime, billing_period_start: datetime,\n                                  billing_period_end: datetime) -> ValidationResult:\n        \"\"\"\n        Validates that upgrade followed by immediate downgrade results in zero net charge.\n        Tests proration calculation symmetry and consistency.\n        \"\"\"\n        # Calculate upgrade proration\n        upgrade_result = ProrationCalculator().calculate_plan_change_proration(\n            old_plan, new_plan, change_date, billing_period_start, billing_period_end\n        )\n        \n        # Calculate immediate downgrade proration\n        downgrade_result = ProrationCalculator().calculate_plan_change_proration(\n            new_plan, old_plan, change_date, billing_period_start, billing_period_end\n        )\n        \n        # Net amount should be zero (within precision tolerance)\n        net_charge = upgrade_result.net_amount.amount_cents + downgrade_result.net_amount.amount_cents\n        tolerance_cents = 1  # Allow 1 cent tolerance for rounding\n        \n        if abs(net_charge) > tolerance_cents:\n            return ValidationResult(\n                is_valid=False,\n                error_type=ValidationError.PRORATION_ASYMMETRY,\n                expected_value=0,\n                actual_value=net_charge,\n                details={\n                    'upgrade_net_cents': upgrade_result.net_amount.amount_cents,\n                    'downgrade_net_cents': downgrade_result.net_amount.amount_cents,\n                    'total_net_cents': net_charge,\n                    'tolerance_cents': tolerance_cents,\n                    'upgrade_details': upgrade_result.calculation_details,\n                    'downgrade_details': downgrade_result.calculation_details\n                }\n            )\n        \n        return ValidationResult(is_valid=True, error_type=None, expected_value=None, actual_value=None, details={})\n\nclass StateConsistencyChecker:\n    \"\"\"\n    Validates subscription and billing state consistency.\n    Identifies state machine violations and data synchronization issues.\n    \"\"\"\n    \n    def __init__(self, database_manager: 'DatabaseManager'):\n        self.db = database_manager\n        self.logger = logging.getLogger(__name__)\n    \n    def check_subscription_state_consistency(self, subscription_id: str) -> List[ValidationResult]:\n        \"\"\"\n        Comprehensive subscription state validation.\n        Checks state machine compliance and business rule adherence.\n        \"\"\"\n        results = []\n        \n        with self.db.transaction() as session:\n            subscription = session.query(Subscription).filter_by(subscription_id=subscription_id).first()\n            if not subscription:\n                return [ValidationResult(\n                    is_valid=False,\n                    error_type=ValidationError.CONSISTENCY,\n                    expected_value=\"subscription exists\",\n                    actual_value=\"subscription not found\",\n                    details={'subscription_id': subscription_id}\n                )]\n            \n            # Validate state-specific conditions\n            results.extend(self._validate_active_subscription_requirements(subscription, session))\n            results.extend(self._validate_past_due_subscription_requirements(subscription, session))\n            results.extend(self._validate_cancelled_subscription_requirements(subscription, session))\n        \n        return results\n    \n    def _validate_active_subscription_requirements(self, subscription: 'Subscription', session) -> List[ValidationResult]:\n        \"\"\"Validate requirements for active subscription status.\"\"\"\n        results = []\n        \n        if subscription.status != SubscriptionStatus.active:\n            return results\n        \n        # Active subscription must have valid payment method\n        payment_methods = session.query(PaymentMethod).filter_by(\n            customer_id=subscription.customer_id,\n            is_default=True\n        ).all()\n        \n        if not payment_methods:\n            results.append(ValidationResult(\n                is_valid=False,\n                error_type=ValidationError.STATE_CONSISTENCY,\n                expected_value=\"active subscription has default payment method\",\n                actual_value=\"no default payment method found\",\n                details={'subscription_id': subscription.subscription_id, 'customer_id': subscription.customer_id}\n            ))\n        \n        return results\n\nclass WebhookDebugger:\n    \"\"\"\n    Diagnoses webhook processing issues and payment gateway synchronization problems.\n    Provides detailed analysis of webhook event flow and processing status.\n    \"\"\"\n    \n    def __init__(self, database_manager: 'DatabaseManager'):\n        self.db = database_manager\n        self.logger = logging.getLogger(__name__)\n    \n    def analyze_webhook_processing(self, gateway_event_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Comprehensive webhook processing analysis.\n        Traces event from gateway through system processing.\n        \"\"\"\n        analysis = {\n            'gateway_event_id': gateway_event_id,\n            'processing_status': 'unknown',\n            'processing_attempts': [],\n            'business_impact': {},\n            'recommendations': []\n        }\n        \n        with self.db.transaction() as session:\n            # Find webhook event records\n            webhook_events = session.query(WebhookEvent).filter_by(\n                gateway_event_id=gateway_event_id\n            ).order_by(WebhookEvent.created_at).all()\n            \n            if not webhook_events:\n                analysis['processing_status'] = 'not_received'\n                analysis['recommendations'].append('Verify webhook URL configuration in payment gateway')\n                return analysis\n            \n            # Analyze processing attempts\n            for event in webhook_events:\n                attempt_info = {\n                    'event_id': event.event_id,\n                    'received_at': event.created_at.isoformat(),\n                    'processed_at': event.processed_at.isoformat() if event.processed_at else None,\n                    'idempotency_key': event.idempotency_key,\n                    'event_type': event.event_type\n                }\n                analysis['processing_attempts'].append(attempt_info)\n            \n            # Check for successful processing\n            processed_events = [e for e in webhook_events if e.processed_at is not None]\n            if processed_events:\n                analysis['processing_status'] = 'processed'\n                analysis['business_impact'] = self._analyze_business_impact(processed_events[-1], session)\n            else:\n                analysis['processing_status'] = 'failed'\n                analysis['recommendations'].extend([\n                    'Check application logs for processing errors',\n                    'Verify webhook payload structure matches expected format',\n                    'Confirm database connectivity during processing window'\n                ])\n        \n        return analysis\n```\n\n**Core Logic Skeleton - Billing Issue Diagnostic Tool:**\n\n```python\nclass BillingIssueDiagnostic:\n    \"\"\"\n    Command-line tool for diagnosing billing system issues.\n    Provides structured investigation workflow for common problems.\n    \"\"\"\n    \n    def __init__(self, database_manager: 'DatabaseManager'):\n        self.db = database_manager\n        self.validator = BillingCalculationValidator()\n        self.consistency_checker = StateConsistencyChecker(database_manager)\n        self.webhook_debugger = WebhookDebugger(database_manager)\n        self.logger = logging.getLogger(__name__)\n    \n    def diagnose_invoice_discrepancy(self, invoice_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Comprehensive invoice discrepancy diagnosis.\n        Validates all calculations and identifies source of errors.\n        \"\"\"\n        # TODO 1: Load invoice and related entities (subscription, customer, line items)\n        # TODO 2: Recalculate invoice total from line items and compare\n        # TODO 3: Validate each line item calculation (subscription, usage, proration, credits)\n        # TODO 4: Check for currency precision issues in calculations\n        # TODO 5: Verify credit application logic and amounts\n        # TODO 6: Generate detailed discrepancy report with recommendations\n        pass\n    \n    def diagnose_subscription_state_issue(self, subscription_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Subscription state diagnostic workflow.\n        Identifies invalid states and recommends correction steps.\n        \"\"\"\n        # TODO 1: Load subscription and validate current state\n        # TODO 2: Trace subscription event history for state transitions\n        # TODO 3: Validate state machine compliance for each transition\n        # TODO 4: Check for concurrent modification conflicts\n        # TODO 5: Verify payment method and invoice alignment with state\n        # TODO 6: Generate state correction recommendations\n        pass\n    \n    def diagnose_payment_processing_issue(self, payment_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Payment processing diagnostic workflow.\n        Traces payment through gateway integration and webhook processing.\n        \"\"\"\n        # TODO 1: Load payment record and related invoice/subscription\n        # TODO 2: Check payment gateway for corresponding transaction\n        # TODO 3: Analyze webhook processing for payment events\n        # TODO 4: Validate payment state consistency with gateway\n        # TODO 5: Check for duplicate payment processing\n        # TODO 6: Generate synchronization and recovery recommendations\n        pass\n\ndef main():\n    \"\"\"Command-line interface for billing system debugging.\"\"\"\n    import argparse\n    \n    parser = argparse.ArgumentParser(description='Billing System Diagnostic Tool')\n    parser.add_argument('issue_type', choices=['invoice', 'subscription', 'payment', 'webhook'])\n    parser.add_argument('entity_id', help='ID of entity to investigate')\n    parser.add_argument('--verbose', action='store_true', help='Enable detailed logging')\n    \n    args = parser.parse_args()\n    \n    if args.verbose:\n        logging.basicConfig(level=logging.DEBUG)\n    \n    db_manager = DatabaseManager()\n    diagnostic = BillingIssueDiagnostic(db_manager)\n    \n    if args.issue_type == 'invoice':\n        result = diagnostic.diagnose_invoice_discrepancy(args.entity_id)\n    elif args.issue_type == 'subscription':\n        result = diagnostic.diagnose_subscription_state_issue(args.entity_id)\n    elif args.issue_type == 'payment':\n        result = diagnostic.diagnose_payment_processing_issue(args.entity_id)\n    elif args.issue_type == 'webhook':\n        result = diagnostic.webhook_debugger.analyze_webhook_processing(args.entity_id)\n    \n    print(json.dumps(result, indent=2, default=str))\n\nif __name__ == '__main__':\n    main()\n```\n\n**Milestone Checkpoint - Debugging Tool Validation:**\n\nAfter implementing the debugging tools, validate their effectiveness with these checkpoints:\n\n1. **Currency Precision Validation**: Run `python -m billing.debug.calculation_validator` with test invoices containing known precision issues. The validator should identify floating-point drift and rounding inconsistencies.\n\n2. **State Consistency Checks**: Execute `python tools/debug_billing_issue.py subscription <subscription_id>` for subscriptions in various states. The tool should identify state machine violations and business rule inconsistencies.\n\n3. **Webhook Processing Analysis**: Use `python tools/debug_billing_issue.py webhook <gateway_event_id>` to trace webhook events from payment gateway through system processing. The analysis should show processing status and business impact.\n\n4. **Proration Symmetry Tests**: Execute proration validation tests that perform upgrade followed by immediate downgrade. The net charge should be zero within rounding tolerance.\n\n**Common Debugging Pitfalls:**\n\n⚠️ **Pitfall: Debugging Symptoms Instead of Root Causes**\nMany developers focus on fixing the immediate symptom (wrong invoice amount) without identifying the underlying issue (currency precision loss in calculations). Always trace the problem back to its source through the audit trail and recalculate values from scratch.\n\n⚠️ **Pitfall: Ignoring Timezone Issues in Date Calculations**\nBilling calculations often involve date arithmetic that can be affected by timezone conversions and daylight saving time changes. Always store timestamps in UTC and convert to local time only for display purposes.\n\n⚠️ **Pitfall: Assuming Webhook Processing is Synchronous**\nWebhook processing is inherently asynchronous, and debugging must account for processing delays, retries, and out-of-order delivery. Check webhook processing timestamps and correlate with business entity state changes.\n\n\n## Future Extensions and Scalability\n\n> **Milestone(s):** All milestones - outlines scalability considerations and future enhancements that build upon the foundation established in plan management (Milestone 1), subscription lifecycle (Milestone 2), proration (Milestone 3), and usage-based billing (Milestone 4)\n\n### Mental Model: Evolution of a Growing Business\n\nThink of the subscription billing system as a growing city's infrastructure. Initially, you build a water system that serves a few thousand residents with simple pipes and a single treatment plant. As the city grows, you need to add multiple treatment facilities (multi-tenant architecture), accommodate different types of buildings with varying water needs (advanced pricing models), and build comprehensive monitoring systems to track usage patterns and optimize distribution (analytics and revenue reporting).\n\nThe key architectural principle is that your foundational infrastructure must be designed to support this growth without requiring complete reconstruction. Just as a well-planned city leaves room for expansion and upgrades existing utilities rather than replacing them entirely, your billing system's core components must be extensible and composable to support future business requirements.\n\n### Advanced Pricing Models\n\nThe current system supports flat-rate, tiered, and volume-based pricing through the `PricingModel` enum and `PricingTier` structures. However, modern B2B SaaS businesses often require more sophisticated pricing models that adapt to complex customer requirements and business relationships.\n\n**Seat-Based Billing Implementation**\n\nSeat-based billing represents a significant extension where charges scale based on the number of active users or licenses within a customer's organization. This model requires tracking user activation and deactivation events throughout the billing cycle, calculating mid-cycle adjustments when users are added or removed, and handling the complexity of different user types with varying pricing.\n\nThe extension begins with enhancing the `Plan` entity to support seat-based pricing configurations. This involves adding fields for base seat count, additional seat pricing, and seat type definitions. The system must track seat usage through dedicated usage events that capture user activation, deactivation, and role changes with precise timestamps.\n\n| Component Enhancement | Current State | Seat-Based Extension |\n|----------------------|---------------|----------------------|\n| Plan Definition | Fixed pricing tiers | Dynamic seat multipliers with base counts |\n| Usage Tracking | Generic `UsageEvent` | Specialized seat activation/deactivation events |\n| Proration Logic | Time-based only | Combination of time and quantity-based proration |\n| Invoice Generation | Static line items | Dynamic seat count calculations per billing period |\n\nThe proration calculations become significantly more complex as they must handle both time-based and quantity-based changes. When a customer adds five users mid-cycle, the system calculates the prorated charge based on the remaining days in the billing period multiplied by the per-seat rate for those five additional users.\n\n**Custom Contract Support Architecture**\n\nEnterprise customers often negotiate custom pricing terms that don't fit standard plan structures. Supporting custom contracts requires a flexible pricing engine that can handle negotiated rates, volume commitments, and custom billing schedules while maintaining the integrity of the standard billing workflows.\n\n> **Decision: Contract-Based Pricing Architecture**\n> - **Context**: Enterprise customers require custom pricing terms, volume commitments, and specialized billing arrangements that exceed standard plan capabilities\n> - **Options Considered**: \n>   1. Extend existing plan system with custom fields\n>   2. Create parallel contract management system\n>   3. Build flexible pricing rule engine\n> - **Decision**: Implement a flexible pricing rule engine with contract overrides\n> - **Rationale**: Rule engine provides maximum flexibility while maintaining consistency with existing billing workflows, allows gradual migration of complex pricing logic\n> - **Consequences**: Increased system complexity but enables unlimited pricing model combinations, requires careful testing of rule interactions\n\n| Contract Feature | Implementation Approach | Integration Point |\n|-----------------|------------------------|-------------------|\n| Volume Commitments | Minimum usage guarantees with true-up invoicing | Usage aggregation engine |\n| Negotiated Rates | Custom pricing tiers per contract | Proration calculator |\n| Custom Billing Cycles | Flexible billing anchor dates | Renewal processing engine |\n| Revenue Recognition | Deferred revenue allocation | Invoice generation |\n\nThe contract management system introduces a `Contract` entity that references the base `Plan` but overrides specific pricing components. The billing engine checks for contract overrides at each calculation point, applying custom rates while maintaining the standard billing workflow structure.\n\n**Dynamic Pricing and Market-Based Adjustments**\n\nAdvanced pricing models increasingly incorporate dynamic elements that respond to market conditions, usage patterns, or customer behavior. This might include seasonal pricing adjustments, loyalty discounts based on tenure, or usage-based discounts that reward high-volume customers.\n\nThe implementation requires extending the pricing calculation engine to support conditional logic and temporal pricing rules. The system must evaluate pricing conditions at billing time, apply appropriate adjustments, and maintain an audit trail of pricing decisions for compliance and customer transparency.\n\n| Dynamic Pricing Type | Trigger Condition | Calculation Method | Persistence Strategy |\n|---------------------|-------------------|-------------------|---------------------|\n| Seasonal Adjustments | Date-based rules | Percentage modifier on base price | Versioned pricing rules |\n| Loyalty Discounts | Customer tenure calculation | Tiered discount percentage | Customer pricing history |\n| Volume Incentives | Usage threshold analysis | Progressive discount rates | Usage milestone tracking |\n| Market Adjustments | External data feeds | Algorithm-based price optimization | Real-time pricing cache |\n\n### Multi-Tenant Architecture\n\nAs the subscription billing system scales to serve multiple organizations or business units, the architecture must support tenant isolation, data segregation, and resource allocation while maintaining operational efficiency and cost-effectiveness.\n\n**Tenant Isolation Strategies**\n\nThe current single-tenant design stores all customer data in shared tables with global unique identifiers. Multi-tenant architecture requires careful consideration of data isolation levels, from shared databases with tenant identifiers to completely separate infrastructure per tenant.\n\n> **Decision: Schema-Per-Tenant with Shared Infrastructure**\n> - **Context**: Need to support multiple tenant organizations with strict data isolation requirements while maintaining operational efficiency\n> - **Options Considered**: \n>   1. Shared tables with tenant ID columns\n>   2. Separate database schema per tenant\n>   3. Completely isolated infrastructure per tenant\n> - **Decision**: Separate database schema per tenant with shared application infrastructure\n> - **Rationale**: Provides strong data isolation without infrastructure multiplication costs, enables tenant-specific customizations while sharing application logic\n> - **Consequences**: Database connection pooling complexity increases, tenant provisioning requires schema creation, backup and migration strategies become more complex\n\n| Isolation Level | Data Security | Operational Complexity | Cost Efficiency | Customization Flexibility |\n|----------------|---------------|------------------------|-----------------|--------------------------|\n| Shared Tables | Medium - relies on application logic | Low | High | Low |\n| Schema Per Tenant | High - database-level isolation | Medium | Medium | Medium |\n| Infrastructure Per Tenant | Highest - complete isolation | High | Low | High |\n\nThe schema-per-tenant approach requires enhancing the `DatabaseManager` to support dynamic schema selection based on request context. Each database operation must include tenant context, ensuring queries execute against the correct schema. The system maintains a tenant registry that maps tenant identifiers to their corresponding database schemas.\n\n**Tenant Provisioning Workflow**\n\nCreating new tenants involves provisioning database schemas, initializing default configurations, and setting up billing parameters specific to the tenant's requirements. This process must be automated and reliable to support rapid tenant onboarding.\n\nThe tenant provisioning workflow includes several critical steps:\n\n1. **Schema Creation**: Generate a new database schema with all required tables, indexes, and constraints based on the standard billing system structure\n2. **Configuration Initialization**: Create default billing settings, supported currencies, and system parameters appropriate for the tenant's geographic location and business model\n3. **Administrative User Setup**: Provision initial administrative users with appropriate permissions for tenant management\n4. **Integration Configuration**: Set up connections to the tenant's payment gateways, accounting systems, and other external services\n5. **Data Migration**: If applicable, import existing customer and subscription data from legacy systems with proper validation and reconciliation\n\n| Provisioning Step | Duration Estimate | Failure Recovery | Validation Requirements |\n|-------------------|-------------------|------------------|------------------------|\n| Schema Creation | 30 seconds | Drop and recreate | Table count and constraint verification |\n| Configuration Setup | 15 seconds | Configuration rollback | Currency and timezone validation |\n| User Provisioning | 10 seconds | User deletion | Authentication system integration |\n| Integration Testing | 2 minutes | Configuration reset | Payment gateway connectivity |\n| Data Migration | Variable | Partial rollback options | Data integrity checksums |\n\n**Cross-Tenant Resource Management**\n\nMulti-tenant architecture introduces challenges in resource allocation, performance isolation, and cost attribution. The system must prevent one tenant's heavy usage from impacting others while providing fair resource distribution and accurate cost allocation.\n\nThe resource management system implements tenant-aware quotas and rate limiting at multiple levels. Database connection pools maintain per-tenant limits to prevent connection exhaustion. API rate limiting applies tenant-specific thresholds based on their subscription tier or negotiated limits. Background processing queues use tenant-aware scheduling to ensure fair processing distribution.\n\n**Tenant-Specific Customizations**\n\nDifferent tenant organizations often require customizations in billing logic, invoice formatting, payment processing workflows, or integration requirements. The multi-tenant architecture must support these customizations without creating maintenance complexity or security vulnerabilities.\n\nThe customization framework uses a plugin architecture where tenant-specific logic extends standard billing workflows. Custom pricing calculators, invoice formatters, and payment processors implement standard interfaces while providing tenant-specific behavior. The system loads appropriate customizations based on tenant context during request processing.\n\n| Customization Type | Implementation Pattern | Isolation Method | Version Management |\n|-------------------|----------------------|------------------|-------------------|\n| Pricing Logic | Strategy pattern with tenant plugins | Interface-based isolation | Plugin versioning with compatibility checks |\n| Invoice Templates | Template engine with tenant themes | Resource namespace separation | Template version control |\n| Payment Workflows | Workflow step overrides | Tenant-specific workflow definitions | Workflow schema validation |\n| Integration Endpoints | Tenant-specific adapters | Configuration-driven routing | Adapter version compatibility |\n\n### Analytics and Revenue Reporting\n\nThe billing system generates vast amounts of financial and operational data that provides valuable insights into business performance, customer behavior, and revenue trends. Building comprehensive analytics capabilities transforms raw billing data into actionable business intelligence.\n\n**Revenue Recognition and Financial Reporting**\n\nModern subscription businesses must comply with accounting standards like ASC 606 that require careful revenue recognition practices. The system must track deferred revenue for prepaid subscriptions, recognize revenue over service delivery periods, and handle complex scenarios like plan changes and cancellations.\n\nRevenue recognition begins with the invoice generation process but extends far beyond simple cash collection. When a customer pays for an annual subscription, the system must defer the revenue recognition and allocate it monthly over the service delivery period. Plan upgrades and downgrades require pro-rata revenue adjustments that comply with accounting standards.\n\n| Revenue Recognition Scenario | Accounting Treatment | System Implementation | Compliance Requirements |\n|-----------------------------|--------------------|----------------------|------------------------|\n| Annual Prepayment | Deferred revenue with monthly recognition | Scheduled revenue allocation jobs | ASC 606 performance obligation tracking |\n| Mid-Cycle Upgrades | Immediate recognition of incremental value | Prorated revenue adjustment calculations | Revenue allocation between performance periods |\n| Service Cancellations | Immediate recognition of earned revenue | Revenue recognition acceleration | Refund liability accounting |\n| Usage-Based Charges | Recognition upon service delivery | Real-time revenue recognition for metered usage | Variable consideration estimation |\n\nThe revenue recognition engine maintains detailed records of performance obligations, contract modifications, and revenue allocation schedules. Monthly revenue recognition jobs process deferred revenue balances and generate accounting entries that integrate with external financial systems.\n\n**Customer Lifecycle Analytics**\n\nUnderstanding customer behavior patterns, churn predictors, and growth opportunities requires comprehensive analysis of subscription lifecycle data. The analytics system must track customer journey metrics, cohort analysis, and predictive indicators that inform business strategy.\n\nCustomer lifecycle analytics begin with subscription creation and continue through the entire customer relationship. The system tracks key metrics including customer acquisition cost, lifetime value, monthly recurring revenue, churn rates, and expansion revenue from upgrades and additional usage.\n\n> **Decision: Real-Time Analytics with Batch Aggregation**\n> - **Context**: Business users need both real-time dashboard updates and complex historical analysis requiring different performance and consistency characteristics\n> - **Options Considered**: \n>   1. Pure real-time analytics with stream processing\n>   2. Batch-only analytics with daily updates\n>   3. Hybrid real-time dashboards with batch analytical processing\n> - **Decision**: Implement hybrid architecture with real-time metrics and batch analytical processing\n> - **Rationale**: Real-time dashboards provide operational visibility while batch processing enables complex analytical queries without impacting billing system performance\n> - **Consequences**: Increased system complexity but optimal performance characteristics for different use cases, requires data consistency management between real-time and batch systems\n\n| Analytics Category | Update Frequency | Data Source | Storage System | Query Patterns |\n|-------------------|------------------|-------------|----------------|----------------|\n| Operational Metrics | Real-time | Transaction logs | Time-series database | Simple aggregations |\n| Cohort Analysis | Daily batch | Customer database | Analytical warehouse | Complex joins and pivots |\n| Revenue Forecasting | Weekly batch | Subscription and usage data | Analytical warehouse | Statistical modeling |\n| Churn Prediction | Daily batch | Customer behavior data | Machine learning platform | Predictive modeling |\n\n**Usage Pattern Analysis and Optimization**\n\nUsage-based billing generates detailed consumption data that reveals customer behavior patterns, feature adoption rates, and optimization opportunities. The analytics system must process high-volume usage events and extract meaningful insights about customer engagement and system utilization.\n\nUsage pattern analysis identifies customers approaching plan limits, features with low adoption rates, and optimization opportunities for both customers and the service provider. The system tracks usage trends over time, compares actual usage against purchased allowances, and identifies customers who might benefit from plan changes.\n\nThe usage analytics pipeline processes raw usage events through multiple aggregation stages. Real-time aggregation provides current usage dashboards and quota enforcement. Daily batch processing generates comprehensive usage reports and trend analysis. Weekly analytical jobs perform cohort analysis and usage pattern recognition.\n\n**Business Intelligence and Reporting Framework**\n\nThe comprehensive reporting framework must serve diverse stakeholder needs, from executive revenue dashboards to detailed customer success team reports. The system must balance query performance, data freshness, and analytical flexibility while maintaining data accuracy and security.\n\nThe reporting framework uses a layered architecture with operational data stores, analytical warehouses, and specialized reporting databases. Data flows from the transactional billing system through ETL pipelines that clean, transform, and aggregate information for analytical consumption.\n\n| Report Category | Target Audience | Update Frequency | Data Requirements | Performance Characteristics |\n|-----------------|----------------|------------------|-------------------|----------------------------|\n| Executive Dashboards | Leadership team | Real-time | High-level KPIs and trends | Fast loading, simple visualizations |\n| Financial Reports | Finance team | Daily | Detailed revenue and cost data | Complex calculations, audit trails |\n| Customer Success | Account managers | Real-time | Individual customer metrics | Drill-down capabilities, alert integration |\n| Product Analytics | Product team | Weekly | Feature usage and adoption | Statistical analysis, cohort comparisons |\n\n### Implementation Guidance\n\n**Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Multi-Tenant Database | PostgreSQL with schemas | Amazon RDS with cross-region replication |\n| Analytics Engine | PostgreSQL analytical queries | Apache Spark with Delta Lake |\n| Real-Time Metrics | Redis with time-series data | InfluxDB with Grafana dashboards |\n| Data Pipeline | Python ETL scripts | Apache Airflow with dbt transformations |\n| Reporting Layer | Django admin with custom views | Tableau or Looker integration |\n| Contract Management | JSON configuration in database | Dedicated contract service with approval workflows |\n\n**File Structure for Extensions**\n\n```\nsubscription-system/\n├── core/\n│   ├── billing/                    # Existing billing components\n│   ├── usage/                      # Existing usage tracking\n│   └── invoicing/                  # Existing invoice generation\n├── extensions/\n│   ├── advanced_pricing/\n│   │   ├── seat_based_billing.py   # Seat-based pricing engine\n│   │   ├── contract_manager.py     # Custom contract support\n│   │   └── dynamic_pricing.py      # Market-based pricing\n│   ├── multi_tenant/\n│   │   ├── tenant_manager.py       # Tenant provisioning and management\n│   │   ├── schema_manager.py       # Database schema management\n│   │   └── resource_manager.py     # Cross-tenant resource allocation\n│   └── analytics/\n│       ├── revenue_recognition.py  # ASC 606 compliant revenue tracking\n│       ├── customer_analytics.py   # Lifecycle and churn analysis\n│       └── usage_analytics.py      # Usage pattern analysis\n├── reporting/\n│   ├── dashboards/                 # Real-time dashboard components\n│   ├── etl/                        # Data pipeline jobs\n│   └── exports/                    # Report generation and export\n└── migrations/\n    ├── multi_tenant_setup/         # Schema setup for multi-tenancy\n    └── analytics_tables/           # Analytical warehouse setup\n```\n\n**Advanced Pricing Infrastructure**\n\n```python\n\"\"\"\nAdvanced pricing engine supporting seat-based billing and custom contracts.\nExtends the existing PricingModel enum and PricingTier structure.\n\"\"\"\n\nfrom enum import Enum\nfrom typing import Dict, List, Optional, Decimal\nfrom datetime import datetime, date\nfrom dataclasses import dataclass\n\nclass AdvancedPricingModel(Enum):\n    SEAT_BASED = \"seat_based\"\n    CONTRACT_CUSTOM = \"contract_custom\" \n    DYNAMIC_PRICING = \"dynamic_pricing\"\n    VOLUME_COMMITMENT = \"volume_commitment\"\n\n@dataclass\nclass SeatConfiguration:\n    \"\"\"Configuration for seat-based billing plans\"\"\"\n    base_seat_count: int\n    base_price_cents: int\n    additional_seat_price_cents: int\n    seat_types: Dict[str, int]  # seat_type -> price_per_seat_cents\n    proration_behavior: str  # \"immediate\", \"next_cycle\", \"anniversary\"\n    minimum_seats: Optional[int] = None\n    maximum_seats: Optional[int] = None\n\n@dataclass \nclass ContractTerms:\n    \"\"\"Custom contract pricing terms that override standard plans\"\"\"\n    contract_id: str\n    customer_id: str\n    base_plan_id: str\n    effective_date: date\n    expiration_date: Optional[date]\n    custom_pricing_rules: List[Dict]  # Flexible rule definitions\n    volume_commitments: Dict[str, Decimal]  # usage_type -> minimum_quantity\n    billing_schedule: str  # \"monthly\", \"quarterly\", \"annual\", \"custom\"\n    revenue_recognition_method: str\n    \nclass AdvancedPricingEngine:\n    \"\"\"\n    Extends the existing pricing engine to support advanced pricing models.\n    Integrates with existing Plan and PricingTier structures.\n    \"\"\"\n    \n    def __init__(self, base_pricing_engine, contract_manager, seat_tracker):\n        # TODO: Initialize with existing pricing engine for fallback\n        # TODO: Store references to contract manager and seat tracking\n        pass\n    \n    def calculate_subscription_charge(self, subscription_id: str, \n                                    billing_period_start: datetime,\n                                    billing_period_end: datetime) -> Money:\n        \"\"\"\n        Calculate total subscription charge including advanced pricing.\n        \n        Steps:\n        1. Load subscription and determine pricing model type\n        2. Check for custom contract overrides\n        3. Apply appropriate pricing calculation method\n        4. Handle seat-based calculations if applicable\n        5. Apply any dynamic pricing adjustments\n        6. Return final calculated amount\n        \"\"\"\n        # TODO: Implement seat-based calculation logic\n        # TODO: Check for contract overrides\n        # TODO: Apply dynamic pricing rules\n        # TODO: Integrate with existing proration logic\n        pass\n    \n    def calculate_seat_based_charge(self, subscription, seat_config: SeatConfiguration,\n                                  current_seats: int, billing_days: int) -> Money:\n        \"\"\"\n        Calculate charges for seat-based billing model.\n        \n        Steps:\n        1. Calculate base seat charge (included seats)\n        2. Calculate additional seat charges\n        3. Apply seat type specific pricing\n        4. Handle mid-cycle seat changes with proration\n        5. Apply minimum/maximum seat constraints\n        \"\"\"\n        # TODO: Implement seat-based pricing calculation\n        # TODO: Handle different seat types with different rates\n        # TODO: Calculate proration for mid-cycle seat changes\n        pass\n    \n    def apply_contract_pricing(self, base_amount: Money, contract: ContractTerms) -> Money:\n        \"\"\"\n        Apply custom contract pricing rules to override standard pricing.\n        \n        Steps:\n        1. Evaluate contract rule conditions\n        2. Apply percentage discounts or fixed amounts\n        3. Handle volume commitment calculations\n        4. Validate pricing against contract terms\n        5. Generate audit trail for contract pricing\n        \"\"\"\n        # TODO: Implement contract rule evaluation engine\n        # TODO: Handle volume commitment true-up calculations  \n        # TODO: Apply custom billing schedule adjustments\n        pass\n```\n\n**Multi-Tenant Infrastructure**\n\n```python\n\"\"\"\nMulti-tenant architecture supporting schema-per-tenant isolation\nwith shared application infrastructure.\n\"\"\"\n\nfrom typing import Dict, Optional, List\nimport threading\nfrom contextlib import contextmanager\nfrom dataclasses import dataclass\n\n@dataclass\nclass TenantConfiguration:\n    \"\"\"Configuration settings specific to a tenant\"\"\"\n    tenant_id: str\n    schema_name: str\n    database_url: str\n    supported_currencies: List[str]\n    default_currency: str\n    timezone: str\n    billing_settings: Dict\n    payment_gateway_config: Dict\n    feature_flags: Dict[str, bool]\n\nclass TenantContext:\n    \"\"\"Thread-local tenant context for request processing\"\"\"\n    _local = threading.local()\n    \n    @classmethod\n    def set_current_tenant(cls, tenant_id: str):\n        # TODO: Set thread-local tenant context\n        # TODO: Load tenant configuration from cache\n        # TODO: Validate tenant is active and accessible\n        pass\n    \n    @classmethod  \n    def get_current_tenant(cls) -> Optional[str]:\n        # TODO: Return current thread-local tenant ID\n        # TODO: Raise exception if no tenant context set\n        pass\n    \n    @classmethod\n    def get_tenant_config(cls) -> TenantConfiguration:\n        # TODO: Return configuration for current tenant\n        # TODO: Cache configuration for performance\n        pass\n\nclass TenantDatabaseManager:\n    \"\"\"\n    Manages database connections and schema routing for multi-tenant architecture.\n    Extends the existing DatabaseManager with tenant-aware operations.\n    \"\"\"\n    \n    def __init__(self, base_database_manager):\n        # TODO: Store reference to base database manager\n        # TODO: Initialize tenant schema registry\n        # TODO: Setup connection pooling per tenant\n        pass\n    \n    @contextmanager\n    def tenant_transaction(self, isolation_level=None):\n        \"\"\"\n        Create database transaction for current tenant schema.\n        \n        Steps:\n        1. Get current tenant context\n        2. Select appropriate database connection\n        3. Set schema search path for tenant\n        4. Begin transaction with specified isolation\n        5. Yield session to caller\n        6. Commit or rollback based on exceptions\n        7. Reset connection state\n        \"\"\"\n        # TODO: Implement tenant-aware transaction management\n        # TODO: Handle schema switching and connection pooling\n        # TODO: Ensure proper cleanup on success or failure\n        pass\n    \n    def provision_tenant_schema(self, tenant_config: TenantConfiguration) -> bool:\n        \"\"\"\n        Create database schema and initial setup for new tenant.\n        \n        Steps:\n        1. Create database schema with tenant name\n        2. Run all migration scripts in new schema\n        3. Insert default configuration data\n        4. Create initial admin user\n        5. Validate schema creation success\n        6. Register tenant in tenant registry\n        \"\"\"\n        # TODO: Implement schema creation and migration\n        # TODO: Handle rollback on provision failure\n        # TODO: Validate schema integrity after creation\n        pass\n    \n    def deprovision_tenant_schema(self, tenant_id: str) -> bool:\n        \"\"\"\n        Safely remove tenant schema and all associated data.\n        \n        Steps:\n        1. Validate tenant can be safely removed\n        2. Export tenant data for backup if required\n        3. Drop tenant schema and all objects\n        4. Remove tenant from registry\n        5. Clean up connection pool resources\n        \"\"\"\n        # TODO: Implement safe tenant removal with backup\n        # TODO: Validate no active connections to tenant schema\n        # TODO: Handle cleanup of related resources\n        pass\n\nclass TenantResourceManager:\n    \"\"\"\n    Manages resource allocation and limits across tenants.\n    \"\"\"\n    \n    def __init__(self):\n        # TODO: Initialize resource tracking and limits\n        # TODO: Setup tenant quota configuration\n        pass\n    \n    def check_tenant_quota(self, tenant_id: str, resource_type: str, \n                          requested_amount: int) -> bool:\n        \"\"\"\n        Check if tenant can consume additional resources.\n        \n        Steps:\n        1. Load tenant resource quotas and current usage\n        2. Check if requested amount exceeds remaining quota\n        3. Apply any burst allowances or temporary increases\n        4. Log quota check for monitoring and billing\n        5. Return availability decision\n        \"\"\"\n        # TODO: Implement quota checking with burst handling\n        # TODO: Track resource usage per tenant\n        # TODO: Handle quota enforcement and alerting\n        pass\n```\n\n**Analytics and Reporting Infrastructure**\n\n```python\n\"\"\"\nAnalytics and revenue reporting system with real-time metrics\nand batch analytical processing.\n\"\"\"\n\nfrom typing import Dict, List, Optional, Tuple\nfrom datetime import datetime, date, timedelta\nfrom decimal import Decimal\nfrom dataclasses import dataclass\n\n@dataclass\nclass RevenueRecognitionSchedule:\n    \"\"\"Schedule for recognizing deferred revenue over time\"\"\"\n    subscription_id: str\n    invoice_id: str\n    total_amount_cents: int\n    recognition_start_date: date\n    recognition_end_date: date\n    monthly_recognition_cents: int\n    recognized_to_date_cents: int\n    remaining_deferred_cents: int\n\nclass RevenueRecognitionEngine:\n    \"\"\"\n    ASC 606 compliant revenue recognition for subscription billing.\n    Handles deferred revenue allocation and recognition scheduling.\n    \"\"\"\n    \n    def __init__(self, billing_engine, accounting_integration):\n        # TODO: Initialize with billing engine and accounting system\n        # TODO: Load revenue recognition policies and schedules\n        pass\n    \n    def create_recognition_schedule(self, invoice: Invoice) -> List[RevenueRecognitionSchedule]:\n        \"\"\"\n        Create revenue recognition schedule for invoice line items.\n        \n        Steps:\n        1. Analyze each line item for revenue recognition requirements\n        2. Determine performance obligation periods\n        3. Calculate monthly recognition amounts\n        4. Handle proration for partial periods\n        5. Create recognition schedule entries\n        6. Integrate with accounting system journal entries\n        \"\"\"\n        # TODO: Implement ASC 606 compliant revenue recognition\n        # TODO: Handle different line item types (subscription, usage, etc.)\n        # TODO: Create deferred revenue liability accounts\n        pass\n    \n    def process_monthly_recognition(self, recognition_date: date) -> List[Dict]:\n        \"\"\"\n        Process monthly revenue recognition for all active schedules.\n        \n        Steps:\n        1. Load all active recognition schedules for the month\n        2. Calculate recognition amounts for each schedule\n        3. Generate accounting journal entries\n        4. Update recognition schedule progress\n        5. Handle schedule modifications for plan changes\n        6. Export entries to accounting system\n        \"\"\"\n        # TODO: Implement monthly revenue recognition batch job\n        # TODO: Handle plan changes and cancellations\n        # TODO: Generate accounting system integration data\n        pass\n\nclass CustomerAnalyticsEngine:\n    \"\"\"\n    Customer lifecycle analytics including cohort analysis and churn prediction.\n    \"\"\"\n    \n    def __init__(self, subscription_engine, usage_engine):\n        # TODO: Initialize with data sources\n        # TODO: Setup analytical data pipeline connections\n        pass\n    \n    def calculate_customer_lifetime_metrics(self, customer_id: str) -> Dict:\n        \"\"\"\n        Calculate comprehensive customer lifetime value and behavior metrics.\n        \n        Steps:\n        1. Load customer subscription and payment history\n        2. Calculate total revenue and average monthly revenue\n        3. Determine customer tenure and renewal rates\n        4. Analyze usage patterns and feature adoption\n        5. Calculate customer acquisition cost attribution\n        6. Generate churn risk indicators\n        \"\"\"\n        # TODO: Implement LTV calculation with usage correlation\n        # TODO: Calculate customer health scores\n        # TODO: Generate expansion opportunity indicators\n        pass\n    \n    def generate_cohort_analysis(self, cohort_period: str, \n                               analysis_date: date) -> List[Dict]:\n        \"\"\"\n        Generate cohort retention and revenue analysis.\n        \n        Steps:\n        1. Group customers by acquisition period (monthly cohorts)\n        2. Track retention rates over subsequent periods\n        3. Calculate revenue per cohort over time\n        4. Identify cohort behavior patterns\n        5. Generate expansion and contraction metrics\n        6. Export analysis for business intelligence tools\n        \"\"\"\n        # TODO: Implement cohort analysis with revenue tracking\n        # TODO: Handle different cohort definitions (acquisition, upgrade, etc.)\n        # TODO: Generate actionable insights and recommendations\n        pass\n\nclass UsageAnalyticsEngine:\n    \"\"\"\n    Usage pattern analysis and optimization recommendations.\n    \"\"\"\n    \n    def __init__(self, usage_tracker, plan_manager):\n        # TODO: Initialize with usage tracking and plan data\n        # TODO: Setup usage trend analysis pipelines\n        pass\n    \n    def analyze_usage_patterns(self, customer_id: str, \n                             analysis_period_days: int) -> Dict:\n        \"\"\"\n        Analyze customer usage patterns and optimization opportunities.\n        \n        Steps:\n        1. Load usage events for analysis period\n        2. Calculate usage trends and seasonality\n        3. Compare against plan allowances and limits\n        4. Identify optimization opportunities (plan changes)\n        5. Generate usage forecasts and recommendations\n        6. Calculate potential cost savings or revenue expansion\n        \"\"\"\n        # TODO: Implement usage trend analysis with forecasting\n        # TODO: Generate plan optimization recommendations\n        # TODO: Identify customers approaching limits for upselling\n        pass\n```\n\n**Milestone Checkpoints**\n\n**Advanced Pricing Validation:**\n1. **Seat-Based Billing Test**: Create a seat-based plan and add/remove users mid-cycle. Verify prorated charges calculate correctly: `python test_seat_based_billing.py`\n2. **Contract Override Test**: Configure a custom contract with negotiated rates. Verify billing engine applies contract pricing instead of standard plan rates\n3. **Dynamic Pricing Test**: Setup seasonal pricing rules and verify they apply correctly during the effective periods\n\n**Multi-Tenant Validation:**\n1. **Schema Isolation Test**: Create multiple tenants and verify data isolation. Query from one tenant should never return another tenant's data\n2. **Resource Quota Test**: Configure tenant quotas and verify enforcement. Exceeding quotas should block additional resource consumption\n3. **Tenant Provisioning Test**: Provision a new tenant and verify complete setup including schema creation, configuration, and user access\n\n**Analytics Validation:**\n1. **Revenue Recognition Test**: Create subscriptions with deferred revenue and verify recognition schedule accuracy over multiple months\n2. **Customer Analytics Test**: Generate cohort analysis reports and verify retention/revenue calculations match manual verification\n3. **Usage Pattern Test**: Submit usage events and verify analytical aggregations match real-time tracking within acceptable variance\n\n**Common Pitfalls and Solutions**\n\n⚠️ **Pitfall: Seat Change Proration Complexity**\nSeat-based billing introduces complex proration scenarios where quantity and time-based proration interact. Adding 5 seats mid-cycle requires calculating the prorated charge for the remaining billing period, but the calculation must account for different seat types and pricing tiers.\n\nSolution: Implement seat change proration as a specialized case of the general proration engine, treating seat additions as quantity-based plan changes with time-based proration factors.\n\n⚠️ **Pitfall: Multi-Tenant Data Leakage**\nThe most critical risk in multi-tenant architecture is data leakage between tenants. A missing tenant context check or incorrect schema routing could expose one tenant's sensitive financial data to another tenant.\n\nSolution: Implement defense-in-depth with multiple isolation layers: middleware-level tenant validation, database-level schema enforcement, and application-level data access controls. Every database query must include tenant context validation.\n\n⚠️ **Pitfall: Revenue Recognition Complexity**\nASC 606 compliance requires detailed tracking of performance obligations and revenue allocation. Plan changes, cancellations, and usage-based billing create complex scenarios where revenue recognition schedules must be modified mid-stream.\n\nSolution: Treat revenue recognition as an event-driven process where subscription changes trigger recognition schedule updates. Maintain detailed audit trails for all recognition adjustments to support compliance requirements.\n\n⚠️ **Pitfall: Analytics Performance Impact**\nReal-time analytics queries can impact billing system performance, especially complex analytical queries that scan large datasets. Running cohort analysis during peak billing periods could slow invoice generation.\n\nSolution: Implement read replicas for analytical workloads and use batch processing for complex analysis. Provide real-time metrics through pre-computed aggregations and time-series databases optimized for analytical queries.\n\n\n## Glossary\n\n> **Milestone(s):** All milestones - provides comprehensive definitions of billing terminology, technical concepts, and domain-specific vocabulary used throughout the subscription billing system implementation\n\n### Mental Model: Building a Shared Language\n\nThink of this glossary as the **shared dictionary** for your billing system team. Just as a successful engineering team develops common terminology for complex concepts, a billing system requires precise vocabulary to prevent costly misunderstandings. When someone says \"proration,\" everyone must understand whether they mean time-based partial charges, quantity-based adjustments, or both. When discussing \"dunning,\" the team needs to know exactly which payment recovery stage is being referenced.\n\nThis shared language becomes critical during incident response. When a customer reports a billing discrepancy at 2 AM, the on-call engineer needs to quickly understand whether the issue involves \"usage aggregation boundaries,\" \"proration symmetry violations,\" or \"webhook idempotency failures.\" Clear terminology accelerates both development and operational troubleshooting.\n\nThe terminology is organized into logical groupings: core billing concepts that form the foundation, technical implementation terms that describe how the system works, and operational vocabulary used during monitoring and support. Each term includes context about when and why it's used, helping engineers understand not just what terms mean but when to apply them correctly.\n\n### Core Billing and Subscription Terminology\n\nThese terms form the fundamental vocabulary of subscription billing systems. Understanding these concepts is essential for anyone working with recurring revenue models, whether in product management, engineering, or customer support roles.\n\n| Term | Definition | Context and Usage |\n|------|------------|-------------------|\n| **subscription billing** | Recurring payment system with lifecycle management that automatically charges customers at regular intervals for ongoing service access | The foundational concept encompassing all aspects of recurring revenue collection, from plan selection through renewal cycles |\n| **billing anchor** | Fixed day for recurring subscription charges, typically set when the subscription is created and maintained throughout its lifecycle | Critical for consistent customer expectations - a subscription created on January 15th should always bill on the 15th of each month |\n| **proration** | Partial charge calculation for mid-cycle changes, ensuring customers pay only for the portion of service they actually receive | Applied during plan upgrades, downgrades, or partial billing periods; must maintain mathematical precision to avoid customer disputes |\n| **grandfathering** | Protecting existing customers from plan changes by allowing them to maintain their original pricing and terms indefinitely | Essential for customer retention when updating pricing models; requires plan versioning to maintain legacy terms |\n| **plan versioning** | Creating new plan versions while maintaining old ones, allowing existing subscribers to keep their original terms | Enables product evolution without disrupting existing customer agreements; prevents forced migrations that could cause churn |\n| **feature entitlements** | Capabilities unlocked by subscription plans, defining what functionality each tier provides to subscribers | Controls access to premium features, API rate limits, storage quotas, and other plan-specific benefits |\n| **dunning management** | Systematic payment failure recovery process that attempts to collect overdue payments through escalating actions | Automated workflow typically including payment retries, email notifications, service restrictions, and eventual cancellation |\n| **grace period** | Time window maintaining service access after payment failure, providing customers opportunity to resolve payment issues | Balances business needs (revenue collection) with customer experience (avoiding service disruption during temporary payment issues) |\n| **usage-based billing** | Charges based on metered consumption, where customers pay for actual usage beyond their plan's included allowances | Common in SaaS for API calls, storage, bandwidth, or processing time; requires robust usage tracking and aggregation systems |\n| **credit balance** | Accumulated customer credits available for future use, typically from downgrades, refunds, or promotional credits | Must be applied automatically to reduce invoice amounts; requires careful tracking to prevent revenue recognition issues |\n| **billing period boundaries** | Start and end dates for usage calculations and recurring charges, ensuring consistent aggregation windows | Critical for usage-based billing accuracy; typically aligned with subscription anniversary dates to simplify customer understanding |\n\n### Pricing and Plan Management Terms\n\nThese terms relate to the flexible pricing structures and plan configurations that support diverse business models. They're particularly relevant during Milestone 1 implementation and ongoing plan management operations.\n\n| Term | Definition | Context and Usage |\n|------|------------|-------------------|\n| **pricing tiers** | Usage brackets with different rates, allowing volume discounts or premium pricing for high consumption | Enables sophisticated pricing strategies like volume discounts; requires careful tier boundary calculations to avoid customer confusion |\n| **tiered pricing** | Different rates for different usage levels within a single billing period, with each tier charged separately | Each usage tier has its own rate - first 1000 API calls at $0.10 each, next 5000 at $0.08 each, etc. |\n| **volume pricing** | Single rate applied to total usage once a threshold is reached, typically offering better rates for higher volumes | Simpler than tiered - once you hit 1000 API calls, your entire usage is charged at the volume rate |\n| **seat-based billing** | Pricing model that scales with number of active users or licenses allocated to the customer account | Common in B2B SaaS; requires tracking active user counts and handling seat additions/removals with appropriate proration |\n| **usage allowances** | Included quantities in subscription plans before overage charges apply | Base plan might include 10,000 API calls per month; additional usage incurs overage charges at specified rates |\n| **overage charges** | Fees for usage beyond plan allowances, calculated using tiered or volume pricing structures | Applied monthly during invoice generation; customers should receive usage alerts before reaching overage thresholds |\n| **usage metrics** | Measurable activities that can be billed, such as API calls, storage consumption, or processing time | Must be clearly defined and consistently measured; forms the basis for usage-based billing calculations |\n| **quota enforcement** | Limiting usage based on plan allowances to prevent unexpected charges or system abuse | Can be soft limits (allow overage with charges) or hard limits (block usage at threshold) |\n| **contract-based pricing** | Custom pricing terms negotiated for enterprise customers, overriding standard plan rates | Requires special handling in billing logic to apply negotiated discounts or custom rate structures |\n| **dynamic pricing** | Market-responsive pricing adjustments based on demand, usage patterns, or external conditions | Advanced feature requiring careful implementation to maintain customer trust and billing predictability |\n\n### Technical Implementation Vocabulary\n\nThese terms describe the technical architecture and implementation patterns used to build reliable billing systems. They're essential for engineering teams working on system design, implementation, and maintenance.\n\n| Term | Definition | Context and Usage |\n|------|------------|-------------------|\n| **financial precision** | Accurate monetary calculations using integer cents to avoid floating-point rounding errors | Always store money amounts as integers (cents, pence, etc.) and use `Money` types for all financial operations |\n| **currency precision** | Using smallest currency unit to avoid rounding errors in international billing scenarios | Essential for multi-currency support; different currencies have different precision requirements (yen has no fractional units) |\n| **idempotency** | Ensuring operations can be safely retried without causing duplicate charges or state changes | Critical for webhook processing, payment operations, and any operation that might be retried during failures |\n| **state machine** | Defined states and transitions for subscription lifecycle management with validation rules | Prevents invalid state transitions and ensures consistent subscription behavior across all system components |\n| **audit trail** | Complete record of financial operations and state changes for compliance and debugging | Required for financial systems; every billing operation must be logged with timestamp, actor, and change details |\n| **optimistic concurrency control** | Version-based conflict detection for concurrent updates to prevent data corruption | Uses version numbers to detect when two operations attempt to modify the same entity simultaneously |\n| **workflow orchestration** | Coordinating multi-step business processes across components with compensation and retry logic | Essential for complex operations like subscription creation, plan changes, and billing cycles |\n| **event-driven architecture** | System design using asynchronous event communication between loosely coupled components | Enables scalability and resilience; billing events trigger downstream processing without tight coupling |\n| **transactional outbox** | Pattern for reliable event publishing with database transactions to ensure consistency | Guarantees that database changes and event publications succeed or fail together |\n| **compensation pattern** | Rollback strategy for distributed operations when part of a multi-step process fails | Implements \"saga pattern\" for distributed transactions; each step must have a corresponding compensation action |\n| **circuit breaker** | Failure prevention pattern for external service calls that opens when failure thresholds are exceeded | Protects billing system from cascading failures when payment gateways or other external services become unavailable |\n| **eventual consistency** | Data consistency model allowing temporary inconsistencies that resolve over time | Acceptable for some billing scenarios where immediate consistency isn't required, such as usage reporting dashboards |\n\n### Data and Storage Concepts\n\nThese terms relate to data modeling, persistence, and consistency requirements specific to billing systems. They're crucial for understanding data architecture decisions and debugging data-related issues.\n\n| Term | Definition | Context and Usage |\n|------|------------|-------------------|\n| **usage factor** | Fraction of billing cycle remaining, used in proration calculations for time-based adjustments | Calculated as (days_remaining / total_days_in_cycle); critical for accurate proration math |\n| **proration symmetry** | Mathematical property that upgrade followed by downgrade should net to zero charge | Essential invariant for testing proration logic; prevents customer disputes over billing accuracy |\n| **billing cycle integration** | Coordination between subscription renewals, usage aggregation, and invoice generation | Ensures all charges for a billing period are captured in the correct invoice |\n| **real-time approximation** | Fast estimates for dashboards and quotas without full aggregation accuracy | Provides immediate feedback for usage-based services while batch processes calculate precise billing amounts |\n| **batch aggregation** | Scheduled processing for complex analytical computations and precise billing calculations | Runs during off-peak hours to perform expensive usage aggregation and generate accurate invoices |\n| **event deduplication** | Preventing duplicate charges for same activity when usage events are reported multiple times | Uses idempotency keys or event IDs to identify and skip duplicate usage reports |\n| **time zone consistency** | UTC timestamp handling across different time zones to ensure consistent billing periods | All internal processing uses UTC; timezone conversion only for customer-facing displays |\n| **calendar arithmetic** | Date calculations handling month overflow and leap years in billing cycle calculations | February billing cycles, leap years, and month-end subscriptions require special handling |\n| **schema-per-tenant** | Database isolation strategy with separate schemas per tenant in multi-tenant systems | Provides strong data isolation while sharing underlying database infrastructure |\n| **tenant isolation** | Preventing data leakage between tenant organizations in multi-tenant billing systems | Critical for SaaS platforms serving multiple organizations; includes data, processing, and access isolation |\n\n### Payment and Financial Processing Terms\n\nThese terms cover payment processing, financial compliance, and revenue recognition aspects of billing systems. They're particularly important for payment gateway integration and financial reporting.\n\n| Term | Definition | Context and Usage |\n|------|------------|-------------------|\n| **payment gateway integration** | Connecting to external payment processors like Stripe, PayPal, or Braintree for charge processing | Requires webhook handling, idempotency protection, and proper error handling for payment failures |\n| **webhook processing** | Handling asynchronous payment status updates from payment gateways reliably | Must include signature verification, idempotency protection, and retry logic for processing failures |\n| **idempotency protection** | Preventing duplicate operation processing when webhooks or API calls are retried | Uses idempotency keys to identify and skip operations that have already been processed |\n| **payment method tokenization** | Storing secure references to payment instruments without handling sensitive card data | PCI compliance requirement; payment processors provide tokens that reference stored payment methods |\n| **dunning escalation** | Progression through increasingly severe actions during payment failure recovery | Typical stages: retry payment → email notification → service restriction → account suspension → cancellation |\n| **revenue recognition** | ASC 606 compliant allocation of revenue over service delivery periods for financial reporting | Required for public companies; subscription revenue is typically recognized ratably over the service period |\n| **deferred revenue** | Liability for services not yet delivered on prepaid subscriptions | Annual subscription payments create deferred revenue that's recognized monthly as service is delivered |\n| **churn prediction** | Analytical model identifying customers at risk of cancellation for retention efforts | Uses billing history, usage patterns, and support interactions to predict cancellation probability |\n| **customer lifetime value** | Total revenue expected from customer relationship over its entire duration | Key metric for subscription businesses; influences customer acquisition spending and retention investments |\n| **cohort analysis** | Grouping customers by acquisition period for retention analysis and business planning | Tracks how customer groups behave over time; essential for understanding business health and growth trends |\n\n### Error Handling and Debugging Terminology\n\nThese terms are essential for troubleshooting billing issues, handling edge cases, and maintaining system reliability in production environments.\n\n| Term | Definition | Context and Usage |\n|------|------------|-------------------|\n| **billing calculation debugging** | Systematic approach to identifying and resolving mathematical errors in subscription billing | Involves tracing calculation inputs, intermediate steps, and final outputs to identify discrepancies |\n| **state consistency** | Alignment between subscription states and related entity states like invoices and payments | Prevents scenarios where subscription shows active but last payment failed; requires cross-entity validation |\n| **webhook reliability** | Ensuring payment gateway events are consistently processed despite network issues or system failures | Requires idempotency, retry logic, and dead letter queues for failed webhook processing |\n| **mathematical invariants** | Properties that must hold true across all test scenarios, such as proration symmetry | Used in property-based testing to verify billing logic correctness across many input combinations |\n| **currency precision testing** | Validation of monetary calculations using integer cents to prevent rounding errors | Ensures all money operations maintain precision and avoid accumulation of rounding errors |\n| **billing logic unit tests** | Mathematical validation of calculation accuracy for proration, usage charges, and pricing tiers | Tests individual calculation functions with known inputs and expected outputs |\n| **integration testing** | Validation of component interaction and data flow across system boundaries | Ensures components work correctly together and data flows properly through complete workflows |\n| **property-based testing** | Automated test generation verifying mathematical invariants across many random inputs | Particularly valuable for billing systems where mathematical correctness is critical |\n| **milestone validation checkpoints** | Verification criteria for development phase completion with specific acceptance tests | Defines what must work correctly before proceeding to next development milestone |\n| **webhook processing reliability** | Ensuring payment gateway webhooks are processed exactly once despite retries or failures | Critical for payment status updates; failures can lead to service disruptions or revenue loss |\n\n### Advanced Architecture and Scalability Terms\n\nThese terms relate to sophisticated architectural patterns and scalability considerations for large-scale billing systems serving many customers and high transaction volumes.\n\n| Term | Definition | Context and Usage |\n|------|------------|-------------------|\n| **multi-tenant architecture** | System design supporting multiple isolated tenant organizations with shared infrastructure | Enables SaaS platforms to serve many customer organizations while maintaining data isolation and security |\n| **resource allocation** | Fair distribution of system resources across tenants to prevent noisy neighbor problems | Includes CPU, memory, database connections, and API rate limits; ensures tenant isolation |\n| **performance obligation** | Distinct service commitment requiring revenue recognition under ASC 606 accounting standards | Each separately identifiable service component may require separate revenue recognition treatment |\n| **usage pattern analysis** | Examination of consumption trends for optimization opportunities and capacity planning | Identifies customers approaching plan limits, unusual usage spikes, or opportunities for plan upgrades |\n| **real-time analytics** | Immediate data processing for operational dashboards and customer-facing usage displays | Provides current usage information while batch processes handle precise billing calculations |\n| **distributed transaction management** | Coordinating consistency across multiple services and databases in billing operations | Uses saga patterns and compensation logic to maintain consistency without distributed locks |\n| **eventual consistency patterns** | Designing for temporary inconsistencies that resolve through background synchronization | Acceptable for some billing scenarios where immediate consistency isn't required |\n| **horizontal scaling strategies** | Techniques for scaling billing systems across multiple servers and database shards | Includes sharding by customer ID, tenant isolation, and distributed processing patterns |\n| **capacity planning** | Forecasting resource requirements based on customer growth and usage patterns | Critical for handling billing cycles, usage processing spikes, and payment processing loads |\n| **disaster recovery** | Business continuity planning for billing system failures and data center outages | Includes backup strategies, failover procedures, and recovery time objectives for financial systems |\n\n### Compliance and Regulatory Terms\n\nThese terms cover legal, regulatory, and compliance requirements that billing systems must address, particularly in regulated industries or international markets.\n\n| Term | Definition | Context and Usage |\n|------|------------|-------------------|\n| **PCI compliance** | Payment Card Industry security standards for handling credit card information | Required when processing payments; affects system architecture and data handling procedures |\n| **data residency** | Legal requirements for where customer data must be stored and processed geographically | Important for international billing systems serving customers in regulated jurisdictions |\n| **audit compliance** | Meeting requirements for financial record keeping and audit trail maintenance | Includes immutable audit logs, change tracking, and retention policies for financial transactions |\n| **tax calculation** | Computing appropriate taxes based on customer location and applicable tax rates | Complex in international contexts; often requires integration with tax calculation services |\n| **regulatory reporting** | Meeting requirements for financial reporting to regulatory authorities | Includes revenue recognition, tax reporting, and anti-money laundering compliance |\n| **customer data protection** | Implementing GDPR, CCPA, and other privacy regulations in billing systems | Affects data collection, storage, processing, and customer rights to access and deletion |\n| **financial controls** | Internal processes ensuring accuracy and preventing fraud in billing operations | Includes segregation of duties, approval workflows, and reconciliation procedures |\n| **retention policies** | Legal requirements for how long financial records must be maintained | Varies by jurisdiction and industry; affects database design and archival strategies |\n| **cross-border payments** | Handling international transactions with currency conversion and regulatory compliance | Includes foreign exchange rates, international banking regulations, and tax implications |\n| **subscription cancellation rights** | Legal requirements for customer cancellation processes and refund policies | Varies by jurisdiction; affects subscription lifecycle design and refund processing |\n\n### Testing and Quality Assurance Vocabulary\n\nThese terms describe testing strategies, quality assurance practices, and validation approaches specific to billing systems where accuracy and reliability are paramount.\n\n| Term | Definition | Context and Usage |\n|------|------------|-------------------|\n| **end-to-end testing** | Complete workflow validation from customer signup through payment processing and service delivery | Ensures entire billing process works correctly including external integrations |\n| **load testing** | Validating system performance under expected and peak transaction volumes | Critical for billing cycles when many customers are processed simultaneously |\n| **chaos engineering** | Deliberately introducing failures to test system resilience and recovery procedures | Important for billing systems where failures can impact revenue and customer trust |\n| **regression testing** | Ensuring changes don't break existing billing calculations or customer agreements | Critical when updating pricing logic or adding new features to billing system |\n| **A/B testing** | Comparing different pricing strategies or billing flows to optimize conversion and retention | Requires careful implementation to avoid billing inconsistencies or customer confusion |\n| **canary deployment** | Gradual rollout of billing system changes to detect issues before full deployment | Essential for billing systems where bugs can cause widespread customer impact |\n| **synthetic monitoring** | Automated testing of critical billing workflows in production to detect issues quickly | Includes test transactions, payment processing, and webhook delivery validation |\n| **data quality monitoring** | Continuous validation of billing data accuracy and consistency | Detects issues like duplicate charges, missing usage events, or calculation errors |\n| **reconciliation testing** | Comparing system calculations with external sources to ensure accuracy | Includes payment gateway reconciliation, usage source validation, and tax calculation verification |\n| **boundary testing** | Validating system behavior at edge cases like month boundaries, leap years, and timezone changes | Critical for billing systems where edge cases can cause calculation errors or service disruptions |\n\n### Implementation Guidance\n\nThis implementation section provides practical resources for maintaining consistent terminology and building shared understanding across your billing system team.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Terminology Management | Shared Markdown glossary in repository | Confluence or Notion with search and cross-references |\n| Code Documentation | Inline comments with term definitions | Generated API documentation with glossary links |\n| Team Communication | Slack channel for terminology questions | Dedicated wiki with examples and usage guidelines |\n| Customer Communication | Simple glossary page on website | Interactive help system with contextual definitions |\n\n#### Recommended File Structure\n\n```\nproject-root/\n  docs/\n    glossary.md                    ← comprehensive term definitions\n    terminology-guide.md           ← usage guidelines for team\n    customer-glossary.md          ← customer-facing definitions\n  src/\n    shared/\n      types/\n        billing_types.py          ← standardized type definitions\n        money.py                  ← Money type with precise arithmetic\n      constants/\n        billing_constants.py      ← standard enum values and constants\n      exceptions/\n        billing_exceptions.py     ← standardized error types\n```\n\n#### Terminology Validation Tools\n\n**Automated Terminology Checker:**\n```python\nclass TerminologyValidator:\n    \"\"\"Validates consistent term usage across codebase and documentation.\"\"\"\n    \n    def __init__(self, glossary_path: str):\n        # TODO: Load glossary terms and approved aliases\n        # TODO: Build term validation rules and patterns\n        # TODO: Initialize spell checker with billing vocabulary\n        pass\n    \n    def validate_code_comments(self, file_path: str) -> List[ValidationResult]:\n        \"\"\"Check code comments for consistent terminology usage.\"\"\"\n        # TODO: Parse code comments and docstrings\n        # TODO: Check against glossary terms and flag inconsistencies\n        # TODO: Suggest correct terms for common misspellings\n        # TODO: Return validation results with line numbers and suggestions\n        pass\n    \n    def validate_documentation(self, doc_path: str) -> List[ValidationResult]:\n        \"\"\"Check documentation for terminology consistency.\"\"\"\n        # TODO: Parse markdown/text content\n        # TODO: Identify billing terminology usage\n        # TODO: Flag undefined terms or inconsistent usage\n        # TODO: Suggest approved alternatives from glossary\n        pass\n```\n\n**Team Communication Templates:**\n\n```python\n# Standard comment template for complex billing logic\n\"\"\"\nCalculates proration for subscription plan changes.\n\nBilling Terms:\n- proration: partial charge calculation for mid-cycle changes  \n- usage factor: fraction of billing cycle remaining\n- billing anchor: fixed day for recurring subscription charges\n\nArgs:\n    old_plan: Current subscription plan with pricing\n    new_plan: Target plan for upgrade/downgrade\n    change_date: When plan change becomes effective\n    \nReturns:\n    ProrationResult with charge_amount, credit_amount, net_amount\n    \nInvariants:\n    - Maintains proration symmetry (upgrade then downgrade nets zero)\n    - Preserves billing anchor date throughout plan changes\n\"\"\"\n```\n\n#### Common Terminology Mistakes\n\n⚠️ **Pitfall: Inconsistent Money Terminology**\nTeams often mix \"amount,\" \"price,\" and \"cost\" inconsistently. Establish clear conventions: use \"amount\" for customer-owed money, \"price\" for plan rates, and \"cost\" for business expenses. This prevents confusion in code reviews and customer communication.\n\n⚠️ **Pitfall: Overloaded State Terms** \nTerms like \"active,\" \"enabled,\" and \"running\" get used interchangeably for subscription states. Use the exact `SubscriptionStatus` enum values (`active`, `past_due`, `cancelled`) consistently across all contexts to prevent state machine bugs.\n\n⚠️ **Pitfall: Vague Usage Terminology**\nDistinguishing between \"usage events,\" \"usage metrics,\" and \"usage aggregations\" is critical for usage-based billing. Usage events are raw activity records, metrics are measurable quantities, and aggregations are billing-period summaries.\n\n#### Milestone Checkpoints\n\n**Terminology Consistency Validation:**\n- Run terminology checker across codebase: `python scripts/check_terminology.py`\n- Expected: No inconsistent term usage, all billing terms match glossary\n- Manual verification: Code reviews should reference specific glossary terms\n- Signs of issues: Mixed terminology in related functions, undefined terms in comments\n\n**Customer-Facing Language Validation:**  \n- Review API error messages and documentation for consistent terminology\n- Expected: All customer communications use approved terms from customer glossary\n- Manual verification: Support team can explain any billing term using glossary definitions\n- Signs of issues: Customer questions about unclear billing terminology\n\nThis comprehensive glossary serves as the authoritative reference for all billing system terminology. Teams should reference it during code reviews, architectural discussions, and customer communication to maintain consistency and clarity throughout the system lifecycle.\n"}