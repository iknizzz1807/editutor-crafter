{"html":"<h1 id=\"-project-charter-virtual-memory-simulator\">ğŸ¯ Project Charter: Virtual Memory Simulator</h1>\n<h2 id=\"what-you-are-building\">What You Are Building</h2>\n<p>A software-based Memory Management Unit (MMU) simulator that emulates the hardware-software contract of modern memory management. You are building a system that decomposes 32-bit virtual addresses, performs hierarchical page table walks starting from a simulated CR3 register, caches translations in an ASID-tagged TLB, and manages a finite physical frame pool by evicting pages to a simulated swap store. By the end, you will have a tool that processes memory access traces and generates detailed performance profiles for different page replacement heuristics.</p>\n<h2 id=\"why-this-project-exists\">Why This Project Exists</h2>\n<p>Virtual memory is the &quot;magic&quot; that allows a 10GB process to run on 8GB of RAM while remaining isolated from other programs. Most developers treat this as a black box provided by the OS, but building a simulator from scratch exposes the exact bit-level mechanicsâ€”such as why the &quot;dirty bit&quot; is critical for disk I/O efficiency and why hierarchical tables are the only way to manage sparse address spaces without wasting gigabytes of metadata.</p>\n<h2 id=\"what-you-will-be-able-to-do-when-done\">What You Will Be Able to Do When Done</h2>\n<ul>\n<li><strong>Decompose Addresses:</strong> Use bitwise shifts and masks to extract VPNs, Page Directory Indices, and offsets for 10-10-12 bit splits.</li>\n<li><strong>Implement Caching:</strong> Build a fully-associative TLB with LRU/Random eviction and Address Space ID (ASID) support for fast context switching.</li>\n<li><strong>Walk Hierarchical Tables:</strong> Implement a radix-trie-based page table walk that allocates second-level tables on demand.</li>\n<li><strong>Manage Scarcity:</strong> Build an eviction engine that handles the full coherence lifecycle: Dirty Write-back -&gt; TLB Invalidation -&gt; PTE Clear -&gt; Frame Reclamation.</li>\n<li><strong>Perform Comparative Analysis:</strong> Mathematically prove BÃ©lÃ¡dyâ€™s Anomaly using FIFO and compare it against LRU and Optimal (future-knowledge) algorithms.</li>\n</ul>\n<h2 id=\"final-deliverable\">Final Deliverable</h2>\n<p>A command-line simulator (implemented in C, Rust, or Python) consisting of ~1,500â€“2,500 lines of code. It accepts a memory access trace file (e.g., <code>R 0x4B00</code>) and a configuration (frame count, TLB size). It outputs a physical address for every access and a final report including TLB hit rates, page fault counts, dirty page write-back counts, and peak working set size.</p>\n<h2 id=\"is-this-project-for-you\">Is This Project For You?</h2>\n<p><strong>You should start this if you:</strong></p>\n<ul>\n<li>Are comfortable with bitwise operations (AND, OR, XOR, SHL, SHR).</li>\n<li>Understand pointers and multi-level indirection (pointers-to-pointers).</li>\n<li>Can implement basic data structures like linked lists or circular buffers.</li>\n<li>Want to understand how OS kernels and CPU hardware interact at the boundary.</li>\n</ul>\n<p><strong>Come back after you&#39;ve learned:</strong></p>\n<ul>\n<li><a href=\"https://www.khanacademy.org/math/algebra-home/alg-intro-to-algebra/algebra-alternate-number-bases/v/number-bases\">Binary and Hexadecimal Arithmetic</a></li>\n<li><a href=\"https://en.cppreference.com/w/c/language/struct\">Basic C Memory Management/Structs</a></li>\n</ul>\n<h2 id=\"estimated-effort\">Estimated Effort</h2>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Time</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single-Level Page Table &amp; Translation</td>\n<td>~5 hours</td>\n</tr>\n<tr>\n<td>TLB with ASID &amp; LRU Eviction</td>\n<td>~7 hours</td>\n</tr>\n<tr>\n<td>Multi-Level Page Tables &amp; CR3 Simulation</td>\n<td>~8 hours</td>\n</tr>\n<tr>\n<td>Page Replacement (FIFO, LRU, Clock, Optimal) &amp; Swap</td>\n<td>~12 hours</td>\n</tr>\n<tr>\n<td><strong>Total</strong></td>\n<td><strong>~32 hours</strong></td>\n</tr>\n</tbody></table>\n<h2 id=\"definition-of-done\">Definition of Done</h2>\n<p>The project is complete when:</p>\n<ul>\n<li>The simulator correctly translates 32-bit addresses using a two-level hierarchy without memory leaks.</li>\n<li>TLB hits are verified to skip the page table walk and correctly differentiate between ASIDs.</li>\n<li>Reaching the physical frame limit (e.g., 64 frames) triggers a replacement algorithm instead of an OOM error.</li>\n<li>Dirty pages are successfully written to simulated swap and reloaded with data integrity on subsequent faults.</li>\n<li>The simulator can run the same trace through all four replacement policies and output a comparative performance table.</li>\n</ul>\n<hr>\n<h1 id=\"virtual-memory-simulator\">Virtual Memory Simulator</h1>\n<p>This project builds a complete virtual memory simulator from the ground up: starting with flat page tables and address translation, layering on TLB caching with ASID support, evolving to multi-level hierarchical page tables with a simulated CR3 register, and culminating in page replacement algorithms (FIFO, LRU, Clock, Optimal) backed by simulated swap space. The simulator processes memory access trace files, enabling reproducible experiments and comparative analysis of different policies.</p>\n<p>By building each layer yourself, you internalize the hardwareâ€“software contract that every modern OS relies on: how a 64-bit virtual address becomes a physical frame lookup through multiple levels of indirection, why TLBs are the single most performance-critical cache in any CPU, and why page replacement policy choice can mean the difference between smooth execution and catastrophic thrashing. Every struct you define mirrors real hardware registers and table entries â€” the PTE flags, the CR3 register, the TLB tags â€” giving you a mental model that transfers directly to reading Linux kernel source or debugging production memory pressure issues.</p>\n<p>The simulator is driven by trace files (e.g., &#39;R 0x1A3F&#39;, &#39;W 0x4B00&#39;), making it easy to construct adversarial access patterns that expose BÃ©lÃ¡dy&#39;s anomaly, demonstrate working set dynamics, and measure the true cost of dirty page write-backs. Statistics collection at every layer (TLB hits, page faults, protection faults, swap I/O) turns abstract OS textbook concepts into measurable, comparable numbers.</p>\n<!-- MS_ID: virtual-memory-sim-m1 -->\n<h1 id=\"milestone-1-single-level-page-table-and-address-translation\">Milestone 1: Single-Level Page Table and Address Translation</h1>\n<h2 id=\"the-problem-you39re-actually-solving\">The Problem You&#39;re Actually Solving</h2>\n<p>Before you write a single line of code, you need to feel the problem physically.\nYour CPU executes instructions that reference memory addresses. A program running on your machine will freely use address <code>0x00401000</code>, another program will also use <code>0x00401000</code>, and both programs are running <em>simultaneously</em>. Yet they cannot be reading from or writing to the same physical memory â€” that would be catastrophic. How does the hardware and OS ensure that these two programs&#39; identical addresses refer to completely different physical locations?\nThe answer is <strong>virtual memory</strong>: every process lives in its own private address space, and a mapping layer translates those private (virtual) addresses into actual (physical) memory locations before any real hardware access occurs.</p>\n<blockquote>\n<p><strong>ğŸ”‘ Foundation: Virtual vs Physical addresses</strong></p>\n<p><strong>1. What it IS</strong>\nA <strong>physical address</strong> is the actual hardware location in your RAM sticks (e.g., &quot;Row 402, Column 12&quot;). A <strong>virtual address</strong> is an alias or &quot;fake&quot; address used by a program. When a program asks to read memory at address <code>0x1234</code>, it is using a virtual address. The hardware&#39;s Memory Management Unit (MMU) uses a lookup table to translate that virtual <code>0x1234</code> into a real physical address like <code>0x88AF</code>.</p>\n</blockquote>\n<p><strong>2. Why you need it right now</strong>\nWithout this distinction, every program would have to manage its own physical RAM. If two programs tried to use physical address <code>0x500</code>, they would crash into each other. Virtual addressing allows the OS to give every process the illusion that it has its own private, continuous block of memory starting from zero, regardless of where that data actually sits in the physical hardware.</p>\n<p><strong>3. Key Insight</strong>\n<strong>The &quot;Coordinate System&quot; Model:</strong> Think of a virtual address like a &quot;Seat Number&quot; on a concert ticket (e.g., Row A, Seat 1). The physical address is the GPS coordinate of that actual chair. The ticket stays the same for the guest, but the venue staff (the OS) can move the actual chairs around between shows without the guest ever knowing.</p>\n<p>That translation layer is the <strong>page table</strong>. In this milestone, you&#39;ll build the simplest possible version â€” a flat, single-level array â€” and in doing so you&#39;ll internalize the insight that makes all virtual memory systems work: <strong>you don&#39;t translate bytes, you translate pages</strong>.</p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-satellite-map.svg\" alt=\"Virtual Memory Simulator â€” Satellite System Map\"></p>\n<hr>\n<h2 id=\"the-revelation-you-don39t-look-up-addresses-you-decompose-them\">The Revelation: You Don&#39;t Look Up Addresses â€” You Decompose Them</h2>\n<p>Here&#39;s the misconception most programmers carry when they first encounter page tables: they picture a lookup table like a dictionary. Virtual address goes in. Physical address comes out. The table has one entry per byte (or word) of memory.\nThat model is wrong, and the wrongness matters for everything you&#39;re about to build.\nConsider a 32-bit address space: 2Â³Â² = 4,294,967,296 possible byte addresses. If you stored one entry per byte, even a single process would need 4 billion table entries. With 8 bytes per entry, that&#39;s 32 GB of page table â€” <em>just for the mapping structure</em> â€” before you&#39;ve stored a single byte of actual program data. This is obviously impossible.\nThe actual insight is this: <strong>memory is organized into fixed-size chunks called pages</strong> (typically 4KB = 4096 bytes), and translation only applies at page granularity. The bottom 12 bits of any address â€” the <em>offset within the page</em> â€” are the same in both the virtual and physical worlds. They pass through the translation unchanged.\n[[EXPLAIN:page-size-and-address-decomposition-(vpn-+-offset-via-bit-shifting)|Page size and address decomposition â€” how VPN and offset are extracted via bit shifting, and why the math works]]\nLet&#39;s make this concrete. Suppose your virtual address is <code>0x001A3F7C</code>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Binary:  0000 0000 0001 1010 0011 1111 0111 1100\n                   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                        VPN = 0x1A3F    offset = 0x07C (20 bits VPN, 12 bits offset)</code></pre></div>\n<p>Wait â€” those bit widths depend on your configuration. With 4KB pages:</p>\n<ul>\n<li>Page size = 4096 = 2Â¹Â²</li>\n<li>Offset field = 12 bits (bottom 12 bits)</li>\n<li>VPN field = remaining upper bits\nFor a 32-bit address: VPN = bits [31:12], offset = bits [11:0].\nThe page table stores exactly one entry <em>per page</em>, not per byte. A 32-bit address space with 4KB pages has 2Â³Â²/2Â¹Â² = 2Â²â° = 1,048,576 possible pages. Your page table needs at most ~1 million entries. At, say, 4 bytes per entry, that&#39;s 4 MB â€” manageable for a single process.\nTranslation is now an <em>array index</em>, not a search:</li>\n</ul>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>physical_address = page_table[VPN].frame_number &lt;&lt; 12 | offset</code></pre></div>\n<p>This is why hardware can perform translation in a single clock cycle (given the right caching, which you&#39;ll build in Milestone 2). It&#39;s not scanning anything â€” it&#39;s computing an array index from the address bits, and reading from that array slot.</p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m1-address-decomposition.svg\" alt=\"Virtual Address Decomposition: VPN + Offset\"></p>\n<hr>\n<h2 id=\"the-page-table-entry-every-bit-earns-its-place\">The Page Table Entry: Every Bit Earns Its Place</h2>\n<p>A Page Table Entry (PTE) is the fundamental data structure of virtual memory. It&#39;s not just a &quot;physical frame number.&quot; It carries metadata that the OS and hardware use to enforce protection, track usage, manage eviction, and detect faults. Every bit has a specific job.</p>\n<blockquote>\n<p><strong>ğŸ”‘ Foundation: What a Page Table Entry contains and why each flag exists</strong></p>\n<p><strong>1. What it IS</strong>\nA Page Table Entry (PTE) is a single record in the OS&#39;s &quot;translation dictionary.&quot; It doesn&#39;t just store the mapping from virtual to physical; it stores metadata flags that tell the CPU what is allowed:</p>\n</blockquote>\n<ul>\n<li><strong>Valid/Present Bit:</strong> Is this page actually in RAM right now? If 0, accessing it triggers a page fault.</li>\n<li><strong>Permission Bits (R/W/X):</strong> Can the program Read, Write, or Execute code on this page? This prevents a program from accidentally overwriting its own code.</li>\n<li><strong>Dirty Bit:</strong> Has the program written to this page since it was loaded? If &quot;dirty,&quot; the OS must save it to disk before reusing the RAM for something else.</li>\n<li><strong>Referenced/Accessed Bit:</strong> Has this page been touched recently? The OS uses this to decide which pages are &quot;old&quot; and safe to swap out when RAM gets full.</li>\n</ul>\n<p><strong>2. Why you need it right now</strong>\nWhen you are implementing memory management or debugging &quot;Segmentation Faults,&quot; you are interacting with these flags. A &quot;Segfault&quot; is often just the MMU seeing a PTE where the &quot;Valid&quot; bit is 1, but the &quot;Write&quot; bit is 0, while the program is trying to perform a write.</p>\n<p><strong>3. Key Insight</strong>\n<strong>The &quot;Passport Control&quot; Model:</strong> A PTE isn&#39;t just a map; itâ€™s a security checkpoint. The CPU doesn&#39;t just ask &quot;Where is this data?&quot;; it asks &quot;Am I allowed to be here, and should I tell the OS I moved the furniture (Dirty bit)?&quot;</p>\n<p>Here&#39;s the PTE structure you&#39;ll implement:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Page Table Entry (PTE) â€” 32-bit layout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Byte offsets:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [31:12] â€” Physical Frame Number (PFN): 20 bits (for 4KB pages, 32-bit phys addr)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [11:8]  â€” Reserved / future use: 4 bits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [7]     â€” Referenced bit (R): set on any access (read or write)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [6]     â€” Dirty bit (D): set only on write access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [5]     â€” Read permission (R_PERM): page may be read</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [4]     â€” Write permission (W_PERM): page may be written</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [3:1]   â€” Reserved: 3 bits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [0]     â€” Valid bit (V): 1 = page is in physical memory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Total size: 4 bytes per PTE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Cache line holds: 64 / 4 = 16 PTEs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pfn        : </span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Physical Frame Number */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> _reserved2 :  </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> referenced :  </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Set on any access */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> dirty      :  </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Set on write access only */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> perm_read  :  </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Read permission */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> perm_write :  </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Write permission */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> _reserved1 :  </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> valid      :  </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Is this page in physical memory? */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">pte_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n<blockquote>\n<p><strong>Hardware Soul â€” Cache Line Analysis:</strong>\nA <code>pte_t</code> is 4 bytes. A CPU cache line is 64 bytes. Walking through 16 consecutive PTEs (16 Ã— 4 = 64 bytes) fits in a single cache line fetch. This is deliberate: when you access page N and then page N+1, both their PTEs likely live in the same cache line, making sequential access patterns warm in L1 cache. When you scatter accesses randomly across the address space â€” different VPNs far apart â€” you thrash the cache with cold PTE fetches. <strong>Page locality in the virtual address space directly translates to cache locality in the page table array.</strong> This is a fundamental law you&#39;ll observe in your simulator&#39;s statistics.</p>\n</blockquote>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m1-pte-struct-layout.svg\" alt=\"Page Table Entry (PTE) Structure â€” Byte-Level Layout\"></p>\n<h3 id=\"alternative-using-a-plain-uint32_t-with-masks\">Alternative: Using a Plain <code>uint32_t</code> with Masks</h3>\n<p>C bitfields are convenient but have implementation-defined behavior (bit ordering across compilers). For clarity and portability, many OS implementations prefer explicit masks:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/* Alternative: plain uint32_t with explicit bit masks */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#79B8FF\"> pte_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_VALID</span><span style=\"color:#E1E4E8\">       (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_PERM_WRITE</span><span style=\"color:#E1E4E8\">  (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_PERM_READ</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_DIRTY</span><span style=\"color:#E1E4E8\">       (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_REFERENCED</span><span style=\"color:#E1E4E8\">  (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_PFN_SHIFT</span><span style=\"color:#79B8FF\">   12</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_PFN_MASK</span><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FFFFF000</span><span style=\"color:#F97583\">u</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  /* bits [31:12] */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Extract PFN from a PTE */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> pte_get_pfn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">pte_t</span><span style=\"color:#FFAB70\"> pte</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_PFN_MASK) </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> PTE_PFN_SHIFT;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Build a PTE from a PFN and permission flags */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#79B8FF\"> pte_t</span><span style=\"color:#B392F0\"> pte_make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> pfn</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> readable</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> writable</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (pfn </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> PTE_PFN_SHIFT);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (readable)  p </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_PERM_READ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (writable)  p </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_PERM_WRITE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    p </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_VALID;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> p;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"design-choice-for-your-simulator-the-bitfield-struct-is-more-readable-for-learning-purposes-use-it-unless-you-run-into-compiler-issues-in-which-case-switch-to-the-mask-approach-real-kernels-like-linux-use-macro-based-masks-_page_present-_page_dirty-_page_accessed-etc-defined-in-archx86includeasmpgtableh\"><strong>Design choice for your simulator:</strong> The bitfield struct is more readable for learning purposes. Use it unless you run into compiler issues, in which case switch to the mask approach. Real kernels like Linux use macro-based masks (<code>_PAGE_PRESENT</code>, <code>_PAGE_DIRTY</code>, <code>_PAGE_ACCESSED</code>, etc.) defined in <code>arch/x86/include/asm/pgtable.h</code>.</h2>\n<h2 id=\"the-full-simulator-data-model\">The Full Simulator Data Model</h2>\n<p>Before implementing any behavior, define the complete in-memory state of your simulator. This is architectural decision-making â€” get the structure right and everything else follows.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdbool.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Configuration â€” adjustable at compile time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_SIZE</span><span style=\"color:#79B8FF\">           4096</span><span style=\"color:#F97583\">u</span><span style=\"color:#6A737D\">       /* bytes â€” must be power of 2        */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_OFFSET_BITS</span><span style=\"color:#79B8FF\">    12</span><span style=\"color:#F97583\">u</span><span style=\"color:#6A737D\">         /* log2(PAGE_SIZE) = 12              */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_OFFSET_MASK</span><span style=\"color:#E1E4E8\">    (PAGE_SIZE </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  /* 0x00000FFF                  */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> NUM_FRAMES</span><span style=\"color:#79B8FF\">          64</span><span style=\"color:#F97583\">u</span><span style=\"color:#6A737D\">         /* physical frames in simulated RAM  */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ADDR_BITS</span><span style=\"color:#79B8FF\">           32</span><span style=\"color:#F97583\">u</span><span style=\"color:#6A737D\">         /* simulated virtual address width   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> VPN_BITS</span><span style=\"color:#E1E4E8\">            (ADDR_BITS </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> PAGE_OFFSET_BITS)</span><span style=\"color:#6A737D\">  /* 20 bits       */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_TABLE_SIZE</span><span style=\"color:#E1E4E8\">     (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> VPN_BITS)</span><span style=\"color:#6A737D\">  /* 2^20 = 1,048,576 entries   */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Physical memory simulation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  data</span><span style=\"color:#E1E4E8\">[PAGE_SIZE];</span><span style=\"color:#6A737D\">   /* simulated page content (all zeros on alloc) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\">     in_use;</span><span style=\"color:#6A737D\">            /* is this frame currently allocated?          */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">physical_frame_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Page table â€” flat array of NUM_FRAMES PTEs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Memory cost: 1,048,576 Ã— 4 bytes = 4 MB per process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#FFAB70\">   entries</span><span style=\"color:#E1E4E8\">[PAGE_TABLE_SIZE];</span><span style=\"color:#6A737D\">   /* indexed directly by VPN           */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Simulator state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#E1E4E8\">    page_table;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    physical_frame_t</span><span style=\"color:#FFAB70\"> frames</span><span style=\"color:#E1E4E8\">[NUM_FRAMES];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Statistics */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    total_accesses;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    page_faults;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    protection_faults;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Configuration */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">    page_size;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">    offset_bits;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">    num_frames;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">simulator_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n<p><strong>Memory layout analysis:</strong></p>\n<ul>\n<li><code>page_table.entries</code>: 1,048,576 Ã— 4 bytes = <strong>4,194,304 bytes = 4 MB</strong></li>\n<li><code>frames[64]</code>: 64 Ã— 4096 bytes = <strong>262,144 bytes = 256 KB</strong></li>\n<li>Total simulator state: ~4.25 MB\nThis 4 MB flat page table is the key motivator for Milestone 3. For a <em>sparse</em> address space â€” a real process that uses only a few hundred MB out of the possible 4 GB â€” most of those 1M entries are unused, yet you&#39;ve paid for all of them upfront. Multi-level page tables fix this by only allocating the sub-tables you actually use.</li>\n</ul>\n<hr>\n<h2 id=\"address-decomposition-the-two-extractors\">Address Decomposition: The Two Extractors</h2>\n<p>Implement two inline functions that you&#39;ll call everywhere:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Extract the Virtual Page Number from a 32-bit virtual address.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * VPN = upper (32 - 12) = 20 bits.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Example: addr = 0x001A3F7C</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   0x001A3F7C >> 12 = 0x001A3   = 6723 (decimal)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> vpn_from_addr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> vaddr </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> PAGE_OFFSET_BITS;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Extract the page offset from a 32-bit virtual address.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Offset = lower 12 bits = unchanged in physical address.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Example: addr = 0x001A3F7C</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   0x001A3F7C &#x26; 0x00000FFF = 0x7C = 124 (decimal)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> offset_from_addr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> vaddr </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PAGE_OFFSET_MASK;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Reconstruct a physical address from a PFN and offset.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Physical address = PFN * PAGE_SIZE + offset</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *                  = (PFN &#x3C;&#x3C; 12) | offset</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> make_physical_addr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> pfn</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> offset</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (pfn </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> PAGE_OFFSET_BITS) </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> offset;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Let&#39;s verify these functions are correct by tracing through manually:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Virtual address:  0x001A3F7C\nBinary:           0000 0000 0001 1010 0011 1111 0111 1100\n                  â†‘â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†‘ â†‘â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†‘\n                              bits [31:12]                bits [11:0]\nVPN  = 0x001A3F7C &gt;&gt; 12  = 0x001A3   = 6723\nOffset = 0x001A3F7C &amp; 0xFFF = 0x7C   = 124\nIf page table says VPN 6723 â†’ PFN 42:\nPhysical address = (42 &lt;&lt; 12) | 0x7C\n                 = 0x0002A000 | 0x7C\n                 = 0x0002A07C</code></pre></div>\n<p><strong>Pitfall: Off-by-one in shift amount.</strong> PAGE_SIZE = 4096 = 2Â¹Â². To extract the VPN, you shift right by 12. A common mistake is shifting by 11 (thinking &quot;4096 has 12 digits in binary, so shift by 11&quot;). Check: <code>1 &lt;&lt; 12 = 4096</code>. Shift by 12, not 11.</p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m1-flat-page-table-lookup.svg\" alt=\"Flat Page Table Lookup â€” Data Walk\"></p>\n<hr>\n<h2 id=\"the-trace-file-your-simulator39s-input\">The Trace File: Your Simulator&#39;s Input</h2>\n<p>The simulator is driven by a <strong>memory access trace</strong> â€” a text file describing a sequence of memory operations. This indirection is the entire reason the simulator is useful: you can craft specific access patterns, replay real program traces, and run the same sequence through multiple algorithms (in later milestones) for direct comparison.</p>\n<h3 id=\"trace-format\">Trace Format</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># Lines starting with '#' are comments â€” ignore them\n# Format: &lt;operation&gt; &lt;hex-address&gt;\n# Operation: R = read, W = write\nR 0x001A3F7C\nW 0x004B0020\nR 0x001A4000\nW 0x001A3F7C\nR 0x00FF1234</code></pre></div>\n<p>Rules:</p>\n<ul>\n<li>One access per line</li>\n<li><code>R</code> = read access, <code>W</code> = write access</li>\n<li>Address is a 32-bit hex value with <code>0x</code> prefix</li>\n<li>Empty lines and comment lines (starting with <code>#</code>) are skipped</li>\n</ul>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m1-trace-format-and-flow.svg\" alt=\"Trace File Format and Simulator Pipeline\"></p>\n<h3 id=\"trace-parser\">Trace Parser</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Memory access record â€” parsed from one trace file line</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> { ACCESS_READ </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, ACCESS_WRITE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#79B8FF\">access_type_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    access_type_t</span><span style=\"color:#E1E4E8\">   type;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">        vaddr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">mem_access_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Parse a single line from the trace file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns true if parsing succeeded, false if line should be skipped</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * (comment, empty, or malformed).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Line format: \"R 0x001A3F7C\\n\" or \"W 0x004B0020\\n\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> parse_trace_line</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">line</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">out</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Skip whitespace-only and comment lines */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">p </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> ' '</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) p</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">p </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '#'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\"> op;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\"> addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">sscanf</span><span style=\"color:#E1E4E8\">(p, </span><span style=\"color:#9ECBFF\">\" </span><span style=\"color:#79B8FF\">%c</span><span style=\"color:#79B8FF\"> %lx</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">op, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">addr) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\">      (op </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'R'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> op </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'r'</span><span style=\"color:#E1E4E8\">) out->type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ACCESS_READ;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (op </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'W'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> op </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'w'</span><span style=\"color:#E1E4E8\">) out->type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#F97583\"> return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    out->vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)addr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Open trace file and count entries â€” used to pre-allocate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * the access array for Optimal (BÃ©lÃ¡dy's) algorithm in Milestone 4.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> load_trace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">mem_access_t</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">out_accesses</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">out_count</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FILE </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">fp </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fopen</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#9ECBFF\">\"r\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">fp) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fopen\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> capacity </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> count    </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">accesses </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">mem_access_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">accesses) { </span><span style=\"color:#B392F0\">fclose</span><span style=\"color:#E1E4E8\">(fp); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">fgets</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(line), fp)) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        mem_access_t</span><span style=\"color:#E1E4E8\"> access;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">parse_trace_line</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">access)) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (count </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> capacity) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            capacity </span><span style=\"color:#F97583\">*=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">tmp </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> realloc</span><span style=\"color:#E1E4E8\">(accesses, capacity </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">mem_access_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">tmp) { </span><span style=\"color:#B392F0\">free</span><span style=\"color:#E1E4E8\">(accesses); </span><span style=\"color:#B392F0\">fclose</span><span style=\"color:#E1E4E8\">(fp); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            accesses </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tmp;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        accesses</span><span style=\"color:#E1E4E8\">[count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> access;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fclose</span><span style=\"color:#E1E4E8\">(fp);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">out_accesses </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> accesses;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">out_count    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"the-two-failure-modes-page-fault-vs-protection-fault\">The Two Failure Modes: Page Fault vs Protection Fault</h2>\n<p>When address translation is attempted, one of three things happens:</p>\n<ol>\n<li><strong>Success</strong>: The PTE is valid and permissions match â†’ return physical address</li>\n<li><strong>Page fault</strong>: The PTE&#39;s <code>valid</code> bit is 0 â†’ page is not in memory</li>\n<li><strong>Protection fault</strong>: The PTE&#39;s <code>valid</code> bit is 1, but the access violates permission bits\nThese are <strong>completely different conditions</strong> with different causes and different responses. Confusing them is the most common mistake in this milestone.</li>\n</ol>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m1-page-fault-vs-protection-fault.svg\" alt=\"Page Fault vs Protection Fault Decision Tree\"></p>\n<table>\n<thead>\n<tr>\n<th>Condition</th>\n<th><code>valid</code> bit</th>\n<th>Permissions</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Page fault</td>\n<td><code>0</code></td>\n<td>(doesn&#39;t matter)</td>\n<td>Load page from storage, allocate frame, retry</td>\n</tr>\n<tr>\n<td>Protection fault</td>\n<td><code>1</code></td>\n<td>Wrong</td>\n<td>Kill or signal process (or log error in simulator)</td>\n</tr>\n<tr>\n<td>Success</td>\n<td><code>1</code></td>\n<td>Correct</td>\n<td>Return physical address</td>\n</tr>\n<tr>\n<td><strong>Why valid=0 doesn&#39;t mean &quot;this page doesn&#39;t exist.&quot;</strong> A page with <code>valid=0</code> might be in swap space (evicted earlier), or simply never accessed yet (demand paging). The OS knows the difference through additional structures (the VMA â€” Virtual Memory Area â€” which describes what <em>should</em> be mapped, even if it isn&#39;t yet). In your simulator, you&#39;ll simplify this: any page not yet allocated gets demand-paged into a free frame on first access, and a write-to-unallocated page is also treated as a page fault (then the new page is also marked writable).</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"demand-paging-pages-on-demand\">Demand Paging: Pages on Demand</h2>\n<blockquote>\n<p><strong>ğŸ”‘ Foundation: Demand paging</strong></p>\n<p><strong>1. What it IS</strong>\nDemand paging is a &quot;lazy&quot; loading strategy. Instead of loading an entire 2GB application into RAM when you double-click it, the OS loads nothing. It marks all the application&#39;s pages as &quot;Not Present&quot; in the page table. When the CPU tries to run the first instruction, it failsâ€”this is a <strong>Page Fault</strong>. The <strong>Page Fault Handler</strong> (a special OS function) catches the failure, finds the data on the disk, puts it into a physical RAM slot, updates the PTE to &quot;Valid,&quot; and tells the CPU to try again.</p>\n</blockquote>\n<p><strong>2. Why you need it right now</strong>\nThis is the magic that allows you to run a 10GB game on a computer with only 8GB of RAM. It ensures that memory is only consumed for the specific parts of a program you are actually using at this moment.</p>\n<p><strong>3. Key Insight</strong>\n<strong>&quot;Just-In-Time Inventory&quot;:</strong> Demand paging is the Amazon Prime of memory. The OS doesn&#39;t keep every item in the front showroom (RAM); it keeps them in a massive warehouse (Disk) and only rushes them to the showroom the second a customer (the CPU) asks for them.</p>\n<p>The OS doesn&#39;t load your entire program into RAM when it starts. It loads a minimal amount, maps the rest as <code>valid=0</code>, and lets the hardware trigger faults as needed. This is <strong>demand paging</strong>: allocate physical memory only when it&#39;s actually demanded by a memory access.\nIn your simulator, demand paging is implemented by the page fault handler:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Allocate a free physical frame from the frame pool.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns frame number on success, or UINT32_MAX if no frames are free.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Complexity: O(NUM_FRAMES) â€” acceptable for small NUM_FRAMES.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In a real OS: maintained as a free list, O(1) allocation.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> alloc_free_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">simulator_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sim</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> sim->num_frames; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">sim->frames[i].in_use) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sim->frames[i].in_use </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Zero-initialize the frame (mimics OS security practice) */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            memset</span><span style=\"color:#E1E4E8\">(sim->frames[i].data, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, PAGE_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span><span style=\"color:#6A737D\">  /* Out of physical memory â€” will need replacement in M4 */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Page fault handler.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Called when PTE.valid == 0 for the given VPN.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   1. Find a free frame (demand paging â€” allocate lazily)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   2. \"Load\" the page (in real OS: read from disk/swap; here: zero-fill)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   3. Update the PTE: set valid=1, set PFN, set permissions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   4. Return the allocated PFN, or UINT32_MAX on OOM</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> handle_page_fault</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">simulator_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sim</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vpn</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                                  access_type_t</span><span style=\"color:#FFAB70\"> access_type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sim->page_faults</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[PAGE FAULT] VPN=0x</span><span style=\"color:#79B8FF\">%05X</span><span style=\"color:#9ECBFF\">  access=</span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            vpn, (access_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE) </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"WRITE\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"READ\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_free_frame</span><span style=\"color:#E1E4E8\">(sim);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT32_MAX) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[OOM] No free frames â€” page replacement needed (Milestone 4)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Set up the PTE for this newly allocated page.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Default permissions: readable; writable only if access is a write.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Real OS would consult the VMA to determine correct permissions. */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">sim->page_table.entries[vpn];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pte_make</span><span style=\"color:#E1E4E8\">(frame,</span><span style=\"color:#6A737D\"> /*readable=*/</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\"> /*writable=*/</span><span style=\"color:#E1E4E8\">(access_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* pte_make already sets valid=1 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> frame;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m1-demand-paging-before-after.svg\" alt=\"Demand Paging: Before and After a Page Fault\"></p>\n<h2 id=\"security-note-the-memsetframedata-0-page_size-call-is-not-just-housekeeping-it39s-a-security-requirement-if-the-os-reuses-frames-without-zeroing-them-a-new-process-could-read-data-left-behind-by-a-previous-process-linux-zeroes-pages-before-handing-them-to-userspace\"><strong>Security note:</strong> The <code>memset(frame.data, 0, PAGE_SIZE)</code> call is not just housekeeping â€” it&#39;s a security requirement. If the OS reuses frames without zeroing them, a new process could read data left behind by a previous process. Linux zeroes pages before handing them to userspace.</h2>\n<h2 id=\"the-core-translation-function\">The Core Translation Function</h2>\n<p>Now assemble the address translation logic. This function is the heart of your simulator â€” every access flows through it.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Result of an address translation attempt.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    XLATE_SUCCESS    </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    XLATE_PAGE_FAULT </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    XLATE_PROT_FAULT </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    XLATE_OOM        </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   /* page fault but no free frames */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">xlate_result_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    xlate_result_t</span><span style=\"color:#E1E4E8\">  result;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">        paddr;</span><span style=\"color:#6A737D\">  /* valid only when result == XLATE_SUCCESS */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">        pfn;</span><span style=\"color:#6A737D\">    /* PFN assigned (after fault resolution) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Translate a virtual address, handling faults as needed.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Algorithm:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   1. Decompose vaddr into VPN and offset</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   2. Look up PTE = page_table[VPN]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   3. If !PTE.valid         â†’ page fault  â†’ handle_page_fault() â†’ retry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   4. If write &#x26;&#x26; !writable â†’ prot fault  â†’ log and return error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   5. Set PTE.referenced = 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   6. If write: set PTE.dirty = 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   7. Build and return physical address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#B392F0\"> translate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">simulator_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sim</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">access_type_t</span><span style=\"color:#FFAB70\"> access_type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sim->total_accesses</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vpn    </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> vpn_from_addr</span><span style=\"color:#E1E4E8\">(vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> offset_from_addr</span><span style=\"color:#E1E4E8\">(vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Bounds check: VPN must be within page table range */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (vpn </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> PAGE_TABLE_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[SEGFAULT] VPN 0x</span><span style=\"color:#79B8FF\">%X</span><span style=\"color:#9ECBFF\"> exceeds page table size</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, vpn);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_PROT_FAULT, .paddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">sim->page_table.entries[vpn];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Step 1: Is the page in memory?</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_VALID)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Page fault: page is not in physical memory */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> handle_page_fault</span><span style=\"color:#E1E4E8\">(sim, vpn, access_type);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT32_MAX) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_OOM };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Reload pte â€” handle_page_fault() updated it */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* (pte is a pointer into the table, so it's already updated) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Step 2: Permission check</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Only check after valid=1 is confirmed â€” checking invalid PTEs'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * permission bits is undefined (they may be garbage).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (access_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_PERM_WRITE)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sim->protection_faults</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[PROT FAULT] VPN=0x</span><span style=\"color:#79B8FF\">%05X</span><span style=\"color:#9ECBFF\"> write to read-only page</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, vpn);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_PROT_FAULT };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Step 3: Set access bits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_REFERENCED;</span><span style=\"color:#6A737D\">                          /* any access */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (access_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_DIRTY;</span><span style=\"color:#6A737D\">  /* writes only */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Step 4: Build physical address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pfn   </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pte_get_pfn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> paddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make_physical_addr</span><span style=\"color:#E1E4E8\">(pfn, offset);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_SUCCESS,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .paddr  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> paddr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .pfn    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pfn,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"critical-ordering-note-check-valid-before-checking-permissions-if-you-check-permissions-on-an-invalid-pte-you39re-reading-garbage-bits-the-pte39s-content-is-meaningless-when-valid0-the-valid-check-must-come-first-dirty-bit-discipline-only-write-accesses-set-the-dirty-bit-read-accesses-never-do-this-matters-enormously-in-milestone-4-a-dirty-page-must-be-written-to-swap-before-its-frame-can-be-reused-if-you-incorrectly-set-dirty-on-reads-you39ll-cause-unnecessary-swap-writes-inflating-your-swap-write-back-statistics\"><strong>Critical ordering note:</strong> Check <code>valid</code> before checking permissions. If you check permissions on an invalid PTE, you&#39;re reading garbage bits â€” the PTE&#39;s content is meaningless when <code>valid=0</code>. The valid check must come first.\n<strong>Dirty bit discipline:</strong> Only write accesses set the dirty bit. Read accesses never do. This matters enormously in Milestone 4: a dirty page must be written to swap before its frame can be reused. If you incorrectly set dirty on reads, you&#39;ll cause unnecessary swap writes, inflating your swap write-back statistics.</h2>\n<h2 id=\"the-main-simulation-loop\">The Main Simulation Loop</h2>\n<p>Connect the trace parser to the translator:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Run the simulator over a loaded trace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> simulate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">simulator_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sim</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">accesses</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#79B8FF\"> mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">acc </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">accesses</span><span style=\"color:#E1E4E8\">[i];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[</span><span style=\"color:#79B8FF\">%6zu</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> 0x</span><span style=\"color:#79B8FF\">%08X</span><span style=\"color:#9ECBFF\"> â†’ \"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               i,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               acc->type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"W\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"R\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               acc->vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        xlate_t</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> translate</span><span style=\"color:#E1E4E8\">(sim, acc->vaddr, acc->type);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> (result.result) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> XLATE_SUCCESS:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"phys=0x</span><span style=\"color:#79B8FF\">%08X</span><span style=\"color:#9ECBFF\"> (PFN=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, result.paddr, result.pfn);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> XLATE_PAGE_FAULT:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* Page fault was handled inside translate(); this shouldn't occur */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PAGE FAULT (unresolved)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> XLATE_PROT_FAULT:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PROTECTION FAULT</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> XLATE_OOM:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"OUT OF MEMORY (no free frames)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Print final statistics.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> print_stats</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> simulator_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sim</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">=== Simulation Statistics ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Total accesses:     </span><span style=\"color:#79B8FF\">%lu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, sim->total_accesses);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Page faults:        </span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\">  (</span><span style=\"color:#79B8FF\">%.2f%%</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           sim->page_faults,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           sim->total_accesses </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               ?</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> sim->page_faults </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> sim->total_accesses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               :</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Protection faults:  </span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\">  (</span><span style=\"color:#79B8FF\">%.2f%%</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           sim->protection_faults,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           sim->total_accesses </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               ?</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> sim->protection_faults </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> sim->total_accesses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               :</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Count allocated frames */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> frames_used </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> sim->num_frames; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (sim->frames[i].in_use) frames_used</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Frames in use:      </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> / </span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, frames_used, sim->num_frames);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"initializing-the-simulator\">Initializing the Simulator</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Initialize the simulator to clean state.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * All PTEs are set to 0 (valid=0, all permissions cleared).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * All frames are marked free.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> simulator_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">simulator_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sim</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(sim, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">sim));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sim->page_size   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PAGE_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sim->offset_bits </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PAGE_OFFSET_BITS;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sim->num_frames  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> NUM_FRAMES;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* page_table.entries is zeroed by memset â€” all PTEs start invalid */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* frames[i].in_use = false for all i â€” all frames start free */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Wire it all together: main entry point.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#F97583\">[]</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> &#x3C;trace-file></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    simulator_t</span><span style=\"color:#E1E4E8\"> sim;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    simulator_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">accesses </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">load_trace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">accesses, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">count) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Failed to load trace file: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Loaded </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> accesses from </span><span style=\"color:#79B8FF\">%s\\n\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, count, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    simulate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim, accesses, count);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    print_stats</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(accesses);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"building-and-testing\">Building and Testing</h2>\n<h3 id=\"compile\">Compile</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -Wall</span><span style=\"color:#79B8FF\"> -Wextra</span><span style=\"color:#79B8FF\"> -O2</span><span style=\"color:#79B8FF\"> -std=c11</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> vmsim</span><span style=\"color:#9ECBFF\"> vmsim.c</span></span></code></pre></div>\n<h3 id=\"minimal-test-trace\">Minimal test trace</h3>\n<p>Create <code>test_basic.trace</code>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># Test: basic read/write sequence\nR 0x00001000\nW 0x00001004\nR 0x00002000\nW 0x00001000</code></pre></div>\n<p>Expected output pattern:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[     0] R 0x00001000 â†’ PAGE FAULT logged, phys=0x00001000 (PFN=0)\n[     1] W 0x00001004 â†’ phys=0x00001004 (PFN=0)   [same page, dirty set]\n[     2] R 0x00002000 â†’ PAGE FAULT logged, phys=0x00011000 (PFN=1)\n[     3] W 0x00001000 â†’ phys=0x00001000 (PFN=0)   [dirty already set]</code></pre></div>\n<h3 id=\"protection-fault-test-trace\">Protection fault test trace</h3>\n<p>To test protection faults, you need a way to mark pages as read-only. Extend your trace format with a setup directive:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># Extended trace: test protection fault\n# MMAP &lt;vpn&gt; &lt;R|W|RW&gt;  â€” pre-map a page with given permissions\nMMAP 0x00001 R\nR 0x00001000   # should succeed\nW 0x00001004   # should trigger PROTECTION FAULT</code></pre></div>\n<p>Alternatively, expose a <code>simulator_mmap()</code> function and call it from a C test:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Pre-map a virtual page with specified permissions (no demand paging â€”</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * allocate a frame immediately and set the PTE directly).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Used for testing protection fault behavior.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> simulator_mmap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">simulator_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sim</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vpn</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> readable</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> writable</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (vpn </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> PAGE_TABLE_SIZE) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_free_frame</span><span style=\"color:#E1E4E8\">(sim);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT32_MAX) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* OOM */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sim->page_table.entries[vpn] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pte_make</span><span style=\"color:#E1E4E8\">(frame, readable, writable);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"common-pitfalls-and-how-to-avoid-them\">Common Pitfalls and How to Avoid Them</h2>\n<table>\n<thead>\n<tr>\n<th>Pitfall</th>\n<th>Symptom</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>vaddr &gt;&gt; 11</code> instead of <code>&gt;&gt; 12</code></td>\n<td>VPN off by factor of 2</td>\n<td>Remember: PAGE_SIZE = 2Â¹Â², shift by <strong>12</strong></td>\n</tr>\n<tr>\n<td>Checking permissions before valid</td>\n<td>Garbage perm bits on invalid PTEs</td>\n<td>Always check <code>valid</code> first</td>\n</tr>\n<tr>\n<td>Setting dirty on read</td>\n<td>Over-counting dirty pages</td>\n<td>Only `</td>\n</tr>\n<tr>\n<td>Not zeroing new frames</td>\n<td>Data leakage between &quot;processes&quot;</td>\n<td><code>memset(frame.data, 0, PAGE_SIZE)</code> on alloc</td>\n</tr>\n<tr>\n<td>Treating page fault as fatal</td>\n<td>Simulator aborts on first fault</td>\n<td>Page faults are expected â€” resolve them</td>\n</tr>\n<tr>\n<td><code>offset_mask = PAGE_SIZE</code> instead of <code>PAGE_SIZE - 1</code></td>\n<td>Wrong offset extraction</td>\n<td>Mask is <code>0xFFF</code> for 4KB pages, not <code>0x1000</code></td>\n</tr>\n<tr>\n<td>The offset mask is a particularly nasty bug. <code>PAGE_SIZE = 4096 = 0x1000</code>. The mask needs to cover bits <code>[11:0]</code> = <code>0xFFF = 4095 = PAGE_SIZE - 1</code>. Using <code>PAGE_SIZE</code> as the mask would give you <code>0x1000</code>, which in binary is <code>0001 0000 0000 0000</code> â€” completely wrong.</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"hardware-soul-what-real-hardware-does\">Hardware Soul: What Real Hardware Does</h2>\n<p>Your simulator runs <code>translate()</code> in software. Real hardware does the equivalent in silicon, in the CPU&#39;s <strong>Memory Management Unit (MMU)</strong>. Understanding the parallel deepens everything you&#39;re building:\n<strong>Real x86-64 hardware:</strong></p>\n<ul>\n<li>CR3 register holds the physical address of the top-level page table</li>\n<li>On every memory instruction, the MMU decomposes the virtual address</li>\n<li>It walks the page table hierarchy (4 levels on x86-64)</li>\n<li>If the TLB has a cached translation, the walk is skipped entirely (Milestone 2)</li>\n<li>If a PTE has <code>Present=0</code> (equivalent to your <code>valid=0</code>), the CPU raises a <strong>#PF (Page Fault) exception</strong> â€” hardware interrupt, not a function call</li>\n<li>The OS&#39;s page fault handler is invoked at interrupt priority, resolves the fault, and resumes the faulting instruction\n<strong>Cache line behavior in your simulator:</strong></li>\n<li><code>page_table.entries</code> is a contiguous array</li>\n<li>Accessing entries for VPNs 0â€“15 touches bytes 0â€“63: exactly one cache line</li>\n<li>Accessing entries for VPNs 0 and 1000 touches two cache lines 4KB apart: likely two separate L1 cache misses</li>\n<li>Your simulator with only 64 frames will mostly access a small range of VPNs â†’ page table accesses are mostly cache-warm\n<strong>TLB hardware (preview for Milestone 2):</strong></li>\n<li>Real CPUs have 64â€“2048 TLB entries that cache VPNâ†’PFN mappings</li>\n<li>A TLB hit costs ~1 cycle; a TLB miss that requires a hardware page table walk costs 4 memory accesses on x86-64 (one per level)</li>\n<li>Your software <code>translate()</code> currently does the &quot;TLB miss&quot; path every time â€” Milestone 2 caches the result</li>\n</ul>\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>You&#39;ve built a page table and implemented demand paging. Here&#39;s what you now understand that you didn&#39;t before:\n<strong>1. Why <code>malloc</code> for large allocations returns page-aligned memory</strong>\n<code>malloc</code> calls <code>mmap()</code> for large requests (typically &gt; 128KB). <code>mmap()</code> returns a page-aligned virtual address because the OS can only map, protect, and fault at page granularity. A virtual address in the middle of a page can&#39;t be given its own PTE â€” the entire page is the minimum unit. This is why <code>posix_memalign(ptr, 4096, size)</code> exists, and why database buffer pools (SQLite, PostgreSQL) align their I/O buffers to 4KB: they need exact page-boundary alignment for <code>O_DIRECT</code> (bypassing the kernel page cache) and for <code>mmap</code>-based storage access.\n<strong>2. How <code>mmap</code> can &quot;map&quot; a 10GB file with only 256MB of RAM</strong></p>\n<blockquote>\n<p><strong>ğŸ”‘ Foundation: How mmap and demand paging together enable mapping files larger than physical memory</strong></p>\n<p><strong>1. What it IS</strong>\n<code>mmap</code> is a system call that &quot;maps&quot; a file directly into a process&#39;s virtual memory space. Instead of using <code>read()</code> to copy a file into a buffer, you tell the OS: &quot;Make this 1GB file appear as if it&#39;s an array at virtual address <code>0x5000</code>.&quot; </p>\n</blockquote>\n<p>The connection to demand paging is crucial: <code>mmap</code> doesn&#39;t actually load the file into RAM. It simply creates the PTEs and marks them as &quot;Not Present,&quot; pointing them to the file on disk. The file is only loaded into RAM piece-by-piece via the Page Fault Handler as your code actually touches different parts of that &quot;array.&quot;</p>\n<p><strong>2. Why you need it right now</strong>\nIf you need to process a dataset that is larger than your available RAM, <code>mmap</code> is the solution. It lets the OS handle all the complex logic of loading, caching, and eviction. You treat the file like a giant pointer, and the demand paging system ensures only the active &quot;window&quot; of that file occupies your physical memory.</p>\n<p><strong>3. Key Insight</strong>\n<strong>The &quot;Portal&quot; Model:</strong> <code>mmap</code> creates a virtual window (the portal) into a file. Demand paging is the mechanism that actually pulls the data through that portal only when you reach out and try to touch it.</p>\n<h2 id=\"mmap-doesn39t-read-the-file-it-creates-ptes-with-valid0-that-point-to-file-offsets-instead-of-swap-when-you-touch-a-mapped-page-the-page-fault-handler-reads-exactly-that-4kb-chunk-from-disk-and-maps-it-into-a-free-frame-you39ve-just-implemented-the-core-of-this-mechanism-the-os-never-needs-more-ram-than-the-number-of-pages-simultaneously-accessed-the-working-set-3-process-isolation-is-a-page-table-not-a-byte-level-guard-every-process-has-its-own-page-table-process-a39s-vpn-0x12345-pfn-17-process-b39s-vpn-0x12345-pfn-83-the-same-virtual-address-translates-to-completely-different-physical-frames-there39s-no-per-byte-checking-no-encryption-no-copying-just-two-separate-ptes-that-happen-to-be-indexed-by-the-same-number-but-live-in-different-page-tables-memory-isolation-is-100-a-page-table-artifact-when-you-see-quotmemory-corruption-via-buffer-overflow-that-overwrites-another-process39s-memoryquot-the-reason-it-doesn39t-happen-normally-is-that-there-are-no-ptes-mapping-virtual-addresses-outside-your-process39s-allocated-regions-4-sqlite-postgresql-and-innodb-all-think-in-pages-every-relational-database-uses-page-sized-io-buffers-because-the-os39s-unit-of-transfer-between-disk-and-ram-is-exactly-one-page-4kb-postgresql39s-page-size-is-8kb-2-os-page-mysql-innodb-uses-16kb-4-os-page-their-buffer-pools-are-essentially-a-software-version-of-what-you-just-built-a-mapping-from-quotlogical-page-number-on-diskquot-to-quotframe-in-the-buffer-poolquot-with-the-same-concepts-of-valid-bits-is-this-page-currently-in-the-pool-dirty-bits-has-it-been-modified-since-last-flush-and-replacement-algorithms-lfu-clock-arc-the-os-virtual-memory-system-and-the-database-buffer-manager-are-isomorphic-designs-solving-the-same-caching-problem-at-different-layers-5-cross-domain-web-caches-and-cdns-the-page-table-is-a-cache-it-maps-virtual-addresses-to-physical-locations-handling-misses-page-faults-by-fetching-from-backing-storage-diskswap-cdns-do-the-same-they-cache-urls-physical-server-responses-handling-misses-by-fetching-from-origin-the-eviction-algorithms-you39ll-implement-in-milestone-4-lru-clock-optimal-are-exactly-the-same-algorithms-used-in-nginx39s-proxy-cache-varnish-and-cdn-edge-nodes-page-replacement-theory-is-cache-theory-the-domains-are-the-same-mathematics\"><code>mmap()</code> doesn&#39;t read the file â€” it creates PTEs with <code>valid=0</code> that point to file offsets instead of swap. When you touch a mapped page, the page fault handler reads exactly that 4KB chunk from disk and maps it into a free frame. You&#39;ve just implemented the core of this mechanism. The OS never needs more RAM than the number of pages simultaneously accessed (the working set).\n<strong>3. Process isolation is a page table, not a byte-level guard</strong>\nEvery process has its own page table. Process A&#39;s VPN 0x12345 â†’ PFN 17; Process B&#39;s VPN 0x12345 â†’ PFN 83. The same virtual address translates to completely different physical frames. There&#39;s no per-byte checking, no encryption, no copying â€” just two separate PTEs that happen to be indexed by the same number but live in different page tables. Memory isolation is 100% a page table artifact. When you see &quot;memory corruption via buffer overflow that overwrites another process&#39;s memory,&quot; the reason it <em>doesn&#39;t</em> happen normally is that there are no PTEs mapping virtual addresses outside your process&#39;s allocated regions.\n<strong>4. SQLite, PostgreSQL, and InnoDB all think in pages</strong>\nEvery relational database uses page-sized I/O buffers because the OS&#39;s unit of transfer between disk and RAM is exactly one page (4KB). PostgreSQL&#39;s page size is 8KB (2Ã— OS page); MySQL InnoDB uses 16KB (4Ã— OS page). Their buffer pools are essentially a software version of what you just built â€” a mapping from &quot;logical page number on disk&quot; to &quot;frame in the buffer pool&quot; â€” with the same concepts of valid bits (is this page currently in the pool?), dirty bits (has it been modified since last flush?), and replacement algorithms (LFU, clock, ARC). The OS virtual memory system and the database buffer manager are isomorphic designs solving the same caching problem at different layers.\n<strong>5. Cross-domain: Web caches and CDNs</strong>\nThe page table is a cache: it maps virtual addresses to physical locations, handling misses (page faults) by fetching from backing storage (disk/swap). CDNs do the same: they cache URLs â†’ physical server responses, handling misses by fetching from origin. The eviction algorithms you&#39;ll implement in Milestone 4 (LRU, Clock, Optimal) are exactly the same algorithms used in Nginx&#39;s proxy cache, Varnish, and CDN edge nodes. Page replacement theory is cache theory. The domains are the same mathematics.</h2>\n<h2 id=\"what-you39ve-built-and-what39s-missing\">What You&#39;ve Built and What&#39;s Missing</h2>\n<p><strong>You have:</strong></p>\n<ul>\n<li>A complete, working virtual memory simulator for a single process</li>\n<li>Flat page table with O(1) address translation</li>\n<li>Demand paging (pages allocated on first access)</li>\n<li>Protection fault detection</li>\n<li>Statistics collection\n<strong>What&#39;s painfully missing:</strong> Every access calls <code>translate()</code> which does a full page table lookup â€” an array read from <code>page_table.entries[vpn]</code>. In a real CPU, this requires a memory access to wherever the page table is stored. For 1M entries at 4 bytes each, the page table is 4MB â€” it doesn&#39;t fit in L1 cache (typically 32â€“64 KB). Most page table accesses are L2 or L3 misses (<del>4ns and ~40ns respectively), compared to a register access (</del>0.25ns).\nReal programs access the same pages repeatedly. The working set of a typical process is 10â€“1000 pages, not millions. If only we could <em>cache</em> the most recent VPNâ†’PFN translations...\nThat&#39;s the TLB. Milestone 2 adds it.\n<strong>Also missing:</strong> The flat page table costs 4MB per process regardless of how sparse the address space is. A process using 10 pages still needs a 1M-entry table. Milestone 3 fixes this with multi-level page tables, which only allocate table memory for regions that are actually mapped.\n<strong>And:</strong> When all 64 frames are full and a new page needs to be loaded, your current simulator simply fails. Milestone 4 adds page replacement â€” deciding which existing page to evict to make room.\nEach milestone is a direct fix for a concrete limitation you&#39;ve now felt in your implementation. That&#39;s not a coincidence â€” it&#39;s the pedagogical design of this project.</li>\n</ul>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: virtual-memory-sim-m2 -->\n<!-- MS_ID: virtual-memory-sim-m2 -->\n<h1 id=\"milestone-2-tlb-translation-lookaside-buffer\">Milestone 2: TLB (Translation Lookaside Buffer)</h1>\n<h2 id=\"the-problem-every-load-is-two-loads\">The Problem: Every Load Is Two Loads</h2>\n<p>You built a page table in Milestone 1. It works. Now run it against this trace and think carefully about what the hardware is actually doing:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>R 0x00401020\nR 0x00401024\nR 0x00401028\nR 0x0040102C</code></pre></div>\n<p>Four reads in a tight loop â€” the kind of thing a program does thousands of times per second when iterating over an array. What does your <code>translate()</code> function do for each one?</p>\n<ol>\n<li>Compute <code>VPN = vaddr &gt;&gt; 12</code></li>\n<li>Access <code>page_table.entries[VPN]</code> â€” <strong>a memory read</strong></li>\n<li>Extract the PFN from the PTE</li>\n<li>Compute <code>physical_address = (PFN &lt;&lt; 12) | offset</code></li>\n<li>Now â€” finally â€” access the data at that physical address â€” <strong>another memory read</strong>\nTwo memory reads for every single memory access. That&#39;s not a theoretical inefficiency â€” it&#39;s a concrete halving of memory bandwidth. Every array element read is secretly two reads. Every function call&#39;s stack frame access is two reads. Every pointer dereference is two reads.\nAt 3 GHz with a 100ns DRAM latency, your CPU can issue ~300 instructions in the time it takes to complete <em>one</em> memory access. Without caching, a page table lookup before every data access means your program grinds at half-speed at best â€” and for multi-level page tables (Milestone 3), it&#39;s <em>three</em> loads for every one data load. The whole system becomes a memory-latency machine.\nHere&#39;s the thing: this problem is deterministic. The same four virtual addresses in the loop above all map to the same VPN. You&#39;re performing the same page table lookup â€” fetching the same PTE â€” four consecutive times. You&#39;re paying 100ns for a lookup whose answer you already knew from the previous iteration.\n<strong>The fix is obvious once you see it: cache the last few VPNâ†’PFN translations.</strong> If you&#39;ve recently looked up VPN 0x401, don&#39;t re-read the page table â€” just return the answer you computed last time. This is the <strong>Translation Lookaside Buffer</strong> (TLB), and it is not a nice-to-have optimization. It is the entire reason virtual memory is feasible in a modern CPU.</li>\n</ol>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m2-tlb-in-translation-pipeline.svg\" alt=\"TLB Position in the Address Translation Pipeline\"></p>\n<hr>\n<h2 id=\"the-revelation-the-tlb-is-the-most-important-cache-in-your-cpu\">The Revelation: The TLB Is the Most Important Cache in Your CPU</h2>\n<p>Here&#39;s the misconception worth destroying before you write a single line of code:\n<em>&quot;The TLB is just a cache for page table entries â€” a useful optimization but fundamentally the page table is the real mechanism.&quot;</em>\nThis is wrong, and the wrongness matters for how you design your system.\nConsider what &quot;99% TLB hit rate&quot; means in practice. If your TLB has 64 entries and achieves a 99% hit rate:</p>\n<ul>\n<li>99% of memory accesses: TLB hit â†’ PFN in ~1 CPU cycle â†’ data access</li>\n<li>1% of memory accesses: TLB miss â†’ page table walk â†’ 1 memory access for single-level, 2â€“4 for multi-level â†’ <em>then</em> data access\nNow consider what 100% TLB miss rate means (no TLB at all):</li>\n<li>Every single memory access first triggers a page table walk</li>\n<li>For a two-level page table: <strong>3 memory accesses per data byte read</strong> (level-1 table, level-2 table, data)</li>\n<li>Effective memory bandwidth: 1/3 of hardware capability</li>\n<li>At 50 GB/s DRAM bandwidth: your program sees 16 GB/s</li>\n<li>Those 300 instructions you could execute in a DRAM latency window? Now you&#39;re burning 300 cycles <em>per byte read</em>\nThe TLB is the only reason virtual memory doesn&#39;t obliterate performance. Real TLBs â€” 64 to 2048 entries â€” achieve 99%+ hit rates through the same principle that makes CPU caches work: <strong>temporal and spatial locality</strong>. Programs tend to access the same pages repeatedly (temporal locality: the loop above reuses VPN 0x401 four times), and nearby addresses (spatial locality: sequential array traversal hits the same page for 4096/8 = 512 consecutive 8-byte reads).\n<strong>The TLB transforms an O(levels) memory-access translation overhead into an O(1) register lookup.</strong> This is why hardware architects gave the TLB its own special designation separate from L1/L2/L3 caches: it&#39;s a different kind of structure, fully associative, searched in parallel, and integrated so tightly with the MMU that its hit latency is often effectively zero (absorbed into the pipeline).\nYour software simulator will, of course, implement TLB lookup as regular C code â€” sequential, not parallel. But the data structures you&#39;ll build mirror the real hardware exactly, and the hit rate behavior you observe will follow the same locality principles.</li>\n</ul>\n<hr>\n<h2 id=\"what-a-tlb-entry-contains\">What a TLB Entry Contains</h2>\n<p>[[EXPLAIN:cache-concepts:-tag-matching,-hit/miss,-eviction-policies|Cache concepts: tag matching, hit/miss, eviction policies â€” how a cache determines if it holds a value and what to discard when full]]\nA TLB entry is not just <code>{vpn, pfn}</code>. It needs additional metadata to handle context switches, dirty-bit propagation, and permission checking without consulting the page table:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * TLB Entry â€” one slot in the Translation Lookaside Buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Memory layout (bytes):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [0..3]  â€” vpn:  Virtual Page Number being cached (tag for lookup)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [4..7]  â€” pfn:  Physical Frame Number (cached translation result)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [8..9]  â€” asid: Address Space ID (which process owns this entry)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [10]    â€” flags byte:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *               bit 0: valid      â€” is this entry occupied?</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *               bit 1: dirty      â€” has this page been written to?</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *               bit 2: referenced â€” has this page been accessed?</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *               bit 3: writable   â€” is this mapping writable?</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [11]    â€” lru_counter (or timestamp): for LRU eviction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Total size: 12 bytes per entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Cache line (64 bytes) holds: 5 entries (with 4 bytes wasted)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * For 64-entry TLB: 64 Ã— 12 = 768 bytes â€” fits entirely in L1 cache (32KB)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vpn;</span><span style=\"color:#6A737D\">           /* Tag: which virtual page is cached?    */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pfn;</span><span style=\"color:#6A737D\">           /* Data: which physical frame maps to it? */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> asid;</span><span style=\"color:#6A737D\">          /* Address Space ID (process identifier)  */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  flags;</span><span style=\"color:#6A737D\">         /* valid | dirty | referenced | writable  */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  lru_counter;</span><span style=\"color:#6A737D\">   /* Used by LRU eviction; higher = more recently used */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">tlb_entry_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* Flag bit masks for tlb_entry_t.flags */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TLB_VALID</span><span style=\"color:#E1E4E8\">      (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TLB_DIRTY</span><span style=\"color:#E1E4E8\">      (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TLB_REFERENCED</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TLB_WRITABLE</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m2-tlb-entry-structure.svg\" alt=\"TLB Entry Structure â€” Tag, Data, and Flags\"></p>\n<p><strong>Why replicate dirty/referenced bits in the TLB?</strong> Because on a TLB hit you don&#39;t consult the page table at all â€” that&#39;s the whole point. But if a write access occurs and sets the dirty bit, where does it get recorded? The TLB holds the live, up-to-date version of these bits during the entry&#39;s residence. The page table&#39;s PTE may be stale. When a TLB entry is evicted, its dirty and referenced bits must be written back to the PTE before the entry is discarded. This is the <strong>TLB write-back</strong> step, and forgetting it is the single most common correctness bug in TLB implementations.\n<strong>Why store <code>writable</code> in the TLB?</strong> So that permission checking can happen entirely within the TLB on a hit, without fetching the PTE. If a write access hits the TLB but <code>TLB_WRITABLE</code> is clear, it&#39;s a protection fault â€” detected and reported without touching the page table array.</p>\n<blockquote>\n<p><strong>ğŸ”‘ Foundation: Fully associative vs set-associative TLB lookup</strong></p>\n<h3 id=\"what-it-is\">What it is</h3>\n<p>In the context of a Translation Lookaside Buffer (TLB), these are two different strategies for finding a physical address from a virtual one:</p>\n</blockquote>\n<ul>\n<li><strong>Fully Associative:</strong> The hardware compares the target virtual address against every single entry in the TLB simultaneously. There is no specific &quot;slot&quot; where a page must live; a translation can be stored anywhere.</li>\n<li><strong>Set-Associative:</strong> The TLB is partitioned into &quot;sets.&quot; A few bits of the virtual address (the <strong>index</strong>) determine exactly which set a translation belongs to. Once the set is identified, the hardware only searches the entries within that specific set (the <strong>ways</strong>). For example, in a &quot;4-way set-associative&quot; TLB, you only ever have to check 4 specific slots.</li>\n</ul>\n<h3 id=\"why-you-need-it-right-now\">Why you need it right now</h3>\n<p>As you implement or optimize memory management, you must balance <strong>latency, power, and conflict misses</strong>. </p>\n<p>If you use a <strong>Fully Associative</strong> lookup, you maximize your &quot;Hit Rate&quot; because you can put any translation in any available slot. However, this requires massive amounts of circuitry (comparators) to check every entry at once, which consumes significant power and doesn&#39;t scale to large TLB sizes.</p>\n<p>If you use <strong>Set-Associative</strong> lookup, you save power and can build much larger TLBs because the hardware only activates the small portion of memory belonging to one set. However, you risk &quot;conflict misses&quot;â€”where two frequently used addresses happen to map to the same set, kicking each other out even if the rest of the TLB is empty.</p>\n<h3 id=\"the-key-insight-the-quotvalet-vs-assigned-parkingquot-model\">The Key Insight: The &quot;Valet vs. Assigned Parking&quot; Model</h3>\n<ul>\n<li><strong>Fully Associative is Valet Parking:</strong> You give the attendant your keys (the virtual address). They can park your car in <strong>any</strong> spot in the entire garage. When you return, they must potentially look at every spot to find it, but the garage is never &quot;full&quot; unless every single spot is taken.</li>\n<li><strong>Set-Associative is Assigned Level Parking:</strong> Your ticket says you <strong>must</strong> park on Level 4. You only have to search the spots on Level 4 to find your car (faster/cheaper), but if Level 4 is full, you can&#39;t park thereâ€”even if Levels 1, 2, and 3 are completely empty.</li>\n</ul>\n<hr>\n<h2 id=\"the-asid-context-switches-without-tears\">The ASID: Context Switches Without Tears</h2>\n<p>Before implementing the TLB structure, you need to understand why the <strong>ASID (Address Space ID)</strong> exists, because it changes everything about how you handle context switches.\nThe naive approach to context switching with a TLB: when the OS switches from Process A to Process B, flush every TLB entry. Process A&#39;s translations are now invalid â€” Process B uses different virtualâ†’physical mappings. Clean slate for Process B.\nThe problem: a context switch happens thousands of times per second on a busy system. Each flush evicts all cached translations. Process B starts with a cold TLB â€” every memory access for the first few hundred microseconds triggers a TLB miss and page table walk. Then the OS switches back to Process A, flushes again, and Process A&#39;s hot TLB entries are gone too.\n<strong>TLB flushes are catastrophically expensive.</strong> This isn&#39;t a microoptimization concern â€” on a system running 1000 context switches per second with a 64-entry TLB, each switch costs roughly 64 &quot;warm-up&quot; accesses to re-populate the TLB. That&#39;s 64,000 extra page table walks per second on behalf of context switching alone.\nThe ASID solution: tag every TLB entry with the process identifier. During lookup, only consider entries whose ASID matches the <em>currently running process&#39;s</em> ASID. Entries from Process A remain in the TLB during Process B&#39;s time slice â€” they&#39;re simply invisible (treated as misses). When the OS switches back to Process A, its entries are still there, warm and valid.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>TLB state during Process A's time slice:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  VPN     â”‚ PFN â”‚ASID â”‚  flags   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ 0x00401  â”‚  7  â”‚  1  â”‚ valid,W  â”‚  â† Process A (ASID=1), active\nâ”‚ 0x00400  â”‚  3  â”‚  1  â”‚ valid    â”‚  â† Process A (ASID=1), active\nâ”‚ 0x00800  â”‚ 22  â”‚  2  â”‚ valid    â”‚  â† Process B (ASID=2), INVISIBLE\nâ”‚ 0x00801  â”‚ 23  â”‚  2  â”‚ valid    â”‚  â† Process B (ASID=2), INVISIBLE\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nActive ASID = 1  â†’  only rows 1-2 are eligible matches\nContext switch: OS sets active ASID = 2\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ 0x00401  â”‚  7  â”‚  1  â”‚ valid,W  â”‚  â† Process A, NOW INVISIBLE\nâ”‚ 0x00400  â”‚  3  â”‚  1  â”‚ valid    â”‚  â† Process A, NOW INVISIBLE\nâ”‚ 0x00800  â”‚ 22  â”‚  2  â”‚ valid    â”‚  â† Process B, ACTIVE again\nâ”‚ 0x00801  â”‚ 23  â”‚  2  â”‚ valid    â”‚  â† Process B, ACTIVE again\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nActive ASID = 2  â†’  zero-cost switch, no flush needed</code></pre></div>\n\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m2-asid-context-switch.svg\" alt=\"ASID-Tagged TLB: Context Switch Without Flush\"></p>\n<p><strong>ASID width limits:</strong> In your simulator, ASID is a <code>uint16_t</code> (16 bits = 65,536 possible ASIDs). In real x86-64 hardware with PCID (Process-Context Identifiers), ASID is 12 bits = 4096 values. When all ASIDs are exhausted (more than 65,535 live processes in your simulator), the OS must recycle old ASIDs. Recycling means that a process might be assigned an ASID that previously belonged to a different process â€” and that previous process&#39;s stale entries might still be in the TLB. The solution: when recycling an ASID, perform a full TLB flush first to evict all entries with that ASID.</p>\n<blockquote>\n<p>ğŸ”­ <strong>Deep Dive</strong>: The Meltdown/Spectre CPU vulnerabilities (Kocher et al., 2018; Lipp et al., 2018) required operating systems to keep kernel and user page tables completely separate (KPTI â€” Kernel Page Table Isolation). Without PCID/ASID support, every syscall required a TLB flush when switching between user and kernel page tables, causing 5â€“30% performance regression on I/O-heavy workloads. PCID support (equivalent to our ASID simulation) restored most of this performance. See the original Meltdown paper (Lipp et al., 2018) and the Linux KPTI patchset documentation for the full technical story.</p>\n</blockquote>\n<hr>\n<h2 id=\"the-tlb-structure\">The TLB Structure</h2>\n<p>Now implement it. The TLB is a fixed-size, fully-associative array of <code>tlb_entry_t</code> records. &quot;Fully associative&quot; means a VPN can be cached in <em>any</em> slot â€” unlike a CPU&#39;s L1 cache which is set-associative (a cache line can only go into specific sets). This makes the TLB simple to implement: lookup is a linear scan through all entries.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TLB_SIZE</span><span style=\"color:#79B8FF\">    64</span><span style=\"color:#6A737D\">      /* configurable: 16, 32, 64, 128           */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ASID_NONE</span><span style=\"color:#F97583\">   0x</span><span style=\"color:#79B8FF\">FFFF</span><span style=\"color:#6A737D\">  /* sentinel: entry is completely empty      */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ASID_MAX</span><span style=\"color:#79B8FF\">    255</span><span style=\"color:#6A737D\">     /* for 8-bit ASIDs; use 65535 for 16-bit    */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    tlb_entry_t</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[TLB_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\">    active_asid;</span><span style=\"color:#6A737D\">        /* ASID of currently running process */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">    clock_hand;</span><span style=\"color:#6A737D\">         /* for CLOCK-based eviction (not LRU variant) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Deterministic PRNG state for random eviction */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">    rand_state;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Statistics */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    hits;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    misses;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    flushes;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    evictions;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Initialize TLB to empty state.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * All entries are invalid; active ASID starts at 0 (first process).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * rand_state seeds the PRNG for reproducible random eviction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tlb_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> initial_asid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> rand_seed</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(tlb, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">tlb));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tlb->active_asid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> initial_asid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tlb->rand_state  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> rand_seed </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> rand_seed </span><span style=\"color:#F97583\">:</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">DEADBEEF</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Mark all entries as invalid with sentinel ASID */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> TLB_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tlb->entries[i].flags </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">          /* TLB_VALID cleared */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tlb->entries[i].asid  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ASID_NONE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"hardware-soul-cache-line-analysis-a-tlb_entry_t-is-12-bytes-a-tlb_t-with-64-entries-is-64-12-768-bytes-for-entries-plus-32-bytes-of-overhead-800-bytes-total-this-fits-comfortably-in-an-l1-cache-typically-32kb-in-hardware-tlb-lookup-is-done-in-parallel-across-all-entries-in-a-single-cycle-using-content-addressable-memory-cam-your-software-implementation-uses-a-sequential-loop-but-the-data-structure-fits-in-l1-regardless-minimizing-the-performance-gap\"><strong>Hardware soul â€” cache line analysis:</strong>\nA <code>tlb_entry_t</code> is 12 bytes. A <code>tlb_t</code> with 64 entries is 64 Ã— 12 = 768 bytes for entries, plus ~32 bytes of overhead = ~800 bytes total. This fits comfortably in an L1 cache (typically 32KB). In hardware, TLB lookup is done in parallel across all entries in a single cycle using content-addressable memory (CAM) â€” your software implementation uses a sequential loop, but the data structure fits in L1 regardless, minimizing the performance gap.</h2>\n<h2 id=\"tlb-lookup-tag-matching-in-action\">TLB Lookup: Tag Matching in Action</h2>\n<p>The lookup is the hot path â€” called on every single memory access:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * TLB lookup â€” the hot path.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Searches all TLB entries for one matching:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   1. entry.valid == 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   2. entry.asid  == tlb->active_asid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   3. entry.vpn   == vpn</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * On HIT:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - Updates referenced bit in TLB entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - Updates dirty bit if access_type == ACCESS_WRITE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - Checks write permission; returns XLATE_PROT_FAULT if violated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - Updates LRU counter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - Returns hit_pfn and XLATE_SUCCESS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * On MISS:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - Returns XLATE_TLB_MISS (caller must do page table walk)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Time complexity: O(TLB_SIZE) â€” sequential scan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In hardware: O(1) â€” parallel CAM lookup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    XLATE_TLB_HIT   </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    XLATE_TLB_MISS  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    XLATE_PROT_FAULT_TLB </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">tlb_result_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    tlb_result_t</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">     pfn;</span><span style=\"color:#6A737D\">       /* valid on HIT */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">          entry_idx;</span><span style=\"color:#6A737D\"> /* index of hit entry, for caller to update */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">tlb_lookup_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">tlb_lookup_t</span><span style=\"color:#B392F0\"> tlb_lookup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vpn</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">access_type_t</span><span style=\"color:#FFAB70\"> access_type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Update LRU counters: increment all entries' lru_counter each access.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * An entry's lru_counter represents \"how long since last access.\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * On hit, we reset that entry's counter to 0 (most recently used).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * On eviction, we pick the entry with the HIGHEST lru_counter (oldest).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Alternative: store a global tick counter and record \"last access tick\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * per entry. Equivalent semantics, different implementation overhead.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> TLB_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (tlb->entries[i].flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> TLB_VALID) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (tlb->entries[i].lru_counter </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 255</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\"> /* prevent overflow */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                tlb->entries[i].lru_counter</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Search for matching entry */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> TLB_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        tlb_entry_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">e </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">tlb->entries[i];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Three-way tag match: valid + ASID + VPN */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(e->flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> TLB_VALID))       </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* empty slot   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (e->asid </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> tlb->active_asid)   </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* wrong process */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (e->vpn  </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> vpn)                </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* wrong page    */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* â”€â”€ CACHE HIT â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tlb->hits</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Permission check on hit â€” no need to touch page table */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (access_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">(e->flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> TLB_WRITABLE)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">tlb_lookup_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_PROT_FAULT_TLB };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Update access metadata in TLB entry */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        e->flags </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> TLB_REFERENCED;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (access_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE) e->flags </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> TLB_DIRTY;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Reset LRU: this entry is now most recently used */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        e->lru_counter </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">tlb_lookup_t</span><span style=\"color:#E1E4E8\">){</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            .result    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_TLB_HIT,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            .pfn       </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> e->pfn,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            .entry_idx </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* â”€â”€ CACHE MISS â”€â”€ */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tlb->misses</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">tlb_lookup_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_TLB_MISS };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><strong>Why increment all counters on every access?</strong> This implements <em>relative</em> LRU tracking without a global timer. Each access ages every entry by 1. The hit entry is reset to 0 (youngest). After 10 accesses where entry A is not touched, its counter is 10. After 10 accesses where entry B is touched on each one, its counter stays near 0. The entry with the highest counter is the oldest â€” the LRU victim. This is O(TLB_SIZE) per access, acceptable for small TLBs (64 entries = 64 comparisons â‰ˆ negligible), but would be replaced with a doubly-linked list in a high-performance implementation.</p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m2-lru-eviction-state.svg\" alt=\"TLB LRU Eviction â€” State Evolution\"></p>\n<hr>\n<h2 id=\"tlb-insertion-and-eviction\">TLB Insertion and Eviction</h2>\n<p>When a TLB miss occurs, the caller walks the page table, gets the PFN, then calls <code>tlb_insert()</code> to cache the result for future accesses. If the TLB is full, an existing entry must be evicted first â€” and its metadata (dirty bit, referenced bit) written back to the page table before it&#39;s discarded.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Write-back TLB entry metadata to the corresponding page table entry.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Called before evicting an entry from the TLB.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This preserves the live dirty/referenced state that was updated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * on TLB hits (without touching the page table on hits).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If the TLB entry is dirty, the PTE's dirty bit is set.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If the TLB entry has referenced, the PTE's referenced bit is set.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Valid bit in PTE is NOT cleared here â€” the page is still in memory,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * just no longer in the TLB.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> tlb_writeback_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_entry_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">e</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(e->flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> TLB_VALID)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* Nothing to write back */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (e->asid </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ASID_NONE)   </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">pt->entries[e->vpn];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (e->flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> TLB_DIRTY)      </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_DIRTY;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (e->flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> TLB_REFERENCED) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_REFERENCED;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Note: we do NOT clear PTE_VALID â€” the page is still in RAM */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Find the LRU victim slot among valid entries.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns index of the entry with the highest lru_counter.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If any invalid slot exists, returns it immediately (free slot = best choice).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> tlb_find_victim_lru</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* First pass: look for an invalid (empty) slot â€” free, no eviction needed */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> TLB_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(tlb->entries[i].flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> TLB_VALID)) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Second pass: find oldest (highest lru_counter) among valid entries */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">    victim </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\"> max_age </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> TLB_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (tlb->entries[i].lru_counter </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> max_age) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            max_age </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tlb->entries[i].lru_counter;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            victim  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> victim;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Simple LCG PRNG for reproducible random eviction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Seed with tlb->rand_state; caller saves updated state.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Not cryptographic â€” just needs to be deterministic for test reproducibility.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> tlb_rand_next</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tlb->rand_state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tlb->rand_state </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1664525</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 1013904223</span><span style=\"color:#F97583\">u</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> /* Numerical Recipes LCG */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> tlb->rand_state;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Insert a VPNâ†’PFN translation into the TLB.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * If the TLB is full, evict using policy (LRU or random).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Write back the evicted entry's metadata to the page table before eviction.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   tlb          â€” the TLB to insert into</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   pt           â€” the page table (for write-back on eviction)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   vpn          â€” virtual page number being inserted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   pfn          â€” physical frame number (result of page table walk)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   writable     â€” copy of PTE's write permission</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   use_random   â€” if true, use random eviction; else LRU</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tlb_insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                uint32_t</span><span style=\"color:#FFAB70\"> vpn</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> pfn</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                int</span><span style=\"color:#FFAB70\"> writable</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> use_random</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> slot;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (use_random) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Random eviction: pick a random slot, write back if valid */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        slot </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#B392F0\">tlb_rand_next</span><span style=\"color:#E1E4E8\">(tlb) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> TLB_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        tlb_writeback_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb->entries[slot], pt);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* LRU eviction: find victim (or free slot) */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        slot </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> tlb_find_victim_lru</span><span style=\"color:#E1E4E8\">(tlb);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        tlb_writeback_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb->entries[slot], pt);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tlb->entries[slot].flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> TLB_VALID) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tlb->evictions</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Populate the new entry */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    tlb_entry_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">e </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">tlb->entries[slot];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    e->vpn         </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> vpn;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    e->pfn         </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pfn;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    e->asid        </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tlb->active_asid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    e->flags       </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TLB_VALID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> TLB_REFERENCED;</span><span style=\"color:#6A737D\">    /* fresh entry = referenced */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (writable) e->flags </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> TLB_WRITABLE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    e->lru_counter </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* most recently used */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m2-tlb-writeback-coherence.svg\" alt=\"TLB Dirty Bit Write-Back on Eviction\"></p>\n<p><strong>Design choice: random vs LRU eviction</strong></p>\n<table>\n<thead>\n<tr>\n<th>Policy</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>LRU âœ“</strong> (default)</td>\n<td>Near-optimal hit rate, deterministic given access pattern</td>\n<td>O(n) counter updates per access</td>\n<td>AMD CPUs (approximate), your simulator</td>\n</tr>\n<tr>\n<td><strong>Random</strong></td>\n<td>O(1), no metadata needed, easy to reason about asymptotically</td>\n<td>Non-deterministic without seeded PRNG</td>\n<td>MIPS R2000 TLB, ARM Cortex-A series</td>\n</tr>\n<tr>\n<td><strong>FIFO</strong></td>\n<td>O(1), no staleness concern</td>\n<td>Susceptible to BÃ©lÃ¡dy anomaly (see Milestone 4)</td>\n<td>Rarely used for TLBs</td>\n</tr>\n<tr>\n<td>For your simulator, implement LRU as the default but support random via a flag. When testing TLB miss rates against known access patterns, use LRU (deterministic). When stress-testing correctness (the algorithm should work regardless of which entry is evicted), use random with a fixed seed.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"tlb-flush-operations\">TLB Flush Operations</h2>\n<p>Two flush operations are needed:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * tlb_flush_all â€” invalidate every entry in the TLB.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Used when:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   1. ASID space is exhausted and an ASID is being recycled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   2. The OS explicitly requests a full shootdown (e.g., after unmapping a range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *      shared across all processes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   3. Page table entries are modified in ways that require TLB coherence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *      (e.g., a page is evicted from physical memory in Milestone 4)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Write back all dirty entries before invalidating!</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Failing to write back = silent data loss of dirty/referenced metadata.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tlb_flush_all</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> TLB_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        tlb_writeback_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb->entries[i], pt);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tlb->entries[i].flags </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tlb->entries[i].asid  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ASID_NONE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tlb->flushes</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * tlb_flush_asid â€” invalidate only entries belonging to a specific ASID.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Used when a process exits: its ASID is being freed, so its TLB entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * must be cleaned up. Other processes' entries are preserved.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This is equivalent to the x86 INVPCID instruction with type=1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * (flush all translations for a specific PCID).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tlb_flush_asid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> asid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> TLB_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> ((tlb->entries[i].flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> TLB_VALID) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> tlb->entries[i].asid </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> asid) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            tlb_writeback_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb->entries[i], pt);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tlb->entries[i].flags </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tlb->entries[i].asid  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ASID_NONE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Note: this doesn't increment tlb->flushes â€” it's a targeted eviction,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * not a full flush. Count it separately if your stats require it. */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * tlb_flush_page â€” invalidate a single VPN across all ASIDs.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Used when a specific page's mapping is modified (e.g., permissions changed,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * page evicted from RAM in Milestone 4). Every process that might have</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * cached that VPN must have its entry invalidated.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Equivalent to x86 INVLPG instruction (invalidate TLB entry for address).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This is the correct operation to call in Milestone 4 when evicting a page</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * from physical memory.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tlb_flush_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vpn</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> TLB_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> ((tlb->entries[i].flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> TLB_VALID) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> tlb->entries[i].vpn </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> vpn) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            tlb_writeback_entry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb->entries[i], pt);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tlb->entries[i].flags </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tlb->entries[i].asid  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ASID_NONE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"why-tlb_flush_page-matters-for-milestone-4-when-you-evict-a-page-from-physical-memory-to-make-room-for-a-new-one-you-must-call-tlb_flush_page-on-that-page39s-vpn-before-clearing-its-pte-otherwise-the-tlb-may-still-hold-a-valid-looking-entry-pointing-to-a-pfn-that-now-belongs-to-a-different-page-that39s-a-tlb-coherence-violation-the-hardware-equivalent-of-reading-from-a-dangling-pointer-the-tlb-would-return-a-pfn-that-now-maps-to-different-data-causing-silent-memory-corruption-with-no-visible-fault\"><strong>Why <code>tlb_flush_page</code> matters for Milestone 4:</strong> When you evict a page from physical memory to make room for a new one, you must call <code>tlb_flush_page()</code> on that page&#39;s VPN <em>before</em> clearing its PTE. Otherwise, the TLB may still hold a valid-looking entry pointing to a PFN that now belongs to a different page. That&#39;s a <strong>TLB coherence violation</strong> â€” the hardware equivalent of reading from a dangling pointer. The TLB would return a PFN that now maps to different data, causing silent memory corruption with no visible fault.</h2>\n<h2 id=\"integrating-the-tlb-into-address-translation\">Integrating the TLB into Address Translation</h2>\n<p>Now rewrite the <code>translate()</code> function from Milestone 1 to check the TLB first:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Extended translate() with TLB.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Three-level view of what happens:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Application level:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   translate(vaddr, ACCESS_READ) â†’ paddr</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Simulator level (this function):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   1. Extract VPN, offset</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   2. TLB lookup â†’ HIT or MISS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   3. On MISS: page table walk, page fault if needed, TLB insert</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   4. Build physical address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Hardware equivalent:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   MMU receives vaddr â†’ checks TLB in parallel with L1 cache index</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   computation â†’ on TLB miss, CPU microcode walks page tables via</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   dedicated page-walk unit â†’ updates TLB â†’ signals OS on page fault (#PF)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#B392F0\"> translate_with_tlb</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">simulator_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sim</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">access_type_t</span><span style=\"color:#FFAB70\"> access_type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sim->total_accesses</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vpn    </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> vpn_from_addr</span><span style=\"color:#E1E4E8\">(vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> offset_from_addr</span><span style=\"color:#E1E4E8\">(vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (vpn </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> PAGE_TABLE_SIZE) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sim->protection_faults</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_PROT_FAULT };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Step 1: TLB Lookup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    tlb_lookup_t</span><span style=\"color:#E1E4E8\"> tlb_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> tlb_lookup</span><span style=\"color:#E1E4E8\">(tlb, vpn, access_type);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tlb_result.result </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> XLATE_PROT_FAULT_TLB) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sim->protection_faults</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[PROT FAULT] TLB hit but write to read-only page \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"VPN=0x</span><span style=\"color:#79B8FF\">%05X\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, vpn);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_PROT_FAULT };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pfn;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tlb_result.result </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> XLATE_TLB_HIT) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * TLB HIT: use cached PFN directly, skip page table entirely</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pfn </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tlb_result.pfn;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Note: dirty/referenced bits already updated inside tlb_lookup() */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * TLB MISS: walk the page table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        pte_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">sim->page_table.entries[vpn];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Is the page in memory? */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_VALID)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Page fault: demand-load the page */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> handle_page_fault</span><span style=\"color:#E1E4E8\">(sim, vpn, access_type);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT32_MAX) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_OOM };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* pte is now updated by handle_page_fault() */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Permission check after confirming valid=1 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (access_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_PERM_WRITE)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sim->protection_faults</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[PROT FAULT] Page table: write to read-only \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    \"VPN=0x</span><span style=\"color:#79B8FF\">%05X\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, vpn);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_PROT_FAULT };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Update PTE metadata on this page table walk */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_REFERENCED;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (access_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_DIRTY;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pfn </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pte_get_pfn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Insert translation into TLB for future accesses */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> writable </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_PERM_WRITE) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        tlb_insert</span><span style=\"color:#E1E4E8\">(tlb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim->page_table, vpn, pfn, writable,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                   /*use_random=*/</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  /* 0 = LRU */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Build physical address (same for hit and miss paths)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> paddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make_physical_addr</span><span style=\"color:#E1E4E8\">(pfn, offset);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_SUCCESS,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .paddr  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> paddr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .pfn    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pfn,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m2-tlb-hit-miss-trace.svg\" alt=\"TLB Hit/Miss Trace Example\"></p>\n<p><strong>The coherence invariant:</strong> After every call to <code>translate_with_tlb()</code>, the following must hold:</p>\n<ol>\n<li>If the TLB has an entry for <code>(vpn, active_asid)</code>, then <code>tlb_entry.pfn == page_table.entries[vpn].pfn</code></li>\n<li>If the TLB entry has <code>TLB_DIRTY</code> set, then <code>page_table.entries[vpn]</code> <em>may or may not</em> have <code>PTE_DIRTY</code> set â€” the TLB is authoritative for the live dirty state</li>\n<li>When a TLB entry is evicted, <code>page_table.entries[vpn]</code> must be updated with the TLB entry&#39;s dirty/referenced bits before the entry is discarded</li>\n</ol>\n<hr>\n<h2 id=\"context-switch-simulation\">Context Switch Simulation</h2>\n<p>Extend the simulator&#39;s state to track the current ASID:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Simulate a context switch: the OS is switching execution to a new process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * identified by new_asid.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * With ASID support: just update the active ASID. The new process's previous</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * TLB entries (if any) are immediately active. The old process's entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * become invisible.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Without ASID support (or when ASIDs are exhausted): flush all TLB entries.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   tlb           â€” TLB state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   pt            â€” current process's page table (for write-back before any flush)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   new_asid      â€” ASID of the process being switched to</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   force_flush   â€” if true, flush regardless of ASID support</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> context_switch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    uint16_t</span><span style=\"color:#FFAB70\"> new_asid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> force_flush</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[CONTEXT SWITCH] ASID </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> â†’ </span><span style=\"color:#79B8FF\">%u%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           tlb->active_asid, new_asid,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           force_flush </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \" (forced flush)\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \" (ASID preserved)\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (force_flush) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        tlb_flush_all</span><span style=\"color:#E1E4E8\">(tlb, pt);</span><span style=\"color:#6A737D\">  /* writes back all dirty bits first */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* else: just switch the active ASID â€” old entries become invisible,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * new process's entries (if any) become visible immediately */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tlb->active_asid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_asid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><strong>Tracing context switch behavior:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Access sequence:\n  [Process 1, ASID=1]\n  R 0x00401000  â†’ TLB MISS, PF, insert(VPN=0x401, PFN=0, ASID=1)\n  R 0x00402000  â†’ TLB MISS, PF, insert(VPN=0x402, PFN=1, ASID=1)\n  R 0x00401000  â†’ TLB HIT  (VPN=0x401, ASID=1) âœ“\n  [CONTEXT SWITCH â†’ Process 2, ASID=2]\n  R 0x00401000  â†’ TLB MISS (ASID=2, no entry for ASID=2, VPN=0x401)\n                  Page table walk â†’ PF â†’ insert(VPN=0x401, PFN=7, ASID=2)\n  [CONTEXT SWITCH â†’ Process 1, ASID=1]\n  R 0x00401000  â†’ TLB HIT  (ASID=1 entry still in TLB!) PFN=0 returned\n                  Process 1's translation survived Process 2's time slice.</code></pre></div>\n<h2 id=\"the-last-access-is-the-key-insight-process-139s-tlb-entry-survived-the-context-switch-because-asid-tagging-made-it-invisible-not-evicted-during-process-239s-execution-when-process-1-resumes-its-entries-are-immediately-warm-this-is-the-entire-performance-value-proposition-of-asid-support\">The last access is the key insight: Process 1&#39;s TLB entry survived the context switch because ASID tagging made it invisible (not evicted) during Process 2&#39;s execution. When Process 1 resumes, its entries are immediately warm. This is the entire performance value proposition of ASID support.</h2>\n<h2 id=\"statistics-and-reporting\">Statistics and Reporting</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * TLB statistics reporter.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Call at end of simulation or after each benchmark phase.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tlb_print_stats</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> total </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tlb->hits </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> tlb->misses;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> hit_rate </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (total </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        ?</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)tlb->hits </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)total</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        :</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">=== TLB Statistics ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"TLB entries:    </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,  TLB_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Total lookups:  </span><span style=\"color:#79B8FF\">%lu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, total);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Hits:           </span><span style=\"color:#79B8FF\">%lu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, tlb->hits);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Misses:         </span><span style=\"color:#79B8FF\">%lu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, tlb->misses);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Hit rate:       </span><span style=\"color:#79B8FF\">%.2f%%\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, hit_rate);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Evictions:      </span><span style=\"color:#79B8FF\">%lu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, tlb->evictions);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Full flushes:   </span><span style=\"color:#79B8FF\">%lu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, tlb->flushes);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Updated simulation loop: emit TLB hit/miss classification per access.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> simulate_with_tlb</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">simulator_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sim</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                       const</span><span style=\"color:#79B8FF\"> mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">accesses</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#79B8FF\"> mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">acc </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">accesses</span><span style=\"color:#E1E4E8\">[i];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Peek at TLB state before the access to classify in output */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> hits_before </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tlb->hits;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        xlate_t</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> translate_with_tlb</span><span style=\"color:#E1E4E8\">(sim, tlb, acc->vaddr, acc->type);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">tlb_status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (tlb->hits </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> hits_before) </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"HIT \"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"MISS\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">op         </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (acc->type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE) </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"W\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"R\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[</span><span style=\"color:#79B8FF\">%6zu</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> 0x</span><span style=\"color:#79B8FF\">%08X</span><span style=\"color:#9ECBFF\">  TLB:</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i, op, acc->vaddr, tlb_status);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> (result.result) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> XLATE_SUCCESS:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  â†’  phys=0x</span><span style=\"color:#79B8FF\">%08X\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, result.paddr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> XLATE_PROT_FAULT:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  â†’  PROTECTION FAULT</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> XLATE_OOM:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  â†’  OUT OF MEMORY</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  â†’  FAULT</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"building-and-testing\">Building and Testing</h2>\n<h3 id=\"compile\">Compile</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -Wall</span><span style=\"color:#79B8FF\"> -Wextra</span><span style=\"color:#79B8FF\"> -O2</span><span style=\"color:#79B8FF\"> -std=c11</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> vmsim</span><span style=\"color:#9ECBFF\"> vmsim.c</span></span></code></pre></div>\n<h3 id=\"test-1-verify-tlb-hit-rate-with-repeated-access\">Test 1: Verify TLB Hit Rate with Repeated Access</h3>\n<p>Create <code>test_tlb_hits.trace</code>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># Access same 4 pages repeatedly â€” should achieve high TLB hit rate\nR 0x00001000\nR 0x00002000\nR 0x00003000\nR 0x00004000\nR 0x00001004\nR 0x00002004\nR 0x00003004\nR 0x00004004\nR 0x00001008\nR 0x00002008\nR 0x00003008\nR 0x00004008</code></pre></div>\n<p>Expected statistics after 12 accesses:</p>\n<ul>\n<li>First 4 accesses: TLB MISS (cold start), page faults</li>\n<li>Accesses 5â€“12: TLB HIT (same VPNs 0x1, 0x2, 0x3, 0x4 â†’ in TLB from first 4)</li>\n<li>Hit rate: 8/12 = <strong>66.7%</strong></li>\n<li>Page faults: 4</li>\n<li>TLB evictions: 0 (4 entries used, TLB_SIZE=64)</li>\n</ul>\n<h3 id=\"test-2-lru-eviction-correctness\">Test 2: LRU Eviction Correctness</h3>\n<p>Create <code>test_tlb_eviction.trace</code> with <code>TLB_SIZE=4</code>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># Access 5 distinct pages with a TLB of size 4\n# After 4 accesses, TLB is full. 5th access evicts the LRU entry.\nR 0x00001000   # TLB MISS â†’ insert VPN=1 (LRU order: 1)\nR 0x00002000   # TLB MISS â†’ insert VPN=2 (LRU order: 2,1)\nR 0x00003000   # TLB MISS â†’ insert VPN=3 (LRU order: 3,2,1)\nR 0x00004000   # TLB MISS â†’ insert VPN=4 (LRU order: 4,3,2,1)\nR 0x00001000   # TLB HIT  VPN=1 â†’ LRU order: 1,4,3,2\nR 0x00005000   # TLB MISS â†’ TLB full â†’ evict VPN=2 (oldest) â†’ insert VPN=5\nR 0x00002000   # TLB MISS â†’ VPN=2 was evicted â†’ page table walk needed</code></pre></div>\n<p>To make this trace work, temporarily define <code>TLB_SIZE 4</code> at the top of your file for this test.</p>\n<h3 id=\"test-3-asid-context-switch-correctness\">Test 3: ASID Context Switch Correctness</h3>\n<p>Write a C test (not a trace file) to verify ASID behavior programmatically:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_asid_context_switch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    simulator_t</span><span style=\"color:#E1E4E8\"> sim;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    simulator_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    tlb_t</span><span style=\"color:#E1E4E8\"> tlb;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    tlb_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb,</span><span style=\"color:#6A737D\"> /*initial_asid=*/</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\"> /*rand_seed=*/</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Process 1 (ASID=1): access VPN 0x401 */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    translate_with_tlb</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00401000</span><span style=\"color:#E1E4E8\">, ACCESS_READ);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(tlb.hits   </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(tlb.misses </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Access again â€” should be a TLB hit */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    translate_with_tlb</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00401008</span><span style=\"color:#E1E4E8\">, ACCESS_READ);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(tlb.hits   </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   /* same VPN=0x401, offset differs â€” HIT */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(tlb.misses </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Context switch to Process 2 (ASID=2) â€” no flush */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    context_switch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim.page_table,</span><span style=\"color:#6A737D\"> /*new_asid=*/</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\"> /*force_flush=*/</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* VPN 0x401 miss: Process 2's ASID=2 has no entry for VPN=0x401 */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    translate_with_tlb</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00401000</span><span style=\"color:#E1E4E8\">, ACCESS_READ);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(tlb.misses </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   /* MISS despite VPN=0x401 being in TLB with ASID=1 */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Context switch back to Process 1 (ASID=1) â€” no flush */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    context_switch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim.page_table,</span><span style=\"color:#6A737D\"> /*new_asid=*/</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\"> /*force_flush=*/</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* VPN 0x401 hit: Process 1's entry survived in the TLB! */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    translate_with_tlb</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00401000</span><span style=\"color:#E1E4E8\">, ACCESS_READ);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(tlb.hits </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">     /* HIT â€” ASID=1 entry is still there */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ASID context switch test: PASSED</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"test-4-dirty-bit-write-back\">Test 4: Dirty Bit Write-Back</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_dirty_writeback</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    simulator_t</span><span style=\"color:#E1E4E8\"> sim;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    simulator_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    tlb_t</span><span style=\"color:#E1E4E8\"> tlb;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    tlb_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Write access to VPN 0x100 â€” page fault, then TLB insert with DIRTY */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    translate_with_tlb</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00100000</span><span style=\"color:#E1E4E8\">, ACCESS_WRITE);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Find the TLB entry and confirm dirty bit is set */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> found </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> TLB_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> ((tlb.entries[i].flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> TLB_VALID) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> tlb.entries[i].vpn </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            assert</span><span style=\"color:#E1E4E8\">(tlb.entries[i].flags </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> TLB_DIRTY);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            found </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(found);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Flush the TLB â€” this should write back the dirty bit to the PTE */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    tlb_flush_all</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim.page_table);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Verify: PTE's dirty bit was written back */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#E1E4E8\"> pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sim.page_table.entries[</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_DIRTY);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Dirty bit write-back test: PASSED</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"common-pitfalls-and-how-to-avoid-them\">Common Pitfalls and How to Avoid Them</h2>\n<table>\n<thead>\n<tr>\n<th>Pitfall</th>\n<th>Symptom</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Checking permissions before <code>valid</code> in TLB lookup</td>\n<td>Prot fault on empty entries</td>\n<td>Check <code>TLB_VALID</code> first, always</td>\n</tr>\n<tr>\n<td>Not writing back dirty/referenced bits on eviction</td>\n<td>PTE dirty state stale; page replacement in M4 will fail to write dirty pages</td>\n<td>Call <code>tlb_writeback_entry()</code> before every eviction</td>\n</tr>\n<tr>\n<td>Not invalidating TLB entry when PTE is modified</td>\n<td>Stale TLB serves old translation after page eviction (M4)</td>\n<td>Call <code>tlb_flush_page(vpn)</code> whenever PTE.valid is cleared</td>\n</tr>\n<tr>\n<td>Using <code>TLB_SIZE</code> not power-of-2 for random eviction</td>\n<td>Modulo bias skews eviction distribution</td>\n<td>Use LCG PRNG + mod, or mask with <code>(TLB_SIZE - 1)</code> if power-of-2</td>\n</tr>\n<tr>\n<td>Forgetting ASID check in lookup (only checking VPN)</td>\n<td>Process B sees Process A&#39;s translations â€” memory isolation broken</td>\n<td>Three-way check: valid AND asid AND vpn</td>\n</tr>\n<tr>\n<td>Setting dirty in TLB on miss instead of tracking in PTE</td>\n<td>Double-setting or missing dirty state during page table walk</td>\n<td>The miss path updates the PTE directly; insert copies writable flag, not dirty</td>\n</tr>\n<tr>\n<td>LRU counter overflow</td>\n<td>After 256 accesses, <code>uint8_t</code> wraps to 0, making all entries look &quot;new&quot;</td>\n<td>Cap at 255 (<code>if counter &lt; 255: counter++</code>) or use <code>uint64_t</code> global tick</td>\n</tr>\n<tr>\n<td>Non-deterministic test failures with random eviction</td>\n<td>Tests pass sometimes, fail others</td>\n<td>Always use a fixed <code>rand_seed</code> in tests</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"hardware-soul-what-your-simulator-abstracts-away\">Hardware Soul: What Your Simulator Abstracts Away</h2>\n<p>Your software TLB does sequential linear scan: O(TLB_SIZE) comparisons per lookup. Real hardware does something qualitatively different:\n<strong>Content-Addressable Memory (CAM):</strong> A hardware TLB is implemented as a CAM â€” a memory array where you broadcast the search key (VPN + ASID) and all entries compare against it <em>simultaneously</em> using parallel combinational logic. A 64-entry TLB completes its lookup in a single clock cycle (~0.3ns at 3GHz), regardless of entry count. Your 64-iteration loop costs more than a TLB miss would in hardware â€” the abstraction leaks here. This is fine for the simulator&#39;s goals (correctness and statistical measurement), but remember that real TLB performance is O(1) not O(n).\n<strong>VIPT L1 Cache:</strong> Modern CPUs use Virtually-Indexed, Physically-Tagged (VIPT) L1 caches. When a memory instruction executes:</p>\n<ol>\n<li>The CPU begins the TLB lookup (VPN â†’ PFN) in parallel</li>\n<li>The CPU simultaneously uses the virtual address&#39;s lower bits (which are identical to the physical address&#39;s lower bits â€” the page offset) to index into the L1 cache&#39;s set</li>\n<li>By the time the cache fetch returns the candidate cache line, the TLB has also completed the PFN lookup</li>\n<li>The CPU compares the returned cache line&#39;s <em>physical</em> tag against the PFN from the TLB\nThis &quot;race&quot; completes in ~4 cycles. If the TLB lookup had to complete <em>before</em> the cache lookup could begin, L1 access would take ~5â€“6 cycles instead of ~4. The VIPT design exploits the fact that the page offset bits are unchanged by translation to parallelize the two lookups. This is why L1 cache size is bounded by <code>page_size Ã— associativity</code>: to keep the cache-set index entirely within the offset bits. A 4-way associative L1 with 4KB pages can be at most 16KB (4 Ã— 4KB). Larger L1 caches require more associativity or larger page sizes.\n<strong>Branch prediction and TLB:</strong> The CPU&#39;s branch predictor attempts to speculatively fetch instructions from the predicted next address. That speculative fetch must also go through the TLB. If the TLB entry for the speculatively accessed page isn&#39;t present, the CPU must either stall the speculation or handle the TLB miss speculatively. This is one of the reasons TLB misses have such high latency variance â€” they can disrupt the pipeline in ways that a cache miss to L3 does not.</li>\n</ol>\n<hr>\n<h2 id=\"knowledge-cascade-what-the-tlb-unlocks\">Knowledge Cascade: What the TLB Unlocks</h2>\n<p><strong>1. Huge Pages â€” Covering More Ground Per TLB Entry</strong>\nA 64-entry TLB with 4KB pages covers 64 Ã— 4096 = <strong>262 KB</strong> of virtual address space without a miss. Add one access to the 263rd KB and you spill out of TLB coverage, causing a miss. Now consider 2MB huge pages: each TLB entry covers 2MB instead of 4KB. A 64-entry TLB covers 64 Ã— 2MB = <strong>128 MB</strong> of address space. With 1GB huge pages (available on x86-64): 64GB covered.\nThis is exactly why PostgreSQL, Linux&#39;s huge page support, JVM G1GC, and DPDK all support huge page allocation (<code>MAP_HUGETLB</code> on Linux, <code>SHM_HUGETLB</code>). A database buffer pool accessing 8GB of data with 4KB pages and a 64-entry TLB would thrash the TLB on every scan â€” every 256th access (64 Ã— 4KB = 256KB) escapes TLB coverage. With 2MB pages, the TLB covers 128MB before spilling; with 1GB pages, the entire buffer pool fits in 8 TLB entries. The TLB miss rate drops from near-100% to near-0% for sequential scans.\n<strong>2. Spectre and Meltdown â€” TLBs as Security Boundaries</strong>\nMeltdown (CVE-2017-5754) exploited the fact that the CPU speculatively executes instructions using kernel memory even before the permission check in the TLB/PTE completes. The kernel memory&#39;s data leaks into the CPU cache before the permission fault is raised. The OS patch (KPTI) separated kernel and user page tables entirely â€” but this meant every syscall (entering kernel mode) required switching page tables, which required either a full TLB flush or an ASID/PCID change. On CPUs without PCID support: full flush on every syscall. On I/O-heavy workloads (databases, web servers making many syscalls): 5â€“30% throughput regression.\nCPUs with PCID support use it like your ASID simulation: kernel gets one PCID, user gets another. Switching between them doesn&#39;t flush the TLB â€” both sets of entries coexist. Performance impact: reduced to ~1â€“2% on most workloads. Understanding your ASID implementation directly maps to understanding why PCID support was the hardware fix for a security crisis.\n<strong>3. The True Cost of a Context Switch</strong>\nComputer science courses teach that a context switch costs &quot;saving and restoring registers.&quot; In reality, the dominant cost on modern hardware is <strong>TLB pollution</strong>. When the scheduler runs a new process:</p>\n<ul>\n<li>Its TLB entries (from its last time slice) may have been partially evicted</li>\n<li>The first 10â€“100 microseconds of execution are spent rebuilding TLB entries</li>\n<li>Each TLB miss costs ~10â€“100 cycles (hardware page walk, possibly L3 cache miss for the PTE)</li>\n<li>For a process with a 10MB working set at 4KB pages: ~2500 distinct pages, far more than a 64-entry TLB\nOperating systems exploit this by: (a) using ASID/PCID to preserve entries across switches, (b) scheduling processes in time slices long enough to amortize the warm-up cost, (c) using NUMA-aware scheduling to keep processes on CPUs whose L3 cache still holds their working set. The kernel scheduler&#39;s decisions are intimately connected to TLB behavior â€” something invisible from a pure scheduling-theory perspective.\n<strong>4. JIT Compilers and TLB Pressure</strong>\nV8 (Chrome&#39;s JavaScript engine), HotSpot (JVM), and LuaJIT allocate JIT-compiled code in executable memory regions. Naively, each JIT compilation might call <code>mmap()</code> and get a new anonymous region scattered across virtual memory. If these regions span many pages, they consume TLB entries for instruction fetches in addition to TLB entries for data. A program that JITs many small functions and stores them in scattered pages creates TLB pressure from both sides â€” code and data compete for the same TLB.\nThis is why production JIT runtimes use a <strong>code arena</strong>: a single large <code>mmap()</code> region divided internally for JIT output. All compiled code lives in a contiguous virtual address range, maximally sharing TLB entries. V8&#39;s <code>CodeSpace</code> and HotSpot&#39;s <code>CodeCache</code> are exactly this pattern. Your simulator could be extended to model two separate TLBs (iTLB for instruction fetches, dTLB for data) â€” which is how real x86-64 CPUs work. Each has ~64â€“2048 entries and can be measured independently.\n<strong>5. Database Buffer Pools â€” Same Mathematics, Different Layer</strong>\nPostgreSQL&#39;s shared buffer pool and InnoDB&#39;s buffer pool implement the <em>same algorithm</em> as your TLB â€” but at the disk-to-RAM boundary instead of the RAM-to-CPU boundary. A buffer pool entry: <code>{page_id â†’ frame_in_RAM, dirty_bit, pin_count}</code>. Buffer pool eviction: clock algorithm or LRU. Buffer pool flush: write dirty pages to disk before evicting. Page fault equivalent: buffer pool miss â†’ read from disk.\nThe translation table you built and the buffer manager these databases use are isomorphic structures solving the same problem at different points in the memory hierarchy. The TLB covers RAMâ†’CPU; the buffer pool covers diskâ†’RAM. Understanding one deeply means you understand the other â€” the same LRU, clock, and optimal algorithms appear in both, just with different latency numbers (1ns vs 10ms) and different eviction costs (1 cycle vs 10ms disk write).</li>\n</ul>\n<hr>\n<h2 id=\"what-you39ve-built-and-what39s-missing\">What You&#39;ve Built and What&#39;s Missing</h2>\n<p><strong>You have:</strong></p>\n<ul>\n<li>A fully-associative TLB with configurable size (16, 32, 64 entries)</li>\n<li>LRU and random (seeded) eviction policies</li>\n<li>ASID-tagged entries for context switch support without full flushes</li>\n<li>Write-back of dirty/referenced bits to the page table on eviction</li>\n<li>Full, ASID-targeted, and page-targeted flush operations</li>\n<li>Integrated translation path: TLB first, page table on miss</li>\n<li>Statistics: hits, misses, hit rate, evictions, flushes\n<strong>What&#39;s still painful:</strong> The flat page table from Milestone 1 consumes 4MB regardless of how sparse the address space is. Two processes each with a flat page table cost 8MB of simulator RAM in page tables alone â€” just for the mapping structures. A real server running thousands of processes would drown in page table overhead.\nMilestone 3 fixes this with multi-level page tables: instead of one giant array, you&#39;ll build a tree structure where inner nodes are only allocated when the corresponding virtual address regions are actually mapped. A process using 10 pages uses only the specific page table nodes needed to describe those 10 pages â€” not a 1M-entry flat array.\nThe TLB you built here will sit in front of the multi-level page table walk in Milestone 3. A TLB miss that triggers a two-level walk costs 2 memory accesses. A TLB miss with a three-level walk costs 3. This is why TLB hit rate is <em>even more critical</em> for multi-level tables than for the flat table you started with â€” each level multiplies the miss penalty.</li>\n</ul>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: virtual-memory-sim-m3 -->\n<!-- MS_ID: virtual-memory-sim-m3 -->\n<h1 id=\"milestone-3-multi-level-page-tables\">Milestone 3: Multi-Level Page Tables</h1>\n<h2 id=\"the-problem-you39re-actually-solving-it39s-not-what-you-think\">The Problem You&#39;re Actually Solving (It&#39;s Not What You Think)</h2>\n<p>Here&#39;s the misconception worth destroying before you write a single line of code:\n<em>&quot;Multi-level page tables exist to handle bigger address spaces. A single-level table can&#39;t address enough memory, so we need more levels â€” like adding digits to a phone number.&quot;</em>\nThis is wrong, and the wrongness is deep enough to corrupt every design decision you&#39;d make afterward.\nRun the numbers on a single-level page table. You built one in Milestone 1. It has <code>2^20 = 1,048,576</code> entries for a 32-bit address space with 4KB pages. Each PTE is 4 bytes. Total cost: <strong>4,194,304 bytes = 4 MB per process</strong>. That 4MB exists in memory even if your process uses exactly three pages â€” a stack page, a code page, and one data page. You&#39;ve paid 4MB to describe 12KB of actual usage. The ratio is 341:1 overhead.\nNow multiply by the number of processes on your system. A server running 100 concurrent processes: <strong>400MB of page tables</strong> just for the mapping structures, before storing a single byte of actual program data. Run 1000 processes and you&#39;ve consumed 4GB â€” exceeding the total available physical memory on many systems â€” just for the empty arrays mapping virtual pages no one will ever use.\nThis is not a theoretical concern. It was the real, production crisis that drove the evolution from flat page tables to hierarchical ones. The problem isn&#39;t address space <em>size</em> â€” it&#39;s address space <em>sparsity</em>. Real processes use tiny islands of virtual addresses separated by vast unmapped voids. A typical process maps a few pages for code, a few for stack, a few for heap, and then nothing else for the next 4 billion bytes of addressable space. Paying for all 4 billion bytes&#39; worth of PTE slots is pure waste.\n<strong>The fix is on-demand allocation of the mapping structure itself.</strong> Instead of one flat array pre-allocated for all possible virtual pages, build a tree. Allocate tree nodes only for branches that are actually used. A process using 3 scattered pages needs only the path through the tree to reach those 3 pages â€” not the entire tree. The unmapped regions simply have <code>NULL</code> pointers at some intermediate level, pruning away entire subtrees at zero cost.\nThis is the revelation: <strong>multi-level page tables are a sparse data structure optimization</strong>. They are conceptually identical to a <a href=\"https://en.wikipedia.org/wiki/Trie\">trie</a> â€” a tree where the path from root to leaf spells out the key (here: the virtual address bits), and missing branches are <code>NULL</code> pointers that save memory. The number of levels is not about addressing capacity â€” it&#39;s about how finely you want to granularize the sparsity.</p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m3-sparse-vs-flat-memory-overhead.svg\" alt=\"Memory Overhead: Flat vs Two-Level for Sparse Address Space\"></p>\n<hr>\n<h2 id=\"why-hierarchical-indexing-saves-memory-for-sparse-structures\">Why Hierarchical Indexing Saves Memory for Sparse Structures</h2>\n<p>[[EXPLAIN:why-hierarchical/multi-level-indexing-saves-memory-for-sparse-structures|Why hierarchical/multi-level indexing saves memory for sparse structures â€” the trie principle applied to page tables, and why missing branches are free]]\nLet&#39;s make the savings concrete before writing any code.\n<strong>Flat table (Milestone 1):</strong></p>\n<ul>\n<li>Size: <code>2^20</code> entries Ã— 4 bytes = <strong>4,194,304 bytes = 4MB</strong>, always, regardless of usage</li>\n<li>A process using 3 pages: 4MB for 3 valid PTEs. 1,048,573 wasted PTEs.\n<strong>Two-level table:</strong></li>\n<li>Level 1: Page directory â€” <code>2^10 = 1024</code> entries Ã— 4 bytes = <strong>4KB</strong>, always allocated (one per process)</li>\n<li>Level 2: Page tables â€” <code>2^10 = 1024</code> entries Ã— 4 bytes = <strong>4KB each</strong>, allocated <em>only when needed</em>\nFor a process using 3 pages that happen to fall in 3 different page directory regions:</li>\n<li>1 page directory: 4KB</li>\n<li>3 second-level page tables: 3 Ã— 4KB = 12KB</li>\n<li><strong>Total: 16KB</strong> instead of 4MB</li>\n<li><strong>Savings: 99.6%</strong> for this workload\nFor a process using 3 pages that fall within the <em>same</em> 4MB region (same page directory entry):</li>\n<li>1 page directory: 4KB</li>\n<li>1 second-level page table: 4KB (covers the whole 4MB region)</li>\n<li><strong>Total: 8KB</strong> instead of 4MB</li>\n<li><strong>Savings: 99.8%</strong>\nFor a process using all of physical memory at maximum density (64 frames, contiguous):</li>\n<li>1 page directory: 4KB</li>\n<li>1 second-level page table: 4KB (64 pages fit within one 4MB region)</li>\n<li><strong>Total: 8KB</strong> â€” far less than 4MB flat table\nThe worst case for a two-level table is a process that uses exactly one page from every possible 4MB region â€” 1024 page directory entries each pointing to a separate second-level table, each containing only one valid PTE. That costs: 4KB + 1024 Ã— 4KB = <strong>4100KB â‰ˆ 4MB</strong> â€” matching the flat table in the absolute worst case. But this access pattern is pathological and never occurs in real programs.</li>\n</ul>\n<hr>\n<h2 id=\"the-virtual-address-decomposition-three-fields-now\">The Virtual Address Decomposition: Three Fields Now</h2>\n<p>In Milestone 1, you split a 32-bit virtual address into two parts: a 20-bit VPN and a 12-bit offset. Now you split it into <em>three</em> parts: a page directory index, a page table index, and the same 12-bit offset.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>32-bit virtual address (4,294,967,296 byte address space):\n 31                22 21                12 11                 0\n â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n â”‚  DIR INDEX (10b) â”‚ TABLE INDEX (10b)â”‚    OFFSET (12b)      â”‚\n â”‚  bits [31:22]    â”‚  bits [21:12]    â”‚   bits [11:0]        â”‚\n â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n        â†“                   â†“                   â†“\n Index into the        Index into the       Byte within\n page directory        page table           the physical frame\n (1024 entries)        (1024 entries)       (unchanged in\n                                            physical addr)</code></pre></div>\n<p>Each 10-bit index can address 2^10 = 1024 entries. At the page directory level, each entry covers a region of 1024 Ã— 4096 = <strong>4,194,304 bytes = 4MB</strong> of virtual address space. At the page table level, each entry covers exactly one 4KB page.</p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m3-address-split-two-level.svg\" alt=\"Two-Level Address Decomposition: Dir Index + Table Index + Offset\"></p>\n<p>The extraction functions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Address decomposition for two-level page table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Bit layout (32-bit virtual address, 4KB pages):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   bits [31:22] â€” page directory index (PDI): 10 bits, 0â€“1023</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   bits [21:12] â€” page table index    (PTI): 10 bits, 0â€“1023</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   bits [11:0]  â€” page offset              : 12 bits, 0â€“4095</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Each level has 1024 entries Ã— 4 bytes = 4KB per table â€” exactly one page.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This is deliberate: each table fits in a single physical frame.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PD_INDEX_BITS</span><span style=\"color:#79B8FF\">    10</span><span style=\"color:#F97583\">u</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PT_INDEX_BITS</span><span style=\"color:#79B8FF\">    10</span><span style=\"color:#F97583\">u</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_OFFSET_BITS</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#F97583\">u</span><span style=\"color:#6A737D\">   /* unchanged from Milestone 1 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PD_INDEX_SHIFT</span><span style=\"color:#E1E4E8\">   (PT_INDEX_BITS </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> PAGE_OFFSET_BITS)</span><span style=\"color:#6A737D\">  /* 22 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PT_INDEX_SHIFT</span><span style=\"color:#E1E4E8\">   (PAGE_OFFSET_BITS)</span><span style=\"color:#6A737D\">                   /* 12 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PD_SIZE</span><span style=\"color:#E1E4E8\">          (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> PD_INDEX_BITS)</span><span style=\"color:#6A737D\">   /* 1024 entries */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PT_SIZE</span><span style=\"color:#E1E4E8\">          (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> PT_INDEX_BITS)</span><span style=\"color:#6A737D\">   /* 1024 entries */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PD_INDEX_MASK</span><span style=\"color:#E1E4E8\">    ((</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> PD_INDEX_BITS) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   /* 0x3FF */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PT_INDEX_MASK</span><span style=\"color:#E1E4E8\">    ((</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> PT_INDEX_BITS) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">   /* 0x3FF */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_OFFSET_MASK</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> PAGE_OFFSET_BITS) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\"> /* 0xFFF */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> pd_index</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (vaddr </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> PD_INDEX_SHIFT) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PD_INDEX_MASK;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> pt_index</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (vaddr </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> PT_INDEX_SHIFT) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PT_INDEX_MASK;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> page_offset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> vaddr </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PAGE_OFFSET_MASK;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><strong>Verify with a concrete example.</strong> Take virtual address <code>0x004056A8</code>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>0x004056A8 in binary:\n  0000 0000 0100 0000 0101 0110 1010 1000\nbits [31:22] = 00 0000 0001 = 0x001 = 1     â†’ PDI = 1\nbits [21:12] = 00 0000 0101 = 0x005 = 5     â†’ PTI = 5\nbits [11:0]  = 0110 1010 1000 = 0x6A8 = 1704 â†’ offset = 1704</code></pre></div>\n<h2 id=\"the-walk-page_directory1-find-the-second-level-page-table-page_table5-pfn-physical-address-pfn-ltlt-12-0x6a8-pitfall-most-significant-bits-select-the-directory-this-is-the-most-common-mistake-you-might-instinctively-grab-the-low-bits-of-the-vpn-for-the-directory-index-and-the-high-bits-for-the-table-index-the-correct-ordering-is-the-most-significant-bits-of-the-virtual-address-select-the-top-level-directory-think-of-it-like-a-postal-code-the-largest-geographical-unit-country-comes-first-then-region-then-city-the-high-bits-of-a-virtual-address-identify-the-coarse-region-the-lower-bits-identify-the-fine-grained-page-within-that-region\">The walk: <code>page_directory[1]</code> â†’ find the second-level page table â†’ <code>page_table[5]</code> â†’ PFN â†’ physical address = <code>(PFN &lt;&lt; 12) | 0x6A8</code>.\n<strong>Pitfall â€” most significant bits select the directory.</strong> This is the most common mistake. You might instinctively grab the <em>low</em> bits of the VPN for the directory index and the <em>high</em> bits for the table index. The correct ordering is: the <em>most significant</em> bits of the virtual address select the top-level directory. Think of it like a postal code: the largest geographical unit (country) comes first, then region, then city. The high bits of a virtual address identify the coarse region; the lower bits identify the fine-grained page within that region.</h2>\n<h2 id=\"the-cr3-register-the-root-of-everything\">The CR3 Register: The Root of Everything</h2>\n<blockquote>\n<p><strong>ğŸ”‘ Foundation: CR3 is a CPU register holding the physical address of the active process&#39;s top-level page directory</strong></p>\n<p><strong>What it IS</strong>\nThe CR3 register (Control Register 3) is a specialized x86 CPU register that acts as the &quot;root&quot; of the virtual memory system. It stores the physical address of the top-level page directory (in 64-bit mode, this is the PML4 table). Every time the CPU needs to translate a virtual address into a physical one, it starts its journey by looking at the address held in CR3.</p>\n</blockquote>\n<p><strong>WHY you need it right now</strong>\nIn systems programming, particularly when writing a kernel or a hypervisor, you are responsible for defining how memory is mapped. Loading a value into CR3 is the definitive act of &quot;turning on&quot; or &quot;switching&quot; a virtual address space. When an operating system switches from Process A to Process B, it isn&#39;t moving data in RAM; it is simply loading Process B&#39;s page table address into CR3. This instantly changes the CPU&#39;s entire view of the world.</p>\n<p><strong>Key Insight / Mental Model</strong>\nThink of CR3 as the <strong>&quot;You Are Here&quot; pointer on a master map</strong>. The page tables are the map of the entire city, but the CPU canâ€™t see the map until you hand it the coordinate for the very first page. Changing CR3 is like swapping the entire map of New York for a map of London in a single instruction.</p>\n<p>On real x86 hardware, the <code>CR3</code> register (Control Register 3) holds the physical base address of the currently active page directory. Every address translation begins with CR3. The hardware page walker reads CR3, uses it to fetch the page directory, walks down the tree, and arrives at a PTE.\nIn your simulator, you&#39;ll model CR3 as a field in your simulator state â€” a physical address pointing to the root page directory of the active process.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Page Directory Entry (PDE) â€” entry in the top-level page directory.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * A PDE is NOT a PTE. It does NOT point to a physical frame for data.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * It points to the PHYSICAL BASE ADDRESS of a second-level page table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Bit layout:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [31:12] â€” physical base address of second-level page table (20 bits)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *             This is 4KB-aligned (low 12 bits are zero), so only 20 bits needed.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [11:1]  â€” reserved / available for OS use</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [0]     â€” present bit: 1 = second-level table exists, 0 = not allocated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * When present=0: the entire 4MB region this entry covers is unmapped.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * No second-level table is allocated. NULL pointer semantics.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Size: 4 bytes per PDE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * A full page directory: 1024 Ã— 4 = 4096 bytes = exactly 1 physical page.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#79B8FF\"> pde_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_PRESENT</span><span style=\"color:#E1E4E8\">      (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_PT_ADDR_MASK</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FFFFF000</span><span style=\"color:#F97583\">u</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  /* bits [31:12] */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_PT_ADDR_SHIFT</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#F97583\">u</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> pde_is_present</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">pde_t</span><span style=\"color:#FFAB70\"> pde</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (pde </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PDE_PRESENT) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> pde_get_pt_phys</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">pde_t</span><span style=\"color:#FFAB70\"> pde</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pde </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PDE_PT_ADDR_MASK;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#79B8FF\"> pde_t</span><span style=\"color:#B392F0\"> pde_make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> pt_phys_base</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* pt_phys_base must be 4KB-aligned */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (pt_phys_base </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PDE_PT_ADDR_MASK) </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PDE_PRESENT;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m3-pde-vs-pte.svg\" alt=\"Page Directory Entry vs Page Table Entry â€” Structural Comparison\"></p>\n<p><strong>The critical distinction: PDE vs PTE.</strong> A PDE points to a page table structure â€” a metadata object that itself contains more entries. A PTE points to an actual physical frame where user data lives. Confusing these is the #1 structural error in Milestone 3. When you follow a PDE, you arrive at another table. When you follow a PTE, you arrive at data.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Page Table Entry (PTE) â€” unchanged from Milestone 1.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Reproduced here for clarity; use the same pte_t typedef.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * A PTE points to a PHYSICAL FRAME (data).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * A PDE points to a PHYSICAL FRAME (containing a page table).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Both are 4 bytes. The difference is in what the pointed-to frame contains.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#79B8FF\"> pte_t</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* same as Milestone 1 */</span></span></code></pre></div>\n<hr>\n<h2 id=\"the-full-data-model-two-level-simulator-state\">The Full Data Model: Two-Level Simulator State</h2>\n<p>Now define the complete data structures for the multi-level simulator. Notice the fundamental change: the page table is no longer a flat <code>pte_t[1048576]</code> array. It&#39;s a tree rooted at a page directory.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdbool.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Physical memory â€” unchanged from Milestone 1 concept, reused here</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PAGE_SIZE</span><span style=\"color:#79B8FF\">       4096</span><span style=\"color:#F97583\">u</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> NUM_FRAMES</span><span style=\"color:#79B8FF\">      64</span><span style=\"color:#F97583\">u</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">[PAGE_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\">    in_use;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">physical_frame_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">physical_frame_t</span><span style=\"color:#FFAB70\"> phys_mem</span><span style=\"color:#E1E4E8\">[NUM_FRAMES];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Page directory â€” one per process, always allocated at process creation.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Contains 1024 PDEs. Total size: 1024 Ã— 4 = 4096 bytes = 1 physical page.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pde_t</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[PD_SIZE];</span><span style=\"color:#6A737D\">   /* 1024 page directory entries */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Second-level page table â€” allocated on demand, one per 4MB region.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Contains 1024 PTEs. Total size: 1024 Ã— 4 = 4096 bytes = 1 physical page.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[PT_SIZE];</span><span style=\"color:#6A737D\">   /* 1024 page table entries */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Process address space â€” owns one page directory and up to 1024</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * second-level page tables, allocated on demand.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In a real OS, these structures live IN physical memory (as page-sized</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * objects assigned specific physical frames). In the simulator, we use</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * heap allocation and track overhead separately.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Memory cost (worst case):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   1 page_directory_t:              4,096 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   up to 1024 page_table_t:  1024 Ã— 4,096 = 4,194,304 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Total worst case:         ~4 MB â€” same as flat table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Typical sparse process:   4KB + few Ã— 4KB â‰ª 4MB</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pgdir;</span><span style=\"color:#6A737D\">       /* root page directory (always allocated) */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#F97583\">     *</span><span style=\"color:#FFAB70\">pgtables</span><span style=\"color:#E1E4E8\">[PD_SIZE];</span><span style=\"color:#6A737D\"> /* second-level tables, NULL if not present */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\">          asid;</span><span style=\"color:#6A737D\">        /* address space ID for TLB (Milestone 2) */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Overhead tracking */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\">            pt_bytes_allocated;</span><span style=\"color:#6A737D\"> /* bytes used by page table structures */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Simulator state â€” adds CR3 and multi-process support</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\">  *</span><span style=\"color:#E1E4E8\">active_process;</span><span style=\"color:#6A737D\">    /* currently executing process             */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">    cr3;</span><span style=\"color:#6A737D\">               /* physical address of active page dir     */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * In the simulator, cr3 is symbolic â€” it identifies which process_t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * is active rather than a literal physical address, because we use</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * heap-allocated page directory structs. In a real system, cr3 would</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * be the actual physical address of the pgdir frame.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Statistics */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    total_accesses;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    page_faults;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    protection_faults;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    pt_walks;</span><span style=\"color:#6A737D\">          /* number of page table walks performed    */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    tlb_hits;</span><span style=\"color:#6A737D\">          /* tracked here for combined reporting     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">ml_simulator_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n<hr>\n<h2 id=\"allocating-structures-the-simulated-memory-manager\">Allocating Structures: The Simulated Memory Manager</h2>\n<p>In a real OS, page directories and page tables are themselves stored in physical frames â€” they&#39;re just pages of memory with a specific interpretation. The OS maintains a free-frame list and assigns frames to page table structures as needed.\nIn your simulator, you&#39;ll use <code>malloc()</code> for simplicity, but you&#39;ll track every allocation byte-for-byte so your overhead comparison is accurate.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Allocate a new second-level page table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * All PTEs initialized to 0 (valid=0, all permissions cleared).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In a real OS: claim one physical frame, zero it, record it as a page table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Here: heap alloc + memset.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns NULL on allocation failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">alloc_page_table</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">proc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">pt) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(pt, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->pt_bytes_allocated </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pt;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Initialize a new process with an empty two-level page table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Allocates the page directory immediately (always needed).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Second-level tables start as NULL (allocated on demand).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> asid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">proc) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->pgdir </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">proc->pgdir) { </span><span style=\"color:#B392F0\">free</span><span style=\"color:#E1E4E8\">(proc); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(proc->pgdir, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#E1E4E8\">));</span><span style=\"color:#6A737D\">   /* all PDEs: present=0 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> PD_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->pgtables[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* no second-level tables yet */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->asid               </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proc->pt_bytes_allocated </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  /* 4KB for pgdir */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> proc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Free all page table memory for a process on exit.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Walks the directory and frees every allocated second-level table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> process_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">proc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> PD_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (proc->pgtables[i]) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            free</span><span style=\"color:#E1E4E8\">(proc->pgtables[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(proc->pgdir);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(proc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Memory overhead report for one process.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Compares actual allocation vs flat-table cost.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> process_print_overhead</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">proc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> flat_cost     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)PD_SIZE </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> PT_SIZE </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">pte_t</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> /* 4MB */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> actual_cost   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->pt_bytes_allocated;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">    tables_alloc  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> PD_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (proc->pgtables[i]) tables_alloc</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"=== Page Table Memory Overhead (ASID=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">) ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, proc->asid);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Flat table cost:        </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes (</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> KB)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           flat_cost, flat_cost </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Two-level actual cost:  </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> bytes (</span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> KB)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           actual_cost, actual_cost </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Page directory:         4096 bytes (always)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Second-level tables:    </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> allocated Ã— 4096 = </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> bytes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           tables_alloc, tables_alloc </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 4096</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Savings:                </span><span style=\"color:#79B8FF\">%.1f%%\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">           100.0</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)actual_cost </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)flat_cost));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"the-page-table-walk-following-the-chain\">The Page Table Walk: Following the Chain</h2>\n<p>The two-level page table walk is the core algorithm of this milestone. You follow a chain of pointers â€” CR3 â†’ page directory â†’ page table â†’ PTE â†’ physical frame â€” with the option to short-circuit at any level if a <code>NULL</code>/not-present entry indicates the region is unmapped.</p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m3-page-table-walk.svg\" alt=\"Two-Level Page Table Walk â€” Complete Data Walk\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Two-level page table walk.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Given a virtual address and access type, traverses:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   CR3 â†’ page_directory[PDI] â†’ page_table[PTI] â†’ PFN</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * On-demand allocation: if the page directory entry for PDI has present=0,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * we have two choices:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - For a data access: page fault (the region is unmapped)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - For a demand-paging fault: allocate a second-level table + new frame</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Return values:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   XLATE_SUCCESS    â€” paddr is valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   XLATE_PAGE_FAULT â€” page not present (resolved via demand paging if OOM ok)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   XLATE_PROT_FAULT â€” permission violation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   XLATE_OOM        â€” no free frames for demand paging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#B392F0\"> ml_translate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ml_simulator_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sim</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">access_type_t</span><span style=\"color:#FFAB70\"> atype</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sim->total_accesses</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pdi    </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pd_index</span><span style=\"color:#E1E4E8\">(vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pti    </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pt_index</span><span style=\"color:#E1E4E8\">(vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> page_offset</span><span style=\"color:#E1E4E8\">(vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sim->active_process;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Level 1: Consult the page directory.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * If the PDE is not present, the entire 4MB region is unmapped.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Demand-allocate a second-level page table for this region.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">pde_is_present</span><span style=\"color:#E1E4E8\">(proc->pgdir->entries[pdi])) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * DEMAND ALLOCATION of second-level page table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * This is analogous to demand paging but for the page TABLE ITSELF:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * we only create the 1024-entry page table structure when the first</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * access to that 4MB region occurs.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">new_pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_page_table</span><span style=\"color:#E1E4E8\">(proc);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">new_pt) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[OOM] Cannot allocate second-level page table \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    \"for PDI=</span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pdi);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_OOM };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->pgtables[pdi] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_pt;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Update the PDE to point to the new page table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * In a real OS, new_pt's physical address would be a frame number</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Ã— 4096. In the simulator, we store the pointer cast to uint32_t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * for lookup, but the PDE conceptually holds a physical address.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * To keep physical addressing clean, we track the pgtables[] array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * directly and use PDI as the index. The PDE present bit signals</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * that the entry is valid.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->pgdir->entries[pdi] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pde_make</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)new_pt</span><span style=\"color:#6A737D\">   /* symbolic physical address */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        );</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Log the on-demand allocation */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[PT ALLOC] PDI=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">: allocated new page table \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"(total PT memory: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> KB)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                pdi, proc->pt_bytes_allocated </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Level 2: Consult the second-level page table.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sim->pt_walks</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pt  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->pgtables[pdi];</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">pt->entries[pti];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Is this specific page in physical memory?</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_VALID)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Page fault: demand-page this specific page */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sim->page_faults</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[PAGE FAULT] vaddr=0x</span><span style=\"color:#79B8FF\">%08X</span><span style=\"color:#9ECBFF\">  PDI=</span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">  PTI=</span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                vaddr, pdi, pti);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_free_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT32_MAX) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[OOM] No free frames â€” need page replacement \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    \"(Milestone 4)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_OOM };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Install PTE pointing to newly allocated frame */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pte_make</span><span style=\"color:#E1E4E8\">(frame,</span><span style=\"color:#6A737D\"> /*readable=*/</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                        /*writable=*/</span><span style=\"color:#E1E4E8\">(atype </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Permission check â€” only after confirming valid=1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (atype </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_PERM_WRITE)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sim->protection_faults</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[PROT FAULT] Write to read-only page \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"vaddr=0x</span><span style=\"color:#79B8FF\">%08X\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_PROT_FAULT };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Update access metadata */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_REFERENCED;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (atype </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_DIRTY;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pfn   </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pte_get_pfn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> paddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make_physical_addr</span><span style=\"color:#E1E4E8\">(pfn, offset);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_SUCCESS,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .paddr  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> paddr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .pfn    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pfn,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m3-on-demand-allocation.svg\" alt=\"On-Demand Second-Level Table Allocation\"></p>\n<h2 id=\"the-critical-ordering-invariant-you-must-check-the-pde-before-dereferencing-the-second-level-page-table-pointer-dereferencing-a-null-pgtablespdi-is-undefined-behavior-in-c-it-won39t-raise-a-controlled-page-fault-it-will-crash-your-simulator-with-a-segfault-the-pde_is_present-check-is-your-guard\"><strong>The critical ordering invariant:</strong> You must check the PDE <em>before</em> dereferencing the second-level page table pointer. Dereferencing a NULL <code>pgtables[pdi]</code> is undefined behavior in C â€” it won&#39;t raise a controlled page fault, it will crash your simulator with a segfault. The <code>pde_is_present()</code> check is your guard.</h2>\n<h2 id=\"on-demand-second-level-table-allocation-the-full-picture\">On-Demand Second-Level Table Allocation: The Full Picture</h2>\n<p>The on-demand allocation pattern deserves explicit visualization. The first access to any virtual address in a previously unmapped 4MB region triggers <em>two</em> allocations before data access is possible:</p>\n<ol>\n<li><strong>Page table allocation</strong>: A new 4KB <code>page_table_t</code> is allocated to represent that 4MB region</li>\n<li><strong>Frame allocation</strong>: A physical frame is allocated for the actual page being accessed\nThese are separate costs. The page table allocation overhead is amortized across all pages in that 4MB region â€” the second access within the same region incurs only the frame allocation.</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>First access to 0x00401000 (PDI=1, PTI=1, offset=0x000):\nBefore:\n  proc-&gt;pgdir-&gt;entries[1] = 0x00000000 (present=0)\n  proc-&gt;pgtables[1]       = NULL\nStep 1 â€” Allocate page table for PDI=1:\n  new_pt = malloc(sizeof(page_table_t))  // 4096 bytes, zeroed\n  proc-&gt;pgtables[1]       = new_pt\n  proc-&gt;pgdir-&gt;entries[1] = pde_make(new_pt)  // present=1\nStep 2 â€” Page fault for PDI=1, PTI=1:\n  frame = alloc_free_frame()  // e.g., frame 0\n  pt-&gt;entries[1] = pte_make(0, readable=1, writable=1)\nStep 3 â€” Return physical address:\n  paddr = (0 &lt;&lt; 12) | 0x000 = 0x00000000\nSecond access to 0x004050A8 (PDI=1, PTI=5, offset=0x0A8):\nBefore:\n  proc-&gt;pgdir-&gt;entries[1] = pde_make(new_pt)  (present=1, pt already exists)\n  proc-&gt;pgtables[1]       = new_pt\n  new_pt-&gt;entries[5]      = 0x00000000 (valid=0 â€” this PTI not yet mapped)\nStep 1 â€” PDE present: SKIP page table allocation (already done)\nStep 2 â€” Page fault for PDI=1, PTI=5:\n  frame = alloc_free_frame()  // e.g., frame 1\n  pt-&gt;entries[5] = pte_make(1, readable=1, writable=1)\nStep 3 â€” Return physical address:\n  paddr = (1 &lt;&lt; 12) | 0x0A8 = 0x000010A8</code></pre></div>\n<h2 id=\"the-page-table-allocation-only-fires-once-per-directory-region-no-matter-how-many-pages-within-that-region-are-subsequently-accessed-this-is-the-memory-efficiency-of-the-hierarchical-approach-made-concrete\">The page table allocation only fires once per directory region, no matter how many pages within that region are subsequently accessed. This is the memory efficiency of the hierarchical approach made concrete.</h2>\n<h2 id=\"context-switching-with-cr3\">Context Switching with CR3</h2>\n<p>Context switching between processes now has a clean, hardware-mirroring implementation. The OS loads the incoming process&#39;s page directory address into CR3, and from that point all translations use the new process&#39;s address space.</p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m3-cr3-context-switch.svg\" alt=\"CR3 Register and Context Switch\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Simulate a context switch between processes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In real hardware:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   MOV CR3, new_pgdir_physical_address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This single instruction switches the entire virtual address space.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * The hardware page walker immediately uses the new CR3 for all subsequent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * translations.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * TLB handling on context switch:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Option A (no ASID support): flush TLB entirely on every switch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Option B (with ASID): update active_asid, preserve all TLB entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * For Milestone 3, we integrate with the TLB from Milestone 2.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * The force_flush flag lets you test both modes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> ml_context_switch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ml_simulator_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sim</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                        process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">new_proc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> force_flush</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">old_proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sim->active_process;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[CTX SWITCH] ASID </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> â†’ ASID </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">  (CR3: </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\"> â†’ </span><span style=\"color:#79B8FF\">%p</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           old_proc </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> old_proc->asid </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           new_proc->asid,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           old_proc </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)old_proc->pgdir </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           (</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)new_proc->pgdir);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (force_flush) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Naive mode: flush entire TLB on every context switch.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Cost: all cached translations are evicted. New process starts cold.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Used by older CPUs without ASID/PCID support, and by Linux's KPTI</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * path on CPUs without PCID (post-Meltdown mitigation).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (tlb) </span><span style=\"color:#B392F0\">tlb_flush_all</span><span style=\"color:#E1E4E8\">(tlb, old_proc </span><span style=\"color:#F97583\">?</span><span style=\"color:#6A737D\"> /*dummy pt*/</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * ASID mode: just switch the active ASID.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Old process's TLB entries become invisible (wrong ASID).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * New process's TLB entries (if any from a previous time slice)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * become immediately visible.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         * Cost: zero cache pollution â€” both processes' entries coexist.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (tlb) tlb->active_asid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_proc->asid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Update simulator CR3 */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sim->active_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_proc;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sim->cr3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)new_proc->pgdir;</span><span style=\"color:#6A737D\">  /* symbolic */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"the-cr3-register-is-the-physical-manifestation-of-process-isolation-when-you-execute-ml_context_switch-the-entire-virtual-address-space-changes-process-a39s-0x00401000-and-process-b39s-0x00401000-are-completely-independent-they-refer-to-different-ptes-in-different-page-directories-which-map-to-different-physical-frames-the-address-0x00401000-means-nothing-without-the-cr3-that-establishes-the-context-for-its-interpretation\"><strong>The CR3 register is the physical manifestation of process isolation.</strong> When you execute <code>ml_context_switch()</code>, the entire virtual address space changes. Process A&#39;s <code>0x00401000</code> and Process B&#39;s <code>0x00401000</code> are completely independent â€” they refer to different PTEs in different page directories, which map to different physical frames. The address <code>0x00401000</code> means nothing without the CR3 that establishes the context for its interpretation.</h2>\n<h2 id=\"integrating-with-the-tlb-the-full-three-level-view\">Integrating with the TLB: The Full Three-Level View</h2>\n<p>Now that you have both a TLB (Milestone 2) and a two-level page table (this milestone), wire them together to complete the address translation pipeline.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Full address translation: TLB â†’ two-level page table walk.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Three-Level View:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Application Level:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Code reads array[i] at virtual address 0x00401050.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Simulator Level (this function):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   1. Check TLB for (VPN=0x401, ASID=active)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   2a. TLB HIT:  return (PFN from TLB &#x3C;&#x3C; 12) | offset</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   2b. TLB MISS: walk two-level page table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *       CR3 â†’ pgdir[PDI=1] â†’ pgtable[PTI=1] â†’ PTE â†’ PFN</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *       Insert (VPN, PFN) into TLB</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   3. Physical address = (PFN &#x3C;&#x3C; 12) | offset</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Hardware Level:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   CPU MMU checks TLB in parallel with L1 cache index computation.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   On TLB miss: hardware page walker reads pgdir and pgtable from RAM</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   (2 memory accesses for two-level; 4 for x86-64's four-level tables).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   On PTE.present=0: #PF exception â†’ OS page fault handler.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#B392F0\"> full_translate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ml_simulator_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sim</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">access_type_t</span><span style=\"color:#FFAB70\"> atype</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sim->total_accesses</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vpn    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> vaddr </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> PAGE_OFFSET_BITS;</span><span style=\"color:#6A737D\">   /* 20-bit combined VPN */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> vaddr </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PAGE_OFFSET_MASK;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * TLB lookup (if TLB present â€” tlb may be NULL for testing walk only)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tlb) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        tlb_lookup_t</span><span style=\"color:#E1E4E8\"> tr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> tlb_lookup</span><span style=\"color:#E1E4E8\">(tlb, vpn, atype);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (tr.result </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> XLATE_TLB_HIT) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sim->tlb_hits</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> paddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make_physical_addr</span><span style=\"color:#E1E4E8\">(tr.pfn, offset);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_SUCCESS, .paddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> paddr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              .pfn </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tr.pfn };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (tr.result </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> XLATE_PROT_FAULT_TLB) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sim->protection_faults</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_PROT_FAULT };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* TLB miss: fall through to page table walk */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Two-level page table walk (TLB miss path)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pdi </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pd_index</span><span style=\"color:#E1E4E8\">(vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pti </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pt_index</span><span style=\"color:#E1E4E8\">(vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sim->active_process;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Level 1: page directory */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">pde_is_present</span><span style=\"color:#E1E4E8\">(proc->pgdir->entries[pdi])) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">new_pt </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_page_table</span><span style=\"color:#E1E4E8\">(proc);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">new_pt) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_OOM };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->pgtables[pdi] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_pt;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc->pgdir->entries[pdi] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pde_make</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)new_pt);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Level 2: page table */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sim->pt_walks</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pt  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->pgtables[pdi];</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">pt->entries[pti];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_VALID)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sim->page_faults</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_free_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT32_MAX) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_OOM };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pte_make</span><span style=\"color:#E1E4E8\">(frame, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, (atype </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (atype </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_PERM_WRITE)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sim->protection_faults</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_PROT_FAULT };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_REFERENCED;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (atype </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_DIRTY;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pfn   </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pte_get_pfn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> paddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make_physical_addr</span><span style=\"color:#E1E4E8\">(pfn, offset);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Insert into TLB for future accesses */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tlb) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> writable </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_PERM_WRITE) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        tlb_insert</span><span style=\"color:#E1E4E8\">(tlb,</span><span style=\"color:#6A737D\"> /*pt=*/</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, vpn, pfn, writable,</span><span style=\"color:#6A737D\"> /*use_random=*/</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">){ .result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> XLATE_SUCCESS, .paddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> paddr, .pfn </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pfn };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"why-tlb-miss-costs-more-with-multi-level-tables-in-milestone-1-with-a-flat-table-a-tlb-miss-cost-one-memory-access-reading-page_tableentriesvpn-with-a-two-level-table-a-tlb-miss-costs-two-memory-accesses-one-to-read-the-pde-from-the-page-directory-and-one-to-read-the-pte-from-the-second-level-table-this-is-why-the-tlb-matters-even-more-with-hierarchical-tables-each-additional-level-multiplies-the-miss-penalty-on-real-x86-64-with-four-level-tables-a-tlb-miss-costs-four-memory-accesses-one-per-level-this-is-why-x86-64-cpus-have-a-dedicated-hardware-page-walker-that-handles-these-four-accesses-using-a-separate-non-pipelined-path-and-why-hardware-prefetchers-try-to-predict-page-table-accesses\"><strong>Why TLB miss costs more with multi-level tables.</strong> In Milestone 1 with a flat table, a TLB miss cost one memory access (reading <code>page_table.entries[vpn]</code>). With a two-level table, a TLB miss costs two memory accesses: one to read the PDE from the page directory, and one to read the PTE from the second-level table. This is why the TLB matters even more with hierarchical tables â€” each additional level multiplies the miss penalty. On real x86-64 with four-level tables, a TLB miss costs four memory accesses (one per level). This is why x86-64 CPUs have a dedicated hardware page walker that handles these four accesses using a separate non-pipelined path, and why hardware prefetchers try to predict page table accesses.</h2>\n<h2 id=\"memory-overhead-comparison-the-numbers-that-matter\">Memory Overhead Comparison: The Numbers That Matter</h2>\n<p>Let&#39;s implement a concrete measurement framework to quantify the savings:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Overhead comparison: simulate the same access pattern under flat and</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * two-level tables, then report the page table memory consumed by each.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This makes the memory efficiency benefit measurable, not just theoretical.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\">   pt_bytes;</span><span style=\"color:#6A737D\">      /* bytes consumed by page table structures */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pages_mapped;</span><span style=\"color:#6A737D\">  /* number of distinct pages that were accessed */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pt2_count;</span><span style=\"color:#6A737D\">     /* number of second-level tables allocated */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">overhead_report_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">overhead_report_t</span><span style=\"color:#B392F0\"> measure_flat_overhead</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> pages_mapped</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Flat table overhead is constant regardless of pages_mapped.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * The entire 1M-entry array is allocated at process creation.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">overhead_report_t</span><span style=\"color:#E1E4E8\">){</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .pt_bytes    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\">)PD_SIZE </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> PT_SIZE </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">pte_t</span><span style=\"color:#E1E4E8\">),</span><span style=\"color:#6A737D\">  /* 4MB */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .pages_mapped </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pages_mapped,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .pt2_count   </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#6A737D\">   /* no second-level concept */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">overhead_report_t</span><span style=\"color:#B392F0\"> measure_twolevel_overhead</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">proc</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pt2_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pages_mapped </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> pdi </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; pdi </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> PD_SIZE; pdi</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">proc->pgtables[pdi]) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pt2_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> pti </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; pti </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> PT_SIZE; pti</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (proc->pgtables[pdi]->entries[pti] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_VALID) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                pages_mapped</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">overhead_report_t</span><span style=\"color:#E1E4E8\">){</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .pt_bytes    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->pt_bytes_allocated,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .pages_mapped </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pages_mapped,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .pt2_count   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pt2_count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> print_overhead_comparison</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> overhead_report_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">flat</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                const</span><span style=\"color:#79B8FF\"> overhead_report_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">two_level</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•‘       Page Table Memory Overhead Report       â•‘</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•£</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•‘ Metric                 â•‘  Flat   â•‘ Two-Level â•‘</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•£</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•‘ Pages mapped           â•‘ </span><span style=\"color:#79B8FF\">%7u</span><span style=\"color:#9ECBFF\"> â•‘ </span><span style=\"color:#79B8FF\">%9u</span><span style=\"color:#9ECBFF\"> â•‘</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           flat->pages_mapped, two_level->pages_mapped);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•‘ PT structures (bytes)  â•‘ </span><span style=\"color:#79B8FF\">%7zu</span><span style=\"color:#9ECBFF\"> â•‘ </span><span style=\"color:#79B8FF\">%9zu</span><span style=\"color:#9ECBFF\"> â•‘</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           flat->pt_bytes, two_level->pt_bytes);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•‘ PT structures (KB)     â•‘ </span><span style=\"color:#79B8FF\">%7zu</span><span style=\"color:#9ECBFF\"> â•‘ </span><span style=\"color:#79B8FF\">%9zu</span><span style=\"color:#9ECBFF\"> â•‘</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           flat->pt_bytes </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">, two_level->pt_bytes </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•‘ L2 tables allocated    â•‘       â€” â•‘ </span><span style=\"color:#79B8FF\">%9u</span><span style=\"color:#9ECBFF\"> â•‘</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           two_level->pt2_count);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•‘ Bytes per mapped page  â•‘ </span><span style=\"color:#79B8FF\">%7zu</span><span style=\"color:#9ECBFF\"> â•‘ </span><span style=\"color:#79B8FF\">%9zu</span><span style=\"color:#9ECBFF\"> â•‘</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           flat->pt_bytes </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (flat->pages_mapped </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> flat->pages_mapped </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           two_level->pt_bytes </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (two_level->pages_mapped </span><span style=\"color:#F97583\">?</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  two_level->pages_mapped </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•£</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    double</span><span style=\"color:#E1E4E8\"> savings </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#F97583\"> -</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)two_level->pt_bytes </span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)flat->pt_bytes);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•‘ Memory savings         â•‘       â€” â•‘   </span><span style=\"color:#79B8FF\">%6.1f%%</span><span style=\"color:#9ECBFF\"> â•‘</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, savings);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><strong>Expected output for a sparse process using 5 pages spread across 5 different 4MB regions:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘       Page Table Memory Overhead Report       â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘ Metric                 â•‘  Flat   â•‘ Two-Level â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘ Pages mapped           â•‘       5 â•‘         5 â•‘\nâ•‘ PT structures (bytes)  â•‘ 4194304 â•‘     24576 â•‘\nâ•‘ PT structures (KB)     â•‘    4096 â•‘        24 â•‘\nâ•‘ L2 tables allocated    â•‘       â€” â•‘         5 â•‘\nâ•‘ Bytes per mapped page  â•‘  838860 â•‘      4915 â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘ Memory savings         â•‘       â€” â•‘    99.4%  â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•</code></pre></div>\n<h2 id=\"994-savings-for-a-sparse-process-using-5-pages-this-is-not-a-toy-improvement-it39s-the-difference-between-a-system-supporting-100-processes-and-one-supporting-10000\">99.4% savings for a sparse process using 5 pages. This is not a toy improvement â€” it&#39;s the difference between a system supporting 100 processes and one supporting 10,000.</h2>\n<h2 id=\"stretch-goal-three-level-page-tables\">Stretch Goal: Three-Level Page Tables</h2>\n<p>The two-level design works perfectly for 32-bit address spaces. But 64-bit address spaces pose a new problem: a full 64-bit address space has 2^52 possible pages (with 4KB pages). Even two levels can&#39;t cover this efficiently. Real 64-bit systems use three, four, or five levels.\nFor 32-bit addresses, a three-level split of <code>2 + 9 + 9 + 12</code> is a useful exercise:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code> 31           30 29                21 20               12 11              0\n â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n â”‚  L1 (2b)  â”‚     L2 (9b)      â”‚     L3 (9b)      â”‚    OFFSET (12b)      â”‚\n â”‚  bits[31:30]â”‚   bits[29:21]   â”‚   bits[20:12]   â”‚    bits[11:0]        â”‚\n â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n       â†“               â†“                  â†“                    â†“\n  4 entries       512 entries        512 entries           4096 bytes\n  (top dir)     (mid tables)        (leaf tables)</code></pre></div>\n\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m3-three-level-stretch.svg\" alt=\"Three-Level Page Table Structure (Stretch Goal)\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Three-level page table configuration (stretch goal).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Address split: 2 + 9 + 9 + 12 for 32-bit, 4KB pages.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Level 1 (root): 2^2 = 4 entries Ã— 4 bytes = 16 bytes (tiny root)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Level 2 (mid):  2^9 = 512 entries Ã— 4 bytes = 2048 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Level 3 (leaf): 2^9 = 512 entries Ã— 4 bytes = 2048 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This is less natural for 32-bit (4 root entries is extremely small)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * but mirrors the structure of 64-bit systems like x86-64, where</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * the top levels also have few entries covering enormous address ranges.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * x86-64 actual split (4-level, 48-bit addresses):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   PGD(9) + PUD(9) + PMD(9) + PTE(9) + offset(12) = 48 bits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * x86-64 LA57 split (5-level, 57-bit addresses):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   P4D(9) + PGD(9) + PUD(9) + PMD(9) + PTE(9) + offset(12) = 57 bits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> L1_BITS</span><span style=\"color:#79B8FF\">   2</span><span style=\"color:#F97583\">u</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> L2_BITS</span><span style=\"color:#79B8FF\">   9</span><span style=\"color:#F97583\">u</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> L3_BITS</span><span style=\"color:#79B8FF\">   9</span><span style=\"color:#F97583\">u</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/* offset = 12, total = 32 âœ“ */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> L1_SHIFT</span><span style=\"color:#E1E4E8\">  (L2_BITS </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> L3_BITS </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> PAGE_OFFSET_BITS)</span><span style=\"color:#6A737D\">  /* 30 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> L2_SHIFT</span><span style=\"color:#E1E4E8\">  (L3_BITS </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> PAGE_OFFSET_BITS)</span><span style=\"color:#6A737D\">             /* 21 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> L3_SHIFT</span><span style=\"color:#E1E4E8\">  (PAGE_OFFSET_BITS)</span><span style=\"color:#6A737D\">                        /* 12 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> L1_SIZE</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> L1_BITS)</span><span style=\"color:#6A737D\">   /* 4   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> L2_SIZE</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> L2_BITS)</span><span style=\"color:#6A737D\">   /* 512 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> L3_SIZE</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> L3_BITS)</span><span style=\"color:#6A737D\">   /* 512 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> L1_MASK</span><span style=\"color:#E1E4E8\">   ((</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> L1_BITS) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> L2_MASK</span><span style=\"color:#E1E4E8\">   ((</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> L2_BITS) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> L3_MASK</span><span style=\"color:#E1E4E8\">   ((</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> L3_BITS) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> l1_index</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> (vaddr </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> L1_SHIFT) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> L1_MASK; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> l2_index</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> (vaddr </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> L2_SHIFT) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> L2_MASK; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> inline</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> l3_index</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> (vaddr </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> L3_SHIFT) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> L3_MASK; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Three-level page table structures.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * A leaf table (L3) contains PTEs pointing to physical frames.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Mid tables (L2) contain PDEs pointing to leaf tables.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Root (L1) contains PDEs pointing to mid tables.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Walk: L1[l1] â†’ L2[l2] â†’ L3[l3] â†’ PFN â†’ paddr</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Memory cost for a single 3-page sparse process:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   L1 root:    4 entries Ã— 4 bytes  = 16 bytes (always)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   L2 tables:  up to 3 Ã— 2KB = 6144 bytes (one per distinct L1 region)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   L3 tables:  up to 3 Ã— 2KB = 6144 bytes (one per distinct L2 region)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Total:      ~12KB vs 4MB flat = 99.7% savings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">pde_t</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[L2_SIZE]; } </span><span style=\"color:#79B8FF\">l2_table_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">pte_t</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[L3_SIZE]; } </span><span style=\"color:#79B8FF\">l3_table_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pde_t</span><span style=\"color:#FFAB70\">      root</span><span style=\"color:#E1E4E8\">[L1_SIZE];</span><span style=\"color:#6A737D\">            /* L1: 4 entries             */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    l2_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">l2tables</span><span style=\"color:#E1E4E8\">[L1_SIZE];</span><span style=\"color:#6A737D\">       /* L2: allocated on demand   */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    l3_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">l3tables</span><span style=\"color:#E1E4E8\">[L1_SIZE][L2_SIZE];</span><span style=\"color:#6A737D\"> /* L3: allocated on demand */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">three_level_pt_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Three-level page table walk.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns PFN, or UINT32_MAX if not mapped (triggers demand allocation).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * The structure is identical to the two-level walk, but with one</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * additional level of indirection inserted between root and leaf.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> three_level_walk</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">three_level_pt_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                           access_type_t</span><span style=\"color:#FFAB70\"> atype</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> i1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> l1_index</span><span style=\"color:#E1E4E8\">(vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> i2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> l2_index</span><span style=\"color:#E1E4E8\">(vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> i3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> l3_index</span><span style=\"color:#E1E4E8\">(vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Level 1 â†’ Level 2 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(pt3->root[i1] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PDE_PRESENT)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pt3->l2tables[i1] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> calloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">l2_table_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">pt3->l2tables[i1]) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pt3->root[i1] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pde_make</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)pt3->l2tables[i1]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Level 2 â†’ Level 3 */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    l2_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">l2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pt3->l2tables[i1];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(l2->entries[i2] </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PDE_PRESENT)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pt3->l3tables[i1][i2] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> calloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">l3_table_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">pt3->l3tables[i1][i2]) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        l2->entries[i2] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pde_make</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)pt3->l3tables[i1][i2]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Level 3 â†’ PTE */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    l3_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">l3  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pt3->l3tables[i1][i2];</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#F97583\">      *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">l3->entries[i3];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_VALID)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> alloc_free_frame</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT32_MAX) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pte_make</span><span style=\"color:#E1E4E8\">(frame, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, (atype </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_REFERENCED;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (atype </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_DIRTY;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> pte_get_pfn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"building-and-testing\">Building and Testing</h2>\n<h3 id=\"compile\">Compile</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -Wall</span><span style=\"color:#79B8FF\"> -Wextra</span><span style=\"color:#79B8FF\"> -O2</span><span style=\"color:#79B8FF\"> -std=c11</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> vmsim_m3</span><span style=\"color:#9ECBFF\"> vmsim_m3.c</span></span></code></pre></div>\n<h3 id=\"test-1-address-decomposition-correctness\">Test 1: Address Decomposition Correctness</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_address_decomposition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Test vector: 0x004056A8</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Expected: PDI=1, PTI=5, offset=0x6A8</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">004056A8</span><span style=\"color:#F97583\">u</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">pd_index</span><span style=\"color:#E1E4E8\">(vaddr)  </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">pt_index</span><span style=\"color:#E1E4E8\">(vaddr)  </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">page_offset</span><span style=\"color:#E1E4E8\">(vaddr) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">6A8</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test vector: 0x00C00000 (exactly at PDI=3, PTI=0, offset=0) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> v2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">00C00000</span><span style=\"color:#F97583\">u</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">pd_index</span><span style=\"color:#E1E4E8\">(v2)  </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">pt_index</span><span style=\"color:#E1E4E8\">(v2)  </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">page_offset</span><span style=\"color:#E1E4E8\">(v2) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Test vector: 0xFFFFFFFF (max 32-bit address) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> v3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFFFFFFF</span><span style=\"color:#F97583\">u</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">pd_index</span><span style=\"color:#E1E4E8\">(v3)  </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1023</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   /* bits[31:22] = 0x3FF */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">pt_index</span><span style=\"color:#E1E4E8\">(v3)  </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1023</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   /* bits[21:12] = 0x3FF */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">page_offset</span><span style=\"color:#E1E4E8\">(v3) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">FFF</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Address decomposition test: PASSED</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"test-2-on-demand-table-allocation\">Test 2: On-Demand Table Allocation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_ondemand_allocation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(proc);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Before any access: no second-level tables */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> PD_SIZE; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(proc->pgtables[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">pde_is_present</span><span style=\"color:#E1E4E8\">(proc->pgdir->entries[i]));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(proc->pt_bytes_allocated </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#E1E4E8\">));</span><span style=\"color:#6A737D\">   /* 4KB */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ml_simulator_t</span><span style=\"color:#E1E4E8\"> sim </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { .active_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc };</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_phys_mem</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* First access to PDI=0 region â€” should allocate L2 table */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    xlate_t</span><span style=\"color:#E1E4E8\"> r1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ml_translate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00001000</span><span style=\"color:#E1E4E8\">, ACCESS_READ);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(r1.result </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> XLATE_SUCCESS);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(proc->pgtables[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   /* L2 table for PDI=0 created */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">pde_is_present</span><span style=\"color:#E1E4E8\">(proc->pgdir->entries[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(proc->pgtables[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   /* other regions untouched */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> after_first </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->pt_bytes_allocated;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(after_first </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Second access to different page in SAME PDI=0 region */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    xlate_t</span><span style=\"color:#E1E4E8\"> r2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ml_translate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00002000</span><span style=\"color:#E1E4E8\">, ACCESS_READ);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(r2.result </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> XLATE_SUCCESS);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* No new L2 table should be allocated â€” same PDI=0 */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(proc->pt_bytes_allocated </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> after_first);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Access to PDI=1 region â€” should allocate a second L2 table */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    xlate_t</span><span style=\"color:#E1E4E8\"> r3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ml_translate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00401000</span><span style=\"color:#E1E4E8\">, ACCESS_READ);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(r3.result </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> XLATE_SUCCESS);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(proc->pgtables[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(proc->pt_bytes_allocated </span><span style=\"color:#F97583\">==</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           after_first </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"On-demand allocation test: PASSED</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    process_destroy</span><span style=\"color:#E1E4E8\">(proc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"test-3-memory-overhead-comparison\">Test 3: Memory Overhead Comparison</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_overhead_comparison</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Access 5 pages spread across 5 different 4MB regions.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * PDI values: 0, 1, 2, 3, 4 (one page per region)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ml_simulator_t</span><span style=\"color:#E1E4E8\"> sim </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { .active_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc };</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_phys_mem</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> test_addrs</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        0x</span><span style=\"color:#79B8FF\">00001000</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   /* PDI=0, PTI=1 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        0x</span><span style=\"color:#79B8FF\">00401000</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   /* PDI=1, PTI=1 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        0x</span><span style=\"color:#79B8FF\">00801000</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   /* PDI=2, PTI=1 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        0x</span><span style=\"color:#79B8FF\">00C01000</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   /* PDI=3, PTI=1 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        0x</span><span style=\"color:#79B8FF\">01001000</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   /* PDI=4, PTI=1 */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        xlate_t</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ml_translate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim, </span><span style=\"color:#FFAB70\">test_addrs</span><span style=\"color:#E1E4E8\">[i], ACCESS_READ);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        assert</span><span style=\"color:#E1E4E8\">(r.result </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> XLATE_SUCCESS);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    overhead_report_t</span><span style=\"color:#E1E4E8\"> flat </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> measure_flat_overhead</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    overhead_report_t</span><span style=\"color:#E1E4E8\"> two  </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> measure_twolevel_overhead</span><span style=\"color:#E1E4E8\">(proc);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(flat.pt_bytes   </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 4194304</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   /* exactly 4MB */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(two.pt_bytes    </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 4096</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  /* 1 pgdir + 5 pgtables = 24KB */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(two.pt2_count   </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(two.pages_mapped </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    print_overhead_comparison</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">flat, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">two);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Overhead comparison test: PASSED</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    process_destroy</span><span style=\"color:#E1E4E8\">(proc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"test-4-cr3-context-switch-isolation\">Test 4: CR3 Context Switch Isolation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_cr3_isolation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_phys_mem</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    tlb_t</span><span style=\"color:#E1E4E8\"> tlb;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    tlb_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ml_simulator_t</span><span style=\"color:#E1E4E8\"> sim </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { .active_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> p1, .cr3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)p1->pgdir };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Process 1: write to 0x00001000 */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    xlate_t</span><span style=\"color:#E1E4E8\"> r1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> full_translate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00001000</span><span style=\"color:#E1E4E8\">, ACCESS_WRITE);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(r1.result </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> XLATE_SUCCESS);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> p1_paddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> r1.paddr;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Context switch to Process 2 */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ml_context_switch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb, p2,</span><span style=\"color:#6A737D\"> /*force_flush=*/</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(sim.active_process </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> p2);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(tlb.active_asid </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Process 2: read same virtual address â€” must get a DIFFERENT physical address */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    xlate_t</span><span style=\"color:#E1E4E8\"> r2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> full_translate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">tlb, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00001000</span><span style=\"color:#E1E4E8\">, ACCESS_READ);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(r2.result </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> XLATE_SUCCESS);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(r2.paddr </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> p1_paddr);</span><span style=\"color:#6A737D\">   /* isolated: different PFN */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CR3 isolation test: PASSED</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    process_destroy</span><span style=\"color:#E1E4E8\">(p1);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    process_destroy</span><span style=\"color:#E1E4E8\">(p2);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"test-5-pde-vs-pte-structural-distinction\">Test 5: PDE vs PTE Structural Distinction</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_pde_vs_pte_distinction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Verify that PDE entries point to page TABLES (not data frames)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * and PTE entries point to data frames.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ml_simulator_t</span><span style=\"color:#E1E4E8\"> sim </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { .active_process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc };</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    init_phys_mem</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    xlate_t</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ml_translate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sim, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">00401000</span><span style=\"color:#E1E4E8\">, ACCESS_READ);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(r.result </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> XLATE_SUCCESS);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* The PDE for PDI=1 must be present */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pde_t</span><span style=\"color:#E1E4E8\"> pde </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->pgdir->entries[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">pde_is_present</span><span style=\"color:#E1E4E8\">(pde));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* The address in the PDE must point to the allocated page table */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* (In simulator: pgtables[1] is non-NULL) */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(proc->pgtables[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* The PTE for PTI=1 in that page table must be valid */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#E1E4E8\"> pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> proc->pgtables[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]->entries[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_VALID);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* The PFN in the PTE must be a valid frame number */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pfn </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pte_get_pfn</span><span style=\"color:#E1E4E8\">(pte);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(pfn </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> NUM_FRAMES);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">phys_mem</span><span style=\"color:#E1E4E8\">[pfn].in_use);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PDE vs PTE distinction test: PASSED</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    process_destroy</span><span style=\"color:#E1E4E8\">(proc);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"common-pitfalls-and-how-to-avoid-them\">Common Pitfalls and How to Avoid Them</h2>\n<table>\n<thead>\n<tr>\n<th>Pitfall</th>\n<th>Symptom</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Index extraction in wrong order</td>\n<td>PDI gets low bits, PTI gets high bits â€” wrong regions mapped</td>\n<td>High bits â†’ directory (coarse), low bits â†’ table (fine)</td>\n</tr>\n<tr>\n<td>Checking PTE permission before PDE present</td>\n<td>NULL pointer dereference when <code>pgtables[pdi] == NULL</code></td>\n<td>Always check PDE present before accessing <code>pgtables[pdi]</code></td>\n</tr>\n<tr>\n<td>Confusing PDE and PTE structures</td>\n<td>A PDE stored in <code>entries[pti]</code> of a leaf table â€” type confusion</td>\n<td>PDE points to tables; PTE points to frames. Types differ.</td>\n</tr>\n<tr>\n<td>Not accounting for page table memory in overhead</td>\n<td>Overhead report shows only data frames, not PT structure cost</td>\n<td>Track <code>pt_bytes_allocated</code> separately from data frames</td>\n</tr>\n<tr>\n<td>Forgetting that page table structures occupy frames in real OS</td>\n<td>Simulator works fine; mental model for real OS is wrong</td>\n<td>In production: pgdir and pgtables steal frames from user data</td>\n</tr>\n<tr>\n<td>Clearing PDE when a page is evicted</td>\n<td>PDE cleared causes loss of entire 4MB mapping region</td>\n<td>Only clear the PTE for the evicted page; leave PDE and PT intact</td>\n</tr>\n<tr>\n<td>Forgetting TLB flush on page table modification</td>\n<td>Stale TLB entry returns old PFN after PTE update</td>\n<td>Call <code>tlb_flush_page(vpn)</code> whenever a PTE&#39;s PFN changes</td>\n</tr>\n<tr>\n<td><code>pde_make()</code> losing low bits (non-aligned pointers)</td>\n<td>PT address stored in PDE is corrupted</td>\n<td>Assert <code>sizeof(page_table_t) == 4096</code> and use aligned allocations</td>\n</tr>\n<tr>\n<td><strong>The non-aligned pointer pitfall deserves elaboration.</strong> Your <code>pde_make()</code> function encodes the page table address in bits <code>[31:12]</code>, preserving only 20 bits of the address. This works only if the page table is 4KB-aligned (low 12 bits are zero). <code>malloc()</code> does <em>not</em> guarantee 4KB alignment â€” it typically gives 8 or 16-byte alignment. In a real OS, page tables are stored in physical frames (inherently 4KB-aligned). In your simulator, use <code>aligned_alloc(PAGE_SIZE, sizeof(page_table_t))</code> or <code>posix_memalign()</code> to ensure alignment, or use a symbolic pointer approach (store pointer directly in a separate array, not in the PDE bits).</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>For the simulator, the cleanest approach is to store the actual C pointer in <code>proc-&gt;pgtables[]</code> and use the PDE purely as a present/absent flag, consulting the pointer array for the actual address. This avoids alignment issues while preserving the conceptual model.</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"hardware-soul-what-real-silicon-does\">Hardware Soul: What Real Silicon Does</h2>\n<p>Your simulator builds page directory and page table structures in heap memory. Real hardware does something subtly but importantly different â€” and understanding the difference deepens your mental model of what these structures are.\n<strong>Page table structures live in physical frames.</strong> In Linux, when a new process is created via <code>fork()</code> or <code>exec()</code>, the kernel allocates physical frames for the page directory and initial page tables from its own free frame pool â€” the same pool used for user data. The frames containing page tables are not special in hardware; they&#39;re ordinary RAM frames that the OS and MMU interpret as containing page table data. The CR3 register holds the <em>physical</em> address of the frame containing the top-level page directory. The hardware page walker follows the CR3 value as a literal memory address, reads the PDE, follows that as another literal memory address, and so on. There&#39;s no OS call, no indirection â€” just hardware reading from physical RAM addresses.\n<strong>Multi-level page table walk costs: 2 memory accesses for two-level.</strong> Each level requires one DRAM access to fetch the directory or table entry. For your two-level table, a TLB miss costs 2 Ã— 100ns = 200ns in DRAM accesses before even accessing the data. For x86-64&#39;s four-level table, it&#39;s 4 Ã— 100ns = 400ns â€” 1200 CPU cycles at 3GHz lost to page walking on every TLB miss. This is why:</p>\n<ol>\n<li><strong>TLB hit rate dominates performance more than page table level count.</strong> A 98% hit rate with four-level tables beats a 90% hit rate with two-level tables in most workloads.</li>\n<li><strong>Hardware page walkers are dedicated units.</strong> Modern x86-64 CPUs have a separate hardware state machine that walks page tables without stalling the CPU pipeline â€” it runs concurrently with other pipeline stages where possible.</li>\n<li><strong>Page table entries are cached in L1/L2.</strong> The hardware page walker generates regular memory reads. These are cached by the CPU&#39;s standard L1/L2/L3 cache hierarchy. If the page directory entry is in L1 cache (64 bytes, covering 16 PDEs), the walk costs ~4ns instead of 100ns. Processes with access patterns that keep their active PDE/PTE hot in cache amortize walk costs dramatically.\n<strong>Cache line analysis for your structures:</strong></li>\n</ol>\n<ul>\n<li><code>page_directory_t</code>: 1024 Ã— 4 bytes = 4096 bytes = 64 cache lines. Accessing PDI=0 and PDI=1 (consecutive entries) hits the same cache line. Accessing PDI=0 and PDI=32 hits different cache lines (offset 0 vs offset 128).</li>\n<li><code>page_table_t</code>: same analysis. Sequential PTI accesses are cache-friendly. Random PTI accesses across more than 16 slots (64 bytes / 4 bytes per PTE) cause cache misses within the page table itself.</li>\n<li>A process whose virtual address usage is clustered within a few 4MB regions keeps both the PDE and the relevant PTEs warm in cache, making page walks nearly free even on TLB misses.</li>\n</ul>\n<hr>\n<h2 id=\"knowledge-cascade-what-multi-level-page-tables-unlock\">Knowledge Cascade: What Multi-Level Page Tables Unlock</h2>\n<h3 id=\"1-the-multi-level-page-table-is-a-radix-trie\">1. The Multi-Level Page Table IS a Radix Trie</h3>\n<p>This is not a metaphor â€” it&#39;s an exact equivalence. A radix trie (compact prefix trie) is a tree where each edge represents a fixed number of bits of the key, and missing branches are represented as NULL pointers. A two-level page table with 10+10+12 bit split is a radix trie keyed on the 20-bit VPN (the top two fields), with 4096-byte leaves (the pages). The PDI selects the first 10-bit chunk; the PTI selects the next 10-bit chunk.\nThis equivalence is not academic. <strong>IP routing tables</strong> use exactly the same structure â€” Patricia tries (radix trees) over IP prefix bits â€” for longest-prefix match. A router&#39;s forwarding table with 700,000 entries (as in the global BGP table) uses a multi-level trie where NULL pointers at upper levels skip enormous prefix ranges, exactly as NULL PDEs skip 4MB virtual address ranges. Understanding your page table gives you the core data structure intuition for network routing, dictionary compression (compressed tries), and all sparse key-value lookup problems.</p>\n<h3 id=\"2-linux39s-5-level-page-table-the-same-concept-extended\">2. Linux&#39;s 5-Level Page Table: The Same Concept, Extended</h3>\n<p>Linux on x86-64 supports up to 5-level page tables (kernel 4.14+, hardware since Ice Lake 2019) for 57-bit virtual address spaces:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>PGD(9) â†’ P4D(9) â†’ PUD(9) â†’ PMD(9) â†’ PTE(9) + offset(12) = 57 bits</code></pre></div>\n<p>Each level is structurally identical to what you built: a 512-entry table where each entry is either a NULL (not present) pointer or a pointer to the next level. NULL at any level skips 2^(remaining bits) bytes of address space. A NULL PGD entry skips 2^(9+9+9+9+12) = 2^48 = 256 TB of virtual address space. Five levels of this structure can address 2^57 = 128 petabytes â€” more than any current application needs, with sparse coverage making the overhead manageable.\nThe Linux kernel&#39;s <code>mm_struct</code> (the structure describing a process&#39;s memory) contains a <code>pgd_t *pgd</code> field â€” the equivalent of your <code>proc-&gt;pgdir</code>. Context switching in Linux&#39;s <code>__switch_to_asm()</code> includes a <code>mov %0, %%cr3</code> instruction that loads the new process&#39;s page directory base. You just simulated that in <code>ml_context_switch()</code>.</p>\n<h3 id=\"3-sparse-file-systems-inode-indirect-blocks\">3. Sparse File Systems: Inode Indirect Blocks</h3>\n<p>The ext4 filesystem&#39;s inode structure for large files uses a multi-level block pointer design that is structurally identical to a three-level page table:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>inode.direct_blocks[12]     â†’ points directly to data blocks (small files)\ninode.indirect              â†’ points to a block of 1024 block pointers\ninode.double_indirect       â†’ points to a block of 1024 indirect pointers\ninode.triple_indirect       â†’ points to a block of 1024 double-indirect ptrs</code></pre></div>\n<p>This is exactly your PGD â†’ PMD â†’ PTE structure, but over disk blocks instead of physical frames. A small file (â‰¤ 48KB) uses only direct blocks â€” no overhead. A large file allocates indirect blocks on demand. A 1TB file that uses only a few regions allocates only the indirect/double-indirect blocks needed to reach those regions.\n[[EXPLAIN:why-hierarchical/multi-level-indexing-saves-memory-for-sparse-structures|Why hierarchical/multi-level indexing saves memory for sparse structures â€” the connection between page tables, filesystem inode trees, and B-trees]]\nNTFS uses a similar structure via its B-tree master file table. SQLite&#39;s B-tree pages are another instantiation: the tree pages (internal nodes) are allocated on demand as the database grows, exactly as your second-level page tables are allocated on demand as the address space is populated.</p>\n<h3 id=\"4-copy-on-write-fork-sharing-page-table-subtrees\">4. Copy-on-Write fork() â€” Sharing Page Table Subtrees</h3>\n<p>The Unix <code>fork()</code> system call creates a child process that is initially an exact copy of the parent. Naively, this would require copying all of the parent&#39;s mapped pages. With copy-on-write (CoW) and hierarchical page tables, <code>fork()</code> instead:</p>\n<ol>\n<li>Copies only the <em>page directory</em> (4KB), not the second-level tables</li>\n<li>Makes the parent and child share all existing second-level page tables and physical frames</li>\n<li>Marks all shared PTEs as read-only in both parent and child</li>\n<li>When either process writes to a shared page, the hardware raises a protection fault; the OS then copies that specific page, maps it privately in the writing process&#39;s page table, and resumes\nThe key insight is that this is efficient precisely because the page table is hierarchical. Sharing a single PDE allows the child to inherit an entire 4MB address region (with 1024 PTEs) by copying just 4 bytes. If the child never writes to that region, the second-level table and all 1024 frames are shared forever at zero copy cost. The savings compound across the entire 4GB address space â€” <code>fork()</code> for a large process is O(number of mapped PDE entries), not O(number of mapped pages).\nThis is why Redis (which uses <code>fork()</code> for background saves) performs so well: the BGSAVE child process shares nearly all of Redis&#39;s memory with the parent via CoW. Only the pages that are actually modified during the save (by incoming write commands) need to be copied. For read-heavy workloads, CoW fork saves 99%+ of the copy cost.</li>\n</ol>\n<h3 id=\"5-memory-mapped-device-io-single-pde-for-a-region\">5. Memory-Mapped Device I/O â€” Single PDE for a Region</h3>\n<p>Hardware devices (GPU framebuffer, network card registers, PCIe BAR regions) are mapped into the virtual address space at specific physical addresses. With a two-level page table, an entire 4MB device region can be described by setting a single PDE to point to a page table where each of the 1024 PTEs maps to successive physical frames of the device&#39;s memory region. One 4-byte PDE describes 4MB of device address space. This is how <code>mmap(&quot;/dev/mem&quot;, ...)</code> works on Linux, and how GPU drivers map video RAM into process virtual address space.</p>\n<h3 id=\"6-huge-pages-collapsing-levels-for-performance\">6. Huge Pages â€” Collapsing Levels for Performance</h3>\n<blockquote>\n<p><strong>ğŸ”‘ Foundation: Huge pages</strong></p>\n<p><strong>What it IS</strong>\nStandard memory paging uses 4KB &quot;frames.&quot; Huge pages allow the hardware to map much larger contiguous blocksâ€”typically 2MB or 1GBâ€”using a single entry in the page table hierarchy. Instead of the translation process going through four levels to find a tiny 4KB slice, the CPU stops &quot;early&quot; at a higher level (like the Page Directory) and treats that entire branch as one massive, continuous page.</p>\n</blockquote>\n<p><strong>WHY you need it right now</strong>\nMemory translation is expensive. To speed it up, the CPU uses a small, lightning-fast cache called the Translation Lookaside Buffer (TLB) to store recent virtual-to-physical mappings. However, the TLB has very few slots (often only a few hundred).</p>\n<ul>\n<li>If you map 1GB of RAM using <strong>4KB pages</strong>, you need <strong>262,144</strong> TLB entries to cover it. You will constantly &quot;miss&quot; the cache and stall the CPU.</li>\n<li>If you map 1GB of RAM using <strong>one 1GB huge page</strong>, you need <strong>exactly 1</strong> TLB entry.\nThis drastically reduces &quot;TLB pressure,&quot; allowing the CPU to spend more time executing code and less time walking page tables in RAM.</li>\n</ul>\n<p><strong>Key Insight / Mental Model</strong>\nThe <strong>&quot;Warehouse vs. Envelopes&quot;</strong> model. Mapping memory with 4KB pages is like trying to track a shipment of 1,000,000 items by putting each one in its own envelope with its own tracking number. Using huge pages is like putting all 1,000,000 items into a single shipping container with one single tracking number. One label (TLB entry) covers the entire load.</p>\n<h2 id=\"with-standard-4kb-pages-a-2mb-allocation-requires-512-ptes-across-potentially-many-cache-lines-in-the-page-table-with-a-2mb-huge-page-the-pmd-entry-in-a-4-level-table-directly-maps-2mb-using-a-single-table-entry-the-leaf-level-pte-is-skipped-entirely-the-entry-in-the-middle-level-table-pmd-sets-a-special-quothuge-pagequot-bit-and-the-physical-address-points-directly-to-a-2mb-aligned-physical-region-in-your-simulator-you-could-implement-huge-pages-by-adding-a-huge-flag-to-pde-entries-if-set-the-pde39s-physical-address-points-directly-to-a-4mb-data-region-aligned-to-4mb-skipping-the-second-level-table-entirely-the-address-decomposition-changes-for-an-access-to-a-quothugequot-pde-the-physical-address-is-pde_pfn_base-vaddr-amp-0x3fffff-the-bottom-22-bits-become-the-offset-within-the-4mb-region-this-is-exactly-why-postgresql-and-redis-benefit-from-huge-page-configuration-vmnr_hugepages-on-linux-a-256mb-database-buffer-pool-with-4kb-pages-requires-65536-ptes-with-2mb-huge-pages-it-requires-128-pmd-entries-the-tlb-pressure-drops-by-512\">With standard 4KB pages, a 2MB allocation requires 512 PTEs across potentially many cache lines in the page table. With a 2MB huge page, the PMD entry (in a 4-level table) directly maps 2MB using a single table entry â€” the leaf level (PTE) is skipped entirely. The entry in the middle-level table (PMD) sets a special &quot;huge page&quot; bit and the physical address points directly to a 2MB-aligned physical region.\nIn your simulator, you could implement huge pages by adding a <code>huge</code> flag to PDE entries: if set, the PDE&#39;s physical address points directly to a 4MB data region (aligned to 4MB), skipping the second-level table entirely. The address decomposition changes: for an access to a &quot;huge&quot; PDE, the physical address is <code>pde_pfn_base + (vaddr &amp; 0x3FFFFF)</code> (the bottom 22 bits become the offset within the 4MB region).\nThis is exactly why PostgreSQL and Redis benefit from huge page configuration (<code>vm.nr_hugepages</code> on Linux): a 256MB database buffer pool with 4KB pages requires 65,536 PTEs; with 2MB huge pages, it requires 128 PMD entries. The TLB pressure drops by 512Ã—.</h2>\n<h2 id=\"what-you39ve-built-and-what39s-missing\">What You&#39;ve Built and What&#39;s Missing</h2>\n<p><strong>You have:</strong></p>\n<ul>\n<li>A two-level hierarchical page table with on-demand second-level table allocation</li>\n<li>A simulated CR3 register driving process-specific address translation</li>\n<li>Correct 10+10+12 address decomposition with extraction functions</li>\n<li>PDE and PTE type distinction with proper handling at each level</li>\n<li>Context switching that changes CR3 and coordinates with the ASID-tagged TLB from Milestone 2</li>\n<li>Quantitative memory overhead measurement and comparison against the flat table</li>\n<li>An optional three-level table implementation following the same structural pattern</li>\n<li>Complete test coverage: decomposition, on-demand allocation, overhead, isolation, type distinction\n<strong>What&#39;s still painful:</strong> All frames are allocated from a fixed pool of 64. Once those 64 frames are claimed by demand paging, the next access triggers <code>XLATE_OOM</code> â€” your simulator just logs an error and gives up. But real virtual memory systems never give up. When physical memory is exhausted, the OS picks a victim page, writes it to disk (if dirty), frees its frame, and uses that frame for the new demand. This is <strong>page replacement</strong> â€” the subject of Milestone 4.\nWith your multi-level page table correctly built, Milestone 4 becomes tractable. Page replacement requires finding a victim PTE (to clear its valid bit and free its frame), writing dirty pages to swap, and reloading them on the next fault. The multi-level structure makes the victim search slightly more complex â€” you need to walk all allocated second-level tables to find candidate pages â€” but structurally the same mechanisms you&#39;ve just built handle the entire flow. The TLB flush on eviction (<code>tlb_flush_page()</code>) that you implemented in Milestone 2 connects directly here: when a frame is reclaimed, you must call <code>tlb_flush_page(vpn)</code> for the evicted page before clearing its PTE.</li>\n</ul>\n<hr>\n<!-- END_MS -->\n\n\n<!-- MS_ID: virtual-memory-sim-m4 -->\n<h1 id=\"milestone-4-page-replacement-and-swap-simulation\">Milestone 4: Page Replacement and Swap Simulation</h1>\n<h2 id=\"the-problem-physical-memory-is-finite-virtual-greed-is-not\">The Problem: Physical Memory Is Finite, Virtual Greed Is Not</h2>\n<h2 id=\"you-have-64-frames-in-your-simulator-after-64-distinct-page-faults-every-frame-is-occupied-the-65th-fault-hits-your-alloc_free_frame-function-which-scans-through-all-frames-finds-none-available-and-returns-uint32_max-your-simulator-logs-oom-no-free-frames-and-gives-up-real-operating-systems-never-give-up-the-linux-kernel-running-a-machine-with-16-gb-of-ram-routinely-handles-workloads-that-would-require-40-gb-if-fully-materialized-in-memory-it-does-this-by-maintaining-the-illusion-that-every-process-has-all-the-memory-it-needs-while-physically-storing-only-the-active-portion-the-working-set-in-ram-everything-else-lives-on-disk-in-a-region-called-swap-space-waiting-to-be-recalled-when-needed-explainswap-space-extending-ram-to-disk-what-39page-out39-and-39page-in39-meanswap-space-extending-ram-to-disk-what-39page-out39-and-39page-in39-mean-how-the-os-extends-the-apparent-size-of-physical-memory-using-disk-storage-this-milestone-is-about-making-the-hard-choice-the-os-always-has-to-make-when-physical-memory-is-full-and-a-new-page-must-be-loaded-which-existing-page-do-you-sacrifice-sacrifice-the-wrong-one-a-page-the-program-needs-again-in-three-instructions-and-you39ve-created-a-chain-of-faults-that-grinds-execution-to-a-halt-choose-well-a-page-that-won39t-be-needed-for-ten-million-accesses-and-the-program-never-notices-the-eviction-happened-that-choice-is-page-replacement-and-it-turns-out-to-be-one-of-the-most-consequential-decisions-an-os-makes-for-application-performance-the-difference-between-a-well-tuned-and-poorly-tuned-replacement-policy-on-a-real-database-server-can-mean-10-throughput-difference-for-the-same-hardware\">You have 64 frames in your simulator. After 64 distinct page faults, every frame is occupied. The 65th fault hits your <code>alloc_free_frame()</code> function, which scans through all frames, finds none available, and returns <code>UINT32_MAX</code>. Your simulator logs <code>[OOM] No free frames</code> and gives up.\nReal operating systems never give up. The Linux kernel, running a machine with 16 GB of RAM, routinely handles workloads that would require 40 GB if fully materialized in memory. It does this by maintaining the illusion that every process has all the memory it needs, while physically storing only the active portion â€” the <em>working set</em> â€” in RAM. Everything else lives on disk, in a region called <strong>swap space</strong>, waiting to be recalled when needed.\n[[EXPLAIN:swap-space:-extending-ram-to-disk,-what-&#39;page-out&#39;-and-&#39;page-in&#39;-mean|Swap space: extending RAM to disk, what &#39;page out&#39; and &#39;page in&#39; mean â€” how the OS extends the apparent size of physical memory using disk storage]]\nThis milestone is about making the hard choice the OS always has to make: when physical memory is full and a new page must be loaded, which <em>existing</em> page do you sacrifice? Sacrifice the wrong one â€” a page the program needs again in three instructions â€” and you&#39;ve created a chain of faults that grinds execution to a halt. Choose well â€” a page that won&#39;t be needed for ten million accesses â€” and the program never notices the eviction happened.\nThat choice is <strong>page replacement</strong>, and it turns out to be one of the most consequential decisions an OS makes for application performance. The difference between a well-tuned and poorly-tuned replacement policy on a real database server can mean 10Ã— throughput difference for the same hardware.</h2>\n<h2 id=\"the-revelation-lru-is-not-the-answer-you-think-it-is\">The Revelation: LRU Is Not the Answer You Think It Is</h2>\n<p>Before writing a single line of code for this milestone, destroy the comfortable myth that computer science textbooks inadvertently instill:\n<em>&quot;LRU is the gold standard page replacement algorithm. Real operating systems use LRU. If you implement LRU, you&#39;re done.&quot;</em>\nEvery part of this statement is wrong in practice, and understanding why is the deepest lesson of this milestone.\n<strong>The fundamental problem with pure LRU:</strong> maintaining true LRU order requires updating data structures on <em>every single memory access</em>. Your program running at 3 GHz might perform 3 billion memory accesses per second. True LRU demands that after every one of those accesses, you update a doubly-linked list â€” moving the accessed node to the front, updating two <code>next</code> and two <code>prev</code> pointers per access. That&#39;s 12 billion pointer writes per second <em>just to maintain the replacement metadata</em>, competing with the actual work your program is doing. The overhead of the bookkeeping would eliminate the benefit of the policy.\n<strong>What hardware actually provides:</strong> The MMU sets a single bit â€” the <em>referenced bit</em> (called the <em>accessed bit</em> in x86 terminology, part of the PTE you built in Milestone 1) â€” when any access to that page occurs. The OS can <em>clear</em> this bit periodically. That&#39;s the entire hardware support for recency information. One bit per page. Not a timestamp, not a list position, not an age counter. One bit that says &quot;has this page been touched since I last cleared this bit?&quot;\n<strong>What real kernels do:</strong></p>\n<ul>\n<li>Linux uses a <strong>two-list approximation</strong>: an &quot;active&quot; list for recently used pages and an &quot;inactive&quot; list for cold candidates. Pages move between lists based on the referenced bit, not on every access.</li>\n<li>FreeBSD uses a <strong>Clock</strong> variant (their &quot;page daemon&quot; with reference-bit clearing).</li>\n<li>macOS/iOS uses a <strong>FIFO with second-chance</strong> structure, tuned for mobile memory pressure.</li>\n<li>None of them use pure LRU.\n<strong>The second revelation â€” BÃ©lÃ¡dy&#39;s anomaly:</strong> FIFO page replacement can produce <em>more</em> page faults with <em>more</em> physical frames. More RAM makes things worse. This sounds impossible â€” how can more memory hurt? â€” but it&#39;s a provable property of FIFO. And it&#39;s not just a toy curiosity: it exposes a fundamental property about what makes replacement algorithms trustworthy for capacity planning.\nYou&#39;ll build all four algorithms â€” FIFO, LRU, Clock, and Optimal â€” and the comparative statistics at the end will show you exactly why the theoretical ranking (Optimal &gt; LRU &gt; Clock &gt; FIFO) doesn&#39;t always hold in practice, and why Clock is the real production workhorse.</li>\n</ul>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m4-replacement-overview.svg\" alt=\"Page Replacement in the Full Translation Pipeline\"></p>\n<hr>\n<h2 id=\"swap-space-the-illusion-of-infinite-memory\">Swap Space: The Illusion of Infinite Memory</h2>\n<p>When the OS evicts a page from a physical frame, where does the data go? If the page is <strong>clean</strong> â€” its contents match what&#39;s on disk (either from the original file it was mapped from, or from a previous write to swap) â€” the frame can simply be reclaimed. The data is already safe elsewhere; discarding the in-RAM copy loses nothing.\nIf the page is <strong>dirty</strong> â€” the program has written to it since it was loaded, and the modified data exists nowhere else â€” discarding it silently would destroy data. The OS must first write the page&#39;s contents to swap space, then free the frame.</p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m4-dirty-clean-eviction-decision.svg\" alt=\"Eviction Decision: Dirty vs Clean Page Cost\"></p>\n<p>This clean/dirty distinction is tracked by the <code>PTE_DIRTY</code> bit you set in Milestone 1. Every write access to a page flips this bit. The eviction path checks it:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Is page dirty?\n  YES â†’ write page data to swap (expensive: disk I/O in a real system)\n        mark page as clean in swap\n        free the frame\n  NO  â†’ frame is free immediately (data unchanged from disk/swap)\n        free the frame</code></pre></div>\n<p>In your simulator, &quot;swap space&quot; is a simple array indexed by Virtual Page Number (VPN). In a real OS, swap is a dedicated disk partition or file (<code>/proc/swaps</code> on Linux shows active swap areas), and &quot;writing to swap&quot; is a block device I/O operation costing 10â€“100 milliseconds â€” roughly 100,000Ã— slower than a memory access.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Simulated swap space.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Indexed by VPN. Each slot stores one page (PAGE_SIZE bytes).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * swap_present[vpn] = true if this VPN has data saved in swap.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In a real OS: a swap partition on disk, addressed by swap slot number.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * The OS maintains a swap map: VPN â†’ swap slot.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Memory cost: NUM_VPN_POSSIBLE Ã— PAGE_SIZE bytes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * For 20-bit VPN (1M pages) at 4KB: 4 GB â€” impractical to actually allocate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Simulator compromise: only allocate swap entries for pages that are</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * actually evicted (sparse swap: use a hash map or fixed-size pool).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Simple version: fixed array of PAGE_SIZE bytes Ã— MAX_SWAP_PAGES.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_SWAP_PAGES</span><span style=\"color:#79B8FF\">   256</span><span style=\"color:#F97583\">u</span><span style=\"color:#6A737D\">    /* maximum number of pages in swap */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  data</span><span style=\"color:#E1E4E8\">[PAGE_SIZE];</span><span style=\"color:#6A737D\">   /* page content saved here on eviction */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vpn;</span><span style=\"color:#6A737D\">               /* which VPN owns this swap slot       */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\">     in_use;</span><span style=\"color:#6A737D\">            /* is this swap slot occupied?          */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">swap_slot_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    swap_slot_t</span><span style=\"color:#FFAB70\"> slots</span><span style=\"color:#E1E4E8\">[MAX_SWAP_PAGES];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    write_backs;</span><span style=\"color:#6A737D\">    /* dirty pages written to swap          */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    page_ins;</span><span style=\"color:#6A737D\">       /* pages loaded back from swap          */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">swap_space_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n<h2 id=\"the-write_backs-counter-is-one-of-your-most-important-statistics-it-counts-the-extra-disk-io-cost-incurred-by-dirty-page-evictions-a-direct-measure-of-how-much-the-replacement-algorithm-is-thrashing-modified-data-in-and-out-of-swap\">The <code>write_backs</code> counter is one of your most important statistics. It counts the extra disk I/O cost incurred by dirty page evictions â€” a direct measure of how much the replacement algorithm is thrashing modified data in and out of swap.</h2>\n<h2 id=\"the-physical-memory-model-frames-and-the-free-pool\">The Physical Memory Model: Frames and the Free Pool</h2>\n<p>Before replacement algorithms can work, you need a clear model of physical memory that tracks not just <em>which</em> frames are free, but <em>which pages</em> currently occupy each frame â€” because the replacement algorithms need to find victims.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Physical frame descriptor.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In a real OS: the kernel maintains a struct page array (one per frame),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * containing reference counts, mapping info, flags, and list linkage.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Linux's struct page is approximately 64 bytes (one cache line).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In your simulator: a simplified version tracking what we need</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * for replacement decisions.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Byte layout:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [0..3]  vpn         â€” which virtual page occupies this frame (UINT32_MAX if free)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [4..7]  load_time   â€” when was this page loaded? (for FIFO: evict smallest)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [8..11] last_access â€” when was this page last accessed? (for LRU: evict smallest)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [12]    ref_bit     â€” referenced since last clock sweep? (for Clock)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [13]    dirty       â€” has this frame been written to? (for write-back decision)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [14]    in_use      â€” is this frame occupied?</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   [15]    pad         â€” alignment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Total: 16 bytes per frame descriptor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Cache line (64 bytes) holds: 4 frame descriptors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vpn;</span><span style=\"color:#6A737D\">           /* virtual page currently mapped here     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> load_time;</span><span style=\"color:#6A737D\">     /* logical time of frame allocation       */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> last_access;</span><span style=\"color:#6A737D\">   /* logical time of last access            */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\">     ref_bit;</span><span style=\"color:#6A737D\">       /* Clock algorithm's reference bit        */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\">     dirty;</span><span style=\"color:#6A737D\">         /* has this page been modified?           */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\">     in_use;</span><span style=\"color:#6A737D\">        /* is the frame occupied?                 */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">frame_desc_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Physical memory pool.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Configurable number of frames. For replacement testing:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - Small (3â€“8 frames): easy to trace by hand, anomalies visible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - Medium (16â€“64): realistic for comparison benchmarks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - Large (256): approximates \"enough memory\" behavior</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> NUM_FRAMES_DEFAULT</span><span style=\"color:#79B8FF\">  16</span><span style=\"color:#F97583\">u</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    frame_desc_t</span><span style=\"color:#FFAB70\"> desc</span><span style=\"color:#E1E4E8\">[NUM_FRAMES_DEFAULT];</span><span style=\"color:#6A737D\">  /* frame metadata          */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">      data</span><span style=\"color:#E1E4E8\">[NUM_FRAMES_DEFAULT][PAGE_SIZE];</span><span style=\"color:#6A737D\"> /* actual content */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">     num_frames;</span><span style=\"color:#6A737D\">                /* configurable size        */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">     clock;</span><span style=\"color:#6A737D\">                     /* logical clock for timestamps */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> phys_mem_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> num_frames</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(pm, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pm));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pm->num_frames </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> num_frames;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> num_frames; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pm->desc[i].vpn     </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span><span style=\"color:#6A737D\">  /* sentinel: no page mapped  */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pm->desc[i].in_use  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Find a free frame, if any.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns frame index, or UINT32_MAX if all frames occupied.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Complexity: O(num_frames) â€” acceptable; real OS maintains a free list O(1).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> phys_find_free</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> pm->num_frames; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">pm->desc[i].in_use) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"the-clock-field-is-a-logical-timestamp-a-global-counter-incremented-on-every-memory-access-you-assign-load_time-when-a-frame-is-claimed-and-last_access-on-every-subsequent-access-to-a-page-in-that-frame-these-timestamps-drive-fifo-and-lru-eviction-decisions-without-requiring-list-manipulation-on-the-common-non-replacement-path\">The <code>clock</code> field is a logical timestamp â€” a global counter incremented on every memory access. You assign <code>load_time</code> when a frame is claimed, and <code>last_access</code> on every subsequent access to a page in that frame. These timestamps drive FIFO and LRU eviction decisions without requiring list manipulation on the common (non-replacement) path.</h2>\n<h2 id=\"the-replacement-interface\">The Replacement Interface</h2>\n<p>All four algorithms share the same external interface. The replacement engine receives the physical memory pool, the swap space, the current page table, and the TLB â€” and returns a newly available frame, having evicted whatever victim it chose.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Replacement policy selector.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Passed to the unified replace_page() dispatcher.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    POLICY_FIFO    </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    POLICY_LRU     </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    POLICY_CLOCK   </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    POLICY_OPTIMAL </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">replacement_policy_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Result of a replacement operation.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> freed_frame;</span><span style=\"color:#6A737D\">    /* the frame number now available for use   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> evicted_vpn;</span><span style=\"color:#6A737D\">    /* which VPN was evicted                    */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\">     was_dirty;</span><span style=\"color:#6A737D\">      /* did we have to write to swap?            */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Unified replacement dispatcher.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Selects a victim, handles dirty write-back, clears the victim's PTE,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * invalidates the TLB entry, and returns the freed frame.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * After this call:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - freed_frame is available for use (in_use=false)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - evicted_vpn's PTE has valid=0 (may have swap data if was_dirty)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - TLB entry for evicted_vpn is invalidated (tlb_flush_page called)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   - If was_dirty: swap_space contains saved data for evicted_vpn</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#B392F0\"> replace_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">swap_space_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">swap</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                               page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                               replacement_policy_t</span><span style=\"color:#FFAB70\"> policy</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                               /* for Optimal only: */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                               const</span><span style=\"color:#79B8FF\"> mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">future</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> future_len</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                               size_t</span><span style=\"color:#FFAB70\"> current_idx</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                               /* for Clock only: */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                               uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">clock_hand</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<h2 id=\"the-key-invariant-this-function-must-maintain-before-the-frame-is-reused-the-tlb-must-be-invalidated-for-the-evicted-vpn-this-is-the-connection-back-to-milestone-239s-tlb_flush_page-skipping-this-step-causes-the-tlb-to-return-a-stale-pfn-for-the-evicted-vpn-pointing-to-a-frame-now-occupied-by-a-different-page39s-data-that39s-the-tlb-coherence-violation-and-it-produces-silent-memory-corruption-with-no-fault-raised\">The key invariant this function must maintain: <strong>before the frame is reused, the TLB must be invalidated for the evicted VPN.</strong> This is the connection back to Milestone 2&#39;s <code>tlb_flush_page()</code>. Skipping this step causes the TLB to return a stale PFN for the evicted VPN â€” pointing to a frame now occupied by a different page&#39;s data. That&#39;s the TLB coherence violation, and it produces silent memory corruption with no fault raised.</h2>\n<h2 id=\"swap-in-and-swap-out-the-data-walk\">Swap In and Swap Out: The Data Walk</h2>\n<p>Before implementing any algorithm, implement the swap operations that all algorithms share. These are called by <code>replace_page()</code> regardless of which policy chose the victim.</p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m4-swap-space-data-walk.svg\" alt=\"Swap Space: Dirty Page Eviction and Reload â€” Data Walk\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Find a swap slot for the given VPN.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns slot index if VPN has data in swap, UINT32_MAX if not.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Complexity: O(MAX_SWAP_PAGES) â€” acceptable for simulation.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> swap_find_slot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> swap_space_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sw</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vpn</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> MAX_SWAP_PAGES; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (sw->slots[i].in_use </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> sw->slots[i].vpn </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> vpn) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Allocate a new swap slot.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns slot index, or UINT32_MAX if swap is full (simulated swap exhaustion).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> swap_alloc_slot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">swap_space_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sw</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vpn</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* First check if this VPN already has a slot (reuse it) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> existing </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> swap_find_slot</span><span style=\"color:#E1E4E8\">(sw, vpn);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (existing </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> UINT32_MAX) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> existing;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> MAX_SWAP_PAGES; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">sw->slots[i].in_use) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sw->slots[i].in_use </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sw->slots[i].vpn    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> vpn;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span><span style=\"color:#6A737D\">   /* swap full â€” swap exhaustion! */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Page-out: write a dirty frame to swap.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Called during eviction when frame_desc.dirty == true.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In a real OS: this triggers a disk write. The process that caused the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * eviction may be blocked (sleeping) until the I/O completes, or the OS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * may run the I/O asynchronously and reclaim the frame later.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In the simulator: memcpy to the swap slot array.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns false if swap is full (cannot evict dirty page â€” critical error).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> swap_page_out</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">swap_space_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sw</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    uint32_t</span><span style=\"color:#FFAB70\"> frame</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vpn</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> slot </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> swap_alloc_slot</span><span style=\"color:#E1E4E8\">(sw, vpn);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (slot </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT32_MAX) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[SWAP FULL] Cannot evict dirty VPN=0x</span><span style=\"color:#79B8FF\">%05X\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, vpn);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Copy frame data to swap slot */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(sw->slots[slot].data, pm->data[frame], PAGE_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sw->write_backs</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[SWAP OUT] VPN=0x</span><span style=\"color:#79B8FF\">%05X</span><span style=\"color:#9ECBFF\"> â†’ swap slot </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> (dirty write-back)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            vpn, slot);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Page-in: load a page back from swap into a freshly freed frame.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Called during page-fault handling when the faulting VPN has data in swap.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In a real OS: disk read, 10â€“100ms latency, process sleeps on I/O.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In the simulator: memcpy from swap slot to frame.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns false if the VPN has no data in swap (first-time fault).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> swap_page_in</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">swap_space_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sw</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   uint32_t</span><span style=\"color:#FFAB70\"> frame</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vpn</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> slot </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> swap_find_slot</span><span style=\"color:#E1E4E8\">(sw, vpn);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (slot </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT32_MAX) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Not in swap: first-time access, zero-fill the frame */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(pm->data[frame], </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, PAGE_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Restore saved data */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memcpy</span><span style=\"color:#E1E4E8\">(pm->data[frame], sw->slots[slot].data, PAGE_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sw->slots[slot].in_use </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* free the swap slot */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sw->page_ins</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[SWAP IN]  VPN=0x</span><span style=\"color:#79B8FF\">%05X</span><span style=\"color:#9ECBFF\"> â† swap slot </span><span style=\"color:#79B8FF\">%u\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, vpn, slot);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"why-freeing-the-swap-slot-on-page-in-matters-once-the-page-is-back-in-ram-dirty-bit-clear-it-was-just-loaded-the-swap-slot-contains-stale-data-if-the-page-is-later-evicted-again-without-being-written-to-it39s-clean-its-on-disk-representation-is-the-original-file-or-zero-fill-for-anonymous-pages-keeping-the-swap-slot-occupied-unnecessarily-wastes-swap-capacity-and-confuses-the-swap_find_slot-logic-on-the-next-eviction\"><strong>Why freeing the swap slot on page-in matters:</strong> Once the page is back in RAM (dirty bit clear â€” it was just loaded), the swap slot contains stale data. If the page is later evicted again <em>without</em> being written to, it&#39;s clean â€” its on-disk representation is the original file (or zero-fill for anonymous pages). Keeping the swap slot occupied unnecessarily wastes swap capacity and confuses the <code>swap_find_slot()</code> logic on the next eviction.</h2>\n<h2 id=\"the-eviction-core-shared-across-all-policies\">The Eviction Core: Shared Across All Policies</h2>\n<p>Once a policy selects a victim frame, the mechanics of eviction are identical regardless of which algorithm chose it:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Evict a specific frame: handle dirty write-back, clear PTE, invalidate TLB.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This is the eviction core â€” called by all four replacement algorithms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * after they've chosen their victim frame.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * INVARIANT: After this call, frame is in_use=false, and victim_vpn's</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * PTE has valid=0. The TLB entry for victim_vpn is invalidated.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#B392F0\"> evict_frame</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">swap_space_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sw</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                              page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                              uint32_t</span><span style=\"color:#FFAB70\"> victim_frame</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    frame_desc_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">pm->desc[victim_frame];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> victim_vpn </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> fd->vpn;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\"> was_dirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> fd->dirty;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Step 1: If dirty, write to swap BEFORE clearing anything.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Order matters: if you clear the PTE first and the write-back fails,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * the page's data is gone with no way to recover it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (was_dirty) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> ok </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> swap_page_out</span><span style=\"color:#E1E4E8\">(pm, sw, victim_frame, victim_vpn);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">ok) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Swap full â€” fatal in simulator; real OS would block or OOM-kill */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[FATAL] Swap full during eviction of VPN=0x</span><span style=\"color:#79B8FF\">%05X\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    victim_vpn);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Return invalid result â€” caller must handle */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#E1E4E8\">){ .freed_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[EVICT]    VPN=0x</span><span style=\"color:#79B8FF\">%05X</span><span style=\"color:#9ECBFF\"> clean â€” frame </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> freed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                victim_vpn, victim_frame);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Step 2: Invalidate the TLB entry for victim_vpn.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * This MUST happen before the frame is reused.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * If a stale TLB entry remains, future accesses to victim_vpn would</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * return a PFN that now belongs to a DIFFERENT page.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (tlb) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        tlb_flush_page</span><span style=\"color:#E1E4E8\">(tlb, pt, victim_vpn);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Step 3: Clear the PTE â€” mark the page as no longer in memory.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * The dirty and referenced bits are cleared; if the page was dirty,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * it's now safely in swap. Permissions are preserved (they're part</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * of the virtual-to-physical mapping that survives eviction).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">pt->entries[victim_vpn];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">(PTE_VALID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PTE_DIRTY </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PTE_REFERENCED);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Note: PTE_PERM_READ, PTE_PERM_WRITE stay â€” they're still valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * for when the page is reloaded from swap. */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Step 4: Reset the frame descriptor for reuse.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fd->vpn         </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fd->in_use      </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fd->ref_bit     </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fd->dirty       </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fd->load_time   </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fd->last_access </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#E1E4E8\">){</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .freed_frame  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> victim_frame,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .evicted_vpn  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> victim_vpn,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .was_dirty    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> was_dirty,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"order-is-life-critical-the-three-operations-write-back-tlb-invalidation-pte-clear-must-happen-in-exactly-this-sequence-write-back-before-pte-clear-ensures-the-data-survives-if-the-write-back-somehow-fails-tlb-invalidation-before-the-frame-is-reused-ensures-no-stale-translations-point-to-the-newly-reassigned-frame-this-ordering-is-the-same-discipline-enforced-in-production-kernels-linux39s-try_to_unmap-pageout-sequence-follows-this-exact-order\"><strong>Order is life-critical.</strong> The three operations â€” write-back, TLB invalidation, PTE clear â€” must happen in exactly this sequence. Write-back before PTE clear ensures the data survives if the write-back somehow fails. TLB invalidation before the frame is reused ensures no stale translations point to the newly reassigned frame. This ordering is the same discipline enforced in production kernels: Linux&#39;s <code>try_to_unmap()</code> + <code>pageout()</code> sequence follows this exact order.</h2>\n<h2 id=\"fifo-the-naive-baseline\">FIFO: The Naive Baseline</h2>\n<p>FIFO (First In, First Out) is the simplest conceivable replacement policy: evict the page that has been in memory the longest. No access tracking, no reference bits, no future knowledge. Just: who got here first, leaves first.</p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m4-fifo-trace-example.svg\" alt=\"FIFO Page Replacement â€” Step-by-Step Trace\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * FIFO replacement: evict the frame with the smallest load_time.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Implementation: scan all frames, find minimum load_time among in_use frames.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Alternative (more efficient): maintain a FIFO queue of frame indices.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Here we scan for simplicity and for consistency with the LRU timestamp approach.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Complexity: O(num_frames) â€” acceptable; real FIFO uses an O(1) queue.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns the index of the victim frame.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> fifo_select_victim</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> victim    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> min_time  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT64_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> pm->num_frames; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">pm->desc[i].in_use) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (pm->desc[i].load_time </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> min_time) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            min_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pm->desc[i].load_time;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            victim   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> victim;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#B392F0\"> replace_fifo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">swap_space_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sw</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                               page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> victim </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fifo_select_victim</span><span style=\"color:#E1E4E8\">(pm);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (victim </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT32_MAX) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[BUG] FIFO: no victim found despite full memory</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#E1E4E8\">){ .freed_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[FIFO] Evicting VPN=0x</span><span style=\"color:#79B8FF\">%05X</span><span style=\"color:#9ECBFF\"> (frame </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">, loaded at t=</span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pm->desc[victim].vpn, victim, pm->desc[victim].load_time);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> evict_frame</span><span style=\"color:#E1E4E8\">(pm, sw, pt, tlb, victim);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"fifo39s-simplicity-is-appealing-its-correctness-is-easy-to-verify-given-any-reference-string-you-can-trace-through-it-by-hand-and-count-faults-this-is-why-it39s-the-standard-baseline-in-os-textbooks-and-the-one-that-exhibits-bldy39s-anomaly-which-we39ll-demonstrate-shortly-fifo39s-fundamental-flaw-it-treats-all-pages-equally-regardless-of-recency-a-page-loaded-at-time-t0-and-accessed-constantly-will-be-evicted-before-a-page-loaded-at-t1-and-never-touched-again-fifo-has-no-concept-of-quotusefulnessquot-only-quotagequot\">FIFO&#39;s simplicity is appealing. Its correctness is easy to verify: given any reference string, you can trace through it by hand and count faults. This is why it&#39;s the standard baseline in OS textbooks and the one that exhibits BÃ©lÃ¡dy&#39;s anomaly â€” which we&#39;ll demonstrate shortly.\n<strong>FIFO&#39;s fundamental flaw:</strong> It treats all pages equally regardless of recency. A page loaded at time T=0 and accessed constantly will be evicted before a page loaded at T=1 and never touched again. FIFO has no concept of &quot;usefulness&quot; â€” only &quot;age.&quot;</h2>\n<h2 id=\"lru-near-optimal-but-impractical-to-implement-honestly\">LRU: Near-Optimal but Impractical to Implement Honestly</h2>\n<p>LRU (Least Recently Used) is theoretically near-optimal. Its intuition is powerful: if you&#39;ve used a page recently, you&#39;re likely to use it again soon (temporal locality). The page you haven&#39;t touched in the longest time is the best eviction candidate.</p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m4-lru-trace-example.svg\" alt=\"LRU Page Replacement â€” Step-by-Step Trace (Same Reference String)\"></p>\n<p>In a simulator, you can implement <em>true</em> LRU using timestamps:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * LRU replacement: evict the frame with the smallest last_access time.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In the simulator: last_access is updated on every access to a page</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * (in the translation path, after TLB miss resolution).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * IMPORTANT: update pm->desc[frame].last_access = pm->clock++ on EVERY</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * access (not just on faults). This is what makes LRU accurate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Without this, LRU degenerates to FIFO (only load time matters).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Hardware reality: real MMUs set only a referenced BIT, not a timestamp.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * True LRU requires software intervention on every access â€” impractical</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * at billions of accesses per second.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns the index of the victim frame.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> lru_select_victim</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> victim    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> min_time  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT64_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> pm->num_frames; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">pm->desc[i].in_use) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (pm->desc[i].last_access </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> min_time) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            min_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pm->desc[i].last_access;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            victim   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> victim;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#B392F0\"> replace_lru</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">swap_space_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sw</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                               page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> victim </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> lru_select_victim</span><span style=\"color:#E1E4E8\">(pm);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (victim </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT32_MAX) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[BUG] LRU: no victim found</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#E1E4E8\">){ .freed_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[LRU] Evicting VPN=0x</span><span style=\"color:#79B8FF\">%05X</span><span style=\"color:#9ECBFF\"> (frame </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">, last accessed t=</span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pm->desc[victim].vpn, victim, pm->desc[victim].last_access);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> evict_frame</span><span style=\"color:#E1E4E8\">(pm, sw, pt, tlb, victim);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><strong>Updating <code>last_access</code> on the translation hot path:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Called in the TLB-miss path after a successful page table walk,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * and on TLB hits (via the frame descriptor update).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This is where the O(1) metadata update happens for our simulated LRU.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In real hardware: this would require hardware support not available.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * In the simulator: we pay the cost willingly for accuracy.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> phys_record_access</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frame</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pm->clock</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pm->desc[frame].last_access </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pm->clock;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pm->desc[frame].ref_bit     </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* also set for Clock algorithm */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m4-lru-implementation-comparison.svg\" alt=\"LRU Implementation: Timestamps vs Doubly-Linked List\"></p>\n<h2 id=\"why-lru-is-impractical-in-hardware-the-last_access-timestamp-requires-64-bits-per-frame-updating-it-on-every-access-means-64-bits-billions-of-accesses-per-second-unacceptable-memory-bandwidth-just-for-bookkeeping-real-hardware-gives-you-one-bit-that39s-the-constraint-that-makes-the-clock-algorithm-the-practical-answer\"><strong>Why LRU is impractical in hardware:</strong> The <code>last_access</code> timestamp requires 64 bits per frame. Updating it on every access means 64 bits Ã— billions of accesses per second = unacceptable memory bandwidth just for bookkeeping. Real hardware gives you one bit. That&#39;s the constraint that makes the Clock algorithm the practical answer.</h2>\n<h2 id=\"the-clock-algorithm-the-production-workhorse\">The Clock Algorithm: The Production Workhorse</h2>\n<p>The Clock algorithm (also called Second-Chance or Not-Recently-Used) is the algorithm that actually ships in operating systems. It achieves near-LRU performance using only the single <code>referenced</code> bit that hardware provides â€” no timestamps, no lists, no per-access bookkeeping.\n[[EXPLAIN:clock-algorithm-conceptual-model-circular-buffer-with-reference-bits|The Clock algorithm conceptual model: a circular buffer of frames with a sweeping hand that clears reference bits on one pass and evicts on the second pass]]\n<strong>The key insight:</strong> A page that has been accessed at any point since the clock hand last swept past it gets a &quot;second chance&quot; â€” its reference bit is cleared instead of the page being evicted. Only pages that the hand encounters with <code>ref_bit=false</code> (meaning they haven&#39;t been accessed since the hand&#39;s last pass) are actual eviction candidates.</p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m4-clock-algorithm.svg\" alt=\"Clock (Second-Chance) Algorithm â€” Circular Buffer Walk\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Clock (Second-Chance) replacement.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * State: clock_hand â€” index into phys_mem[], advances circularly.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *        ref_bit per frame â€” set by hardware on any access, cleared by Clock.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Algorithm:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   While (victim not found):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *     frame = frames[clock_hand]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *     if frame.in_use AND frame.ref_bit == false:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *       â†’ EVICT this frame (it hasn't been accessed since last sweep)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *     else if frame.in_use AND frame.ref_bit == true:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *       â†’ Clear ref_bit (\"second chance\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *       â†’ Advance hand</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *     else (frame not in use):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *       â†’ Advance hand (skip free frames)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Worst case: two full sweeps of all frames before finding a victim.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Average case: O(1) amortized (frames become evictable after ~1 sweep).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * The clock_hand persists across calls â€” it remembers where it stopped.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This is ESSENTIAL: if it restarted from 0 each time, recently-cleared</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * bits would be immediately reconsidered before they accumulate more accesses.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#B392F0\"> replace_clock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">swap_space_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sw</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                                 page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                 uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">clock_hand</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> sweeps </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> max_sweeps </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> pm->num_frames;</span><span style=\"color:#6A737D\">   /* safety: prevent infinite loop */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (sweeps </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> max_sweeps) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">clock_hand;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        frame_desc_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">pm->desc[i];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">clock_hand </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> pm->num_frames;</span><span style=\"color:#6A737D\">   /* advance hand */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sweeps</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">fd->in_use) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* skip free frames */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (fd->ref_bit) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Second chance: clear the bit, move on */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fd->ref_bit </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Also clear the referenced bit in the PTE â€” OS does this too */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pt->entries[fd->vpn] </span><span style=\"color:#F97583\">&#x26;=</span><span style=\"color:#F97583\"> ~</span><span style=\"color:#E1E4E8\">PTE_REFERENCED;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[CLOCK] VPN=0x</span><span style=\"color:#79B8FF\">%05X</span><span style=\"color:#9ECBFF\"> ref_bit cleared, second chance</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    fd->vpn);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* ref_bit is 0: this page hasn't been used since last sweep â€” evict it */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[CLOCK] Evicting VPN=0x</span><span style=\"color:#79B8FF\">%05X</span><span style=\"color:#9ECBFF\"> (frame </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\">, ref_bit=0)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    fd->vpn, i);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> evict_frame</span><span style=\"color:#E1E4E8\">(pm, sw, pt, tlb, i);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * If we swept twice without finding a victim, every frame had ref_bit=1.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * After one full sweep, all bits are cleared; second sweep finds a victim.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * If we still didn't find one â€” BUG (should be impossible).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[BUG] Clock: failed to find victim after </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> sweeps</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, max_sweeps);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#E1E4E8\">){ .freed_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"why-the-clock-hand-persists-across-calls-if-the-hand-reset-to-frame-0-after-every-replacement-it-would-always-evaluate-the-same-frames-first-frames-near-the-start-of-the-array-would-be-evicted-disproportionately-and-frames-at-the-end-would-accumulate-references-without-scrutiny-the-persistent-hand-gives-every-frame-equal-opportunity-to-be-either-protected-by-accumulating-a-reference-bit-or-evicted-by-having-its-bit-swept-clear-hardware-soul-clock-vs-lru-every-memory-access-in-clock-requires-zero-bookkeeping-work-the-mmu-sets-ref_bit-automatically-for-free-the-os39s-clock-daemon-runs-periodically-not-on-every-access-sweeping-through-frames-and-clearing-bits-this-is-why-clock-is-o1-amortized-per-eviction-the-work-is-spread-across-all-accesses-not-concentrated-per-access-lru-with-timestamps-requires-o1-work-per-access-timestamp-update-which-is-3-billion-writessecond-on-a-modern-cpu-clock-requires-oframes_swept-per-eviction-amortized-to-near-zero-per-access\"><strong>Why the clock hand persists across calls:</strong> If the hand reset to frame 0 after every replacement, it would always evaluate the same frames first. Frames near the start of the array would be evicted disproportionately, and frames at the end would accumulate references without scrutiny. The persistent hand gives every frame equal opportunity to be either protected (by accumulating a reference bit) or evicted (by having its bit swept clear).\n<strong>Hardware soul â€” Clock vs LRU:</strong> Every memory access in Clock requires zero bookkeeping work (the MMU sets <code>ref_bit</code> automatically, for free). The OS&#39;s clock daemon runs periodically â€” not on every access â€” sweeping through frames and clearing bits. This is why Clock is O(1) amortized per eviction: the work is spread across all accesses, not concentrated per-access. LRU with timestamps requires O(1) work per <em>access</em> (timestamp update), which is 3 billion writes/second on a modern CPU. Clock requires O(frames_swept) per <em>eviction</em>, amortized to near zero per access.</h2>\n<h2 id=\"the-working-set-model-why-thrashing-happens\">The Working Set Model: Why Thrashing Happens</h2>\n<p>Before implementing Optimal and analyzing the statistics, you need a framework for understanding <em>why</em> page fault rates behave the way they do. The working set model gives you that framework.\n[[EXPLAIN:working-set-model-and-locality-of-reference|Working set model and locality of reference â€” the set of pages actively used in a time window, how it determines the minimum frames needed for efficient execution, and why exceeding it causes thrashing]]\nThe <strong>working set</strong> of a process at time T, with window size Î”, is the set of distinct pages accessed in the interval <code>[T - Î”, T]</code>. If physical memory provides fewer frames than the working set size, the process cannot make progress without constantly faulting â€” this is <strong>thrashing</strong>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Working set tracker.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Maintains a sliding window of the last WINDOW_SIZE accesses.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Working set size = number of distinct VPNs in that window.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This is O(WINDOW_SIZE) per access â€” acceptable for the simulator.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Production systems approximate this with the referenced bit: pages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * with ref_bit=1 in the current epoch are \"in the working set.\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> WORKING_SET_WINDOW</span><span style=\"color:#79B8FF\">  10</span><span style=\"color:#F97583\">u</span><span style=\"color:#6A737D\">   /* configurable */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#FFAB70\">  history</span><span style=\"color:#E1E4E8\">[WORKING_SET_WINDOW];</span><span style=\"color:#6A737D\">  /* ring buffer of recent VPNs */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">  head;</span><span style=\"color:#6A737D\">                          /* next write position         */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">  filled;</span><span style=\"color:#6A737D\">                        /* how many entries are valid  */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">working_set_tracker_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> ws_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">working_set_tracker_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">ws</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(ws, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">ws));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> WORKING_SET_WINDOW; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ws->history[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span><span style=\"color:#6A737D\">  /* sentinel: empty slot */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Record a page access and return the current working set size.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> ws_record_access</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">working_set_tracker_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">ws</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vpn</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Add to ring buffer */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ws->history[ws->head] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> vpn;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ws->head </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (ws->head </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> WORKING_SET_WINDOW;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ws->filled </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> WORKING_SET_WINDOW) ws->filled</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Count distinct VPNs in the window â€” O(WINDOW_SIZE^2) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> distinct </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> ws->filled; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ws->history[i];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (v </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT32_MAX) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        bool</span><span style=\"color:#E1E4E8\"> is_duplicate </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> i; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (ws->history[j] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> v) { is_duplicate </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">break</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">is_duplicate) distinct</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> distinct;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m4-working-set-window.svg\" alt=\"Working Set Size Over Time â€” Sliding Window Visualization\"></p>\n<h2 id=\"thrashing-detection-track-the-working-set-size-over-time-if-ws_size-gt-pm-gtnum_frames-consistently-you39re-in-a-thrashing-regime-every-access-faults-because-the-active-pages-can39t-all-fit-in-memory-real-os-kernels-detect-this-via-page-fault-frequency-if-a-process39s-fault-rate-exceeds-a-threshold-the-kernel-may-suspend-the-process-via-working-set-model-enforcement-rather-than-let-it-thrash-and-drag-down-every-other-process\"><strong>Thrashing detection:</strong> track the working set size over time. If <code>ws_size &gt; pm-&gt;num_frames</code> consistently, you&#39;re in a thrashing regime â€” every access faults because the active pages can&#39;t all fit in memory. Real OS kernels detect this via page fault frequency: if a process&#39;s fault rate exceeds a threshold, the kernel may suspend the process (via working set model enforcement) rather than let it thrash and drag down every other process.</h2>\n<h2 id=\"optimal-bldy39s-algorithm-the-theoretical-lower-bound\">Optimal (BÃ©lÃ¡dy&#39;s Algorithm): The Theoretical Lower Bound</h2>\n<p>Optimal page replacement evicts the page that will not be needed for the <strong>longest time in the future</strong>. This is provably the fewest possible page faults for any algorithm â€” it&#39;s the theoretical lower bound, the ceiling no algorithm can exceed.\nThe catch: you need to know the future. In a real running system, you can&#39;t. Optimal is not a practical algorithm â€” it&#39;s a <strong>benchmark</strong>. You run it on a recorded trace (which you have in full), compare your FIFO/LRU/Clock fault counts against it, and the gap tells you how much headroom exists for better heuristics.</p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m4-optimal-beladys.svg\" alt=\"Optimal (BÃ©lÃ¡dy's) Algorithm â€” Look-Ahead Trace\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Optimal (BÃ©lÃ¡dy's) replacement.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Requires the complete future access trace from current_idx onward.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This is only possible in a simulator â€” not in a real OS.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Algorithm:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   For each frame currently in memory:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *     Find the next access to that frame's VPN in future[current_idx..]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *     If a VPN never appears again: it's the ideal victim (evict immediately)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *     Otherwise: record the distance to next access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   Evict the frame with the LARGEST next-access distance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   (the page we won't need for the longest time)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Time complexity: O(num_frames Ã— remaining_trace) â€” expensive but offline.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Space: O(1) extra beyond the trace (we scan forward per candidate).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#B392F0\"> optimal_select_victim</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                        const</span><span style=\"color:#79B8FF\"> mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">future</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                        size_t</span><span style=\"color:#FFAB70\"> future_len</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                        size_t</span><span style=\"color:#FFAB70\"> current_idx</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> victim      </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> max_dist    </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> pm->num_frames; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">pm->desc[i].in_use) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> vpn </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pm->desc[i].vpn;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* Find next use of this VPN in the future */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint64_t</span><span style=\"color:#E1E4E8\"> next_use </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT64_MAX;</span><span style=\"color:#6A737D\">  /* \"never used again\" */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_idx; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> future_len; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">vpn_from_addr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">future</span><span style=\"color:#E1E4E8\">[j].vaddr) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> vpn) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                next_use </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\">)(j </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> current_idx);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /* A page never used again is the perfect victim */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (next_use </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT64_MAX) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[OPT] VPN=0x</span><span style=\"color:#79B8FF\">%05X</span><span style=\"color:#9ECBFF\"> never used again â€” ideal victim</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, vpn);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (next_use </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> max_dist) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            max_dist </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next_use;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            victim   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[OPT] Evicting VPN=0x</span><span style=\"color:#79B8FF\">%05X</span><span style=\"color:#9ECBFF\"> (next use in </span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> steps)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pm->desc[victim].vpn, max_dist);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> victim;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#B392F0\"> replace_optimal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">swap_space_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sw</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                                   page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                   const</span><span style=\"color:#79B8FF\"> mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">future</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> future_len</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                   size_t</span><span style=\"color:#FFAB70\"> current_idx</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> victim </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> optimal_select_victim</span><span style=\"color:#E1E4E8\">(pm, future, future_len, current_idx);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (victim </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT32_MAX) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[BUG] Optimal: no victim selected</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#E1E4E8\">){ .freed_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> evict_frame</span><span style=\"color:#E1E4E8\">(pm, sw, pt, tlb, victim);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"optimal39s-off-by-one-discipline-current_idx-points-to-the-access-currently-being-handled-the-faulting-access-the-look-ahead-begins-at-current_idx-not-current_idx-1-to-correctly-identify-the-very-next-use-of-each-candidate-vpn-in-the-future-trace-if-you-start-at-current_idx-1-you-may-incorrectly-believe-the-currently-faulting-page-has-no-near-future-use\"><strong>Optimal&#39;s off-by-one discipline:</strong> <code>current_idx</code> points to the access <em>currently being handled</em> (the faulting access). The look-ahead begins at <code>current_idx</code> (not <code>current_idx + 1</code>) to correctly identify the very next use of each candidate VPN in the future trace. If you start at <code>current_idx + 1</code>, you may incorrectly believe the currently faulting page has no near future use.</h2>\n<h2 id=\"the-dispatcher-wiring-all-four-policies-together\">The Dispatcher: Wiring All Four Policies Together</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Unified replacement dispatcher.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Selects algorithm based on policy, then calls the shared eviction core.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#B392F0\"> replace_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">swap_space_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sw</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                               page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                               replacement_policy_t</span><span style=\"color:#FFAB70\"> policy</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                               const</span><span style=\"color:#79B8FF\"> mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">future</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> future_len</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                               size_t</span><span style=\"color:#FFAB70\"> current_idx</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                               uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">clock_hand</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (policy) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> POLICY_FIFO:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> replace_fifo</span><span style=\"color:#E1E4E8\">(pm, sw, pt, tlb);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> POLICY_LRU:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> replace_lru</span><span style=\"color:#E1E4E8\">(pm, sw, pt, tlb);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> POLICY_CLOCK:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> replace_clock</span><span style=\"color:#E1E4E8\">(pm, sw, pt, tlb, clock_hand);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> POLICY_OPTIMAL:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> replace_optimal</span><span style=\"color:#E1E4E8\">(pm, sw, pt, tlb, future, future_len, current_idx);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[BUG] Unknown policy </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">policy</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#E1E4E8\">){ .freed_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"the-full-simulation-loop-with-replacement\">The Full Simulation Loop with Replacement</h2>\n<p>Now the page fault handler from Milestone 1 gains a new capability: when <code>alloc_free_frame()</code> returns <code>UINT32_MAX</code>, instead of failing, it invokes the replacement policy:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Statistics collected per algorithm run.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    replacement_policy_t</span><span style=\"color:#E1E4E8\"> policy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\">          *</span><span style=\"color:#E1E4E8\">name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">             total_accesses;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">             page_faults;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">             dirty_writebacks;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">             page_ins;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">             protection_faults;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">             peak_working_set;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">sim_stats_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Run the full simulation for one policy over the complete trace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Resets physical memory and swap between runs so each algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * starts from the same blank-slate state.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns statistics for this run.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">sim_stats_t</span><span style=\"color:#B392F0\"> run_simulation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">accesses</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            uint32_t</span><span style=\"color:#FFAB70\"> num_frames</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                            replacement_policy_t</span><span style=\"color:#FFAB70\"> policy</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                            page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   /* reset by caller */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                            tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">) {</span><span style=\"color:#6A737D\">       /* reset by caller */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    phys_mem_t</span><span style=\"color:#E1E4E8\">  pm;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    swap_space_t</span><span style=\"color:#E1E4E8\"> sw;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    phys_mem_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pm, num_frames);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sw, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(sw));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> clock_hand </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    working_set_tracker_t</span><span style=\"color:#E1E4E8\"> ws;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ws_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ws);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    sim_stats_t</span><span style=\"color:#E1E4E8\"> stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .policy </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> policy,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .name   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> policy </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> POLICY_FIFO    </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"FIFO\"</span><span style=\"color:#F97583\">    :</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  policy </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> POLICY_LRU     </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"LRU\"</span><span style=\"color:#F97583\">     :</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  policy </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> POLICY_CLOCK   </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"Clock\"</span><span style=\"color:#F97583\">   :</span><span style=\"color:#9ECBFF\"> \"Optimal\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">size_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> count; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#79B8FF\"> mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">acc </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">accesses</span><span style=\"color:#E1E4E8\">[i];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stats.total_accesses</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> vpn    </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> vpn_from_addr</span><span style=\"color:#E1E4E8\">(acc->vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> offset </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> offset_from_addr</span><span style=\"color:#E1E4E8\">(acc->vaddr);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*â”€â”€ Update working set â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> ws_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> ws_record_access</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ws, vpn);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (ws_size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> stats.peak_working_set)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stats.peak_working_set </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ws_size;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*â”€â”€ TLB Lookup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (tlb) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            tlb_lookup_t</span><span style=\"color:#E1E4E8\"> tr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> tlb_lookup</span><span style=\"color:#E1E4E8\">(tlb, vpn, acc->type);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (tr.result </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> XLATE_TLB_HIT) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                phys_record_access</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pm, tr.pfn);</span><span style=\"color:#6A737D\">  /* update LRU/Clock metadata */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">                          /* no fault needed */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*â”€â”€ Page table walk â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        pte_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">pt->entries[vpn];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_VALID)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /*â”€â”€ Page Fault â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stats.page_faults</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Try to get a free frame */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> phys_find_free</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pm);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT32_MAX) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                /* All frames occupied â€” invoke replacement */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                replace_result_t</span><span style=\"color:#E1E4E8\"> rr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> replace_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pm, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sw, pt, tlb,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                                    policy,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                                    accesses, count, i,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                                    &#x26;</span><span style=\"color:#E1E4E8\">clock_hand);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (rr.freed_frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> UINT32_MAX) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[FATAL] Replacement failed at access </span><span style=\"color:#79B8FF\">%zu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> rr.freed_frame;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> (rr.was_dirty) stats.dirty_writebacks</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Load page into frame (from swap if available, else zero-fill) */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            bool</span><span style=\"color:#E1E4E8\"> from_swap </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> swap_page_in</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pm, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sw, frame, vpn);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (from_swap) stats.page_ins</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Set up the frame descriptor */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pm.clock</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pm.desc[frame].vpn         </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> vpn;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pm.desc[frame].load_time   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pm.clock;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pm.desc[frame].last_access </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pm.clock;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pm.desc[frame].ref_bit     </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pm.desc[frame].dirty       </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">   /* freshly loaded = clean */</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pm.desc[frame].in_use      </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Install PTE */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pte_make</span><span style=\"color:#E1E4E8\">(frame,</span><span style=\"color:#6A737D\"> /*readable=*/</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                            /*writable=*/</span><span style=\"color:#E1E4E8\">(acc->type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            /* Insert into TLB */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (tlb) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                int</span><span style=\"color:#E1E4E8\"> writable </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (acc->type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                tlb_insert</span><span style=\"color:#E1E4E8\">(tlb, pt, vpn, frame, writable,</span><span style=\"color:#6A737D\"> /*use_random=*/</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*â”€â”€ Permission check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (acc->type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_PERM_WRITE)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stats.protection_faults</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        /*â”€â”€ Update access metadata â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        uint32_t</span><span style=\"color:#E1E4E8\"> frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pte_get_pfn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">pte);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        phys_record_access</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pm, frame);</span><span style=\"color:#6A737D\">   /* updates last_access, ref_bit */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_REFERENCED;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (acc->type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            *</span><span style=\"color:#E1E4E8\">pte </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> PTE_DIRTY;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pm.desc[frame].dirty </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats.dirty_writebacks </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> sw.write_backs;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats.page_ins         </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> sw.page_ins;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> stats;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"why-reset-state-between-algorithm-runs-the-comparison-is-only-valid-if-every-algorithm-sees-the-same-initial-condition-empty-memory-no-swap-data-no-tlb-entries-otherwise-you39re-measuring-the-combined-effect-of-quotwhich-algorithm-benefited-from-the-previous-algorithm39s-warm-upquot-rather-than-the-algorithm39s-intrinsic-policy-behavior-each-run-must-start-cold\"><strong>Why reset state between algorithm runs?</strong> The comparison is only valid if every algorithm sees the same initial condition â€” empty memory, no swap data, no TLB entries. Otherwise you&#39;re measuring the combined effect of &quot;which algorithm benefited from the previous algorithm&#39;s warm-up&quot; rather than the algorithm&#39;s intrinsic policy behavior. Each run must start cold.</h2>\n<h2 id=\"bldy39s-anomaly-when-more-memory-makes-things-worse\">BÃ©lÃ¡dy&#39;s Anomaly: When More Memory Makes Things Worse</h2>\n<p>This is the result you need to demonstrate. It&#39;s not obvious. It challenges your intuition. It has practical consequences for capacity planning.\n<strong>The anomaly:</strong> For FIFO replacement, there exist reference strings where increasing the number of frames <em>increases</em> the number of page faults.</p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m4-beladys-anomaly.svg\" alt=\"BÃ©lÃ¡dy's Anomaly: FIFO Gets WORSE with More Frames\"></p>\n<p>The classic demonstration uses this reference string:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</code></pre></div>\n<p>For this reference string:</p>\n<ul>\n<li>With <strong>3 frames</strong>: 9 page faults</li>\n<li>With <strong>4 frames</strong>: 10 page faults (MORE faults with MORE frames!)\nLet&#39;s trace through it in code:</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * BÃ©lÃ¡dy's anomaly demonstration trace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Reference string: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * (each VPN maps to an address on that page: VPN=N â†’ address N*4096)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Save this as \"beladys.trace\":</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#E1E4E8\"> BELADYS_TRACE</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"R 0x00001000</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">   /* VPN 1 */</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"R 0x00002000</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">   /* VPN 2 */</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"R 0x00003000</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">   /* VPN 3 */</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"R 0x00004000</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">   /* VPN 4 */</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"R 0x00001000</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">   /* VPN 1 */</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"R 0x00002000</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">   /* VPN 2 */</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"R 0x00005000</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">   /* VPN 5 */</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"R 0x00001000</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">   /* VPN 1 */</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"R 0x00002000</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">   /* VPN 2 */</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"R 0x00003000</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">   /* VPN 3 */</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"R 0x00004000</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">   /* VPN 4 */</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"R 0x00005000</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  /* VPN 5 */</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Why this trace causes the anomaly with FIFO:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * With 3 frames (FIFO trace):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Access:   1    2    3    4    1    2    5    1    2    3    4    5</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Frames:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 1: [1  -  -]                                         FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 2: [1  2  -]                                         FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 3: [1  2  3]                                         FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 4: [4  2  3] evict 1 (oldest)                        FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 1: [4  1  3] evict 2                                 FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 2: [4  1  2] evict 3                                 FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 5: [5  1  2] evict 4                                 FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 1: HIT [5 1 2]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 2: HIT [5 1 2]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 3: [5  3  2] evict 1                                 FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 4: [5  3  4] evict 2                                 FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 5: HIT [5 3 4]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Total faults with 3 frames: 9</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * With 4 frames (FIFO trace):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Access:   1    2    3    4    1    2    5    1    2    3    4    5</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Frames:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 1: [1  -  -  -]                                      FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 2: [1  2  -  -]                                      FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 3: [1  2  3  -]                                      FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 4: [1  2  3  4]                                      FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 1: HIT [1 2 3 4]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 2: HIT [1 2 3 4]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 5: [5  2  3  4] evict 1 (oldest)                     FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 1: [5  1  3  4] evict 2                              FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 2: [5  1  2  4] evict 3                              FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 3: [5  1  2  3] evict 4                              FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 4: [4  1  2  3] evict 5                              FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> *   After 5: [4  5  2  3] evict 1                              FAULT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Total faults with 4 frames: 10 â† MORE than 3 frames!</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> demonstrate_beladys_anomaly</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Parse the reference string into accesses */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    mem_access_t</span><span style=\"color:#FFAB70\"> accesses</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vpns</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        accesses</span><span style=\"color:#E1E4E8\">[i].type  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ACCESS_READ;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        accesses</span><span style=\"color:#E1E4E8\">[i].vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> vpns</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> PAGE_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">=== BÃ©lÃ¡dy's Anomaly Demonstration ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Reference string: 1,2,3,4,1,2,5,1,2,3,4,5</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> nframes </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">; nframes </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">; nframes</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        page_table_t</span><span style=\"color:#E1E4E8\"> pt;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(pt));</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        sim_stats_t</span><span style=\"color:#E1E4E8\"> stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> run_simulation</span><span style=\"color:#E1E4E8\">(accesses, </span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">, nframes,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                            POLICY_FIFO, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt,</span><span style=\"color:#6A737D\"> /*tlb=*/</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"FIFO with </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> frames: </span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> page faults</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               nframes, stats.page_faults);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">Expected: 3 frames â†’ 9 faults, 4 frames â†’ 10 faults</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"(FIFO gets WORSE with more frames â€” BÃ©lÃ¡dy's anomaly)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">For comparison (LRU â€” immune to anomaly):</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> nframes </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">; nframes </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">; nframes</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        page_table_t</span><span style=\"color:#E1E4E8\"> pt;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(pt));</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        sim_stats_t</span><span style=\"color:#E1E4E8\"> stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> run_simulation</span><span style=\"color:#E1E4E8\">(accesses, </span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">, nframes,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                            POLICY_LRU, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt,</span><span style=\"color:#6A737D\"> /*tlb=*/</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"LRU  with </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> frames: </span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> page faults</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               nframes, stats.page_faults);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"why-lru-is-immune-to-bldy39s-anomaly-lru-belongs-to-a-class-called-stack-algorithms-for-stack-algorithms-the-set-of-pages-in-memory-with-k-frames-is-always-a-subset-of-the-pages-in-memory-with-k1-frames-adding-a-frame-to-a-stack-algorithm-can-never-evict-a-page-that-would-have-stayed-with-fewer-frames-so-more-frames-can-only-mean-fewer-or-equal-faults-never-more-fifo-is-not-a-stack-algorithm-the-page-evicted-with-k-frames-might-be-a-page-that-would-have-stayed-with-k1-frames-adding-that-extra-frame-displaces-the-fifo-ordering-just-enough-to-evict-differently-and-create-more-misses-optimal-and-lru-are-both-stack-algorithms-clock-is-an-approximation-of-lru-and-generally-does-not-exhibit-the-anomaly-in-practice-though-it-lacks-the-formal-proof\"><strong>Why LRU is immune to BÃ©lÃ¡dy&#39;s anomaly:</strong> LRU belongs to a class called <strong>stack algorithms</strong>. For stack algorithms, the set of pages in memory with k frames is always a <em>subset</em> of the pages in memory with k+1 frames. Adding a frame to a stack algorithm can never evict a page that would have stayed with fewer frames â€” so more frames can only mean fewer or equal faults, never more.\nFIFO is not a stack algorithm. The page evicted with k frames might be a page that would have stayed with k+1 frames. Adding that extra frame displaces the FIFO ordering just enough to evict differently and create more misses.\nOptimal and LRU are both stack algorithms. Clock is an approximation of LRU and generally does not exhibit the anomaly in practice, though it lacks the formal proof.</h2>\n<h2 id=\"comparative-statistics-all-four-algorithms-side-by-side\">Comparative Statistics: All Four Algorithms Side by Side</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Run all four algorithms on the same trace with the same frame count.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Print a comparative report.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> run_comparison</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">accesses</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> count</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                     uint32_t</span><span style=\"color:#FFAB70\"> num_frames</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    replacement_policy_t</span><span style=\"color:#E1E4E8\"> policies</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        POLICY_FIFO, POLICY_LRU, POLICY_CLOCK, POLICY_OPTIMAL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    sim_stats_t</span><span style=\"color:#FFAB70\"> results</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">Running comparison: </span><span style=\"color:#79B8FF\">%zu</span><span style=\"color:#9ECBFF\"> accesses, </span><span style=\"color:#79B8FF\">%u</span><span style=\"color:#9ECBFF\"> frames</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, count, num_frames);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; p </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">; p</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        page_table_t</span><span style=\"color:#E1E4E8\"> pt;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(pt));</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        results</span><span style=\"color:#E1E4E8\">[p] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> run_simulation</span><span style=\"color:#E1E4E8\">(accesses, count, num_frames,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                                     policies</span><span style=\"color:#E1E4E8\">[p], </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt,</span><span style=\"color:#6A737D\"> /*tlb=*/</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    print_comparison_table</span><span style=\"color:#E1E4E8\">(results, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, count);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> print_comparison_table</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> sim_stats_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> n</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> total</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•‘ Algorithm    â•‘   Faults  â•‘ Fault</span><span style=\"color:#79B8FF\">%%</span><span style=\"color:#9ECBFF\">    â•‘ WriteBack â•‘ Peak WS Size â•‘</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> n; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•‘ </span><span style=\"color:#79B8FF\">%-12s</span><span style=\"color:#9ECBFF\"> â•‘ </span><span style=\"color:#79B8FF\">%9lu</span><span style=\"color:#9ECBFF\"> â•‘ </span><span style=\"color:#79B8FF\">%8.2f%%</span><span style=\"color:#9ECBFF\"> â•‘ </span><span style=\"color:#79B8FF\">%9lu</span><span style=\"color:#9ECBFF\"> â•‘ </span><span style=\"color:#79B8FF\">%12u</span><span style=\"color:#9ECBFF\"> â•‘</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">               stats</span><span style=\"color:#E1E4E8\">[i].name,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">               stats</span><span style=\"color:#E1E4E8\">[i].page_faults,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               total </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">[i].page_faults </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> total </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">               stats</span><span style=\"color:#E1E4E8\">[i].dirty_writebacks,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">               stats</span><span style=\"color:#E1E4E8\">[i].peak_working_set);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Print Optimal as the lower bound and efficiency ratios */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> opt_faults </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> n; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#E1E4E8\">[i].policy </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> POLICY_OPTIMAL) opt_faults </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> stats</span><span style=\"color:#E1E4E8\">[i].page_faults;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (opt_faults </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">Efficiency vs Optimal (lower = closer to optimal):</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> n; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#E1E4E8\">[i].policy </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> POLICY_OPTIMAL) </span><span style=\"color:#F97583\">continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            double</span><span style=\"color:#E1E4E8\"> ratio </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#E1E4E8\">[i].page_faults </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">double</span><span style=\"color:#E1E4E8\">)opt_faults;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  </span><span style=\"color:#79B8FF\">%-8s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%.2f</span><span style=\"color:#9ECBFF\">Ã— optimal (</span><span style=\"color:#79B8FF\">%+ld</span><span style=\"color:#9ECBFF\"> faults)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                   stats</span><span style=\"color:#E1E4E8\">[i].name, ratio,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#FFAB70\">stats</span><span style=\"color:#E1E4E8\">[i].page_faults </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> opt_faults));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fdiag-m4-algorithm-comparison-chart.svg\" alt=\"Comparative Statistics: All Four Algorithms Side by Side\"></p>\n<p><strong>Expected rankings for typical access patterns:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Metric</th>\n<th>Typical ranking</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Page faults</td>\n<td>Optimal â‰¤ LRU â‰¤ Clock â‰¤ FIFO</td>\n</tr>\n<tr>\n<td>Dirty write-backs</td>\n<td>Varies â€” depends on access pattern</td>\n</tr>\n<tr>\n<td>Implementation complexity</td>\n<td>FIFO &lt; Clock &lt; LRU &lt; Optimal</td>\n</tr>\n<tr>\n<td>Real-world usability</td>\n<td>Clock (production) &gt; LRU (simulation) &gt; FIFO (baseline) &gt; Optimal (offline)</td>\n</tr>\n<tr>\n<td>The dirty write-back count reveals something the raw fault count misses: an algorithm that makes good page choices may still incur more write-back I/O if its victim selection tends to hit dirty pages. Clock&#39;s approach of evicting unreferenced pages (regardless of dirty status) can sometimes cause more write-backs than FIFO â€” even with fewer total faults â€” because FIFO may happen to evict clean pages more often on a particular trace.</td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"building-and-testing\">Building and Testing</h2>\n<h3 id=\"compile\">Compile</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -Wall</span><span style=\"color:#79B8FF\"> -Wextra</span><span style=\"color:#79B8FF\"> -O2</span><span style=\"color:#79B8FF\"> -std=c11</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> vmsim_m4</span><span style=\"color:#9ECBFF\"> vmsim_m4.c</span></span></code></pre></div>\n<h3 id=\"test-1-fifo-correctness-against-known-output\">Test 1: FIFO Correctness Against Known Output</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_fifo_known_trace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Classic reference string: 7,0,1,2,0,3,0,4,2,3,0,3,2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * With 3 frames, FIFO produces 9 page faults.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * (Standard result from Silberschatz OS textbook, Section 9.4)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vpns</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(vpns)</span><span style=\"color:#F97583\">/sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">vpns</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    mem_access_t</span><span style=\"color:#FFAB70\"> accesses</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">13</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> n; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        accesses</span><span style=\"color:#E1E4E8\">[i].type  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ACCESS_READ;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        accesses</span><span style=\"color:#E1E4E8\">[i].vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> vpns</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> PAGE_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#E1E4E8\"> pt;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(pt));</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    sim_stats_t</span><span style=\"color:#E1E4E8\"> stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> run_simulation</span><span style=\"color:#E1E4E8\">(accesses, n,</span><span style=\"color:#6A737D\"> /*frames=*/</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                        POLICY_FIFO, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(stats.page_faults </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 9</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"FIFO known-trace test: PASSED (</span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> faults, expected 9)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           stats.page_faults);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"test-2-lru-correctness\">Test 2: LRU Correctness</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_lru_known_trace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Same reference string: 7,0,1,2,0,3,0,4,2,3,0,3,2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * With 3 frames, LRU produces 8 page faults.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vpns</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(vpns)</span><span style=\"color:#F97583\">/sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">vpns</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    mem_access_t</span><span style=\"color:#FFAB70\"> accesses</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">13</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> n; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        accesses</span><span style=\"color:#E1E4E8\">[i].type  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ACCESS_READ;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        accesses</span><span style=\"color:#E1E4E8\">[i].vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> vpns</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> PAGE_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#E1E4E8\"> pt;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(pt));</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    sim_stats_t</span><span style=\"color:#E1E4E8\"> stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> run_simulation</span><span style=\"color:#E1E4E8\">(accesses, n,</span><span style=\"color:#6A737D\"> /*frames=*/</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                        POLICY_LRU, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(stats.page_faults </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"LRU known-trace test: PASSED (</span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> faults, expected 8)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           stats.page_faults);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"test-3-optimal-lower-bound\">Test 3: Optimal Lower Bound</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_optimal_is_lower_bound</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Property: Optimal must produce &#x3C;= faults of any other algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * for the same trace and frame count.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vpns</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">7</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(vpns)</span><span style=\"color:#F97583\">/sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">vpns</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    mem_access_t</span><span style=\"color:#FFAB70\"> accesses</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">13</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> n; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        accesses</span><span style=\"color:#E1E4E8\">[i].type  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ACCESS_READ;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        accesses</span><span style=\"color:#E1E4E8\">[i].vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> vpns</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> PAGE_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> opt_faults, fifo_faults, lru_faults, clk_faults;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#E1E4E8\"> pt;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> RUN</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">policy_</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">count_</span><span style=\"color:#E1E4E8\">) ({                                          </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(pt));                                          </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run_simulation</span><span style=\"color:#E1E4E8\">(accesses, n, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, policy_, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">).page_faults; })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    opt_faults  </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> RUN</span><span style=\"color:#E1E4E8\">(POLICY_OPTIMAL, n);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fifo_faults </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> RUN</span><span style=\"color:#E1E4E8\">(POLICY_FIFO,    n);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lru_faults  </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> RUN</span><span style=\"color:#E1E4E8\">(POLICY_LRU,     n);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    clk_faults  </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> RUN</span><span style=\"color:#E1E4E8\">(POLICY_CLOCK,   n);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#undef</span><span style=\"color:#B392F0\"> RUN</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(opt_faults </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> fifo_faults);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(opt_faults </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> lru_faults);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(opt_faults </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> clk_faults);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Optimal lower bound test: PASSED \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">           \"(OPT=</span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> â‰¤ LRU=</span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> â‰¤ CLK=</span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> â‰¤ FIFO=</span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           opt_faults, lru_faults, clk_faults, fifo_faults);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"test-4-dirty-write-back-correctness\">Test 4: Dirty Write-Back Correctness</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_dirty_writeback</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Access sequence: write to VPN 1, then force eviction of VPN 1.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Verify that a swap write-back occurred.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    mem_access_t</span><span style=\"color:#FFAB70\"> accesses</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Write to VPN 1 â€” marks it dirty */</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    accesses</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">mem_access_t</span><span style=\"color:#E1E4E8\">){ .type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ACCESS_WRITE, .vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">00001000</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Fill 2 more frames (2-frame pool) */</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    accesses</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">mem_access_t</span><span style=\"color:#E1E4E8\">){ .type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ACCESS_READ,  .vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">00002000</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Force FIFO eviction: first-loaded (VPN 1) should be evicted â€” dirty */</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    accesses</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">mem_access_t</span><span style=\"color:#E1E4E8\">){ .type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ACCESS_READ,  .vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">00003000</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Now re-access VPN 1 â€” should reload from swap */</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    accesses</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">mem_access_t</span><span style=\"color:#E1E4E8\">){ .type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ACCESS_READ,  .vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">00001000</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#E1E4E8\"> pt;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(pt));</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    sim_stats_t</span><span style=\"color:#E1E4E8\"> stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> run_simulation</span><span style=\"color:#E1E4E8\">(accesses, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\"> /*frames=*/</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                        POLICY_FIFO, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(stats.dirty_writebacks </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   /* VPN 1 was dirty when evicted */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(stats.page_faults </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">        /* VPN1, VPN2, VPN3 cold faults + VPN1 reload */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Dirty write-back test: PASSED (</span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> write-backs)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           stats.dirty_writebacks);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"test-5-bldy39s-anomaly\">Test 5: BÃ©lÃ¡dy&#39;s Anomaly</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_beladys_anomaly</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vpns</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    mem_access_t</span><span style=\"color:#FFAB70\"> accesses</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">12</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> n; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        accesses</span><span style=\"color:#E1E4E8\">[i].type  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ACCESS_READ;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        accesses</span><span style=\"color:#E1E4E8\">[i].vaddr </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> vpns</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> PAGE_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#E1E4E8\"> pt3, pt4;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt3, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(pt3));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt4, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(pt4));</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    sim_stats_t</span><span style=\"color:#E1E4E8\"> s3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> run_simulation</span><span style=\"color:#E1E4E8\">(accesses, n, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, POLICY_FIFO, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt3, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    sim_stats_t</span><span style=\"color:#E1E4E8\"> s4 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> run_simulation</span><span style=\"color:#E1E4E8\">(accesses, n, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, POLICY_FIFO, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt4, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"BÃ©lÃ¡dy's anomaly: 3 frames=</span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> faults, 4 frames=</span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> faults</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           s3.page_faults, s4.page_faults);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* The anomaly: 4 frames produces MORE faults than 3 frames */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(s4.page_faults </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> s3.page_faults);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"BÃ©lÃ¡dy's anomaly confirmed: MORE frames â†’ MORE faults with FIFO</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Verify LRU is immune */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt3, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(pt3));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt4, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(pt4));</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    sim_stats_t</span><span style=\"color:#E1E4E8\"> l3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> run_simulation</span><span style=\"color:#E1E4E8\">(accesses, n, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, POLICY_LRU, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt3, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    sim_stats_t</span><span style=\"color:#E1E4E8\"> l4 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> run_simulation</span><span style=\"color:#E1E4E8\">(accesses, n, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, POLICY_LRU, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt4, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(l4.page_faults </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> l3.page_faults);</span><span style=\"color:#6A737D\">   /* LRU immune to anomaly */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"LRU immunity confirmed: </span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> faults (3 frames) â‰¥ </span><span style=\"color:#79B8FF\">%lu</span><span style=\"color:#9ECBFF\"> faults (4 frames)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           l3.page_faults, l4.page_faults);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"test-6-clock-advances-hand-correctly\">Test 6: Clock Advances Hand Correctly</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> test_clock_hand_persistence</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Verify clock hand persists across calls.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * After N evictions, clock hand should be at a predictable position.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     *</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Implementation detail: the caller passes a uint32_t* clock_hand</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * and must preserve it between calls. Verify by observing that</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * eviction patterns rotate through frames.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> clock_hand </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> first_eviction_frame  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> second_eviction_frame </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> UINT32_MAX;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* With all ref_bits initially false, first call should evict frame 0,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * second call frame 1, etc. (no second-chance needed on fresh state) */</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    phys_mem_t</span><span style=\"color:#E1E4E8\"> pm;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    phys_mem_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pm, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Fill all 4 frames with distinct VPNs, ref_bit=false */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pm.desc[i].in_use      </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pm.desc[i].vpn         </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pm.desc[i].ref_bit     </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pm.desc[i].dirty       </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#E1E4E8\"> pt;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(pt));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* Install PTEs for VPNs 1-4 */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#E1E4E8\"> vpn </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; vpn </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">; vpn</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pt.entries[vpn] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> pte_make</span><span style=\"color:#E1E4E8\">(vpn </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    swap_space_t</span><span style=\"color:#E1E4E8\"> sw;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    memset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sw, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(sw));</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    replace_result_t</span><span style=\"color:#E1E4E8\"> r1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> replace_clock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pm, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sw, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">clock_hand);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    replace_result_t</span><span style=\"color:#E1E4E8\"> r2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> replace_clock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pm, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sw, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">pt, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">clock_hand);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /* With all ref_bits=0 and hand starting at 0: frame 0 then frame 1 */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(r1.freed_frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(r2.freed_frame </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    assert</span><span style=\"color:#E1E4E8\">(clock_hand </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   /* hand advanced past both evicted frames */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Clock hand persistence test: PASSED</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"hardware-soul-what-real-operating-systems-do\">Hardware Soul: What Real Operating Systems Do</h2>\n<h2 id=\"your-simulator-implements-page-replacement-in-pure-software-with-full-visibility-into-all-state-real-os-kernels-have-much-harder-constraints-and-their-solutions-reveal-decades-of-hard-won-wisdom-linux39s-two-list-approximation-linux-doesn39t-use-clock-directly-instead-it-maintains-two-lru-lists-per-zone-memory-region-the-active-list-and-the-inactive-list-pages-enter-the-inactive-list-on-first-access-if-a-page-on-the-inactive-list-is-accessed-again-referenced-bit-set-it39s-promoted-to-the-active-list-pages-are-evicted-only-from-the-inactive-list-this-is-a-two-chance-policy-a-page-must-be-accessed-at-least-twice-before-it39s-immune-to-immediate-eviction-a-page-accessed-exactly-once-a-quotstreamingquot-access-that-won39t-recur-stays-on-the-inactive-list-and-is-evicted-cheaply-a-page-accessed-repeatedly-earns-active-list-status-and-is-protected-the-kernel39s-kswapd-daemon-runs-when-free-memory-falls-below-a-threshold-moving-pages-from-active-to-inactive-after-clearing-reference-bits-and-then-from-inactive-to-disk-this-avoids-synchronously-evicting-pages-during-page-fault-handling-a-latency-critical-path-instead-replacement-happens-asynchronously-keeping-a-reserve-of-pre-freed-frames-available-for-fault-handlers-cache-line-behavior-of-your-frame-descriptors-your-frame_desc_t-is-16-bytes-four-frame-descriptors-fit-in-one-64-byte-cache-line-when-the-clock-algorithm-scans-frames-sequentially-the-common-case-during-replacement-it-accesses-frame-descriptors-in-cache-line-aligned-chunks-efficient-sequential-access-when-the-clock-hand-wraps-around-it-starts-fresh-from-a-cache-cold-position-for-large-frame-pools-thousands-of-frames-the-initial-sweep-is-cache-hostile-subsequent-sweeps-with-cleared-reference-bits-tend-to-terminate-quickly-on-recently-cleared-frames-keeping-the-scan-length-short-tlb-invalidation-across-cpus-tlb-shootdown-in-a-multiprocessor-system-each-cpu-has-its-own-tlb-when-page-x-is-evicted-on-cpu-0-cpus-1-2-and-3-might-have-cached-translations-for-page-x-in-their-own-tlbs-before-the-frame-can-be-reused-all-other-cpus-must-invalidate-their-entry-for-that-vpn-this-requires-an-inter-processor-interrupt-ipi-cpu-0-sends-an-interrupt-to-all-other-cpus-which-each-execute-invlpgx-and-acknowledge-only-after-all-cpus-acknowledge-can-cpu-0-consider-the-frame-free-this-quottlb-shootdownquot-is-the-most-expensive-operation-in-the-page-replacement-path-on-smp-systems-on-a-64-core-machine-evicting-one-page-you39re-waiting-for-63-ipis-to-round-trip-before-proceeding-high-performance-workloads-databases-hpc-try-hard-to-minimize-page-eviction-frequency-precisely-to-avoid-shootdown-overhead-your-simulator-calls-tlb_flush_page-once-simulating-single-cpu-behavior-a-multi-cpu-extension-would-need-shootdown-simulation\">Your simulator implements page replacement in pure software with full visibility into all state. Real OS kernels have much harder constraints â€” and their solutions reveal decades of hard-won wisdom.\n<strong>Linux&#39;s Two-List Approximation:</strong>\nLinux doesn&#39;t use Clock directly. Instead, it maintains two LRU lists per zone (memory region): the <strong>active list</strong> and the <strong>inactive list</strong>. Pages enter the inactive list on first access. If a page on the inactive list is accessed again (referenced bit set), it&#39;s promoted to the active list. Pages are evicted only from the inactive list.\nThis is a two-chance policy: a page must be accessed at least twice before it&#39;s immune to immediate eviction. A page accessed exactly once (a &quot;streaming&quot; access that won&#39;t recur) stays on the inactive list and is evicted cheaply. A page accessed repeatedly earns active-list status and is protected.\nThe kernel&#39;s <code>kswapd</code> daemon runs when free memory falls below a threshold, moving pages from active to inactive (after clearing reference bits) and then from inactive to disk. This avoids synchronously evicting pages during page fault handling â€” a latency-critical path. Instead, replacement happens asynchronously, keeping a reserve of pre-freed frames available for fault handlers.\n<strong>Cache line behavior of your frame descriptors:</strong>\nYour <code>frame_desc_t</code> is 16 bytes. Four frame descriptors fit in one 64-byte cache line. When the Clock algorithm scans frames sequentially (the common case during replacement), it accesses frame descriptors in cache-line-aligned chunks â€” efficient sequential access. When the clock hand wraps around, it starts fresh from a cache-cold position. For large frame pools (thousands of frames), the initial sweep is cache-hostile; subsequent sweeps (with cleared reference bits) tend to terminate quickly on recently-cleared frames, keeping the scan length short.\n<strong>TLB invalidation across CPUs â€” TLB shootdown:</strong>\nIn a multiprocessor system, each CPU has its own TLB. When page <code>X</code> is evicted on CPU 0, CPUs 1, 2, and 3 might have cached translations for page X in their own TLBs. Before the frame can be reused, all other CPUs must invalidate their entry for that VPN. This requires an <strong>inter-processor interrupt (IPI)</strong> â€” CPU 0 sends an interrupt to all other CPUs, which each execute <code>INVLPG(X)</code> and acknowledge. Only after all CPUs acknowledge can CPU 0 consider the frame free.\nThis &quot;TLB shootdown&quot; is the most expensive operation in the page replacement path on SMP systems. On a 64-core machine evicting one page, you&#39;re waiting for 63 IPIs to round-trip before proceeding. High-performance workloads (databases, HPC) try hard to minimize page eviction frequency precisely to avoid shootdown overhead. Your simulator calls <code>tlb_flush_page()</code> once â€” simulating single-CPU behavior. A multi-CPU extension would need shootdown simulation.</h2>\n<h2 id=\"knowledge-cascade-page-replacement-connects-everywhere\">Knowledge Cascade: Page Replacement Connects Everywhere</h2>\n<h3 id=\"1-redis-and-sampled-lru-the-same-compromise-different-scale\">1. Redis and Sampled-LRU: The Same Compromise, Different Scale</h3>\n<p>Redis needs to evict keys when it reaches its <code>maxmemory</code> limit. True LRU would require tracking access time for every key â€” billions of keys, billions of updates per second â€” the same O(n) overhead problem you encountered. Redis&#39;s solution: <strong>sampled-LRU</strong>. When eviction is needed, Redis samples 5 random keys (configurable via <code>maxmemory-samples</code>), picks the least-recently-used among those 5, and evicts it.\nThis is a probabilistic approximation of LRU with O(1) overhead. With just 5 samples, Redis achieves remarkably good approximation of true LRU because the oldest key is likely to appear in a random sample when memory has many cold entries. The principle is identical to Clock: instead of tracking full history, make a good approximation using sparse information.\nMemcached uses a segmented LRU approach (similar to Linux&#39;s active/inactive lists). Varnish (HTTP cache) uses a Clock variant. Every caching system in production has independently rediscovered the same truth: true LRU is too expensive; good approximations are available for much lower cost.</p>\n<h3 id=\"2-stack-algorithms-and-capacity-planning\">2. Stack Algorithms and Capacity Planning</h3>\n<p>The formal definition of a <strong>stack algorithm</strong> (Mattson et al., 1970): replacement algorithm A is a stack algorithm if, for any reference string, the set of pages in memory with k frames (denoted S(k)) is a subset of pages in memory with k+1 frames. Formally: <code>S(k) âŠ† S(k+1)</code> for all k.\nStack algorithms provably cannot exhibit BÃ©lÃ¡dy&#39;s anomaly. Any algorithm where adding frames can only add pages to memory (never change which pages are kept) satisfies this property. LRU and Optimal are stack algorithms; FIFO is not.\nWhy does this matter for capacity planning? If your cache uses a stack algorithm, you can simulate future fault rates with fewer frames by running the simulation with more frames and reading off the k-frame column from the &quot;inclusion property&quot; â€” you don&#39;t need to re-run the simulation for every frame count. This property also means: with LRU/Optimal, adding RAM to a production server is guaranteed to help or be neutral â€” never harmful. With FIFO-like policies, this guarantee doesn&#39;t hold.\n[[EXPLAIN:inclusion-property-of-stack-algorithms-and-why-it-matters-for-capacity-planning|Inclusion property of stack algorithms â€” why LRU&#39;s stack property means simulation results at k frames extend to k+1 frames without re-running, enabling efficient capacity planning]]</p>\n<h3 id=\"3-thrashing-and-admission-control-the-same-problem-in-web-services\">3. Thrashing and Admission Control: The Same Problem in Web Services</h3>\n<p>When working set size exceeds physical frames, every access faults. The page fault rate explodes. CPU time is consumed entirely by fault handling and swap I/O. Useful work drops to near zero. This is thrashing â€” and it&#39;s a <strong>phase transition</strong>, not a gradual degradation. Below the threshold: normal execution. Above the threshold: complete collapse.\nWeb services experience the identical phenomenon at a higher level. When incoming request rate exceeds server processing capacity, the request queue grows without bound. Queue depth increases latency for all requests, which triggers timeouts, which causes retries, which increases request rate further â€” a feedback loop that collapses throughput completely. The symptom is identical: 100% resource utilization with 0% useful work.\nThe OS solution for thrashing is <strong>working set enforcement</strong>: the scheduler measures each process&#39;s page fault frequency. If it exceeds a threshold, the scheduler <em>suspends</em> the process rather than let it thrash. Fewer active processes means each active process&#39;s working set fits in memory. This is load shedding.\nWeb service admission control is the same principle: reject incoming requests when the server is overloaded rather than queue them infinitely. A 503 response now is better than a 30-second timeout later. Understanding thrashing in virtual memory systems gives you the intuition for why admission control is correct in web services â€” the math of saturation collapse is identical.</p>\n<h3 id=\"4-database-buffer-pools-isomorphic-to-page-replacement\">4. Database Buffer Pools: Isomorphic to Page Replacement</h3>\n<p>PostgreSQL&#39;s <code>shared_buffers</code> pool, MySQL InnoDB&#39;s <code>innodb_buffer_pool_size</code>, and SQLite&#39;s page cache are all doing exactly what your <code>phys_mem_t</code> + replacement policy does â€” but between disk and RAM instead of RAM and CPU.\nPostgreSQL uses a <strong>Clock sweep</strong> algorithm (same as your Clock) to choose victim buffers. Each buffer has a <code>usage_count</code> (0â€“5) instead of a single reference bit. The clock sweep decrements <code>usage_count</code>; a buffer is evicted only when <code>usage_count</code> reaches 0. This is a more gradual version of Clock â€” pages accumulate up to 5 &quot;lives&quot; before they can be evicted. The concept is identical, just with more resolution.\nInnoDB uses an LRU list divided into &quot;young&quot; (front 37%) and &quot;old&quot; (back 63%) regions. New pages enter the old region. If accessed within <code>innodb_old_blocks_time</code> milliseconds of entering, they stay in old â€” preventing full-table scans from polluting the cache with pages that won&#39;t be reused. This is exactly the two-list approach, again independently discovered because the problem constraints are identical.\n<strong>Dirty page write-back in databases is write-ahead logging (WAL).</strong> Before a database buffer can be evicted, any changes made to it must be written to the WAL (write-ahead log) on disk. The data file page is only updated lazily (at checkpoint time). This is structurally identical to your <code>swap_page_out()</code> call â€” you must persist the dirty data somewhere before discarding the in-memory copy. In databases, &quot;somewhere&quot; is the WAL instead of swap space, but the ordering invariant is identical: persist before discard.</p>\n<h3 id=\"5-prefetching-and-access-pattern-awareness\">5. Prefetching and Access Pattern Awareness</h3>\n<h2 id=\"your-working-set-tracker-measures-the-current-working-set-size-more-sophisticated-systems-also-use-access-patterns-to-predict-the-next-working-set-disk-aware-page-replacement-implemented-in-database-systems-not-typically-in-os-kernels-examines-access-patterns-to-prefetch-pages-that-are-likely-to-be-needed-soon-sequential-scan-detection-if-the-simulator-noticed-that-accesses-follow-a-sequential-vpn-pattern-vpn-n-n1-n2-it-could-prefetch-vpn-nk-before-it39s-needed-hiding-the-fault-latency-linux39s-mmap-with-map_populate-does-this-at-mapping-time-postgresql39s-sequential-scan-detection-switches-the-buffer-replacement-policy-for-sequential-scans-to-prevent-them-from-displacing-hot-random-access-data-your-optimal-algorithm-is-the-perfect-prefetcher-it-knows-exactly-which-pages-to-load-before-they39re-needed-because-it-has-the-future-trace-the-gap-between-optimal-and-clock-in-your-statistics-represents-the-maximum-possible-gain-from-perfect-prefetching-the-quotoracle-gapquot-real-prefetchers-close-some-fraction-of-this-gap-using-heuristic-access-pattern-detection\">Your working set tracker measures the <em>current</em> working set size. More sophisticated systems also use access patterns to <em>predict</em> the next working set. Disk-aware page replacement â€” implemented in database systems, not typically in OS kernels â€” examines access patterns to prefetch pages that are likely to be needed soon.\nSequential scan detection: if the simulator noticed that accesses follow a sequential VPN pattern (VPN N, N+1, N+2, ...), it could prefetch VPN N+k before it&#39;s needed, hiding the fault latency. Linux&#39;s <code>mmap()</code> with <code>MAP_POPULATE</code> does this at mapping time. PostgreSQL&#39;s sequential scan detection switches the buffer replacement policy for sequential scans to prevent them from displacing hot random-access data.\nYour Optimal algorithm is the perfect prefetcher: it knows exactly which pages to load before they&#39;re needed (because it has the future trace). The gap between Optimal and Clock in your statistics represents the maximum possible gain from perfect prefetching â€” the &quot;oracle gap.&quot; Real prefetchers close some fraction of this gap using heuristic access pattern detection.</h2>\n<h2 id=\"what-you39ve-built-the-complete-virtual-memory-simulator\">What You&#39;ve Built: The Complete Virtual Memory Simulator</h2>\n<p>With Milestone 4 complete, your simulator is a full implementation of every layer in a real operating system&#39;s virtual memory subsystem:</p>\n<table>\n<thead>\n<tr>\n<th>Layer</th>\n<th>Milestone</th>\n<th>What you built</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Address translation</td>\n<td>M1</td>\n<td>Flat page table, PTE flags, demand paging, protection faults</td>\n</tr>\n<tr>\n<td>Translation acceleration</td>\n<td>M2</td>\n<td>TLB with ASID tags, LRU eviction, dirty write-back, flush operations</td>\n</tr>\n<tr>\n<td>Memory efficiency</td>\n<td>M3</td>\n<td>Two-level page table, CR3 simulation, on-demand table allocation</td>\n</tr>\n<tr>\n<td>Bounded physical memory</td>\n<td>M4</td>\n<td>FIFO, LRU, Clock, Optimal replacement + swap space + statistics</td>\n</tr>\n<tr>\n<td>The system you&#39;ve built processes real memory access traces, produces measurable statistics, and lets you experimentally validate properties that OS textbooks describe abstractly. You can now:</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li>Construct adversarial FIFO traces that trigger BÃ©lÃ¡dy&#39;s anomaly</li>\n<li>Measure the efficiency gap between Clock (production-practical) and Optimal (theoretically perfect)</li>\n<li>Quantify the dirty write-back cost of different access patterns</li>\n<li>Observe working set dynamics as your simulator processes real traces</li>\n<li>Demonstrate that the same reference string produces different fault counts under different policies â€” and understand <em>why</em> from the algorithm&#39;s victim selection logic\nThe mental model you&#39;ve built â€” PTE flags, TLB coherence invariants, the clean/dirty distinction, stack algorithm properties â€” transfers directly to reading Linux kernel source code (<code>mm/vmscan.c</code>, <code>mm/swap.c</code>, <code>arch/x86/mm/tlb.c</code>), debugging production memory pressure issues (<code>/proc/vmstat</code>, <code>perf stat cache-misses</code>), and designing application-level caches with the same principles.</li>\n</ul>\n<hr>\n<!-- END_MS -->\n\n\n<h2 id=\"system-overview\">System Overview</h2>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Fsystem-overview.svg\" alt=\"System Overview\"></p>\n<h1 id=\"tdd\">TDD</h1>\n<p>A layered, hardware-faithful simulator built in four milestone modules, each fixing a concrete limitation exposed by the previous one. The physical constraint negotiated throughout is the finite 64-frame pool vs. unbounded virtual greed. Every struct mirrors real hardware registers (CR3, PTE, TLB entry). Every algorithm is measurable via trace-driven statistics. The TDD blueprint specifies byte-level layouts, cache-line analysis, exact state machines, and sequence diagrams for all coherence-critical operations â€” particularly TLB invalidation ordering and dirty-write-back sequencing, both of which are silent-corruption landmines if misordered.</p>\n<!-- TDD_MOD_ID: virtual-memory-sim-m1 -->\n<h1 id=\"technical-design-specification-single-level-page-table-and-address-translation-m1\">Technical Design Specification: Single-Level Page Table and Address Translation (m1)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module implements the foundational translation layer for the Virtual Memory Simulator. It establishes the &quot;Physical/Hardware Soul&quot; of the project by defining the bit-level contract for Page Table Entries (PTEs) and the mechanical process of decomposing a virtual address into its constituent components (VPN and Offset). </p>\n<p><strong>What it does:</strong></p>\n<ul>\n<li>Defines the <code>pte_t</code> bit-packed structure and <code>page_table_t</code> flat array.</li>\n<li>Implements bit-shifting logic to extract the Virtual Page Number (VPN) and Offset.</li>\n<li>Provides a <code>translate()</code> function that performs O(1) lookup, permission checking, and metadata bit updates (Referenced/Dirty).</li>\n<li>Implements a demand-paging fault handler that allocates frames from a fixed pool on first access.</li>\n<li>Parses memory access trace files into an internal executable sequence.</li>\n</ul>\n<p><strong>What it does NOT do:</strong></p>\n<ul>\n<li>It does not implement TLB caching (M2).</li>\n<li>It does not implement multi-level hierarchical tables (M3).</li>\n<li>It does not implement page replacement (M4); the simulator will treat physical memory exhaustion as a fatal <code>XLATE_OOM</code> error in this milestone.</li>\n</ul>\n<p><strong>Upstream Dependencies:</strong> None.\n<strong>Downstream Dependencies:</strong> Milestone 2 (TLB) will wrap the <code>translate()</code> function; Milestone 3 will replace the flat <code>page_table_t</code> with a tree.</p>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>The bottom <code>log2(PAGE_SIZE)</code> bits of the virtual address MUST remain identical in the physical address (Offset preservation).</li>\n<li>A write access to a page with <code>valid=1</code> but <code>perm_write=0</code> MUST trigger a <code>XLATE_PROT_FAULT</code> immediately.</li>\n<li>The <code>dirty</code> bit MUST only be set on <code>ACCESS_WRITE</code>, never on <code>ACCESS_READ</code>.</li>\n</ul>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>The implementation should follow this creation order:</p>\n<ol>\n<li><code>vmsim_types.h</code>: Common type definitions, bit-masks, and configuration constants.</li>\n<li><code>trace_parser.h / .c</code>: Logic for reading and tokenizing the <code>.trace</code> files.</li>\n<li><code>mmu.h / .c</code>: The core translation logic, bit-manipulation, and fault handling.</li>\n<li><code>main.c</code>: Simulator entry point, loop, and statistics reporting.</li>\n</ol>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-bit-level-page-table-entry-pte_t\">3.1. Bit-Level Page Table Entry (pte_t)</h3>\n<p>The <code>pte_t</code> is a 32-bit (4-byte) structure. We use explicit bit-masking to ensure hardware-faithful behavior regardless of compiler bit-field packing order.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Bit Range</th>\n<th align=\"left\">Name</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">[31:12]</td>\n<td align=\"left\"><strong>PFN</strong></td>\n<td align=\"left\">Physical Frame Number. Maps to a 4KB-aligned frame in <code>phys_mem</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">[11:8]</td>\n<td align=\"left\"><strong>RSVD</strong></td>\n<td align=\"left\">Reserved for future use (e.g., protection keys).</td>\n</tr>\n<tr>\n<td align=\"left\">[7]</td>\n<td align=\"left\"><strong>A</strong></td>\n<td align=\"left\">Accessed/Referenced bit. Set by hardware/MMU on any access.</td>\n</tr>\n<tr>\n<td align=\"left\">[6]</td>\n<td align=\"left\"><strong>D</strong></td>\n<td align=\"left\">Dirty bit. Set by hardware/MMU on write access only.</td>\n</tr>\n<tr>\n<td align=\"left\">[5]</td>\n<td align=\"left\"><strong>R</strong></td>\n<td align=\"left\">Read permission bit. 1 = Readable.</td>\n</tr>\n<tr>\n<td align=\"left\">[4]</td>\n<td align=\"left\"><strong>W</strong></td>\n<td align=\"left\">Write permission bit. 1 = Writable.</td>\n</tr>\n<tr>\n<td align=\"left\">[3:1]</td>\n<td align=\"left\"><strong>RSVD</strong></td>\n<td align=\"left\">Reserved.</td>\n</tr>\n<tr>\n<td align=\"left\">[0]</td>\n<td align=\"left\"><strong>V</strong></td>\n<td align=\"left\">Valid/Present bit. 1 = Mapping is in RAM. 0 = Fault.</td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// vmsim_types.h</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#79B8FF\"> pte_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_V_MASK</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_W_MASK</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_R_MASK</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_D_MASK</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_A_MASK</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_PFN_MASK</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FFFFF000</span><span style=\"color:#F97583\">u</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_PFN_SHIFT</span><span style=\"color:#79B8FF\"> 12</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper macros for PTE manipulation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_GET_PFN</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pte</span><span style=\"color:#E1E4E8\">) (((pte) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_PFN_MASK) </span><span style=\"color:#F97583\">>></span><span style=\"color:#E1E4E8\"> PTE_PFN_SHIFT)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_SET_PFN</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pfn</span><span style=\"color:#E1E4E8\">) (((pfn) </span><span style=\"color:#F97583\">&#x3C;&#x3C;</span><span style=\"color:#E1E4E8\"> PTE_PFN_SHIFT) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_PFN_MASK)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_IS_VALID</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pte</span><span style=\"color:#E1E4E8\">) ((pte) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_V_MASK)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PTE_IS_WRITABLE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pte</span><span style=\"color:#E1E4E8\">) ((pte) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PTE_W_MASK)</span></span></code></pre></div>\n\n<h3 id=\"32-physical-frame-physical_frame_t\">3.2. Physical Frame (physical_frame_t)</h3>\n<p>Represents one 4096-byte page of simulated RAM.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\"> // Simulated page content (zeroed on alloc)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> owner_vpn;</span><span style=\"color:#6A737D\">  // Back-reference for debugging/replacement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\">     in_use;</span><span style=\"color:#6A737D\">     // Allocation status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">physical_frame_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<h3 id=\"33-page-table-page_table_t\">3.3. Page Table (page_table_t)</h3>\n<p>A flat array of entries covering the 32-bit address space with 4KB pages.\nSize: $2^{32} / 2^{12} = 2^{20} = 1,048,576$ entries.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">entries;</span><span style=\"color:#6A737D\">      // Heap-allocated array of 1,048,576 pte_t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> num_entries;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<h3 id=\"34-simulator-context-simulator_t\">3.4. Simulator Context (simulator_t)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#E1E4E8\">      pt;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    physical_frame_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">frames;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">          num_frames;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> stats_accesses;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> stats_page_faults;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> stats_prot_faults;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">simulator_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-1.svg\" alt=\"pte_t Memory Layout â€” Bit-Level Field Map\"></p>\n<p><em>Diagram 1: Memory Layout of the Simulator. Shows the 4MB Page Table pointing into a fixed 256KB pool of physical frames (assuming 64 frames).</em></p>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-address-decomposition\">4.1. Address Decomposition</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> vpn_from_addr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> offset_from_addr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<ul>\n<li><strong>VPN:</strong> <code>vaddr &gt;&gt; 12</code>.</li>\n<li><strong>Offset:</strong> <code>vaddr &amp; 0xFFF</code>.</li>\n</ul>\n<h3 id=\"42-core-translation\">4.2. Core Translation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    XLATE_SUCCESS,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    XLATE_PAGE_FAULT,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    XLATE_PROT_FAULT,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    XLATE_OOM</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">xlate_result_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    xlate_result_t</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">       paddr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#B392F0\"> translate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">simulator_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sim</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_write</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<ul>\n<li><strong>Constraints:</strong> <code>vaddr</code> is a 32-bit unsigned integer. <code>is_write</code> distinguishes read/write logic.</li>\n<li><strong>Edge Case:</strong> If <code>vpn &gt;= 1048576</code>, return <code>XLATE_PROT_FAULT</code> (Segmentation Fault).</li>\n</ul>\n<h3 id=\"43-trace-parsing\">4.3. Trace Parsing</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\">     type;</span><span style=\"color:#6A737D\">    // 'R' or 'W'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vaddr;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">mem_access_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> load_trace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">filename</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">mem_access_t</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">out_accesses</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">out_count</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<ul>\n<li><strong>Constraint:</strong> Must ignore lines starting with <code>#</code> and empty lines.</li>\n<li><strong>Format:</strong> <code>%c 0x%x</code>.</li>\n</ul>\n<h2 id=\"5-algorithm-specification-translate\">5. Algorithm Specification: <code>translate()</code></h2>\n<p>The <code>translate</code> function acts as the simulated MMU.</p>\n<ol>\n<li><strong>Extract Components:</strong> Calculate <code>vpn</code> and <code>offset</code> using bitwise shifts and masks.</li>\n<li><strong>Boundary Check:</strong> If <code>vpn &gt;= sim-&gt;pt.num_entries</code>, return <code>XLATE_PROT_FAULT</code>.</li>\n<li><strong>Fetch PTE:</strong> <code>pte_t pte = sim-&gt;pt.entries[vpn]</code>.</li>\n<li><strong>Valid Check (Demand Paging):</strong><ul>\n<li>If <code>!PTE_IS_VALID(pte)</code>:<ul>\n<li>Call <code>handle_page_fault(sim, vpn, is_write)</code>.</li>\n<li>If fault handler returns failure, return <code>XLATE_OOM</code>.</li>\n<li>Re-fetch <code>pte</code> from the updated table.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Protection Check:</strong><ul>\n<li>If <code>is_write</code> AND <code>!PTE_IS_WRITABLE(pte)</code>:<ul>\n<li>Increment <code>stats_prot_faults</code>.</li>\n<li>Return <code>XLATE_PROT_FAULT</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Update Metadata:</strong><ul>\n<li>Set <code>PTE_A_MASK</code> (Accessed) in <code>sim-&gt;pt.entries[vpn]</code>.</li>\n<li>If <code>is_write</code>, set <code>PTE_D_MASK</code> (Dirty) in <code>sim-&gt;pt.entries[vpn]</code>.</li>\n</ul>\n</li>\n<li><strong>Reconstruct Address:</strong><ul>\n<li><code>uint32_t pfn = PTE_GET_PFN(pte)</code>.</li>\n<li><code>uint32_t paddr = (pfn &lt;&lt; 12) | offset</code>.</li>\n</ul>\n</li>\n<li><strong>Return:</strong> <code>XLATE_SUCCESS</code> with <code>paddr</code>.</li>\n</ol>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-2.svg\" alt=\"simulator_t and Supporting Structs â€” Full Module Architecture\"></p>\n<p><em>Diagram 2: Flowchart of translate() function logic, highlighting the early-exit on faults vs. the metadata update path.</em></p>\n<h2 id=\"6-algorithm-specification-handle_page_fault\">6. Algorithm Specification: <code>handle_page_fault()</code></h2>\n<ol>\n<li><strong>Scan for Free Frame:</strong> Iterate through <code>sim-&gt;frames[0...num_frames-1]</code>.</li>\n<li><strong>Find Victim (M1 Simplified):</strong><ul>\n<li>If a frame has <code>in_use == false</code>: Use it.</li>\n<li>If NO frames are free: Return <code>XLATE_OOM</code>. (Replacing logic is M4).</li>\n</ul>\n</li>\n<li><strong>Initialize Frame:</strong><ul>\n<li>Set <code>frame.in_use = true</code>.</li>\n<li>Set <code>frame.owner_vpn = vpn</code>.</li>\n<li><code>memset(frame.data, 0, 4096)</code> (security: zero-fill).</li>\n</ul>\n</li>\n<li><strong>Update Page Table:</strong><ul>\n<li>Create new <code>pte_t</code>.</li>\n<li>Set <code>PFN</code> to the index of the found frame.</li>\n<li>Set <code>PTE_V_MASK</code>.</li>\n<li>Set <code>PTE_R_MASK</code> (all pages readable).</li>\n<li>If fault was triggered by a write, set <code>PTE_W_MASK</code>.</li>\n<li>Store back to <code>sim-&gt;pt.entries[vpn]</code>.</li>\n</ul>\n</li>\n<li><strong>Log Statistics:</strong> Increment <code>stats_page_faults</code>.</li>\n</ol>\n<h2 id=\"7-error-handling-matrix\">7. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>XLATE_PAGE_FAULT</code></td>\n<td align=\"left\"><code>translate()</code> via <code>valid</code> bit</td>\n<td align=\"left\">Invoke <code>handle_page_fault()</code>, reload PTE</td>\n<td align=\"left\">Yes (log entry)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>XLATE_PROT_FAULT</code></td>\n<td align=\"left\"><code>translate()</code> via <code>perm_write</code> bit</td>\n<td align=\"left\">Stop access, log error, continue to next trace line</td>\n<td align=\"left\">Yes (error message)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>XLATE_OOM</code></td>\n<td align=\"left\"><code>handle_page_fault()</code></td>\n<td align=\"left\">Terminal for current trace sequence in M1</td>\n<td align=\"left\">Yes (CRITICAL)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>FILE_NOT_FOUND</code></td>\n<td align=\"left\"><code>load_trace()</code></td>\n<td align=\"left\">Abort program</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>MALFORMED_ADDR</code></td>\n<td align=\"left\"><code>sscanf</code> in parser</td>\n<td align=\"left\">Skip line, increment skip_count</td>\n<td align=\"left\">No</td>\n</tr>\n</tbody></table>\n<h2 id=\"8-implementation-sequence-with-checkpoints\">8. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-bit-math-amp-structs-15-hours\">Phase 1: Bit Math &amp; Structs (1.5 Hours)</h3>\n<ul>\n<li>Define <code>pte_t</code> masks and macros.</li>\n<li>Implement <code>vpn_from_addr</code> and <code>offset_from_addr</code>.</li>\n<li><strong>Checkpoint:</strong> Write a small main that takes <code>0x1A3F7C</code> and prints <code>VPN: 0x1A3, Offset: 0xF7C</code>. Verify against manual bit decomposition.</li>\n</ul>\n<h3 id=\"phase-2-trace-parser-1-hour\">Phase 2: Trace Parser (1 Hour)</h3>\n<ul>\n<li>Implement <code>load_trace</code> using <code>fgets</code> and <code>sscanf</code>.</li>\n<li>Implement internal array storage for <code>mem_access_t</code>.</li>\n<li><strong>Checkpoint:</strong> Load a file with 10 lines, print them back. Ensure <code>#</code> comments are skipped.</li>\n</ul>\n<h3 id=\"phase-3-the-mmu-core-2-hours\">Phase 3: The MMU Core (2 Hours)</h3>\n<ul>\n<li>Implement <code>simulator_init</code> (allocate 4MB for PT).</li>\n<li>Implement <code>translate()</code> and <code>handle_page_fault()</code>.</li>\n<li>Implement <code>alloc_free_frame()</code> with linear scan.</li>\n<li><strong>Checkpoint:</strong> Run a trace that accesses 5 different pages. Verify <code>stats_page_faults</code> is 5 and <code>frames_used</code> is 5.</li>\n</ul>\n<h3 id=\"phase-4-protection-logic-1-hour\">Phase 4: Protection Logic (1 Hour)</h3>\n<ul>\n<li>Implement a <code>simulator_mmap(sim, vpn, bool writable)</code> helper to pre-set PTEs.</li>\n<li>Write a test trace that writes to a VPN previously mapped as read-only.</li>\n<li><strong>Checkpoint:</strong> Run simulator. Verify <code>PROTECTION FAULT</code> is logged for the illegal write.</li>\n</ul>\n<h2 id=\"9-test-specification\">9. Test Specification</h2>\n<h3 id=\"91-unit-test-address-decomposition\">9.1. Unit Test: Address Decomposition</h3>\n<ul>\n<li><strong>Input:</strong> <code>0xDEADBEEF</code>.</li>\n<li><strong>Expected:</strong> VPN = <code>0xDEADB</code>, Offset = <code>0xEEF</code>.</li>\n<li><strong>Input:</strong> <code>0x00000000</code>.</li>\n<li><strong>Expected:</strong> VPN = <code>0</code>, Offset = <code>0</code>.</li>\n</ul>\n<h3 id=\"92-integration-test-demand-paging\">9.2. Integration Test: Demand Paging</h3>\n<ul>\n<li><strong>Trace:</strong></li>\n</ul>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>  R 0x1000\n  W 0x1004\n  R 0x2000</code></pre></div>\n<ul>\n<li><strong>Expectation:</strong><ul>\n<li>Access 1: Page Fault, VPN 1 -&gt; Frame 0. <code>paddr</code> = 0x0000.</li>\n<li>Access 2: Success (Valid=1), VPN 1 -&gt; Frame 0. <code>paddr</code> = 0x0004. Dirty bit set.</li>\n<li>Access 3: Page Fault, VPN 2 -&gt; Frame 1. <code>paddr</code> = 0x1000.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"93-edge-case-oom-limit\">9.3. Edge Case: OOM Limit</h3>\n<ul>\n<li>Set <code>NUM_FRAMES = 2</code>.</li>\n<li><strong>Trace:</strong></li>\n</ul>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>  R 0x1000\n  R 0x2000\n  R 0x3000</code></pre></div>\n<ul>\n<li><strong>Expectation:</strong><ul>\n<li>Access 1 &amp; 2: Success (Fault + Alloc).</li>\n<li>Access 3: <code>XLATE_OOM</code> error.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"10-performance-targets\">10. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>translate()</code></td>\n<td align=\"left\">&lt; 50ns</td>\n<td align=\"left\">Average of 1M calls using <code>clock_gettime</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>load_trace()</code></td>\n<td align=\"left\">1M lines / sec</td>\n<td align=\"left\">Wall clock time for large traces.</td>\n</tr>\n<tr>\n<td align=\"left\">Page Table Memory</td>\n<td align=\"left\">4.0 MiB</td>\n<td align=\"left\"><code>sizeof(pte_t) * (1 &lt;&lt; 20)</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">Frame Scan</td>\n<td align=\"left\">O(F)</td>\n<td align=\"left\">Linear scan time where F is frame count.</td>\n</tr>\n</tbody></table>\n<h2 id=\"11-hardware-soul-cache-line-impact\">11. Hardware Soul - Cache Line Impact</h2>\n<p>In a real system, the <code>page_table_t</code> array would be accessed from RAM. </p>\n<ul>\n<li>A <code>pte_t</code> is 4 bytes.</li>\n<li>A CPU cache line is 64 bytes.</li>\n<li>Therefore, one cache line fetch brings in 16 PTEs. </li>\n<li>Sequential access (e.g., VPN 0, then VPN 1) will hit the same cache line.</li>\n<li>In this simulator, we can measure the &quot;PTE Locality&quot; by tracking how often <code>current_vpn</code> is within +/- 16 of <code>previous_vpn</code>.</li>\n</ul>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-3.svg\" alt=\"Virtual Address Decomposition: VPN + Offset via Bit Shifting\"></p>\n<p><em>Diagram 3: Cache-line visualization showing 16 PTEs packed into a single 64B block.</em></p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: virtual-memory-sim-m2 -->\n<h1 id=\"technical-design-specification-tlb-translation-lookaside-buffer-m2\">Technical Design Specification: TLB (Translation Lookaside Buffer) (m2)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module implements the <strong>Translation Lookaside Buffer (TLB)</strong>, a high-speed associative cache designed to reduce the frequency of expensive page table walks. In Milestone 1, every memory access required a lookup in the flat page table array. Milestone 2 introduces a software-simulated TLB that caches recent <code>Virtual Page Number (VPN) -&gt; Physical Frame Number (PFN)</code> mappings.</p>\n<p><strong>What it does:</strong></p>\n<ul>\n<li>Implements a fully-associative TLB with a configurable number of entries (default 64).</li>\n<li>Provides $O(TLB_SIZE)$ lookup with three-way tag matching: <code>(Valid bit, ASID, VPN)</code>.</li>\n<li>Implements <strong>Address Space ID (ASID)</strong> support, allowing translations for multiple processes to coexist in the TLB simultaneously, significantly reducing context-switch overhead.</li>\n<li>Manages <strong>TLB Coherence</strong> via dirty/referenced bit write-back to the main page table upon entry eviction or flush.</li>\n<li>Provides multiple eviction policies: <strong>LRU (Least Recently Used)</strong> via age-counters and <strong>Seeded-Random</strong> for reproducible testing.</li>\n<li>Implements targeted flush operations: <code>flush_all</code>, <code>flush_asid</code>, and <code>flush_page</code>.</li>\n</ul>\n<p><strong>What it does NOT do:</strong></p>\n<ul>\n<li>It does not implement multi-level page tables (M3).</li>\n<li>It does not handle page replacement/swap logic (M4).</li>\n<li>It does not simulate hardware multi-threading or SMP TLB shootdowns (Single-core simulation only).</li>\n</ul>\n<p><strong>Upstream Dependencies:</strong> Milestone 1 (Page Table Entry definitions, VPN decomposition).\n<strong>Downstream Dependencies:</strong> Milestone 3 (Multi-level page walks will be triggered by TLB misses).</p>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>A TLB hit MUST be authoritative; the main page table is not consulted on a hit.</li>\n<li>Any modification to a TLB entry&#39;s <code>Dirty</code> or <code>Referenced</code> bits MUST eventually be synchronized with the main Page Table (on eviction or flush).</li>\n<li>A context switch without a flush MUST only allow lookups where <code>entry.asid == current_asid</code>.</li>\n</ul>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>Implementation follows this creation order:</p>\n<ol>\n<li><code>tlb.h</code>: Struct definitions for <code>tlb_entry_t</code>, <code>tlb_t</code>, and function prototypes.</li>\n<li><code>tlb.c</code>: Implementation of lookup, insertion, and eviction logic.</li>\n<li><code>mmu_v2.c</code>: Integration of TLB into the translation pipeline (wrapping M1 logic).</li>\n<li><code>tlb_tests.c</code>: Unit tests for LRU, Random eviction, and ASID isolation.</li>\n</ol>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-tlb-entry-layout-tlb_entry_t\">3.1. TLB Entry Layout (tlb_entry_t)</h3>\n<p>A <code>tlb_entry_t</code> is designed to be compact (12 bytes) to maximize cache density. In a real system, these would be searched in parallel via Content-Addressable Memory (CAM).</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Byte Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>vpn</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Virtual Page Number (The Tag).</td>\n</tr>\n<tr>\n<td align=\"left\">0x04</td>\n<td align=\"left\"><code>pfn</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Physical Frame Number (The Data).</td>\n</tr>\n<tr>\n<td align=\"left\">0x08</td>\n<td align=\"left\"><code>asid</code></td>\n<td align=\"left\"><code>uint16_t</code></td>\n<td align=\"left\">Address Space Identifier (0-65535).</td>\n</tr>\n<tr>\n<td align=\"left\">0x0A</td>\n<td align=\"left\"><code>flags</code></td>\n<td align=\"left\"><code>uint8_t</code></td>\n<td align=\"left\">Bitmask: Valid, Dirty, Ref, Writable.</td>\n</tr>\n<tr>\n<td align=\"left\">0x0B</td>\n<td align=\"left\"><code>age</code></td>\n<td align=\"left\"><code>uint8_t</code></td>\n<td align=\"left\">LRU counter (0 = fresh, 255 = oldest).</td>\n</tr>\n</tbody></table>\n<p><strong>Bitmask for <code>flags</code>:</strong></p>\n<ul>\n<li><code>0x01</code>: <code>TLB_V</code> (Valid)</li>\n<li><code>0x02</code>: <code>TLB_D</code> (Dirty - set on write)</li>\n<li><code>0x04</code>: <code>TLB_R</code> (Referenced - set on any hit)</li>\n<li><code>0x08</code>: <code>TLB_W</code> (Writable - copied from PTE)</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vpn;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> pfn;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> asid;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  flags;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#E1E4E8\">  age;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">tlb_entry_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<h3 id=\"32-tlb-context-tlb_t\">3.2. TLB Context (tlb_t)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    tlb_entry_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">entries;</span><span style=\"color:#6A737D\">      // Array of size TLB_SIZE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">     size;</span><span style=\"color:#6A737D\">         // Configurable (16, 32, 64)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\">     active_asid;</span><span style=\"color:#6A737D\">  // Current process ID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">     rand_state;</span><span style=\"color:#6A737D\">   // Seed for random eviction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> hits;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> misses;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> evictions;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\"> flushes;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<h3 id=\"33-cache-line-analysis-mandatory\">3.3. Cache Line Analysis (MANDATORY)</h3>\n<ul>\n<li><code>sizeof(tlb_entry_t)</code> = 12 bytes.</li>\n<li>Standard x86_64 Cache Line = 64 bytes.</li>\n<li>64 / 12 = 5.33. This means a single cache line fetch pulls in ~5 TLB entries.</li>\n<li>A 64-entry TLB consumes 768 bytes, fitting comfortably within the 32KB L1 Data Cache. </li>\n<li>Sequential scans of the TLB in software are highly cache-friendly.</li>\n</ul>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-9.svg\" alt=\"tlb_entry_t Memory Layout â€” 12-Byte Struct with Flag Byte Detail\"></p>\n<p><em>Diagram 9: Byte-offset layout of tlb_entry_t and its packing within a 64B cache line.</em></p>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-tlb-operations\">4.1. TLB Operations</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Initialize TLB with size and random seed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tlb_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> size</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> seed</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Search for a translation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns: hit_pfn on success, or sentinel 0xFFFFFFFF on miss</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> tlb_lookup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vpn</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_write</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">out_status</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Insert a new translation (triggers eviction if full)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tlb_insert</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vpn</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> pfn</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> writable</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h3 id=\"42-flush-amp-maintenance\">4.2. Flush &amp; Maintenance</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Invalidate all entries (Global Flush)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tlb_flush_all</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Invalidate entries for a specific process (Context Flush)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tlb_flush_asid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> asid</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Invalidate specific page (required for coherence when PTE changes)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> tlb_flush_page</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vpn</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h3 id=\"43-context-switching\">4.3. Context Switching</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Switch the active ASID. If asid_support is false, triggers tlb_flush_all.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> context_switch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> new_asid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> flush_on_switch</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h2 id=\"5-algorithm-specification\">5. Algorithm Specification</h2>\n<h3 id=\"51-tlb_lookup-the-hot-path\">5.1. <code>tlb_lookup</code> (The Hot Path)</h3>\n<ol>\n<li><strong>Iterate</strong> through <code>tlb-&gt;entries[0...size-1]</code>.</li>\n<li><strong>Tag Match Check</strong>:<ul>\n<li><code>if ((e.flags &amp; TLB_V) &amp;&amp; (e.asid == tlb-&gt;active_asid) &amp;&amp; (e.vpn == vpn))</code></li>\n</ul>\n</li>\n<li><strong>On Hit</strong>:<ul>\n<li>Increment <code>tlb-&gt;hits</code>.</li>\n<li><strong>Permission Check</strong>: If <code>is_write</code> AND <code>!(e.flags &amp; TLB_W)</code>, return <code>XLATE_PROT_FAULT_TLB</code>.</li>\n<li><strong>Update Flags</strong>: <code>e.flags |= TLB_R</code>. If <code>is_write</code>, <code>e.flags |= TLB_D</code>.</li>\n<li><strong>LRU Update</strong>: Reset <code>e.age = 0</code>. Increment age of all OTHER valid entries (cap at 255).</li>\n<li>Return <code>e.pfn</code>.</li>\n</ul>\n</li>\n<li><strong>On Miss</strong>:<ul>\n<li>Increment <code>tlb-&gt;misses</code>.</li>\n<li>Return <code>MISS_SENTINEL</code>.</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-10.svg\" alt=\"TLB Position in Address Translation Pipeline\"></p>\n<p><em>Diagram 10: Logic flow of TLB Lookup including ASID matching and LRU aging.</em></p>\n<h3 id=\"52-tlb_insert-with-coherence-write-back\">5.2. <code>tlb_insert</code> with Coherence Write-back</h3>\n<ol>\n<li><strong>Find Victim</strong>:<ul>\n<li><strong>Step A</strong>: Search for any entry with <code>!(flags &amp; TLB_V)</code>. If found, use this slot.</li>\n<li><strong>Step B</strong>: If no invalid slots, use policy:<ul>\n<li><strong>LRU</strong>: Find entry with highest <code>age</code>.</li>\n<li><strong>Random</strong>: <code>idx = tlb_rand_next() % size</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Coherence Write-back</strong>:<ul>\n<li>If victim entry is valid (<code>TLB_V</code>):<ul>\n<li>Increment <code>tlb-&gt;evictions</code>.</li>\n<li>Fetch the main Page Table Entry: <code>pte_t *pte = &amp;pt-&gt;entries[victim.vpn]</code>.</li>\n<li><strong>Sync Flags</strong>:<ul>\n<li>If <code>victim.flags &amp; TLB_D</code>, then <code>*pte |= PTE_D_MASK</code>.</li>\n<li>If <code>victim.flags &amp; TLB_R</code>, then <code>*pte |= PTE_A_MASK</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Populate New Entry</strong>:<ul>\n<li><code>e.vpn = vpn</code>, <code>e.pfn = pfn</code>, <code>e.asid = tlb-&gt;active_asid</code>.</li>\n<li><code>e.flags = TLB_V | TLB_R</code>. If <code>writable</code>, <code>e.flags |= TLB_W</code>.</li>\n<li><code>e.age = 0</code>.</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-11.svg\" alt=\"tlb_lookup() State Machine: VALID â†’ ASID â†’ VPN â†’ Result\"></p>\n<p><em>Diagram 11: Sequence diagram of TLB Eviction showing the critical write-back to the M1 Page Table.</em></p>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>PROT_FAULT_TLB</code></td>\n<td align=\"left\"><code>tlb_lookup</code></td>\n<td align=\"left\">Access aborted, log fault.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>TLB_MISS</code></td>\n<td align=\"left\"><code>translate_with_tlb</code></td>\n<td align=\"left\">Perform Page Table Walk, call <code>tlb_insert</code>.</td>\n<td align=\"left\">No (Status log)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>STALE_ENTRY</code></td>\n<td align=\"left\">Simulator logic</td>\n<td align=\"left\">Manual <code>tlb_flush_page</code> call required on PTE change.</td>\n<td align=\"left\">If missed: Data corruption.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>LRU_OVERFLOW</code></td>\n<td align=\"left\"><code>tlb_lookup</code> age increment</td>\n<td align=\"left\"><code>if (age &lt; 255) age++;</code></td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ASID_MISMATCH</code></td>\n<td align=\"left\"><code>tlb_lookup</code></td>\n<td align=\"left\">Treated as a Miss.</td>\n<td align=\"left\">No</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-foundation-1-hour\">Phase 1: Foundation (1 Hour)</h3>\n<ul>\n<li>Define <code>tlb_entry_t</code> and <code>tlb_t</code>.</li>\n<li>Implement <code>tlb_init</code> and <code>tlb_flush_all</code>.</li>\n<li><strong>Checkpoint:</strong> Initialize a 16-entry TLB. Verify all <code>flags</code> are 0 and <code>asid</code> is <code>active_asid</code>.</li>\n</ul>\n<h3 id=\"phase-2-lookup-amp-lru-2-hours\">Phase 2: Lookup &amp; LRU (2 Hours)</h3>\n<ul>\n<li>Implement <code>tlb_lookup</code> with tag matching.</li>\n<li>Implement the $O(N)$ LRU aging logic (increment all, reset one).</li>\n<li><strong>Checkpoint:</strong> Manually insert 2 entries. Call <code>lookup</code> on Entry A, then Entry B. Verify <code>age</code> of A is 1 and <code>age</code> of B is 0.</li>\n</ul>\n<h3 id=\"phase-3-insertion-amp-eviction-2-hours\">Phase 3: Insertion &amp; Eviction (2 Hours)</h3>\n<ul>\n<li>Implement <code>tlb_insert</code>.</li>\n<li>Implement <code>tlb_find_victim_lru</code> and <code>tlb_writeback_entry</code>.</li>\n<li><strong>Checkpoint:</strong> Set <code>TLB_SIZE = 2</code>. Insert VPN 1, 2, 3. Verify VPN 1 is evicted and its Dirty bit is correctly reflected in the <code>page_table_t</code>.</li>\n</ul>\n<h3 id=\"phase-4-integration-15-hours\">Phase 4: Integration (1.5 Hours)</h3>\n<ul>\n<li>Create <code>translate_with_tlb</code>.</li>\n<li>Logic: <code>tlb_lookup</code> -&gt; if Miss -&gt; <code>m1_translate</code> -&gt; <code>tlb_insert</code>.</li>\n<li><strong>Checkpoint:</strong> Run M1 basic trace. Total hits should be 0 on first pass, but subsequent accesses to the same page should show <code>TLB: HIT</code>.</li>\n</ul>\n<h3 id=\"phase-5-asid-amp-context-switching-1-hour\">Phase 5: ASID &amp; Context Switching (1 Hour)</h3>\n<ul>\n<li>Implement <code>context_switch</code>.</li>\n<li>Update <code>tlb_lookup</code> to enforce <code>asid</code> matching.</li>\n<li><strong>Checkpoint:</strong> Process 1 (ASID 1) accesses VPN 0x10. Context switch to Process 2 (ASID 2). Access VPN 0x10. Verify a TLB Miss occurs.</li>\n</ul>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-unit-test-asid-isolation\">8.1. Unit Test: ASID Isolation</h3>\n<ul>\n<li><strong>Setup:</strong> ASID 1 maps VPN 0x10 -&gt; PFN 0xA. ASID 2 maps VPN 0x10 -&gt; PFN 0xB.</li>\n<li><strong>Test:</strong> Set <code>active_asid = 1</code>, <code>lookup(0x10)</code>. Expect PFN 0xA. Set <code>active_asid = 2</code>, <code>lookup(0x10)</code>. Expect PFN 0xB.</li>\n<li><strong>Success:</strong> No cross-contamination between address spaces.</li>\n</ul>\n<h3 id=\"82-unit-test-lru-eviction-order\">8.2. Unit Test: LRU Eviction Order</h3>\n<ul>\n<li><strong>Setup:</strong> <code>TLB_SIZE = 4</code>. Access VPNs 1, 2, 3, 4. </li>\n<li><strong>Action:</strong> Access VPN 1 (makes it youngest). Access VPN 5.</li>\n<li><strong>Expectation:</strong> VPN 2 should be evicted (it was the oldest after 1 was refreshed).</li>\n<li><strong>Success:</strong> <code>tlb_lookup(2)</code> returns MISS. <code>tlb_lookup(1)</code> returns HIT.</li>\n</ul>\n<h3 id=\"83-integration-test-dirty-write-back\">8.3. Integration Test: Dirty Write-back</h3>\n<ul>\n<li><strong>Setup:</strong> TLB Hit on VPN 0x5 with <code>is_write = true</code>.</li>\n<li><strong>Action:</strong> Call <code>tlb_flush_page(0x5)</code>.</li>\n<li><strong>Expectation:</strong> The PTE in the flat page table for VPN 0x5 must now have <code>PTE_D_MASK</code> set.</li>\n</ul>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>tlb_lookup</code> (64 entries)</td>\n<td align=\"left\">&lt; 100ns</td>\n<td align=\"left\">Average over 10M lookups.</td>\n</tr>\n<tr>\n<td align=\"left\">Hit Rate (Sequential)</td>\n<td align=\"left\">&gt; 99%</td>\n<td align=\"left\">Trace: <code>R 0x1000, R 0x1004, ... R 0x1FFC</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">Hit Rate (Random)</td>\n<td align=\"left\">~0.02%</td>\n<td align=\"left\">Trace: Uniformly random VPNs over 1GB space.</td>\n</tr>\n<tr>\n<td align=\"left\">Write-back Overhead</td>\n<td align=\"left\">&lt; 5%</td>\n<td align=\"left\">Total simulation time delta vs. M1.</td>\n</tr>\n</tbody></table>\n<h2 id=\"10-hardware-soul-cam-vs-linear-scan\">10. Hardware Soul - CAM vs Linear Scan</h2>\n<p>In real hardware, the TLB uses <strong>Content Addressable Memory (CAM)</strong>. </p>\n<ul>\n<li><strong>CAM Logic:</strong> The VPN is broadcast to every slot simultaneously. Each slot has a comparator that triggers a match signal in parallel ($O(1)$).</li>\n<li><strong>Simulator Logic:</strong> We use a loop ($O(N)$). </li>\n<li><strong>Performance Note:</strong> Even though we are $O(N)$, because the data structure (768 bytes) fits in the L1 Cache, the loop is extremely fast. However, we must not increase <code>TLB_SIZE</code> beyond ~256 in software, as the linear scan will eventually exceed the cost of a Page Table walk.</li>\n</ul>\n<p>{{DIAGRAM:tdd-diag-12}}\n<em>Diagram 12: Sequence diagram of a Context Switch with and without ASID support.</em></p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-13.svg\" alt=\"ASID-Tagged TLB: Context Switch Without Flush\"></p>\n<p><em>Diagram 13: TLB Flush operations (Page, ASID, All) and their impact on entry validity.</em></p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-14.svg\" alt=\"TLB Dirty Bit Write-Back on Eviction â€” Coherence Sequence\"></p>\n<p><em>Diagram 14: Parallel vs Sequential lookup - Hardware Silicon vs Software Simulator comparison.</em></p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-15.svg\" alt=\"tlb_flush_page() â€” Single-VPN Invalidation Before Frame Reuse\"></p>\n<p><em>Diagram 15: The &quot;Hot Path&quot; - detailed view of translate_with_tlb() decision tree.</em></p>\n<!-- END_TDD_MOD -->\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: virtual-memory-sim-m3 -->\n<h1 id=\"technical-design-specification-multi-level-page-tables-m3\">Technical Design Specification: Multi-Level Page Tables (m3)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module replaces the rigid, memory-inefficient flat page table from Milestone 1 with a dynamic, hierarchical two-level page table (radix trie). It negotiates the hardware tension between a vast 4GB virtual address space and the physical reality that most processes only use a few megabytes of RAM.</p>\n<p><strong>What it does:</strong></p>\n<ul>\n<li>Implements a 10-10-12 bit address decomposition for a 32-bit virtual address space.</li>\n<li>Simulates the <strong>CR3 (Page Directory Base Register)</strong>, providing the root for all translation walks.</li>\n<li>Implements <strong>On-Demand Table Allocation</strong>: second-level page tables are only allocated when a memory access falls within a new 4MB virtual region.</li>\n<li>Manages the <code>process_t</code> abstraction, ensuring full isolation between address spaces via separate page directory roots.</li>\n<li>Quantifies the &quot;Sparsity Benefit&quot; by comparing the memory footprint of hierarchical tables versus the flat 4MB baseline.</li>\n<li>Integrates the M2 TLB, ensuring that a TLB miss triggers a multi-level hardware-style walk.</li>\n</ul>\n<p><strong>What it does NOT do:</strong></p>\n<ul>\n<li>It does not implement page replacement (M4). Physical memory exhaustion (OOM) still returns an error.</li>\n<li>It does not simulate 64-bit canonical address checks (strictly 32-bit simulation).</li>\n</ul>\n<p><strong>Upstream Dependencies:</strong> Milestone 1 (PTE definitions, Offset logic), Milestone 2 (TLB lookup/insert).\n<strong>Downstream Dependencies:</strong> Milestone 4 (Page replacement will require walking these trees to find eviction victims).</p>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>A Page Directory Entry (PDE) with the <code>Present</code> bit set to 0 MUST treat the entire 4MB region as unmapped.</li>\n<li>Every allocated Page Directory and Page Table MUST be 4096-byte aligned to mirror physical frame boundaries.</li>\n<li>The CR3 register MUST always point to the physical base of a valid <code>page_directory_t</code>.</li>\n</ul>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>The implementation follows this creation order:</p>\n<ol>\n<li><code>vmsim_m3_types.h</code>: Definitions for <code>pde_t</code>, <code>page_directory_t</code>, and <code>process_t</code>.</li>\n<li><code>address_utils.h</code>: Inline functions for 10-10-12 bit decomposition.</li>\n<li><code>process_manager.c</code>: Implementation of <code>process_create</code>, <code>process_destroy</code>, and on-demand allocation.</li>\n<li><code>mmu_v3.c</code>: The hierarchical walk logic and integration with M2 TLB.</li>\n<li><code>overhead_reports.c</code>: Logic for calculating and printing memory savings statistics.</li>\n</ol>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-page-directory-entry-pde_t\">3.1. Page Directory Entry (pde_t)</h3>\n<p>The <code>pde_t</code> is a 4-byte entry in the top-level directory. It points to a second-level page table rather than a data frame.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Bit Range</th>\n<th align=\"left\">Name</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">[31:12]</td>\n<td align=\"left\"><strong>PT_ADDR</strong></td>\n<td align=\"left\">Physical Base Address of the 2nd-level Page Table. (4KB aligned).</td>\n</tr>\n<tr>\n<td align=\"left\">[11:1]</td>\n<td align=\"left\"><strong>AVAIL</strong></td>\n<td align=\"left\">Available for OS use (ignored by hardware simulation).</td>\n</tr>\n<tr>\n<td align=\"left\">[0]</td>\n<td align=\"left\"><strong>P</strong></td>\n<td align=\"left\">Present Bit. 1 = Sub-table exists; 0 = Region unmapped.</td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> uint32_t</span><span style=\"color:#79B8FF\"> pde_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_P_MASK</span><span style=\"color:#E1E4E8\">         (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\">u</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_PT_ADDR_MASK</span><span style=\"color:#E1E4E8\">   (</span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">FFFFF000</span><span style=\"color:#F97583\">u</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_PT_ADDR_SHIFT</span><span style=\"color:#79B8FF\">  12</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_IS_PRESENT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pde</span><span style=\"color:#E1E4E8\">) ((pde) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PDE_P_MASK)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PDE_GET_PT_ADDR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pde</span><span style=\"color:#E1E4E8\">) ((pde) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\"> PDE_PT_ADDR_MASK)</span></span></code></pre></div>\n\n<h3 id=\"32-hierarchical-structures\">3.2. Hierarchical Structures</h3>\n<p>Each structure is exactly 4096 bytes to fit perfectly in one physical frame.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Top Level: Page Directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pde_t</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\"> // 1024 * 4 bytes = 4096 bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">page_directory_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Second Level: Page Table (same as M1, but conceptually nested)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    pte_t</span><span style=\"color:#FFAB70\"> entries</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\"> // 1024 * 4 bytes = 4096 bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">page_table_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<h3 id=\"33-process-abstraction-process_t\">3.3. Process Abstraction (process_t)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\">          asid;</span><span style=\"color:#6A737D\">               // Address Space ID for TLB</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_directory_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">pgdir;</span><span style=\"color:#6A737D\">              // Root (simulated physical address)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#F97583\">     *</span><span style=\"color:#FFAB70\">pgtables</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">     // Pointer array for simulator convenience</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\">            pt_bytes_allocated;</span><span style=\"color:#6A737D\"> // Tracks 4KB increments</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<h3 id=\"34-byte-level-layout-amp-cache-line-analysis\">3.4. Byte-Level Layout &amp; Cache Line Analysis</h3>\n<ul>\n<li><strong>Page Directory (4096B):</strong> Contains 1024 entries. </li>\n<li><strong>PDI 0-15:</strong> Occupy the first 64 bytes (one cache line). Accessing addresses in the first 64MB of virtual space (16 entries * 4MB per entry) will result in directory cache hits.</li>\n<li><strong>PT Locality:</strong> Accessing two virtual addresses $V_1$ and $V_2$ where $|V_1 - V_2| &lt; 4MB$ guarantees they share the same Page Directory Entry.</li>\n</ul>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-16.svg\" alt=\"Two-Level Virtual Address Decomposition: 10+10+12 Bit Split\"></p>\n<p><em>Diagram 16: Hierarchical structure of the 10-10-12 Page Table system. Show CR3 pointing to Directory, Directory index selecting PDE, PDE pointing to Table, Table index selecting PTE.</em></p>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-address-decomposition\">4.1. Address Decomposition</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> get_pdi</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> // bits [31:22]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> get_pti</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> // bits [21:12]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#B392F0\"> get_offset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> // bits [11:0]</span></span></code></pre></div>\n\n<h3 id=\"42-process-lifecycle\">4.2. Process Lifecycle</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> process_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> asid</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\">       process_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">process_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">proc</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<ul>\n<li><strong>Constraint:</strong> <code>process_create</code> must allocate and zero-initialize the <code>page_directory_t</code>.</li>\n<li><strong>Constraint:</strong> <code>process_destroy</code> must iterate <code>pgtables[]</code> and free all non-NULL second-level tables.</li>\n</ul>\n<h3 id=\"43-hierarchical-translation\">4.3. Hierarchical Translation</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    xlate_result_t</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">       paddr;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">       pfn;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">xlate_t</span><span style=\"color:#B392F0\"> ml_translate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ml_simulator_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sim</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vaddr</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#FFAB70\"> is_write</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<ul>\n<li><strong>Error Categories:</strong><ul>\n<li><code>XLATE_OOM</code>: If an L2 table needs to be allocated but <code>malloc</code> fails or frame pool is empty.</li>\n<li><code>XLATE_PROT_FAULT</code>: Accessing an unmapped region (if your simulator chooses not to auto-grow) or permission mismatch.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"5-algorithm-specification\">5. Algorithm Specification</h2>\n<h3 id=\"51-the-hierarchical-walk-ml_translate\">5.1. The Hierarchical Walk (<code>ml_translate</code>)</h3>\n<ol>\n<li><strong>Extract Indices:</strong> <code>pdi = get_pdi(vaddr)</code>, <code>pti = get_pti(vaddr)</code>, <code>off = get_offset(vaddr)</code>.</li>\n<li><strong>Level 1 (Directory) Lookup:</strong><ul>\n<li><code>pde_t pde = sim-&gt;active_process-&gt;pgdir-&gt;entries[pdi]</code>.</li>\n<li>If <code>!PDE_IS_PRESENT(pde)</code>:<ul>\n<li><strong>On-Demand Allocation</strong>:<ul>\n<li><code>new_pt = aligned_alloc(4096, sizeof(page_table_t))</code>.</li>\n<li>If fails, return <code>XLATE_OOM</code>.</li>\n<li><code>memset(new_pt, 0, 4096)</code>.</li>\n<li><code>sim-&gt;active_process-&gt;pgtables[pdi] = new_pt</code>.</li>\n<li><code>sim-&gt;active_process-&gt;pgdir-&gt;entries[pdi] = pde_make(new_pt)</code>.</li>\n<li>Update <code>pt_bytes_allocated += 4096</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Level 2 (Table) Lookup:</strong><ul>\n<li><code>page_table_t *pt = sim-&gt;active_process-&gt;pgtables[pdi]</code>.</li>\n<li><code>pte_t pte = pt-&gt;entries[pti]</code>.</li>\n</ul>\n</li>\n<li><strong>Valid/Demand Paging (Same as M1):</strong><ul>\n<li>If <code>!PTE_IS_VALID(pte)</code>:<ul>\n<li>Allocate data frame, update <code>pt-&gt;entries[pti]</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Finalize:</strong> Reconstruct address using PFN and Offset.</li>\n</ol>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-17.svg\" alt=\"process_t and Two-Level Page Table Struct Architecture\"></p>\n<p><em>Diagram 17: Sequence Diagram of an On-Demand L2 Page Table allocation. Show the MMU detecting a missing PDE, triggering the allocator, and then proceeding with the PTE lookup.</em></p>\n<h3 id=\"52-context-switch-with-cr3-update\">5.2. Context Switch with CR3 Update</h3>\n<ol>\n<li><strong>Identify Old Process:</strong> Get <code>sim-&gt;active_process</code>.</li>\n<li><strong>Update CR3:</strong> <code>sim-&gt;cr3 = (uint32_t)new_proc-&gt;pgdir</code>.</li>\n<li><strong>Set Active Process:</strong> <code>sim-&gt;active_process = new_proc</code>.</li>\n<li><strong>TLB Coordination:</strong><ul>\n<li>If <code>force_flush == true</code>: Call <code>tlb_flush_all(tlb, old_proc-&gt;pgdir)</code>.</li>\n<li>Else: Call <code>tlb-&gt;active_asid = new_proc-&gt;asid</code> (M2 ASID support).</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>NULL_PDE_DEREFERENCE</code></td>\n<td align=\"left\"><code>ml_translate</code></td>\n<td align=\"left\">Check <code>PDE_IS_PRESENT</code> before <code>pgtables[pdi]</code>.</td>\n<td align=\"left\">Internal Crash if missed.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>XLATE_OOM</code></td>\n<td align=\"left\"><code>alloc_page_table</code></td>\n<td align=\"left\">Stop simulation for that trace.</td>\n<td align=\"left\">Yes (Log)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>PDE_PT_MISALIGN</code></td>\n<td align=\"left\"><code>pde_make</code></td>\n<td align=\"left\"><code>assert((addr &amp; 0xFFF) == 0)</code></td>\n<td align=\"left\">Internal Crash.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>TLB_STALENESS</code></td>\n<td align=\"left\"><code>ml_translate</code></td>\n<td align=\"left\">Call <code>tlb_flush_page</code> if PTE is manually modified.</td>\n<td align=\"left\">No (Data corruption).</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-bitfields-amp-indices-05-hours\">Phase 1: Bitfields &amp; Indices (0.5 Hours)</h3>\n<ul>\n<li>Implement <code>get_pdi</code>, <code>get_pti</code>, <code>get_offset</code>.</li>\n<li><strong>Checkpoint:</strong> Use <code>0x004056A8</code>. Verify PDI=1, PTI=5, Offset=0x6A8.</li>\n</ul>\n<h3 id=\"phase-2-on-demand-logic-15-hours\">Phase 2: On-Demand Logic (1.5 Hours)</h3>\n<ul>\n<li>Implement <code>process_create</code> and the &quot;Directory Present&quot; check in <code>ml_translate</code>.</li>\n<li>Integrate <code>aligned_alloc</code> for 4KB alignment.</li>\n<li><strong>Checkpoint:</strong> Run a trace accessing <code>0x1000</code> and <code>0x401000</code>. Verify <code>pt_bytes_allocated</code> is 12288 (1 Dir + 2 Tables).</li>\n</ul>\n<h3 id=\"phase-3-tlb-integration-1-hour\">Phase 3: TLB Integration (1 Hour)</h3>\n<ul>\n<li>Modify <code>full_translate</code> to check TLB. On miss, perform the 2-level walk.</li>\n<li><strong>Checkpoint:</strong> Run trace with repeated access. Verify first access is <code>MISS + Walk</code>, second is <code>HIT</code>.</li>\n</ul>\n<h3 id=\"phase-4-overhead-reporting-1-hour\">Phase 4: Overhead Reporting (1 Hour)</h3>\n<ul>\n<li>Implement <code>print_overhead_comparison</code>.</li>\n<li>Logic: <code>Flat_Cost = 4MB</code>. <code>Savings = 1 - (proc-&gt;pt_bytes_allocated / 4MB)</code>.</li>\n<li><strong>Checkpoint:</strong> Print report for a 1-page process. Savings should be &gt; 99%.</li>\n</ul>\n<h3 id=\"phase-5-stretch-3-level-table-2-hours\">Phase 5: Stretch - 3-Level Table (2 Hours)</h3>\n<ul>\n<li>Implement <code>l1/l2/l3</code> split: 2 bits / 9 bits / 9 bits.</li>\n<li>Implement <code>three_level_walk</code>.</li>\n<li><strong>Checkpoint:</strong> Verify 3rd level tables are also allocated on demand.</li>\n</ul>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-unit-test-pdepte-distinction\">8.1. Unit Test: PDE/PTE Distinction</h3>\n<ul>\n<li><strong>Scenario:</strong> Address <code>0x00800000</code> (PDI=2). </li>\n<li><strong>Setup:</strong> Manually set <code>pgdir-&gt;entries[2]</code> to a valid data frame address (Illegal).</li>\n<li><strong>Test:</strong> Run <code>ml_translate</code>.</li>\n<li><strong>Expectation:</strong> The walk should fail or the simulator should crash when trying to treat user data as a Page Table. Ensure logic distinguishes between &quot;Pointer to Table&quot; and &quot;Pointer to Frame&quot;.</li>\n</ul>\n<h3 id=\"82-integration-test-address-space-isolation\">8.2. Integration Test: Address Space Isolation</h3>\n<ul>\n<li><strong>Scenario:</strong> <ol>\n<li>Process 1 (ASID 1) maps <code>0x1000</code> -&gt; Frame 5.</li>\n<li>Process 2 (ASID 2) maps <code>0x1000</code> -&gt; Frame 10.</li>\n</ol>\n</li>\n<li><strong>Action:</strong> Context switch between P1 and P2. Access <code>0x1000</code>.</li>\n<li><strong>Expectation:</strong> P1 gets Frame 5; P2 gets Frame 10. Verify CR3 value changed.</li>\n</ul>\n<h3 id=\"83-boundary-test-max-address\">8.3. Boundary Test: Max Address</h3>\n<ul>\n<li><strong>Input:</strong> <code>0xFFFFFFFF</code>.</li>\n<li><strong>Expectation:</strong> PDI=1023, PTI=1023, Offset=4095. Correct walk to the very last PTE in the system.</li>\n</ul>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Walk Latency</strong></td>\n<td align=\"left\">$2.0 \\times$ Flat Table Walk</td>\n<td align=\"left\">Measure TLB-Miss cycles.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Mem Creation</strong></td>\n<td align=\"left\">$O(1)$</td>\n<td align=\"left\">Time for <code>process_create</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Mem Cleanup</strong></td>\n<td align=\"left\">$O(N)$ where N is L2 tables</td>\n<td align=\"left\">Time for <code>process_destroy</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Sparsity Savings</strong></td>\n<td align=\"left\">$&gt; 90%$ for most traces</td>\n<td align=\"left\"><code>pt_bytes_allocated</code> vs 4MB baseline.</td>\n</tr>\n</tbody></table>\n<h2 id=\"10-hardware-soul-the-multi-level-penalty\">10. Hardware Soul - The Multi-Level Penalty</h2>\n<p>In real silicon, every level added to the page table is another potentially-catastrophic memory access.</p>\n<ul>\n<li><strong>Flat Table:</strong> 1 memory load on TLB miss.</li>\n<li><strong>2-Level Table:</strong> 2 memory loads (Directory, then Table).</li>\n<li><strong>4-Level (x86-64):</strong> 4 memory loads.\nThis is why the <strong>TLB Hit Rate</strong> is the absolute king of systems performance. A 2-level walk is twice as &quot;expensive&quot; as a flat walk in the worst case (cache cold). However, because <code>page_directory_t</code> and <code>page_table_t</code> are 4KB pages, they are frequently cached in the L2/L3 of the CPU, mitigating this cost.</li>\n</ul>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-18.svg\" alt=\"pde_t vs pte_t Structural Comparison â€” What Each Points To\"></p>\n<p><em>Diagram 18: Comparison of Flat vs 2-Level walk steps.</em></p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-19.svg\" alt=\"Two-Level Page Table Walk â€” Complete Data Flow with On-Demand Allocation\"></p>\n<p><em>Diagram 19: Address Decomposition bit-field map for 2-level (10-10-12) and 3-level (2-9-9-12).</em></p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-20.svg\" alt=\"On-Demand Second-Level Table Allocation: Before/After State\"></p>\n<p><em>Diagram 20: Memory Overhead Graph showing the linear growth of Hierarchical tables vs constant Flat table.</em></p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-21.svg\" alt=\"CR3 Register and Context Switch: Address Space Isolation\"></p>\n<p><em>Diagram 21: Context Switch State Machine: Transitioning from Proc A to Proc B via CR3.</em></p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: virtual-memory-sim-m4 -->\n<h1 id=\"technical-design-specification-page-replacement-and-swap-simulation-m4\">Technical Design Specification: Page Replacement and Swap Simulation (m4)</h1>\n<h2 id=\"1-module-charter\">1. Module Charter</h2>\n<p>This module implements the &quot;Governor of Scarcity&quot;â€”the page replacement engine and backing swap store. It resolves the fundamental tension between a process&#39;s unbounded virtual memory demand and the simulator&#39;s fixed 64-frame physical limit. By implementing four distinct replacement algorithms (FIFO, LRU, Clock, and Optimal), it allows for a quantitative analysis of how different heuristics affect system throughput and disk I/O (swap) overhead.</p>\n<p><strong>What it does:</strong></p>\n<ul>\n<li>Manages a simulated swap partition (array-backed) to persist evicted dirty pages.</li>\n<li>Implements the <strong>Eviction Core</strong>, ensuring a strict coherence protocol: Dirty Write-back â†’ TLB Invalidation â†’ PTE Invalidation â†’ Frame Reclamation.</li>\n<li>Provides four replacement heuristics: <strong>FIFO</strong> (age-based), <strong>LRU</strong> (recency-based), <strong>Clock</strong> (reference-bit approximation), and <strong>Optimal</strong> (future-knowledge benchmark).</li>\n<li>Tracks the <strong>Working Set</strong> of the process using a sliding window to detect and report thrashing.</li>\n<li>Demonstrates <strong>BÃ©lÃ¡dyâ€™s Anomaly</strong> by comparing FIFO fault rates across different frame counts.</li>\n<li>Generates comparative performance reports (Fault Rate, Swap I/O count, Efficiency vs. Optimal).</li>\n</ul>\n<p><strong>What it does NOT do:</strong></p>\n<ul>\n<li>It does not implement huge pages (4KB granularity only).</li>\n<li>It does not support compressed swap (ZSwap) or asynchronous page-out threads.</li>\n<li>It does not handle multi-process shared swap slots (private per-process swap only).</li>\n</ul>\n<p><strong>Upstream Dependencies:</strong> Milestone 1 (PTE flags), Milestone 2 (TLB flushing), Milestone 3 (Hierarchical walk to clear PTEs).\n<strong>Downstream Dependencies:</strong> This is the terminal milestone of the Virtual Memory Simulator.</p>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>A frame MUST be flushed from the TLB via <code>tlb_flush_page</code> BEFORE its PTE is cleared and the frame is reassigned.</li>\n<li>A page marked <code>Dirty</code> in its PTE or TLB entry MUST be written to swap before its frame is reclaimed.</li>\n<li>The <code>Optimal</code> algorithm MUST produce the absolute minimum number of page faults for any given trace (theoretical lower bound).</li>\n</ul>\n<h2 id=\"2-file-structure\">2. File Structure</h2>\n<p>The implementation follows this creation order:</p>\n<ol>\n<li><code>swap.h / swap.c</code>: Definitions for <code>swap_slot_t</code> and <code>swap_space_t</code>; logic for page-in/page-out.</li>\n<li><code>replacement_metadata.h</code>: The <code>frame_desc_t</code> and <code>phys_mem_t</code> structures with replacement-tracking fields.</li>\n<li><code>algorithms.c</code>: Implementation of the four selection heuristics (FIFO, LRU, Clock, Optimal).</li>\n<li><code>eviction_engine.c</code>: The unified <code>replace_page</code> logic and coherence sequencer.</li>\n<li><code>working_set.c</code>: Sliding window tracker for working set size analysis.</li>\n<li><code>reporting.c</code>: Comparative statistics generator and BÃ©lÃ¡dy anomaly demonstrator.</li>\n</ol>\n<h2 id=\"3-complete-data-model\">3. Complete Data Model</h2>\n<h3 id=\"31-frame-descriptor-frame_desc_t\">3.1. Frame Descriptor (frame_desc_t)</h3>\n<p>This structure tracks the &quot;Life and Times&quot; of a physical frame. It is exactly 32 bytes to ensure dual-entry packing within a 64-byte cache line.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Byte Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>vpn</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\">Currently mapped Virtual Page Number. <code>0xFFFFFFFF</code> if free.</td>\n</tr>\n<tr>\n<td align=\"left\">0x04</td>\n<td align=\"left\"><code>asid</code></td>\n<td align=\"left\"><code>uint16_t</code></td>\n<td align=\"left\">ASID of the process owning this frame.</td>\n</tr>\n<tr>\n<td align=\"left\">0x06</td>\n<td align=\"left\"><code>flags</code></td>\n<td align=\"left\"><code>uint8_t</code></td>\n<td align=\"left\">Bits: [0] InUse, [1] Dirty, [2] RefBit, [3] Reserved.</td>\n</tr>\n<tr>\n<td align=\"left\">0x07</td>\n<td align=\"left\"><code>padding</code></td>\n<td align=\"left\"><code>uint8_t</code></td>\n<td align=\"left\">Alignment padding.</td>\n</tr>\n<tr>\n<td align=\"left\">0x08</td>\n<td align=\"left\"><code>load_time</code></td>\n<td align=\"left\"><code>uint64_t</code></td>\n<td align=\"left\">Logical timestamp when the page was first loaded (FIFO).</td>\n</tr>\n<tr>\n<td align=\"left\">0x10</td>\n<td align=\"left\"><code>last_access</code></td>\n<td align=\"left\"><code>uint64_t</code></td>\n<td align=\"left\">Logical timestamp of the most recent access (LRU).</td>\n</tr>\n<tr>\n<td align=\"left\">0x18</td>\n<td align=\"left\"><code>reserved</code></td>\n<td align=\"left\"><code>uint64_t</code></td>\n<td align=\"left\">Future expansion (e.g., pinning counts).</td>\n</tr>\n</tbody></table>\n<p><strong>Total: 32 bytes.</strong></p>\n<h3 id=\"32-physical-memory-pool-phys_mem_t\">3.2. Physical Memory Pool (phys_mem_t)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    frame_desc_t</span><span style=\"color:#FFAB70\"> desc</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">              // Metadata for 64 frames</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">      data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">        // Actual 256KB of simulated RAM</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">     num_frames;</span><span style=\"color:#6A737D\">            // Configurable size (e.g., 3, 16, 64)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">     logical_clock;</span><span style=\"color:#6A737D\">         // Incremented on every memory access</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<h3 id=\"33-swap-space-swap_space_t\">3.3. Swap Space (swap_space_t)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_SWAP_PAGES</span><span style=\"color:#79B8FF\"> 1024</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint8_t</span><span style=\"color:#FFAB70\">  data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> vpn;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\">     in_use;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">swap_slot_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    swap_slot_t</span><span style=\"color:#FFAB70\"> slots</span><span style=\"color:#E1E4E8\">[MAX_SWAP_PAGES];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\">    count;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    stats_write_backs;</span><span style=\"color:#6A737D\">      // Count of dirty evictions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint64_t</span><span style=\"color:#E1E4E8\">    stats_page_ins;</span><span style=\"color:#6A737D\">         // Count of swap reloads</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">swap_space_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<h3 id=\"34-working-set-tracker\">3.4. Working Set Tracker</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> WS_WINDOW_SIZE</span><span style=\"color:#79B8FF\"> 50</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#FFAB70\"> vpn_history</span><span style=\"color:#E1E4E8\">[WS_WINDOW_SIZE];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> head;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> current_size;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">working_set_tracker_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-24.svg\" alt=\"frame_desc_t Memory Layout â€” 16-Byte Struct with Cache-Line Analysis\"></p>\n<p><em>Diagram 24: Memory Relationship Map. Shows PhysMem descriptors pointing to PTEs, and SwapSpace acting as the overflow reservoir.</em></p>\n<h2 id=\"4-interface-contracts\">4. Interface Contracts</h2>\n<h3 id=\"41-the-replacement-dispatcher\">4.1. The Replacement Dispatcher</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    POLICY_FIFO,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    POLICY_LRU,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    POLICY_CLOCK,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    POLICY_OPTIMAL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">replacement_policy_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> freed_frame;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#E1E4E8\"> evicted_vpn;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    bool</span><span style=\"color:#E1E4E8\">     was_dirty;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">replace_result_t</span><span style=\"color:#B392F0\"> replace_page</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    swap_space_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">swap</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    page_table_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pt</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    tlb_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">tlb</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    replacement_policy_t</span><span style=\"color:#FFAB70\"> policy</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> mem_access_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">future_trace</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\"> // For Optimal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#FFAB70\"> trace_len</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#FFAB70\"> current_step</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint32_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">clock_hand</span><span style=\"color:#6A737D\">             // For Clock persistence</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<ul>\n<li><strong>Constraints:</strong> <code>pm</code> must be full (no free frames) before calling this.</li>\n<li><strong>Side Effects:</strong> Modifies Page Table <code>valid</code> bits and flushes TLB entries.</li>\n</ul>\n<h3 id=\"42-swap-io\">4.2. Swap I/O</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Move data from Frame to Swap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> swap_page_out</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">swap_space_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sw</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frame_idx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vpn</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Move data from Swap to Frame (if it exists)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">bool</span><span style=\"color:#B392F0\"> swap_page_in</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">phys_mem_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">swap_space_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sw</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> frame_idx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint32_t</span><span style=\"color:#FFAB70\"> vpn</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h2 id=\"5-algorithm-specifications\">5. Algorithm Specifications</h2>\n<h3 id=\"51-the-eviction-core-sequence-critical-path\">5.1. The Eviction Core Sequence (Critical Path)</h3>\n<p>This logic is shared by all algorithms once a victim frame is identified.</p>\n<ol>\n<li><strong>Identify Victim:</strong> Let <code>f = victim_frame_index</code>.</li>\n<li><strong>Metadata Check:</strong> Extract <code>v = pm-&gt;desc[f].vpn</code>. Check <code>pm-&gt;desc[f].flags &amp; DIRTY</code>.</li>\n<li><strong>TLB Shootdown:</strong> Call <code>tlb_flush_page(tlb, pt, v)</code>. <em>Note: The TLB may contain updated Dirty/Ref bits that must be synced to the PTE during this flush.</em></li>\n<li><strong>Dirty Write-back:</strong> <ul>\n<li>If <code>Dirty</code> bit is set (in PTE or TLB):<ul>\n<li>Call <code>swap_page_out(pm, swap, f, v)</code>.</li>\n<li>Increment <code>swap-&gt;stats_write_backs</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>PTE Invalidation:</strong> <ul>\n<li>Perform a hierarchical walk (M3 logic) to find the PTE for <code>v</code>.</li>\n<li>Clear <code>PTE_V_MASK</code>, <code>PTE_D_MASK</code>, <code>PTE_A_MASK</code>.</li>\n</ul>\n</li>\n<li><strong>Frame Reclamation:</strong> <ul>\n<li>Set <code>pm-&gt;desc[f].in_use = false</code>.</li>\n<li>Set <code>pm-&gt;desc[f].vpn = 0xFFFFFFFF</code>.</li>\n</ul>\n</li>\n<li><strong>Return:</strong> <code>replace_result_t</code> with indices and dirty status.</li>\n</ol>\n<h3 id=\"52-clock-second-chance-logic\">5.2. Clock (Second-Chance) Logic</h3>\n<ol>\n<li><strong>Start</strong> at <code>*clock_hand</code>.</li>\n<li><strong>Loop</strong> until a victim is found:<ul>\n<li><code>frame_desc_t *d = &amp;pm-&gt;desc[*clock_hand]</code>.</li>\n<li>If <code>d-&gt;flags &amp; RefBit</code>:<ul>\n<li>Clear <code>RefBit</code> in <code>d-&gt;flags</code>.</li>\n<li>Also clear <code>PTE_A_MASK</code> in the corresponding Page Table Entry.</li>\n<li>Increment <code>*clock_hand = (*clock_hand + 1) % num_frames</code>.</li>\n</ul>\n</li>\n<li>Else (RefBit is 0):<ul>\n<li>This is the victim. </li>\n<li>Stop loop and return <code>*clock_hand</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Safety:</strong> Guard against infinite loop with a <code>sweep_count</code> (max 2 full rotations).</li>\n</ol>\n<h3 id=\"53-optimal-bldys-algorithm\">5.3. Optimal (BÃ©lÃ¡dyâ€™s Algorithm)</h3>\n<ol>\n<li><strong>Scan</strong> all frames currently <code>in_use</code> in <code>pm</code>.</li>\n<li><strong>For each frame</strong>, look ahead in <code>future_trace</code> starting at <code>current_step + 1</code>.</li>\n<li><strong>Calculate Distance:</strong><ul>\n<li>If <code>vpn</code> is found at step <code>K</code>, <code>distance = K - current_step</code>.</li>\n<li>If <code>vpn</code> is never found again, <code>distance = INFINITY</code>.</li>\n</ul>\n</li>\n<li><strong>Selection:</strong> Choose the frame with the <strong>largest distance</strong>.</li>\n<li><strong>Tie-breaker:</strong> If multiple pages have <code>INFINITY</code> distance, choose the one with the lowest frame index.</li>\n</ol>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-25.svg\" alt=\"Page Replacement Full Module Architecture\"></p>\n<p><em>Diagram 25: Optimal Selection Logic. Visualizing the look-ahead scan across the trace array.</em></p>\n<h2 id=\"6-error-handling-matrix\">6. Error Handling Matrix</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>SWAP_FULL</code></td>\n<td align=\"left\"><code>swap_alloc_slot</code></td>\n<td align=\"left\">Critical failure. <code>abort()</code> simulator or return <code>OOM_FATAL</code>.</td>\n<td align=\"left\">Yes (Crash)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>STALE_TLB</code></td>\n<td align=\"left\">Access Logic</td>\n<td align=\"left\">Avoided by <code>tlb_flush_page</code> preceding PTE clear.</td>\n<td align=\"left\">If missed: Data corruption.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>THRASHING</code></td>\n<td align=\"left\"><code>ws_record_access</code></td>\n<td align=\"left\">Monitor <code>fault_rate</code>. Log warning if rate &gt; 50%.</td>\n<td align=\"left\">Yes (Warning)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>CLOCK_STALL</code></td>\n<td align=\"left\"><code>replace_clock</code></td>\n<td align=\"left\">Sweep twice, then force evict current hand position.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><code>DIRTY_LOST</code></td>\n<td align=\"left\"><code>evict_frame</code></td>\n<td align=\"left\">Enforce Write-back <em>before</em> frame clearing.</td>\n<td align=\"left\">If missed: Data corruption.</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-implementation-sequence-with-checkpoints\">7. Implementation Sequence with Checkpoints</h2>\n<h3 id=\"phase-1-frame-descriptors-1-hour\">Phase 1: Frame Descriptors (1 Hour)</h3>\n<ul>\n<li>Implement <code>phys_mem_init</code> and <code>frame_desc_t</code> packing.</li>\n<li>Implement <code>phys_record_access</code> (updates <code>last_access</code> and <code>RefBit</code> on every translation hit/miss).</li>\n<li><strong>Checkpoint:</strong> Run a trace of 5 accesses. Verify <code>logical_clock</code> is 5 and descriptors have correct <code>last_access</code> times.</li>\n</ul>\n<h3 id=\"phase-2-swap-subsystem-2-hours\">Phase 2: Swap Subsystem (2 Hours)</h3>\n<ul>\n<li>Implement <code>swap_page_out</code> and <code>swap_page_in</code>.</li>\n<li>Create a simple fixed-array <code>swap_space_t</code>.</li>\n<li><strong>Checkpoint:</strong> Manually &quot;page out&quot; VPN 10, then &quot;page in&quot; to a different frame. Verify <code>memcmp</code> of data is identical.</li>\n</ul>\n<h3 id=\"phase-3-selection-algorithms-3-hours\">Phase 3: Selection Algorithms (3 Hours)</h3>\n<ul>\n<li>Implement <code>replace_fifo</code>, <code>replace_lru</code>, and <code>replace_clock</code>.</li>\n<li>Implement <code>replace_optimal</code> (requires trace look-ahead).</li>\n<li><strong>Checkpoint:</strong> Write a unit test using the trace <code>7,0,1,2,0,3</code>. With 3 frames, verify FIFO picks VPN 7 for eviction.</li>\n</ul>\n<h3 id=\"phase-4-the-eviction-sequencer-2-hours\">Phase 4: The Eviction Sequencer (2 Hours)</h3>\n<ul>\n<li>Implement the <code>evict_frame</code> core logic with TLB shootdown.</li>\n<li>Integrate into <code>full_translate</code>. If <code>phys_find_free</code> fails, call <code>replace_page</code>.</li>\n<li><strong>Checkpoint:</strong> Run a trace that exceeds frame count. Verify no <code>OOM</code> occurs and <code>swap_write_backs</code> increments for dirty pages.</li>\n</ul>\n<h3 id=\"phase-5-statistics-amp-anomaly-2-hours\">Phase 5: Statistics &amp; Anomaly (2 Hours)</h3>\n<ul>\n<li>Implement <code>run_comparison</code>.</li>\n<li>Implement BÃ©lÃ¡dy anomaly test script (FIFO with 3 vs 4 frames).</li>\n<li><strong>Checkpoint:</strong> Generate the comparative table. Verify Optimal has the lowest fault count.</li>\n</ul>\n<h2 id=\"8-test-specification\">8. Test Specification</h2>\n<h3 id=\"81-bldys-anomaly-test\">8.1. BÃ©lÃ¡dyâ€™s Anomaly Test</h3>\n<ul>\n<li><strong>Trace:</strong> <code>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</code> (Mapped to 4KB offsets).</li>\n<li><strong>Condition:</strong> Run with FIFO policy.</li>\n<li><strong>Execution 1:</strong> <code>num_frames = 3</code>. Expect 9 faults.</li>\n<li><strong>Execution 2:</strong> <code>num_frames = 4</code>. Expect 10 faults.</li>\n<li><strong>Success:</strong> Fault count increases when memory increases.</li>\n</ul>\n<h3 id=\"82-dirty-bit-persistence-test\">8.2. Dirty Bit Persistence Test</h3>\n<ul>\n<li><strong>Action:</strong> Write to <code>0x1000</code>. Perform enough other accesses to trigger eviction of VPN 1. Then read <code>0x1000</code>.</li>\n<li><strong>Expectation:</strong> <code>swap_write_backs</code> should be 1. The reload must show the data written originally (not zero).</li>\n</ul>\n<h3 id=\"83-optimal-benchmark-test\">8.3. Optimal Benchmark Test</h3>\n<ul>\n<li><strong>Trace:</strong> Random distribution of 100 pages.</li>\n<li><strong>Expectation:</strong> <code>faults(Optimal) &lt;= faults(LRU) &lt;= faults(FIFO)</code>.</li>\n</ul>\n<h2 id=\"9-performance-targets\">9. Performance Targets</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>LRU Selection</strong></td>\n<td align=\"left\">$O(F)$ where $F=64$</td>\n<td align=\"left\">Cycles per eviction.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Clock Selection</strong></td>\n<td align=\"left\">$O(F)$ worst-case</td>\n<td align=\"left\">Cycles per eviction.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Swap I/O</strong></td>\n<td align=\"left\">$O(PAGE_SIZE)$</td>\n<td align=\"left\"><code>memcpy</code> overhead in <code>swap_page_out</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Optimal Scan</strong></td>\n<td align=\"left\">$O(F \\cdot T)$</td>\n<td align=\"left\">Wall clock time for 100k-line trace.</td>\n</tr>\n</tbody></table>\n<h2 id=\"10-hardware-soul-cache-and-pipeline-constraints\">10. Hardware Soul - Cache and Pipeline Constraints</h2>\n<h3 id=\"101-temporal-locality-and-lru\">10.1. Temporal Locality and LRU</h3>\n<p>True LRU is computationally expensive because it requires a metadata update on <strong>every</strong> access. In our simulator, we use <code>logical_clock</code> timestamps. In real hardware, this would be a pipeline bottleneck. This is why <strong>Clock</strong> is the industry standardâ€”it moves the overhead from the &quot;Hot Path&quot; (access) to the &quot;Cold Path&quot; (fault handling).</p>\n<h3 id=\"102-tlb-coherence-the-shootdown\">10.2. TLB Coherence (The Shootdown)</h3>\n<p>When we evict a frame, the simulator calls <code>tlb_flush_page</code>. In a multi-core CPU, this triggers a <strong>TLB Shootdown</strong>:</p>\n<ol>\n<li>Initiating CPU sends an Interrupt (IPI) to all other cores.</li>\n<li>Cores stop execution, invalidate their local TLB entry for that VPN.</li>\n<li>Cores acknowledge.</li>\n<li>Initiating CPU proceeds only after all ACKs.\nOur single-threaded simulation hides this latency, but the <code>tlb_flush_page</code> call is the critical hook for where this logic would live.</li>\n</ol>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-26.svg\" alt=\"Dirty vs Clean Page Eviction Decision â€” Cost Divergence\"></p>\n<p><em>Diagram 26: Frame Descriptor Cache-Line Packing. Showing two 32B descriptors sharing a single 64B line.</em></p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-27.svg\" alt=\"evict_frame() Operation Sequence â€” Mandatory Ordering\"></p>\n<p><em>Diagram 27: The Eviction/Replacement State Machine. Transitions from Allocated -&gt; Dirty -&gt; Swapped -&gt; Free.</em></p>\n<p><img src=\"/api/project/virtual-memory-sim/architecture-doc/asset?path=diagrams%2Ftdd-diag-28.svg\" alt=\"FIFO Replacement Trace â€” Step-by-Step with 3 Frames\"></p>\n<p><em>Diagram 28: Working Set Sliding Window. Tracking distinct page IDs in the last N cycles.</em></p>\n<!-- END_TDD_MOD -->\n\n\n<h1 id=\"project-structure-virtual-memory-simulator\">Project Structure: Virtual Memory Simulator</h1>\n<h2 id=\"directory-tree\">Directory Tree</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">text</span><pre class=\"arch-pre shiki-highlighted\"><code>vmsim-root/\nâ”œâ”€â”€ include/                 # Header files (Definitions &amp; Interfaces)\nâ”‚   â”œâ”€â”€ vmsim_types.h       # Core types, PTE masks (M1)\nâ”‚   â”œâ”€â”€ mmu.h               # MMU translation interfaces (M1-M3)\nâ”‚   â”œâ”€â”€ tlb.h               # TLB structures and logic (M2)\nâ”‚   â”œâ”€â”€ vmsim_m3_types.h    # PDE and Process structs (M3)\nâ”‚   â”œâ”€â”€ address_utils.h     # Bit-shifting decomposition helpers (M3)\nâ”‚   â”œâ”€â”€ swap.h              # Swap space &amp; slot definitions (M4)\nâ”‚   â”œâ”€â”€ replacement_metadata.h # Frame descriptors &amp; phys_mem (M4)\nâ”‚   â””â”€â”€ trace_parser.h      # Trace file tokenization API (M1)\nâ”œâ”€â”€ src/                     # Implementation files\nâ”‚   â”œâ”€â”€ main.c              # Simulator entry &amp; main loop (M1-M4)\nâ”‚   â”œâ”€â”€ mmu.c               # Hierarchical walk &amp; translation (M1, M3)\nâ”‚   â”œâ”€â”€ tlb.c               # TLB lookup, LRU, &amp; ASID logic (M2)\nâ”‚   â”œâ”€â”€ trace_parser.c      # .trace file parsing logic (M1)\nâ”‚   â”œâ”€â”€ process_manager.c   # On-demand PT allocation (M3)\nâ”‚   â”œâ”€â”€ algorithms.c        # FIFO, LRU, Clock, Optimal logic (M4)\nâ”‚   â”œâ”€â”€ eviction_engine.c   # Dirty write-back &amp; coherence (M4)\nâ”‚   â”œâ”€â”€ swap.c              # Page-in/Page-out I/O logic (M4)\nâ”‚   â”œâ”€â”€ working_set.c       # Sliding window locality tracker (M4)\nâ”‚   â”œâ”€â”€ reporting.c         # Stats, overhead &amp; anomaly reports (M3, M4)\nâ”‚   â””â”€â”€ overhead_reports.c  # Sparsity savings calculations (M3)\nâ”œâ”€â”€ tests/                   # Test suite\nâ”‚   â”œâ”€â”€ tlb_tests.c         # Unit tests for TLB/ASID (M2)\nâ”‚   â””â”€â”€ integration_tests.c # End-to-end trace validation (M1-M4)\nâ”œâ”€â”€ traces/                  # Input trace files\nâ”‚   â”œâ”€â”€ basic.trace         # Simple R/W sequence (M1)\nâ”‚   â”œâ”€â”€ tlb_stress.trace    # Repeated access for hits (M2)\nâ”‚   â”œâ”€â”€ sparse.trace        # Distant addresses for sparsity (M3)\nâ”‚   â””â”€â”€ belady.trace        # Anomaly demonstration string (M4)\nâ”œâ”€â”€ build/                   # Compiled binaries and objects\nâ”œâ”€â”€ Makefile                 # Build system (gcc, flags, clean)\nâ”œâ”€â”€ README.md                # Project setup and usage guide\nâ””â”€â”€ .gitignore               # Ignore build/ and traces/</code></pre></div>\n\n<h2 id=\"creation-order\">Creation Order</h2>\n<ol>\n<li><p><strong>Environment &amp; Infrastructure (M1)</strong></p>\n<ul>\n<li><code>Makefile</code>, <code>vmsim_types.h</code>, <code>trace_parser.h/.c</code>.</li>\n<li>Establish ability to read <code>.trace</code> files into memory.</li>\n</ul>\n</li>\n<li><p><strong>The Translation Core (M1)</strong></p>\n<ul>\n<li><code>mmu.h/.c</code> (Flat Table version), <code>main.c</code>.</li>\n<li>Implement bit-shifting for VPN/Offset and basic demand paging.</li>\n</ul>\n</li>\n<li><p><strong>The Fast Path (M2)</strong></p>\n<ul>\n<li><code>tlb.h/.c</code>.</li>\n<li>Integrate TLB into <code>mmu.c</code>. Implement LRU aging and ASID matching.</li>\n</ul>\n</li>\n<li><p><strong>Hierarchical Expansion (M3)</strong></p>\n<ul>\n<li><code>vmsim_m3_types.h</code>, <code>address_utils.h</code>, <code>process_manager.c</code>.</li>\n<li>Refactor <code>mmu.c</code> to perform 2-level walks with on-demand Page Table allocation.</li>\n</ul>\n</li>\n<li><p><strong>The Eviction Engine (M4)</strong></p>\n<ul>\n<li><code>replacement_metadata.h</code>, <code>swap.h/.c</code>, <code>eviction_engine.c</code>.</li>\n<li>Implement the core &quot;shootdown&quot; sequence (TLB Flush -&gt; Write-back -&gt; PTE Clear).</li>\n</ul>\n</li>\n<li><p><strong>Heuristics &amp; Analytics (M4)</strong></p>\n<ul>\n<li><code>algorithms.c</code>, <code>working_set.c</code>, <code>reporting.c</code>.</li>\n<li>Implement FIFO, Clock, and Optimal. Generate comparative performance tables.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"file-count-summary\">File Count Summary</h2>\n<ul>\n<li><strong>Total Files:</strong> 22</li>\n<li><strong>Directories:</strong> 6</li>\n<li><strong>Estimated Lines of Code:</strong> ~1,800 - 2,200 LOC</li>\n<li><strong>Primary Language:</strong> C11 (Standard library only)</li>\n</ul>\n<h1 id=\"-beyond-the-atlas-further-reading\">ğŸ“š Beyond the Atlas: Further Reading</h1>\n<h2 id=\"-foundations-of-virtual-memory\">ğŸŒ Foundations of Virtual Memory</h2>\n<h3 id=\"1-one-level-storage-system\">1. One-Level Storage System</h3>\n<ul>\n<li><strong>Paper</strong>: T. Kilburn, D. B. G. Edwards, M. J. Lanigan, and F. H. Sumner, &quot;One-Level Storage System,&quot; <em>IRE Transactions on Electronic Computers</em>, 1962.</li>\n<li><strong>Best Explanation</strong>: <em>Operating Systems: Three Easy Pieces</em> (OSTEP) by Arpaci-Dusseau, Chapter 13: &quot;Address Spaces.&quot;</li>\n<li><strong>Why</strong>: This is the seminal paper from the Manchester Atlas project that invented virtual memory; reading it reveals that &quot;demand paging&quot; was born from physical hardware limitations of the 1960s.</li>\n<li><strong>When to Read</strong>: <strong>Before starting Milestone 1</strong>. It establishes the &quot;why&quot; before you touch the &quot;how.&quot;</li>\n</ul>\n<h3 id=\"2-intel-64-and-ia-32-architectures-software-developers-manual\">2. Intel 64 and IA-32 Architectures Software Developerâ€™s Manual</h3>\n<ul>\n<li><strong>Spec</strong>: Intel SDM, Volume 3A, Chapter 4: &quot;Paging.&quot;</li>\n<li><strong>Code</strong>: <code>arch/x86/include/asm/pgtable_64_types.h</code> (Linux Kernel).</li>\n<li><strong>Best Explanation</strong>: OSTEP Chapter 18: &quot;Paging: Introduction.&quot;</li>\n<li><strong>Why</strong>: This is the authoritative &quot;ground truth&quot; for how x86 hardware actually traverses the structures you are simulating.</li>\n<li><strong>When to Read</strong>: <strong>During Milestone 1</strong>. Compare your <code>pte_t</code> bitmask to Intelâ€™s actual hardware bit definitions (Figure 4-4).</li>\n</ul>\n<h2 id=\"-tlb-amp-context-switching\">âš¡ TLB &amp; Context Switching</h2>\n<h3 id=\"3-meltdown-reading-kernel-memory-from-user-space\">3. Meltdown: Reading Kernel Memory from User Space</h3>\n<ul>\n<li><strong>Paper</strong>: Moritz Lipp et al., &quot;Meltdown: Reading Kernel Memory from User Space,&quot; <em>USENIX Security Symposium</em>, 2018.</li>\n<li><strong>Code</strong>: <code>arch/x86/mm/tlb.c</code> â€” specifically <code>switch_mm_irqs_off()</code>.</li>\n<li><strong>Best Explanation</strong>: &quot;Computer Architecture: A Quantitative Approach&quot; (Hennessy &amp; Patterson), Appendix B.</li>\n<li><strong>Why</strong>: This paper highlights why the ASID (PCID on x86) you implement in M2 is no longer just a performance optimization, but a critical component of modern security mitigations (KPTI).</li>\n<li><strong>When to Read</strong>: <strong>After Milestone 2 (TLB)</strong>. You&#39;ll understand why flushing the TLB is the &quot;nuclear option&quot; for performance.</li>\n</ul>\n<h3 id=\"4-analysis-of-tlb-performance\">4. Analysis of TLB Performance</h3>\n<ul>\n<li><strong>Paper</strong>: J. Bradley Chen et al., &quot;The Measured Performance of Personal Computer Operating Systems,&quot; <em>ACM SIGOPS</em>, 1995.</li>\n<li><strong>Best Explanation</strong>: OSTEP Chapter 19: &quot;Paging: Faster Translations (TLBs).&quot;</li>\n<li><strong>Why</strong>: Quantitative proof that TLB miss rates are the primary driver of overhead in modern kernels.</li>\n<li><strong>When to Read</strong>: <strong>During Milestone 2</strong>. It validates why you are bothering to track hit/miss statistics.</li>\n</ul>\n<h2 id=\"-hierarchical-structures-amp-sparsity\">ğŸŒ³ Hierarchical Structures &amp; Sparsity</h2>\n<h3 id=\"5-multi-level-page-tables\">5. Multi-Level Page Tables</h3>\n<ul>\n<li><strong>Best Explanation</strong>: OSTEP Chapter 20: &quot;Paging: Smaller Tables.&quot;</li>\n<li><strong>Why</strong>: The most intuitive explanation of why &quot;Page Directories&quot; act as a sparse index, preventing the 4MB memory waste you see in Milestone 1.</li>\n<li><strong>When to Read</strong>: <strong>Before Milestone 3 (Multi-Level)</strong>. It provides the &quot;Coordinate System&quot; mental model needed for the 10-10-12 bit split.</li>\n</ul>\n<h3 id=\"6-the-design-and-implementation-of-a-log-structured-file-system\">6. The Design and Implementation of a Log-Structured File System</h3>\n<ul>\n<li><strong>Paper</strong>: Mendel Rosenblum and John K. Ousterhout, &quot;The Design and Implementation of a Log-Structured File System,&quot; <em>ACM TOCS</em>, 1992.</li>\n<li><strong>Why</strong>: Demonstrates how the same Radix Tree/Trie principles used in your M3 page tables are applied to disk block mapping.</li>\n<li><strong>When to Read</strong>: <strong>After Milestone 3</strong>. To see the &quot;Knowledge Cascade&quot; of how multi-level indexing applies to file systems.</li>\n</ul>\n<h2 id=\"-page-replacement-amp-swap-theory\">ğŸ”„ Page Replacement &amp; Swap Theory</h2>\n<h3 id=\"7-a-study-of-replacement-algorithms-for-a-virtual-storage-computer\">7. A Study of Replacement Algorithms for a Virtual-Storage Computer</h3>\n<ul>\n<li><strong>Paper</strong>: Laszlo BÃ©lÃ¡dy, &quot;A study of replacement algorithms for a virtual-storage computer,&quot; <em>IBM Systems Journal</em>, 1966.</li>\n<li><strong>Best Explanation</strong>: OSTEP Chapter 22: &quot;Beyond Physical Memory: Policies.&quot;</li>\n<li><strong>Why</strong>: This is the origin of &quot;BÃ©lÃ¡dyâ€™s Anomaly,&quot; where the author proves that FIFO can actually perform worse with more memoryâ€”a concept you will replicate in M4.</li>\n<li><strong>When to Read</strong>: <strong>Before Milestone 4 (Replacement)</strong>. It sets the stage for the comparative analysis.</li>\n</ul>\n<h3 id=\"8-evaluation-of-page-replacement-algorithms\">8. Evaluation of Page Replacement Algorithms</h3>\n<ul>\n<li><strong>Paper</strong>: Mattson et al., &quot;Evaluation techniques for storage hierarchies,&quot; <em>IBM Systems Journal</em>, 1970.</li>\n<li><strong>Best Explanation</strong>: Wikipedia&#39;s &quot;Stack algorithm&quot; entry for the formal definition.</li>\n<li><strong>Why</strong>: The definitive proof that LRU and Optimal are &quot;Stack Algorithms&quot; and thus immune to the anomaly you found in FIFO.</li>\n<li><strong>When to Read</strong>: <strong>During Milestone 4</strong>. It explains why the &quot;Inclusion Property&quot; makes capacity planning possible.</li>\n</ul>\n<h3 id=\"9-linux-kernel-the-page-frame-reclaim-algorithm-pfra\">9. Linux Kernel: The Page Frame Reclaim Algorithm (PFRA)</h3>\n<ul>\n<li><strong>Code</strong>: <code>mm/vmscan.c</code> (Linux Kernel).</li>\n<li><strong>Best Explanation</strong>: <em>Understanding the Linux Kernel</em> (Bovet &amp; Cesati), Chapter 17: &quot;Page Frame Reclaim.&quot;</li>\n<li><strong>Why</strong>: Shows how a production kernel implements the &quot;Clock&quot; approximation (using active/inactive lists) that you build in M4.</li>\n<li><strong>When to Read</strong>: <strong>After completing the project</strong>. It is the &quot;Boss Level&quot; of virtual memory understanding.</li>\n</ul>\n<h2 id=\"-tooling-amp-real-world-application\">ğŸ› ï¸ Tooling &amp; Real-World Application</h2>\n<h3 id=\"10-valgrind-a-framework-for-heavyweight-dynamic-binary-instrumentation\">10. Valgrind: A Framework for Heavyweight Dynamic Binary Instrumentation</h3>\n<ul>\n<li><strong>Paper</strong>: Nicholas Nethercote and Julian Seward, &quot;Valgrind: A Framework for Heavyweight Dynamic Binary Instrumentation,&quot; <em>PLDI</em>, 2007.</li>\n<li><strong>Why</strong>: Valgrind is essentially a massive, highly optimized version of the simulator you just built.</li>\n<li><strong>When to Read</strong>: <strong>Project Reflection</strong>. To see how your shadow page table concepts power modern debugging tools.</li>\n</ul>\n","toc":[{"level":1,"text":"ğŸ¯ Project Charter: Virtual Memory Simulator","id":"-project-charter-virtual-memory-simulator"},{"level":2,"text":"What You Are Building","id":"what-you-are-building"},{"level":2,"text":"Why This Project Exists","id":"why-this-project-exists"},{"level":2,"text":"What You Will Be Able to Do When Done","id":"what-you-will-be-able-to-do-when-done"},{"level":2,"text":"Final Deliverable","id":"final-deliverable"},{"level":2,"text":"Is This Project For You?","id":"is-this-project-for-you"},{"level":2,"text":"Estimated Effort","id":"estimated-effort"},{"level":2,"text":"Definition of Done","id":"definition-of-done"},{"level":1,"text":"Virtual Memory Simulator","id":"virtual-memory-simulator"},{"level":1,"text":"Milestone 1: Single-Level Page Table and Address Translation","id":"milestone-1-single-level-page-table-and-address-translation"},{"level":2,"text":"The Problem You&#39;re Actually Solving","id":"the-problem-you39re-actually-solving"},{"level":2,"text":"The Revelation: You Don&#39;t Look Up Addresses â€” You Decompose Them","id":"the-revelation-you-don39t-look-up-addresses-you-decompose-them"},{"level":2,"text":"The Page Table Entry: Every Bit Earns Its Place","id":"the-page-table-entry-every-bit-earns-its-place"},{"level":3,"text":"Alternative: Using a Plain uint32_t with Masks","id":"alternative-using-a-plain-uint32_t-with-masks"},{"level":2,"text":"Design choice for your simulator: The bitfield struct is more readable for learning purposes. Use it unless you run into compiler issues, in which case switch to the mask approach. Real kernels like Linux use macro-based masks (_PAGE_PRESENT, _PAGE_DIRTY, _PAGE_ACCESSED, etc.) defined in arch/x86/include/asm/pgtable.h.","id":"design-choice-for-your-simulator-the-bitfield-struct-is-more-readable-for-learning-purposes-use-it-unless-you-run-into-compiler-issues-in-which-case-switch-to-the-mask-approach-real-kernels-like-linux-use-macro-based-masks-_page_present-_page_dirty-_page_accessed-etc-defined-in-archx86includeasmpgtableh"},{"level":2,"text":"The Full Simulator Data Model","id":"the-full-simulator-data-model"},{"level":2,"text":"Address Decomposition: The Two Extractors","id":"address-decomposition-the-two-extractors"},{"level":2,"text":"The Trace File: Your Simulator&#39;s Input","id":"the-trace-file-your-simulator39s-input"},{"level":3,"text":"Trace Format","id":"trace-format"},{"level":3,"text":"Trace Parser","id":"trace-parser"},{"level":2,"text":"The Two Failure Modes: Page Fault vs Protection Fault","id":"the-two-failure-modes-page-fault-vs-protection-fault"},{"level":2,"text":"Demand Paging: Pages on Demand","id":"demand-paging-pages-on-demand"},{"level":2,"text":"Security note: The memset(frame.data, 0, PAGE_SIZE) call is not just housekeeping â€” it&#39;s a security requirement. If the OS reuses frames without zeroing them, a new process could read data left behind by a previous process. Linux zeroes pages before handing them to userspace.","id":"security-note-the-memsetframedata-0-page_size-call-is-not-just-housekeeping-it39s-a-security-requirement-if-the-os-reuses-frames-without-zeroing-them-a-new-process-could-read-data-left-behind-by-a-previous-process-linux-zeroes-pages-before-handing-them-to-userspace"},{"level":2,"text":"The Core Translation Function","id":"the-core-translation-function"},{"level":2,"text":"Critical ordering note: Check valid before checking permissions. If you check permissions on an invalid PTE, you&#39;re reading garbage bits â€” the PTE&#39;s content is meaningless when valid=0. The valid check must come first.\nDirty bit discipline: Only write accesses set the dirty bit. Read accesses never do. This matters enormously in Milestone 4: a dirty page must be written to swap before its frame can be reused. If you incorrectly set dirty on reads, you&#39;ll cause unnecessary swap writes, inflating your swap write-back statistics.","id":"critical-ordering-note-check-valid-before-checking-permissions-if-you-check-permissions-on-an-invalid-pte-you39re-reading-garbage-bits-the-pte39s-content-is-meaningless-when-valid0-the-valid-check-must-come-first-dirty-bit-discipline-only-write-accesses-set-the-dirty-bit-read-accesses-never-do-this-matters-enormously-in-milestone-4-a-dirty-page-must-be-written-to-swap-before-its-frame-can-be-reused-if-you-incorrectly-set-dirty-on-reads-you39ll-cause-unnecessary-swap-writes-inflating-your-swap-write-back-statistics"},{"level":2,"text":"The Main Simulation Loop","id":"the-main-simulation-loop"},{"level":2,"text":"Initializing the Simulator","id":"initializing-the-simulator"},{"level":2,"text":"Building and Testing","id":"building-and-testing"},{"level":3,"text":"Compile","id":"compile"},{"level":3,"text":"Minimal test trace","id":"minimal-test-trace"},{"level":3,"text":"Protection fault test trace","id":"protection-fault-test-trace"},{"level":2,"text":"Common Pitfalls and How to Avoid Them","id":"common-pitfalls-and-how-to-avoid-them"},{"level":2,"text":"Hardware Soul: What Real Hardware Does","id":"hardware-soul-what-real-hardware-does"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":2,"text":"mmap() doesn&#39;t read the file â€” it creates PTEs with valid=0 that point to file offsets instead of swap. When you touch a mapped page, the page fault handler reads exactly that 4KB chunk from disk and maps it into a free frame. You&#39;ve just implemented the core of this mechanism. The OS never needs more RAM than the number of pages simultaneously accessed (the working set).\n3. Process isolation is a page table, not a byte-level guard\nEvery process has its own page table. Process A&#39;s VPN 0x12345 â†’ PFN 17; Process B&#39;s VPN 0x12345 â†’ PFN 83. The same virtual address translates to completely different physical frames. There&#39;s no per-byte checking, no encryption, no copying â€” just two separate PTEs that happen to be indexed by the same number but live in different page tables. Memory isolation is 100% a page table artifact. When you see &quot;memory corruption via buffer overflow that overwrites another process&#39;s memory,&quot; the reason it doesn&#39;t happen normally is that there are no PTEs mapping virtual addresses outside your process&#39;s allocated regions.\n4. SQLite, PostgreSQL, and InnoDB all think in pages\nEvery relational database uses page-sized I/O buffers because the OS&#39;s unit of transfer between disk and RAM is exactly one page (4KB). PostgreSQL&#39;s page size is 8KB (2Ã— OS page); MySQL InnoDB uses 16KB (4Ã— OS page). Their buffer pools are essentially a software version of what you just built â€” a mapping from &quot;logical page number on disk&quot; to &quot;frame in the buffer pool&quot; â€” with the same concepts of valid bits (is this page currently in the pool?), dirty bits (has it been modified since last flush?), and replacement algorithms (LFU, clock, ARC). The OS virtual memory system and the database buffer manager are isomorphic designs solving the same caching problem at different layers.\n5. Cross-domain: Web caches and CDNs\nThe page table is a cache: it maps virtual addresses to physical locations, handling misses (page faults) by fetching from backing storage (disk/swap). CDNs do the same: they cache URLs â†’ physical server responses, handling misses by fetching from origin. The eviction algorithms you&#39;ll implement in Milestone 4 (LRU, Clock, Optimal) are exactly the same algorithms used in Nginx&#39;s proxy cache, Varnish, and CDN edge nodes. Page replacement theory is cache theory. The domains are the same mathematics.","id":"mmap-doesn39t-read-the-file-it-creates-ptes-with-valid0-that-point-to-file-offsets-instead-of-swap-when-you-touch-a-mapped-page-the-page-fault-handler-reads-exactly-that-4kb-chunk-from-disk-and-maps-it-into-a-free-frame-you39ve-just-implemented-the-core-of-this-mechanism-the-os-never-needs-more-ram-than-the-number-of-pages-simultaneously-accessed-the-working-set-3-process-isolation-is-a-page-table-not-a-byte-level-guard-every-process-has-its-own-page-table-process-a39s-vpn-0x12345-pfn-17-process-b39s-vpn-0x12345-pfn-83-the-same-virtual-address-translates-to-completely-different-physical-frames-there39s-no-per-byte-checking-no-encryption-no-copying-just-two-separate-ptes-that-happen-to-be-indexed-by-the-same-number-but-live-in-different-page-tables-memory-isolation-is-100-a-page-table-artifact-when-you-see-quotmemory-corruption-via-buffer-overflow-that-overwrites-another-process39s-memoryquot-the-reason-it-doesn39t-happen-normally-is-that-there-are-no-ptes-mapping-virtual-addresses-outside-your-process39s-allocated-regions-4-sqlite-postgresql-and-innodb-all-think-in-pages-every-relational-database-uses-page-sized-io-buffers-because-the-os39s-unit-of-transfer-between-disk-and-ram-is-exactly-one-page-4kb-postgresql39s-page-size-is-8kb-2-os-page-mysql-innodb-uses-16kb-4-os-page-their-buffer-pools-are-essentially-a-software-version-of-what-you-just-built-a-mapping-from-quotlogical-page-number-on-diskquot-to-quotframe-in-the-buffer-poolquot-with-the-same-concepts-of-valid-bits-is-this-page-currently-in-the-pool-dirty-bits-has-it-been-modified-since-last-flush-and-replacement-algorithms-lfu-clock-arc-the-os-virtual-memory-system-and-the-database-buffer-manager-are-isomorphic-designs-solving-the-same-caching-problem-at-different-layers-5-cross-domain-web-caches-and-cdns-the-page-table-is-a-cache-it-maps-virtual-addresses-to-physical-locations-handling-misses-page-faults-by-fetching-from-backing-storage-diskswap-cdns-do-the-same-they-cache-urls-physical-server-responses-handling-misses-by-fetching-from-origin-the-eviction-algorithms-you39ll-implement-in-milestone-4-lru-clock-optimal-are-exactly-the-same-algorithms-used-in-nginx39s-proxy-cache-varnish-and-cdn-edge-nodes-page-replacement-theory-is-cache-theory-the-domains-are-the-same-mathematics"},{"level":2,"text":"What You&#39;ve Built and What&#39;s Missing","id":"what-you39ve-built-and-what39s-missing"},{"level":1,"text":"Milestone 2: TLB (Translation Lookaside Buffer)","id":"milestone-2-tlb-translation-lookaside-buffer"},{"level":2,"text":"The Problem: Every Load Is Two Loads","id":"the-problem-every-load-is-two-loads"},{"level":2,"text":"The Revelation: The TLB Is the Most Important Cache in Your CPU","id":"the-revelation-the-tlb-is-the-most-important-cache-in-your-cpu"},{"level":2,"text":"What a TLB Entry Contains","id":"what-a-tlb-entry-contains"},{"level":3,"text":"What it is","id":"what-it-is"},{"level":3,"text":"Why you need it right now","id":"why-you-need-it-right-now"},{"level":3,"text":"The Key Insight: The &quot;Valet vs. Assigned Parking&quot; Model","id":"the-key-insight-the-quotvalet-vs-assigned-parkingquot-model"},{"level":2,"text":"The ASID: Context Switches Without Tears","id":"the-asid-context-switches-without-tears"},{"level":2,"text":"The TLB Structure","id":"the-tlb-structure"},{"level":2,"text":"Hardware soul â€” cache line analysis:\nA tlb_entry_t is 12 bytes. A tlb_t with 64 entries is 64 Ã— 12 = 768 bytes for entries, plus ~32 bytes of overhead = ~800 bytes total. This fits comfortably in an L1 cache (typically 32KB). In hardware, TLB lookup is done in parallel across all entries in a single cycle using content-addressable memory (CAM) â€” your software implementation uses a sequential loop, but the data structure fits in L1 regardless, minimizing the performance gap.","id":"hardware-soul-cache-line-analysis-a-tlb_entry_t-is-12-bytes-a-tlb_t-with-64-entries-is-64-12-768-bytes-for-entries-plus-32-bytes-of-overhead-800-bytes-total-this-fits-comfortably-in-an-l1-cache-typically-32kb-in-hardware-tlb-lookup-is-done-in-parallel-across-all-entries-in-a-single-cycle-using-content-addressable-memory-cam-your-software-implementation-uses-a-sequential-loop-but-the-data-structure-fits-in-l1-regardless-minimizing-the-performance-gap"},{"level":2,"text":"TLB Lookup: Tag Matching in Action","id":"tlb-lookup-tag-matching-in-action"},{"level":2,"text":"TLB Insertion and Eviction","id":"tlb-insertion-and-eviction"},{"level":2,"text":"TLB Flush Operations","id":"tlb-flush-operations"},{"level":2,"text":"Why tlb_flush_page matters for Milestone 4: When you evict a page from physical memory to make room for a new one, you must call tlb_flush_page() on that page&#39;s VPN before clearing its PTE. Otherwise, the TLB may still hold a valid-looking entry pointing to a PFN that now belongs to a different page. That&#39;s a TLB coherence violation â€” the hardware equivalent of reading from a dangling pointer. The TLB would return a PFN that now maps to different data, causing silent memory corruption with no visible fault.","id":"why-tlb_flush_page-matters-for-milestone-4-when-you-evict-a-page-from-physical-memory-to-make-room-for-a-new-one-you-must-call-tlb_flush_page-on-that-page39s-vpn-before-clearing-its-pte-otherwise-the-tlb-may-still-hold-a-valid-looking-entry-pointing-to-a-pfn-that-now-belongs-to-a-different-page-that39s-a-tlb-coherence-violation-the-hardware-equivalent-of-reading-from-a-dangling-pointer-the-tlb-would-return-a-pfn-that-now-maps-to-different-data-causing-silent-memory-corruption-with-no-visible-fault"},{"level":2,"text":"Integrating the TLB into Address Translation","id":"integrating-the-tlb-into-address-translation"},{"level":2,"text":"Context Switch Simulation","id":"context-switch-simulation"},{"level":2,"text":"The last access is the key insight: Process 1&#39;s TLB entry survived the context switch because ASID tagging made it invisible (not evicted) during Process 2&#39;s execution. When Process 1 resumes, its entries are immediately warm. This is the entire performance value proposition of ASID support.","id":"the-last-access-is-the-key-insight-process-139s-tlb-entry-survived-the-context-switch-because-asid-tagging-made-it-invisible-not-evicted-during-process-239s-execution-when-process-1-resumes-its-entries-are-immediately-warm-this-is-the-entire-performance-value-proposition-of-asid-support"},{"level":2,"text":"Statistics and Reporting","id":"statistics-and-reporting"},{"level":2,"text":"Building and Testing","id":"building-and-testing"},{"level":3,"text":"Compile","id":"compile"},{"level":3,"text":"Test 1: Verify TLB Hit Rate with Repeated Access","id":"test-1-verify-tlb-hit-rate-with-repeated-access"},{"level":3,"text":"Test 2: LRU Eviction Correctness","id":"test-2-lru-eviction-correctness"},{"level":3,"text":"Test 3: ASID Context Switch Correctness","id":"test-3-asid-context-switch-correctness"},{"level":3,"text":"Test 4: Dirty Bit Write-Back","id":"test-4-dirty-bit-write-back"},{"level":2,"text":"Common Pitfalls and How to Avoid Them","id":"common-pitfalls-and-how-to-avoid-them"},{"level":2,"text":"Hardware Soul: What Your Simulator Abstracts Away","id":"hardware-soul-what-your-simulator-abstracts-away"},{"level":2,"text":"Knowledge Cascade: What the TLB Unlocks","id":"knowledge-cascade-what-the-tlb-unlocks"},{"level":2,"text":"What You&#39;ve Built and What&#39;s Missing","id":"what-you39ve-built-and-what39s-missing"},{"level":1,"text":"Milestone 3: Multi-Level Page Tables","id":"milestone-3-multi-level-page-tables"},{"level":2,"text":"The Problem You&#39;re Actually Solving (It&#39;s Not What You Think)","id":"the-problem-you39re-actually-solving-it39s-not-what-you-think"},{"level":2,"text":"Why Hierarchical Indexing Saves Memory for Sparse Structures","id":"why-hierarchical-indexing-saves-memory-for-sparse-structures"},{"level":2,"text":"The Virtual Address Decomposition: Three Fields Now","id":"the-virtual-address-decomposition-three-fields-now"},{"level":2,"text":"The walk: page_directory[1] â†’ find the second-level page table â†’ page_table[5] â†’ PFN â†’ physical address = (PFN &lt;&lt; 12) | 0x6A8.\nPitfall â€” most significant bits select the directory. This is the most common mistake. You might instinctively grab the low bits of the VPN for the directory index and the high bits for the table index. The correct ordering is: the most significant bits of the virtual address select the top-level directory. Think of it like a postal code: the largest geographical unit (country) comes first, then region, then city. The high bits of a virtual address identify the coarse region; the lower bits identify the fine-grained page within that region.","id":"the-walk-page_directory1-find-the-second-level-page-table-page_table5-pfn-physical-address-pfn-ltlt-12-0x6a8-pitfall-most-significant-bits-select-the-directory-this-is-the-most-common-mistake-you-might-instinctively-grab-the-low-bits-of-the-vpn-for-the-directory-index-and-the-high-bits-for-the-table-index-the-correct-ordering-is-the-most-significant-bits-of-the-virtual-address-select-the-top-level-directory-think-of-it-like-a-postal-code-the-largest-geographical-unit-country-comes-first-then-region-then-city-the-high-bits-of-a-virtual-address-identify-the-coarse-region-the-lower-bits-identify-the-fine-grained-page-within-that-region"},{"level":2,"text":"The CR3 Register: The Root of Everything","id":"the-cr3-register-the-root-of-everything"},{"level":2,"text":"The Full Data Model: Two-Level Simulator State","id":"the-full-data-model-two-level-simulator-state"},{"level":2,"text":"Allocating Structures: The Simulated Memory Manager","id":"allocating-structures-the-simulated-memory-manager"},{"level":2,"text":"The Page Table Walk: Following the Chain","id":"the-page-table-walk-following-the-chain"},{"level":2,"text":"The critical ordering invariant: You must check the PDE before dereferencing the second-level page table pointer. Dereferencing a NULL pgtables[pdi] is undefined behavior in C â€” it won&#39;t raise a controlled page fault, it will crash your simulator with a segfault. The pde_is_present() check is your guard.","id":"the-critical-ordering-invariant-you-must-check-the-pde-before-dereferencing-the-second-level-page-table-pointer-dereferencing-a-null-pgtablespdi-is-undefined-behavior-in-c-it-won39t-raise-a-controlled-page-fault-it-will-crash-your-simulator-with-a-segfault-the-pde_is_present-check-is-your-guard"},{"level":2,"text":"On-Demand Second-Level Table Allocation: The Full Picture","id":"on-demand-second-level-table-allocation-the-full-picture"},{"level":2,"text":"The page table allocation only fires once per directory region, no matter how many pages within that region are subsequently accessed. This is the memory efficiency of the hierarchical approach made concrete.","id":"the-page-table-allocation-only-fires-once-per-directory-region-no-matter-how-many-pages-within-that-region-are-subsequently-accessed-this-is-the-memory-efficiency-of-the-hierarchical-approach-made-concrete"},{"level":2,"text":"Context Switching with CR3","id":"context-switching-with-cr3"},{"level":2,"text":"The CR3 register is the physical manifestation of process isolation. When you execute ml_context_switch(), the entire virtual address space changes. Process A&#39;s 0x00401000 and Process B&#39;s 0x00401000 are completely independent â€” they refer to different PTEs in different page directories, which map to different physical frames. The address 0x00401000 means nothing without the CR3 that establishes the context for its interpretation.","id":"the-cr3-register-is-the-physical-manifestation-of-process-isolation-when-you-execute-ml_context_switch-the-entire-virtual-address-space-changes-process-a39s-0x00401000-and-process-b39s-0x00401000-are-completely-independent-they-refer-to-different-ptes-in-different-page-directories-which-map-to-different-physical-frames-the-address-0x00401000-means-nothing-without-the-cr3-that-establishes-the-context-for-its-interpretation"},{"level":2,"text":"Integrating with the TLB: The Full Three-Level View","id":"integrating-with-the-tlb-the-full-three-level-view"},{"level":2,"text":"Why TLB miss costs more with multi-level tables. In Milestone 1 with a flat table, a TLB miss cost one memory access (reading page_table.entries[vpn]). With a two-level table, a TLB miss costs two memory accesses: one to read the PDE from the page directory, and one to read the PTE from the second-level table. This is why the TLB matters even more with hierarchical tables â€” each additional level multiplies the miss penalty. On real x86-64 with four-level tables, a TLB miss costs four memory accesses (one per level). This is why x86-64 CPUs have a dedicated hardware page walker that handles these four accesses using a separate non-pipelined path, and why hardware prefetchers try to predict page table accesses.","id":"why-tlb-miss-costs-more-with-multi-level-tables-in-milestone-1-with-a-flat-table-a-tlb-miss-cost-one-memory-access-reading-page_tableentriesvpn-with-a-two-level-table-a-tlb-miss-costs-two-memory-accesses-one-to-read-the-pde-from-the-page-directory-and-one-to-read-the-pte-from-the-second-level-table-this-is-why-the-tlb-matters-even-more-with-hierarchical-tables-each-additional-level-multiplies-the-miss-penalty-on-real-x86-64-with-four-level-tables-a-tlb-miss-costs-four-memory-accesses-one-per-level-this-is-why-x86-64-cpus-have-a-dedicated-hardware-page-walker-that-handles-these-four-accesses-using-a-separate-non-pipelined-path-and-why-hardware-prefetchers-try-to-predict-page-table-accesses"},{"level":2,"text":"Memory Overhead Comparison: The Numbers That Matter","id":"memory-overhead-comparison-the-numbers-that-matter"},{"level":2,"text":"99.4% savings for a sparse process using 5 pages. This is not a toy improvement â€” it&#39;s the difference between a system supporting 100 processes and one supporting 10,000.","id":"994-savings-for-a-sparse-process-using-5-pages-this-is-not-a-toy-improvement-it39s-the-difference-between-a-system-supporting-100-processes-and-one-supporting-10000"},{"level":2,"text":"Stretch Goal: Three-Level Page Tables","id":"stretch-goal-three-level-page-tables"},{"level":2,"text":"Building and Testing","id":"building-and-testing"},{"level":3,"text":"Compile","id":"compile"},{"level":3,"text":"Test 1: Address Decomposition Correctness","id":"test-1-address-decomposition-correctness"},{"level":3,"text":"Test 2: On-Demand Table Allocation","id":"test-2-on-demand-table-allocation"},{"level":3,"text":"Test 3: Memory Overhead Comparison","id":"test-3-memory-overhead-comparison"},{"level":3,"text":"Test 4: CR3 Context Switch Isolation","id":"test-4-cr3-context-switch-isolation"},{"level":3,"text":"Test 5: PDE vs PTE Structural Distinction","id":"test-5-pde-vs-pte-structural-distinction"},{"level":2,"text":"Common Pitfalls and How to Avoid Them","id":"common-pitfalls-and-how-to-avoid-them"},{"level":2,"text":"Hardware Soul: What Real Silicon Does","id":"hardware-soul-what-real-silicon-does"},{"level":2,"text":"Knowledge Cascade: What Multi-Level Page Tables Unlock","id":"knowledge-cascade-what-multi-level-page-tables-unlock"},{"level":3,"text":"1. The Multi-Level Page Table IS a Radix Trie","id":"1-the-multi-level-page-table-is-a-radix-trie"},{"level":3,"text":"2. Linux&#39;s 5-Level Page Table: The Same Concept, Extended","id":"2-linux39s-5-level-page-table-the-same-concept-extended"},{"level":3,"text":"3. Sparse File Systems: Inode Indirect Blocks","id":"3-sparse-file-systems-inode-indirect-blocks"},{"level":3,"text":"4. Copy-on-Write fork() â€” Sharing Page Table Subtrees","id":"4-copy-on-write-fork-sharing-page-table-subtrees"},{"level":3,"text":"5. Memory-Mapped Device I/O â€” Single PDE for a Region","id":"5-memory-mapped-device-io-single-pde-for-a-region"},{"level":3,"text":"6. Huge Pages â€” Collapsing Levels for Performance","id":"6-huge-pages-collapsing-levels-for-performance"},{"level":2,"text":"With standard 4KB pages, a 2MB allocation requires 512 PTEs across potentially many cache lines in the page table. With a 2MB huge page, the PMD entry (in a 4-level table) directly maps 2MB using a single table entry â€” the leaf level (PTE) is skipped entirely. The entry in the middle-level table (PMD) sets a special &quot;huge page&quot; bit and the physical address points directly to a 2MB-aligned physical region.\nIn your simulator, you could implement huge pages by adding a huge flag to PDE entries: if set, the PDE&#39;s physical address points directly to a 4MB data region (aligned to 4MB), skipping the second-level table entirely. The address decomposition changes: for an access to a &quot;huge&quot; PDE, the physical address is pde_pfn_base + (vaddr &amp; 0x3FFFFF) (the bottom 22 bits become the offset within the 4MB region).\nThis is exactly why PostgreSQL and Redis benefit from huge page configuration (vm.nr_hugepages on Linux): a 256MB database buffer pool with 4KB pages requires 65,536 PTEs; with 2MB huge pages, it requires 128 PMD entries. The TLB pressure drops by 512Ã—.","id":"with-standard-4kb-pages-a-2mb-allocation-requires-512-ptes-across-potentially-many-cache-lines-in-the-page-table-with-a-2mb-huge-page-the-pmd-entry-in-a-4-level-table-directly-maps-2mb-using-a-single-table-entry-the-leaf-level-pte-is-skipped-entirely-the-entry-in-the-middle-level-table-pmd-sets-a-special-quothuge-pagequot-bit-and-the-physical-address-points-directly-to-a-2mb-aligned-physical-region-in-your-simulator-you-could-implement-huge-pages-by-adding-a-huge-flag-to-pde-entries-if-set-the-pde39s-physical-address-points-directly-to-a-4mb-data-region-aligned-to-4mb-skipping-the-second-level-table-entirely-the-address-decomposition-changes-for-an-access-to-a-quothugequot-pde-the-physical-address-is-pde_pfn_base-vaddr-amp-0x3fffff-the-bottom-22-bits-become-the-offset-within-the-4mb-region-this-is-exactly-why-postgresql-and-redis-benefit-from-huge-page-configuration-vmnr_hugepages-on-linux-a-256mb-database-buffer-pool-with-4kb-pages-requires-65536-ptes-with-2mb-huge-pages-it-requires-128-pmd-entries-the-tlb-pressure-drops-by-512"},{"level":2,"text":"What You&#39;ve Built and What&#39;s Missing","id":"what-you39ve-built-and-what39s-missing"},{"level":1,"text":"Milestone 4: Page Replacement and Swap Simulation","id":"milestone-4-page-replacement-and-swap-simulation"},{"level":2,"text":"The Problem: Physical Memory Is Finite, Virtual Greed Is Not","id":"the-problem-physical-memory-is-finite-virtual-greed-is-not"},{"level":2,"text":"You have 64 frames in your simulator. After 64 distinct page faults, every frame is occupied. The 65th fault hits your alloc_free_frame() function, which scans through all frames, finds none available, and returns UINT32_MAX. Your simulator logs [OOM] No free frames and gives up.\nReal operating systems never give up. The Linux kernel, running a machine with 16 GB of RAM, routinely handles workloads that would require 40 GB if fully materialized in memory. It does this by maintaining the illusion that every process has all the memory it needs, while physically storing only the active portion â€” the working set â€” in RAM. Everything else lives on disk, in a region called swap space, waiting to be recalled when needed.\n[[EXPLAIN:swap-space:-extending-ram-to-disk,-what-&#39;page-out&#39;-and-&#39;page-in&#39;-mean|Swap space: extending RAM to disk, what &#39;page out&#39; and &#39;page in&#39; mean â€” how the OS extends the apparent size of physical memory using disk storage]]\nThis milestone is about making the hard choice the OS always has to make: when physical memory is full and a new page must be loaded, which existing page do you sacrifice? Sacrifice the wrong one â€” a page the program needs again in three instructions â€” and you&#39;ve created a chain of faults that grinds execution to a halt. Choose well â€” a page that won&#39;t be needed for ten million accesses â€” and the program never notices the eviction happened.\nThat choice is page replacement, and it turns out to be one of the most consequential decisions an OS makes for application performance. The difference between a well-tuned and poorly-tuned replacement policy on a real database server can mean 10Ã— throughput difference for the same hardware.","id":"you-have-64-frames-in-your-simulator-after-64-distinct-page-faults-every-frame-is-occupied-the-65th-fault-hits-your-alloc_free_frame-function-which-scans-through-all-frames-finds-none-available-and-returns-uint32_max-your-simulator-logs-oom-no-free-frames-and-gives-up-real-operating-systems-never-give-up-the-linux-kernel-running-a-machine-with-16-gb-of-ram-routinely-handles-workloads-that-would-require-40-gb-if-fully-materialized-in-memory-it-does-this-by-maintaining-the-illusion-that-every-process-has-all-the-memory-it-needs-while-physically-storing-only-the-active-portion-the-working-set-in-ram-everything-else-lives-on-disk-in-a-region-called-swap-space-waiting-to-be-recalled-when-needed-explainswap-space-extending-ram-to-disk-what-39page-out39-and-39page-in39-meanswap-space-extending-ram-to-disk-what-39page-out39-and-39page-in39-mean-how-the-os-extends-the-apparent-size-of-physical-memory-using-disk-storage-this-milestone-is-about-making-the-hard-choice-the-os-always-has-to-make-when-physical-memory-is-full-and-a-new-page-must-be-loaded-which-existing-page-do-you-sacrifice-sacrifice-the-wrong-one-a-page-the-program-needs-again-in-three-instructions-and-you39ve-created-a-chain-of-faults-that-grinds-execution-to-a-halt-choose-well-a-page-that-won39t-be-needed-for-ten-million-accesses-and-the-program-never-notices-the-eviction-happened-that-choice-is-page-replacement-and-it-turns-out-to-be-one-of-the-most-consequential-decisions-an-os-makes-for-application-performance-the-difference-between-a-well-tuned-and-poorly-tuned-replacement-policy-on-a-real-database-server-can-mean-10-throughput-difference-for-the-same-hardware"},{"level":2,"text":"The Revelation: LRU Is Not the Answer You Think It Is","id":"the-revelation-lru-is-not-the-answer-you-think-it-is"},{"level":2,"text":"Swap Space: The Illusion of Infinite Memory","id":"swap-space-the-illusion-of-infinite-memory"},{"level":2,"text":"The write_backs counter is one of your most important statistics. It counts the extra disk I/O cost incurred by dirty page evictions â€” a direct measure of how much the replacement algorithm is thrashing modified data in and out of swap.","id":"the-write_backs-counter-is-one-of-your-most-important-statistics-it-counts-the-extra-disk-io-cost-incurred-by-dirty-page-evictions-a-direct-measure-of-how-much-the-replacement-algorithm-is-thrashing-modified-data-in-and-out-of-swap"},{"level":2,"text":"The Physical Memory Model: Frames and the Free Pool","id":"the-physical-memory-model-frames-and-the-free-pool"},{"level":2,"text":"The clock field is a logical timestamp â€” a global counter incremented on every memory access. You assign load_time when a frame is claimed, and last_access on every subsequent access to a page in that frame. These timestamps drive FIFO and LRU eviction decisions without requiring list manipulation on the common (non-replacement) path.","id":"the-clock-field-is-a-logical-timestamp-a-global-counter-incremented-on-every-memory-access-you-assign-load_time-when-a-frame-is-claimed-and-last_access-on-every-subsequent-access-to-a-page-in-that-frame-these-timestamps-drive-fifo-and-lru-eviction-decisions-without-requiring-list-manipulation-on-the-common-non-replacement-path"},{"level":2,"text":"The Replacement Interface","id":"the-replacement-interface"},{"level":2,"text":"The key invariant this function must maintain: before the frame is reused, the TLB must be invalidated for the evicted VPN. This is the connection back to Milestone 2&#39;s tlb_flush_page(). Skipping this step causes the TLB to return a stale PFN for the evicted VPN â€” pointing to a frame now occupied by a different page&#39;s data. That&#39;s the TLB coherence violation, and it produces silent memory corruption with no fault raised.","id":"the-key-invariant-this-function-must-maintain-before-the-frame-is-reused-the-tlb-must-be-invalidated-for-the-evicted-vpn-this-is-the-connection-back-to-milestone-239s-tlb_flush_page-skipping-this-step-causes-the-tlb-to-return-a-stale-pfn-for-the-evicted-vpn-pointing-to-a-frame-now-occupied-by-a-different-page39s-data-that39s-the-tlb-coherence-violation-and-it-produces-silent-memory-corruption-with-no-fault-raised"},{"level":2,"text":"Swap In and Swap Out: The Data Walk","id":"swap-in-and-swap-out-the-data-walk"},{"level":2,"text":"Why freeing the swap slot on page-in matters: Once the page is back in RAM (dirty bit clear â€” it was just loaded), the swap slot contains stale data. If the page is later evicted again without being written to, it&#39;s clean â€” its on-disk representation is the original file (or zero-fill for anonymous pages). Keeping the swap slot occupied unnecessarily wastes swap capacity and confuses the swap_find_slot() logic on the next eviction.","id":"why-freeing-the-swap-slot-on-page-in-matters-once-the-page-is-back-in-ram-dirty-bit-clear-it-was-just-loaded-the-swap-slot-contains-stale-data-if-the-page-is-later-evicted-again-without-being-written-to-it39s-clean-its-on-disk-representation-is-the-original-file-or-zero-fill-for-anonymous-pages-keeping-the-swap-slot-occupied-unnecessarily-wastes-swap-capacity-and-confuses-the-swap_find_slot-logic-on-the-next-eviction"},{"level":2,"text":"The Eviction Core: Shared Across All Policies","id":"the-eviction-core-shared-across-all-policies"},{"level":2,"text":"Order is life-critical. The three operations â€” write-back, TLB invalidation, PTE clear â€” must happen in exactly this sequence. Write-back before PTE clear ensures the data survives if the write-back somehow fails. TLB invalidation before the frame is reused ensures no stale translations point to the newly reassigned frame. This ordering is the same discipline enforced in production kernels: Linux&#39;s try_to_unmap() + pageout() sequence follows this exact order.","id":"order-is-life-critical-the-three-operations-write-back-tlb-invalidation-pte-clear-must-happen-in-exactly-this-sequence-write-back-before-pte-clear-ensures-the-data-survives-if-the-write-back-somehow-fails-tlb-invalidation-before-the-frame-is-reused-ensures-no-stale-translations-point-to-the-newly-reassigned-frame-this-ordering-is-the-same-discipline-enforced-in-production-kernels-linux39s-try_to_unmap-pageout-sequence-follows-this-exact-order"},{"level":2,"text":"FIFO: The Naive Baseline","id":"fifo-the-naive-baseline"},{"level":2,"text":"FIFO&#39;s simplicity is appealing. Its correctness is easy to verify: given any reference string, you can trace through it by hand and count faults. This is why it&#39;s the standard baseline in OS textbooks and the one that exhibits BÃ©lÃ¡dy&#39;s anomaly â€” which we&#39;ll demonstrate shortly.\nFIFO&#39;s fundamental flaw: It treats all pages equally regardless of recency. A page loaded at time T=0 and accessed constantly will be evicted before a page loaded at T=1 and never touched again. FIFO has no concept of &quot;usefulness&quot; â€” only &quot;age.&quot;","id":"fifo39s-simplicity-is-appealing-its-correctness-is-easy-to-verify-given-any-reference-string-you-can-trace-through-it-by-hand-and-count-faults-this-is-why-it39s-the-standard-baseline-in-os-textbooks-and-the-one-that-exhibits-bldy39s-anomaly-which-we39ll-demonstrate-shortly-fifo39s-fundamental-flaw-it-treats-all-pages-equally-regardless-of-recency-a-page-loaded-at-time-t0-and-accessed-constantly-will-be-evicted-before-a-page-loaded-at-t1-and-never-touched-again-fifo-has-no-concept-of-quotusefulnessquot-only-quotagequot"},{"level":2,"text":"LRU: Near-Optimal but Impractical to Implement Honestly","id":"lru-near-optimal-but-impractical-to-implement-honestly"},{"level":2,"text":"Why LRU is impractical in hardware: The last_access timestamp requires 64 bits per frame. Updating it on every access means 64 bits Ã— billions of accesses per second = unacceptable memory bandwidth just for bookkeeping. Real hardware gives you one bit. That&#39;s the constraint that makes the Clock algorithm the practical answer.","id":"why-lru-is-impractical-in-hardware-the-last_access-timestamp-requires-64-bits-per-frame-updating-it-on-every-access-means-64-bits-billions-of-accesses-per-second-unacceptable-memory-bandwidth-just-for-bookkeeping-real-hardware-gives-you-one-bit-that39s-the-constraint-that-makes-the-clock-algorithm-the-practical-answer"},{"level":2,"text":"The Clock Algorithm: The Production Workhorse","id":"the-clock-algorithm-the-production-workhorse"},{"level":2,"text":"Why the clock hand persists across calls: If the hand reset to frame 0 after every replacement, it would always evaluate the same frames first. Frames near the start of the array would be evicted disproportionately, and frames at the end would accumulate references without scrutiny. The persistent hand gives every frame equal opportunity to be either protected (by accumulating a reference bit) or evicted (by having its bit swept clear).\nHardware soul â€” Clock vs LRU: Every memory access in Clock requires zero bookkeeping work (the MMU sets ref_bit automatically, for free). The OS&#39;s clock daemon runs periodically â€” not on every access â€” sweeping through frames and clearing bits. This is why Clock is O(1) amortized per eviction: the work is spread across all accesses, not concentrated per-access. LRU with timestamps requires O(1) work per access (timestamp update), which is 3 billion writes/second on a modern CPU. Clock requires O(frames_swept) per eviction, amortized to near zero per access.","id":"why-the-clock-hand-persists-across-calls-if-the-hand-reset-to-frame-0-after-every-replacement-it-would-always-evaluate-the-same-frames-first-frames-near-the-start-of-the-array-would-be-evicted-disproportionately-and-frames-at-the-end-would-accumulate-references-without-scrutiny-the-persistent-hand-gives-every-frame-equal-opportunity-to-be-either-protected-by-accumulating-a-reference-bit-or-evicted-by-having-its-bit-swept-clear-hardware-soul-clock-vs-lru-every-memory-access-in-clock-requires-zero-bookkeeping-work-the-mmu-sets-ref_bit-automatically-for-free-the-os39s-clock-daemon-runs-periodically-not-on-every-access-sweeping-through-frames-and-clearing-bits-this-is-why-clock-is-o1-amortized-per-eviction-the-work-is-spread-across-all-accesses-not-concentrated-per-access-lru-with-timestamps-requires-o1-work-per-access-timestamp-update-which-is-3-billion-writessecond-on-a-modern-cpu-clock-requires-oframes_swept-per-eviction-amortized-to-near-zero-per-access"},{"level":2,"text":"The Working Set Model: Why Thrashing Happens","id":"the-working-set-model-why-thrashing-happens"},{"level":2,"text":"Thrashing detection: track the working set size over time. If ws_size &gt; pm-&gt;num_frames consistently, you&#39;re in a thrashing regime â€” every access faults because the active pages can&#39;t all fit in memory. Real OS kernels detect this via page fault frequency: if a process&#39;s fault rate exceeds a threshold, the kernel may suspend the process (via working set model enforcement) rather than let it thrash and drag down every other process.","id":"thrashing-detection-track-the-working-set-size-over-time-if-ws_size-gt-pm-gtnum_frames-consistently-you39re-in-a-thrashing-regime-every-access-faults-because-the-active-pages-can39t-all-fit-in-memory-real-os-kernels-detect-this-via-page-fault-frequency-if-a-process39s-fault-rate-exceeds-a-threshold-the-kernel-may-suspend-the-process-via-working-set-model-enforcement-rather-than-let-it-thrash-and-drag-down-every-other-process"},{"level":2,"text":"Optimal (BÃ©lÃ¡dy&#39;s Algorithm): The Theoretical Lower Bound","id":"optimal-bldy39s-algorithm-the-theoretical-lower-bound"},{"level":2,"text":"Optimal&#39;s off-by-one discipline: current_idx points to the access currently being handled (the faulting access). The look-ahead begins at current_idx (not current_idx + 1) to correctly identify the very next use of each candidate VPN in the future trace. If you start at current_idx + 1, you may incorrectly believe the currently faulting page has no near future use.","id":"optimal39s-off-by-one-discipline-current_idx-points-to-the-access-currently-being-handled-the-faulting-access-the-look-ahead-begins-at-current_idx-not-current_idx-1-to-correctly-identify-the-very-next-use-of-each-candidate-vpn-in-the-future-trace-if-you-start-at-current_idx-1-you-may-incorrectly-believe-the-currently-faulting-page-has-no-near-future-use"},{"level":2,"text":"The Dispatcher: Wiring All Four Policies Together","id":"the-dispatcher-wiring-all-four-policies-together"},{"level":2,"text":"The Full Simulation Loop with Replacement","id":"the-full-simulation-loop-with-replacement"},{"level":2,"text":"Why reset state between algorithm runs? The comparison is only valid if every algorithm sees the same initial condition â€” empty memory, no swap data, no TLB entries. Otherwise you&#39;re measuring the combined effect of &quot;which algorithm benefited from the previous algorithm&#39;s warm-up&quot; rather than the algorithm&#39;s intrinsic policy behavior. Each run must start cold.","id":"why-reset-state-between-algorithm-runs-the-comparison-is-only-valid-if-every-algorithm-sees-the-same-initial-condition-empty-memory-no-swap-data-no-tlb-entries-otherwise-you39re-measuring-the-combined-effect-of-quotwhich-algorithm-benefited-from-the-previous-algorithm39s-warm-upquot-rather-than-the-algorithm39s-intrinsic-policy-behavior-each-run-must-start-cold"},{"level":2,"text":"BÃ©lÃ¡dy&#39;s Anomaly: When More Memory Makes Things Worse","id":"bldy39s-anomaly-when-more-memory-makes-things-worse"},{"level":2,"text":"Why LRU is immune to BÃ©lÃ¡dy&#39;s anomaly: LRU belongs to a class called stack algorithms. For stack algorithms, the set of pages in memory with k frames is always a subset of the pages in memory with k+1 frames. Adding a frame to a stack algorithm can never evict a page that would have stayed with fewer frames â€” so more frames can only mean fewer or equal faults, never more.\nFIFO is not a stack algorithm. The page evicted with k frames might be a page that would have stayed with k+1 frames. Adding that extra frame displaces the FIFO ordering just enough to evict differently and create more misses.\nOptimal and LRU are both stack algorithms. Clock is an approximation of LRU and generally does not exhibit the anomaly in practice, though it lacks the formal proof.","id":"why-lru-is-immune-to-bldy39s-anomaly-lru-belongs-to-a-class-called-stack-algorithms-for-stack-algorithms-the-set-of-pages-in-memory-with-k-frames-is-always-a-subset-of-the-pages-in-memory-with-k1-frames-adding-a-frame-to-a-stack-algorithm-can-never-evict-a-page-that-would-have-stayed-with-fewer-frames-so-more-frames-can-only-mean-fewer-or-equal-faults-never-more-fifo-is-not-a-stack-algorithm-the-page-evicted-with-k-frames-might-be-a-page-that-would-have-stayed-with-k1-frames-adding-that-extra-frame-displaces-the-fifo-ordering-just-enough-to-evict-differently-and-create-more-misses-optimal-and-lru-are-both-stack-algorithms-clock-is-an-approximation-of-lru-and-generally-does-not-exhibit-the-anomaly-in-practice-though-it-lacks-the-formal-proof"},{"level":2,"text":"Comparative Statistics: All Four Algorithms Side by Side","id":"comparative-statistics-all-four-algorithms-side-by-side"},{"level":2,"text":"Building and Testing","id":"building-and-testing"},{"level":3,"text":"Compile","id":"compile"},{"level":3,"text":"Test 1: FIFO Correctness Against Known Output","id":"test-1-fifo-correctness-against-known-output"},{"level":3,"text":"Test 2: LRU Correctness","id":"test-2-lru-correctness"},{"level":3,"text":"Test 3: Optimal Lower Bound","id":"test-3-optimal-lower-bound"},{"level":3,"text":"Test 4: Dirty Write-Back Correctness","id":"test-4-dirty-write-back-correctness"},{"level":3,"text":"Test 5: BÃ©lÃ¡dy&#39;s Anomaly","id":"test-5-bldy39s-anomaly"},{"level":3,"text":"Test 6: Clock Advances Hand Correctly","id":"test-6-clock-advances-hand-correctly"},{"level":2,"text":"Hardware Soul: What Real Operating Systems Do","id":"hardware-soul-what-real-operating-systems-do"},{"level":2,"text":"Your simulator implements page replacement in pure software with full visibility into all state. Real OS kernels have much harder constraints â€” and their solutions reveal decades of hard-won wisdom.\nLinux&#39;s Two-List Approximation:\nLinux doesn&#39;t use Clock directly. Instead, it maintains two LRU lists per zone (memory region): the active list and the inactive list. Pages enter the inactive list on first access. If a page on the inactive list is accessed again (referenced bit set), it&#39;s promoted to the active list. Pages are evicted only from the inactive list.\nThis is a two-chance policy: a page must be accessed at least twice before it&#39;s immune to immediate eviction. A page accessed exactly once (a &quot;streaming&quot; access that won&#39;t recur) stays on the inactive list and is evicted cheaply. A page accessed repeatedly earns active-list status and is protected.\nThe kernel&#39;s kswapd daemon runs when free memory falls below a threshold, moving pages from active to inactive (after clearing reference bits) and then from inactive to disk. This avoids synchronously evicting pages during page fault handling â€” a latency-critical path. Instead, replacement happens asynchronously, keeping a reserve of pre-freed frames available for fault handlers.\nCache line behavior of your frame descriptors:\nYour frame_desc_t is 16 bytes. Four frame descriptors fit in one 64-byte cache line. When the Clock algorithm scans frames sequentially (the common case during replacement), it accesses frame descriptors in cache-line-aligned chunks â€” efficient sequential access. When the clock hand wraps around, it starts fresh from a cache-cold position. For large frame pools (thousands of frames), the initial sweep is cache-hostile; subsequent sweeps (with cleared reference bits) tend to terminate quickly on recently-cleared frames, keeping the scan length short.\nTLB invalidation across CPUs â€” TLB shootdown:\nIn a multiprocessor system, each CPU has its own TLB. When page X is evicted on CPU 0, CPUs 1, 2, and 3 might have cached translations for page X in their own TLBs. Before the frame can be reused, all other CPUs must invalidate their entry for that VPN. This requires an inter-processor interrupt (IPI) â€” CPU 0 sends an interrupt to all other CPUs, which each execute INVLPG(X) and acknowledge. Only after all CPUs acknowledge can CPU 0 consider the frame free.\nThis &quot;TLB shootdown&quot; is the most expensive operation in the page replacement path on SMP systems. On a 64-core machine evicting one page, you&#39;re waiting for 63 IPIs to round-trip before proceeding. High-performance workloads (databases, HPC) try hard to minimize page eviction frequency precisely to avoid shootdown overhead. Your simulator calls tlb_flush_page() once â€” simulating single-CPU behavior. A multi-CPU extension would need shootdown simulation.","id":"your-simulator-implements-page-replacement-in-pure-software-with-full-visibility-into-all-state-real-os-kernels-have-much-harder-constraints-and-their-solutions-reveal-decades-of-hard-won-wisdom-linux39s-two-list-approximation-linux-doesn39t-use-clock-directly-instead-it-maintains-two-lru-lists-per-zone-memory-region-the-active-list-and-the-inactive-list-pages-enter-the-inactive-list-on-first-access-if-a-page-on-the-inactive-list-is-accessed-again-referenced-bit-set-it39s-promoted-to-the-active-list-pages-are-evicted-only-from-the-inactive-list-this-is-a-two-chance-policy-a-page-must-be-accessed-at-least-twice-before-it39s-immune-to-immediate-eviction-a-page-accessed-exactly-once-a-quotstreamingquot-access-that-won39t-recur-stays-on-the-inactive-list-and-is-evicted-cheaply-a-page-accessed-repeatedly-earns-active-list-status-and-is-protected-the-kernel39s-kswapd-daemon-runs-when-free-memory-falls-below-a-threshold-moving-pages-from-active-to-inactive-after-clearing-reference-bits-and-then-from-inactive-to-disk-this-avoids-synchronously-evicting-pages-during-page-fault-handling-a-latency-critical-path-instead-replacement-happens-asynchronously-keeping-a-reserve-of-pre-freed-frames-available-for-fault-handlers-cache-line-behavior-of-your-frame-descriptors-your-frame_desc_t-is-16-bytes-four-frame-descriptors-fit-in-one-64-byte-cache-line-when-the-clock-algorithm-scans-frames-sequentially-the-common-case-during-replacement-it-accesses-frame-descriptors-in-cache-line-aligned-chunks-efficient-sequential-access-when-the-clock-hand-wraps-around-it-starts-fresh-from-a-cache-cold-position-for-large-frame-pools-thousands-of-frames-the-initial-sweep-is-cache-hostile-subsequent-sweeps-with-cleared-reference-bits-tend-to-terminate-quickly-on-recently-cleared-frames-keeping-the-scan-length-short-tlb-invalidation-across-cpus-tlb-shootdown-in-a-multiprocessor-system-each-cpu-has-its-own-tlb-when-page-x-is-evicted-on-cpu-0-cpus-1-2-and-3-might-have-cached-translations-for-page-x-in-their-own-tlbs-before-the-frame-can-be-reused-all-other-cpus-must-invalidate-their-entry-for-that-vpn-this-requires-an-inter-processor-interrupt-ipi-cpu-0-sends-an-interrupt-to-all-other-cpus-which-each-execute-invlpgx-and-acknowledge-only-after-all-cpus-acknowledge-can-cpu-0-consider-the-frame-free-this-quottlb-shootdownquot-is-the-most-expensive-operation-in-the-page-replacement-path-on-smp-systems-on-a-64-core-machine-evicting-one-page-you39re-waiting-for-63-ipis-to-round-trip-before-proceeding-high-performance-workloads-databases-hpc-try-hard-to-minimize-page-eviction-frequency-precisely-to-avoid-shootdown-overhead-your-simulator-calls-tlb_flush_page-once-simulating-single-cpu-behavior-a-multi-cpu-extension-would-need-shootdown-simulation"},{"level":2,"text":"Knowledge Cascade: Page Replacement Connects Everywhere","id":"knowledge-cascade-page-replacement-connects-everywhere"},{"level":3,"text":"1. Redis and Sampled-LRU: The Same Compromise, Different Scale","id":"1-redis-and-sampled-lru-the-same-compromise-different-scale"},{"level":3,"text":"2. Stack Algorithms and Capacity Planning","id":"2-stack-algorithms-and-capacity-planning"},{"level":3,"text":"3. Thrashing and Admission Control: The Same Problem in Web Services","id":"3-thrashing-and-admission-control-the-same-problem-in-web-services"},{"level":3,"text":"4. Database Buffer Pools: Isomorphic to Page Replacement","id":"4-database-buffer-pools-isomorphic-to-page-replacement"},{"level":3,"text":"5. Prefetching and Access Pattern Awareness","id":"5-prefetching-and-access-pattern-awareness"},{"level":2,"text":"Your working set tracker measures the current working set size. More sophisticated systems also use access patterns to predict the next working set. Disk-aware page replacement â€” implemented in database systems, not typically in OS kernels â€” examines access patterns to prefetch pages that are likely to be needed soon.\nSequential scan detection: if the simulator noticed that accesses follow a sequential VPN pattern (VPN N, N+1, N+2, ...), it could prefetch VPN N+k before it&#39;s needed, hiding the fault latency. Linux&#39;s mmap() with MAP_POPULATE does this at mapping time. PostgreSQL&#39;s sequential scan detection switches the buffer replacement policy for sequential scans to prevent them from displacing hot random-access data.\nYour Optimal algorithm is the perfect prefetcher: it knows exactly which pages to load before they&#39;re needed (because it has the future trace). The gap between Optimal and Clock in your statistics represents the maximum possible gain from perfect prefetching â€” the &quot;oracle gap.&quot; Real prefetchers close some fraction of this gap using heuristic access pattern detection.","id":"your-working-set-tracker-measures-the-current-working-set-size-more-sophisticated-systems-also-use-access-patterns-to-predict-the-next-working-set-disk-aware-page-replacement-implemented-in-database-systems-not-typically-in-os-kernels-examines-access-patterns-to-prefetch-pages-that-are-likely-to-be-needed-soon-sequential-scan-detection-if-the-simulator-noticed-that-accesses-follow-a-sequential-vpn-pattern-vpn-n-n1-n2-it-could-prefetch-vpn-nk-before-it39s-needed-hiding-the-fault-latency-linux39s-mmap-with-map_populate-does-this-at-mapping-time-postgresql39s-sequential-scan-detection-switches-the-buffer-replacement-policy-for-sequential-scans-to-prevent-them-from-displacing-hot-random-access-data-your-optimal-algorithm-is-the-perfect-prefetcher-it-knows-exactly-which-pages-to-load-before-they39re-needed-because-it-has-the-future-trace-the-gap-between-optimal-and-clock-in-your-statistics-represents-the-maximum-possible-gain-from-perfect-prefetching-the-quotoracle-gapquot-real-prefetchers-close-some-fraction-of-this-gap-using-heuristic-access-pattern-detection"},{"level":2,"text":"What You&#39;ve Built: The Complete Virtual Memory Simulator","id":"what-you39ve-built-the-complete-virtual-memory-simulator"},{"level":2,"text":"System Overview","id":"system-overview"},{"level":1,"text":"TDD","id":"tdd"},{"level":1,"text":"Technical Design Specification: Single-Level Page Table and Address Translation (m1)","id":"technical-design-specification-single-level-page-table-and-address-translation-m1"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1. Bit-Level Page Table Entry (pte_t)","id":"31-bit-level-page-table-entry-pte_t"},{"level":3,"text":"3.2. Physical Frame (physical_frame_t)","id":"32-physical-frame-physical_frame_t"},{"level":3,"text":"3.3. Page Table (page_table_t)","id":"33-page-table-page_table_t"},{"level":3,"text":"3.4. Simulator Context (simulator_t)","id":"34-simulator-context-simulator_t"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1. Address Decomposition","id":"41-address-decomposition"},{"level":3,"text":"4.2. Core Translation","id":"42-core-translation"},{"level":3,"text":"4.3. Trace Parsing","id":"43-trace-parsing"},{"level":2,"text":"5. Algorithm Specification: translate()","id":"5-algorithm-specification-translate"},{"level":2,"text":"6. Algorithm Specification: handle_page_fault()","id":"6-algorithm-specification-handle_page_fault"},{"level":2,"text":"7. Error Handling Matrix","id":"7-error-handling-matrix"},{"level":2,"text":"8. Implementation Sequence with Checkpoints","id":"8-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Bit Math &amp; Structs (1.5 Hours)","id":"phase-1-bit-math-amp-structs-15-hours"},{"level":3,"text":"Phase 2: Trace Parser (1 Hour)","id":"phase-2-trace-parser-1-hour"},{"level":3,"text":"Phase 3: The MMU Core (2 Hours)","id":"phase-3-the-mmu-core-2-hours"},{"level":3,"text":"Phase 4: Protection Logic (1 Hour)","id":"phase-4-protection-logic-1-hour"},{"level":2,"text":"9. Test Specification","id":"9-test-specification"},{"level":3,"text":"9.1. Unit Test: Address Decomposition","id":"91-unit-test-address-decomposition"},{"level":3,"text":"9.2. Integration Test: Demand Paging","id":"92-integration-test-demand-paging"},{"level":3,"text":"9.3. Edge Case: OOM Limit","id":"93-edge-case-oom-limit"},{"level":2,"text":"10. Performance Targets","id":"10-performance-targets"},{"level":2,"text":"11. Hardware Soul - Cache Line Impact","id":"11-hardware-soul-cache-line-impact"},{"level":1,"text":"Technical Design Specification: TLB (Translation Lookaside Buffer) (m2)","id":"technical-design-specification-tlb-translation-lookaside-buffer-m2"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1. TLB Entry Layout (tlb_entry_t)","id":"31-tlb-entry-layout-tlb_entry_t"},{"level":3,"text":"3.2. TLB Context (tlb_t)","id":"32-tlb-context-tlb_t"},{"level":3,"text":"3.3. Cache Line Analysis (MANDATORY)","id":"33-cache-line-analysis-mandatory"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1. TLB Operations","id":"41-tlb-operations"},{"level":3,"text":"4.2. Flush &amp; Maintenance","id":"42-flush-amp-maintenance"},{"level":3,"text":"4.3. Context Switching","id":"43-context-switching"},{"level":2,"text":"5. Algorithm Specification","id":"5-algorithm-specification"},{"level":3,"text":"5.1. tlb_lookup (The Hot Path)","id":"51-tlb_lookup-the-hot-path"},{"level":3,"text":"5.2. tlb_insert with Coherence Write-back","id":"52-tlb_insert-with-coherence-write-back"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Foundation (1 Hour)","id":"phase-1-foundation-1-hour"},{"level":3,"text":"Phase 2: Lookup &amp; LRU (2 Hours)","id":"phase-2-lookup-amp-lru-2-hours"},{"level":3,"text":"Phase 3: Insertion &amp; Eviction (2 Hours)","id":"phase-3-insertion-amp-eviction-2-hours"},{"level":3,"text":"Phase 4: Integration (1.5 Hours)","id":"phase-4-integration-15-hours"},{"level":3,"text":"Phase 5: ASID &amp; Context Switching (1 Hour)","id":"phase-5-asid-amp-context-switching-1-hour"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1. Unit Test: ASID Isolation","id":"81-unit-test-asid-isolation"},{"level":3,"text":"8.2. Unit Test: LRU Eviction Order","id":"82-unit-test-lru-eviction-order"},{"level":3,"text":"8.3. Integration Test: Dirty Write-back","id":"83-integration-test-dirty-write-back"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Hardware Soul - CAM vs Linear Scan","id":"10-hardware-soul-cam-vs-linear-scan"},{"level":1,"text":"Technical Design Specification: Multi-Level Page Tables (m3)","id":"technical-design-specification-multi-level-page-tables-m3"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1. Page Directory Entry (pde_t)","id":"31-page-directory-entry-pde_t"},{"level":3,"text":"3.2. Hierarchical Structures","id":"32-hierarchical-structures"},{"level":3,"text":"3.3. Process Abstraction (process_t)","id":"33-process-abstraction-process_t"},{"level":3,"text":"3.4. Byte-Level Layout &amp; Cache Line Analysis","id":"34-byte-level-layout-amp-cache-line-analysis"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1. Address Decomposition","id":"41-address-decomposition"},{"level":3,"text":"4.2. Process Lifecycle","id":"42-process-lifecycle"},{"level":3,"text":"4.3. Hierarchical Translation","id":"43-hierarchical-translation"},{"level":2,"text":"5. Algorithm Specification","id":"5-algorithm-specification"},{"level":3,"text":"5.1. The Hierarchical Walk (ml_translate)","id":"51-the-hierarchical-walk-ml_translate"},{"level":3,"text":"5.2. Context Switch with CR3 Update","id":"52-context-switch-with-cr3-update"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Bitfields &amp; Indices (0.5 Hours)","id":"phase-1-bitfields-amp-indices-05-hours"},{"level":3,"text":"Phase 2: On-Demand Logic (1.5 Hours)","id":"phase-2-on-demand-logic-15-hours"},{"level":3,"text":"Phase 3: TLB Integration (1 Hour)","id":"phase-3-tlb-integration-1-hour"},{"level":3,"text":"Phase 4: Overhead Reporting (1 Hour)","id":"phase-4-overhead-reporting-1-hour"},{"level":3,"text":"Phase 5: Stretch - 3-Level Table (2 Hours)","id":"phase-5-stretch-3-level-table-2-hours"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1. Unit Test: PDE/PTE Distinction","id":"81-unit-test-pdepte-distinction"},{"level":3,"text":"8.2. Integration Test: Address Space Isolation","id":"82-integration-test-address-space-isolation"},{"level":3,"text":"8.3. Boundary Test: Max Address","id":"83-boundary-test-max-address"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Hardware Soul - The Multi-Level Penalty","id":"10-hardware-soul-the-multi-level-penalty"},{"level":1,"text":"Technical Design Specification: Page Replacement and Swap Simulation (m4)","id":"technical-design-specification-page-replacement-and-swap-simulation-m4"},{"level":2,"text":"1. Module Charter","id":"1-module-charter"},{"level":2,"text":"2. File Structure","id":"2-file-structure"},{"level":2,"text":"3. Complete Data Model","id":"3-complete-data-model"},{"level":3,"text":"3.1. Frame Descriptor (frame_desc_t)","id":"31-frame-descriptor-frame_desc_t"},{"level":3,"text":"3.2. Physical Memory Pool (phys_mem_t)","id":"32-physical-memory-pool-phys_mem_t"},{"level":3,"text":"3.3. Swap Space (swap_space_t)","id":"33-swap-space-swap_space_t"},{"level":3,"text":"3.4. Working Set Tracker","id":"34-working-set-tracker"},{"level":2,"text":"4. Interface Contracts","id":"4-interface-contracts"},{"level":3,"text":"4.1. The Replacement Dispatcher","id":"41-the-replacement-dispatcher"},{"level":3,"text":"4.2. Swap I/O","id":"42-swap-io"},{"level":2,"text":"5. Algorithm Specifications","id":"5-algorithm-specifications"},{"level":3,"text":"5.1. The Eviction Core Sequence (Critical Path)","id":"51-the-eviction-core-sequence-critical-path"},{"level":3,"text":"5.2. Clock (Second-Chance) Logic","id":"52-clock-second-chance-logic"},{"level":3,"text":"5.3. Optimal (BÃ©lÃ¡dyâ€™s Algorithm)","id":"53-optimal-bldys-algorithm"},{"level":2,"text":"6. Error Handling Matrix","id":"6-error-handling-matrix"},{"level":2,"text":"7. Implementation Sequence with Checkpoints","id":"7-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Frame Descriptors (1 Hour)","id":"phase-1-frame-descriptors-1-hour"},{"level":3,"text":"Phase 2: Swap Subsystem (2 Hours)","id":"phase-2-swap-subsystem-2-hours"},{"level":3,"text":"Phase 3: Selection Algorithms (3 Hours)","id":"phase-3-selection-algorithms-3-hours"},{"level":3,"text":"Phase 4: The Eviction Sequencer (2 Hours)","id":"phase-4-the-eviction-sequencer-2-hours"},{"level":3,"text":"Phase 5: Statistics &amp; Anomaly (2 Hours)","id":"phase-5-statistics-amp-anomaly-2-hours"},{"level":2,"text":"8. Test Specification","id":"8-test-specification"},{"level":3,"text":"8.1. BÃ©lÃ¡dyâ€™s Anomaly Test","id":"81-bldys-anomaly-test"},{"level":3,"text":"8.2. Dirty Bit Persistence Test","id":"82-dirty-bit-persistence-test"},{"level":3,"text":"8.3. Optimal Benchmark Test","id":"83-optimal-benchmark-test"},{"level":2,"text":"9. Performance Targets","id":"9-performance-targets"},{"level":2,"text":"10. Hardware Soul - Cache and Pipeline Constraints","id":"10-hardware-soul-cache-and-pipeline-constraints"},{"level":3,"text":"10.1. Temporal Locality and LRU","id":"101-temporal-locality-and-lru"},{"level":3,"text":"10.2. TLB Coherence (The Shootdown)","id":"102-tlb-coherence-the-shootdown"},{"level":1,"text":"Project Structure: Virtual Memory Simulator","id":"project-structure-virtual-memory-simulator"},{"level":2,"text":"Directory Tree","id":"directory-tree"},{"level":2,"text":"Creation Order","id":"creation-order"},{"level":2,"text":"File Count Summary","id":"file-count-summary"},{"level":1,"text":"ğŸ“š Beyond the Atlas: Further Reading","id":"-beyond-the-atlas-further-reading"},{"level":2,"text":"ğŸŒ Foundations of Virtual Memory","id":"-foundations-of-virtual-memory"},{"level":3,"text":"1. One-Level Storage System","id":"1-one-level-storage-system"},{"level":3,"text":"2. Intel 64 and IA-32 Architectures Software Developerâ€™s Manual","id":"2-intel-64-and-ia-32-architectures-software-developers-manual"},{"level":2,"text":"âš¡ TLB &amp; Context Switching","id":"-tlb-amp-context-switching"},{"level":3,"text":"3. Meltdown: Reading Kernel Memory from User Space","id":"3-meltdown-reading-kernel-memory-from-user-space"},{"level":3,"text":"4. Analysis of TLB Performance","id":"4-analysis-of-tlb-performance"},{"level":2,"text":"ğŸŒ³ Hierarchical Structures &amp; Sparsity","id":"-hierarchical-structures-amp-sparsity"},{"level":3,"text":"5. Multi-Level Page Tables","id":"5-multi-level-page-tables"},{"level":3,"text":"6. The Design and Implementation of a Log-Structured File System","id":"6-the-design-and-implementation-of-a-log-structured-file-system"},{"level":2,"text":"ğŸ”„ Page Replacement &amp; Swap Theory","id":"-page-replacement-amp-swap-theory"},{"level":3,"text":"7. A Study of Replacement Algorithms for a Virtual-Storage Computer","id":"7-a-study-of-replacement-algorithms-for-a-virtual-storage-computer"},{"level":3,"text":"8. Evaluation of Page Replacement Algorithms","id":"8-evaluation-of-page-replacement-algorithms"},{"level":3,"text":"9. Linux Kernel: The Page Frame Reclaim Algorithm (PFRA)","id":"9-linux-kernel-the-page-frame-reclaim-algorithm-pfra"},{"level":2,"text":"ğŸ› ï¸ Tooling &amp; Real-World Application","id":"-tooling-amp-real-world-application"},{"level":3,"text":"10. Valgrind: A Framework for Heavyweight Dynamic Binary Instrumentation","id":"10-valgrind-a-framework-for-heavyweight-dynamic-binary-instrumentation"}],"title":"ğŸ¯ Project Charter: Virtual Memory Simulator","markdown":"# ğŸ¯ Project Charter: Virtual Memory Simulator\n\n## What You Are Building\nA software-based Memory Management Unit (MMU) simulator that emulates the hardware-software contract of modern memory management. You are building a system that decomposes 32-bit virtual addresses, performs hierarchical page table walks starting from a simulated CR3 register, caches translations in an ASID-tagged TLB, and manages a finite physical frame pool by evicting pages to a simulated swap store. By the end, you will have a tool that processes memory access traces and generates detailed performance profiles for different page replacement heuristics.\n\n## Why This Project Exists\nVirtual memory is the \"magic\" that allows a 10GB process to run on 8GB of RAM while remaining isolated from other programs. Most developers treat this as a black box provided by the OS, but building a simulator from scratch exposes the exact bit-level mechanicsâ€”such as why the \"dirty bit\" is critical for disk I/O efficiency and why hierarchical tables are the only way to manage sparse address spaces without wasting gigabytes of metadata.\n\n## What You Will Be Able to Do When Done\n- **Decompose Addresses:** Use bitwise shifts and masks to extract VPNs, Page Directory Indices, and offsets for 10-10-12 bit splits.\n- **Implement Caching:** Build a fully-associative TLB with LRU/Random eviction and Address Space ID (ASID) support for fast context switching.\n- **Walk Hierarchical Tables:** Implement a radix-trie-based page table walk that allocates second-level tables on demand.\n- **Manage Scarcity:** Build an eviction engine that handles the full coherence lifecycle: Dirty Write-back -> TLB Invalidation -> PTE Clear -> Frame Reclamation.\n- **Perform Comparative Analysis:** Mathematically prove BÃ©lÃ¡dyâ€™s Anomaly using FIFO and compare it against LRU and Optimal (future-knowledge) algorithms.\n\n## Final Deliverable\nA command-line simulator (implemented in C, Rust, or Python) consisting of ~1,500â€“2,500 lines of code. It accepts a memory access trace file (e.g., `R 0x4B00`) and a configuration (frame count, TLB size). It outputs a physical address for every access and a final report including TLB hit rates, page fault counts, dirty page write-back counts, and peak working set size.\n\n## Is This Project For You?\n**You should start this if you:**\n- Are comfortable with bitwise operations (AND, OR, XOR, SHL, SHR).\n- Understand pointers and multi-level indirection (pointers-to-pointers).\n- Can implement basic data structures like linked lists or circular buffers.\n- Want to understand how OS kernels and CPU hardware interact at the boundary.\n\n**Come back after you've learned:**\n- [Binary and Hexadecimal Arithmetic](https://www.khanacademy.org/math/algebra-home/alg-intro-to-algebra/algebra-alternate-number-bases/v/number-bases)\n- [Basic C Memory Management/Structs](https://en.cppreference.com/w/c/language/struct)\n\n## Estimated Effort\n| Phase | Time |\n|-------|------|\n| Single-Level Page Table & Translation | ~5 hours |\n| TLB with ASID & LRU Eviction | ~7 hours |\n| Multi-Level Page Tables & CR3 Simulation | ~8 hours |\n| Page Replacement (FIFO, LRU, Clock, Optimal) & Swap | ~12 hours |\n| **Total** | **~32 hours** |\n\n## Definition of Done\nThe project is complete when:\n- The simulator correctly translates 32-bit addresses using a two-level hierarchy without memory leaks.\n- TLB hits are verified to skip the page table walk and correctly differentiate between ASIDs.\n- Reaching the physical frame limit (e.g., 64 frames) triggers a replacement algorithm instead of an OOM error.\n- Dirty pages are successfully written to simulated swap and reloaded with data integrity on subsequent faults.\n- The simulator can run the same trace through all four replacement policies and output a comparative performance table.\n\n---\n\n# Virtual Memory Simulator\n\nThis project builds a complete virtual memory simulator from the ground up: starting with flat page tables and address translation, layering on TLB caching with ASID support, evolving to multi-level hierarchical page tables with a simulated CR3 register, and culminating in page replacement algorithms (FIFO, LRU, Clock, Optimal) backed by simulated swap space. The simulator processes memory access trace files, enabling reproducible experiments and comparative analysis of different policies.\n\nBy building each layer yourself, you internalize the hardwareâ€“software contract that every modern OS relies on: how a 64-bit virtual address becomes a physical frame lookup through multiple levels of indirection, why TLBs are the single most performance-critical cache in any CPU, and why page replacement policy choice can mean the difference between smooth execution and catastrophic thrashing. Every struct you define mirrors real hardware registers and table entries â€” the PTE flags, the CR3 register, the TLB tags â€” giving you a mental model that transfers directly to reading Linux kernel source or debugging production memory pressure issues.\n\nThe simulator is driven by trace files (e.g., 'R 0x1A3F', 'W 0x4B00'), making it easy to construct adversarial access patterns that expose BÃ©lÃ¡dy's anomaly, demonstrate working set dynamics, and measure the true cost of dirty page write-backs. Statistics collection at every layer (TLB hits, page faults, protection faults, swap I/O) turns abstract OS textbook concepts into measurable, comparable numbers.\n\n\n\n<!-- MS_ID: virtual-memory-sim-m1 -->\n# Milestone 1: Single-Level Page Table and Address Translation\n## The Problem You're Actually Solving\nBefore you write a single line of code, you need to feel the problem physically.\nYour CPU executes instructions that reference memory addresses. A program running on your machine will freely use address `0x00401000`, another program will also use `0x00401000`, and both programs are running *simultaneously*. Yet they cannot be reading from or writing to the same physical memory â€” that would be catastrophic. How does the hardware and OS ensure that these two programs' identical addresses refer to completely different physical locations?\nThe answer is **virtual memory**: every process lives in its own private address space, and a mapping layer translates those private (virtual) addresses into actual (physical) memory locations before any real hardware access occurs.\n\n> **ğŸ”‘ Foundation: Virtual vs Physical addresses**\n> \n> **1. What it IS**\nA **physical address** is the actual hardware location in your RAM sticks (e.g., \"Row 402, Column 12\"). A **virtual address** is an alias or \"fake\" address used by a program. When a program asks to read memory at address `0x1234`, it is using a virtual address. The hardware's Memory Management Unit (MMU) uses a lookup table to translate that virtual `0x1234` into a real physical address like `0x88AF`.\n\n**2. Why you need it right now**\nWithout this distinction, every program would have to manage its own physical RAM. If two programs tried to use physical address `0x500`, they would crash into each other. Virtual addressing allows the OS to give every process the illusion that it has its own private, continuous block of memory starting from zero, regardless of where that data actually sits in the physical hardware.\n\n**3. Key Insight**\n**The \"Coordinate System\" Model:** Think of a virtual address like a \"Seat Number\" on a concert ticket (e.g., Row A, Seat 1). The physical address is the GPS coordinate of that actual chair. The ticket stays the same for the guest, but the venue staff (the OS) can move the actual chairs around between shows without the guest ever knowing.\n\nThat translation layer is the **page table**. In this milestone, you'll build the simplest possible version â€” a flat, single-level array â€” and in doing so you'll internalize the insight that makes all virtual memory systems work: **you don't translate bytes, you translate pages**.\n\n![Virtual Memory Simulator â€” Satellite System Map](./diagrams/diag-satellite-map.svg)\n\n---\n## The Revelation: You Don't Look Up Addresses â€” You Decompose Them\nHere's the misconception most programmers carry when they first encounter page tables: they picture a lookup table like a dictionary. Virtual address goes in. Physical address comes out. The table has one entry per byte (or word) of memory.\nThat model is wrong, and the wrongness matters for everything you're about to build.\nConsider a 32-bit address space: 2Â³Â² = 4,294,967,296 possible byte addresses. If you stored one entry per byte, even a single process would need 4 billion table entries. With 8 bytes per entry, that's 32 GB of page table â€” *just for the mapping structure* â€” before you've stored a single byte of actual program data. This is obviously impossible.\nThe actual insight is this: **memory is organized into fixed-size chunks called pages** (typically 4KB = 4096 bytes), and translation only applies at page granularity. The bottom 12 bits of any address â€” the *offset within the page* â€” are the same in both the virtual and physical worlds. They pass through the translation unchanged.\n[[EXPLAIN:page-size-and-address-decomposition-(vpn-+-offset-via-bit-shifting)|Page size and address decomposition â€” how VPN and offset are extracted via bit shifting, and why the math works]]\nLet's make this concrete. Suppose your virtual address is `0x001A3F7C`:\n```\nBinary:  0000 0000 0001 1010 0011 1111 0111 1100\n                   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n                        VPN = 0x1A3F    offset = 0x07C (20 bits VPN, 12 bits offset)\n```\nWait â€” those bit widths depend on your configuration. With 4KB pages:\n- Page size = 4096 = 2Â¹Â²\n- Offset field = 12 bits (bottom 12 bits)\n- VPN field = remaining upper bits\nFor a 32-bit address: VPN = bits [31:12], offset = bits [11:0].\nThe page table stores exactly one entry *per page*, not per byte. A 32-bit address space with 4KB pages has 2Â³Â²/2Â¹Â² = 2Â²â° = 1,048,576 possible pages. Your page table needs at most ~1 million entries. At, say, 4 bytes per entry, that's 4 MB â€” manageable for a single process.\nTranslation is now an *array index*, not a search:\n```\nphysical_address = page_table[VPN].frame_number << 12 | offset\n```\nThis is why hardware can perform translation in a single clock cycle (given the right caching, which you'll build in Milestone 2). It's not scanning anything â€” it's computing an array index from the address bits, and reading from that array slot.\n\n![Virtual Address Decomposition: VPN + Offset](./diagrams/diag-m1-address-decomposition.svg)\n\n---\n## The Page Table Entry: Every Bit Earns Its Place\nA Page Table Entry (PTE) is the fundamental data structure of virtual memory. It's not just a \"physical frame number.\" It carries metadata that the OS and hardware use to enforce protection, track usage, manage eviction, and detect faults. Every bit has a specific job.\n\n> **ğŸ”‘ Foundation: What a Page Table Entry contains and why each flag exists**\n> \n> **1. What it IS**\nA Page Table Entry (PTE) is a single record in the OS's \"translation dictionary.\" It doesn't just store the mapping from virtual to physical; it stores metadata flags that tell the CPU what is allowed:\n*   **Valid/Present Bit:** Is this page actually in RAM right now? If 0, accessing it triggers a page fault.\n*   **Permission Bits (R/W/X):** Can the program Read, Write, or Execute code on this page? This prevents a program from accidentally overwriting its own code.\n*   **Dirty Bit:** Has the program written to this page since it was loaded? If \"dirty,\" the OS must save it to disk before reusing the RAM for something else.\n*   **Referenced/Accessed Bit:** Has this page been touched recently? The OS uses this to decide which pages are \"old\" and safe to swap out when RAM gets full.\n\n**2. Why you need it right now**\nWhen you are implementing memory management or debugging \"Segmentation Faults,\" you are interacting with these flags. A \"Segfault\" is often just the MMU seeing a PTE where the \"Valid\" bit is 1, but the \"Write\" bit is 0, while the program is trying to perform a write.\n\n**3. Key Insight**\n**The \"Passport Control\" Model:** A PTE isn't just a map; itâ€™s a security checkpoint. The CPU doesn't just ask \"Where is this data?\"; it asks \"Am I allowed to be here, and should I tell the OS I moved the furniture (Dirty bit)?\"\n\nHere's the PTE structure you'll implement:\n```c\n/*\n * Page Table Entry (PTE) â€” 32-bit layout\n *\n * Byte offsets:\n *   [31:12] â€” Physical Frame Number (PFN): 20 bits (for 4KB pages, 32-bit phys addr)\n *   [11:8]  â€” Reserved / future use: 4 bits\n *   [7]     â€” Referenced bit (R): set on any access (read or write)\n *   [6]     â€” Dirty bit (D): set only on write access\n *   [5]     â€” Read permission (R_PERM): page may be read\n *   [4]     â€” Write permission (W_PERM): page may be written\n *   [3:1]   â€” Reserved: 3 bits\n *   [0]     â€” Valid bit (V): 1 = page is in physical memory\n *\n * Total size: 4 bytes per PTE\n * Cache line holds: 64 / 4 = 16 PTEs\n */\ntypedef struct {\n    uint32_t pfn        : 20;  /* Physical Frame Number */\n    uint32_t _reserved2 :  4;\n    uint32_t referenced :  1;  /* Set on any access */\n    uint32_t dirty      :  1;  /* Set on write access only */\n    uint32_t perm_read  :  1;  /* Read permission */\n    uint32_t perm_write :  1;  /* Write permission */\n    uint32_t _reserved1 :  3;\n    uint32_t valid      :  1;  /* Is this page in physical memory? */\n} pte_t;\n```\n> **Hardware Soul â€” Cache Line Analysis:**\n> A `pte_t` is 4 bytes. A CPU cache line is 64 bytes. Walking through 16 consecutive PTEs (16 Ã— 4 = 64 bytes) fits in a single cache line fetch. This is deliberate: when you access page N and then page N+1, both their PTEs likely live in the same cache line, making sequential access patterns warm in L1 cache. When you scatter accesses randomly across the address space â€” different VPNs far apart â€” you thrash the cache with cold PTE fetches. **Page locality in the virtual address space directly translates to cache locality in the page table array.** This is a fundamental law you'll observe in your simulator's statistics.\n\n![Page Table Entry (PTE) Structure â€” Byte-Level Layout](./diagrams/diag-m1-pte-struct-layout.svg)\n\n### Alternative: Using a Plain `uint32_t` with Masks\nC bitfields are convenient but have implementation-defined behavior (bit ordering across compilers). For clarity and portability, many OS implementations prefer explicit masks:\n```c\n/* Alternative: plain uint32_t with explicit bit masks */\ntypedef uint32_t pte_t;\n#define PTE_VALID       (1u << 0)\n#define PTE_PERM_WRITE  (1u << 4)\n#define PTE_PERM_READ   (1u << 5)\n#define PTE_DIRTY       (1u << 6)\n#define PTE_REFERENCED  (1u << 7)\n#define PTE_PFN_SHIFT   12\n#define PTE_PFN_MASK    (0xFFFFF000u)  /* bits [31:12] */\n/* Extract PFN from a PTE */\nstatic inline uint32_t pte_get_pfn(pte_t pte) {\n    return (pte & PTE_PFN_MASK) >> PTE_PFN_SHIFT;\n}\n/* Build a PTE from a PFN and permission flags */\nstatic inline pte_t pte_make(uint32_t pfn, int readable, int writable) {\n    pte_t p = (pfn << PTE_PFN_SHIFT);\n    if (readable)  p |= PTE_PERM_READ;\n    if (writable)  p |= PTE_PERM_WRITE;\n    p |= PTE_VALID;\n    return p;\n}\n```\n**Design choice for your simulator:** The bitfield struct is more readable for learning purposes. Use it unless you run into compiler issues, in which case switch to the mask approach. Real kernels like Linux use macro-based masks (`_PAGE_PRESENT`, `_PAGE_DIRTY`, `_PAGE_ACCESSED`, etc.) defined in `arch/x86/include/asm/pgtable.h`.\n---\n## The Full Simulator Data Model\nBefore implementing any behavior, define the complete in-memory state of your simulator. This is architectural decision-making â€” get the structure right and everything else follows.\n```c\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n * Configuration â€” adjustable at compile time\n *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n#define PAGE_SIZE           4096u       /* bytes â€” must be power of 2        */\n#define PAGE_OFFSET_BITS    12u         /* log2(PAGE_SIZE) = 12              */\n#define PAGE_OFFSET_MASK    (PAGE_SIZE - 1)  /* 0x00000FFF                  */\n#define NUM_FRAMES          64u         /* physical frames in simulated RAM  */\n#define ADDR_BITS           32u         /* simulated virtual address width   */\n#define VPN_BITS            (ADDR_BITS - PAGE_OFFSET_BITS)  /* 20 bits       */\n#define PAGE_TABLE_SIZE     (1u << VPN_BITS)  /* 2^20 = 1,048,576 entries   */\n/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n * Physical memory simulation\n *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\ntypedef struct {\n    uint8_t  data[PAGE_SIZE];   /* simulated page content (all zeros on alloc) */\n    bool     in_use;            /* is this frame currently allocated?          */\n} physical_frame_t;\n/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n * Page table â€” flat array of NUM_FRAMES PTEs\n * Memory cost: 1,048,576 Ã— 4 bytes = 4 MB per process\n *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\ntypedef struct {\n    pte_t   entries[PAGE_TABLE_SIZE];   /* indexed directly by VPN           */\n} page_table_t;\n/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n * Simulator state\n *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\ntypedef struct {\n    page_table_t    page_table;\n    physical_frame_t frames[NUM_FRAMES];\n    /* Statistics */\n    uint64_t    total_accesses;\n    uint64_t    page_faults;\n    uint64_t    protection_faults;\n    /* Configuration */\n    uint32_t    page_size;\n    uint32_t    offset_bits;\n    uint32_t    num_frames;\n} simulator_t;\n```\n**Memory layout analysis:**\n- `page_table.entries`: 1,048,576 Ã— 4 bytes = **4,194,304 bytes = 4 MB**\n- `frames[64]`: 64 Ã— 4096 bytes = **262,144 bytes = 256 KB**\n- Total simulator state: ~4.25 MB\nThis 4 MB flat page table is the key motivator for Milestone 3. For a *sparse* address space â€” a real process that uses only a few hundred MB out of the possible 4 GB â€” most of those 1M entries are unused, yet you've paid for all of them upfront. Multi-level page tables fix this by only allocating the sub-tables you actually use.\n---\n## Address Decomposition: The Two Extractors\nImplement two inline functions that you'll call everywhere:\n```c\n/*\n * Extract the Virtual Page Number from a 32-bit virtual address.\n * VPN = upper (32 - 12) = 20 bits.\n *\n * Example: addr = 0x001A3F7C\n *   0x001A3F7C >> 12 = 0x001A3   = 6723 (decimal)\n */\nstatic inline uint32_t vpn_from_addr(uint32_t vaddr) {\n    return vaddr >> PAGE_OFFSET_BITS;\n}\n/*\n * Extract the page offset from a 32-bit virtual address.\n * Offset = lower 12 bits = unchanged in physical address.\n *\n * Example: addr = 0x001A3F7C\n *   0x001A3F7C & 0x00000FFF = 0x7C = 124 (decimal)\n */\nstatic inline uint32_t offset_from_addr(uint32_t vaddr) {\n    return vaddr & PAGE_OFFSET_MASK;\n}\n/*\n * Reconstruct a physical address from a PFN and offset.\n * Physical address = PFN * PAGE_SIZE + offset\n *                  = (PFN << 12) | offset\n */\nstatic inline uint32_t make_physical_addr(uint32_t pfn, uint32_t offset) {\n    return (pfn << PAGE_OFFSET_BITS) | offset;\n}\n```\nLet's verify these functions are correct by tracing through manually:\n```\nVirtual address:  0x001A3F7C\nBinary:           0000 0000 0001 1010 0011 1111 0111 1100\n                  â†‘â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†‘ â†‘â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†‘\n                              bits [31:12]                bits [11:0]\nVPN  = 0x001A3F7C >> 12  = 0x001A3   = 6723\nOffset = 0x001A3F7C & 0xFFF = 0x7C   = 124\nIf page table says VPN 6723 â†’ PFN 42:\nPhysical address = (42 << 12) | 0x7C\n                 = 0x0002A000 | 0x7C\n                 = 0x0002A07C\n```\n**Pitfall: Off-by-one in shift amount.** PAGE_SIZE = 4096 = 2Â¹Â². To extract the VPN, you shift right by 12. A common mistake is shifting by 11 (thinking \"4096 has 12 digits in binary, so shift by 11\"). Check: `1 << 12 = 4096`. Shift by 12, not 11.\n\n![Flat Page Table Lookup â€” Data Walk](./diagrams/diag-m1-flat-page-table-lookup.svg)\n\n---\n## The Trace File: Your Simulator's Input\nThe simulator is driven by a **memory access trace** â€” a text file describing a sequence of memory operations. This indirection is the entire reason the simulator is useful: you can craft specific access patterns, replay real program traces, and run the same sequence through multiple algorithms (in later milestones) for direct comparison.\n### Trace Format\n```\n# Lines starting with '#' are comments â€” ignore them\n# Format: <operation> <hex-address>\n# Operation: R = read, W = write\nR 0x001A3F7C\nW 0x004B0020\nR 0x001A4000\nW 0x001A3F7C\nR 0x00FF1234\n```\nRules:\n- One access per line\n- `R` = read access, `W` = write access\n- Address is a 32-bit hex value with `0x` prefix\n- Empty lines and comment lines (starting with `#`) are skipped\n\n![Trace File Format and Simulator Pipeline](./diagrams/diag-m1-trace-format-and-flow.svg)\n\n### Trace Parser\n```c\n/*\n * Memory access record â€” parsed from one trace file line\n */\ntypedef enum { ACCESS_READ = 0, ACCESS_WRITE = 1 } access_type_t;\ntypedef struct {\n    access_type_t   type;\n    uint32_t        vaddr;\n} mem_access_t;\n/*\n * Parse a single line from the trace file.\n * Returns true if parsing succeeded, false if line should be skipped\n * (comment, empty, or malformed).\n *\n * Line format: \"R 0x001A3F7C\\n\" or \"W 0x004B0020\\n\"\n */\nbool parse_trace_line(const char *line, mem_access_t *out) {\n    /* Skip whitespace-only and comment lines */\n    const char *p = line;\n    while (*p == ' ' || *p == '\\t') p++;\n    if (*p == '\\0' || *p == '\\n' || *p == '#') return false;\n    char op;\n    unsigned long addr;\n    if (sscanf(p, \" %c %lx\", &op, &addr) != 2) return false;\n    if      (op == 'R' || op == 'r') out->type = ACCESS_READ;\n    else if (op == 'W' || op == 'w') out->type = ACCESS_WRITE;\n    else return false;\n    out->vaddr = (uint32_t)addr;\n    return true;\n}\n/*\n * Open trace file and count entries â€” used to pre-allocate\n * the access array for Optimal (BÃ©lÃ¡dy's) algorithm in Milestone 4.\n */\nint load_trace(const char *path, mem_access_t **out_accesses, size_t *out_count) {\n    FILE *fp = fopen(path, \"r\");\n    if (!fp) { perror(\"fopen\"); return -1; }\n    size_t capacity = 1024;\n    size_t count    = 0;\n    mem_access_t *accesses = malloc(capacity * sizeof(mem_access_t));\n    if (!accesses) { fclose(fp); return -1; }\n    char line[256];\n    while (fgets(line, sizeof(line), fp)) {\n        mem_access_t access;\n        if (!parse_trace_line(line, &access)) continue;\n        if (count >= capacity) {\n            capacity *= 2;\n            mem_access_t *tmp = realloc(accesses, capacity * sizeof(mem_access_t));\n            if (!tmp) { free(accesses); fclose(fp); return -1; }\n            accesses = tmp;\n        }\n        accesses[count++] = access;\n    }\n    fclose(fp);\n    *out_accesses = accesses;\n    *out_count    = count;\n    return 0;\n}\n```\n---\n## The Two Failure Modes: Page Fault vs Protection Fault\nWhen address translation is attempted, one of three things happens:\n1. **Success**: The PTE is valid and permissions match â†’ return physical address\n2. **Page fault**: The PTE's `valid` bit is 0 â†’ page is not in memory\n3. **Protection fault**: The PTE's `valid` bit is 1, but the access violates permission bits\nThese are **completely different conditions** with different causes and different responses. Confusing them is the most common mistake in this milestone.\n\n![Page Fault vs Protection Fault Decision Tree](./diagrams/diag-m1-page-fault-vs-protection-fault.svg)\n\n| Condition | `valid` bit | Permissions | Response |\n|-----------|-------------|-------------|----------|\n| Page fault | `0` | (doesn't matter) | Load page from storage, allocate frame, retry |\n| Protection fault | `1` | Wrong | Kill or signal process (or log error in simulator) |\n| Success | `1` | Correct | Return physical address |\n**Why valid=0 doesn't mean \"this page doesn't exist.\"** A page with `valid=0` might be in swap space (evicted earlier), or simply never accessed yet (demand paging). The OS knows the difference through additional structures (the VMA â€” Virtual Memory Area â€” which describes what *should* be mapped, even if it isn't yet). In your simulator, you'll simplify this: any page not yet allocated gets demand-paged into a free frame on first access, and a write-to-unallocated page is also treated as a page fault (then the new page is also marked writable).\n---\n## Demand Paging: Pages on Demand\n\n> **ğŸ”‘ Foundation: Demand paging**\n> \n> **1. What it IS**\nDemand paging is a \"lazy\" loading strategy. Instead of loading an entire 2GB application into RAM when you double-click it, the OS loads nothing. It marks all the application's pages as \"Not Present\" in the page table. When the CPU tries to run the first instruction, it failsâ€”this is a **Page Fault**. The **Page Fault Handler** (a special OS function) catches the failure, finds the data on the disk, puts it into a physical RAM slot, updates the PTE to \"Valid,\" and tells the CPU to try again.\n\n**2. Why you need it right now**\nThis is the magic that allows you to run a 10GB game on a computer with only 8GB of RAM. It ensures that memory is only consumed for the specific parts of a program you are actually using at this moment.\n\n**3. Key Insight**\n**\"Just-In-Time Inventory\":** Demand paging is the Amazon Prime of memory. The OS doesn't keep every item in the front showroom (RAM); it keeps them in a massive warehouse (Disk) and only rushes them to the showroom the second a customer (the CPU) asks for them.\n\nThe OS doesn't load your entire program into RAM when it starts. It loads a minimal amount, maps the rest as `valid=0`, and lets the hardware trigger faults as needed. This is **demand paging**: allocate physical memory only when it's actually demanded by a memory access.\nIn your simulator, demand paging is implemented by the page fault handler:\n```c\n/*\n * Allocate a free physical frame from the frame pool.\n * Returns frame number on success, or UINT32_MAX if no frames are free.\n * Complexity: O(NUM_FRAMES) â€” acceptable for small NUM_FRAMES.\n * In a real OS: maintained as a free list, O(1) allocation.\n */\nstatic uint32_t alloc_free_frame(simulator_t *sim) {\n    for (uint32_t i = 0; i < sim->num_frames; i++) {\n        if (!sim->frames[i].in_use) {\n            sim->frames[i].in_use = true;\n            /* Zero-initialize the frame (mimics OS security practice) */\n            memset(sim->frames[i].data, 0, PAGE_SIZE);\n            return i;\n        }\n    }\n    return UINT32_MAX;  /* Out of physical memory â€” will need replacement in M4 */\n}\n/*\n * Page fault handler.\n * Called when PTE.valid == 0 for the given VPN.\n *\n * Behavior:\n *   1. Find a free frame (demand paging â€” allocate lazily)\n *   2. \"Load\" the page (in real OS: read from disk/swap; here: zero-fill)\n *   3. Update the PTE: set valid=1, set PFN, set permissions\n *   4. Return the allocated PFN, or UINT32_MAX on OOM\n */\nstatic uint32_t handle_page_fault(simulator_t *sim, uint32_t vpn,\n                                  access_type_t access_type) {\n    sim->page_faults++;\n    fprintf(stderr, \"[PAGE FAULT] VPN=0x%05X  access=%s\\n\",\n            vpn, (access_type == ACCESS_WRITE) ? \"WRITE\" : \"READ\");\n    uint32_t frame = alloc_free_frame(sim);\n    if (frame == UINT32_MAX) {\n        fprintf(stderr, \"[OOM] No free frames â€” page replacement needed (Milestone 4)\\n\");\n        return UINT32_MAX;\n    }\n    /* Set up the PTE for this newly allocated page.\n     * Default permissions: readable; writable only if access is a write.\n     * Real OS would consult the VMA to determine correct permissions. */\n    pte_t *pte = &sim->page_table.entries[vpn];\n    *pte = pte_make(frame, /*readable=*/1, /*writable=*/(access_type == ACCESS_WRITE));\n    /* pte_make already sets valid=1 */\n    return frame;\n}\n```\n\n![Demand Paging: Before and After a Page Fault](./diagrams/diag-m1-demand-paging-before-after.svg)\n\n**Security note:** The `memset(frame.data, 0, PAGE_SIZE)` call is not just housekeeping â€” it's a security requirement. If the OS reuses frames without zeroing them, a new process could read data left behind by a previous process. Linux zeroes pages before handing them to userspace.\n---\n## The Core Translation Function\nNow assemble the address translation logic. This function is the heart of your simulator â€” every access flows through it.\n```c\n/*\n * Result of an address translation attempt.\n */\ntypedef enum {\n    XLATE_SUCCESS    = 0,\n    XLATE_PAGE_FAULT = 1,\n    XLATE_PROT_FAULT = 2,\n    XLATE_OOM        = 3,   /* page fault but no free frames */\n} xlate_result_t;\ntypedef struct {\n    xlate_result_t  result;\n    uint32_t        paddr;  /* valid only when result == XLATE_SUCCESS */\n    uint32_t        pfn;    /* PFN assigned (after fault resolution) */\n} xlate_t;\n/*\n * Translate a virtual address, handling faults as needed.\n *\n * Algorithm:\n *   1. Decompose vaddr into VPN and offset\n *   2. Look up PTE = page_table[VPN]\n *   3. If !PTE.valid         â†’ page fault  â†’ handle_page_fault() â†’ retry\n *   4. If write && !writable â†’ prot fault  â†’ log and return error\n *   5. Set PTE.referenced = 1\n *   6. If write: set PTE.dirty = 1\n *   7. Build and return physical address\n */\nxlate_t translate(simulator_t *sim, uint32_t vaddr, access_type_t access_type) {\n    sim->total_accesses++;\n    uint32_t vpn    = vpn_from_addr(vaddr);\n    uint32_t offset = offset_from_addr(vaddr);\n    /* Bounds check: VPN must be within page table range */\n    if (vpn >= PAGE_TABLE_SIZE) {\n        fprintf(stderr, \"[SEGFAULT] VPN 0x%X exceeds page table size\\n\", vpn);\n        return (xlate_t){ .result = XLATE_PROT_FAULT, .paddr = 0 };\n    }\n    pte_t *pte = &sim->page_table.entries[vpn];\n    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     * Step 1: Is the page in memory?\n     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n    if (!(*pte & PTE_VALID)) {\n        /* Page fault: page is not in physical memory */\n        uint32_t frame = handle_page_fault(sim, vpn, access_type);\n        if (frame == UINT32_MAX) {\n            return (xlate_t){ .result = XLATE_OOM };\n        }\n        /* Reload pte â€” handle_page_fault() updated it */\n        /* (pte is a pointer into the table, so it's already updated) */\n    }\n    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     * Step 2: Permission check\n     * Only check after valid=1 is confirmed â€” checking invalid PTEs'\n     * permission bits is undefined (they may be garbage).\n     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n    if (access_type == ACCESS_WRITE && !(*pte & PTE_PERM_WRITE)) {\n        sim->protection_faults++;\n        fprintf(stderr, \"[PROT FAULT] VPN=0x%05X write to read-only page\\n\", vpn);\n        return (xlate_t){ .result = XLATE_PROT_FAULT };\n    }\n    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     * Step 3: Set access bits\n     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n    *pte |= PTE_REFERENCED;                          /* any access */\n    if (access_type == ACCESS_WRITE) *pte |= PTE_DIRTY;  /* writes only */\n    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     * Step 4: Build physical address\n     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n    uint32_t pfn   = pte_get_pfn(*pte);\n    uint32_t paddr = make_physical_addr(pfn, offset);\n    return (xlate_t){\n        .result = XLATE_SUCCESS,\n        .paddr  = paddr,\n        .pfn    = pfn,\n    };\n}\n```\n**Critical ordering note:** Check `valid` before checking permissions. If you check permissions on an invalid PTE, you're reading garbage bits â€” the PTE's content is meaningless when `valid=0`. The valid check must come first.\n**Dirty bit discipline:** Only write accesses set the dirty bit. Read accesses never do. This matters enormously in Milestone 4: a dirty page must be written to swap before its frame can be reused. If you incorrectly set dirty on reads, you'll cause unnecessary swap writes, inflating your swap write-back statistics.\n---\n## The Main Simulation Loop\nConnect the trace parser to the translator:\n```c\n/*\n * Run the simulator over a loaded trace.\n */\nvoid simulate(simulator_t *sim, const mem_access_t *accesses, size_t count) {\n    for (size_t i = 0; i < count; i++) {\n        const mem_access_t *acc = &accesses[i];\n        printf(\"[%6zu] %s 0x%08X â†’ \",\n               i,\n               acc->type == ACCESS_WRITE ? \"W\" : \"R\",\n               acc->vaddr);\n        xlate_t result = translate(sim, acc->vaddr, acc->type);\n        switch (result.result) {\n            case XLATE_SUCCESS:\n                printf(\"phys=0x%08X (PFN=%u)\\n\", result.paddr, result.pfn);\n                break;\n            case XLATE_PAGE_FAULT:\n                /* Page fault was handled inside translate(); this shouldn't occur */\n                printf(\"PAGE FAULT (unresolved)\\n\");\n                break;\n            case XLATE_PROT_FAULT:\n                printf(\"PROTECTION FAULT\\n\");\n                break;\n            case XLATE_OOM:\n                printf(\"OUT OF MEMORY (no free frames)\\n\");\n                break;\n        }\n    }\n}\n/*\n * Print final statistics.\n */\nvoid print_stats(const simulator_t *sim) {\n    printf(\"\\n=== Simulation Statistics ===\\n\");\n    printf(\"Total accesses:     %lu\\n\", sim->total_accesses);\n    printf(\"Page faults:        %lu  (%.2f%%)\\n\",\n           sim->page_faults,\n           sim->total_accesses > 0\n               ? 100.0 * sim->page_faults / sim->total_accesses\n               : 0.0);\n    printf(\"Protection faults:  %lu  (%.2f%%)\\n\",\n           sim->protection_faults,\n           sim->total_accesses > 0\n               ? 100.0 * sim->protection_faults / sim->total_accesses\n               : 0.0);\n    /* Count allocated frames */\n    uint32_t frames_used = 0;\n    for (uint32_t i = 0; i < sim->num_frames; i++) {\n        if (sim->frames[i].in_use) frames_used++;\n    }\n    printf(\"Frames in use:      %u / %u\\n\", frames_used, sim->num_frames);\n}\n```\n---\n## Initializing the Simulator\n```c\n/*\n * Initialize the simulator to clean state.\n *\n * All PTEs are set to 0 (valid=0, all permissions cleared).\n * All frames are marked free.\n */\nvoid simulator_init(simulator_t *sim) {\n    memset(sim, 0, sizeof(*sim));\n    sim->page_size   = PAGE_SIZE;\n    sim->offset_bits = PAGE_OFFSET_BITS;\n    sim->num_frames  = NUM_FRAMES;\n    /* page_table.entries is zeroed by memset â€” all PTEs start invalid */\n    /* frames[i].in_use = false for all i â€” all frames start free */\n}\n/*\n * Wire it all together: main entry point.\n */\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <trace-file>\\n\", argv[0]);\n        return 1;\n    }\n    simulator_t sim;\n    simulator_init(&sim);\n    mem_access_t *accesses = NULL;\n    size_t count = 0;\n    if (load_trace(argv[1], &accesses, &count) != 0) {\n        fprintf(stderr, \"Failed to load trace file: %s\\n\", argv[1]);\n        return 1;\n    }\n    printf(\"Loaded %zu accesses from %s\\n\\n\", count, argv[1]);\n    simulate(&sim, accesses, count);\n    print_stats(&sim);\n    free(accesses);\n    return 0;\n}\n```\n---\n## Building and Testing\n### Compile\n```bash\ngcc -Wall -Wextra -O2 -std=c11 -o vmsim vmsim.c\n```\n### Minimal test trace\nCreate `test_basic.trace`:\n```\n# Test: basic read/write sequence\nR 0x00001000\nW 0x00001004\nR 0x00002000\nW 0x00001000\n```\nExpected output pattern:\n```\n[     0] R 0x00001000 â†’ PAGE FAULT logged, phys=0x00001000 (PFN=0)\n[     1] W 0x00001004 â†’ phys=0x00001004 (PFN=0)   [same page, dirty set]\n[     2] R 0x00002000 â†’ PAGE FAULT logged, phys=0x00011000 (PFN=1)\n[     3] W 0x00001000 â†’ phys=0x00001000 (PFN=0)   [dirty already set]\n```\n### Protection fault test trace\nTo test protection faults, you need a way to mark pages as read-only. Extend your trace format with a setup directive:\n```\n# Extended trace: test protection fault\n# MMAP <vpn> <R|W|RW>  â€” pre-map a page with given permissions\nMMAP 0x00001 R\nR 0x00001000   # should succeed\nW 0x00001004   # should trigger PROTECTION FAULT\n```\nAlternatively, expose a `simulator_mmap()` function and call it from a C test:\n```c\n/*\n * Pre-map a virtual page with specified permissions (no demand paging â€”\n * allocate a frame immediately and set the PTE directly).\n * Used for testing protection fault behavior.\n */\nint simulator_mmap(simulator_t *sim, uint32_t vpn, int readable, int writable) {\n    if (vpn >= PAGE_TABLE_SIZE) return -1;\n    uint32_t frame = alloc_free_frame(sim);\n    if (frame == UINT32_MAX) return -1;  /* OOM */\n    sim->page_table.entries[vpn] = pte_make(frame, readable, writable);\n    return 0;\n}\n```\n---\n## Common Pitfalls and How to Avoid Them\n| Pitfall | Symptom | Fix |\n|---------|---------|-----|\n| `vaddr >> 11` instead of `>> 12` | VPN off by factor of 2 | Remember: PAGE_SIZE = 2Â¹Â², shift by **12** |\n| Checking permissions before valid | Garbage perm bits on invalid PTEs | Always check `valid` first |\n| Setting dirty on read | Over-counting dirty pages | Only `|= PTE_DIRTY` on `ACCESS_WRITE` |\n| Not zeroing new frames | Data leakage between \"processes\" | `memset(frame.data, 0, PAGE_SIZE)` on alloc |\n| Treating page fault as fatal | Simulator aborts on first fault | Page faults are expected â€” resolve them |\n| `offset_mask = PAGE_SIZE` instead of `PAGE_SIZE - 1` | Wrong offset extraction | Mask is `0xFFF` for 4KB pages, not `0x1000` |\nThe offset mask is a particularly nasty bug. `PAGE_SIZE = 4096 = 0x1000`. The mask needs to cover bits `[11:0]` = `0xFFF = 4095 = PAGE_SIZE - 1`. Using `PAGE_SIZE` as the mask would give you `0x1000`, which in binary is `0001 0000 0000 0000` â€” completely wrong.\n---\n## Hardware Soul: What Real Hardware Does\nYour simulator runs `translate()` in software. Real hardware does the equivalent in silicon, in the CPU's **Memory Management Unit (MMU)**. Understanding the parallel deepens everything you're building:\n**Real x86-64 hardware:**\n- CR3 register holds the physical address of the top-level page table\n- On every memory instruction, the MMU decomposes the virtual address\n- It walks the page table hierarchy (4 levels on x86-64)\n- If the TLB has a cached translation, the walk is skipped entirely (Milestone 2)\n- If a PTE has `Present=0` (equivalent to your `valid=0`), the CPU raises a **#PF (Page Fault) exception** â€” hardware interrupt, not a function call\n- The OS's page fault handler is invoked at interrupt priority, resolves the fault, and resumes the faulting instruction\n**Cache line behavior in your simulator:**\n- `page_table.entries` is a contiguous array\n- Accessing entries for VPNs 0â€“15 touches bytes 0â€“63: exactly one cache line\n- Accessing entries for VPNs 0 and 1000 touches two cache lines 4KB apart: likely two separate L1 cache misses\n- Your simulator with only 64 frames will mostly access a small range of VPNs â†’ page table accesses are mostly cache-warm\n**TLB hardware (preview for Milestone 2):**\n- Real CPUs have 64â€“2048 TLB entries that cache VPNâ†’PFN mappings\n- A TLB hit costs ~1 cycle; a TLB miss that requires a hardware page table walk costs 4 memory accesses on x86-64 (one per level)\n- Your software `translate()` currently does the \"TLB miss\" path every time â€” Milestone 2 caches the result\n---\n## Knowledge Cascade: What This Unlocks\nYou've built a page table and implemented demand paging. Here's what you now understand that you didn't before:\n**1. Why `malloc` for large allocations returns page-aligned memory**\n`malloc` calls `mmap()` for large requests (typically > 128KB). `mmap()` returns a page-aligned virtual address because the OS can only map, protect, and fault at page granularity. A virtual address in the middle of a page can't be given its own PTE â€” the entire page is the minimum unit. This is why `posix_memalign(ptr, 4096, size)` exists, and why database buffer pools (SQLite, PostgreSQL) align their I/O buffers to 4KB: they need exact page-boundary alignment for `O_DIRECT` (bypassing the kernel page cache) and for `mmap`-based storage access.\n**2. How `mmap` can \"map\" a 10GB file with only 256MB of RAM**\n\n> **ğŸ”‘ Foundation: How mmap and demand paging together enable mapping files larger than physical memory**\n> \n> **1. What it IS**\n`mmap` is a system call that \"maps\" a file directly into a process's virtual memory space. Instead of using `read()` to copy a file into a buffer, you tell the OS: \"Make this 1GB file appear as if it's an array at virtual address `0x5000`.\" \n\nThe connection to demand paging is crucial: `mmap` doesn't actually load the file into RAM. It simply creates the PTEs and marks them as \"Not Present,\" pointing them to the file on disk. The file is only loaded into RAM piece-by-piece via the Page Fault Handler as your code actually touches different parts of that \"array.\"\n\n**2. Why you need it right now**\nIf you need to process a dataset that is larger than your available RAM, `mmap` is the solution. It lets the OS handle all the complex logic of loading, caching, and eviction. You treat the file like a giant pointer, and the demand paging system ensures only the active \"window\" of that file occupies your physical memory.\n\n**3. Key Insight**\n**The \"Portal\" Model:** `mmap` creates a virtual window (the portal) into a file. Demand paging is the mechanism that actually pulls the data through that portal only when you reach out and try to touch it.\n\n`mmap()` doesn't read the file â€” it creates PTEs with `valid=0` that point to file offsets instead of swap. When you touch a mapped page, the page fault handler reads exactly that 4KB chunk from disk and maps it into a free frame. You've just implemented the core of this mechanism. The OS never needs more RAM than the number of pages simultaneously accessed (the working set).\n**3. Process isolation is a page table, not a byte-level guard**\nEvery process has its own page table. Process A's VPN 0x12345 â†’ PFN 17; Process B's VPN 0x12345 â†’ PFN 83. The same virtual address translates to completely different physical frames. There's no per-byte checking, no encryption, no copying â€” just two separate PTEs that happen to be indexed by the same number but live in different page tables. Memory isolation is 100% a page table artifact. When you see \"memory corruption via buffer overflow that overwrites another process's memory,\" the reason it *doesn't* happen normally is that there are no PTEs mapping virtual addresses outside your process's allocated regions.\n**4. SQLite, PostgreSQL, and InnoDB all think in pages**\nEvery relational database uses page-sized I/O buffers because the OS's unit of transfer between disk and RAM is exactly one page (4KB). PostgreSQL's page size is 8KB (2Ã— OS page); MySQL InnoDB uses 16KB (4Ã— OS page). Their buffer pools are essentially a software version of what you just built â€” a mapping from \"logical page number on disk\" to \"frame in the buffer pool\" â€” with the same concepts of valid bits (is this page currently in the pool?), dirty bits (has it been modified since last flush?), and replacement algorithms (LFU, clock, ARC). The OS virtual memory system and the database buffer manager are isomorphic designs solving the same caching problem at different layers.\n**5. Cross-domain: Web caches and CDNs**\nThe page table is a cache: it maps virtual addresses to physical locations, handling misses (page faults) by fetching from backing storage (disk/swap). CDNs do the same: they cache URLs â†’ physical server responses, handling misses by fetching from origin. The eviction algorithms you'll implement in Milestone 4 (LRU, Clock, Optimal) are exactly the same algorithms used in Nginx's proxy cache, Varnish, and CDN edge nodes. Page replacement theory is cache theory. The domains are the same mathematics.\n---\n## What You've Built and What's Missing\n**You have:**\n- A complete, working virtual memory simulator for a single process\n- Flat page table with O(1) address translation\n- Demand paging (pages allocated on first access)\n- Protection fault detection\n- Statistics collection\n**What's painfully missing:** Every access calls `translate()` which does a full page table lookup â€” an array read from `page_table.entries[vpn]`. In a real CPU, this requires a memory access to wherever the page table is stored. For 1M entries at 4 bytes each, the page table is 4MB â€” it doesn't fit in L1 cache (typically 32â€“64 KB). Most page table accesses are L2 or L3 misses (~4ns and ~40ns respectively), compared to a register access (~0.25ns).\nReal programs access the same pages repeatedly. The working set of a typical process is 10â€“1000 pages, not millions. If only we could *cache* the most recent VPNâ†’PFN translations...\nThat's the TLB. Milestone 2 adds it.\n**Also missing:** The flat page table costs 4MB per process regardless of how sparse the address space is. A process using 10 pages still needs a 1M-entry table. Milestone 3 fixes this with multi-level page tables, which only allocate table memory for regions that are actually mapped.\n**And:** When all 64 frames are full and a new page needs to be loaded, your current simulator simply fails. Milestone 4 adds page replacement â€” deciding which existing page to evict to make room.\nEach milestone is a direct fix for a concrete limitation you've now felt in your implementation. That's not a coincidence â€” it's the pedagogical design of this project.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: virtual-memory-sim-m2 -->\n<!-- MS_ID: virtual-memory-sim-m2 -->\n# Milestone 2: TLB (Translation Lookaside Buffer)\n## The Problem: Every Load Is Two Loads\nYou built a page table in Milestone 1. It works. Now run it against this trace and think carefully about what the hardware is actually doing:\n```\nR 0x00401020\nR 0x00401024\nR 0x00401028\nR 0x0040102C\n```\nFour reads in a tight loop â€” the kind of thing a program does thousands of times per second when iterating over an array. What does your `translate()` function do for each one?\n1. Compute `VPN = vaddr >> 12`\n2. Access `page_table.entries[VPN]` â€” **a memory read**\n3. Extract the PFN from the PTE\n4. Compute `physical_address = (PFN << 12) | offset`\n5. Now â€” finally â€” access the data at that physical address â€” **another memory read**\nTwo memory reads for every single memory access. That's not a theoretical inefficiency â€” it's a concrete halving of memory bandwidth. Every array element read is secretly two reads. Every function call's stack frame access is two reads. Every pointer dereference is two reads.\nAt 3 GHz with a 100ns DRAM latency, your CPU can issue ~300 instructions in the time it takes to complete *one* memory access. Without caching, a page table lookup before every data access means your program grinds at half-speed at best â€” and for multi-level page tables (Milestone 3), it's *three* loads for every one data load. The whole system becomes a memory-latency machine.\nHere's the thing: this problem is deterministic. The same four virtual addresses in the loop above all map to the same VPN. You're performing the same page table lookup â€” fetching the same PTE â€” four consecutive times. You're paying 100ns for a lookup whose answer you already knew from the previous iteration.\n**The fix is obvious once you see it: cache the last few VPNâ†’PFN translations.** If you've recently looked up VPN 0x401, don't re-read the page table â€” just return the answer you computed last time. This is the **Translation Lookaside Buffer** (TLB), and it is not a nice-to-have optimization. It is the entire reason virtual memory is feasible in a modern CPU.\n\n![TLB Position in the Address Translation Pipeline](./diagrams/diag-m2-tlb-in-translation-pipeline.svg)\n\n---\n## The Revelation: The TLB Is the Most Important Cache in Your CPU\nHere's the misconception worth destroying before you write a single line of code:\n*\"The TLB is just a cache for page table entries â€” a useful optimization but fundamentally the page table is the real mechanism.\"*\nThis is wrong, and the wrongness matters for how you design your system.\nConsider what \"99% TLB hit rate\" means in practice. If your TLB has 64 entries and achieves a 99% hit rate:\n- 99% of memory accesses: TLB hit â†’ PFN in ~1 CPU cycle â†’ data access\n- 1% of memory accesses: TLB miss â†’ page table walk â†’ 1 memory access for single-level, 2â€“4 for multi-level â†’ *then* data access\nNow consider what 100% TLB miss rate means (no TLB at all):\n- Every single memory access first triggers a page table walk\n- For a two-level page table: **3 memory accesses per data byte read** (level-1 table, level-2 table, data)\n- Effective memory bandwidth: 1/3 of hardware capability\n- At 50 GB/s DRAM bandwidth: your program sees 16 GB/s\n- Those 300 instructions you could execute in a DRAM latency window? Now you're burning 300 cycles *per byte read*\nThe TLB is the only reason virtual memory doesn't obliterate performance. Real TLBs â€” 64 to 2048 entries â€” achieve 99%+ hit rates through the same principle that makes CPU caches work: **temporal and spatial locality**. Programs tend to access the same pages repeatedly (temporal locality: the loop above reuses VPN 0x401 four times), and nearby addresses (spatial locality: sequential array traversal hits the same page for 4096/8 = 512 consecutive 8-byte reads).\n**The TLB transforms an O(levels) memory-access translation overhead into an O(1) register lookup.** This is why hardware architects gave the TLB its own special designation separate from L1/L2/L3 caches: it's a different kind of structure, fully associative, searched in parallel, and integrated so tightly with the MMU that its hit latency is often effectively zero (absorbed into the pipeline).\nYour software simulator will, of course, implement TLB lookup as regular C code â€” sequential, not parallel. But the data structures you'll build mirror the real hardware exactly, and the hit rate behavior you observe will follow the same locality principles.\n---\n## What a TLB Entry Contains\n[[EXPLAIN:cache-concepts:-tag-matching,-hit/miss,-eviction-policies|Cache concepts: tag matching, hit/miss, eviction policies â€” how a cache determines if it holds a value and what to discard when full]]\nA TLB entry is not just `{vpn, pfn}`. It needs additional metadata to handle context switches, dirty-bit propagation, and permission checking without consulting the page table:\n```c\n/*\n * TLB Entry â€” one slot in the Translation Lookaside Buffer\n *\n * Memory layout (bytes):\n *   [0..3]  â€” vpn:  Virtual Page Number being cached (tag for lookup)\n *   [4..7]  â€” pfn:  Physical Frame Number (cached translation result)\n *   [8..9]  â€” asid: Address Space ID (which process owns this entry)\n *   [10]    â€” flags byte:\n *               bit 0: valid      â€” is this entry occupied?\n *               bit 1: dirty      â€” has this page been written to?\n *               bit 2: referenced â€” has this page been accessed?\n *               bit 3: writable   â€” is this mapping writable?\n *   [11]    â€” lru_counter (or timestamp): for LRU eviction\n *\n * Total size: 12 bytes per entry\n * Cache line (64 bytes) holds: 5 entries (with 4 bytes wasted)\n * For 64-entry TLB: 64 Ã— 12 = 768 bytes â€” fits entirely in L1 cache (32KB)\n */\ntypedef struct {\n    uint32_t vpn;           /* Tag: which virtual page is cached?    */\n    uint32_t pfn;           /* Data: which physical frame maps to it? */\n    uint16_t asid;          /* Address Space ID (process identifier)  */\n    uint8_t  flags;         /* valid | dirty | referenced | writable  */\n    uint8_t  lru_counter;   /* Used by LRU eviction; higher = more recently used */\n} tlb_entry_t;\n/* Flag bit masks for tlb_entry_t.flags */\n#define TLB_VALID      (1u << 0)\n#define TLB_DIRTY      (1u << 1)\n#define TLB_REFERENCED (1u << 2)\n#define TLB_WRITABLE   (1u << 3)\n```\n\n![TLB Entry Structure â€” Tag, Data, and Flags](./diagrams/diag-m2-tlb-entry-structure.svg)\n\n**Why replicate dirty/referenced bits in the TLB?** Because on a TLB hit you don't consult the page table at all â€” that's the whole point. But if a write access occurs and sets the dirty bit, where does it get recorded? The TLB holds the live, up-to-date version of these bits during the entry's residence. The page table's PTE may be stale. When a TLB entry is evicted, its dirty and referenced bits must be written back to the PTE before the entry is discarded. This is the **TLB write-back** step, and forgetting it is the single most common correctness bug in TLB implementations.\n**Why store `writable` in the TLB?** So that permission checking can happen entirely within the TLB on a hit, without fetching the PTE. If a write access hits the TLB but `TLB_WRITABLE` is clear, it's a protection fault â€” detected and reported without touching the page table array.\n\n> **ğŸ”‘ Foundation: Fully associative vs set-associative TLB lookup**\n> \n> ### What it is\nIn the context of a Translation Lookaside Buffer (TLB), these are two different strategies for finding a physical address from a virtual one:\n\n*   **Fully Associative:** The hardware compares the target virtual address against every single entry in the TLB simultaneously. There is no specific \"slot\" where a page must live; a translation can be stored anywhere.\n*   **Set-Associative:** The TLB is partitioned into \"sets.\" A few bits of the virtual address (the **index**) determine exactly which set a translation belongs to. Once the set is identified, the hardware only searches the entries within that specific set (the **ways**). For example, in a \"4-way set-associative\" TLB, you only ever have to check 4 specific slots.\n\n### Why you need it right now\nAs you implement or optimize memory management, you must balance **latency, power, and conflict misses**. \n\nIf you use a **Fully Associative** lookup, you maximize your \"Hit Rate\" because you can put any translation in any available slot. However, this requires massive amounts of circuitry (comparators) to check every entry at once, which consumes significant power and doesn't scale to large TLB sizes.\n\nIf you use **Set-Associative** lookup, you save power and can build much larger TLBs because the hardware only activates the small portion of memory belonging to one set. However, you risk \"conflict misses\"â€”where two frequently used addresses happen to map to the same set, kicking each other out even if the rest of the TLB is empty.\n\n### The Key Insight: The \"Valet vs. Assigned Parking\" Model\n*   **Fully Associative is Valet Parking:** You give the attendant your keys (the virtual address). They can park your car in **any** spot in the entire garage. When you return, they must potentially look at every spot to find it, but the garage is never \"full\" unless every single spot is taken.\n*   **Set-Associative is Assigned Level Parking:** Your ticket says you **must** park on Level 4. You only have to search the spots on Level 4 to find your car (faster/cheaper), but if Level 4 is full, you can't park thereâ€”even if Levels 1, 2, and 3 are completely empty.\n\n---\n## The ASID: Context Switches Without Tears\nBefore implementing the TLB structure, you need to understand why the **ASID (Address Space ID)** exists, because it changes everything about how you handle context switches.\nThe naive approach to context switching with a TLB: when the OS switches from Process A to Process B, flush every TLB entry. Process A's translations are now invalid â€” Process B uses different virtualâ†’physical mappings. Clean slate for Process B.\nThe problem: a context switch happens thousands of times per second on a busy system. Each flush evicts all cached translations. Process B starts with a cold TLB â€” every memory access for the first few hundred microseconds triggers a TLB miss and page table walk. Then the OS switches back to Process A, flushes again, and Process A's hot TLB entries are gone too.\n**TLB flushes are catastrophically expensive.** This isn't a microoptimization concern â€” on a system running 1000 context switches per second with a 64-entry TLB, each switch costs roughly 64 \"warm-up\" accesses to re-populate the TLB. That's 64,000 extra page table walks per second on behalf of context switching alone.\nThe ASID solution: tag every TLB entry with the process identifier. During lookup, only consider entries whose ASID matches the *currently running process's* ASID. Entries from Process A remain in the TLB during Process B's time slice â€” they're simply invisible (treated as misses). When the OS switches back to Process A, its entries are still there, warm and valid.\n```\nTLB state during Process A's time slice:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  VPN     â”‚ PFN â”‚ASID â”‚  flags   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ 0x00401  â”‚  7  â”‚  1  â”‚ valid,W  â”‚  â† Process A (ASID=1), active\nâ”‚ 0x00400  â”‚  3  â”‚  1  â”‚ valid    â”‚  â† Process A (ASID=1), active\nâ”‚ 0x00800  â”‚ 22  â”‚  2  â”‚ valid    â”‚  â† Process B (ASID=2), INVISIBLE\nâ”‚ 0x00801  â”‚ 23  â”‚  2  â”‚ valid    â”‚  â† Process B (ASID=2), INVISIBLE\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nActive ASID = 1  â†’  only rows 1-2 are eligible matches\nContext switch: OS sets active ASID = 2\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ 0x00401  â”‚  7  â”‚  1  â”‚ valid,W  â”‚  â† Process A, NOW INVISIBLE\nâ”‚ 0x00400  â”‚  3  â”‚  1  â”‚ valid    â”‚  â† Process A, NOW INVISIBLE\nâ”‚ 0x00800  â”‚ 22  â”‚  2  â”‚ valid    â”‚  â† Process B, ACTIVE again\nâ”‚ 0x00801  â”‚ 23  â”‚  2  â”‚ valid    â”‚  â† Process B, ACTIVE again\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nActive ASID = 2  â†’  zero-cost switch, no flush needed\n```\n\n![ASID-Tagged TLB: Context Switch Without Flush](./diagrams/diag-m2-asid-context-switch.svg)\n\n**ASID width limits:** In your simulator, ASID is a `uint16_t` (16 bits = 65,536 possible ASIDs). In real x86-64 hardware with PCID (Process-Context Identifiers), ASID is 12 bits = 4096 values. When all ASIDs are exhausted (more than 65,535 live processes in your simulator), the OS must recycle old ASIDs. Recycling means that a process might be assigned an ASID that previously belonged to a different process â€” and that previous process's stale entries might still be in the TLB. The solution: when recycling an ASID, perform a full TLB flush first to evict all entries with that ASID.\n> ğŸ”­ **Deep Dive**: The Meltdown/Spectre CPU vulnerabilities (Kocher et al., 2018; Lipp et al., 2018) required operating systems to keep kernel and user page tables completely separate (KPTI â€” Kernel Page Table Isolation). Without PCID/ASID support, every syscall required a TLB flush when switching between user and kernel page tables, causing 5â€“30% performance regression on I/O-heavy workloads. PCID support (equivalent to our ASID simulation) restored most of this performance. See the original Meltdown paper (Lipp et al., 2018) and the Linux KPTI patchset documentation for the full technical story.\n---\n## The TLB Structure\nNow implement it. The TLB is a fixed-size, fully-associative array of `tlb_entry_t` records. \"Fully associative\" means a VPN can be cached in *any* slot â€” unlike a CPU's L1 cache which is set-associative (a cache line can only go into specific sets). This makes the TLB simple to implement: lookup is a linear scan through all entries.\n```c\n#define TLB_SIZE    64      /* configurable: 16, 32, 64, 128           */\n#define ASID_NONE   0xFFFF  /* sentinel: entry is completely empty      */\n#define ASID_MAX    255     /* for 8-bit ASIDs; use 65535 for 16-bit    */\ntypedef struct {\n    tlb_entry_t entries[TLB_SIZE];\n    uint16_t    active_asid;        /* ASID of currently running process */\n    uint32_t    clock_hand;         /* for CLOCK-based eviction (not LRU variant) */\n    /* Deterministic PRNG state for random eviction */\n    uint32_t    rand_state;\n    /* Statistics */\n    uint64_t    hits;\n    uint64_t    misses;\n    uint64_t    flushes;\n    uint64_t    evictions;\n} tlb_t;\n/*\n * Initialize TLB to empty state.\n * All entries are invalid; active ASID starts at 0 (first process).\n * rand_state seeds the PRNG for reproducible random eviction.\n */\nvoid tlb_init(tlb_t *tlb, uint16_t initial_asid, uint32_t rand_seed) {\n    memset(tlb, 0, sizeof(*tlb));\n    tlb->active_asid = initial_asid;\n    tlb->rand_state  = rand_seed ? rand_seed : 0xDEADBEEF;\n    /* Mark all entries as invalid with sentinel ASID */\n    for (int i = 0; i < TLB_SIZE; i++) {\n        tlb->entries[i].flags = 0;          /* TLB_VALID cleared */\n        tlb->entries[i].asid  = ASID_NONE;\n    }\n}\n```\n**Hardware soul â€” cache line analysis:**\nA `tlb_entry_t` is 12 bytes. A `tlb_t` with 64 entries is 64 Ã— 12 = 768 bytes for entries, plus ~32 bytes of overhead = ~800 bytes total. This fits comfortably in an L1 cache (typically 32KB). In hardware, TLB lookup is done in parallel across all entries in a single cycle using content-addressable memory (CAM) â€” your software implementation uses a sequential loop, but the data structure fits in L1 regardless, minimizing the performance gap.\n---\n## TLB Lookup: Tag Matching in Action\nThe lookup is the hot path â€” called on every single memory access:\n```c\n/*\n * TLB lookup â€” the hot path.\n *\n * Searches all TLB entries for one matching:\n *   1. entry.valid == 1\n *   2. entry.asid  == tlb->active_asid\n *   3. entry.vpn   == vpn\n *\n * On HIT:\n *   - Updates referenced bit in TLB entry\n *   - Updates dirty bit if access_type == ACCESS_WRITE\n *   - Checks write permission; returns XLATE_PROT_FAULT if violated\n *   - Updates LRU counter\n *   - Returns hit_pfn and XLATE_SUCCESS\n *\n * On MISS:\n *   - Returns XLATE_TLB_MISS (caller must do page table walk)\n *\n * Time complexity: O(TLB_SIZE) â€” sequential scan\n * In hardware: O(1) â€” parallel CAM lookup\n */\ntypedef enum {\n    XLATE_TLB_HIT   = 0,\n    XLATE_TLB_MISS  = 1,\n    XLATE_PROT_FAULT_TLB = 2,\n} tlb_result_t;\ntypedef struct {\n    tlb_result_t result;\n    uint32_t     pfn;       /* valid on HIT */\n    int          entry_idx; /* index of hit entry, for caller to update */\n} tlb_lookup_t;\ntlb_lookup_t tlb_lookup(tlb_t *tlb, uint32_t vpn, access_type_t access_type) {\n    /*\n     * Update LRU counters: increment all entries' lru_counter each access.\n     * An entry's lru_counter represents \"how long since last access.\"\n     * On hit, we reset that entry's counter to 0 (most recently used).\n     * On eviction, we pick the entry with the HIGHEST lru_counter (oldest).\n     *\n     * Alternative: store a global tick counter and record \"last access tick\"\n     * per entry. Equivalent semantics, different implementation overhead.\n     */\n    for (int i = 0; i < TLB_SIZE; i++) {\n        if (tlb->entries[i].flags & TLB_VALID) {\n            if (tlb->entries[i].lru_counter < 255) /* prevent overflow */\n                tlb->entries[i].lru_counter++;\n        }\n    }\n    /* Search for matching entry */\n    for (int i = 0; i < TLB_SIZE; i++) {\n        tlb_entry_t *e = &tlb->entries[i];\n        /* Three-way tag match: valid + ASID + VPN */\n        if (!(e->flags & TLB_VALID))       continue;  /* empty slot   */\n        if (e->asid != tlb->active_asid)   continue;  /* wrong process */\n        if (e->vpn  != vpn)                continue;  /* wrong page    */\n        /* â”€â”€ CACHE HIT â”€â”€ */\n        tlb->hits++;\n        /* Permission check on hit â€” no need to touch page table */\n        if (access_type == ACCESS_WRITE && !(e->flags & TLB_WRITABLE)) {\n            return (tlb_lookup_t){ .result = XLATE_PROT_FAULT_TLB };\n        }\n        /* Update access metadata in TLB entry */\n        e->flags |= TLB_REFERENCED;\n        if (access_type == ACCESS_WRITE) e->flags |= TLB_DIRTY;\n        /* Reset LRU: this entry is now most recently used */\n        e->lru_counter = 0;\n        return (tlb_lookup_t){\n            .result    = XLATE_TLB_HIT,\n            .pfn       = e->pfn,\n            .entry_idx = i,\n        };\n    }\n    /* â”€â”€ CACHE MISS â”€â”€ */\n    tlb->misses++;\n    return (tlb_lookup_t){ .result = XLATE_TLB_MISS };\n}\n```\n**Why increment all counters on every access?** This implements *relative* LRU tracking without a global timer. Each access ages every entry by 1. The hit entry is reset to 0 (youngest). After 10 accesses where entry A is not touched, its counter is 10. After 10 accesses where entry B is touched on each one, its counter stays near 0. The entry with the highest counter is the oldest â€” the LRU victim. This is O(TLB_SIZE) per access, acceptable for small TLBs (64 entries = 64 comparisons â‰ˆ negligible), but would be replaced with a doubly-linked list in a high-performance implementation.\n\n![TLB LRU Eviction â€” State Evolution](./diagrams/diag-m2-lru-eviction-state.svg)\n\n---\n## TLB Insertion and Eviction\nWhen a TLB miss occurs, the caller walks the page table, gets the PFN, then calls `tlb_insert()` to cache the result for future accesses. If the TLB is full, an existing entry must be evicted first â€” and its metadata (dirty bit, referenced bit) written back to the page table before it's discarded.\n```c\n/*\n * Write-back TLB entry metadata to the corresponding page table entry.\n * Called before evicting an entry from the TLB.\n *\n * This preserves the live dirty/referenced state that was updated\n * on TLB hits (without touching the page table on hits).\n *\n * If the TLB entry is dirty, the PTE's dirty bit is set.\n * If the TLB entry has referenced, the PTE's referenced bit is set.\n * Valid bit in PTE is NOT cleared here â€” the page is still in memory,\n * just no longer in the TLB.\n */\nstatic void tlb_writeback_entry(tlb_entry_t *e, page_table_t *pt) {\n    if (!(e->flags & TLB_VALID)) return;  /* Nothing to write back */\n    if (e->asid == ASID_NONE)   return;\n    pte_t *pte = &pt->entries[e->vpn];\n    if (e->flags & TLB_DIRTY)      *pte |= PTE_DIRTY;\n    if (e->flags & TLB_REFERENCED) *pte |= PTE_REFERENCED;\n    /* Note: we do NOT clear PTE_VALID â€” the page is still in RAM */\n}\n/*\n * Find the LRU victim slot among valid entries.\n * Returns index of the entry with the highest lru_counter.\n * If any invalid slot exists, returns it immediately (free slot = best choice).\n */\nstatic int tlb_find_victim_lru(tlb_t *tlb) {\n    /* First pass: look for an invalid (empty) slot â€” free, no eviction needed */\n    for (int i = 0; i < TLB_SIZE; i++) {\n        if (!(tlb->entries[i].flags & TLB_VALID)) return i;\n    }\n    /* Second pass: find oldest (highest lru_counter) among valid entries */\n    int    victim = 0;\n    uint8_t max_age = 0;\n    for (int i = 0; i < TLB_SIZE; i++) {\n        if (tlb->entries[i].lru_counter > max_age) {\n            max_age = tlb->entries[i].lru_counter;\n            victim  = i;\n        }\n    }\n    return victim;\n}\n/*\n * Simple LCG PRNG for reproducible random eviction.\n * Seed with tlb->rand_state; caller saves updated state.\n * Not cryptographic â€” just needs to be deterministic for test reproducibility.\n */\nstatic uint32_t tlb_rand_next(tlb_t *tlb) {\n    tlb->rand_state = tlb->rand_state * 1664525u + 1013904223u; /* Numerical Recipes LCG */\n    return tlb->rand_state;\n}\n/*\n * Insert a VPNâ†’PFN translation into the TLB.\n *\n * If the TLB is full, evict using policy (LRU or random).\n * Write back the evicted entry's metadata to the page table before eviction.\n *\n * Parameters:\n *   tlb          â€” the TLB to insert into\n *   pt           â€” the page table (for write-back on eviction)\n *   vpn          â€” virtual page number being inserted\n *   pfn          â€” physical frame number (result of page table walk)\n *   writable     â€” copy of PTE's write permission\n *   use_random   â€” if true, use random eviction; else LRU\n */\nvoid tlb_insert(tlb_t *tlb, page_table_t *pt,\n                uint32_t vpn, uint32_t pfn,\n                int writable, int use_random) {\n    int slot;\n    if (use_random) {\n        /* Random eviction: pick a random slot, write back if valid */\n        slot = (int)(tlb_rand_next(tlb) % TLB_SIZE);\n        tlb_writeback_entry(&tlb->entries[slot], pt);\n    } else {\n        /* LRU eviction: find victim (or free slot) */\n        slot = tlb_find_victim_lru(tlb);\n        tlb_writeback_entry(&tlb->entries[slot], pt);\n    }\n    if (tlb->entries[slot].flags & TLB_VALID) {\n        tlb->evictions++;\n    }\n    /* Populate the new entry */\n    tlb_entry_t *e = &tlb->entries[slot];\n    e->vpn         = vpn;\n    e->pfn         = pfn;\n    e->asid        = tlb->active_asid;\n    e->flags       = TLB_VALID | TLB_REFERENCED;    /* fresh entry = referenced */\n    if (writable) e->flags |= TLB_WRITABLE;\n    e->lru_counter = 0;   /* most recently used */\n}\n```\n\n![TLB Dirty Bit Write-Back on Eviction](./diagrams/diag-m2-tlb-writeback-coherence.svg)\n\n**Design choice: random vs LRU eviction**\n| Policy | Pros | Cons | Used By |\n|--------|------|------|---------|\n| **LRU âœ“** (default) | Near-optimal hit rate, deterministic given access pattern | O(n) counter updates per access | AMD CPUs (approximate), your simulator |\n| **Random** | O(1), no metadata needed, easy to reason about asymptotically | Non-deterministic without seeded PRNG | MIPS R2000 TLB, ARM Cortex-A series |\n| **FIFO** | O(1), no staleness concern | Susceptible to BÃ©lÃ¡dy anomaly (see Milestone 4) | Rarely used for TLBs |\nFor your simulator, implement LRU as the default but support random via a flag. When testing TLB miss rates against known access patterns, use LRU (deterministic). When stress-testing correctness (the algorithm should work regardless of which entry is evicted), use random with a fixed seed.\n---\n## TLB Flush Operations\nTwo flush operations are needed:\n```c\n/*\n * tlb_flush_all â€” invalidate every entry in the TLB.\n *\n * Used when:\n *   1. ASID space is exhausted and an ASID is being recycled\n *   2. The OS explicitly requests a full shootdown (e.g., after unmapping a range\n *      shared across all processes)\n *   3. Page table entries are modified in ways that require TLB coherence\n *      (e.g., a page is evicted from physical memory in Milestone 4)\n *\n * Write back all dirty entries before invalidating!\n * Failing to write back = silent data loss of dirty/referenced metadata.\n */\nvoid tlb_flush_all(tlb_t *tlb, page_table_t *pt) {\n    for (int i = 0; i < TLB_SIZE; i++) {\n        tlb_writeback_entry(&tlb->entries[i], pt);\n        tlb->entries[i].flags = 0;\n        tlb->entries[i].asid  = ASID_NONE;\n    }\n    tlb->flushes++;\n}\n/*\n * tlb_flush_asid â€” invalidate only entries belonging to a specific ASID.\n *\n * Used when a process exits: its ASID is being freed, so its TLB entries\n * must be cleaned up. Other processes' entries are preserved.\n *\n * This is equivalent to the x86 INVPCID instruction with type=1\n * (flush all translations for a specific PCID).\n */\nvoid tlb_flush_asid(tlb_t *tlb, page_table_t *pt, uint16_t asid) {\n    for (int i = 0; i < TLB_SIZE; i++) {\n        if ((tlb->entries[i].flags & TLB_VALID) && tlb->entries[i].asid == asid) {\n            tlb_writeback_entry(&tlb->entries[i], pt);\n            tlb->entries[i].flags = 0;\n            tlb->entries[i].asid  = ASID_NONE;\n        }\n    }\n    /* Note: this doesn't increment tlb->flushes â€” it's a targeted eviction,\n     * not a full flush. Count it separately if your stats require it. */\n}\n/*\n * tlb_flush_page â€” invalidate a single VPN across all ASIDs.\n *\n * Used when a specific page's mapping is modified (e.g., permissions changed,\n * page evicted from RAM in Milestone 4). Every process that might have\n * cached that VPN must have its entry invalidated.\n *\n * Equivalent to x86 INVLPG instruction (invalidate TLB entry for address).\n * This is the correct operation to call in Milestone 4 when evicting a page\n * from physical memory.\n */\nvoid tlb_flush_page(tlb_t *tlb, page_table_t *pt, uint32_t vpn) {\n    for (int i = 0; i < TLB_SIZE; i++) {\n        if ((tlb->entries[i].flags & TLB_VALID) && tlb->entries[i].vpn == vpn) {\n            tlb_writeback_entry(&tlb->entries[i], pt);\n            tlb->entries[i].flags = 0;\n            tlb->entries[i].asid  = ASID_NONE;\n        }\n    }\n}\n```\n**Why `tlb_flush_page` matters for Milestone 4:** When you evict a page from physical memory to make room for a new one, you must call `tlb_flush_page()` on that page's VPN *before* clearing its PTE. Otherwise, the TLB may still hold a valid-looking entry pointing to a PFN that now belongs to a different page. That's a **TLB coherence violation** â€” the hardware equivalent of reading from a dangling pointer. The TLB would return a PFN that now maps to different data, causing silent memory corruption with no visible fault.\n---\n## Integrating the TLB into Address Translation\nNow rewrite the `translate()` function from Milestone 1 to check the TLB first:\n```c\n/*\n * Extended translate() with TLB.\n *\n * Three-level view of what happens:\n *\n * Application level:\n *   translate(vaddr, ACCESS_READ) â†’ paddr\n *\n * Simulator level (this function):\n *   1. Extract VPN, offset\n *   2. TLB lookup â†’ HIT or MISS\n *   3. On MISS: page table walk, page fault if needed, TLB insert\n *   4. Build physical address\n *\n * Hardware equivalent:\n *   MMU receives vaddr â†’ checks TLB in parallel with L1 cache index\n *   computation â†’ on TLB miss, CPU microcode walks page tables via\n *   dedicated page-walk unit â†’ updates TLB â†’ signals OS on page fault (#PF)\n */\nxlate_t translate_with_tlb(simulator_t *sim, tlb_t *tlb,\n                            uint32_t vaddr, access_type_t access_type) {\n    sim->total_accesses++;\n    uint32_t vpn    = vpn_from_addr(vaddr);\n    uint32_t offset = offset_from_addr(vaddr);\n    if (vpn >= PAGE_TABLE_SIZE) {\n        sim->protection_faults++;\n        return (xlate_t){ .result = XLATE_PROT_FAULT };\n    }\n    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     * Step 1: TLB Lookup\n     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n    tlb_lookup_t tlb_result = tlb_lookup(tlb, vpn, access_type);\n    if (tlb_result.result == XLATE_PROT_FAULT_TLB) {\n        sim->protection_faults++;\n        fprintf(stderr, \"[PROT FAULT] TLB hit but write to read-only page \"\n                \"VPN=0x%05X\\n\", vpn);\n        return (xlate_t){ .result = XLATE_PROT_FAULT };\n    }\n    uint32_t pfn;\n    if (tlb_result.result == XLATE_TLB_HIT) {\n        /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n         * TLB HIT: use cached PFN directly, skip page table entirely\n         *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n        pfn = tlb_result.pfn;\n        /* Note: dirty/referenced bits already updated inside tlb_lookup() */\n    } else {\n        /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n         * TLB MISS: walk the page table\n         *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n        pte_t *pte = &sim->page_table.entries[vpn];\n        /* Is the page in memory? */\n        if (!(*pte & PTE_VALID)) {\n            /* Page fault: demand-load the page */\n            uint32_t frame = handle_page_fault(sim, vpn, access_type);\n            if (frame == UINT32_MAX) {\n                return (xlate_t){ .result = XLATE_OOM };\n            }\n            /* pte is now updated by handle_page_fault() */\n        }\n        /* Permission check after confirming valid=1 */\n        if (access_type == ACCESS_WRITE && !(*pte & PTE_PERM_WRITE)) {\n            sim->protection_faults++;\n            fprintf(stderr, \"[PROT FAULT] Page table: write to read-only \"\n                    \"VPN=0x%05X\\n\", vpn);\n            return (xlate_t){ .result = XLATE_PROT_FAULT };\n        }\n        /* Update PTE metadata on this page table walk */\n        *pte |= PTE_REFERENCED;\n        if (access_type == ACCESS_WRITE) *pte |= PTE_DIRTY;\n        pfn = pte_get_pfn(*pte);\n        /* Insert translation into TLB for future accesses */\n        int writable = (*pte & PTE_PERM_WRITE) ? 1 : 0;\n        tlb_insert(tlb, &sim->page_table, vpn, pfn, writable,\n                   /*use_random=*/0);  /* 0 = LRU */\n    }\n    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     * Build physical address (same for hit and miss paths)\n     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n    uint32_t paddr = make_physical_addr(pfn, offset);\n    return (xlate_t){\n        .result = XLATE_SUCCESS,\n        .paddr  = paddr,\n        .pfn    = pfn,\n    };\n}\n```\n\n![TLB Hit/Miss Trace Example](./diagrams/diag-m2-tlb-hit-miss-trace.svg)\n\n**The coherence invariant:** After every call to `translate_with_tlb()`, the following must hold:\n1. If the TLB has an entry for `(vpn, active_asid)`, then `tlb_entry.pfn == page_table.entries[vpn].pfn`\n2. If the TLB entry has `TLB_DIRTY` set, then `page_table.entries[vpn]` *may or may not* have `PTE_DIRTY` set â€” the TLB is authoritative for the live dirty state\n3. When a TLB entry is evicted, `page_table.entries[vpn]` must be updated with the TLB entry's dirty/referenced bits before the entry is discarded\n---\n## Context Switch Simulation\nExtend the simulator's state to track the current ASID:\n```c\n/*\n * Simulate a context switch: the OS is switching execution to a new process\n * identified by new_asid.\n *\n * With ASID support: just update the active ASID. The new process's previous\n * TLB entries (if any) are immediately active. The old process's entries\n * become invisible.\n *\n * Without ASID support (or when ASIDs are exhausted): flush all TLB entries.\n *\n * Parameters:\n *   tlb           â€” TLB state\n *   pt            â€” current process's page table (for write-back before any flush)\n *   new_asid      â€” ASID of the process being switched to\n *   force_flush   â€” if true, flush regardless of ASID support\n */\nvoid context_switch(tlb_t *tlb, page_table_t *pt,\n                    uint16_t new_asid, int force_flush) {\n    printf(\"[CONTEXT SWITCH] ASID %u â†’ %u%s\\n\",\n           tlb->active_asid, new_asid,\n           force_flush ? \" (forced flush)\" : \" (ASID preserved)\");\n    if (force_flush) {\n        tlb_flush_all(tlb, pt);  /* writes back all dirty bits first */\n    }\n    /* else: just switch the active ASID â€” old entries become invisible,\n     * new process's entries (if any) become visible immediately */\n    tlb->active_asid = new_asid;\n}\n```\n**Tracing context switch behavior:**\n```\nAccess sequence:\n  [Process 1, ASID=1]\n  R 0x00401000  â†’ TLB MISS, PF, insert(VPN=0x401, PFN=0, ASID=1)\n  R 0x00402000  â†’ TLB MISS, PF, insert(VPN=0x402, PFN=1, ASID=1)\n  R 0x00401000  â†’ TLB HIT  (VPN=0x401, ASID=1) âœ“\n  [CONTEXT SWITCH â†’ Process 2, ASID=2]\n  R 0x00401000  â†’ TLB MISS (ASID=2, no entry for ASID=2, VPN=0x401)\n                  Page table walk â†’ PF â†’ insert(VPN=0x401, PFN=7, ASID=2)\n  [CONTEXT SWITCH â†’ Process 1, ASID=1]\n  R 0x00401000  â†’ TLB HIT  (ASID=1 entry still in TLB!) PFN=0 returned\n                  Process 1's translation survived Process 2's time slice.\n```\nThe last access is the key insight: Process 1's TLB entry survived the context switch because ASID tagging made it invisible (not evicted) during Process 2's execution. When Process 1 resumes, its entries are immediately warm. This is the entire performance value proposition of ASID support.\n---\n## Statistics and Reporting\n```c\n/*\n * TLB statistics reporter.\n * Call at end of simulation or after each benchmark phase.\n */\nvoid tlb_print_stats(const tlb_t *tlb) {\n    uint64_t total = tlb->hits + tlb->misses;\n    double hit_rate = (total > 0)\n        ? 100.0 * (double)tlb->hits / (double)total\n        : 0.0;\n    printf(\"\\n=== TLB Statistics ===\\n\");\n    printf(\"TLB entries:    %d\\n\",  TLB_SIZE);\n    printf(\"Total lookups:  %lu\\n\", total);\n    printf(\"Hits:           %lu\\n\", tlb->hits);\n    printf(\"Misses:         %lu\\n\", tlb->misses);\n    printf(\"Hit rate:       %.2f%%\\n\", hit_rate);\n    printf(\"Evictions:      %lu\\n\", tlb->evictions);\n    printf(\"Full flushes:   %lu\\n\", tlb->flushes);\n}\n/*\n * Updated simulation loop: emit TLB hit/miss classification per access.\n */\nvoid simulate_with_tlb(simulator_t *sim, tlb_t *tlb,\n                       const mem_access_t *accesses, size_t count) {\n    for (size_t i = 0; i < count; i++) {\n        const mem_access_t *acc = &accesses[i];\n        /* Peek at TLB state before the access to classify in output */\n        uint64_t hits_before = tlb->hits;\n        xlate_t result = translate_with_tlb(sim, tlb, acc->vaddr, acc->type);\n        const char *tlb_status = (tlb->hits > hits_before) ? \"HIT \" : \"MISS\";\n        const char *op         = (acc->type == ACCESS_WRITE) ? \"W\" : \"R\";\n        printf(\"[%6zu] %s 0x%08X  TLB:%s\", i, op, acc->vaddr, tlb_status);\n        switch (result.result) {\n            case XLATE_SUCCESS:\n                printf(\"  â†’  phys=0x%08X\\n\", result.paddr);\n                break;\n            case XLATE_PROT_FAULT:\n                printf(\"  â†’  PROTECTION FAULT\\n\");\n                break;\n            case XLATE_OOM:\n                printf(\"  â†’  OUT OF MEMORY\\n\");\n                break;\n            default:\n                printf(\"  â†’  FAULT\\n\");\n        }\n    }\n}\n```\n---\n## Building and Testing\n### Compile\n```bash\ngcc -Wall -Wextra -O2 -std=c11 -o vmsim vmsim.c\n```\n### Test 1: Verify TLB Hit Rate with Repeated Access\nCreate `test_tlb_hits.trace`:\n```\n# Access same 4 pages repeatedly â€” should achieve high TLB hit rate\nR 0x00001000\nR 0x00002000\nR 0x00003000\nR 0x00004000\nR 0x00001004\nR 0x00002004\nR 0x00003004\nR 0x00004004\nR 0x00001008\nR 0x00002008\nR 0x00003008\nR 0x00004008\n```\nExpected statistics after 12 accesses:\n- First 4 accesses: TLB MISS (cold start), page faults\n- Accesses 5â€“12: TLB HIT (same VPNs 0x1, 0x2, 0x3, 0x4 â†’ in TLB from first 4)\n- Hit rate: 8/12 = **66.7%**\n- Page faults: 4\n- TLB evictions: 0 (4 entries used, TLB_SIZE=64)\n### Test 2: LRU Eviction Correctness\nCreate `test_tlb_eviction.trace` with `TLB_SIZE=4`:\n```\n# Access 5 distinct pages with a TLB of size 4\n# After 4 accesses, TLB is full. 5th access evicts the LRU entry.\nR 0x00001000   # TLB MISS â†’ insert VPN=1 (LRU order: 1)\nR 0x00002000   # TLB MISS â†’ insert VPN=2 (LRU order: 2,1)\nR 0x00003000   # TLB MISS â†’ insert VPN=3 (LRU order: 3,2,1)\nR 0x00004000   # TLB MISS â†’ insert VPN=4 (LRU order: 4,3,2,1)\nR 0x00001000   # TLB HIT  VPN=1 â†’ LRU order: 1,4,3,2\nR 0x00005000   # TLB MISS â†’ TLB full â†’ evict VPN=2 (oldest) â†’ insert VPN=5\nR 0x00002000   # TLB MISS â†’ VPN=2 was evicted â†’ page table walk needed\n```\nTo make this trace work, temporarily define `TLB_SIZE 4` at the top of your file for this test.\n### Test 3: ASID Context Switch Correctness\nWrite a C test (not a trace file) to verify ASID behavior programmatically:\n```c\nvoid test_asid_context_switch(void) {\n    simulator_t sim;\n    simulator_init(&sim);\n    tlb_t tlb;\n    tlb_init(&tlb, /*initial_asid=*/1, /*rand_seed=*/42);\n    /* Process 1 (ASID=1): access VPN 0x401 */\n    translate_with_tlb(&sim, &tlb, 0x00401000, ACCESS_READ);\n    assert(tlb.hits   == 0);\n    assert(tlb.misses == 1);\n    /* Access again â€” should be a TLB hit */\n    translate_with_tlb(&sim, &tlb, 0x00401008, ACCESS_READ);\n    assert(tlb.hits   == 1);   /* same VPN=0x401, offset differs â€” HIT */\n    assert(tlb.misses == 1);\n    /* Context switch to Process 2 (ASID=2) â€” no flush */\n    context_switch(&tlb, &sim.page_table, /*new_asid=*/2, /*force_flush=*/0);\n    /* VPN 0x401 miss: Process 2's ASID=2 has no entry for VPN=0x401 */\n    translate_with_tlb(&sim, &tlb, 0x00401000, ACCESS_READ);\n    assert(tlb.misses == 2);   /* MISS despite VPN=0x401 being in TLB with ASID=1 */\n    /* Context switch back to Process 1 (ASID=1) â€” no flush */\n    context_switch(&tlb, &sim.page_table, /*new_asid=*/1, /*force_flush=*/0);\n    /* VPN 0x401 hit: Process 1's entry survived in the TLB! */\n    translate_with_tlb(&sim, &tlb, 0x00401000, ACCESS_READ);\n    assert(tlb.hits == 2);     /* HIT â€” ASID=1 entry is still there */\n    printf(\"ASID context switch test: PASSED\\n\");\n}\n```\n### Test 4: Dirty Bit Write-Back\n```c\nvoid test_dirty_writeback(void) {\n    simulator_t sim;\n    simulator_init(&sim);\n    tlb_t tlb;\n    tlb_init(&tlb, 1, 42);\n    /* Write access to VPN 0x100 â€” page fault, then TLB insert with DIRTY */\n    translate_with_tlb(&sim, &tlb, 0x00100000, ACCESS_WRITE);\n    /* Find the TLB entry and confirm dirty bit is set */\n    int found = 0;\n    for (int i = 0; i < TLB_SIZE; i++) {\n        if ((tlb.entries[i].flags & TLB_VALID) && tlb.entries[i].vpn == 0x100) {\n            assert(tlb.entries[i].flags & TLB_DIRTY);\n            found = 1;\n            break;\n        }\n    }\n    assert(found);\n    /* Flush the TLB â€” this should write back the dirty bit to the PTE */\n    tlb_flush_all(&tlb, &sim.page_table);\n    /* Verify: PTE's dirty bit was written back */\n    pte_t pte = sim.page_table.entries[0x100];\n    assert(pte & PTE_DIRTY);\n    printf(\"Dirty bit write-back test: PASSED\\n\");\n}\n```\n---\n## Common Pitfalls and How to Avoid Them\n| Pitfall | Symptom | Fix |\n|---------|---------|-----|\n| Checking permissions before `valid` in TLB lookup | Prot fault on empty entries | Check `TLB_VALID` first, always |\n| Not writing back dirty/referenced bits on eviction | PTE dirty state stale; page replacement in M4 will fail to write dirty pages | Call `tlb_writeback_entry()` before every eviction |\n| Not invalidating TLB entry when PTE is modified | Stale TLB serves old translation after page eviction (M4) | Call `tlb_flush_page(vpn)` whenever PTE.valid is cleared |\n| Using `TLB_SIZE` not power-of-2 for random eviction | Modulo bias skews eviction distribution | Use LCG PRNG + mod, or mask with `(TLB_SIZE - 1)` if power-of-2 |\n| Forgetting ASID check in lookup (only checking VPN) | Process B sees Process A's translations â€” memory isolation broken | Three-way check: valid AND asid AND vpn |\n| Setting dirty in TLB on miss instead of tracking in PTE | Double-setting or missing dirty state during page table walk | The miss path updates the PTE directly; insert copies writable flag, not dirty |\n| LRU counter overflow | After 256 accesses, `uint8_t` wraps to 0, making all entries look \"new\" | Cap at 255 (`if counter < 255: counter++`) or use `uint64_t` global tick |\n| Non-deterministic test failures with random eviction | Tests pass sometimes, fail others | Always use a fixed `rand_seed` in tests |\n---\n## Hardware Soul: What Your Simulator Abstracts Away\nYour software TLB does sequential linear scan: O(TLB_SIZE) comparisons per lookup. Real hardware does something qualitatively different:\n**Content-Addressable Memory (CAM):** A hardware TLB is implemented as a CAM â€” a memory array where you broadcast the search key (VPN + ASID) and all entries compare against it *simultaneously* using parallel combinational logic. A 64-entry TLB completes its lookup in a single clock cycle (~0.3ns at 3GHz), regardless of entry count. Your 64-iteration loop costs more than a TLB miss would in hardware â€” the abstraction leaks here. This is fine for the simulator's goals (correctness and statistical measurement), but remember that real TLB performance is O(1) not O(n).\n**VIPT L1 Cache:** Modern CPUs use Virtually-Indexed, Physically-Tagged (VIPT) L1 caches. When a memory instruction executes:\n1. The CPU begins the TLB lookup (VPN â†’ PFN) in parallel\n2. The CPU simultaneously uses the virtual address's lower bits (which are identical to the physical address's lower bits â€” the page offset) to index into the L1 cache's set\n3. By the time the cache fetch returns the candidate cache line, the TLB has also completed the PFN lookup\n4. The CPU compares the returned cache line's *physical* tag against the PFN from the TLB\nThis \"race\" completes in ~4 cycles. If the TLB lookup had to complete *before* the cache lookup could begin, L1 access would take ~5â€“6 cycles instead of ~4. The VIPT design exploits the fact that the page offset bits are unchanged by translation to parallelize the two lookups. This is why L1 cache size is bounded by `page_size Ã— associativity`: to keep the cache-set index entirely within the offset bits. A 4-way associative L1 with 4KB pages can be at most 16KB (4 Ã— 4KB). Larger L1 caches require more associativity or larger page sizes.\n**Branch prediction and TLB:** The CPU's branch predictor attempts to speculatively fetch instructions from the predicted next address. That speculative fetch must also go through the TLB. If the TLB entry for the speculatively accessed page isn't present, the CPU must either stall the speculation or handle the TLB miss speculatively. This is one of the reasons TLB misses have such high latency variance â€” they can disrupt the pipeline in ways that a cache miss to L3 does not.\n---\n## Knowledge Cascade: What the TLB Unlocks\n**1. Huge Pages â€” Covering More Ground Per TLB Entry**\nA 64-entry TLB with 4KB pages covers 64 Ã— 4096 = **262 KB** of virtual address space without a miss. Add one access to the 263rd KB and you spill out of TLB coverage, causing a miss. Now consider 2MB huge pages: each TLB entry covers 2MB instead of 4KB. A 64-entry TLB covers 64 Ã— 2MB = **128 MB** of address space. With 1GB huge pages (available on x86-64): 64GB covered.\nThis is exactly why PostgreSQL, Linux's huge page support, JVM G1GC, and DPDK all support huge page allocation (`MAP_HUGETLB` on Linux, `SHM_HUGETLB`). A database buffer pool accessing 8GB of data with 4KB pages and a 64-entry TLB would thrash the TLB on every scan â€” every 256th access (64 Ã— 4KB = 256KB) escapes TLB coverage. With 2MB pages, the TLB covers 128MB before spilling; with 1GB pages, the entire buffer pool fits in 8 TLB entries. The TLB miss rate drops from near-100% to near-0% for sequential scans.\n**2. Spectre and Meltdown â€” TLBs as Security Boundaries**\nMeltdown (CVE-2017-5754) exploited the fact that the CPU speculatively executes instructions using kernel memory even before the permission check in the TLB/PTE completes. The kernel memory's data leaks into the CPU cache before the permission fault is raised. The OS patch (KPTI) separated kernel and user page tables entirely â€” but this meant every syscall (entering kernel mode) required switching page tables, which required either a full TLB flush or an ASID/PCID change. On CPUs without PCID support: full flush on every syscall. On I/O-heavy workloads (databases, web servers making many syscalls): 5â€“30% throughput regression.\nCPUs with PCID support use it like your ASID simulation: kernel gets one PCID, user gets another. Switching between them doesn't flush the TLB â€” both sets of entries coexist. Performance impact: reduced to ~1â€“2% on most workloads. Understanding your ASID implementation directly maps to understanding why PCID support was the hardware fix for a security crisis.\n**3. The True Cost of a Context Switch**\nComputer science courses teach that a context switch costs \"saving and restoring registers.\" In reality, the dominant cost on modern hardware is **TLB pollution**. When the scheduler runs a new process:\n- Its TLB entries (from its last time slice) may have been partially evicted\n- The first 10â€“100 microseconds of execution are spent rebuilding TLB entries\n- Each TLB miss costs ~10â€“100 cycles (hardware page walk, possibly L3 cache miss for the PTE)\n- For a process with a 10MB working set at 4KB pages: ~2500 distinct pages, far more than a 64-entry TLB\nOperating systems exploit this by: (a) using ASID/PCID to preserve entries across switches, (b) scheduling processes in time slices long enough to amortize the warm-up cost, (c) using NUMA-aware scheduling to keep processes on CPUs whose L3 cache still holds their working set. The kernel scheduler's decisions are intimately connected to TLB behavior â€” something invisible from a pure scheduling-theory perspective.\n**4. JIT Compilers and TLB Pressure**\nV8 (Chrome's JavaScript engine), HotSpot (JVM), and LuaJIT allocate JIT-compiled code in executable memory regions. Naively, each JIT compilation might call `mmap()` and get a new anonymous region scattered across virtual memory. If these regions span many pages, they consume TLB entries for instruction fetches in addition to TLB entries for data. A program that JITs many small functions and stores them in scattered pages creates TLB pressure from both sides â€” code and data compete for the same TLB.\nThis is why production JIT runtimes use a **code arena**: a single large `mmap()` region divided internally for JIT output. All compiled code lives in a contiguous virtual address range, maximally sharing TLB entries. V8's `CodeSpace` and HotSpot's `CodeCache` are exactly this pattern. Your simulator could be extended to model two separate TLBs (iTLB for instruction fetches, dTLB for data) â€” which is how real x86-64 CPUs work. Each has ~64â€“2048 entries and can be measured independently.\n**5. Database Buffer Pools â€” Same Mathematics, Different Layer**\nPostgreSQL's shared buffer pool and InnoDB's buffer pool implement the *same algorithm* as your TLB â€” but at the disk-to-RAM boundary instead of the RAM-to-CPU boundary. A buffer pool entry: `{page_id â†’ frame_in_RAM, dirty_bit, pin_count}`. Buffer pool eviction: clock algorithm or LRU. Buffer pool flush: write dirty pages to disk before evicting. Page fault equivalent: buffer pool miss â†’ read from disk.\nThe translation table you built and the buffer manager these databases use are isomorphic structures solving the same problem at different points in the memory hierarchy. The TLB covers RAMâ†’CPU; the buffer pool covers diskâ†’RAM. Understanding one deeply means you understand the other â€” the same LRU, clock, and optimal algorithms appear in both, just with different latency numbers (1ns vs 10ms) and different eviction costs (1 cycle vs 10ms disk write).\n---\n## What You've Built and What's Missing\n**You have:**\n- A fully-associative TLB with configurable size (16, 32, 64 entries)\n- LRU and random (seeded) eviction policies\n- ASID-tagged entries for context switch support without full flushes\n- Write-back of dirty/referenced bits to the page table on eviction\n- Full, ASID-targeted, and page-targeted flush operations\n- Integrated translation path: TLB first, page table on miss\n- Statistics: hits, misses, hit rate, evictions, flushes\n**What's still painful:** The flat page table from Milestone 1 consumes 4MB regardless of how sparse the address space is. Two processes each with a flat page table cost 8MB of simulator RAM in page tables alone â€” just for the mapping structures. A real server running thousands of processes would drown in page table overhead.\nMilestone 3 fixes this with multi-level page tables: instead of one giant array, you'll build a tree structure where inner nodes are only allocated when the corresponding virtual address regions are actually mapped. A process using 10 pages uses only the specific page table nodes needed to describe those 10 pages â€” not a 1M-entry flat array.\nThe TLB you built here will sit in front of the multi-level page table walk in Milestone 3. A TLB miss that triggers a two-level walk costs 2 memory accesses. A TLB miss with a three-level walk costs 3. This is why TLB hit rate is *even more critical* for multi-level tables than for the flat table you started with â€” each level multiplies the miss penalty.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: virtual-memory-sim-m3 -->\n<!-- MS_ID: virtual-memory-sim-m3 -->\n# Milestone 3: Multi-Level Page Tables\n## The Problem You're Actually Solving (It's Not What You Think)\nHere's the misconception worth destroying before you write a single line of code:\n*\"Multi-level page tables exist to handle bigger address spaces. A single-level table can't address enough memory, so we need more levels â€” like adding digits to a phone number.\"*\nThis is wrong, and the wrongness is deep enough to corrupt every design decision you'd make afterward.\nRun the numbers on a single-level page table. You built one in Milestone 1. It has `2^20 = 1,048,576` entries for a 32-bit address space with 4KB pages. Each PTE is 4 bytes. Total cost: **4,194,304 bytes = 4 MB per process**. That 4MB exists in memory even if your process uses exactly three pages â€” a stack page, a code page, and one data page. You've paid 4MB to describe 12KB of actual usage. The ratio is 341:1 overhead.\nNow multiply by the number of processes on your system. A server running 100 concurrent processes: **400MB of page tables** just for the mapping structures, before storing a single byte of actual program data. Run 1000 processes and you've consumed 4GB â€” exceeding the total available physical memory on many systems â€” just for the empty arrays mapping virtual pages no one will ever use.\nThis is not a theoretical concern. It was the real, production crisis that drove the evolution from flat page tables to hierarchical ones. The problem isn't address space *size* â€” it's address space *sparsity*. Real processes use tiny islands of virtual addresses separated by vast unmapped voids. A typical process maps a few pages for code, a few for stack, a few for heap, and then nothing else for the next 4 billion bytes of addressable space. Paying for all 4 billion bytes' worth of PTE slots is pure waste.\n**The fix is on-demand allocation of the mapping structure itself.** Instead of one flat array pre-allocated for all possible virtual pages, build a tree. Allocate tree nodes only for branches that are actually used. A process using 3 scattered pages needs only the path through the tree to reach those 3 pages â€” not the entire tree. The unmapped regions simply have `NULL` pointers at some intermediate level, pruning away entire subtrees at zero cost.\nThis is the revelation: **multi-level page tables are a sparse data structure optimization**. They are conceptually identical to a [trie](https://en.wikipedia.org/wiki/Trie) â€” a tree where the path from root to leaf spells out the key (here: the virtual address bits), and missing branches are `NULL` pointers that save memory. The number of levels is not about addressing capacity â€” it's about how finely you want to granularize the sparsity.\n\n![Memory Overhead: Flat vs Two-Level for Sparse Address Space](./diagrams/diag-m3-sparse-vs-flat-memory-overhead.svg)\n\n---\n## Why Hierarchical Indexing Saves Memory for Sparse Structures\n[[EXPLAIN:why-hierarchical/multi-level-indexing-saves-memory-for-sparse-structures|Why hierarchical/multi-level indexing saves memory for sparse structures â€” the trie principle applied to page tables, and why missing branches are free]]\nLet's make the savings concrete before writing any code.\n**Flat table (Milestone 1):**\n- Size: `2^20` entries Ã— 4 bytes = **4,194,304 bytes = 4MB**, always, regardless of usage\n- A process using 3 pages: 4MB for 3 valid PTEs. 1,048,573 wasted PTEs.\n**Two-level table:**\n- Level 1: Page directory â€” `2^10 = 1024` entries Ã— 4 bytes = **4KB**, always allocated (one per process)\n- Level 2: Page tables â€” `2^10 = 1024` entries Ã— 4 bytes = **4KB each**, allocated *only when needed*\nFor a process using 3 pages that happen to fall in 3 different page directory regions:\n- 1 page directory: 4KB\n- 3 second-level page tables: 3 Ã— 4KB = 12KB\n- **Total: 16KB** instead of 4MB\n- **Savings: 99.6%** for this workload\nFor a process using 3 pages that fall within the *same* 4MB region (same page directory entry):\n- 1 page directory: 4KB\n- 1 second-level page table: 4KB (covers the whole 4MB region)\n- **Total: 8KB** instead of 4MB\n- **Savings: 99.8%**\nFor a process using all of physical memory at maximum density (64 frames, contiguous):\n- 1 page directory: 4KB\n- 1 second-level page table: 4KB (64 pages fit within one 4MB region)\n- **Total: 8KB** â€” far less than 4MB flat table\nThe worst case for a two-level table is a process that uses exactly one page from every possible 4MB region â€” 1024 page directory entries each pointing to a separate second-level table, each containing only one valid PTE. That costs: 4KB + 1024 Ã— 4KB = **4100KB â‰ˆ 4MB** â€” matching the flat table in the absolute worst case. But this access pattern is pathological and never occurs in real programs.\n---\n## The Virtual Address Decomposition: Three Fields Now\nIn Milestone 1, you split a 32-bit virtual address into two parts: a 20-bit VPN and a 12-bit offset. Now you split it into *three* parts: a page directory index, a page table index, and the same 12-bit offset.\n```\n32-bit virtual address (4,294,967,296 byte address space):\n 31                22 21                12 11                 0\n â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n â”‚  DIR INDEX (10b) â”‚ TABLE INDEX (10b)â”‚    OFFSET (12b)      â”‚\n â”‚  bits [31:22]    â”‚  bits [21:12]    â”‚   bits [11:0]        â”‚\n â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n        â†“                   â†“                   â†“\n Index into the        Index into the       Byte within\n page directory        page table           the physical frame\n (1024 entries)        (1024 entries)       (unchanged in\n                                            physical addr)\n```\nEach 10-bit index can address 2^10 = 1024 entries. At the page directory level, each entry covers a region of 1024 Ã— 4096 = **4,194,304 bytes = 4MB** of virtual address space. At the page table level, each entry covers exactly one 4KB page.\n\n![Two-Level Address Decomposition: Dir Index + Table Index + Offset](./diagrams/diag-m3-address-split-two-level.svg)\n\nThe extraction functions:\n```c\n/*\n * Address decomposition for two-level page table.\n *\n * Bit layout (32-bit virtual address, 4KB pages):\n *   bits [31:22] â€” page directory index (PDI): 10 bits, 0â€“1023\n *   bits [21:12] â€” page table index    (PTI): 10 bits, 0â€“1023\n *   bits [11:0]  â€” page offset              : 12 bits, 0â€“4095\n *\n * Each level has 1024 entries Ã— 4 bytes = 4KB per table â€” exactly one page.\n * This is deliberate: each table fits in a single physical frame.\n */\n#define PD_INDEX_BITS    10u\n#define PT_INDEX_BITS    10u\n#define PAGE_OFFSET_BITS 12u   /* unchanged from Milestone 1 */\n#define PD_INDEX_SHIFT   (PT_INDEX_BITS + PAGE_OFFSET_BITS)  /* 22 */\n#define PT_INDEX_SHIFT   (PAGE_OFFSET_BITS)                   /* 12 */\n#define PD_SIZE          (1u << PD_INDEX_BITS)   /* 1024 entries */\n#define PT_SIZE          (1u << PT_INDEX_BITS)   /* 1024 entries */\n#define PD_INDEX_MASK    ((1u << PD_INDEX_BITS) - 1)   /* 0x3FF */\n#define PT_INDEX_MASK    ((1u << PT_INDEX_BITS) - 1)   /* 0x3FF */\n#define PAGE_OFFSET_MASK ((1u << PAGE_OFFSET_BITS) - 1) /* 0xFFF */\nstatic inline uint32_t pd_index(uint32_t vaddr) {\n    return (vaddr >> PD_INDEX_SHIFT) & PD_INDEX_MASK;\n}\nstatic inline uint32_t pt_index(uint32_t vaddr) {\n    return (vaddr >> PT_INDEX_SHIFT) & PT_INDEX_MASK;\n}\nstatic inline uint32_t page_offset(uint32_t vaddr) {\n    return vaddr & PAGE_OFFSET_MASK;\n}\n```\n**Verify with a concrete example.** Take virtual address `0x004056A8`:\n```\n0x004056A8 in binary:\n  0000 0000 0100 0000 0101 0110 1010 1000\nbits [31:22] = 00 0000 0001 = 0x001 = 1     â†’ PDI = 1\nbits [21:12] = 00 0000 0101 = 0x005 = 5     â†’ PTI = 5\nbits [11:0]  = 0110 1010 1000 = 0x6A8 = 1704 â†’ offset = 1704\n```\nThe walk: `page_directory[1]` â†’ find the second-level page table â†’ `page_table[5]` â†’ PFN â†’ physical address = `(PFN << 12) | 0x6A8`.\n**Pitfall â€” most significant bits select the directory.** This is the most common mistake. You might instinctively grab the *low* bits of the VPN for the directory index and the *high* bits for the table index. The correct ordering is: the *most significant* bits of the virtual address select the top-level directory. Think of it like a postal code: the largest geographical unit (country) comes first, then region, then city. The high bits of a virtual address identify the coarse region; the lower bits identify the fine-grained page within that region.\n---\n## The CR3 Register: The Root of Everything\n\n> **ğŸ”‘ Foundation: CR3 is a CPU register holding the physical address of the active process's top-level page directory**\n> \n> **What it IS**\nThe CR3 register (Control Register 3) is a specialized x86 CPU register that acts as the \"root\" of the virtual memory system. It stores the physical address of the top-level page directory (in 64-bit mode, this is the PML4 table). Every time the CPU needs to translate a virtual address into a physical one, it starts its journey by looking at the address held in CR3.\n\n**WHY you need it right now**\nIn systems programming, particularly when writing a kernel or a hypervisor, you are responsible for defining how memory is mapped. Loading a value into CR3 is the definitive act of \"turning on\" or \"switching\" a virtual address space. When an operating system switches from Process A to Process B, it isn't moving data in RAM; it is simply loading Process B's page table address into CR3. This instantly changes the CPU's entire view of the world.\n\n**Key Insight / Mental Model**\nThink of CR3 as the **\"You Are Here\" pointer on a master map**. The page tables are the map of the entire city, but the CPU canâ€™t see the map until you hand it the coordinate for the very first page. Changing CR3 is like swapping the entire map of New York for a map of London in a single instruction.\n\nOn real x86 hardware, the `CR3` register (Control Register 3) holds the physical base address of the currently active page directory. Every address translation begins with CR3. The hardware page walker reads CR3, uses it to fetch the page directory, walks down the tree, and arrives at a PTE.\nIn your simulator, you'll model CR3 as a field in your simulator state â€” a physical address pointing to the root page directory of the active process.\n```c\n/*\n * Page Directory Entry (PDE) â€” entry in the top-level page directory.\n *\n * A PDE is NOT a PTE. It does NOT point to a physical frame for data.\n * It points to the PHYSICAL BASE ADDRESS of a second-level page table.\n *\n * Bit layout:\n *   [31:12] â€” physical base address of second-level page table (20 bits)\n *             This is 4KB-aligned (low 12 bits are zero), so only 20 bits needed.\n *   [11:1]  â€” reserved / available for OS use\n *   [0]     â€” present bit: 1 = second-level table exists, 0 = not allocated\n *\n * When present=0: the entire 4MB region this entry covers is unmapped.\n * No second-level table is allocated. NULL pointer semantics.\n *\n * Size: 4 bytes per PDE\n * A full page directory: 1024 Ã— 4 = 4096 bytes = exactly 1 physical page.\n */\ntypedef uint32_t pde_t;\n#define PDE_PRESENT      (1u << 0)\n#define PDE_PT_ADDR_MASK (0xFFFFF000u)  /* bits [31:12] */\n#define PDE_PT_ADDR_SHIFT 12u\nstatic inline int pde_is_present(pde_t pde) {\n    return (pde & PDE_PRESENT) != 0;\n}\nstatic inline uint32_t pde_get_pt_phys(pde_t pde) {\n    return pde & PDE_PT_ADDR_MASK;\n}\nstatic inline pde_t pde_make(uint32_t pt_phys_base) {\n    /* pt_phys_base must be 4KB-aligned */\n    return (pt_phys_base & PDE_PT_ADDR_MASK) | PDE_PRESENT;\n}\n```\n\n![Page Directory Entry vs Page Table Entry â€” Structural Comparison](./diagrams/diag-m3-pde-vs-pte.svg)\n\n**The critical distinction: PDE vs PTE.** A PDE points to a page table structure â€” a metadata object that itself contains more entries. A PTE points to an actual physical frame where user data lives. Confusing these is the #1 structural error in Milestone 3. When you follow a PDE, you arrive at another table. When you follow a PTE, you arrive at data.\n```c\n/*\n * Page Table Entry (PTE) â€” unchanged from Milestone 1.\n * Reproduced here for clarity; use the same pte_t typedef.\n *\n * A PTE points to a PHYSICAL FRAME (data).\n * A PDE points to a PHYSICAL FRAME (containing a page table).\n *\n * Both are 4 bytes. The difference is in what the pointed-to frame contains.\n */\ntypedef uint32_t pte_t;   /* same as Milestone 1 */\n```\n---\n## The Full Data Model: Two-Level Simulator State\nNow define the complete data structures for the multi-level simulator. Notice the fundamental change: the page table is no longer a flat `pte_t[1048576]` array. It's a tree rooted at a page directory.\n```c\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n * Physical memory â€” unchanged from Milestone 1 concept, reused here\n *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n#define PAGE_SIZE       4096u\n#define NUM_FRAMES      64u\ntypedef struct {\n    uint8_t data[PAGE_SIZE];\n    bool    in_use;\n} physical_frame_t;\nphysical_frame_t phys_mem[NUM_FRAMES];\n/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n * Page directory â€” one per process, always allocated at process creation.\n * Contains 1024 PDEs. Total size: 1024 Ã— 4 = 4096 bytes = 1 physical page.\n *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\ntypedef struct {\n    pde_t entries[PD_SIZE];   /* 1024 page directory entries */\n} page_directory_t;\n/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n * Second-level page table â€” allocated on demand, one per 4MB region.\n * Contains 1024 PTEs. Total size: 1024 Ã— 4 = 4096 bytes = 1 physical page.\n *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\ntypedef struct {\n    pte_t entries[PT_SIZE];   /* 1024 page table entries */\n} page_table_t;\n/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n * Process address space â€” owns one page directory and up to 1024\n * second-level page tables, allocated on demand.\n *\n * In a real OS, these structures live IN physical memory (as page-sized\n * objects assigned specific physical frames). In the simulator, we use\n * heap allocation and track overhead separately.\n *\n * Memory cost (worst case):\n *   1 page_directory_t:              4,096 bytes\n *   up to 1024 page_table_t:  1024 Ã— 4,096 = 4,194,304 bytes\n *   Total worst case:         ~4 MB â€” same as flat table\n *   Typical sparse process:   4KB + few Ã— 4KB â‰ª 4MB\n *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\ntypedef struct {\n    page_directory_t *pgdir;       /* root page directory (always allocated) */\n    page_table_t     *pgtables[PD_SIZE]; /* second-level tables, NULL if not present */\n    uint16_t          asid;        /* address space ID for TLB (Milestone 2) */\n    /* Overhead tracking */\n    size_t            pt_bytes_allocated; /* bytes used by page table structures */\n} process_t;\n/*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n * Simulator state â€” adds CR3 and multi-process support\n *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\ntypedef struct {\n    process_t  *active_process;    /* currently executing process             */\n    uint32_t    cr3;               /* physical address of active page dir     */\n    /*\n     * In the simulator, cr3 is symbolic â€” it identifies which process_t\n     * is active rather than a literal physical address, because we use\n     * heap-allocated page directory structs. In a real system, cr3 would\n     * be the actual physical address of the pgdir frame.\n     */\n    /* Statistics */\n    uint64_t    total_accesses;\n    uint64_t    page_faults;\n    uint64_t    protection_faults;\n    uint64_t    pt_walks;          /* number of page table walks performed    */\n    uint64_t    tlb_hits;          /* tracked here for combined reporting     */\n} ml_simulator_t;\n```\n---\n## Allocating Structures: The Simulated Memory Manager\nIn a real OS, page directories and page tables are themselves stored in physical frames â€” they're just pages of memory with a specific interpretation. The OS maintains a free-frame list and assigns frames to page table structures as needed.\nIn your simulator, you'll use `malloc()` for simplicity, but you'll track every allocation byte-for-byte so your overhead comparison is accurate.\n```c\n/*\n * Allocate a new second-level page table.\n *\n * All PTEs initialized to 0 (valid=0, all permissions cleared).\n * In a real OS: claim one physical frame, zero it, record it as a page table.\n * Here: heap alloc + memset.\n *\n * Returns NULL on allocation failure.\n */\nstatic page_table_t *alloc_page_table(process_t *proc) {\n    page_table_t *pt = malloc(sizeof(page_table_t));\n    if (!pt) return NULL;\n    memset(pt, 0, sizeof(page_table_t));\n    proc->pt_bytes_allocated += sizeof(page_table_t);\n    return pt;\n}\n/*\n * Initialize a new process with an empty two-level page table.\n *\n * Allocates the page directory immediately (always needed).\n * Second-level tables start as NULL (allocated on demand).\n */\nprocess_t *process_create(uint16_t asid) {\n    process_t *proc = malloc(sizeof(process_t));\n    if (!proc) return NULL;\n    proc->pgdir = malloc(sizeof(page_directory_t));\n    if (!proc->pgdir) { free(proc); return NULL; }\n    memset(proc->pgdir, 0, sizeof(page_directory_t));   /* all PDEs: present=0 */\n    for (int i = 0; i < PD_SIZE; i++) {\n        proc->pgtables[i] = NULL;   /* no second-level tables yet */\n    }\n    proc->asid               = asid;\n    proc->pt_bytes_allocated = sizeof(page_directory_t);  /* 4KB for pgdir */\n    return proc;\n}\n/*\n * Free all page table memory for a process on exit.\n * Walks the directory and frees every allocated second-level table.\n */\nvoid process_destroy(process_t *proc) {\n    for (int i = 0; i < PD_SIZE; i++) {\n        if (proc->pgtables[i]) {\n            free(proc->pgtables[i]);\n        }\n    }\n    free(proc->pgdir);\n    free(proc);\n}\n/*\n * Memory overhead report for one process.\n * Compares actual allocation vs flat-table cost.\n */\nvoid process_print_overhead(const process_t *proc) {\n    size_t flat_cost     = (size_t)PD_SIZE * PT_SIZE * sizeof(pte_t); /* 4MB */\n    size_t actual_cost   = proc->pt_bytes_allocated;\n    int    tables_alloc  = 0;\n    for (int i = 0; i < PD_SIZE; i++) {\n        if (proc->pgtables[i]) tables_alloc++;\n    }\n    printf(\"=== Page Table Memory Overhead (ASID=%u) ===\\n\", proc->asid);\n    printf(\"Flat table cost:        %zu bytes (%zu KB)\\n\",\n           flat_cost, flat_cost / 1024);\n    printf(\"Two-level actual cost:  %zu bytes (%zu KB)\\n\",\n           actual_cost, actual_cost / 1024);\n    printf(\"Page directory:         4096 bytes (always)\\n\");\n    printf(\"Second-level tables:    %d allocated Ã— 4096 = %d bytes\\n\",\n           tables_alloc, tables_alloc * 4096);\n    printf(\"Savings:                %.1f%%\\n\",\n           100.0 * (1.0 - (double)actual_cost / (double)flat_cost));\n}\n```\n---\n## The Page Table Walk: Following the Chain\nThe two-level page table walk is the core algorithm of this milestone. You follow a chain of pointers â€” CR3 â†’ page directory â†’ page table â†’ PTE â†’ physical frame â€” with the option to short-circuit at any level if a `NULL`/not-present entry indicates the region is unmapped.\n\n![Two-Level Page Table Walk â€” Complete Data Walk](./diagrams/diag-m3-page-table-walk.svg)\n\n```c\n/*\n * Two-level page table walk.\n *\n * Given a virtual address and access type, traverses:\n *   CR3 â†’ page_directory[PDI] â†’ page_table[PTI] â†’ PFN\n *\n * On-demand allocation: if the page directory entry for PDI has present=0,\n * we have two choices:\n *   - For a data access: page fault (the region is unmapped)\n *   - For a demand-paging fault: allocate a second-level table + new frame\n *\n * Return values:\n *   XLATE_SUCCESS    â€” paddr is valid\n *   XLATE_PAGE_FAULT â€” page not present (resolved via demand paging if OOM ok)\n *   XLATE_PROT_FAULT â€” permission violation\n *   XLATE_OOM        â€” no free frames for demand paging\n */\nxlate_t ml_translate(ml_simulator_t *sim, uint32_t vaddr, access_type_t atype) {\n    sim->total_accesses++;\n    uint32_t pdi    = pd_index(vaddr);\n    uint32_t pti    = pt_index(vaddr);\n    uint32_t offset = page_offset(vaddr);\n    process_t *proc = sim->active_process;\n    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     * Level 1: Consult the page directory.\n     *\n     * If the PDE is not present, the entire 4MB region is unmapped.\n     * Demand-allocate a second-level page table for this region.\n     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n    if (!pde_is_present(proc->pgdir->entries[pdi])) {\n        /*\n         * DEMAND ALLOCATION of second-level page table.\n         * This is analogous to demand paging but for the page TABLE ITSELF:\n         * we only create the 1024-entry page table structure when the first\n         * access to that 4MB region occurs.\n         */\n        page_table_t *new_pt = alloc_page_table(proc);\n        if (!new_pt) {\n            fprintf(stderr, \"[OOM] Cannot allocate second-level page table \"\n                    \"for PDI=%u\\n\", pdi);\n            return (xlate_t){ .result = XLATE_OOM };\n        }\n        proc->pgtables[pdi] = new_pt;\n        /*\n         * Update the PDE to point to the new page table.\n         * In a real OS, new_pt's physical address would be a frame number\n         * Ã— 4096. In the simulator, we store the pointer cast to uint32_t\n         * for lookup, but the PDE conceptually holds a physical address.\n         *\n         * To keep physical addressing clean, we track the pgtables[] array\n         * directly and use PDI as the index. The PDE present bit signals\n         * that the entry is valid.\n         */\n        proc->pgdir->entries[pdi] = pde_make(\n            (uint32_t)(uintptr_t)new_pt   /* symbolic physical address */\n        );\n        /* Log the on-demand allocation */\n        fprintf(stderr, \"[PT ALLOC] PDI=%u: allocated new page table \"\n                \"(total PT memory: %zu KB)\\n\",\n                pdi, proc->pt_bytes_allocated / 1024);\n    }\n    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     * Level 2: Consult the second-level page table.\n     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n    sim->pt_walks++;\n    page_table_t *pt  = proc->pgtables[pdi];\n    pte_t        *pte = &pt->entries[pti];\n    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     * Is this specific page in physical memory?\n     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n    if (!(*pte & PTE_VALID)) {\n        /* Page fault: demand-page this specific page */\n        sim->page_faults++;\n        fprintf(stderr, \"[PAGE FAULT] vaddr=0x%08X  PDI=%u  PTI=%u\\n\",\n                vaddr, pdi, pti);\n        uint32_t frame = alloc_free_frame();\n        if (frame == UINT32_MAX) {\n            fprintf(stderr, \"[OOM] No free frames â€” need page replacement \"\n                    \"(Milestone 4)\\n\");\n            return (xlate_t){ .result = XLATE_OOM };\n        }\n        /* Install PTE pointing to newly allocated frame */\n        *pte = pte_make(frame, /*readable=*/1,\n                        /*writable=*/(atype == ACCESS_WRITE));\n    }\n    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     * Permission check â€” only after confirming valid=1\n     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n    if (atype == ACCESS_WRITE && !(*pte & PTE_PERM_WRITE)) {\n        sim->protection_faults++;\n        fprintf(stderr, \"[PROT FAULT] Write to read-only page \"\n                \"vaddr=0x%08X\\n\", vaddr);\n        return (xlate_t){ .result = XLATE_PROT_FAULT };\n    }\n    /* Update access metadata */\n    *pte |= PTE_REFERENCED;\n    if (atype == ACCESS_WRITE) *pte |= PTE_DIRTY;\n    uint32_t pfn   = pte_get_pfn(*pte);\n    uint32_t paddr = make_physical_addr(pfn, offset);\n    return (xlate_t){\n        .result = XLATE_SUCCESS,\n        .paddr  = paddr,\n        .pfn    = pfn,\n    };\n}\n```\n\n![On-Demand Second-Level Table Allocation](./diagrams/diag-m3-on-demand-allocation.svg)\n\n**The critical ordering invariant:** You must check the PDE *before* dereferencing the second-level page table pointer. Dereferencing a NULL `pgtables[pdi]` is undefined behavior in C â€” it won't raise a controlled page fault, it will crash your simulator with a segfault. The `pde_is_present()` check is your guard.\n---\n## On-Demand Second-Level Table Allocation: The Full Picture\nThe on-demand allocation pattern deserves explicit visualization. The first access to any virtual address in a previously unmapped 4MB region triggers *two* allocations before data access is possible:\n1. **Page table allocation**: A new 4KB `page_table_t` is allocated to represent that 4MB region\n2. **Frame allocation**: A physical frame is allocated for the actual page being accessed\nThese are separate costs. The page table allocation overhead is amortized across all pages in that 4MB region â€” the second access within the same region incurs only the frame allocation.\n```\nFirst access to 0x00401000 (PDI=1, PTI=1, offset=0x000):\nBefore:\n  proc->pgdir->entries[1] = 0x00000000 (present=0)\n  proc->pgtables[1]       = NULL\nStep 1 â€” Allocate page table for PDI=1:\n  new_pt = malloc(sizeof(page_table_t))  // 4096 bytes, zeroed\n  proc->pgtables[1]       = new_pt\n  proc->pgdir->entries[1] = pde_make(new_pt)  // present=1\nStep 2 â€” Page fault for PDI=1, PTI=1:\n  frame = alloc_free_frame()  // e.g., frame 0\n  pt->entries[1] = pte_make(0, readable=1, writable=1)\nStep 3 â€” Return physical address:\n  paddr = (0 << 12) | 0x000 = 0x00000000\nSecond access to 0x004050A8 (PDI=1, PTI=5, offset=0x0A8):\nBefore:\n  proc->pgdir->entries[1] = pde_make(new_pt)  (present=1, pt already exists)\n  proc->pgtables[1]       = new_pt\n  new_pt->entries[5]      = 0x00000000 (valid=0 â€” this PTI not yet mapped)\nStep 1 â€” PDE present: SKIP page table allocation (already done)\nStep 2 â€” Page fault for PDI=1, PTI=5:\n  frame = alloc_free_frame()  // e.g., frame 1\n  pt->entries[5] = pte_make(1, readable=1, writable=1)\nStep 3 â€” Return physical address:\n  paddr = (1 << 12) | 0x0A8 = 0x000010A8\n```\nThe page table allocation only fires once per directory region, no matter how many pages within that region are subsequently accessed. This is the memory efficiency of the hierarchical approach made concrete.\n---\n## Context Switching with CR3\nContext switching between processes now has a clean, hardware-mirroring implementation. The OS loads the incoming process's page directory address into CR3, and from that point all translations use the new process's address space.\n\n![CR3 Register and Context Switch](./diagrams/diag-m3-cr3-context-switch.svg)\n\n```c\n/*\n * Simulate a context switch between processes.\n *\n * In real hardware:\n *   MOV CR3, new_pgdir_physical_address\n * This single instruction switches the entire virtual address space.\n * The hardware page walker immediately uses the new CR3 for all subsequent\n * translations.\n *\n * TLB handling on context switch:\n *   Option A (no ASID support): flush TLB entirely on every switch\n *   Option B (with ASID): update active_asid, preserve all TLB entries\n *\n * For Milestone 3, we integrate with the TLB from Milestone 2.\n * The force_flush flag lets you test both modes.\n */\nvoid ml_context_switch(ml_simulator_t *sim, tlb_t *tlb,\n                        process_t *new_proc, int force_flush) {\n    process_t *old_proc = sim->active_process;\n    printf(\"[CTX SWITCH] ASID %u â†’ ASID %u  (CR3: %p â†’ %p)\\n\",\n           old_proc ? old_proc->asid : 0,\n           new_proc->asid,\n           old_proc ? (void *)old_proc->pgdir : NULL,\n           (void *)new_proc->pgdir);\n    if (force_flush) {\n        /*\n         * Naive mode: flush entire TLB on every context switch.\n         * Cost: all cached translations are evicted. New process starts cold.\n         * Used by older CPUs without ASID/PCID support, and by Linux's KPTI\n         * path on CPUs without PCID (post-Meltdown mitigation).\n         */\n        if (tlb) tlb_flush_all(tlb, old_proc ? /*dummy pt*/NULL : NULL);\n    } else {\n        /*\n         * ASID mode: just switch the active ASID.\n         * Old process's TLB entries become invisible (wrong ASID).\n         * New process's TLB entries (if any from a previous time slice)\n         * become immediately visible.\n         * Cost: zero cache pollution â€” both processes' entries coexist.\n         */\n        if (tlb) tlb->active_asid = new_proc->asid;\n    }\n    /* Update simulator CR3 */\n    sim->active_process = new_proc;\n    sim->cr3 = (uint32_t)(uintptr_t)new_proc->pgdir;  /* symbolic */\n}\n```\n**The CR3 register is the physical manifestation of process isolation.** When you execute `ml_context_switch()`, the entire virtual address space changes. Process A's `0x00401000` and Process B's `0x00401000` are completely independent â€” they refer to different PTEs in different page directories, which map to different physical frames. The address `0x00401000` means nothing without the CR3 that establishes the context for its interpretation.\n---\n## Integrating with the TLB: The Full Three-Level View\nNow that you have both a TLB (Milestone 2) and a two-level page table (this milestone), wire them together to complete the address translation pipeline.\n```c\n/*\n * Full address translation: TLB â†’ two-level page table walk.\n *\n * Three-Level View:\n *\n * Application Level:\n *   Code reads array[i] at virtual address 0x00401050.\n *\n * Simulator Level (this function):\n *   1. Check TLB for (VPN=0x401, ASID=active)\n *   2a. TLB HIT:  return (PFN from TLB << 12) | offset\n *   2b. TLB MISS: walk two-level page table\n *       CR3 â†’ pgdir[PDI=1] â†’ pgtable[PTI=1] â†’ PTE â†’ PFN\n *       Insert (VPN, PFN) into TLB\n *   3. Physical address = (PFN << 12) | offset\n *\n * Hardware Level:\n *   CPU MMU checks TLB in parallel with L1 cache index computation.\n *   On TLB miss: hardware page walker reads pgdir and pgtable from RAM\n *   (2 memory accesses for two-level; 4 for x86-64's four-level tables).\n *   On PTE.present=0: #PF exception â†’ OS page fault handler.\n */\nxlate_t full_translate(ml_simulator_t *sim, tlb_t *tlb,\n                        uint32_t vaddr, access_type_t atype) {\n    sim->total_accesses++;\n    uint32_t vpn    = vaddr >> PAGE_OFFSET_BITS;   /* 20-bit combined VPN */\n    uint32_t offset = vaddr & PAGE_OFFSET_MASK;\n    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     * TLB lookup (if TLB present â€” tlb may be NULL for testing walk only)\n     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n    if (tlb) {\n        tlb_lookup_t tr = tlb_lookup(tlb, vpn, atype);\n        if (tr.result == XLATE_TLB_HIT) {\n            sim->tlb_hits++;\n            uint32_t paddr = make_physical_addr(tr.pfn, offset);\n            return (xlate_t){ .result = XLATE_SUCCESS, .paddr = paddr,\n                              .pfn = tr.pfn };\n        }\n        if (tr.result == XLATE_PROT_FAULT_TLB) {\n            sim->protection_faults++;\n            return (xlate_t){ .result = XLATE_PROT_FAULT };\n        }\n        /* TLB miss: fall through to page table walk */\n    }\n    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     * Two-level page table walk (TLB miss path)\n     *â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n    uint32_t pdi = pd_index(vaddr);\n    uint32_t pti = pt_index(vaddr);\n    process_t *proc = sim->active_process;\n    /* Level 1: page directory */\n    if (!pde_is_present(proc->pgdir->entries[pdi])) {\n        page_table_t *new_pt = alloc_page_table(proc);\n        if (!new_pt) return (xlate_t){ .result = XLATE_OOM };\n        proc->pgtables[pdi] = new_pt;\n        proc->pgdir->entries[pdi] = pde_make((uint32_t)(uintptr_t)new_pt);\n    }\n    /* Level 2: page table */\n    sim->pt_walks++;\n    page_table_t *pt  = proc->pgtables[pdi];\n    pte_t        *pte = &pt->entries[pti];\n    if (!(*pte & PTE_VALID)) {\n        sim->page_faults++;\n        uint32_t frame = alloc_free_frame();\n        if (frame == UINT32_MAX) return (xlate_t){ .result = XLATE_OOM };\n        *pte = pte_make(frame, 1, (atype == ACCESS_WRITE));\n    }\n    if (atype == ACCESS_WRITE && !(*pte & PTE_PERM_WRITE)) {\n        sim->protection_faults++;\n        return (xlate_t){ .result = XLATE_PROT_FAULT };\n    }\n    *pte |= PTE_REFERENCED;\n    if (atype == ACCESS_WRITE) *pte |= PTE_DIRTY;\n    uint32_t pfn   = pte_get_pfn(*pte);\n    uint32_t paddr = make_physical_addr(pfn, offset);\n    /* Insert into TLB for future accesses */\n    if (tlb) {\n        int writable = (*pte & PTE_PERM_WRITE) ? 1 : 0;\n        tlb_insert(tlb, /*pt=*/NULL, vpn, pfn, writable, /*use_random=*/0);\n    }\n    return (xlate_t){ .result = XLATE_SUCCESS, .paddr = paddr, .pfn = pfn };\n}\n```\n**Why TLB miss costs more with multi-level tables.** In Milestone 1 with a flat table, a TLB miss cost one memory access (reading `page_table.entries[vpn]`). With a two-level table, a TLB miss costs two memory accesses: one to read the PDE from the page directory, and one to read the PTE from the second-level table. This is why the TLB matters even more with hierarchical tables â€” each additional level multiplies the miss penalty. On real x86-64 with four-level tables, a TLB miss costs four memory accesses (one per level). This is why x86-64 CPUs have a dedicated hardware page walker that handles these four accesses using a separate non-pipelined path, and why hardware prefetchers try to predict page table accesses.\n---\n## Memory Overhead Comparison: The Numbers That Matter\nLet's implement a concrete measurement framework to quantify the savings:\n```c\n/*\n * Overhead comparison: simulate the same access pattern under flat and\n * two-level tables, then report the page table memory consumed by each.\n *\n * This makes the memory efficiency benefit measurable, not just theoretical.\n */\ntypedef struct {\n    size_t   pt_bytes;      /* bytes consumed by page table structures */\n    uint32_t pages_mapped;  /* number of distinct pages that were accessed */\n    uint32_t pt2_count;     /* number of second-level tables allocated */\n} overhead_report_t;\noverhead_report_t measure_flat_overhead(uint32_t pages_mapped) {\n    /*\n     * Flat table overhead is constant regardless of pages_mapped.\n     * The entire 1M-entry array is allocated at process creation.\n     */\n    return (overhead_report_t){\n        .pt_bytes    = (size_t)PD_SIZE * PT_SIZE * sizeof(pte_t),  /* 4MB */\n        .pages_mapped = pages_mapped,\n        .pt2_count   = 0   /* no second-level concept */\n    };\n}\noverhead_report_t measure_twolevel_overhead(const process_t *proc) {\n    uint32_t pt2_count = 0;\n    uint32_t pages_mapped = 0;\n    for (int pdi = 0; pdi < PD_SIZE; pdi++) {\n        if (!proc->pgtables[pdi]) continue;\n        pt2_count++;\n        for (int pti = 0; pti < PT_SIZE; pti++) {\n            if (proc->pgtables[pdi]->entries[pti] & PTE_VALID) {\n                pages_mapped++;\n            }\n        }\n    }\n    return (overhead_report_t){\n        .pt_bytes    = proc->pt_bytes_allocated,\n        .pages_mapped = pages_mapped,\n        .pt2_count   = pt2_count\n    };\n}\nvoid print_overhead_comparison(const overhead_report_t *flat,\n                                const overhead_report_t *two_level) {\n    printf(\"\\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\\n\");\n    printf(\"â•‘       Page Table Memory Overhead Report       â•‘\\n\");\n    printf(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•£\\n\");\n    printf(\"â•‘ Metric                 â•‘  Flat   â•‘ Two-Level â•‘\\n\");\n    printf(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•£\\n\");\n    printf(\"â•‘ Pages mapped           â•‘ %7u â•‘ %9u â•‘\\n\",\n           flat->pages_mapped, two_level->pages_mapped);\n    printf(\"â•‘ PT structures (bytes)  â•‘ %7zu â•‘ %9zu â•‘\\n\",\n           flat->pt_bytes, two_level->pt_bytes);\n    printf(\"â•‘ PT structures (KB)     â•‘ %7zu â•‘ %9zu â•‘\\n\",\n           flat->pt_bytes / 1024, two_level->pt_bytes / 1024);\n    printf(\"â•‘ L2 tables allocated    â•‘       â€” â•‘ %9u â•‘\\n\",\n           two_level->pt2_count);\n    printf(\"â•‘ Bytes per mapped page  â•‘ %7zu â•‘ %9zu â•‘\\n\",\n           flat->pt_bytes / (flat->pages_mapped ? flat->pages_mapped : 1),\n           two_level->pt_bytes / (two_level->pages_mapped ?\n                                  two_level->pages_mapped : 1));\n    printf(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•£\\n\");\n    double savings = 100.0 * (1.0 - (double)two_level->pt_bytes /\n                               (double)flat->pt_bytes);\n    printf(\"â•‘ Memory savings         â•‘       â€” â•‘   %6.1f%% â•‘\\n\", savings);\n    printf(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•\\n\");\n}\n```\n**Expected output for a sparse process using 5 pages spread across 5 different 4MB regions:**\n```\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘       Page Table Memory Overhead Report       â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘ Metric                 â•‘  Flat   â•‘ Two-Level â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘ Pages mapped           â•‘       5 â•‘         5 â•‘\nâ•‘ PT structures (bytes)  â•‘ 4194304 â•‘     24576 â•‘\nâ•‘ PT structures (KB)     â•‘    4096 â•‘        24 â•‘\nâ•‘ L2 tables allocated    â•‘       â€” â•‘         5 â•‘\nâ•‘ Bytes per mapped page  â•‘  838860 â•‘      4915 â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘ Memory savings         â•‘       â€” â•‘    99.4%  â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•\n```\n99.4% savings for a sparse process using 5 pages. This is not a toy improvement â€” it's the difference between a system supporting 100 processes and one supporting 10,000.\n---\n## Stretch Goal: Three-Level Page Tables\nThe two-level design works perfectly for 32-bit address spaces. But 64-bit address spaces pose a new problem: a full 64-bit address space has 2^52 possible pages (with 4KB pages). Even two levels can't cover this efficiently. Real 64-bit systems use three, four, or five levels.\nFor 32-bit addresses, a three-level split of `2 + 9 + 9 + 12` is a useful exercise:\n```\n 31           30 29                21 20               12 11              0\n â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n â”‚  L1 (2b)  â”‚     L2 (9b)      â”‚     L3 (9b)      â”‚    OFFSET (12b)      â”‚\n â”‚  bits[31:30]â”‚   bits[29:21]   â”‚   bits[20:12]   â”‚    bits[11:0]        â”‚\n â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n       â†“               â†“                  â†“                    â†“\n  4 entries       512 entries        512 entries           4096 bytes\n  (top dir)     (mid tables)        (leaf tables)\n```\n\n![Three-Level Page Table Structure (Stretch Goal)](./diagrams/diag-m3-three-level-stretch.svg)\n\n```c\n/*\n * Three-level page table configuration (stretch goal).\n *\n * Address split: 2 + 9 + 9 + 12 for 32-bit, 4KB pages.\n *\n * Level 1 (root): 2^2 = 4 entries Ã— 4 bytes = 16 bytes (tiny root)\n * Level 2 (mid):  2^9 = 512 entries Ã— 4 bytes = 2048 bytes\n * Level 3 (leaf): 2^9 = 512 entries Ã— 4 bytes = 2048 bytes\n *\n * This is less natural for 32-bit (4 root entries is extremely small)\n * but mirrors the structure of 64-bit systems like x86-64, where\n * the top levels also have few entries covering enormous address ranges.\n *\n * x86-64 actual split (4-level, 48-bit addresses):\n *   PGD(9) + PUD(9) + PMD(9) + PTE(9) + offset(12) = 48 bits\n *\n * x86-64 LA57 split (5-level, 57-bit addresses):\n *   P4D(9) + PGD(9) + PUD(9) + PMD(9) + PTE(9) + offset(12) = 57 bits\n */\n#define L1_BITS   2u\n#define L2_BITS   9u\n#define L3_BITS   9u\n/* offset = 12, total = 32 âœ“ */\n#define L1_SHIFT  (L2_BITS + L3_BITS + PAGE_OFFSET_BITS)  /* 30 */\n#define L2_SHIFT  (L3_BITS + PAGE_OFFSET_BITS)             /* 21 */\n#define L3_SHIFT  (PAGE_OFFSET_BITS)                        /* 12 */\n#define L1_SIZE   (1u << L1_BITS)   /* 4   */\n#define L2_SIZE   (1u << L2_BITS)   /* 512 */\n#define L3_SIZE   (1u << L3_BITS)   /* 512 */\n#define L1_MASK   ((1u << L1_BITS) - 1)\n#define L2_MASK   ((1u << L2_BITS) - 1)\n#define L3_MASK   ((1u << L3_BITS) - 1)\nstatic inline uint32_t l1_index(uint32_t vaddr) { return (vaddr >> L1_SHIFT) & L1_MASK; }\nstatic inline uint32_t l2_index(uint32_t vaddr) { return (vaddr >> L2_SHIFT) & L2_MASK; }\nstatic inline uint32_t l3_index(uint32_t vaddr) { return (vaddr >> L3_SHIFT) & L3_MASK; }\n/*\n * Three-level page table structures.\n *\n * A leaf table (L3) contains PTEs pointing to physical frames.\n * Mid tables (L2) contain PDEs pointing to leaf tables.\n * Root (L1) contains PDEs pointing to mid tables.\n *\n * Walk: L1[l1] â†’ L2[l2] â†’ L3[l3] â†’ PFN â†’ paddr\n *\n * Memory cost for a single 3-page sparse process:\n *   L1 root:    4 entries Ã— 4 bytes  = 16 bytes (always)\n *   L2 tables:  up to 3 Ã— 2KB = 6144 bytes (one per distinct L1 region)\n *   L3 tables:  up to 3 Ã— 2KB = 6144 bytes (one per distinct L2 region)\n *   Total:      ~12KB vs 4MB flat = 99.7% savings\n */\ntypedef struct { pde_t entries[L2_SIZE]; } l2_table_t;\ntypedef struct { pte_t entries[L3_SIZE]; } l3_table_t;\ntypedef struct {\n    pde_t      root[L1_SIZE];            /* L1: 4 entries             */\n    l2_table_t *l2tables[L1_SIZE];       /* L2: allocated on demand   */\n    l3_table_t *l3tables[L1_SIZE][L2_SIZE]; /* L3: allocated on demand */\n} three_level_pt_t;\n/*\n * Three-level page table walk.\n * Returns PFN, or UINT32_MAX if not mapped (triggers demand allocation).\n *\n * The structure is identical to the two-level walk, but with one\n * additional level of indirection inserted between root and leaf.\n */\nuint32_t three_level_walk(three_level_pt_t *pt3, uint32_t vaddr,\n                           access_type_t atype) {\n    uint32_t i1 = l1_index(vaddr);\n    uint32_t i2 = l2_index(vaddr);\n    uint32_t i3 = l3_index(vaddr);\n    /* Level 1 â†’ Level 2 */\n    if (!(pt3->root[i1] & PDE_PRESENT)) {\n        pt3->l2tables[i1] = calloc(1, sizeof(l2_table_t));\n        if (!pt3->l2tables[i1]) return UINT32_MAX;\n        pt3->root[i1] = pde_make((uint32_t)(uintptr_t)pt3->l2tables[i1]);\n    }\n    /* Level 2 â†’ Level 3 */\n    l2_table_t *l2 = pt3->l2tables[i1];\n    if (!(l2->entries[i2] & PDE_PRESENT)) {\n        pt3->l3tables[i1][i2] = calloc(1, sizeof(l3_table_t));\n        if (!pt3->l3tables[i1][i2]) return UINT32_MAX;\n        l2->entries[i2] = pde_make(\n            (uint32_t)(uintptr_t)pt3->l3tables[i1][i2]);\n    }\n    /* Level 3 â†’ PTE */\n    l3_table_t *l3  = pt3->l3tables[i1][i2];\n    pte_t      *pte = &l3->entries[i3];\n    if (!(*pte & PTE_VALID)) {\n        uint32_t frame = alloc_free_frame();\n        if (frame == UINT32_MAX) return UINT32_MAX;\n        *pte = pte_make(frame, 1, (atype == ACCESS_WRITE));\n    }\n    *pte |= PTE_REFERENCED;\n    if (atype == ACCESS_WRITE) *pte |= PTE_DIRTY;\n    return pte_get_pfn(*pte);\n}\n```\n---\n## Building and Testing\n### Compile\n```bash\ngcc -Wall -Wextra -O2 -std=c11 -o vmsim_m3 vmsim_m3.c\n```\n### Test 1: Address Decomposition Correctness\n```c\nvoid test_address_decomposition(void) {\n    /*\n     * Test vector: 0x004056A8\n     * Expected: PDI=1, PTI=5, offset=0x6A8\n     */\n    uint32_t vaddr = 0x004056A8u;\n    assert(pd_index(vaddr)  == 1);\n    assert(pt_index(vaddr)  == 5);\n    assert(page_offset(vaddr) == 0x6A8);\n    /* Test vector: 0x00C00000 (exactly at PDI=3, PTI=0, offset=0) */\n    uint32_t v2 = 0x00C00000u;\n    assert(pd_index(v2)  == 3);\n    assert(pt_index(v2)  == 0);\n    assert(page_offset(v2) == 0);\n    /* Test vector: 0xFFFFFFFF (max 32-bit address) */\n    uint32_t v3 = 0xFFFFFFFFu;\n    assert(pd_index(v3)  == 1023);   /* bits[31:22] = 0x3FF */\n    assert(pt_index(v3)  == 1023);   /* bits[21:12] = 0x3FF */\n    assert(page_offset(v3) == 0xFFF);\n    printf(\"Address decomposition test: PASSED\\n\");\n}\n```\n### Test 2: On-Demand Table Allocation\n```c\nvoid test_ondemand_allocation(void) {\n    process_t *proc = process_create(1);\n    assert(proc);\n    /* Before any access: no second-level tables */\n    for (int i = 0; i < PD_SIZE; i++) {\n        assert(proc->pgtables[i] == NULL);\n        assert(!pde_is_present(proc->pgdir->entries[i]));\n    }\n    assert(proc->pt_bytes_allocated == sizeof(page_directory_t));   /* 4KB */\n    ml_simulator_t sim = { .active_process = proc };\n    init_phys_mem();\n    /* First access to PDI=0 region â€” should allocate L2 table */\n    xlate_t r1 = ml_translate(&sim, 0x00001000, ACCESS_READ);\n    assert(r1.result == XLATE_SUCCESS);\n    assert(proc->pgtables[0] != NULL);   /* L2 table for PDI=0 created */\n    assert(pde_is_present(proc->pgdir->entries[0]));\n    assert(proc->pgtables[1] == NULL);   /* other regions untouched */\n    size_t after_first = proc->pt_bytes_allocated;\n    assert(after_first == sizeof(page_directory_t) + sizeof(page_table_t));\n    /* Second access to different page in SAME PDI=0 region */\n    xlate_t r2 = ml_translate(&sim, 0x00002000, ACCESS_READ);\n    assert(r2.result == XLATE_SUCCESS);\n    /* No new L2 table should be allocated â€” same PDI=0 */\n    assert(proc->pt_bytes_allocated == after_first);\n    /* Access to PDI=1 region â€” should allocate a second L2 table */\n    xlate_t r3 = ml_translate(&sim, 0x00401000, ACCESS_READ);\n    assert(r3.result == XLATE_SUCCESS);\n    assert(proc->pgtables[1] != NULL);\n    assert(proc->pt_bytes_allocated ==\n           after_first + sizeof(page_table_t));\n    printf(\"On-demand allocation test: PASSED\\n\");\n    process_destroy(proc);\n}\n```\n### Test 3: Memory Overhead Comparison\n```c\nvoid test_overhead_comparison(void) {\n    /*\n     * Access 5 pages spread across 5 different 4MB regions.\n     * PDI values: 0, 1, 2, 3, 4 (one page per region)\n     */\n    process_t *proc = process_create(1);\n    ml_simulator_t sim = { .active_process = proc };\n    init_phys_mem();\n    uint32_t test_addrs[] = {\n        0x00001000,   /* PDI=0, PTI=1 */\n        0x00401000,   /* PDI=1, PTI=1 */\n        0x00801000,   /* PDI=2, PTI=1 */\n        0x00C01000,   /* PDI=3, PTI=1 */\n        0x01001000,   /* PDI=4, PTI=1 */\n    };\n    for (int i = 0; i < 5; i++) {\n        xlate_t r = ml_translate(&sim, test_addrs[i], ACCESS_READ);\n        assert(r.result == XLATE_SUCCESS);\n    }\n    overhead_report_t flat = measure_flat_overhead(5);\n    overhead_report_t two  = measure_twolevel_overhead(proc);\n    assert(flat.pt_bytes   == 4194304);   /* exactly 4MB */\n    assert(two.pt_bytes    == 6 * 4096);  /* 1 pgdir + 5 pgtables = 24KB */\n    assert(two.pt2_count   == 5);\n    assert(two.pages_mapped == 5);\n    print_overhead_comparison(&flat, &two);\n    printf(\"Overhead comparison test: PASSED\\n\");\n    process_destroy(proc);\n}\n```\n### Test 4: CR3 Context Switch Isolation\n```c\nvoid test_cr3_isolation(void) {\n    init_phys_mem();\n    tlb_t tlb;\n    tlb_init(&tlb, 1, 42);\n    process_t *p1 = process_create(1);\n    process_t *p2 = process_create(2);\n    ml_simulator_t sim = { .active_process = p1, .cr3 = (uint32_t)(uintptr_t)p1->pgdir };\n    /* Process 1: write to 0x00001000 */\n    xlate_t r1 = full_translate(&sim, &tlb, 0x00001000, ACCESS_WRITE);\n    assert(r1.result == XLATE_SUCCESS);\n    uint32_t p1_paddr = r1.paddr;\n    /* Context switch to Process 2 */\n    ml_context_switch(&sim, &tlb, p2, /*force_flush=*/0);\n    assert(sim.active_process == p2);\n    assert(tlb.active_asid == 2);\n    /* Process 2: read same virtual address â€” must get a DIFFERENT physical address */\n    xlate_t r2 = full_translate(&sim, &tlb, 0x00001000, ACCESS_READ);\n    assert(r2.result == XLATE_SUCCESS);\n    assert(r2.paddr != p1_paddr);   /* isolated: different PFN */\n    printf(\"CR3 isolation test: PASSED\\n\");\n    process_destroy(p1);\n    process_destroy(p2);\n}\n```\n### Test 5: PDE vs PTE Structural Distinction\n```c\nvoid test_pde_vs_pte_distinction(void) {\n    /*\n     * Verify that PDE entries point to page TABLES (not data frames)\n     * and PTE entries point to data frames.\n     */\n    process_t *proc = process_create(1);\n    ml_simulator_t sim = { .active_process = proc };\n    init_phys_mem();\n    xlate_t r = ml_translate(&sim, 0x00401000, ACCESS_READ);\n    assert(r.result == XLATE_SUCCESS);\n    /* The PDE for PDI=1 must be present */\n    pde_t pde = proc->pgdir->entries[1];\n    assert(pde_is_present(pde));\n    /* The address in the PDE must point to the allocated page table */\n    /* (In simulator: pgtables[1] is non-NULL) */\n    assert(proc->pgtables[1] != NULL);\n    /* The PTE for PTI=1 in that page table must be valid */\n    pte_t pte = proc->pgtables[1]->entries[1];\n    assert(pte & PTE_VALID);\n    /* The PFN in the PTE must be a valid frame number */\n    uint32_t pfn = pte_get_pfn(pte);\n    assert(pfn < NUM_FRAMES);\n    assert(phys_mem[pfn].in_use);\n    printf(\"PDE vs PTE distinction test: PASSED\\n\");\n    process_destroy(proc);\n}\n```\n---\n## Common Pitfalls and How to Avoid Them\n| Pitfall | Symptom | Fix |\n|---------|---------|-----|\n| Index extraction in wrong order | PDI gets low bits, PTI gets high bits â€” wrong regions mapped | High bits â†’ directory (coarse), low bits â†’ table (fine) |\n| Checking PTE permission before PDE present | NULL pointer dereference when `pgtables[pdi] == NULL` | Always check PDE present before accessing `pgtables[pdi]` |\n| Confusing PDE and PTE structures | A PDE stored in `entries[pti]` of a leaf table â€” type confusion | PDE points to tables; PTE points to frames. Types differ. |\n| Not accounting for page table memory in overhead | Overhead report shows only data frames, not PT structure cost | Track `pt_bytes_allocated` separately from data frames |\n| Forgetting that page table structures occupy frames in real OS | Simulator works fine; mental model for real OS is wrong | In production: pgdir and pgtables steal frames from user data |\n| Clearing PDE when a page is evicted | PDE cleared causes loss of entire 4MB mapping region | Only clear the PTE for the evicted page; leave PDE and PT intact |\n| Forgetting TLB flush on page table modification | Stale TLB entry returns old PFN after PTE update | Call `tlb_flush_page(vpn)` whenever a PTE's PFN changes |\n| `pde_make()` losing low bits (non-aligned pointers) | PT address stored in PDE is corrupted | Assert `sizeof(page_table_t) == 4096` and use aligned allocations |\n**The non-aligned pointer pitfall deserves elaboration.** Your `pde_make()` function encodes the page table address in bits `[31:12]`, preserving only 20 bits of the address. This works only if the page table is 4KB-aligned (low 12 bits are zero). `malloc()` does *not* guarantee 4KB alignment â€” it typically gives 8 or 16-byte alignment. In a real OS, page tables are stored in physical frames (inherently 4KB-aligned). In your simulator, use `aligned_alloc(PAGE_SIZE, sizeof(page_table_t))` or `posix_memalign()` to ensure alignment, or use a symbolic pointer approach (store pointer directly in a separate array, not in the PDE bits).\nFor the simulator, the cleanest approach is to store the actual C pointer in `proc->pgtables[]` and use the PDE purely as a present/absent flag, consulting the pointer array for the actual address. This avoids alignment issues while preserving the conceptual model.\n---\n## Hardware Soul: What Real Silicon Does\nYour simulator builds page directory and page table structures in heap memory. Real hardware does something subtly but importantly different â€” and understanding the difference deepens your mental model of what these structures are.\n**Page table structures live in physical frames.** In Linux, when a new process is created via `fork()` or `exec()`, the kernel allocates physical frames for the page directory and initial page tables from its own free frame pool â€” the same pool used for user data. The frames containing page tables are not special in hardware; they're ordinary RAM frames that the OS and MMU interpret as containing page table data. The CR3 register holds the *physical* address of the frame containing the top-level page directory. The hardware page walker follows the CR3 value as a literal memory address, reads the PDE, follows that as another literal memory address, and so on. There's no OS call, no indirection â€” just hardware reading from physical RAM addresses.\n**Multi-level page table walk costs: 2 memory accesses for two-level.** Each level requires one DRAM access to fetch the directory or table entry. For your two-level table, a TLB miss costs 2 Ã— 100ns = 200ns in DRAM accesses before even accessing the data. For x86-64's four-level table, it's 4 Ã— 100ns = 400ns â€” 1200 CPU cycles at 3GHz lost to page walking on every TLB miss. This is why:\n1. **TLB hit rate dominates performance more than page table level count.** A 98% hit rate with four-level tables beats a 90% hit rate with two-level tables in most workloads.\n2. **Hardware page walkers are dedicated units.** Modern x86-64 CPUs have a separate hardware state machine that walks page tables without stalling the CPU pipeline â€” it runs concurrently with other pipeline stages where possible.\n3. **Page table entries are cached in L1/L2.** The hardware page walker generates regular memory reads. These are cached by the CPU's standard L1/L2/L3 cache hierarchy. If the page directory entry is in L1 cache (64 bytes, covering 16 PDEs), the walk costs ~4ns instead of 100ns. Processes with access patterns that keep their active PDE/PTE hot in cache amortize walk costs dramatically.\n**Cache line analysis for your structures:**\n- `page_directory_t`: 1024 Ã— 4 bytes = 4096 bytes = 64 cache lines. Accessing PDI=0 and PDI=1 (consecutive entries) hits the same cache line. Accessing PDI=0 and PDI=32 hits different cache lines (offset 0 vs offset 128).\n- `page_table_t`: same analysis. Sequential PTI accesses are cache-friendly. Random PTI accesses across more than 16 slots (64 bytes / 4 bytes per PTE) cause cache misses within the page table itself.\n- A process whose virtual address usage is clustered within a few 4MB regions keeps both the PDE and the relevant PTEs warm in cache, making page walks nearly free even on TLB misses.\n---\n## Knowledge Cascade: What Multi-Level Page Tables Unlock\n### 1. The Multi-Level Page Table IS a Radix Trie\nThis is not a metaphor â€” it's an exact equivalence. A radix trie (compact prefix trie) is a tree where each edge represents a fixed number of bits of the key, and missing branches are represented as NULL pointers. A two-level page table with 10+10+12 bit split is a radix trie keyed on the 20-bit VPN (the top two fields), with 4096-byte leaves (the pages). The PDI selects the first 10-bit chunk; the PTI selects the next 10-bit chunk.\nThis equivalence is not academic. **IP routing tables** use exactly the same structure â€” Patricia tries (radix trees) over IP prefix bits â€” for longest-prefix match. A router's forwarding table with 700,000 entries (as in the global BGP table) uses a multi-level trie where NULL pointers at upper levels skip enormous prefix ranges, exactly as NULL PDEs skip 4MB virtual address ranges. Understanding your page table gives you the core data structure intuition for network routing, dictionary compression (compressed tries), and all sparse key-value lookup problems.\n### 2. Linux's 5-Level Page Table: The Same Concept, Extended\nLinux on x86-64 supports up to 5-level page tables (kernel 4.14+, hardware since Ice Lake 2019) for 57-bit virtual address spaces:\n```\nPGD(9) â†’ P4D(9) â†’ PUD(9) â†’ PMD(9) â†’ PTE(9) + offset(12) = 57 bits\n```\nEach level is structurally identical to what you built: a 512-entry table where each entry is either a NULL (not present) pointer or a pointer to the next level. NULL at any level skips 2^(remaining bits) bytes of address space. A NULL PGD entry skips 2^(9+9+9+9+12) = 2^48 = 256 TB of virtual address space. Five levels of this structure can address 2^57 = 128 petabytes â€” more than any current application needs, with sparse coverage making the overhead manageable.\nThe Linux kernel's `mm_struct` (the structure describing a process's memory) contains a `pgd_t *pgd` field â€” the equivalent of your `proc->pgdir`. Context switching in Linux's `__switch_to_asm()` includes a `mov %0, %%cr3` instruction that loads the new process's page directory base. You just simulated that in `ml_context_switch()`.\n### 3. Sparse File Systems: Inode Indirect Blocks\nThe ext4 filesystem's inode structure for large files uses a multi-level block pointer design that is structurally identical to a three-level page table:\n```\ninode.direct_blocks[12]     â†’ points directly to data blocks (small files)\ninode.indirect              â†’ points to a block of 1024 block pointers\ninode.double_indirect       â†’ points to a block of 1024 indirect pointers\ninode.triple_indirect       â†’ points to a block of 1024 double-indirect ptrs\n```\nThis is exactly your PGD â†’ PMD â†’ PTE structure, but over disk blocks instead of physical frames. A small file (â‰¤ 48KB) uses only direct blocks â€” no overhead. A large file allocates indirect blocks on demand. A 1TB file that uses only a few regions allocates only the indirect/double-indirect blocks needed to reach those regions.\n[[EXPLAIN:why-hierarchical/multi-level-indexing-saves-memory-for-sparse-structures|Why hierarchical/multi-level indexing saves memory for sparse structures â€” the connection between page tables, filesystem inode trees, and B-trees]]\nNTFS uses a similar structure via its B-tree master file table. SQLite's B-tree pages are another instantiation: the tree pages (internal nodes) are allocated on demand as the database grows, exactly as your second-level page tables are allocated on demand as the address space is populated.\n### 4. Copy-on-Write fork() â€” Sharing Page Table Subtrees\nThe Unix `fork()` system call creates a child process that is initially an exact copy of the parent. Naively, this would require copying all of the parent's mapped pages. With copy-on-write (CoW) and hierarchical page tables, `fork()` instead:\n1. Copies only the *page directory* (4KB), not the second-level tables\n2. Makes the parent and child share all existing second-level page tables and physical frames\n3. Marks all shared PTEs as read-only in both parent and child\n4. When either process writes to a shared page, the hardware raises a protection fault; the OS then copies that specific page, maps it privately in the writing process's page table, and resumes\nThe key insight is that this is efficient precisely because the page table is hierarchical. Sharing a single PDE allows the child to inherit an entire 4MB address region (with 1024 PTEs) by copying just 4 bytes. If the child never writes to that region, the second-level table and all 1024 frames are shared forever at zero copy cost. The savings compound across the entire 4GB address space â€” `fork()` for a large process is O(number of mapped PDE entries), not O(number of mapped pages).\nThis is why Redis (which uses `fork()` for background saves) performs so well: the BGSAVE child process shares nearly all of Redis's memory with the parent via CoW. Only the pages that are actually modified during the save (by incoming write commands) need to be copied. For read-heavy workloads, CoW fork saves 99%+ of the copy cost.\n### 5. Memory-Mapped Device I/O â€” Single PDE for a Region\nHardware devices (GPU framebuffer, network card registers, PCIe BAR regions) are mapped into the virtual address space at specific physical addresses. With a two-level page table, an entire 4MB device region can be described by setting a single PDE to point to a page table where each of the 1024 PTEs maps to successive physical frames of the device's memory region. One 4-byte PDE describes 4MB of device address space. This is how `mmap(\"/dev/mem\", ...)` works on Linux, and how GPU drivers map video RAM into process virtual address space.\n### 6. Huge Pages â€” Collapsing Levels for Performance\n\n> **ğŸ”‘ Foundation: Huge pages**\n> \n> **What it IS**\nStandard memory paging uses 4KB \"frames.\" Huge pages allow the hardware to map much larger contiguous blocksâ€”typically 2MB or 1GBâ€”using a single entry in the page table hierarchy. Instead of the translation process going through four levels to find a tiny 4KB slice, the CPU stops \"early\" at a higher level (like the Page Directory) and treats that entire branch as one massive, continuous page.\n\n**WHY you need it right now**\nMemory translation is expensive. To speed it up, the CPU uses a small, lightning-fast cache called the Translation Lookaside Buffer (TLB) to store recent virtual-to-physical mappings. However, the TLB has very few slots (often only a few hundred).\n*   If you map 1GB of RAM using **4KB pages**, you need **262,144** TLB entries to cover it. You will constantly \"miss\" the cache and stall the CPU.\n*   If you map 1GB of RAM using **one 1GB huge page**, you need **exactly 1** TLB entry.\nThis drastically reduces \"TLB pressure,\" allowing the CPU to spend more time executing code and less time walking page tables in RAM.\n\n**Key Insight / Mental Model**\nThe **\"Warehouse vs. Envelopes\"** model. Mapping memory with 4KB pages is like trying to track a shipment of 1,000,000 items by putting each one in its own envelope with its own tracking number. Using huge pages is like putting all 1,000,000 items into a single shipping container with one single tracking number. One label (TLB entry) covers the entire load.\n\nWith standard 4KB pages, a 2MB allocation requires 512 PTEs across potentially many cache lines in the page table. With a 2MB huge page, the PMD entry (in a 4-level table) directly maps 2MB using a single table entry â€” the leaf level (PTE) is skipped entirely. The entry in the middle-level table (PMD) sets a special \"huge page\" bit and the physical address points directly to a 2MB-aligned physical region.\nIn your simulator, you could implement huge pages by adding a `huge` flag to PDE entries: if set, the PDE's physical address points directly to a 4MB data region (aligned to 4MB), skipping the second-level table entirely. The address decomposition changes: for an access to a \"huge\" PDE, the physical address is `pde_pfn_base + (vaddr & 0x3FFFFF)` (the bottom 22 bits become the offset within the 4MB region).\nThis is exactly why PostgreSQL and Redis benefit from huge page configuration (`vm.nr_hugepages` on Linux): a 256MB database buffer pool with 4KB pages requires 65,536 PTEs; with 2MB huge pages, it requires 128 PMD entries. The TLB pressure drops by 512Ã—.\n---\n## What You've Built and What's Missing\n**You have:**\n- A two-level hierarchical page table with on-demand second-level table allocation\n- A simulated CR3 register driving process-specific address translation\n- Correct 10+10+12 address decomposition with extraction functions\n- PDE and PTE type distinction with proper handling at each level\n- Context switching that changes CR3 and coordinates with the ASID-tagged TLB from Milestone 2\n- Quantitative memory overhead measurement and comparison against the flat table\n- An optional three-level table implementation following the same structural pattern\n- Complete test coverage: decomposition, on-demand allocation, overhead, isolation, type distinction\n**What's still painful:** All frames are allocated from a fixed pool of 64. Once those 64 frames are claimed by demand paging, the next access triggers `XLATE_OOM` â€” your simulator just logs an error and gives up. But real virtual memory systems never give up. When physical memory is exhausted, the OS picks a victim page, writes it to disk (if dirty), frees its frame, and uses that frame for the new demand. This is **page replacement** â€” the subject of Milestone 4.\nWith your multi-level page table correctly built, Milestone 4 becomes tractable. Page replacement requires finding a victim PTE (to clear its valid bit and free its frame), writing dirty pages to swap, and reloading them on the next fault. The multi-level structure makes the victim search slightly more complex â€” you need to walk all allocated second-level tables to find candidate pages â€” but structurally the same mechanisms you've just built handle the entire flow. The TLB flush on eviction (`tlb_flush_page()`) that you implemented in Milestone 2 connects directly here: when a frame is reclaimed, you must call `tlb_flush_page(vpn)` for the evicted page before clearing its PTE.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: virtual-memory-sim-m4 -->\n# Milestone 4: Page Replacement and Swap Simulation\n## The Problem: Physical Memory Is Finite, Virtual Greed Is Not\nYou have 64 frames in your simulator. After 64 distinct page faults, every frame is occupied. The 65th fault hits your `alloc_free_frame()` function, which scans through all frames, finds none available, and returns `UINT32_MAX`. Your simulator logs `[OOM] No free frames` and gives up.\nReal operating systems never give up. The Linux kernel, running a machine with 16 GB of RAM, routinely handles workloads that would require 40 GB if fully materialized in memory. It does this by maintaining the illusion that every process has all the memory it needs, while physically storing only the active portion â€” the *working set* â€” in RAM. Everything else lives on disk, in a region called **swap space**, waiting to be recalled when needed.\n[[EXPLAIN:swap-space:-extending-ram-to-disk,-what-'page-out'-and-'page-in'-mean|Swap space: extending RAM to disk, what 'page out' and 'page in' mean â€” how the OS extends the apparent size of physical memory using disk storage]]\nThis milestone is about making the hard choice the OS always has to make: when physical memory is full and a new page must be loaded, which *existing* page do you sacrifice? Sacrifice the wrong one â€” a page the program needs again in three instructions â€” and you've created a chain of faults that grinds execution to a halt. Choose well â€” a page that won't be needed for ten million accesses â€” and the program never notices the eviction happened.\nThat choice is **page replacement**, and it turns out to be one of the most consequential decisions an OS makes for application performance. The difference between a well-tuned and poorly-tuned replacement policy on a real database server can mean 10Ã— throughput difference for the same hardware.\n---\n## The Revelation: LRU Is Not the Answer You Think It Is\nBefore writing a single line of code for this milestone, destroy the comfortable myth that computer science textbooks inadvertently instill:\n*\"LRU is the gold standard page replacement algorithm. Real operating systems use LRU. If you implement LRU, you're done.\"*\nEvery part of this statement is wrong in practice, and understanding why is the deepest lesson of this milestone.\n**The fundamental problem with pure LRU:** maintaining true LRU order requires updating data structures on *every single memory access*. Your program running at 3 GHz might perform 3 billion memory accesses per second. True LRU demands that after every one of those accesses, you update a doubly-linked list â€” moving the accessed node to the front, updating two `next` and two `prev` pointers per access. That's 12 billion pointer writes per second *just to maintain the replacement metadata*, competing with the actual work your program is doing. The overhead of the bookkeeping would eliminate the benefit of the policy.\n**What hardware actually provides:** The MMU sets a single bit â€” the *referenced bit* (called the *accessed bit* in x86 terminology, part of the PTE you built in Milestone 1) â€” when any access to that page occurs. The OS can *clear* this bit periodically. That's the entire hardware support for recency information. One bit per page. Not a timestamp, not a list position, not an age counter. One bit that says \"has this page been touched since I last cleared this bit?\"\n**What real kernels do:**\n- Linux uses a **two-list approximation**: an \"active\" list for recently used pages and an \"inactive\" list for cold candidates. Pages move between lists based on the referenced bit, not on every access.\n- FreeBSD uses a **Clock** variant (their \"page daemon\" with reference-bit clearing).\n- macOS/iOS uses a **FIFO with second-chance** structure, tuned for mobile memory pressure.\n- None of them use pure LRU.\n**The second revelation â€” BÃ©lÃ¡dy's anomaly:** FIFO page replacement can produce *more* page faults with *more* physical frames. More RAM makes things worse. This sounds impossible â€” how can more memory hurt? â€” but it's a provable property of FIFO. And it's not just a toy curiosity: it exposes a fundamental property about what makes replacement algorithms trustworthy for capacity planning.\nYou'll build all four algorithms â€” FIFO, LRU, Clock, and Optimal â€” and the comparative statistics at the end will show you exactly why the theoretical ranking (Optimal > LRU > Clock > FIFO) doesn't always hold in practice, and why Clock is the real production workhorse.\n\n![Page Replacement in the Full Translation Pipeline](./diagrams/diag-m4-replacement-overview.svg)\n\n---\n## Swap Space: The Illusion of Infinite Memory\nWhen the OS evicts a page from a physical frame, where does the data go? If the page is **clean** â€” its contents match what's on disk (either from the original file it was mapped from, or from a previous write to swap) â€” the frame can simply be reclaimed. The data is already safe elsewhere; discarding the in-RAM copy loses nothing.\nIf the page is **dirty** â€” the program has written to it since it was loaded, and the modified data exists nowhere else â€” discarding it silently would destroy data. The OS must first write the page's contents to swap space, then free the frame.\n\n![Eviction Decision: Dirty vs Clean Page Cost](./diagrams/diag-m4-dirty-clean-eviction-decision.svg)\n\nThis clean/dirty distinction is tracked by the `PTE_DIRTY` bit you set in Milestone 1. Every write access to a page flips this bit. The eviction path checks it:\n```\nIs page dirty?\n  YES â†’ write page data to swap (expensive: disk I/O in a real system)\n        mark page as clean in swap\n        free the frame\n  NO  â†’ frame is free immediately (data unchanged from disk/swap)\n        free the frame\n```\nIn your simulator, \"swap space\" is a simple array indexed by Virtual Page Number (VPN). In a real OS, swap is a dedicated disk partition or file (`/proc/swaps` on Linux shows active swap areas), and \"writing to swap\" is a block device I/O operation costing 10â€“100 milliseconds â€” roughly 100,000Ã— slower than a memory access.\n```c\n/*\n * Simulated swap space.\n *\n * Indexed by VPN. Each slot stores one page (PAGE_SIZE bytes).\n * swap_present[vpn] = true if this VPN has data saved in swap.\n *\n * In a real OS: a swap partition on disk, addressed by swap slot number.\n * The OS maintains a swap map: VPN â†’ swap slot.\n *\n * Memory cost: NUM_VPN_POSSIBLE Ã— PAGE_SIZE bytes.\n * For 20-bit VPN (1M pages) at 4KB: 4 GB â€” impractical to actually allocate.\n * Simulator compromise: only allocate swap entries for pages that are\n * actually evicted (sparse swap: use a hash map or fixed-size pool).\n *\n * Simple version: fixed array of PAGE_SIZE bytes Ã— MAX_SWAP_PAGES.\n */\n#define MAX_SWAP_PAGES   256u    /* maximum number of pages in swap */\ntypedef struct {\n    uint8_t  data[PAGE_SIZE];   /* page content saved here on eviction */\n    uint32_t vpn;               /* which VPN owns this swap slot       */\n    bool     in_use;            /* is this swap slot occupied?          */\n} swap_slot_t;\ntypedef struct {\n    swap_slot_t slots[MAX_SWAP_PAGES];\n    uint64_t    write_backs;    /* dirty pages written to swap          */\n    uint64_t    page_ins;       /* pages loaded back from swap          */\n} swap_space_t;\n```\nThe `write_backs` counter is one of your most important statistics. It counts the extra disk I/O cost incurred by dirty page evictions â€” a direct measure of how much the replacement algorithm is thrashing modified data in and out of swap.\n---\n## The Physical Memory Model: Frames and the Free Pool\nBefore replacement algorithms can work, you need a clear model of physical memory that tracks not just *which* frames are free, but *which pages* currently occupy each frame â€” because the replacement algorithms need to find victims.\n```c\n/*\n * Physical frame descriptor.\n *\n * In a real OS: the kernel maintains a struct page array (one per frame),\n * containing reference counts, mapping info, flags, and list linkage.\n * Linux's struct page is approximately 64 bytes (one cache line).\n *\n * In your simulator: a simplified version tracking what we need\n * for replacement decisions.\n *\n * Byte layout:\n *   [0..3]  vpn         â€” which virtual page occupies this frame (UINT32_MAX if free)\n *   [4..7]  load_time   â€” when was this page loaded? (for FIFO: evict smallest)\n *   [8..11] last_access â€” when was this page last accessed? (for LRU: evict smallest)\n *   [12]    ref_bit     â€” referenced since last clock sweep? (for Clock)\n *   [13]    dirty       â€” has this frame been written to? (for write-back decision)\n *   [14]    in_use      â€” is this frame occupied?\n *   [15]    pad         â€” alignment\n * Total: 16 bytes per frame descriptor\n * Cache line (64 bytes) holds: 4 frame descriptors\n */\ntypedef struct {\n    uint32_t vpn;           /* virtual page currently mapped here     */\n    uint64_t load_time;     /* logical time of frame allocation       */\n    uint64_t last_access;   /* logical time of last access            */\n    bool     ref_bit;       /* Clock algorithm's reference bit        */\n    bool     dirty;         /* has this page been modified?           */\n    bool     in_use;        /* is the frame occupied?                 */\n} frame_desc_t;\n/*\n * Physical memory pool.\n *\n * Configurable number of frames. For replacement testing:\n *   - Small (3â€“8 frames): easy to trace by hand, anomalies visible\n *   - Medium (16â€“64): realistic for comparison benchmarks\n *   - Large (256): approximates \"enough memory\" behavior\n */\n#define NUM_FRAMES_DEFAULT  16u\ntypedef struct {\n    frame_desc_t desc[NUM_FRAMES_DEFAULT];  /* frame metadata          */\n    uint8_t      data[NUM_FRAMES_DEFAULT][PAGE_SIZE]; /* actual content */\n    uint32_t     num_frames;                /* configurable size        */\n    uint64_t     clock;                     /* logical clock for timestamps */\n} phys_mem_t;\nvoid phys_mem_init(phys_mem_t *pm, uint32_t num_frames) {\n    memset(pm, 0, sizeof(*pm));\n    pm->num_frames = num_frames;\n    for (uint32_t i = 0; i < num_frames; i++) {\n        pm->desc[i].vpn     = UINT32_MAX;  /* sentinel: no page mapped  */\n        pm->desc[i].in_use  = false;\n    }\n}\n/*\n * Find a free frame, if any.\n * Returns frame index, or UINT32_MAX if all frames occupied.\n * Complexity: O(num_frames) â€” acceptable; real OS maintains a free list O(1).\n */\nuint32_t phys_find_free(phys_mem_t *pm) {\n    for (uint32_t i = 0; i < pm->num_frames; i++) {\n        if (!pm->desc[i].in_use) return i;\n    }\n    return UINT32_MAX;\n}\n```\nThe `clock` field is a logical timestamp â€” a global counter incremented on every memory access. You assign `load_time` when a frame is claimed, and `last_access` on every subsequent access to a page in that frame. These timestamps drive FIFO and LRU eviction decisions without requiring list manipulation on the common (non-replacement) path.\n---\n## The Replacement Interface\nAll four algorithms share the same external interface. The replacement engine receives the physical memory pool, the swap space, the current page table, and the TLB â€” and returns a newly available frame, having evicted whatever victim it chose.\n```c\n/*\n * Replacement policy selector.\n * Passed to the unified replace_page() dispatcher.\n */\ntypedef enum {\n    POLICY_FIFO    = 0,\n    POLICY_LRU     = 1,\n    POLICY_CLOCK   = 2,\n    POLICY_OPTIMAL = 3,\n} replacement_policy_t;\n/*\n * Result of a replacement operation.\n */\ntypedef struct {\n    uint32_t freed_frame;    /* the frame number now available for use   */\n    uint32_t evicted_vpn;    /* which VPN was evicted                    */\n    bool     was_dirty;      /* did we have to write to swap?            */\n} replace_result_t;\n/*\n * Unified replacement dispatcher.\n * Selects a victim, handles dirty write-back, clears the victim's PTE,\n * invalidates the TLB entry, and returns the freed frame.\n *\n * After this call:\n *   - freed_frame is available for use (in_use=false)\n *   - evicted_vpn's PTE has valid=0 (may have swap data if was_dirty)\n *   - TLB entry for evicted_vpn is invalidated (tlb_flush_page called)\n *   - If was_dirty: swap_space contains saved data for evicted_vpn\n */\nreplace_result_t replace_page(phys_mem_t *pm, swap_space_t *swap,\n                               page_table_t *pt, tlb_t *tlb,\n                               replacement_policy_t policy,\n                               /* for Optimal only: */\n                               const mem_access_t *future, size_t future_len,\n                               size_t current_idx,\n                               /* for Clock only: */\n                               uint32_t *clock_hand);\n```\nThe key invariant this function must maintain: **before the frame is reused, the TLB must be invalidated for the evicted VPN.** This is the connection back to Milestone 2's `tlb_flush_page()`. Skipping this step causes the TLB to return a stale PFN for the evicted VPN â€” pointing to a frame now occupied by a different page's data. That's the TLB coherence violation, and it produces silent memory corruption with no fault raised.\n---\n## Swap In and Swap Out: The Data Walk\nBefore implementing any algorithm, implement the swap operations that all algorithms share. These are called by `replace_page()` regardless of which policy chose the victim.\n\n![Swap Space: Dirty Page Eviction and Reload â€” Data Walk](./diagrams/diag-m4-swap-space-data-walk.svg)\n\n```c\n/*\n * Find a swap slot for the given VPN.\n * Returns slot index if VPN has data in swap, UINT32_MAX if not.\n * Complexity: O(MAX_SWAP_PAGES) â€” acceptable for simulation.\n */\nstatic uint32_t swap_find_slot(const swap_space_t *sw, uint32_t vpn) {\n    for (uint32_t i = 0; i < MAX_SWAP_PAGES; i++) {\n        if (sw->slots[i].in_use && sw->slots[i].vpn == vpn) return i;\n    }\n    return UINT32_MAX;\n}\n/*\n * Allocate a new swap slot.\n * Returns slot index, or UINT32_MAX if swap is full (simulated swap exhaustion).\n */\nstatic uint32_t swap_alloc_slot(swap_space_t *sw, uint32_t vpn) {\n    /* First check if this VPN already has a slot (reuse it) */\n    uint32_t existing = swap_find_slot(sw, vpn);\n    if (existing != UINT32_MAX) return existing;\n    for (uint32_t i = 0; i < MAX_SWAP_PAGES; i++) {\n        if (!sw->slots[i].in_use) {\n            sw->slots[i].in_use = true;\n            sw->slots[i].vpn    = vpn;\n            return i;\n        }\n    }\n    return UINT32_MAX;   /* swap full â€” swap exhaustion! */\n}\n/*\n * Page-out: write a dirty frame to swap.\n * Called during eviction when frame_desc.dirty == true.\n *\n * In a real OS: this triggers a disk write. The process that caused the\n * eviction may be blocked (sleeping) until the I/O completes, or the OS\n * may run the I/O asynchronously and reclaim the frame later.\n *\n * In the simulator: memcpy to the swap slot array.\n *\n * Returns false if swap is full (cannot evict dirty page â€” critical error).\n */\nbool swap_page_out(phys_mem_t *pm, swap_space_t *sw,\n                    uint32_t frame, uint32_t vpn) {\n    uint32_t slot = swap_alloc_slot(sw, vpn);\n    if (slot == UINT32_MAX) {\n        fprintf(stderr, \"[SWAP FULL] Cannot evict dirty VPN=0x%05X\\n\", vpn);\n        return false;\n    }\n    /* Copy frame data to swap slot */\n    memcpy(sw->slots[slot].data, pm->data[frame], PAGE_SIZE);\n    sw->write_backs++;\n    fprintf(stderr, \"[SWAP OUT] VPN=0x%05X â†’ swap slot %u (dirty write-back)\\n\",\n            vpn, slot);\n    return true;\n}\n/*\n * Page-in: load a page back from swap into a freshly freed frame.\n * Called during page-fault handling when the faulting VPN has data in swap.\n *\n * In a real OS: disk read, 10â€“100ms latency, process sleeps on I/O.\n * In the simulator: memcpy from swap slot to frame.\n *\n * Returns false if the VPN has no data in swap (first-time fault).\n */\nbool swap_page_in(phys_mem_t *pm, swap_space_t *sw,\n                   uint32_t frame, uint32_t vpn) {\n    uint32_t slot = swap_find_slot(sw, vpn);\n    if (slot == UINT32_MAX) {\n        /* Not in swap: first-time access, zero-fill the frame */\n        memset(pm->data[frame], 0, PAGE_SIZE);\n        return false;\n    }\n    /* Restore saved data */\n    memcpy(pm->data[frame], sw->slots[slot].data, PAGE_SIZE);\n    sw->slots[slot].in_use = false;   /* free the swap slot */\n    sw->page_ins++;\n    fprintf(stderr, \"[SWAP IN]  VPN=0x%05X â† swap slot %u\\n\", vpn, slot);\n    return true;\n}\n```\n**Why freeing the swap slot on page-in matters:** Once the page is back in RAM (dirty bit clear â€” it was just loaded), the swap slot contains stale data. If the page is later evicted again *without* being written to, it's clean â€” its on-disk representation is the original file (or zero-fill for anonymous pages). Keeping the swap slot occupied unnecessarily wastes swap capacity and confuses the `swap_find_slot()` logic on the next eviction.\n---\n## The Eviction Core: Shared Across All Policies\nOnce a policy selects a victim frame, the mechanics of eviction are identical regardless of which algorithm chose it:\n```c\n/*\n * Evict a specific frame: handle dirty write-back, clear PTE, invalidate TLB.\n *\n * This is the eviction core â€” called by all four replacement algorithms\n * after they've chosen their victim frame.\n *\n * INVARIANT: After this call, frame is in_use=false, and victim_vpn's\n * PTE has valid=0. The TLB entry for victim_vpn is invalidated.\n */\nreplace_result_t evict_frame(phys_mem_t *pm, swap_space_t *sw,\n                              page_table_t *pt, tlb_t *tlb,\n                              uint32_t victim_frame) {\n    frame_desc_t *fd = &pm->desc[victim_frame];\n    uint32_t victim_vpn = fd->vpn;\n    bool was_dirty = fd->dirty;\n    /*\n     * Step 1: If dirty, write to swap BEFORE clearing anything.\n     * Order matters: if you clear the PTE first and the write-back fails,\n     * the page's data is gone with no way to recover it.\n     */\n    if (was_dirty) {\n        bool ok = swap_page_out(pm, sw, victim_frame, victim_vpn);\n        if (!ok) {\n            /* Swap full â€” fatal in simulator; real OS would block or OOM-kill */\n            fprintf(stderr, \"[FATAL] Swap full during eviction of VPN=0x%05X\\n\",\n                    victim_vpn);\n            /* Return invalid result â€” caller must handle */\n            return (replace_result_t){ .freed_frame = UINT32_MAX };\n        }\n    } else {\n        fprintf(stderr, \"[EVICT]    VPN=0x%05X clean â€” frame %u freed\\n\",\n                victim_vpn, victim_frame);\n    }\n    /*\n     * Step 2: Invalidate the TLB entry for victim_vpn.\n     * This MUST happen before the frame is reused.\n     * If a stale TLB entry remains, future accesses to victim_vpn would\n     * return a PFN that now belongs to a DIFFERENT page.\n     */\n    if (tlb) {\n        tlb_flush_page(tlb, pt, victim_vpn);\n    }\n    /*\n     * Step 3: Clear the PTE â€” mark the page as no longer in memory.\n     * The dirty and referenced bits are cleared; if the page was dirty,\n     * it's now safely in swap. Permissions are preserved (they're part\n     * of the virtual-to-physical mapping that survives eviction).\n     */\n    pte_t *pte = &pt->entries[victim_vpn];\n    *pte &= ~(PTE_VALID | PTE_DIRTY | PTE_REFERENCED);\n    /* Note: PTE_PERM_READ, PTE_PERM_WRITE stay â€” they're still valid\n     * for when the page is reloaded from swap. */\n    /*\n     * Step 4: Reset the frame descriptor for reuse.\n     */\n    fd->vpn         = UINT32_MAX;\n    fd->in_use      = false;\n    fd->ref_bit     = false;\n    fd->dirty       = false;\n    fd->load_time   = 0;\n    fd->last_access = 0;\n    return (replace_result_t){\n        .freed_frame  = victim_frame,\n        .evicted_vpn  = victim_vpn,\n        .was_dirty    = was_dirty,\n    };\n}\n```\n**Order is life-critical.** The three operations â€” write-back, TLB invalidation, PTE clear â€” must happen in exactly this sequence. Write-back before PTE clear ensures the data survives if the write-back somehow fails. TLB invalidation before the frame is reused ensures no stale translations point to the newly reassigned frame. This ordering is the same discipline enforced in production kernels: Linux's `try_to_unmap()` + `pageout()` sequence follows this exact order.\n---\n## FIFO: The Naive Baseline\nFIFO (First In, First Out) is the simplest conceivable replacement policy: evict the page that has been in memory the longest. No access tracking, no reference bits, no future knowledge. Just: who got here first, leaves first.\n\n![FIFO Page Replacement â€” Step-by-Step Trace](./diagrams/diag-m4-fifo-trace-example.svg)\n\n```c\n/*\n * FIFO replacement: evict the frame with the smallest load_time.\n *\n * Implementation: scan all frames, find minimum load_time among in_use frames.\n * Alternative (more efficient): maintain a FIFO queue of frame indices.\n * Here we scan for simplicity and for consistency with the LRU timestamp approach.\n *\n * Complexity: O(num_frames) â€” acceptable; real FIFO uses an O(1) queue.\n *\n * Returns the index of the victim frame.\n */\nstatic uint32_t fifo_select_victim(const phys_mem_t *pm) {\n    uint32_t victim    = UINT32_MAX;\n    uint64_t min_time  = UINT64_MAX;\n    for (uint32_t i = 0; i < pm->num_frames; i++) {\n        if (!pm->desc[i].in_use) continue;\n        if (pm->desc[i].load_time < min_time) {\n            min_time = pm->desc[i].load_time;\n            victim   = i;\n        }\n    }\n    return victim;\n}\nreplace_result_t replace_fifo(phys_mem_t *pm, swap_space_t *sw,\n                               page_table_t *pt, tlb_t *tlb) {\n    uint32_t victim = fifo_select_victim(pm);\n    if (victim == UINT32_MAX) {\n        fprintf(stderr, \"[BUG] FIFO: no victim found despite full memory\\n\");\n        return (replace_result_t){ .freed_frame = UINT32_MAX };\n    }\n    fprintf(stderr, \"[FIFO] Evicting VPN=0x%05X (frame %u, loaded at t=%lu)\\n\",\n            pm->desc[victim].vpn, victim, pm->desc[victim].load_time);\n    return evict_frame(pm, sw, pt, tlb, victim);\n}\n```\nFIFO's simplicity is appealing. Its correctness is easy to verify: given any reference string, you can trace through it by hand and count faults. This is why it's the standard baseline in OS textbooks and the one that exhibits BÃ©lÃ¡dy's anomaly â€” which we'll demonstrate shortly.\n**FIFO's fundamental flaw:** It treats all pages equally regardless of recency. A page loaded at time T=0 and accessed constantly will be evicted before a page loaded at T=1 and never touched again. FIFO has no concept of \"usefulness\" â€” only \"age.\"\n---\n## LRU: Near-Optimal but Impractical to Implement Honestly\nLRU (Least Recently Used) is theoretically near-optimal. Its intuition is powerful: if you've used a page recently, you're likely to use it again soon (temporal locality). The page you haven't touched in the longest time is the best eviction candidate.\n\n![LRU Page Replacement â€” Step-by-Step Trace (Same Reference String)](./diagrams/diag-m4-lru-trace-example.svg)\n\nIn a simulator, you can implement *true* LRU using timestamps:\n```c\n/*\n * LRU replacement: evict the frame with the smallest last_access time.\n *\n * In the simulator: last_access is updated on every access to a page\n * (in the translation path, after TLB miss resolution).\n *\n * IMPORTANT: update pm->desc[frame].last_access = pm->clock++ on EVERY\n * access (not just on faults). This is what makes LRU accurate.\n * Without this, LRU degenerates to FIFO (only load time matters).\n *\n * Hardware reality: real MMUs set only a referenced BIT, not a timestamp.\n * True LRU requires software intervention on every access â€” impractical\n * at billions of accesses per second.\n *\n * Returns the index of the victim frame.\n */\nstatic uint32_t lru_select_victim(const phys_mem_t *pm) {\n    uint32_t victim    = UINT32_MAX;\n    uint64_t min_time  = UINT64_MAX;\n    for (uint32_t i = 0; i < pm->num_frames; i++) {\n        if (!pm->desc[i].in_use) continue;\n        if (pm->desc[i].last_access < min_time) {\n            min_time = pm->desc[i].last_access;\n            victim   = i;\n        }\n    }\n    return victim;\n}\nreplace_result_t replace_lru(phys_mem_t *pm, swap_space_t *sw,\n                               page_table_t *pt, tlb_t *tlb) {\n    uint32_t victim = lru_select_victim(pm);\n    if (victim == UINT32_MAX) {\n        fprintf(stderr, \"[BUG] LRU: no victim found\\n\");\n        return (replace_result_t){ .freed_frame = UINT32_MAX };\n    }\n    fprintf(stderr, \"[LRU] Evicting VPN=0x%05X (frame %u, last accessed t=%lu)\\n\",\n            pm->desc[victim].vpn, victim, pm->desc[victim].last_access);\n    return evict_frame(pm, sw, pt, tlb, victim);\n}\n```\n**Updating `last_access` on the translation hot path:**\n```c\n/*\n * Called in the TLB-miss path after a successful page table walk,\n * and on TLB hits (via the frame descriptor update).\n *\n * This is where the O(1) metadata update happens for our simulated LRU.\n * In real hardware: this would require hardware support not available.\n * In the simulator: we pay the cost willingly for accuracy.\n */\nvoid phys_record_access(phys_mem_t *pm, uint32_t frame) {\n    pm->clock++;\n    pm->desc[frame].last_access = pm->clock;\n    pm->desc[frame].ref_bit     = true;   /* also set for Clock algorithm */\n}\n```\n\n![LRU Implementation: Timestamps vs Doubly-Linked List](./diagrams/diag-m4-lru-implementation-comparison.svg)\n\n**Why LRU is impractical in hardware:** The `last_access` timestamp requires 64 bits per frame. Updating it on every access means 64 bits Ã— billions of accesses per second = unacceptable memory bandwidth just for bookkeeping. Real hardware gives you one bit. That's the constraint that makes the Clock algorithm the practical answer.\n---\n## The Clock Algorithm: The Production Workhorse\nThe Clock algorithm (also called Second-Chance or Not-Recently-Used) is the algorithm that actually ships in operating systems. It achieves near-LRU performance using only the single `referenced` bit that hardware provides â€” no timestamps, no lists, no per-access bookkeeping.\n[[EXPLAIN:clock-algorithm-conceptual-model-circular-buffer-with-reference-bits|The Clock algorithm conceptual model: a circular buffer of frames with a sweeping hand that clears reference bits on one pass and evicts on the second pass]]\n**The key insight:** A page that has been accessed at any point since the clock hand last swept past it gets a \"second chance\" â€” its reference bit is cleared instead of the page being evicted. Only pages that the hand encounters with `ref_bit=false` (meaning they haven't been accessed since the hand's last pass) are actual eviction candidates.\n\n![Clock (Second-Chance) Algorithm â€” Circular Buffer Walk](./diagrams/diag-m4-clock-algorithm.svg)\n\n```c\n/*\n * Clock (Second-Chance) replacement.\n *\n * State: clock_hand â€” index into phys_mem[], advances circularly.\n *        ref_bit per frame â€” set by hardware on any access, cleared by Clock.\n *\n * Algorithm:\n *   While (victim not found):\n *     frame = frames[clock_hand]\n *     if frame.in_use AND frame.ref_bit == false:\n *       â†’ EVICT this frame (it hasn't been accessed since last sweep)\n *     else if frame.in_use AND frame.ref_bit == true:\n *       â†’ Clear ref_bit (\"second chance\")\n *       â†’ Advance hand\n *     else (frame not in use):\n *       â†’ Advance hand (skip free frames)\n *\n * Worst case: two full sweeps of all frames before finding a victim.\n * Average case: O(1) amortized (frames become evictable after ~1 sweep).\n *\n * The clock_hand persists across calls â€” it remembers where it stopped.\n * This is ESSENTIAL: if it restarted from 0 each time, recently-cleared\n * bits would be immediately reconsidered before they accumulate more accesses.\n */\nreplace_result_t replace_clock(phys_mem_t *pm, swap_space_t *sw,\n                                 page_table_t *pt, tlb_t *tlb,\n                                 uint32_t *clock_hand) {\n    uint32_t sweeps = 0;\n    uint32_t max_sweeps = 2 * pm->num_frames;   /* safety: prevent infinite loop */\n    while (sweeps < max_sweeps) {\n        uint32_t i = *clock_hand;\n        frame_desc_t *fd = &pm->desc[i];\n        *clock_hand = (i + 1) % pm->num_frames;   /* advance hand */\n        sweeps++;\n        if (!fd->in_use) continue;   /* skip free frames */\n        if (fd->ref_bit) {\n            /* Second chance: clear the bit, move on */\n            fd->ref_bit = false;\n            /* Also clear the referenced bit in the PTE â€” OS does this too */\n            pt->entries[fd->vpn] &= ~PTE_REFERENCED;\n            fprintf(stderr, \"[CLOCK] VPN=0x%05X ref_bit cleared, second chance\\n\",\n                    fd->vpn);\n        } else {\n            /* ref_bit is 0: this page hasn't been used since last sweep â€” evict it */\n            fprintf(stderr, \"[CLOCK] Evicting VPN=0x%05X (frame %u, ref_bit=0)\\n\",\n                    fd->vpn, i);\n            return evict_frame(pm, sw, pt, tlb, i);\n        }\n    }\n    /*\n     * If we swept twice without finding a victim, every frame had ref_bit=1.\n     * After one full sweep, all bits are cleared; second sweep finds a victim.\n     * If we still didn't find one â€” BUG (should be impossible).\n     */\n    fprintf(stderr, \"[BUG] Clock: failed to find victim after %u sweeps\\n\", max_sweeps);\n    return (replace_result_t){ .freed_frame = UINT32_MAX };\n}\n```\n**Why the clock hand persists across calls:** If the hand reset to frame 0 after every replacement, it would always evaluate the same frames first. Frames near the start of the array would be evicted disproportionately, and frames at the end would accumulate references without scrutiny. The persistent hand gives every frame equal opportunity to be either protected (by accumulating a reference bit) or evicted (by having its bit swept clear).\n**Hardware soul â€” Clock vs LRU:** Every memory access in Clock requires zero bookkeeping work (the MMU sets `ref_bit` automatically, for free). The OS's clock daemon runs periodically â€” not on every access â€” sweeping through frames and clearing bits. This is why Clock is O(1) amortized per eviction: the work is spread across all accesses, not concentrated per-access. LRU with timestamps requires O(1) work per *access* (timestamp update), which is 3 billion writes/second on a modern CPU. Clock requires O(frames_swept) per *eviction*, amortized to near zero per access.\n---\n## The Working Set Model: Why Thrashing Happens\nBefore implementing Optimal and analyzing the statistics, you need a framework for understanding *why* page fault rates behave the way they do. The working set model gives you that framework.\n[[EXPLAIN:working-set-model-and-locality-of-reference|Working set model and locality of reference â€” the set of pages actively used in a time window, how it determines the minimum frames needed for efficient execution, and why exceeding it causes thrashing]]\nThe **working set** of a process at time T, with window size Î”, is the set of distinct pages accessed in the interval `[T - Î”, T]`. If physical memory provides fewer frames than the working set size, the process cannot make progress without constantly faulting â€” this is **thrashing**.\n```c\n/*\n * Working set tracker.\n *\n * Maintains a sliding window of the last WINDOW_SIZE accesses.\n * Working set size = number of distinct VPNs in that window.\n *\n * This is O(WINDOW_SIZE) per access â€” acceptable for the simulator.\n * Production systems approximate this with the referenced bit: pages\n * with ref_bit=1 in the current epoch are \"in the working set.\"\n */\n#define WORKING_SET_WINDOW  10u   /* configurable */\ntypedef struct {\n    uint32_t  history[WORKING_SET_WINDOW];  /* ring buffer of recent VPNs */\n    uint32_t  head;                          /* next write position         */\n    uint32_t  filled;                        /* how many entries are valid  */\n} working_set_tracker_t;\nvoid ws_init(working_set_tracker_t *ws) {\n    memset(ws, 0, sizeof(*ws));\n    for (uint32_t i = 0; i < WORKING_SET_WINDOW; i++) {\n        ws->history[i] = UINT32_MAX;  /* sentinel: empty slot */\n    }\n}\n/*\n * Record a page access and return the current working set size.\n */\nuint32_t ws_record_access(working_set_tracker_t *ws, uint32_t vpn) {\n    /* Add to ring buffer */\n    ws->history[ws->head] = vpn;\n    ws->head = (ws->head + 1) % WORKING_SET_WINDOW;\n    if (ws->filled < WORKING_SET_WINDOW) ws->filled++;\n    /* Count distinct VPNs in the window â€” O(WINDOW_SIZE^2) */\n    uint32_t distinct = 0;\n    for (uint32_t i = 0; i < ws->filled; i++) {\n        uint32_t v = ws->history[i];\n        if (v == UINT32_MAX) continue;\n        bool is_duplicate = false;\n        for (uint32_t j = 0; j < i; j++) {\n            if (ws->history[j] == v) { is_duplicate = true; break; }\n        }\n        if (!is_duplicate) distinct++;\n    }\n    return distinct;\n}\n```\n\n![Working Set Size Over Time â€” Sliding Window Visualization](./diagrams/diag-m4-working-set-window.svg)\n\n**Thrashing detection:** track the working set size over time. If `ws_size > pm->num_frames` consistently, you're in a thrashing regime â€” every access faults because the active pages can't all fit in memory. Real OS kernels detect this via page fault frequency: if a process's fault rate exceeds a threshold, the kernel may suspend the process (via working set model enforcement) rather than let it thrash and drag down every other process.\n---\n## Optimal (BÃ©lÃ¡dy's Algorithm): The Theoretical Lower Bound\nOptimal page replacement evicts the page that will not be needed for the **longest time in the future**. This is provably the fewest possible page faults for any algorithm â€” it's the theoretical lower bound, the ceiling no algorithm can exceed.\nThe catch: you need to know the future. In a real running system, you can't. Optimal is not a practical algorithm â€” it's a **benchmark**. You run it on a recorded trace (which you have in full), compare your FIFO/LRU/Clock fault counts against it, and the gap tells you how much headroom exists for better heuristics.\n\n![Optimal (BÃ©lÃ¡dy's) Algorithm â€” Look-Ahead Trace](./diagrams/diag-m4-optimal-beladys.svg)\n\n```c\n/*\n * Optimal (BÃ©lÃ¡dy's) replacement.\n *\n * Requires the complete future access trace from current_idx onward.\n * This is only possible in a simulator â€” not in a real OS.\n *\n * Algorithm:\n *   For each frame currently in memory:\n *     Find the next access to that frame's VPN in future[current_idx..]\n *     If a VPN never appears again: it's the ideal victim (evict immediately)\n *     Otherwise: record the distance to next access\n *   Evict the frame with the LARGEST next-access distance\n *   (the page we won't need for the longest time)\n *\n * Time complexity: O(num_frames Ã— remaining_trace) â€” expensive but offline.\n * Space: O(1) extra beyond the trace (we scan forward per candidate).\n */\nstatic uint32_t optimal_select_victim(const phys_mem_t *pm,\n                                        const mem_access_t *future,\n                                        size_t future_len,\n                                        size_t current_idx) {\n    uint32_t victim      = UINT32_MAX;\n    uint64_t max_dist    = 0;\n    for (uint32_t i = 0; i < pm->num_frames; i++) {\n        if (!pm->desc[i].in_use) continue;\n        uint32_t vpn = pm->desc[i].vpn;\n        /* Find next use of this VPN in the future */\n        uint64_t next_use = UINT64_MAX;  /* \"never used again\" */\n        for (size_t j = current_idx; j < future_len; j++) {\n            if (vpn_from_addr(future[j].vaddr) == vpn) {\n                next_use = (uint64_t)(j - current_idx);\n                break;\n            }\n        }\n        /* A page never used again is the perfect victim */\n        if (next_use == UINT64_MAX) {\n            fprintf(stderr, \"[OPT] VPN=0x%05X never used again â€” ideal victim\\n\", vpn);\n            return i;\n        }\n        if (next_use > max_dist) {\n            max_dist = next_use;\n            victim   = i;\n        }\n    }\n    fprintf(stderr, \"[OPT] Evicting VPN=0x%05X (next use in %lu steps)\\n\",\n            pm->desc[victim].vpn, max_dist);\n    return victim;\n}\nreplace_result_t replace_optimal(phys_mem_t *pm, swap_space_t *sw,\n                                   page_table_t *pt, tlb_t *tlb,\n                                   const mem_access_t *future, size_t future_len,\n                                   size_t current_idx) {\n    uint32_t victim = optimal_select_victim(pm, future, future_len, current_idx);\n    if (victim == UINT32_MAX) {\n        fprintf(stderr, \"[BUG] Optimal: no victim selected\\n\");\n        return (replace_result_t){ .freed_frame = UINT32_MAX };\n    }\n    return evict_frame(pm, sw, pt, tlb, victim);\n}\n```\n**Optimal's off-by-one discipline:** `current_idx` points to the access *currently being handled* (the faulting access). The look-ahead begins at `current_idx` (not `current_idx + 1`) to correctly identify the very next use of each candidate VPN in the future trace. If you start at `current_idx + 1`, you may incorrectly believe the currently faulting page has no near future use.\n---\n## The Dispatcher: Wiring All Four Policies Together\n```c\n/*\n * Unified replacement dispatcher.\n * Selects algorithm based on policy, then calls the shared eviction core.\n */\nreplace_result_t replace_page(phys_mem_t *pm, swap_space_t *sw,\n                               page_table_t *pt, tlb_t *tlb,\n                               replacement_policy_t policy,\n                               const mem_access_t *future, size_t future_len,\n                               size_t current_idx,\n                               uint32_t *clock_hand) {\n    switch (policy) {\n        case POLICY_FIFO:\n            return replace_fifo(pm, sw, pt, tlb);\n        case POLICY_LRU:\n            return replace_lru(pm, sw, pt, tlb);\n        case POLICY_CLOCK:\n            return replace_clock(pm, sw, pt, tlb, clock_hand);\n        case POLICY_OPTIMAL:\n            return replace_optimal(pm, sw, pt, tlb, future, future_len, current_idx);\n        default:\n            fprintf(stderr, \"[BUG] Unknown policy %d\\n\", (int)policy);\n            return (replace_result_t){ .freed_frame = UINT32_MAX };\n    }\n}\n```\n---\n## The Full Simulation Loop with Replacement\nNow the page fault handler from Milestone 1 gains a new capability: when `alloc_free_frame()` returns `UINT32_MAX`, instead of failing, it invokes the replacement policy:\n```c\n/*\n * Statistics collected per algorithm run.\n */\ntypedef struct {\n    replacement_policy_t policy;\n    const char          *name;\n    uint64_t             total_accesses;\n    uint64_t             page_faults;\n    uint64_t             dirty_writebacks;\n    uint64_t             page_ins;\n    uint64_t             protection_faults;\n    uint32_t             peak_working_set;\n} sim_stats_t;\n/*\n * Run the full simulation for one policy over the complete trace.\n *\n * Resets physical memory and swap between runs so each algorithm\n * starts from the same blank-slate state.\n *\n * Returns statistics for this run.\n */\nsim_stats_t run_simulation(const mem_access_t *accesses, size_t count,\n                            uint32_t num_frames,\n                            replacement_policy_t policy,\n                            page_table_t *pt,   /* reset by caller */\n                            tlb_t *tlb) {       /* reset by caller */\n    phys_mem_t  pm;\n    swap_space_t sw;\n    phys_mem_init(&pm, num_frames);\n    memset(&sw, 0, sizeof(sw));\n    uint32_t clock_hand = 0;\n    working_set_tracker_t ws;\n    ws_init(&ws);\n    sim_stats_t stats = {\n        .policy = policy,\n        .name   = policy == POLICY_FIFO    ? \"FIFO\"    :\n                  policy == POLICY_LRU     ? \"LRU\"     :\n                  policy == POLICY_CLOCK   ? \"Clock\"   : \"Optimal\",\n    };\n    for (size_t i = 0; i < count; i++) {\n        const mem_access_t *acc = &accesses[i];\n        stats.total_accesses++;\n        uint32_t vpn    = vpn_from_addr(acc->vaddr);\n        uint32_t offset = offset_from_addr(acc->vaddr);\n        /*â”€â”€ Update working set â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n        uint32_t ws_size = ws_record_access(&ws, vpn);\n        if (ws_size > stats.peak_working_set)\n            stats.peak_working_set = ws_size;\n        /*â”€â”€ TLB Lookup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n        if (tlb) {\n            tlb_lookup_t tr = tlb_lookup(tlb, vpn, acc->type);\n            if (tr.result == XLATE_TLB_HIT) {\n                phys_record_access(&pm, tr.pfn);  /* update LRU/Clock metadata */\n                continue;                          /* no fault needed */\n            }\n        }\n        /*â”€â”€ Page table walk â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n        pte_t *pte = &pt->entries[vpn];\n        if (!(*pte & PTE_VALID)) {\n            /*â”€â”€ Page Fault â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n            stats.page_faults++;\n            /* Try to get a free frame */\n            uint32_t frame = phys_find_free(&pm);\n            if (frame == UINT32_MAX) {\n                /* All frames occupied â€” invoke replacement */\n                replace_result_t rr = replace_page(&pm, &sw, pt, tlb,\n                                                    policy,\n                                                    accesses, count, i,\n                                                    &clock_hand);\n                if (rr.freed_frame == UINT32_MAX) {\n                    fprintf(stderr, \"[FATAL] Replacement failed at access %zu\\n\", i);\n                    break;\n                }\n                frame = rr.freed_frame;\n                if (rr.was_dirty) stats.dirty_writebacks++;\n            }\n            /* Load page into frame (from swap if available, else zero-fill) */\n            bool from_swap = swap_page_in(&pm, &sw, frame, vpn);\n            if (from_swap) stats.page_ins++;\n            /* Set up the frame descriptor */\n            pm.clock++;\n            pm.desc[frame].vpn         = vpn;\n            pm.desc[frame].load_time   = pm.clock;\n            pm.desc[frame].last_access = pm.clock;\n            pm.desc[frame].ref_bit     = true;\n            pm.desc[frame].dirty       = false;   /* freshly loaded = clean */\n            pm.desc[frame].in_use      = true;\n            /* Install PTE */\n            *pte = pte_make(frame, /*readable=*/1,\n                            /*writable=*/(acc->type == ACCESS_WRITE));\n            /* Insert into TLB */\n            if (tlb) {\n                int writable = (acc->type == ACCESS_WRITE) ? 1 : 0;\n                tlb_insert(tlb, pt, vpn, frame, writable, /*use_random=*/0);\n            }\n        }\n        /*â”€â”€ Permission check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n        if (acc->type == ACCESS_WRITE && !(*pte & PTE_PERM_WRITE)) {\n            stats.protection_faults++;\n            continue;\n        }\n        /*â”€â”€ Update access metadata â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/\n        uint32_t frame = pte_get_pfn(*pte);\n        phys_record_access(&pm, frame);   /* updates last_access, ref_bit */\n        *pte |= PTE_REFERENCED;\n        if (acc->type == ACCESS_WRITE) {\n            *pte |= PTE_DIRTY;\n            pm.desc[frame].dirty = true;\n        }\n    }\n    stats.dirty_writebacks += sw.write_backs;\n    stats.page_ins         += sw.page_ins;\n    return stats;\n}\n```\n**Why reset state between algorithm runs?** The comparison is only valid if every algorithm sees the same initial condition â€” empty memory, no swap data, no TLB entries. Otherwise you're measuring the combined effect of \"which algorithm benefited from the previous algorithm's warm-up\" rather than the algorithm's intrinsic policy behavior. Each run must start cold.\n---\n## BÃ©lÃ¡dy's Anomaly: When More Memory Makes Things Worse\nThis is the result you need to demonstrate. It's not obvious. It challenges your intuition. It has practical consequences for capacity planning.\n**The anomaly:** For FIFO replacement, there exist reference strings where increasing the number of frames *increases* the number of page faults.\n\n![BÃ©lÃ¡dy's Anomaly: FIFO Gets WORSE with More Frames](./diagrams/diag-m4-beladys-anomaly.svg)\n\nThe classic demonstration uses this reference string:\n```\n1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5\n```\nFor this reference string:\n- With **3 frames**: 9 page faults\n- With **4 frames**: 10 page faults (MORE faults with MORE frames!)\nLet's trace through it in code:\n```c\n/*\n * BÃ©lÃ¡dy's anomaly demonstration trace.\n * Reference string: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5\n * (each VPN maps to an address on that page: VPN=N â†’ address N*4096)\n *\n * Save this as \"beladys.trace\":\n */\nstatic const char BELADYS_TRACE[] =\n    \"R 0x00001000\\n\"   /* VPN 1 */\n    \"R 0x00002000\\n\"   /* VPN 2 */\n    \"R 0x00003000\\n\"   /* VPN 3 */\n    \"R 0x00004000\\n\"   /* VPN 4 */\n    \"R 0x00001000\\n\"   /* VPN 1 */\n    \"R 0x00002000\\n\"   /* VPN 2 */\n    \"R 0x00005000\\n\"   /* VPN 5 */\n    \"R 0x00001000\\n\"   /* VPN 1 */\n    \"R 0x00002000\\n\"   /* VPN 2 */\n    \"R 0x00003000\\n\"   /* VPN 3 */\n    \"R 0x00004000\\n\"   /* VPN 4 */\n    \"R 0x00005000\\n\";  /* VPN 5 */\n/*\n * Why this trace causes the anomaly with FIFO:\n *\n * With 3 frames (FIFO trace):\n * Access:   1    2    3    4    1    2    5    1    2    3    4    5\n * Frames:\n *   After 1: [1  -  -]                                         FAULT\n *   After 2: [1  2  -]                                         FAULT\n *   After 3: [1  2  3]                                         FAULT\n *   After 4: [4  2  3] evict 1 (oldest)                        FAULT\n *   After 1: [4  1  3] evict 2                                 FAULT\n *   After 2: [4  1  2] evict 3                                 FAULT\n *   After 5: [5  1  2] evict 4                                 FAULT\n *   After 1: HIT [5 1 2]\n *   After 2: HIT [5 1 2]\n *   After 3: [5  3  2] evict 1                                 FAULT\n *   After 4: [5  3  4] evict 2                                 FAULT\n *   After 5: HIT [5 3 4]\n * Total faults with 3 frames: 9\n *\n * With 4 frames (FIFO trace):\n * Access:   1    2    3    4    1    2    5    1    2    3    4    5\n * Frames:\n *   After 1: [1  -  -  -]                                      FAULT\n *   After 2: [1  2  -  -]                                      FAULT\n *   After 3: [1  2  3  -]                                      FAULT\n *   After 4: [1  2  3  4]                                      FAULT\n *   After 1: HIT [1 2 3 4]\n *   After 2: HIT [1 2 3 4]\n *   After 5: [5  2  3  4] evict 1 (oldest)                     FAULT\n *   After 1: [5  1  3  4] evict 2                              FAULT\n *   After 2: [5  1  2  4] evict 3                              FAULT\n *   After 3: [5  1  2  3] evict 4                              FAULT\n *   After 4: [4  1  2  3] evict 5                              FAULT\n *   After 5: [4  5  2  3] evict 1                              FAULT\n * Total faults with 4 frames: 10 â† MORE than 3 frames!\n */\nvoid demonstrate_beladys_anomaly(void) {\n    /* Parse the reference string into accesses */\n    mem_access_t accesses[12];\n    uint32_t vpns[] = {1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5};\n    for (int i = 0; i < 12; i++) {\n        accesses[i].type  = ACCESS_READ;\n        accesses[i].vaddr = vpns[i] * PAGE_SIZE;\n    }\n    printf(\"\\n=== BÃ©lÃ¡dy's Anomaly Demonstration ===\\n\");\n    printf(\"Reference string: 1,2,3,4,1,2,5,1,2,3,4,5\\n\\n\");\n    for (uint32_t nframes = 3; nframes <= 6; nframes++) {\n        page_table_t pt;\n        memset(&pt, 0, sizeof(pt));\n        sim_stats_t stats = run_simulation(accesses, 12, nframes,\n                                            POLICY_FIFO, &pt, /*tlb=*/NULL);\n        printf(\"FIFO with %u frames: %lu page faults\\n\",\n               nframes, stats.page_faults);\n    }\n    printf(\"\\nExpected: 3 frames â†’ 9 faults, 4 frames â†’ 10 faults\\n\");\n    printf(\"(FIFO gets WORSE with more frames â€” BÃ©lÃ¡dy's anomaly)\\n\");\n    printf(\"\\nFor comparison (LRU â€” immune to anomaly):\\n\");\n    for (uint32_t nframes = 3; nframes <= 6; nframes++) {\n        page_table_t pt;\n        memset(&pt, 0, sizeof(pt));\n        sim_stats_t stats = run_simulation(accesses, 12, nframes,\n                                            POLICY_LRU, &pt, /*tlb=*/NULL);\n        printf(\"LRU  with %u frames: %lu page faults\\n\",\n               nframes, stats.page_faults);\n    }\n}\n```\n**Why LRU is immune to BÃ©lÃ¡dy's anomaly:** LRU belongs to a class called **stack algorithms**. For stack algorithms, the set of pages in memory with k frames is always a *subset* of the pages in memory with k+1 frames. Adding a frame to a stack algorithm can never evict a page that would have stayed with fewer frames â€” so more frames can only mean fewer or equal faults, never more.\nFIFO is not a stack algorithm. The page evicted with k frames might be a page that would have stayed with k+1 frames. Adding that extra frame displaces the FIFO ordering just enough to evict differently and create more misses.\nOptimal and LRU are both stack algorithms. Clock is an approximation of LRU and generally does not exhibit the anomaly in practice, though it lacks the formal proof.\n---\n## Comparative Statistics: All Four Algorithms Side by Side\n```c\n/*\n * Run all four algorithms on the same trace with the same frame count.\n * Print a comparative report.\n */\nvoid run_comparison(const mem_access_t *accesses, size_t count,\n                     uint32_t num_frames) {\n    replacement_policy_t policies[] = {\n        POLICY_FIFO, POLICY_LRU, POLICY_CLOCK, POLICY_OPTIMAL\n    };\n    sim_stats_t results[4];\n    printf(\"\\nRunning comparison: %zu accesses, %u frames\\n\\n\", count, num_frames);\n    for (int p = 0; p < 4; p++) {\n        page_table_t pt;\n        memset(&pt, 0, sizeof(pt));\n        results[p] = run_simulation(accesses, count, num_frames,\n                                     policies[p], &pt, /*tlb=*/NULL);\n    }\n    print_comparison_table(results, 4, count);\n}\nvoid print_comparison_table(const sim_stats_t *stats, int n, size_t total) {\n    printf(\"â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\\n\");\n    printf(\"â•‘ Algorithm    â•‘   Faults  â•‘ Fault%%    â•‘ WriteBack â•‘ Peak WS Size â•‘\\n\");\n    printf(\"â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"â•‘ %-12s â•‘ %9lu â•‘ %8.2f%% â•‘ %9lu â•‘ %12u â•‘\\n\",\n               stats[i].name,\n               stats[i].page_faults,\n               total > 0 ? 100.0 * stats[i].page_faults / total : 0.0,\n               stats[i].dirty_writebacks,\n               stats[i].peak_working_set);\n    }\n    printf(\"â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n\");\n    /* Print Optimal as the lower bound and efficiency ratios */\n    uint64_t opt_faults = 0;\n    for (int i = 0; i < n; i++) {\n        if (stats[i].policy == POLICY_OPTIMAL) opt_faults = stats[i].page_faults;\n    }\n    if (opt_faults > 0) {\n        printf(\"\\nEfficiency vs Optimal (lower = closer to optimal):\\n\");\n        for (int i = 0; i < n; i++) {\n            if (stats[i].policy == POLICY_OPTIMAL) continue;\n            double ratio = (double)stats[i].page_faults / (double)opt_faults;\n            printf(\"  %-8s: %.2fÃ— optimal (%+ld faults)\\n\",\n                   stats[i].name, ratio,\n                   (long)(stats[i].page_faults - opt_faults));\n        }\n    }\n}\n```\n\n![Comparative Statistics: All Four Algorithms Side by Side](./diagrams/diag-m4-algorithm-comparison-chart.svg)\n\n**Expected rankings for typical access patterns:**\n| Metric | Typical ranking |\n|--------|----------------|\n| Page faults | Optimal â‰¤ LRU â‰¤ Clock â‰¤ FIFO |\n| Dirty write-backs | Varies â€” depends on access pattern |\n| Implementation complexity | FIFO < Clock < LRU < Optimal |\n| Real-world usability | Clock (production) > LRU (simulation) > FIFO (baseline) > Optimal (offline) |\nThe dirty write-back count reveals something the raw fault count misses: an algorithm that makes good page choices may still incur more write-back I/O if its victim selection tends to hit dirty pages. Clock's approach of evicting unreferenced pages (regardless of dirty status) can sometimes cause more write-backs than FIFO â€” even with fewer total faults â€” because FIFO may happen to evict clean pages more often on a particular trace.\n---\n## Building and Testing\n### Compile\n```bash\ngcc -Wall -Wextra -O2 -std=c11 -o vmsim_m4 vmsim_m4.c\n```\n### Test 1: FIFO Correctness Against Known Output\n```c\nvoid test_fifo_known_trace(void) {\n    /*\n     * Classic reference string: 7,0,1,2,0,3,0,4,2,3,0,3,2\n     * With 3 frames, FIFO produces 9 page faults.\n     * (Standard result from Silberschatz OS textbook, Section 9.4)\n     */\n    uint32_t vpns[] = {7,0,1,2,0,3,0,4,2,3,0,3,2};\n    int n = sizeof(vpns)/sizeof(vpns[0]);\n    mem_access_t accesses[13];\n    for (int i = 0; i < n; i++) {\n        accesses[i].type  = ACCESS_READ;\n        accesses[i].vaddr = vpns[i] * PAGE_SIZE;\n    }\n    page_table_t pt;\n    memset(&pt, 0, sizeof(pt));\n    sim_stats_t stats = run_simulation(accesses, n, /*frames=*/3,\n                                        POLICY_FIFO, &pt, NULL);\n    assert(stats.page_faults == 9);\n    printf(\"FIFO known-trace test: PASSED (%lu faults, expected 9)\\n\",\n           stats.page_faults);\n}\n```\n### Test 2: LRU Correctness\n```c\nvoid test_lru_known_trace(void) {\n    /*\n     * Same reference string: 7,0,1,2,0,3,0,4,2,3,0,3,2\n     * With 3 frames, LRU produces 8 page faults.\n     */\n    uint32_t vpns[] = {7,0,1,2,0,3,0,4,2,3,0,3,2};\n    int n = sizeof(vpns)/sizeof(vpns[0]);\n    mem_access_t accesses[13];\n    for (int i = 0; i < n; i++) {\n        accesses[i].type  = ACCESS_READ;\n        accesses[i].vaddr = vpns[i] * PAGE_SIZE;\n    }\n    page_table_t pt;\n    memset(&pt, 0, sizeof(pt));\n    sim_stats_t stats = run_simulation(accesses, n, /*frames=*/3,\n                                        POLICY_LRU, &pt, NULL);\n    assert(stats.page_faults == 8);\n    printf(\"LRU known-trace test: PASSED (%lu faults, expected 8)\\n\",\n           stats.page_faults);\n}\n```\n### Test 3: Optimal Lower Bound\n```c\nvoid test_optimal_is_lower_bound(void) {\n    /*\n     * Property: Optimal must produce <= faults of any other algorithm\n     * for the same trace and frame count.\n     */\n    uint32_t vpns[] = {7,0,1,2,0,3,0,4,2,3,0,3,2};\n    int n = sizeof(vpns)/sizeof(vpns[0]);\n    mem_access_t accesses[13];\n    for (int i = 0; i < n; i++) {\n        accesses[i].type  = ACCESS_READ;\n        accesses[i].vaddr = vpns[i] * PAGE_SIZE;\n    }\n    uint64_t opt_faults, fifo_faults, lru_faults, clk_faults;\n    page_table_t pt;\n#define RUN(policy_, count_) ({                                          \\\n    memset(&pt, 0, sizeof(pt));                                          \\\n    run_simulation(accesses, n, 3, policy_, &pt, NULL).page_faults; })\n    opt_faults  = RUN(POLICY_OPTIMAL, n);\n    fifo_faults = RUN(POLICY_FIFO,    n);\n    lru_faults  = RUN(POLICY_LRU,     n);\n    clk_faults  = RUN(POLICY_CLOCK,   n);\n#undef RUN\n    assert(opt_faults <= fifo_faults);\n    assert(opt_faults <= lru_faults);\n    assert(opt_faults <= clk_faults);\n    printf(\"Optimal lower bound test: PASSED \"\n           \"(OPT=%lu â‰¤ LRU=%lu â‰¤ CLK=%lu â‰¤ FIFO=%lu)\\n\",\n           opt_faults, lru_faults, clk_faults, fifo_faults);\n}\n```\n### Test 4: Dirty Write-Back Correctness\n```c\nvoid test_dirty_writeback(void) {\n    /*\n     * Access sequence: write to VPN 1, then force eviction of VPN 1.\n     * Verify that a swap write-back occurred.\n     */\n    mem_access_t accesses[5];\n    /* Write to VPN 1 â€” marks it dirty */\n    accesses[0] = (mem_access_t){ .type = ACCESS_WRITE, .vaddr = 0x00001000 };\n    /* Fill 2 more frames (2-frame pool) */\n    accesses[1] = (mem_access_t){ .type = ACCESS_READ,  .vaddr = 0x00002000 };\n    /* Force FIFO eviction: first-loaded (VPN 1) should be evicted â€” dirty */\n    accesses[2] = (mem_access_t){ .type = ACCESS_READ,  .vaddr = 0x00003000 };\n    /* Now re-access VPN 1 â€” should reload from swap */\n    accesses[3] = (mem_access_t){ .type = ACCESS_READ,  .vaddr = 0x00001000 };\n    page_table_t pt;\n    memset(&pt, 0, sizeof(pt));\n    sim_stats_t stats = run_simulation(accesses, 4, /*frames=*/2,\n                                        POLICY_FIFO, &pt, NULL);\n    assert(stats.dirty_writebacks == 1);   /* VPN 1 was dirty when evicted */\n    assert(stats.page_faults >= 3);        /* VPN1, VPN2, VPN3 cold faults + VPN1 reload */\n    printf(\"Dirty write-back test: PASSED (%lu write-backs)\\n\",\n           stats.dirty_writebacks);\n}\n```\n### Test 5: BÃ©lÃ¡dy's Anomaly\n```c\nvoid test_beladys_anomaly(void) {\n    uint32_t vpns[] = {1,2,3,4,1,2,5,1,2,3,4,5};\n    int n = 12;\n    mem_access_t accesses[12];\n    for (int i = 0; i < n; i++) {\n        accesses[i].type  = ACCESS_READ;\n        accesses[i].vaddr = vpns[i] * PAGE_SIZE;\n    }\n    page_table_t pt3, pt4;\n    memset(&pt3, 0, sizeof(pt3));\n    memset(&pt4, 0, sizeof(pt4));\n    sim_stats_t s3 = run_simulation(accesses, n, 3, POLICY_FIFO, &pt3, NULL);\n    sim_stats_t s4 = run_simulation(accesses, n, 4, POLICY_FIFO, &pt4, NULL);\n    printf(\"BÃ©lÃ¡dy's anomaly: 3 frames=%lu faults, 4 frames=%lu faults\\n\",\n           s3.page_faults, s4.page_faults);\n    /* The anomaly: 4 frames produces MORE faults than 3 frames */\n    assert(s4.page_faults > s3.page_faults);\n    printf(\"BÃ©lÃ¡dy's anomaly confirmed: MORE frames â†’ MORE faults with FIFO\\n\");\n    /* Verify LRU is immune */\n    memset(&pt3, 0, sizeof(pt3));\n    memset(&pt4, 0, sizeof(pt4));\n    sim_stats_t l3 = run_simulation(accesses, n, 3, POLICY_LRU, &pt3, NULL);\n    sim_stats_t l4 = run_simulation(accesses, n, 4, POLICY_LRU, &pt4, NULL);\n    assert(l4.page_faults <= l3.page_faults);   /* LRU immune to anomaly */\n    printf(\"LRU immunity confirmed: %lu faults (3 frames) â‰¥ %lu faults (4 frames)\\n\",\n           l3.page_faults, l4.page_faults);\n}\n```\n### Test 6: Clock Advances Hand Correctly\n```c\nvoid test_clock_hand_persistence(void) {\n    /*\n     * Verify clock hand persists across calls.\n     * After N evictions, clock hand should be at a predictable position.\n     *\n     * Implementation detail: the caller passes a uint32_t* clock_hand\n     * and must preserve it between calls. Verify by observing that\n     * eviction patterns rotate through frames.\n     */\n    uint32_t clock_hand = 0;\n    uint32_t first_eviction_frame  = UINT32_MAX;\n    uint32_t second_eviction_frame = UINT32_MAX;\n    /* With all ref_bits initially false, first call should evict frame 0,\n     * second call frame 1, etc. (no second-chance needed on fresh state) */\n    phys_mem_t pm;\n    phys_mem_init(&pm, 4);\n    /* Fill all 4 frames with distinct VPNs, ref_bit=false */\n    for (uint32_t i = 0; i < 4; i++) {\n        pm.desc[i].in_use      = true;\n        pm.desc[i].vpn         = i + 1;\n        pm.desc[i].ref_bit     = false;\n        pm.desc[i].dirty       = false;\n    }\n    page_table_t pt;\n    memset(&pt, 0, sizeof(pt));\n    /* Install PTEs for VPNs 1-4 */\n    for (uint32_t vpn = 1; vpn <= 4; vpn++) {\n        pt.entries[vpn] = pte_make(vpn - 1, 1, 1);\n    }\n    swap_space_t sw;\n    memset(&sw, 0, sizeof(sw));\n    replace_result_t r1 = replace_clock(&pm, &sw, &pt, NULL, &clock_hand);\n    replace_result_t r2 = replace_clock(&pm, &sw, &pt, NULL, &clock_hand);\n    /* With all ref_bits=0 and hand starting at 0: frame 0 then frame 1 */\n    assert(r1.freed_frame == 0);\n    assert(r2.freed_frame == 1);\n    assert(clock_hand == 2);   /* hand advanced past both evicted frames */\n    printf(\"Clock hand persistence test: PASSED\\n\");\n}\n```\n---\n## Hardware Soul: What Real Operating Systems Do\nYour simulator implements page replacement in pure software with full visibility into all state. Real OS kernels have much harder constraints â€” and their solutions reveal decades of hard-won wisdom.\n**Linux's Two-List Approximation:**\nLinux doesn't use Clock directly. Instead, it maintains two LRU lists per zone (memory region): the **active list** and the **inactive list**. Pages enter the inactive list on first access. If a page on the inactive list is accessed again (referenced bit set), it's promoted to the active list. Pages are evicted only from the inactive list.\nThis is a two-chance policy: a page must be accessed at least twice before it's immune to immediate eviction. A page accessed exactly once (a \"streaming\" access that won't recur) stays on the inactive list and is evicted cheaply. A page accessed repeatedly earns active-list status and is protected.\nThe kernel's `kswapd` daemon runs when free memory falls below a threshold, moving pages from active to inactive (after clearing reference bits) and then from inactive to disk. This avoids synchronously evicting pages during page fault handling â€” a latency-critical path. Instead, replacement happens asynchronously, keeping a reserve of pre-freed frames available for fault handlers.\n**Cache line behavior of your frame descriptors:**\nYour `frame_desc_t` is 16 bytes. Four frame descriptors fit in one 64-byte cache line. When the Clock algorithm scans frames sequentially (the common case during replacement), it accesses frame descriptors in cache-line-aligned chunks â€” efficient sequential access. When the clock hand wraps around, it starts fresh from a cache-cold position. For large frame pools (thousands of frames), the initial sweep is cache-hostile; subsequent sweeps (with cleared reference bits) tend to terminate quickly on recently-cleared frames, keeping the scan length short.\n**TLB invalidation across CPUs â€” TLB shootdown:**\nIn a multiprocessor system, each CPU has its own TLB. When page `X` is evicted on CPU 0, CPUs 1, 2, and 3 might have cached translations for page X in their own TLBs. Before the frame can be reused, all other CPUs must invalidate their entry for that VPN. This requires an **inter-processor interrupt (IPI)** â€” CPU 0 sends an interrupt to all other CPUs, which each execute `INVLPG(X)` and acknowledge. Only after all CPUs acknowledge can CPU 0 consider the frame free.\nThis \"TLB shootdown\" is the most expensive operation in the page replacement path on SMP systems. On a 64-core machine evicting one page, you're waiting for 63 IPIs to round-trip before proceeding. High-performance workloads (databases, HPC) try hard to minimize page eviction frequency precisely to avoid shootdown overhead. Your simulator calls `tlb_flush_page()` once â€” simulating single-CPU behavior. A multi-CPU extension would need shootdown simulation.\n---\n## Knowledge Cascade: Page Replacement Connects Everywhere\n### 1. Redis and Sampled-LRU: The Same Compromise, Different Scale\nRedis needs to evict keys when it reaches its `maxmemory` limit. True LRU would require tracking access time for every key â€” billions of keys, billions of updates per second â€” the same O(n) overhead problem you encountered. Redis's solution: **sampled-LRU**. When eviction is needed, Redis samples 5 random keys (configurable via `maxmemory-samples`), picks the least-recently-used among those 5, and evicts it.\nThis is a probabilistic approximation of LRU with O(1) overhead. With just 5 samples, Redis achieves remarkably good approximation of true LRU because the oldest key is likely to appear in a random sample when memory has many cold entries. The principle is identical to Clock: instead of tracking full history, make a good approximation using sparse information.\nMemcached uses a segmented LRU approach (similar to Linux's active/inactive lists). Varnish (HTTP cache) uses a Clock variant. Every caching system in production has independently rediscovered the same truth: true LRU is too expensive; good approximations are available for much lower cost.\n### 2. Stack Algorithms and Capacity Planning\nThe formal definition of a **stack algorithm** (Mattson et al., 1970): replacement algorithm A is a stack algorithm if, for any reference string, the set of pages in memory with k frames (denoted S(k)) is a subset of pages in memory with k+1 frames. Formally: `S(k) âŠ† S(k+1)` for all k.\nStack algorithms provably cannot exhibit BÃ©lÃ¡dy's anomaly. Any algorithm where adding frames can only add pages to memory (never change which pages are kept) satisfies this property. LRU and Optimal are stack algorithms; FIFO is not.\nWhy does this matter for capacity planning? If your cache uses a stack algorithm, you can simulate future fault rates with fewer frames by running the simulation with more frames and reading off the k-frame column from the \"inclusion property\" â€” you don't need to re-run the simulation for every frame count. This property also means: with LRU/Optimal, adding RAM to a production server is guaranteed to help or be neutral â€” never harmful. With FIFO-like policies, this guarantee doesn't hold.\n[[EXPLAIN:inclusion-property-of-stack-algorithms-and-why-it-matters-for-capacity-planning|Inclusion property of stack algorithms â€” why LRU's stack property means simulation results at k frames extend to k+1 frames without re-running, enabling efficient capacity planning]]\n### 3. Thrashing and Admission Control: The Same Problem in Web Services\nWhen working set size exceeds physical frames, every access faults. The page fault rate explodes. CPU time is consumed entirely by fault handling and swap I/O. Useful work drops to near zero. This is thrashing â€” and it's a **phase transition**, not a gradual degradation. Below the threshold: normal execution. Above the threshold: complete collapse.\nWeb services experience the identical phenomenon at a higher level. When incoming request rate exceeds server processing capacity, the request queue grows without bound. Queue depth increases latency for all requests, which triggers timeouts, which causes retries, which increases request rate further â€” a feedback loop that collapses throughput completely. The symptom is identical: 100% resource utilization with 0% useful work.\nThe OS solution for thrashing is **working set enforcement**: the scheduler measures each process's page fault frequency. If it exceeds a threshold, the scheduler *suspends* the process rather than let it thrash. Fewer active processes means each active process's working set fits in memory. This is load shedding.\nWeb service admission control is the same principle: reject incoming requests when the server is overloaded rather than queue them infinitely. A 503 response now is better than a 30-second timeout later. Understanding thrashing in virtual memory systems gives you the intuition for why admission control is correct in web services â€” the math of saturation collapse is identical.\n### 4. Database Buffer Pools: Isomorphic to Page Replacement\nPostgreSQL's `shared_buffers` pool, MySQL InnoDB's `innodb_buffer_pool_size`, and SQLite's page cache are all doing exactly what your `phys_mem_t` + replacement policy does â€” but between disk and RAM instead of RAM and CPU.\nPostgreSQL uses a **Clock sweep** algorithm (same as your Clock) to choose victim buffers. Each buffer has a `usage_count` (0â€“5) instead of a single reference bit. The clock sweep decrements `usage_count`; a buffer is evicted only when `usage_count` reaches 0. This is a more gradual version of Clock â€” pages accumulate up to 5 \"lives\" before they can be evicted. The concept is identical, just with more resolution.\nInnoDB uses an LRU list divided into \"young\" (front 37%) and \"old\" (back 63%) regions. New pages enter the old region. If accessed within `innodb_old_blocks_time` milliseconds of entering, they stay in old â€” preventing full-table scans from polluting the cache with pages that won't be reused. This is exactly the two-list approach, again independently discovered because the problem constraints are identical.\n**Dirty page write-back in databases is write-ahead logging (WAL).** Before a database buffer can be evicted, any changes made to it must be written to the WAL (write-ahead log) on disk. The data file page is only updated lazily (at checkpoint time). This is structurally identical to your `swap_page_out()` call â€” you must persist the dirty data somewhere before discarding the in-memory copy. In databases, \"somewhere\" is the WAL instead of swap space, but the ordering invariant is identical: persist before discard.\n### 5. Prefetching and Access Pattern Awareness\nYour working set tracker measures the *current* working set size. More sophisticated systems also use access patterns to *predict* the next working set. Disk-aware page replacement â€” implemented in database systems, not typically in OS kernels â€” examines access patterns to prefetch pages that are likely to be needed soon.\nSequential scan detection: if the simulator noticed that accesses follow a sequential VPN pattern (VPN N, N+1, N+2, ...), it could prefetch VPN N+k before it's needed, hiding the fault latency. Linux's `mmap()` with `MAP_POPULATE` does this at mapping time. PostgreSQL's sequential scan detection switches the buffer replacement policy for sequential scans to prevent them from displacing hot random-access data.\nYour Optimal algorithm is the perfect prefetcher: it knows exactly which pages to load before they're needed (because it has the future trace). The gap between Optimal and Clock in your statistics represents the maximum possible gain from perfect prefetching â€” the \"oracle gap.\" Real prefetchers close some fraction of this gap using heuristic access pattern detection.\n---\n## What You've Built: The Complete Virtual Memory Simulator\nWith Milestone 4 complete, your simulator is a full implementation of every layer in a real operating system's virtual memory subsystem:\n| Layer | Milestone | What you built |\n|-------|-----------|----------------|\n| Address translation | M1 | Flat page table, PTE flags, demand paging, protection faults |\n| Translation acceleration | M2 | TLB with ASID tags, LRU eviction, dirty write-back, flush operations |\n| Memory efficiency | M3 | Two-level page table, CR3 simulation, on-demand table allocation |\n| Bounded physical memory | M4 | FIFO, LRU, Clock, Optimal replacement + swap space + statistics |\nThe system you've built processes real memory access traces, produces measurable statistics, and lets you experimentally validate properties that OS textbooks describe abstractly. You can now:\n- Construct adversarial FIFO traces that trigger BÃ©lÃ¡dy's anomaly\n- Measure the efficiency gap between Clock (production-practical) and Optimal (theoretically perfect)\n- Quantify the dirty write-back cost of different access patterns\n- Observe working set dynamics as your simulator processes real traces\n- Demonstrate that the same reference string produces different fault counts under different policies â€” and understand *why* from the algorithm's victim selection logic\nThe mental model you've built â€” PTE flags, TLB coherence invariants, the clean/dirty distinction, stack algorithm properties â€” transfers directly to reading Linux kernel source code (`mm/vmscan.c`, `mm/swap.c`, `arch/x86/mm/tlb.c`), debugging production memory pressure issues (`/proc/vmstat`, `perf stat cache-misses`), and designing application-level caches with the same principles.\n---\n<!-- END_MS -->\n\n\n## System Overview\n\n![System Overview](./diagrams/system-overview.svg)\n\n\n\n\n# TDD\n\nA layered, hardware-faithful simulator built in four milestone modules, each fixing a concrete limitation exposed by the previous one. The physical constraint negotiated throughout is the finite 64-frame pool vs. unbounded virtual greed. Every struct mirrors real hardware registers (CR3, PTE, TLB entry). Every algorithm is measurable via trace-driven statistics. The TDD blueprint specifies byte-level layouts, cache-line analysis, exact state machines, and sequence diagrams for all coherence-critical operations â€” particularly TLB invalidation ordering and dirty-write-back sequencing, both of which are silent-corruption landmines if misordered.\n\n\n\n<!-- TDD_MOD_ID: virtual-memory-sim-m1 -->\n# Technical Design Specification: Single-Level Page Table and Address Translation (m1)\n\n## 1. Module Charter\nThis module implements the foundational translation layer for the Virtual Memory Simulator. It establishes the \"Physical/Hardware Soul\" of the project by defining the bit-level contract for Page Table Entries (PTEs) and the mechanical process of decomposing a virtual address into its constituent components (VPN and Offset). \n\n**What it does:**\n- Defines the `pte_t` bit-packed structure and `page_table_t` flat array.\n- Implements bit-shifting logic to extract the Virtual Page Number (VPN) and Offset.\n- Provides a `translate()` function that performs O(1) lookup, permission checking, and metadata bit updates (Referenced/Dirty).\n- Implements a demand-paging fault handler that allocates frames from a fixed pool on first access.\n- Parses memory access trace files into an internal executable sequence.\n\n**What it does NOT do:**\n- It does not implement TLB caching (M2).\n- It does not implement multi-level hierarchical tables (M3).\n- It does not implement page replacement (M4); the simulator will treat physical memory exhaustion as a fatal `XLATE_OOM` error in this milestone.\n\n**Upstream Dependencies:** None.\n**Downstream Dependencies:** Milestone 2 (TLB) will wrap the `translate()` function; Milestone 3 will replace the flat `page_table_t` with a tree.\n\n**Invariants:**\n- The bottom `log2(PAGE_SIZE)` bits of the virtual address MUST remain identical in the physical address (Offset preservation).\n- A write access to a page with `valid=1` but `perm_write=0` MUST trigger a `XLATE_PROT_FAULT` immediately.\n- The `dirty` bit MUST only be set on `ACCESS_WRITE`, never on `ACCESS_READ`.\n\n## 2. File Structure\nThe implementation should follow this creation order:\n\n1.  `vmsim_types.h`: Common type definitions, bit-masks, and configuration constants.\n2.  `trace_parser.h / .c`: Logic for reading and tokenizing the `.trace` files.\n3.  `mmu.h / .c`: The core translation logic, bit-manipulation, and fault handling.\n4.  `main.c`: Simulator entry point, loop, and statistics reporting.\n\n## 3. Complete Data Model\n\n### 3.1. Bit-Level Page Table Entry (pte_t)\nThe `pte_t` is a 32-bit (4-byte) structure. We use explicit bit-masking to ensure hardware-faithful behavior regardless of compiler bit-field packing order.\n\n| Bit Range | Name | Description |\n| :--- | :--- | :--- |\n| [31:12] | **PFN** | Physical Frame Number. Maps to a 4KB-aligned frame in `phys_mem`. |\n| [11:8] | **RSVD** | Reserved for future use (e.g., protection keys). |\n| [7] | **A** | Accessed/Referenced bit. Set by hardware/MMU on any access. |\n| [6] | **D** | Dirty bit. Set by hardware/MMU on write access only. |\n| [5] | **R** | Read permission bit. 1 = Readable. |\n| [4] | **W** | Write permission bit. 1 = Writable. |\n| [3:1] | **RSVD** | Reserved. |\n| [0] | **V** | Valid/Present bit. 1 = Mapping is in RAM. 0 = Fault. |\n\n```c\n// vmsim_types.h\n\ntypedef uint32_t pte_t;\n\n#define PTE_V_MASK   (1u << 0)\n#define PTE_W_MASK   (1u << 4)\n#define PTE_R_MASK   (1u << 5)\n#define PTE_D_MASK   (1u << 6)\n#define PTE_A_MASK   (1u << 7)\n#define PTE_PFN_MASK (0xFFFFF000u)\n#define PTE_PFN_SHIFT 12\n\n// Helper macros for PTE manipulation\n#define PTE_GET_PFN(pte) (((pte) & PTE_PFN_MASK) >> PTE_PFN_SHIFT)\n#define PTE_SET_PFN(pfn) (((pfn) << PTE_PFN_SHIFT) & PTE_PFN_MASK)\n#define PTE_IS_VALID(pte) ((pte) & PTE_V_MASK)\n#define PTE_IS_WRITABLE(pte) ((pte) & PTE_W_MASK)\n```\n\n### 3.2. Physical Frame (physical_frame_t)\nRepresents one 4096-byte page of simulated RAM.\n\n```c\ntypedef struct {\n    uint8_t  data[4096]; // Simulated page content (zeroed on alloc)\n    uint32_t owner_vpn;  // Back-reference for debugging/replacement\n    bool     in_use;     // Allocation status\n} physical_frame_t;\n```\n\n### 3.3. Page Table (page_table_t)\nA flat array of entries covering the 32-bit address space with 4KB pages.\nSize: $2^{32} / 2^{12} = 2^{20} = 1,048,576$ entries.\n\n```c\ntypedef struct {\n    pte_t *entries;      // Heap-allocated array of 1,048,576 pte_t\n    size_t num_entries;\n} page_table_t;\n```\n\n### 3.4. Simulator Context (simulator_t)\n```c\ntypedef struct {\n    page_table_t      pt;\n    physical_frame_t *frames;\n    uint32_t          num_frames;\n    \n    // Statistics\n    uint64_t stats_accesses;\n    uint64_t stats_page_faults;\n    uint64_t stats_prot_faults;\n} simulator_t;\n```\n\n\n![pte_t Memory Layout â€” Bit-Level Field Map](./diagrams/tdd-diag-1.svg)\n\n*Diagram 1: Memory Layout of the Simulator. Shows the 4MB Page Table pointing into a fixed 256KB pool of physical frames (assuming 64 frames).*\n\n## 4. Interface Contracts\n\n### 4.1. Address Decomposition\n```c\nuint32_t vpn_from_addr(uint32_t vaddr);\nuint32_t offset_from_addr(uint32_t vaddr);\n```\n- **VPN:** `vaddr >> 12`.\n- **Offset:** `vaddr & 0xFFF`.\n\n### 4.2. Core Translation\n```c\ntypedef enum {\n    XLATE_SUCCESS,\n    XLATE_PAGE_FAULT,\n    XLATE_PROT_FAULT,\n    XLATE_OOM\n} xlate_result_t;\n\ntypedef struct {\n    xlate_result_t result;\n    uint32_t       paddr;\n} xlate_t;\n\nxlate_t translate(simulator_t *sim, uint32_t vaddr, bool is_write);\n```\n- **Constraints:** `vaddr` is a 32-bit unsigned integer. `is_write` distinguishes read/write logic.\n- **Edge Case:** If `vpn >= 1048576`, return `XLATE_PROT_FAULT` (Segmentation Fault).\n\n### 4.3. Trace Parsing\n```c\ntypedef struct {\n    char     type;    // 'R' or 'W'\n    uint32_t vaddr;\n} mem_access_t;\n\nint load_trace(const char *filename, mem_access_t **out_accesses, size_t *out_count);\n```\n- **Constraint:** Must ignore lines starting with `#` and empty lines.\n- **Format:** `%c 0x%x`.\n\n## 5. Algorithm Specification: `translate()`\n\nThe `translate` function acts as the simulated MMU.\n\n1.  **Extract Components:** Calculate `vpn` and `offset` using bitwise shifts and masks.\n2.  **Boundary Check:** If `vpn >= sim->pt.num_entries`, return `XLATE_PROT_FAULT`.\n3.  **Fetch PTE:** `pte_t pte = sim->pt.entries[vpn]`.\n4.  **Valid Check (Demand Paging):**\n    - If `!PTE_IS_VALID(pte)`:\n        - Call `handle_page_fault(sim, vpn, is_write)`.\n        - If fault handler returns failure, return `XLATE_OOM`.\n        - Re-fetch `pte` from the updated table.\n5.  **Protection Check:**\n    - If `is_write` AND `!PTE_IS_WRITABLE(pte)`:\n        - Increment `stats_prot_faults`.\n        - Return `XLATE_PROT_FAULT`.\n6.  **Update Metadata:**\n    - Set `PTE_A_MASK` (Accessed) in `sim->pt.entries[vpn]`.\n    - If `is_write`, set `PTE_D_MASK` (Dirty) in `sim->pt.entries[vpn]`.\n7.  **Reconstruct Address:**\n    - `uint32_t pfn = PTE_GET_PFN(pte)`.\n    - `uint32_t paddr = (pfn << 12) | offset`.\n8.  **Return:** `XLATE_SUCCESS` with `paddr`.\n\n\n![simulator_t and Supporting Structs â€” Full Module Architecture](./diagrams/tdd-diag-2.svg)\n\n*Diagram 2: Flowchart of translate() function logic, highlighting the early-exit on faults vs. the metadata update path.*\n\n## 6. Algorithm Specification: `handle_page_fault()`\n\n1.  **Scan for Free Frame:** Iterate through `sim->frames[0...num_frames-1]`.\n2.  **Find Victim (M1 Simplified):**\n    - If a frame has `in_use == false`: Use it.\n    - If NO frames are free: Return `XLATE_OOM`. (Replacing logic is M4).\n3.  **Initialize Frame:**\n    - Set `frame.in_use = true`.\n    - Set `frame.owner_vpn = vpn`.\n    - `memset(frame.data, 0, 4096)` (security: zero-fill).\n4.  **Update Page Table:**\n    - Create new `pte_t`.\n    - Set `PFN` to the index of the found frame.\n    - Set `PTE_V_MASK`.\n    - Set `PTE_R_MASK` (all pages readable).\n    - If fault was triggered by a write, set `PTE_W_MASK`.\n    - Store back to `sim->pt.entries[vpn]`.\n5.  **Log Statistics:** Increment `stats_page_faults`.\n\n## 7. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `XLATE_PAGE_FAULT` | `translate()` via `valid` bit | Invoke `handle_page_fault()`, reload PTE | Yes (log entry) |\n| `XLATE_PROT_FAULT` | `translate()` via `perm_write` bit | Stop access, log error, continue to next trace line | Yes (error message) |\n| `XLATE_OOM` | `handle_page_fault()` | Terminal for current trace sequence in M1 | Yes (CRITICAL) |\n| `FILE_NOT_FOUND` | `load_trace()` | Abort program | Yes |\n| `MALFORMED_ADDR` | `sscanf` in parser | Skip line, increment skip_count | No |\n\n## 8. Implementation Sequence with Checkpoints\n\n### Phase 1: Bit Math & Structs (1.5 Hours)\n- Define `pte_t` masks and macros.\n- Implement `vpn_from_addr` and `offset_from_addr`.\n- **Checkpoint:** Write a small main that takes `0x1A3F7C` and prints `VPN: 0x1A3, Offset: 0xF7C`. Verify against manual bit decomposition.\n\n### Phase 2: Trace Parser (1 Hour)\n- Implement `load_trace` using `fgets` and `sscanf`.\n- Implement internal array storage for `mem_access_t`.\n- **Checkpoint:** Load a file with 10 lines, print them back. Ensure `#` comments are skipped.\n\n### Phase 3: The MMU Core (2 Hours)\n- Implement `simulator_init` (allocate 4MB for PT).\n- Implement `translate()` and `handle_page_fault()`.\n- Implement `alloc_free_frame()` with linear scan.\n- **Checkpoint:** Run a trace that accesses 5 different pages. Verify `stats_page_faults` is 5 and `frames_used` is 5.\n\n### Phase 4: Protection Logic (1 Hour)\n- Implement a `simulator_mmap(sim, vpn, bool writable)` helper to pre-set PTEs.\n- Write a test trace that writes to a VPN previously mapped as read-only.\n- **Checkpoint:** Run simulator. Verify `PROTECTION FAULT` is logged for the illegal write.\n\n## 9. Test Specification\n\n### 9.1. Unit Test: Address Decomposition\n- **Input:** `0xDEADBEEF`.\n- **Expected:** VPN = `0xDEADB`, Offset = `0xEEF`.\n- **Input:** `0x00000000`.\n- **Expected:** VPN = `0`, Offset = `0`.\n\n### 9.2. Integration Test: Demand Paging\n- **Trace:**\n  ```\n  R 0x1000\n  W 0x1004\n  R 0x2000\n  ```\n- **Expectation:**\n  - Access 1: Page Fault, VPN 1 -> Frame 0. `paddr` = 0x0000.\n  - Access 2: Success (Valid=1), VPN 1 -> Frame 0. `paddr` = 0x0004. Dirty bit set.\n  - Access 3: Page Fault, VPN 2 -> Frame 1. `paddr` = 0x1000.\n\n### 9.3. Edge Case: OOM Limit\n- Set `NUM_FRAMES = 2`.\n- **Trace:**\n  ```\n  R 0x1000\n  R 0x2000\n  R 0x3000\n  ```\n- **Expectation:**\n  - Access 1 & 2: Success (Fault + Alloc).\n  - Access 3: `XLATE_OOM` error.\n\n## 10. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| `translate()` | < 50ns | Average of 1M calls using `clock_gettime`. |\n| `load_trace()` | 1M lines / sec | Wall clock time for large traces. |\n| Page Table Memory | 4.0 MiB | `sizeof(pte_t) * (1 << 20)`. |\n| Frame Scan | O(F) | Linear scan time where F is frame count. |\n\n## 11. Hardware Soul - Cache Line Impact\nIn a real system, the `page_table_t` array would be accessed from RAM. \n- A `pte_t` is 4 bytes.\n- A CPU cache line is 64 bytes.\n- Therefore, one cache line fetch brings in 16 PTEs. \n- Sequential access (e.g., VPN 0, then VPN 1) will hit the same cache line.\n- In this simulator, we can measure the \"PTE Locality\" by tracking how often `current_vpn` is within +/- 16 of `previous_vpn`.\n\n\n![Virtual Address Decomposition: VPN + Offset via Bit Shifting](./diagrams/tdd-diag-3.svg)\n\n*Diagram 3: Cache-line visualization showing 16 PTEs packed into a single 64B block.*\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: virtual-memory-sim-m2 -->\n# Technical Design Specification: TLB (Translation Lookaside Buffer) (m2)\n\n## 1. Module Charter\n\nThis module implements the **Translation Lookaside Buffer (TLB)**, a high-speed associative cache designed to reduce the frequency of expensive page table walks. In Milestone 1, every memory access required a lookup in the flat page table array. Milestone 2 introduces a software-simulated TLB that caches recent `Virtual Page Number (VPN) -> Physical Frame Number (PFN)` mappings.\n\n**What it does:**\n- Implements a fully-associative TLB with a configurable number of entries (default 64).\n- Provides $O(TLB\\_SIZE)$ lookup with three-way tag matching: `(Valid bit, ASID, VPN)`.\n- Implements **Address Space ID (ASID)** support, allowing translations for multiple processes to coexist in the TLB simultaneously, significantly reducing context-switch overhead.\n- Manages **TLB Coherence** via dirty/referenced bit write-back to the main page table upon entry eviction or flush.\n- Provides multiple eviction policies: **LRU (Least Recently Used)** via age-counters and **Seeded-Random** for reproducible testing.\n- Implements targeted flush operations: `flush_all`, `flush_asid`, and `flush_page`.\n\n**What it does NOT do:**\n- It does not implement multi-level page tables (M3).\n- It does not handle page replacement/swap logic (M4).\n- It does not simulate hardware multi-threading or SMP TLB shootdowns (Single-core simulation only).\n\n**Upstream Dependencies:** Milestone 1 (Page Table Entry definitions, VPN decomposition).\n**Downstream Dependencies:** Milestone 3 (Multi-level page walks will be triggered by TLB misses).\n\n**Invariants:**\n- A TLB hit MUST be authoritative; the main page table is not consulted on a hit.\n- Any modification to a TLB entry's `Dirty` or `Referenced` bits MUST eventually be synchronized with the main Page Table (on eviction or flush).\n- A context switch without a flush MUST only allow lookups where `entry.asid == current_asid`.\n\n## 2. File Structure\n\nImplementation follows this creation order:\n\n1.  `tlb.h`: Struct definitions for `tlb_entry_t`, `tlb_t`, and function prototypes.\n2.  `tlb.c`: Implementation of lookup, insertion, and eviction logic.\n3.  `mmu_v2.c`: Integration of TLB into the translation pipeline (wrapping M1 logic).\n4.  `tlb_tests.c`: Unit tests for LRU, Random eviction, and ASID isolation.\n\n## 3. Complete Data Model\n\n### 3.1. TLB Entry Layout (tlb_entry_t)\n\nA `tlb_entry_t` is designed to be compact (12 bytes) to maximize cache density. In a real system, these would be searched in parallel via Content-Addressable Memory (CAM).\n\n| Byte Offset | Field | Type | Description |\n| :--- | :--- | :--- | :--- |\n| 0x00 | `vpn` | `uint32_t` | Virtual Page Number (The Tag). |\n| 0x04 | `pfn` | `uint32_t` | Physical Frame Number (The Data). |\n| 0x08 | `asid` | `uint16_t` | Address Space Identifier (0-65535). |\n| 0x0A | `flags` | `uint8_t` | Bitmask: Valid, Dirty, Ref, Writable. |\n| 0x0B | `age` | `uint8_t` | LRU counter (0 = fresh, 255 = oldest). |\n\n**Bitmask for `flags`:**\n- `0x01`: `TLB_V` (Valid)\n- `0x02`: `TLB_D` (Dirty - set on write)\n- `0x04`: `TLB_R` (Referenced - set on any hit)\n- `0x08`: `TLB_W` (Writable - copied from PTE)\n\n```c\ntypedef struct {\n    uint32_t vpn;\n    uint32_t pfn;\n    uint16_t asid;\n    uint8_t  flags;\n    uint8_t  age;\n} tlb_entry_t;\n```\n\n### 3.2. TLB Context (tlb_t)\n\n```c\ntypedef struct {\n    tlb_entry_t *entries;      // Array of size TLB_SIZE\n    uint32_t     size;         // Configurable (16, 32, 64)\n    uint16_t     active_asid;  // Current process ID\n    uint32_t     rand_state;   // Seed for random eviction\n    \n    // Statistics\n    uint64_t hits;\n    uint64_t misses;\n    uint64_t evictions;\n    uint64_t flushes;\n} tlb_t;\n```\n\n### 3.3. Cache Line Analysis (MANDATORY)\n- `sizeof(tlb_entry_t)` = 12 bytes.\n- Standard x86_64 Cache Line = 64 bytes.\n- 64 / 12 = 5.33. This means a single cache line fetch pulls in ~5 TLB entries.\n- A 64-entry TLB consumes 768 bytes, fitting comfortably within the 32KB L1 Data Cache. \n- Sequential scans of the TLB in software are highly cache-friendly.\n\n\n![tlb_entry_t Memory Layout â€” 12-Byte Struct with Flag Byte Detail](./diagrams/tdd-diag-9.svg)\n\n*Diagram 9: Byte-offset layout of tlb_entry_t and its packing within a 64B cache line.*\n\n## 4. Interface Contracts\n\n### 4.1. TLB Operations\n```c\n// Initialize TLB with size and random seed\nvoid tlb_init(tlb_t *tlb, uint32_t size, uint32_t seed);\n\n// Search for a translation\n// Returns: hit_pfn on success, or sentinel 0xFFFFFFFF on miss\nuint32_t tlb_lookup(tlb_t *tlb, uint32_t vpn, bool is_write, int *out_status);\n\n// Insert a new translation (triggers eviction if full)\nvoid tlb_insert(tlb_t *tlb, page_table_t *pt, uint32_t vpn, uint32_t pfn, bool writable);\n```\n\n### 4.2. Flush & Maintenance\n```c\n// Invalidate all entries (Global Flush)\nvoid tlb_flush_all(tlb_t *tlb, page_table_t *pt);\n\n// Invalidate entries for a specific process (Context Flush)\nvoid tlb_flush_asid(tlb_t *tlb, page_table_t *pt, uint16_t asid);\n\n// Invalidate specific page (required for coherence when PTE changes)\nvoid tlb_flush_page(tlb_t *tlb, page_table_t *pt, uint32_t vpn);\n```\n\n### 4.3. Context Switching\n```c\n// Switch the active ASID. If asid_support is false, triggers tlb_flush_all.\nvoid context_switch(tlb_t *tlb, page_table_t *pt, uint16_t new_asid, bool flush_on_switch);\n```\n\n## 5. Algorithm Specification\n\n### 5.1. `tlb_lookup` (The Hot Path)\n1.  **Iterate** through `tlb->entries[0...size-1]`.\n2.  **Tag Match Check**:\n    - `if ((e.flags & TLB_V) && (e.asid == tlb->active_asid) && (e.vpn == vpn))`\n3.  **On Hit**:\n    - Increment `tlb->hits`.\n    - **Permission Check**: If `is_write` AND `!(e.flags & TLB_W)`, return `XLATE_PROT_FAULT_TLB`.\n    - **Update Flags**: `e.flags |= TLB_R`. If `is_write`, `e.flags |= TLB_D`.\n    - **LRU Update**: Reset `e.age = 0`. Increment age of all OTHER valid entries (cap at 255).\n    - Return `e.pfn`.\n4.  **On Miss**:\n    - Increment `tlb->misses`.\n    - Return `MISS_SENTINEL`.\n\n\n![TLB Position in Address Translation Pipeline](./diagrams/tdd-diag-10.svg)\n\n*Diagram 10: Logic flow of TLB Lookup including ASID matching and LRU aging.*\n\n### 5.2. `tlb_insert` with Coherence Write-back\n1.  **Find Victim**:\n    - **Step A**: Search for any entry with `!(flags & TLB_V)`. If found, use this slot.\n    - **Step B**: If no invalid slots, use policy:\n        - **LRU**: Find entry with highest `age`.\n        - **Random**: `idx = tlb_rand_next() % size`.\n2.  **Coherence Write-back**:\n    - If victim entry is valid (`TLB_V`):\n        - Increment `tlb->evictions`.\n        - Fetch the main Page Table Entry: `pte_t *pte = &pt->entries[victim.vpn]`.\n        - **Sync Flags**:\n            - If `victim.flags & TLB_D`, then `*pte |= PTE_D_MASK`.\n            - If `victim.flags & TLB_R`, then `*pte |= PTE_A_MASK`.\n3.  **Populate New Entry**:\n    - `e.vpn = vpn`, `e.pfn = pfn`, `e.asid = tlb->active_asid`.\n    - `e.flags = TLB_V | TLB_R`. If `writable`, `e.flags |= TLB_W`.\n    - `e.age = 0`.\n\n\n![tlb_lookup() State Machine: VALID â†’ ASID â†’ VPN â†’ Result](./diagrams/tdd-diag-11.svg)\n\n*Diagram 11: Sequence diagram of TLB Eviction showing the critical write-back to the M1 Page Table.*\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `PROT_FAULT_TLB` | `tlb_lookup` | Access aborted, log fault. | Yes |\n| `TLB_MISS` | `translate_with_tlb` | Perform Page Table Walk, call `tlb_insert`. | No (Status log) |\n| `STALE_ENTRY` | Simulator logic | Manual `tlb_flush_page` call required on PTE change. | If missed: Data corruption. |\n| `LRU_OVERFLOW` | `tlb_lookup` age increment | `if (age < 255) age++;` | No |\n| `ASID_MISMATCH` | `tlb_lookup` | Treated as a Miss. | No |\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: Foundation (1 Hour)\n- Define `tlb_entry_t` and `tlb_t`.\n- Implement `tlb_init` and `tlb_flush_all`.\n- **Checkpoint:** Initialize a 16-entry TLB. Verify all `flags` are 0 and `asid` is `active_asid`.\n\n### Phase 2: Lookup & LRU (2 Hours)\n- Implement `tlb_lookup` with tag matching.\n- Implement the $O(N)$ LRU aging logic (increment all, reset one).\n- **Checkpoint:** Manually insert 2 entries. Call `lookup` on Entry A, then Entry B. Verify `age` of A is 1 and `age` of B is 0.\n\n### Phase 3: Insertion & Eviction (2 Hours)\n- Implement `tlb_insert`.\n- Implement `tlb_find_victim_lru` and `tlb_writeback_entry`.\n- **Checkpoint:** Set `TLB_SIZE = 2`. Insert VPN 1, 2, 3. Verify VPN 1 is evicted and its Dirty bit is correctly reflected in the `page_table_t`.\n\n### Phase 4: Integration (1.5 Hours)\n- Create `translate_with_tlb`.\n- Logic: `tlb_lookup` -> if Miss -> `m1_translate` -> `tlb_insert`.\n- **Checkpoint:** Run M1 basic trace. Total hits should be 0 on first pass, but subsequent accesses to the same page should show `TLB: HIT`.\n\n### Phase 5: ASID & Context Switching (1 Hour)\n- Implement `context_switch`.\n- Update `tlb_lookup` to enforce `asid` matching.\n- **Checkpoint:** Process 1 (ASID 1) accesses VPN 0x10. Context switch to Process 2 (ASID 2). Access VPN 0x10. Verify a TLB Miss occurs.\n\n## 8. Test Specification\n\n### 8.1. Unit Test: ASID Isolation\n- **Setup:** ASID 1 maps VPN 0x10 -> PFN 0xA. ASID 2 maps VPN 0x10 -> PFN 0xB.\n- **Test:** Set `active_asid = 1`, `lookup(0x10)`. Expect PFN 0xA. Set `active_asid = 2`, `lookup(0x10)`. Expect PFN 0xB.\n- **Success:** No cross-contamination between address spaces.\n\n### 8.2. Unit Test: LRU Eviction Order\n- **Setup:** `TLB_SIZE = 4`. Access VPNs 1, 2, 3, 4. \n- **Action:** Access VPN 1 (makes it youngest). Access VPN 5.\n- **Expectation:** VPN 2 should be evicted (it was the oldest after 1 was refreshed).\n- **Success:** `tlb_lookup(2)` returns MISS. `tlb_lookup(1)` returns HIT.\n\n### 8.3. Integration Test: Dirty Write-back\n- **Setup:** TLB Hit on VPN 0x5 with `is_write = true`.\n- **Action:** Call `tlb_flush_page(0x5)`.\n- **Expectation:** The PTE in the flat page table for VPN 0x5 must now have `PTE_D_MASK` set.\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| `tlb_lookup` (64 entries) | < 100ns | Average over 10M lookups. |\n| Hit Rate (Sequential) | > 99% | Trace: `R 0x1000, R 0x1004, ... R 0x1FFC`. |\n| Hit Rate (Random) | ~0.02% | Trace: Uniformly random VPNs over 1GB space. |\n| Write-back Overhead | < 5% | Total simulation time delta vs. M1. |\n\n## 10. Hardware Soul - CAM vs Linear Scan\n\nIn real hardware, the TLB uses **Content Addressable Memory (CAM)**. \n- **CAM Logic:** The VPN is broadcast to every slot simultaneously. Each slot has a comparator that triggers a match signal in parallel ($O(1)$).\n- **Simulator Logic:** We use a loop ($O(N)$). \n- **Performance Note:** Even though we are $O(N)$, because the data structure (768 bytes) fits in the L1 Cache, the loop is extremely fast. However, we must not increase `TLB_SIZE` beyond ~256 in software, as the linear scan will eventually exceed the cost of a Page Table walk.\n\n{{DIAGRAM:tdd-diag-12}}\n*Diagram 12: Sequence diagram of a Context Switch with and without ASID support.*\n\n\n![ASID-Tagged TLB: Context Switch Without Flush](./diagrams/tdd-diag-13.svg)\n\n*Diagram 13: TLB Flush operations (Page, ASID, All) and their impact on entry validity.*\n\n\n![TLB Dirty Bit Write-Back on Eviction â€” Coherence Sequence](./diagrams/tdd-diag-14.svg)\n\n*Diagram 14: Parallel vs Sequential lookup - Hardware Silicon vs Software Simulator comparison.*\n\n\n![tlb_flush_page() â€” Single-VPN Invalidation Before Frame Reuse](./diagrams/tdd-diag-15.svg)\n\n*Diagram 15: The \"Hot Path\" - detailed view of translate_with_tlb() decision tree.*\n\n\n<!-- END_TDD_MOD -->\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: virtual-memory-sim-m3 -->\n# Technical Design Specification: Multi-Level Page Tables (m3)\n\n## 1. Module Charter\nThis module replaces the rigid, memory-inefficient flat page table from Milestone 1 with a dynamic, hierarchical two-level page table (radix trie). It negotiates the hardware tension between a vast 4GB virtual address space and the physical reality that most processes only use a few megabytes of RAM.\n\n**What it does:**\n- Implements a 10-10-12 bit address decomposition for a 32-bit virtual address space.\n- Simulates the **CR3 (Page Directory Base Register)**, providing the root for all translation walks.\n- Implements **On-Demand Table Allocation**: second-level page tables are only allocated when a memory access falls within a new 4MB virtual region.\n- Manages the `process_t` abstraction, ensuring full isolation between address spaces via separate page directory roots.\n- Quantifies the \"Sparsity Benefit\" by comparing the memory footprint of hierarchical tables versus the flat 4MB baseline.\n- Integrates the M2 TLB, ensuring that a TLB miss triggers a multi-level hardware-style walk.\n\n**What it does NOT do:**\n- It does not implement page replacement (M4). Physical memory exhaustion (OOM) still returns an error.\n- It does not simulate 64-bit canonical address checks (strictly 32-bit simulation).\n\n**Upstream Dependencies:** Milestone 1 (PTE definitions, Offset logic), Milestone 2 (TLB lookup/insert).\n**Downstream Dependencies:** Milestone 4 (Page replacement will require walking these trees to find eviction victims).\n\n**Invariants:**\n- A Page Directory Entry (PDE) with the `Present` bit set to 0 MUST treat the entire 4MB region as unmapped.\n- Every allocated Page Directory and Page Table MUST be 4096-byte aligned to mirror physical frame boundaries.\n- The CR3 register MUST always point to the physical base of a valid `page_directory_t`.\n\n## 2. File Structure\nThe implementation follows this creation order:\n\n1.  `vmsim_m3_types.h`: Definitions for `pde_t`, `page_directory_t`, and `process_t`.\n2.  `address_utils.h`: Inline functions for 10-10-12 bit decomposition.\n3.  `process_manager.c`: Implementation of `process_create`, `process_destroy`, and on-demand allocation.\n4.  `mmu_v3.c`: The hierarchical walk logic and integration with M2 TLB.\n5.  `overhead_reports.c`: Logic for calculating and printing memory savings statistics.\n\n## 3. Complete Data Model\n\n### 3.1. Page Directory Entry (pde_t)\nThe `pde_t` is a 4-byte entry in the top-level directory. It points to a second-level page table rather than a data frame.\n\n| Bit Range | Name | Description |\n| :--- | :--- | :--- |\n| [31:12] | **PT_ADDR** | Physical Base Address of the 2nd-level Page Table. (4KB aligned). |\n| [11:1] | **AVAIL** | Available for OS use (ignored by hardware simulation). |\n| [0] | **P** | Present Bit. 1 = Sub-table exists; 0 = Region unmapped. |\n\n```c\ntypedef uint32_t pde_t;\n\n#define PDE_P_MASK         (1u << 0)\n#define PDE_PT_ADDR_MASK   (0xFFFFF000u)\n#define PDE_PT_ADDR_SHIFT  12\n\n#define PDE_IS_PRESENT(pde) ((pde) & PDE_P_MASK)\n#define PDE_GET_PT_ADDR(pde) ((pde) & PDE_PT_ADDR_MASK)\n```\n\n### 3.2. Hierarchical Structures\nEach structure is exactly 4096 bytes to fit perfectly in one physical frame.\n\n```c\n// Top Level: Page Directory\ntypedef struct {\n    pde_t entries[1024]; // 1024 * 4 bytes = 4096 bytes\n} page_directory_t;\n\n// Second Level: Page Table (same as M1, but conceptually nested)\ntypedef struct {\n    pte_t entries[1024]; // 1024 * 4 bytes = 4096 bytes\n} page_table_t;\n```\n\n### 3.3. Process Abstraction (process_t)\n```c\ntypedef struct {\n    uint16_t          asid;               // Address Space ID for TLB\n    page_directory_t *pgdir;              // Root (simulated physical address)\n    page_table_t     *pgtables[1024];     // Pointer array for simulator convenience\n    size_t            pt_bytes_allocated; // Tracks 4KB increments\n} process_t;\n```\n\n### 3.4. Byte-Level Layout & Cache Line Analysis\n- **Page Directory (4096B):** Contains 1024 entries. \n- **PDI 0-15:** Occupy the first 64 bytes (one cache line). Accessing addresses in the first 64MB of virtual space (16 entries * 4MB per entry) will result in directory cache hits.\n- **PT Locality:** Accessing two virtual addresses $V_1$ and $V_2$ where $|V_1 - V_2| < 4MB$ guarantees they share the same Page Directory Entry.\n\n\n![Two-Level Virtual Address Decomposition: 10+10+12 Bit Split](./diagrams/tdd-diag-16.svg)\n\n*Diagram 16: Hierarchical structure of the 10-10-12 Page Table system. Show CR3 pointing to Directory, Directory index selecting PDE, PDE pointing to Table, Table index selecting PTE.*\n\n## 4. Interface Contracts\n\n### 4.1. Address Decomposition\n```c\nuint32_t get_pdi(uint32_t vaddr); // bits [31:22]\nuint32_t get_pti(uint32_t vaddr); // bits [21:12]\nuint32_t get_offset(uint32_t vaddr); // bits [11:0]\n```\n\n### 4.2. Process Lifecycle\n```c\nprocess_t* process_create(uint16_t asid);\nvoid       process_destroy(process_t *proc);\n```\n- **Constraint:** `process_create` must allocate and zero-initialize the `page_directory_t`.\n- **Constraint:** `process_destroy` must iterate `pgtables[]` and free all non-NULL second-level tables.\n\n### 4.3. Hierarchical Translation\n```c\ntypedef struct {\n    xlate_result_t result;\n    uint32_t       paddr;\n    uint32_t       pfn;\n} xlate_t;\n\nxlate_t ml_translate(ml_simulator_t *sim, tlb_t *tlb, uint32_t vaddr, bool is_write);\n```\n- **Error Categories:**\n    - `XLATE_OOM`: If an L2 table needs to be allocated but `malloc` fails or frame pool is empty.\n    - `XLATE_PROT_FAULT`: Accessing an unmapped region (if your simulator chooses not to auto-grow) or permission mismatch.\n\n## 5. Algorithm Specification\n\n### 5.1. The Hierarchical Walk (`ml_translate`)\n1.  **Extract Indices:** `pdi = get_pdi(vaddr)`, `pti = get_pti(vaddr)`, `off = get_offset(vaddr)`.\n2.  **Level 1 (Directory) Lookup:**\n    - `pde_t pde = sim->active_process->pgdir->entries[pdi]`.\n    - If `!PDE_IS_PRESENT(pde)`:\n        - **On-Demand Allocation**:\n            - `new_pt = aligned_alloc(4096, sizeof(page_table_t))`.\n            - If fails, return `XLATE_OOM`.\n            - `memset(new_pt, 0, 4096)`.\n            - `sim->active_process->pgtables[pdi] = new_pt`.\n            - `sim->active_process->pgdir->entries[pdi] = pde_make(new_pt)`.\n            - Update `pt_bytes_allocated += 4096`.\n3.  **Level 2 (Table) Lookup:**\n    - `page_table_t *pt = sim->active_process->pgtables[pdi]`.\n    - `pte_t pte = pt->entries[pti]`.\n4.  **Valid/Demand Paging (Same as M1):**\n    - If `!PTE_IS_VALID(pte)`:\n        - Allocate data frame, update `pt->entries[pti]`.\n5.  **Finalize:** Reconstruct address using PFN and Offset.\n\n\n![process_t and Two-Level Page Table Struct Architecture](./diagrams/tdd-diag-17.svg)\n\n*Diagram 17: Sequence Diagram of an On-Demand L2 Page Table allocation. Show the MMU detecting a missing PDE, triggering the allocator, and then proceeding with the PTE lookup.*\n\n### 5.2. Context Switch with CR3 Update\n1.  **Identify Old Process:** Get `sim->active_process`.\n2.  **Update CR3:** `sim->cr3 = (uint32_t)new_proc->pgdir`.\n3.  **Set Active Process:** `sim->active_process = new_proc`.\n4.  **TLB Coordination:**\n    - If `force_flush == true`: Call `tlb_flush_all(tlb, old_proc->pgdir)`.\n    - Else: Call `tlb->active_asid = new_proc->asid` (M2 ASID support).\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `NULL_PDE_DEREFERENCE` | `ml_translate` | Check `PDE_IS_PRESENT` before `pgtables[pdi]`. | Internal Crash if missed. |\n| `XLATE_OOM` | `alloc_page_table` | Stop simulation for that trace. | Yes (Log) |\n| `PDE_PT_MISALIGN` | `pde_make` | `assert((addr & 0xFFF) == 0)` | Internal Crash. |\n| `TLB_STALENESS` | `ml_translate` | Call `tlb_flush_page` if PTE is manually modified. | No (Data corruption). |\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: Bitfields & Indices (0.5 Hours)\n- Implement `get_pdi`, `get_pti`, `get_offset`.\n- **Checkpoint:** Use `0x004056A8`. Verify PDI=1, PTI=5, Offset=0x6A8.\n\n### Phase 2: On-Demand Logic (1.5 Hours)\n- Implement `process_create` and the \"Directory Present\" check in `ml_translate`.\n- Integrate `aligned_alloc` for 4KB alignment.\n- **Checkpoint:** Run a trace accessing `0x1000` and `0x401000`. Verify `pt_bytes_allocated` is 12288 (1 Dir + 2 Tables).\n\n### Phase 3: TLB Integration (1 Hour)\n- Modify `full_translate` to check TLB. On miss, perform the 2-level walk.\n- **Checkpoint:** Run trace with repeated access. Verify first access is `MISS + Walk`, second is `HIT`.\n\n### Phase 4: Overhead Reporting (1 Hour)\n- Implement `print_overhead_comparison`.\n- Logic: `Flat_Cost = 4MB`. `Savings = 1 - (proc->pt_bytes_allocated / 4MB)`.\n- **Checkpoint:** Print report for a 1-page process. Savings should be > 99%.\n\n### Phase 5: Stretch - 3-Level Table (2 Hours)\n- Implement `l1/l2/l3` split: 2 bits / 9 bits / 9 bits.\n- Implement `three_level_walk`.\n- **Checkpoint:** Verify 3rd level tables are also allocated on demand.\n\n## 8. Test Specification\n\n### 8.1. Unit Test: PDE/PTE Distinction\n- **Scenario:** Address `0x00800000` (PDI=2). \n- **Setup:** Manually set `pgdir->entries[2]` to a valid data frame address (Illegal).\n- **Test:** Run `ml_translate`.\n- **Expectation:** The walk should fail or the simulator should crash when trying to treat user data as a Page Table. Ensure logic distinguishes between \"Pointer to Table\" and \"Pointer to Frame\".\n\n### 8.2. Integration Test: Address Space Isolation\n- **Scenario:** \n  1. Process 1 (ASID 1) maps `0x1000` -> Frame 5.\n  2. Process 2 (ASID 2) maps `0x1000` -> Frame 10.\n- **Action:** Context switch between P1 and P2. Access `0x1000`.\n- **Expectation:** P1 gets Frame 5; P2 gets Frame 10. Verify CR3 value changed.\n\n### 8.3. Boundary Test: Max Address\n- **Input:** `0xFFFFFFFF`.\n- **Expectation:** PDI=1023, PTI=1023, Offset=4095. Correct walk to the very last PTE in the system.\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| **Walk Latency** | $2.0 \\times$ Flat Table Walk | Measure TLB-Miss cycles. |\n| **Mem Creation** | $O(1)$ | Time for `process_create`. |\n| **Mem Cleanup** | $O(N)$ where N is L2 tables | Time for `process_destroy`. |\n| **Sparsity Savings** | $> 90\\%$ for most traces | `pt_bytes_allocated` vs 4MB baseline. |\n\n## 10. Hardware Soul - The Multi-Level Penalty\nIn real silicon, every level added to the page table is another potentially-catastrophic memory access.\n- **Flat Table:** 1 memory load on TLB miss.\n- **2-Level Table:** 2 memory loads (Directory, then Table).\n- **4-Level (x86-64):** 4 memory loads.\nThis is why the **TLB Hit Rate** is the absolute king of systems performance. A 2-level walk is twice as \"expensive\" as a flat walk in the worst case (cache cold). However, because `page_directory_t` and `page_table_t` are 4KB pages, they are frequently cached in the L2/L3 of the CPU, mitigating this cost.\n\n\n![pde_t vs pte_t Structural Comparison â€” What Each Points To](./diagrams/tdd-diag-18.svg)\n\n*Diagram 18: Comparison of Flat vs 2-Level walk steps.*\n\n\n![Two-Level Page Table Walk â€” Complete Data Flow with On-Demand Allocation](./diagrams/tdd-diag-19.svg)\n\n*Diagram 19: Address Decomposition bit-field map for 2-level (10-10-12) and 3-level (2-9-9-12).*\n\n\n![On-Demand Second-Level Table Allocation: Before/After State](./diagrams/tdd-diag-20.svg)\n\n*Diagram 20: Memory Overhead Graph showing the linear growth of Hierarchical tables vs constant Flat table.*\n\n\n![CR3 Register and Context Switch: Address Space Isolation](./diagrams/tdd-diag-21.svg)\n\n*Diagram 21: Context Switch State Machine: Transitioning from Proc A to Proc B via CR3.*\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: virtual-memory-sim-m4 -->\n# Technical Design Specification: Page Replacement and Swap Simulation (m4)\n\n## 1. Module Charter\nThis module implements the \"Governor of Scarcity\"â€”the page replacement engine and backing swap store. It resolves the fundamental tension between a process's unbounded virtual memory demand and the simulator's fixed 64-frame physical limit. By implementing four distinct replacement algorithms (FIFO, LRU, Clock, and Optimal), it allows for a quantitative analysis of how different heuristics affect system throughput and disk I/O (swap) overhead.\n\n**What it does:**\n- Manages a simulated swap partition (array-backed) to persist evicted dirty pages.\n- Implements the **Eviction Core**, ensuring a strict coherence protocol: Dirty Write-back â†’ TLB Invalidation â†’ PTE Invalidation â†’ Frame Reclamation.\n- Provides four replacement heuristics: **FIFO** (age-based), **LRU** (recency-based), **Clock** (reference-bit approximation), and **Optimal** (future-knowledge benchmark).\n- Tracks the **Working Set** of the process using a sliding window to detect and report thrashing.\n- Demonstrates **BÃ©lÃ¡dyâ€™s Anomaly** by comparing FIFO fault rates across different frame counts.\n- Generates comparative performance reports (Fault Rate, Swap I/O count, Efficiency vs. Optimal).\n\n**What it does NOT do:**\n- It does not implement huge pages (4KB granularity only).\n- It does not support compressed swap (ZSwap) or asynchronous page-out threads.\n- It does not handle multi-process shared swap slots (private per-process swap only).\n\n**Upstream Dependencies:** Milestone 1 (PTE flags), Milestone 2 (TLB flushing), Milestone 3 (Hierarchical walk to clear PTEs).\n**Downstream Dependencies:** This is the terminal milestone of the Virtual Memory Simulator.\n\n**Invariants:**\n- A frame MUST be flushed from the TLB via `tlb_flush_page` BEFORE its PTE is cleared and the frame is reassigned.\n- A page marked `Dirty` in its PTE or TLB entry MUST be written to swap before its frame is reclaimed.\n- The `Optimal` algorithm MUST produce the absolute minimum number of page faults for any given trace (theoretical lower bound).\n\n## 2. File Structure\nThe implementation follows this creation order:\n\n1.  `swap.h / swap.c`: Definitions for `swap_slot_t` and `swap_space_t`; logic for page-in/page-out.\n2.  `replacement_metadata.h`: The `frame_desc_t` and `phys_mem_t` structures with replacement-tracking fields.\n3.  `algorithms.c`: Implementation of the four selection heuristics (FIFO, LRU, Clock, Optimal).\n4.  `eviction_engine.c`: The unified `replace_page` logic and coherence sequencer.\n5.  `working_set.c`: Sliding window tracker for working set size analysis.\n6.  `reporting.c`: Comparative statistics generator and BÃ©lÃ¡dy anomaly demonstrator.\n\n## 3. Complete Data Model\n\n### 3.1. Frame Descriptor (frame_desc_t)\nThis structure tracks the \"Life and Times\" of a physical frame. It is exactly 32 bytes to ensure dual-entry packing within a 64-byte cache line.\n\n| Byte Offset | Field | Type | Description |\n| :--- | :--- | :--- | :--- |\n| 0x00 | `vpn` | `uint32_t` | Currently mapped Virtual Page Number. `0xFFFFFFFF` if free. |\n| 0x04 | `asid` | `uint16_t` | ASID of the process owning this frame. |\n| 0x06 | `flags` | `uint8_t` | Bits: [0] InUse, [1] Dirty, [2] RefBit, [3] Reserved. |\n| 0x07 | `padding` | `uint8_t` | Alignment padding. |\n| 0x08 | `load_time` | `uint64_t` | Logical timestamp when the page was first loaded (FIFO). |\n| 0x10 | `last_access`| `uint64_t` | Logical timestamp of the most recent access (LRU). |\n| 0x18 | `reserved` | `uint64_t` | Future expansion (e.g., pinning counts). |\n\n**Total: 32 bytes.**\n\n### 3.2. Physical Memory Pool (phys_mem_t)\n```c\ntypedef struct {\n    frame_desc_t desc[64];              // Metadata for 64 frames\n    uint8_t      data[64][4096];        // Actual 256KB of simulated RAM\n    uint32_t     num_frames;            // Configurable size (e.g., 3, 16, 64)\n    uint64_t     logical_clock;         // Incremented on every memory access\n} phys_mem_t;\n```\n\n### 3.3. Swap Space (swap_space_t)\n```c\n#define MAX_SWAP_PAGES 1024\n\ntypedef struct {\n    uint8_t  data[4096];\n    uint32_t vpn;\n    bool     in_use;\n} swap_slot_t;\n\ntypedef struct {\n    swap_slot_t slots[MAX_SWAP_PAGES];\n    uint32_t    count;\n    uint64_t    stats_write_backs;      // Count of dirty evictions\n    uint64_t    stats_page_ins;         // Count of swap reloads\n} swap_space_t;\n```\n\n### 3.4. Working Set Tracker\n```c\n#define WS_WINDOW_SIZE 50\n\ntypedef struct {\n    uint32_t vpn_history[WS_WINDOW_SIZE];\n    uint32_t head;\n    uint32_t current_size;\n} working_set_tracker_t;\n```\n\n\n![frame_desc_t Memory Layout â€” 16-Byte Struct with Cache-Line Analysis](./diagrams/tdd-diag-24.svg)\n\n*Diagram 24: Memory Relationship Map. Shows PhysMem descriptors pointing to PTEs, and SwapSpace acting as the overflow reservoir.*\n\n## 4. Interface Contracts\n\n### 4.1. The Replacement Dispatcher\n```c\ntypedef enum {\n    POLICY_FIFO,\n    POLICY_LRU,\n    POLICY_CLOCK,\n    POLICY_OPTIMAL\n} replacement_policy_t;\n\ntypedef struct {\n    uint32_t freed_frame;\n    uint32_t evicted_vpn;\n    bool     was_dirty;\n} replace_result_t;\n\nreplace_result_t replace_page(\n    phys_mem_t *pm, \n    swap_space_t *swap, \n    page_table_t *pt, \n    tlb_t *tlb, \n    replacement_policy_t policy,\n    const mem_access_t *future_trace, // For Optimal\n    size_t trace_len,\n    size_t current_step,\n    uint32_t *clock_hand             // For Clock persistence\n);\n```\n- **Constraints:** `pm` must be full (no free frames) before calling this.\n- **Side Effects:** Modifies Page Table `valid` bits and flushes TLB entries.\n\n### 4.2. Swap I/O\n```c\n// Move data from Frame to Swap\nbool swap_page_out(phys_mem_t *pm, swap_space_t *sw, uint32_t frame_idx, uint32_t vpn);\n\n// Move data from Swap to Frame (if it exists)\nbool swap_page_in(phys_mem_t *pm, swap_space_t *sw, uint32_t frame_idx, uint32_t vpn);\n```\n\n## 5. Algorithm Specifications\n\n### 5.1. The Eviction Core Sequence (Critical Path)\nThis logic is shared by all algorithms once a victim frame is identified.\n1.  **Identify Victim:** Let `f = victim_frame_index`.\n2.  **Metadata Check:** Extract `v = pm->desc[f].vpn`. Check `pm->desc[f].flags & DIRTY`.\n3.  **TLB Shootdown:** Call `tlb_flush_page(tlb, pt, v)`. *Note: The TLB may contain updated Dirty/Ref bits that must be synced to the PTE during this flush.*\n4.  **Dirty Write-back:** \n    - If `Dirty` bit is set (in PTE or TLB):\n        - Call `swap_page_out(pm, swap, f, v)`.\n        - Increment `swap->stats_write_backs`.\n5.  **PTE Invalidation:** \n    - Perform a hierarchical walk (M3 logic) to find the PTE for `v`.\n    - Clear `PTE_V_MASK`, `PTE_D_MASK`, `PTE_A_MASK`.\n6.  **Frame Reclamation:** \n    - Set `pm->desc[f].in_use = false`.\n    - Set `pm->desc[f].vpn = 0xFFFFFFFF`.\n7.  **Return:** `replace_result_t` with indices and dirty status.\n\n### 5.2. Clock (Second-Chance) Logic\n1.  **Start** at `*clock_hand`.\n2.  **Loop** until a victim is found:\n    - `frame_desc_t *d = &pm->desc[*clock_hand]`.\n    - If `d->flags & RefBit`:\n        - Clear `RefBit` in `d->flags`.\n        - Also clear `PTE_A_MASK` in the corresponding Page Table Entry.\n        - Increment `*clock_hand = (*clock_hand + 1) % num_frames`.\n    - Else (RefBit is 0):\n        - This is the victim. \n        - Stop loop and return `*clock_hand`.\n3.  **Safety:** Guard against infinite loop with a `sweep_count` (max 2 full rotations).\n\n### 5.3. Optimal (BÃ©lÃ¡dyâ€™s Algorithm)\n1.  **Scan** all frames currently `in_use` in `pm`.\n2.  **For each frame**, look ahead in `future_trace` starting at `current_step + 1`.\n3.  **Calculate Distance:**\n    - If `vpn` is found at step `K`, `distance = K - current_step`.\n    - If `vpn` is never found again, `distance = INFINITY`.\n4.  **Selection:** Choose the frame with the **largest distance**.\n5.  **Tie-breaker:** If multiple pages have `INFINITY` distance, choose the one with the lowest frame index.\n\n\n![Page Replacement Full Module Architecture](./diagrams/tdd-diag-25.svg)\n\n*Diagram 25: Optimal Selection Logic. Visualizing the look-ahead scan across the trace array.*\n\n## 6. Error Handling Matrix\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `SWAP_FULL` | `swap_alloc_slot` | Critical failure. `abort()` simulator or return `OOM_FATAL`. | Yes (Crash) |\n| `STALE_TLB` | Access Logic | Avoided by `tlb_flush_page` preceding PTE clear. | If missed: Data corruption. |\n| `THRASHING` | `ws_record_access` | Monitor `fault_rate`. Log warning if rate > 50%. | Yes (Warning) |\n| `CLOCK_STALL` | `replace_clock` | Sweep twice, then force evict current hand position. | No |\n| `DIRTY_LOST` | `evict_frame` | Enforce Write-back *before* frame clearing. | If missed: Data corruption. |\n\n## 7. Implementation Sequence with Checkpoints\n\n### Phase 1: Frame Descriptors (1 Hour)\n- Implement `phys_mem_init` and `frame_desc_t` packing.\n- Implement `phys_record_access` (updates `last_access` and `RefBit` on every translation hit/miss).\n- **Checkpoint:** Run a trace of 5 accesses. Verify `logical_clock` is 5 and descriptors have correct `last_access` times.\n\n### Phase 2: Swap Subsystem (2 Hours)\n- Implement `swap_page_out` and `swap_page_in`.\n- Create a simple fixed-array `swap_space_t`.\n- **Checkpoint:** Manually \"page out\" VPN 10, then \"page in\" to a different frame. Verify `memcmp` of data is identical.\n\n### Phase 3: Selection Algorithms (3 Hours)\n- Implement `replace_fifo`, `replace_lru`, and `replace_clock`.\n- Implement `replace_optimal` (requires trace look-ahead).\n- **Checkpoint:** Write a unit test using the trace `7,0,1,2,0,3`. With 3 frames, verify FIFO picks VPN 7 for eviction.\n\n### Phase 4: The Eviction Sequencer (2 Hours)\n- Implement the `evict_frame` core logic with TLB shootdown.\n- Integrate into `full_translate`. If `phys_find_free` fails, call `replace_page`.\n- **Checkpoint:** Run a trace that exceeds frame count. Verify no `OOM` occurs and `swap_write_backs` increments for dirty pages.\n\n### Phase 5: Statistics & Anomaly (2 Hours)\n- Implement `run_comparison`.\n- Implement BÃ©lÃ¡dy anomaly test script (FIFO with 3 vs 4 frames).\n- **Checkpoint:** Generate the comparative table. Verify Optimal has the lowest fault count.\n\n## 8. Test Specification\n\n### 8.1. BÃ©lÃ¡dyâ€™s Anomaly Test\n- **Trace:** `1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5` (Mapped to 4KB offsets).\n- **Condition:** Run with FIFO policy.\n- **Execution 1:** `num_frames = 3`. Expect 9 faults.\n- **Execution 2:** `num_frames = 4`. Expect 10 faults.\n- **Success:** Fault count increases when memory increases.\n\n### 8.2. Dirty Bit Persistence Test\n- **Action:** Write to `0x1000`. Perform enough other accesses to trigger eviction of VPN 1. Then read `0x1000`.\n- **Expectation:** `swap_write_backs` should be 1. The reload must show the data written originally (not zero).\n\n### 8.3. Optimal Benchmark Test\n- **Trace:** Random distribution of 100 pages.\n- **Expectation:** `faults(Optimal) <= faults(LRU) <= faults(FIFO)`.\n\n## 9. Performance Targets\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| **LRU Selection** | $O(F)$ where $F=64$ | Cycles per eviction. |\n| **Clock Selection**| $O(F)$ worst-case | Cycles per eviction. |\n| **Swap I/O** | $O(PAGE\\_SIZE)$ | `memcpy` overhead in `swap_page_out`. |\n| **Optimal Scan** | $O(F \\cdot T)$ | Wall clock time for 100k-line trace. |\n\n## 10. Hardware Soul - Cache and Pipeline Constraints\n\n### 10.1. Temporal Locality and LRU\nTrue LRU is computationally expensive because it requires a metadata update on **every** access. In our simulator, we use `logical_clock` timestamps. In real hardware, this would be a pipeline bottleneck. This is why **Clock** is the industry standardâ€”it moves the overhead from the \"Hot Path\" (access) to the \"Cold Path\" (fault handling).\n\n### 10.2. TLB Coherence (The Shootdown)\nWhen we evict a frame, the simulator calls `tlb_flush_page`. In a multi-core CPU, this triggers a **TLB Shootdown**:\n1.  Initiating CPU sends an Interrupt (IPI) to all other cores.\n2.  Cores stop execution, invalidate their local TLB entry for that VPN.\n3.  Cores acknowledge.\n4.  Initiating CPU proceeds only after all ACKs.\nOur single-threaded simulation hides this latency, but the `tlb_flush_page` call is the critical hook for where this logic would live.\n\n\n![Dirty vs Clean Page Eviction Decision â€” Cost Divergence](./diagrams/tdd-diag-26.svg)\n\n*Diagram 26: Frame Descriptor Cache-Line Packing. Showing two 32B descriptors sharing a single 64B line.*\n\n\n![evict_frame() Operation Sequence â€” Mandatory Ordering](./diagrams/tdd-diag-27.svg)\n\n*Diagram 27: The Eviction/Replacement State Machine. Transitions from Allocated -> Dirty -> Swapped -> Free.*\n\n\n![FIFO Replacement Trace â€” Step-by-Step with 3 Frames](./diagrams/tdd-diag-28.svg)\n\n*Diagram 28: Working Set Sliding Window. Tracking distinct page IDs in the last N cycles.*\n<!-- END_TDD_MOD -->\n\n\n# Project Structure: Virtual Memory Simulator\n\n## Directory Tree\n\n```text\nvmsim-root/\nâ”œâ”€â”€ include/                 # Header files (Definitions & Interfaces)\nâ”‚   â”œâ”€â”€ vmsim_types.h       # Core types, PTE masks (M1)\nâ”‚   â”œâ”€â”€ mmu.h               # MMU translation interfaces (M1-M3)\nâ”‚   â”œâ”€â”€ tlb.h               # TLB structures and logic (M2)\nâ”‚   â”œâ”€â”€ vmsim_m3_types.h    # PDE and Process structs (M3)\nâ”‚   â”œâ”€â”€ address_utils.h     # Bit-shifting decomposition helpers (M3)\nâ”‚   â”œâ”€â”€ swap.h              # Swap space & slot definitions (M4)\nâ”‚   â”œâ”€â”€ replacement_metadata.h # Frame descriptors & phys_mem (M4)\nâ”‚   â””â”€â”€ trace_parser.h      # Trace file tokenization API (M1)\nâ”œâ”€â”€ src/                     # Implementation files\nâ”‚   â”œâ”€â”€ main.c              # Simulator entry & main loop (M1-M4)\nâ”‚   â”œâ”€â”€ mmu.c               # Hierarchical walk & translation (M1, M3)\nâ”‚   â”œâ”€â”€ tlb.c               # TLB lookup, LRU, & ASID logic (M2)\nâ”‚   â”œâ”€â”€ trace_parser.c      # .trace file parsing logic (M1)\nâ”‚   â”œâ”€â”€ process_manager.c   # On-demand PT allocation (M3)\nâ”‚   â”œâ”€â”€ algorithms.c        # FIFO, LRU, Clock, Optimal logic (M4)\nâ”‚   â”œâ”€â”€ eviction_engine.c   # Dirty write-back & coherence (M4)\nâ”‚   â”œâ”€â”€ swap.c              # Page-in/Page-out I/O logic (M4)\nâ”‚   â”œâ”€â”€ working_set.c       # Sliding window locality tracker (M4)\nâ”‚   â”œâ”€â”€ reporting.c         # Stats, overhead & anomaly reports (M3, M4)\nâ”‚   â””â”€â”€ overhead_reports.c  # Sparsity savings calculations (M3)\nâ”œâ”€â”€ tests/                   # Test suite\nâ”‚   â”œâ”€â”€ tlb_tests.c         # Unit tests for TLB/ASID (M2)\nâ”‚   â””â”€â”€ integration_tests.c # End-to-end trace validation (M1-M4)\nâ”œâ”€â”€ traces/                  # Input trace files\nâ”‚   â”œâ”€â”€ basic.trace         # Simple R/W sequence (M1)\nâ”‚   â”œâ”€â”€ tlb_stress.trace    # Repeated access for hits (M2)\nâ”‚   â”œâ”€â”€ sparse.trace        # Distant addresses for sparsity (M3)\nâ”‚   â””â”€â”€ belady.trace        # Anomaly demonstration string (M4)\nâ”œâ”€â”€ build/                   # Compiled binaries and objects\nâ”œâ”€â”€ Makefile                 # Build system (gcc, flags, clean)\nâ”œâ”€â”€ README.md                # Project setup and usage guide\nâ””â”€â”€ .gitignore               # Ignore build/ and traces/\n```\n\n## Creation Order\n\n1.  **Environment & Infrastructure (M1)**\n    *   `Makefile`, `vmsim_types.h`, `trace_parser.h/.c`.\n    *   Establish ability to read `.trace` files into memory.\n\n2.  **The Translation Core (M1)**\n    *   `mmu.h/.c` (Flat Table version), `main.c`.\n    *   Implement bit-shifting for VPN/Offset and basic demand paging.\n\n3.  **The Fast Path (M2)**\n    *   `tlb.h/.c`.\n    *   Integrate TLB into `mmu.c`. Implement LRU aging and ASID matching.\n\n4.  **Hierarchical Expansion (M3)**\n    *   `vmsim_m3_types.h`, `address_utils.h`, `process_manager.c`.\n    *   Refactor `mmu.c` to perform 2-level walks with on-demand Page Table allocation.\n\n5.  **The Eviction Engine (M4)**\n    *   `replacement_metadata.h`, `swap.h/.c`, `eviction_engine.c`.\n    *   Implement the core \"shootdown\" sequence (TLB Flush -> Write-back -> PTE Clear).\n\n6.  **Heuristics & Analytics (M4)**\n    *   `algorithms.c`, `working_set.c`, `reporting.c`.\n    *   Implement FIFO, Clock, and Optimal. Generate comparative performance tables.\n\n## File Count Summary\n- **Total Files:** 22\n- **Directories:** 6\n- **Estimated Lines of Code:** ~1,800 - 2,200 LOC\n- **Primary Language:** C11 (Standard library only)\n\n# ğŸ“š Beyond the Atlas: Further Reading\n\n## ğŸŒ Foundations of Virtual Memory\n### 1. One-Level Storage System\n- **Paper**: T. Kilburn, D. B. G. Edwards, M. J. Lanigan, and F. H. Sumner, \"One-Level Storage System,\" *IRE Transactions on Electronic Computers*, 1962.\n- **Best Explanation**: *Operating Systems: Three Easy Pieces* (OSTEP) by Arpaci-Dusseau, Chapter 13: \"Address Spaces.\"\n- **Why**: This is the seminal paper from the Manchester Atlas project that invented virtual memory; reading it reveals that \"demand paging\" was born from physical hardware limitations of the 1960s.\n- **When to Read**: **Before starting Milestone 1**. It establishes the \"why\" before you touch the \"how.\"\n\n### 2. Intel 64 and IA-32 Architectures Software Developerâ€™s Manual\n- **Spec**: Intel SDM, Volume 3A, Chapter 4: \"Paging.\"\n- **Code**: `arch/x86/include/asm/pgtable_64_types.h` (Linux Kernel).\n- **Best Explanation**: OSTEP Chapter 18: \"Paging: Introduction.\"\n- **Why**: This is the authoritative \"ground truth\" for how x86 hardware actually traverses the structures you are simulating.\n- **When to Read**: **During Milestone 1**. Compare your `pte_t` bitmask to Intelâ€™s actual hardware bit definitions (Figure 4-4).\n\n## âš¡ TLB & Context Switching\n### 3. Meltdown: Reading Kernel Memory from User Space\n- **Paper**: Moritz Lipp et al., \"Meltdown: Reading Kernel Memory from User Space,\" *USENIX Security Symposium*, 2018.\n- **Code**: `arch/x86/mm/tlb.c` â€” specifically `switch_mm_irqs_off()`.\n- **Best Explanation**: \"Computer Architecture: A Quantitative Approach\" (Hennessy & Patterson), Appendix B.\n- **Why**: This paper highlights why the ASID (PCID on x86) you implement in M2 is no longer just a performance optimization, but a critical component of modern security mitigations (KPTI).\n- **When to Read**: **After Milestone 2 (TLB)**. You'll understand why flushing the TLB is the \"nuclear option\" for performance.\n\n### 4. Analysis of TLB Performance\n- **Paper**: J. Bradley Chen et al., \"The Measured Performance of Personal Computer Operating Systems,\" *ACM SIGOPS*, 1995.\n- **Best Explanation**: OSTEP Chapter 19: \"Paging: Faster Translations (TLBs).\"\n- **Why**: Quantitative proof that TLB miss rates are the primary driver of overhead in modern kernels.\n- **When to Read**: **During Milestone 2**. It validates why you are bothering to track hit/miss statistics.\n\n## ğŸŒ³ Hierarchical Structures & Sparsity\n### 5. Multi-Level Page Tables\n- **Best Explanation**: OSTEP Chapter 20: \"Paging: Smaller Tables.\"\n- **Why**: The most intuitive explanation of why \"Page Directories\" act as a sparse index, preventing the 4MB memory waste you see in Milestone 1.\n- **When to Read**: **Before Milestone 3 (Multi-Level)**. It provides the \"Coordinate System\" mental model needed for the 10-10-12 bit split.\n\n### 6. The Design and Implementation of a Log-Structured File System\n- **Paper**: Mendel Rosenblum and John K. Ousterhout, \"The Design and Implementation of a Log-Structured File System,\" *ACM TOCS*, 1992.\n- **Why**: Demonstrates how the same Radix Tree/Trie principles used in your M3 page tables are applied to disk block mapping.\n- **When to Read**: **After Milestone 3**. To see the \"Knowledge Cascade\" of how multi-level indexing applies to file systems.\n\n## ğŸ”„ Page Replacement & Swap Theory\n### 7. A Study of Replacement Algorithms for a Virtual-Storage Computer\n- **Paper**: Laszlo BÃ©lÃ¡dy, \"A study of replacement algorithms for a virtual-storage computer,\" *IBM Systems Journal*, 1966.\n- **Best Explanation**: OSTEP Chapter 22: \"Beyond Physical Memory: Policies.\"\n- **Why**: This is the origin of \"BÃ©lÃ¡dyâ€™s Anomaly,\" where the author proves that FIFO can actually perform worse with more memoryâ€”a concept you will replicate in M4.\n- **When to Read**: **Before Milestone 4 (Replacement)**. It sets the stage for the comparative analysis.\n\n### 8. Evaluation of Page Replacement Algorithms\n- **Paper**: Mattson et al., \"Evaluation techniques for storage hierarchies,\" *IBM Systems Journal*, 1970.\n- **Best Explanation**: Wikipedia's \"Stack algorithm\" entry for the formal definition.\n- **Why**: The definitive proof that LRU and Optimal are \"Stack Algorithms\" and thus immune to the anomaly you found in FIFO.\n- **When to Read**: **During Milestone 4**. It explains why the \"Inclusion Property\" makes capacity planning possible.\n\n### 9. Linux Kernel: The Page Frame Reclaim Algorithm (PFRA)\n- **Code**: `mm/vmscan.c` (Linux Kernel).\n- **Best Explanation**: *Understanding the Linux Kernel* (Bovet & Cesati), Chapter 17: \"Page Frame Reclaim.\"\n- **Why**: Shows how a production kernel implements the \"Clock\" approximation (using active/inactive lists) that you build in M4.\n- **When to Read**: **After completing the project**. It is the \"Boss Level\" of virtual memory understanding.\n\n## ğŸ› ï¸ Tooling & Real-World Application\n### 10. Valgrind: A Framework for Heavyweight Dynamic Binary Instrumentation\n- **Paper**: Nicholas Nethercote and Julian Seward, \"Valgrind: A Framework for Heavyweight Dynamic Binary Instrumentation,\" *PLDI*, 2007.\n- **Why**: Valgrind is essentially a massive, highly optimized version of the simulator you just built.\n- **When to Read**: **Project Reflection**. To see how your shadow page table concepts power modern debugging tools."}