[LEVEL1]
An aggregate rebuilds its state by replaying all events from its stream in order—each event represents a fact that happened in the past. Commands validate business rules against the current state and produce new events if valid, which are then applied to update state and queued for persistence. Keep business logic in command handlers (where validation happens) and keep apply methods pure state mutators—applying an event should never fail or validate, it just rebuilds state from history.
[/LEVEL1]
[LEVEL2]
Steps to implement event-sourced aggregates:

1. Create an abstract Aggregate base class with:
   - id and version fields to track identity and event sequence
   - uncommittedChanges list to hold new events before persistence
   - abstract apply(Event) method that subclasses override for state reconstruction

2. Implement loadFromHistory(List<Event> events):
   - Iterate through all events in order
   - Call apply(event) for each to rebuild state
   - Update version to match the last event's version
   - DO NOT add these events to uncommittedChanges (they're already persisted)

3. Implement raiseEvent(Event event) helper:
   - Add event to uncommittedChanges list
   - Immediately call apply(event) to update current state
   - Increment version for optimistic concurrency

4. Create command handler methods (e.g., createOrder, addItem, submit):
   - Validate business rules using current aggregate state
   - If valid, call raiseEvent with the new domain event
   - If invalid, throw an exception (don't emit events for failed commands)

5. Implement getUncommittedChanges() and clearChanges():
   - Repository reads uncommittedChanges after command execution
   - After successful persistence, call clearChanges() to prevent duplicates

6. In apply(Event), use pattern matching or if-else on event type:
   - Mutate aggregate state based on event data
   - Never validate or throw exceptions in apply—it must be idempotent
[/LEVEL2]
[LEVEL3]
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

abstract class Aggregate {
    protected String id;
    protected int version;
    private List<Event> uncommittedChanges = new ArrayList<>();

    // Reconstitute aggregate from event history
    public void loadFromHistory(List<Event> events) {
        for (Event event : events) {
            applyChange(event, false); // false = don't add to uncommittedChanges
            this.version = event.getVersion();
        }
    }

    // Subclasses override to rebuild state from events
    protected abstract void apply(Event event);

    // Raise new event from command handler
    protected void raiseEvent(Event event) {
        applyChange(event, true); // true = add to uncommittedChanges for persistence
    }

    private void applyChange(Event event, boolean isNew) {
        apply(event); // Delegate to subclass to mutate state
        if (isNew) {
            uncommittedChanges.add(event);
        }
    }

    public List<Event> getUncommittedChanges() {
        return new ArrayList<>(uncommittedChanges); // Return copy to prevent external modification
    }

    public void markChangesAsCommitted() {
        uncommittedChanges.clear(); // Must clear after save to avoid duplicates
    }
}

class Order extends Aggregate {
    private String customerId;
    private List<OrderItem> items = new ArrayList<>();
    private String status = "DRAFT";
    private double total = 0.0;

    // Command: validate then emit event
    public void createOrder(String orderId, String customerId) {
        if (this.id != null) {
            throw new IllegalStateException("Order already created");
        }
        raiseEvent(new OrderCreatedEvent(orderId, customerId, version + 1));
    }

    public void addItem(String productId, int quantity, double price) {
        if (!"DRAFT".equals(status)) {
            throw new IllegalStateException("Cannot modify submitted order");
        }
        raiseEvent(new ItemAddedEvent(id, productId, quantity, price, version + 1));
    }

    public void submit() {
        if (!"DRAFT".equals(status)) {
            throw new IllegalStateException("Order already submitted");
        }
        if (items.isEmpty()) {
            throw new IllegalStateException("Cannot submit empty order");
        }
        raiseEvent(new OrderSubmittedEvent(id, total, version + 1));
    }

    // Event handlers: pure state mutation, no validation
    @Override
    protected void apply(Event event) {
        if (event instanceof OrderCreatedEvent e) {
            this.id = e.getOrderId();
            this.customerId = e.getCustomerId();
        } else if (event instanceof ItemAddedEvent e) {
            items.add(new OrderItem(e.getProductId(), e.getQuantity(), e.getPrice()));
            this.total += e.getQuantity() * e.getPrice();
        } else if (event instanceof OrderSubmittedEvent e) {
            this.status = "SUBMITTED";
        }
    }
}

record OrderItem(String productId, int quantity, double price) {}