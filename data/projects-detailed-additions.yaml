# =============================================================================
# DETAILED PROJECT SPECIFICATIONS - ADDITIONS
# =============================================================================
# This file contains detailed specs for ALL projects across all domains
# To be merged into projects.yaml

# =============================================================================
# APPLICATION DEVELOPMENT - BEGINNER
# =============================================================================

todo-app:
  id: todo-app
  name: Todo App
  description: |
    Build a classic todo application with CRUD operations. Learn fundamental
    web development patterns including state management, local storage, and DOM manipulation.

  difficulty: beginner
  estimated_hours: 8-12

  prerequisites:
    - HTML/CSS basics
    - JavaScript fundamentals
    - DOM manipulation basics

  languages:
    recommended: [JavaScript, TypeScript]
    also_possible: [Python, React, Vue]

  resources:
    tutorials:
      - name: "MDN Todo App Tutorial"
        url: "https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_todo_list_beginning"
        type: tutorial
      - name: "JavaScript Todo App - freeCodeCamp"
        url: "https://www.freecodecamp.org/news/how-to-build-a-todo-app-with-javascript/"
        type: tutorial

  milestones:
    - id: todo-01
      name: Project Setup & Basic HTML Structure
      description: |
        Set up the project and create the basic HTML structure for the todo app.

      acceptance_criteria:
        - HTML page with input field for new todos
        - Add button to create todos
        - Empty list container for todos
        - Basic CSS styling applied

      hints:
        - level1: "Start with a simple HTML file with an input, button, and ul element."
        - level2: "Use semantic HTML: main, section, form elements for better structure."
        - level3: |
            HTML structure:
            <form id="todo-form">
              <input type="text" id="todo-input" placeholder="Add a todo...">
              <button type="submit">Add</button>
            </form>
            <ul id="todo-list"></ul>

      pitfalls:
        - "Forgetting to prevent default form submission"
        - "Not using semantic HTML elements"
        - "Hardcoding styles instead of using CSS classes"

      concepts:
        - HTML forms
        - Semantic HTML
        - CSS basics

      estimated_hours: 1-2

    - id: todo-02
      name: Add Todo Functionality
      description: |
        Implement the ability to add new todos to the list.

      acceptance_criteria:
        - User can type in input field
        - Pressing Enter or clicking Add creates new todo
        - New todo appears in the list
        - Input field clears after adding
        - Empty todos are not allowed

      hints:
        - level1: "Listen for form submit event, get input value, create list item."
        - level2: "Use createElement or template literals to build todo HTML dynamically."
        - level3: |
            function addTodo(text) {
              const li = document.createElement('li');
              li.textContent = text;
              todoList.appendChild(li);
            }

      pitfalls:
        - "Not trimming whitespace from input"
        - "Memory leaks from not removing event listeners"
        - "XSS vulnerability if using innerHTML without sanitization"

      concepts:
        - Event handling
        - DOM manipulation
        - Input validation

      estimated_hours: 1-2

    - id: todo-03
      name: Complete & Delete Todos
      description: |
        Add ability to mark todos as complete and delete them.

      acceptance_criteria:
        - Clicking a todo toggles its completed state
        - Completed todos have visual distinction (strikethrough)
        - Delete button removes todo from list
        - Confirmation before delete (optional)

      hints:
        - level1: "Add click event to toggle a 'completed' class on the todo item."
        - level2: "Use event delegation: listen on parent, check event.target."
        - level3: |
            todoList.addEventListener('click', (e) => {
              if (e.target.matches('.delete-btn')) {
                e.target.parentElement.remove();
              } else if (e.target.matches('li')) {
                e.target.classList.toggle('completed');
              }
            });

      pitfalls:
        - "Adding event listeners to each item (use delegation instead)"
        - "Not handling click on child elements of li"
        - "Removing wrong element from DOM"

      concepts:
        - Event delegation
        - CSS classes for state
        - DOM element removal

      estimated_hours: 1-2

    - id: todo-04
      name: Local Storage Persistence
      description: |
        Save todos to localStorage so they persist across page refreshes.

      acceptance_criteria:
        - Todos saved to localStorage on every change
        - Todos loaded from localStorage on page load
        - Completed state persists
        - Works even if localStorage is empty

      hints:
        - level1: "Use JSON.stringify to save array, JSON.parse to load."
        - level2: "Create a save function, call it after every add/delete/toggle."
        - level3: |
            function saveTodos() {
              const todos = Array.from(todoList.children).map(li => ({
                text: li.textContent,
                completed: li.classList.contains('completed')
              }));
              localStorage.setItem('todos', JSON.stringify(todos));
            }

      pitfalls:
        - "Forgetting to handle null from localStorage.getItem"
        - "Not updating localStorage after every change"
        - "Storing DOM elements instead of data"

      concepts:
        - localStorage API
        - JSON serialization
        - Data persistence

      estimated_hours: 1-2

    - id: todo-05
      name: Filter & Polish
      description: |
        Add filtering options and polish the user experience.

      acceptance_criteria:
        - Filter buttons: All, Active, Completed
        - Show count of remaining todos
        - Clear completed button
        - Smooth animations for add/remove
        - Responsive design

      hints:
        - level1: "Filter by showing/hiding items based on their completed state."
        - level2: "Keep track of current filter, re-render list when filter changes."
        - level3: |
            function filterTodos(filter) {
              const todos = todoList.querySelectorAll('li');
              todos.forEach(todo => {
                const isCompleted = todo.classList.contains('completed');
                const show = filter === 'all' ||
                  (filter === 'active' && !isCompleted) ||
                  (filter === 'completed' && isCompleted);
                todo.style.display = show ? '' : 'none';
              });
            }

      pitfalls:
        - "Not updating count when filtering"
        - "CSS transitions causing layout shifts"
        - "Accessibility issues with filter buttons"

      concepts:
        - UI state management
        - CSS transitions
        - Responsive design

      estimated_hours: 2-3

# -----------------------------------------------------------------------------

weather-app:
  id: weather-app
  name: Weather App
  description: |
    Build a weather application that fetches real-time weather data from an API.
    Learn about async JavaScript, API consumption, and handling loading/error states.

  difficulty: beginner
  estimated_hours: 10-15

  prerequisites:
    - HTML/CSS basics
    - JavaScript fundamentals
    - Understanding of async/await

  languages:
    recommended: [JavaScript, TypeScript]
    also_possible: [Python, React, Vue]

  resources:
    tutorials:
      - name: "OpenWeatherMap API"
        url: "https://openweathermap.org/api"
        type: documentation
      - name: "Build a Weather App with Vanilla JS"
        url: "https://www.youtube.com/watch?v=WZNG8UomjSI"
        type: video

  milestones:
    - id: weather-01
      name: API Setup & Basic Fetch
      description: |
        Set up API key and make basic weather API calls.

      acceptance_criteria:
        - Sign up for OpenWeatherMap API key
        - Successfully fetch weather data for a hardcoded city
        - Log weather data to console
        - Handle API errors gracefully

      hints:
        - level1: "Use fetch() with your API key as a query parameter."
        - level2: "Store API key in a config file, not hardcoded in fetch URL."
        - level3: |
            const API_KEY = 'your_api_key';
            async function getWeather(city) {
              const response = await fetch(
                `https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${API_KEY}&units=metric`
              );
              if (!response.ok) throw new Error('City not found');
              return response.json();
            }

      pitfalls:
        - "Exposing API key in client-side code (use env vars in production)"
        - "Not handling network errors"
        - "Forgetting units parameter (default is Kelvin)"

      concepts:
        - REST APIs
        - Fetch API
        - Async/await
        - Error handling

      estimated_hours: 2-3

    - id: weather-02
      name: Search Functionality
      description: |
        Allow users to search for weather by city name.

      acceptance_criteria:
        - Search input field for city name
        - Search triggers on Enter or button click
        - Loading indicator while fetching
        - Error message for invalid city

      hints:
        - level1: "Add event listener for form submit, get input value, call API."
        - level2: "Show a loading spinner while waiting for API response."
        - level3: |
            searchForm.addEventListener('submit', async (e) => {
              e.preventDefault();
              const city = cityInput.value.trim();
              if (!city) return;

              showLoading();
              try {
                const data = await getWeather(city);
                displayWeather(data);
              } catch (error) {
                showError(error.message);
              } finally {
                hideLoading();
              }
            });

      pitfalls:
        - "Not debouncing rapid searches"
        - "Not clearing previous errors"
        - "Accessibility: missing form labels"

      concepts:
        - Form handling
        - Loading states
        - Error states

      estimated_hours: 2-3

    - id: weather-03
      name: Display Weather Data
      description: |
        Create a beautiful UI to display weather information.

      acceptance_criteria:
        - Display city name and country
        - Show current temperature
        - Show weather condition with icon
        - Display humidity, wind speed
        - Show feels-like temperature

      hints:
        - level1: "Map API response fields to UI elements."
        - level2: "Use weather icon codes from API to show appropriate icons."
        - level3: |
            function displayWeather(data) {
              cityEl.textContent = `${data.name}, ${data.sys.country}`;
              tempEl.textContent = `${Math.round(data.main.temp)}Â°C`;
              iconEl.src = `https://openweathermap.org/img/wn/${data.weather[0].icon}@2x.png`;
              descEl.textContent = data.weather[0].description;
              humidityEl.textContent = `Humidity: ${data.main.humidity}%`;
              windEl.textContent = `Wind: ${data.wind.speed} m/s`;
            }

      pitfalls:
        - "Not handling missing data fields"
        - "Icon URL format changes with API version"
        - "Not rounding temperature values"

      concepts:
        - Data mapping
        - Dynamic content
        - API response structure

      estimated_hours: 2-3

    - id: weather-04
      name: Geolocation & Current Location
      description: |
        Use browser geolocation to get weather for current location.

      acceptance_criteria:
        - Button to get current location weather
        - Request geolocation permission
        - Fetch weather using lat/lon coordinates
        - Handle permission denied gracefully

      hints:
        - level1: "Use navigator.geolocation.getCurrentPosition() API."
        - level2: "API supports lat/lon params instead of city name."
        - level3: |
            function getCurrentLocationWeather() {
              navigator.geolocation.getCurrentPosition(
                async (position) => {
                  const { latitude, longitude } = position.coords;
                  const data = await getWeatherByCoords(latitude, longitude);
                  displayWeather(data);
                },
                (error) => showError('Location access denied')
              );
            }

      pitfalls:
        - "Geolocation requires HTTPS in production"
        - "Not handling timeout for slow GPS"
        - "High accuracy option drains battery"

      concepts:
        - Geolocation API
        - Permissions
        - Coordinate-based queries

      estimated_hours: 2-3

    - id: weather-05
      name: 5-Day Forecast & Polish
      description: |
        Add extended forecast and polish the application.

      acceptance_criteria:
        - Show 5-day forecast
        - Forecast shows date, icon, high/low temps
        - Toggle between Celsius and Fahrenheit
        - Responsive design for mobile
        - Save last searched city

      hints:
        - level1: "Use the forecast endpoint: /forecast?q={city}"
        - level2: "Group forecast data by day, API returns 3-hour intervals."
        - level3: |
            // Forecast API returns 40 items (8 per day x 5 days)
            function groupByDay(forecastList) {
              return forecastList.reduce((days, item) => {
                const date = item.dt_txt.split(' ')[0];
                if (!days[date]) days[date] = [];
                days[date].push(item);
                return days;
              }, {});
            }

      pitfalls:
        - "Forecast data has different structure than current weather"
        - "Time zone handling for different cities"
        - "Not caching API responses"

      concepts:
        - Data aggregation
        - Temperature conversion
        - localStorage caching

      estimated_hours: 3-4

# -----------------------------------------------------------------------------

portfolio-site:
  id: portfolio-site
  name: Portfolio Website
  description: |
    Build a personal portfolio website to showcase your projects and skills.
    Learn responsive design, CSS layouts, and web accessibility.

  difficulty: beginner
  estimated_hours: 12-16

  prerequisites:
    - HTML basics
    - CSS fundamentals
    - Basic understanding of responsive design

  languages:
    recommended: [HTML, CSS, JavaScript]
    also_possible: [React, Vue, Astro]

  resources:
    tutorials:
      - name: "freeCodeCamp Responsive Web Design"
        url: "https://www.freecodecamp.org/learn/2022/responsive-web-design/"
        type: course
      - name: "CSS Grid Garden"
        url: "https://cssgridgarden.com/"
        type: interactive

  milestones:
    - id: portfolio-01
      name: Structure & Hero Section
      description: |
        Create the basic structure and compelling hero section.

      acceptance_criteria:
        - Semantic HTML structure (header, main, sections, footer)
        - Hero section with name and tagline
        - Navigation menu
        - Responsive hero layout
        - Accessible color contrast

      hints:
        - level1: "Start with mobile-first design, then add media queries."
        - level2: "Use CSS Flexbox for hero layout, Grid for overall structure."
        - level3: |
            <header>
              <nav>...</nav>
            </header>
            <main>
              <section id="hero">
                <h1>Your Name</h1>
                <p>Full-Stack Developer</p>
                <a href="#contact" class="cta">Get in Touch</a>
              </section>
            </main>

      pitfalls:
        - "Using divs instead of semantic elements"
        - "Fixed widths that break on mobile"
        - "Low contrast text on images"

      concepts:
        - Semantic HTML
        - CSS Flexbox
        - Mobile-first design

      estimated_hours: 2-3

    - id: portfolio-02
      name: About & Skills Section
      description: |
        Create an about section with skills showcase.

      acceptance_criteria:
        - About section with bio paragraph
        - Photo or avatar
        - Skills displayed visually (badges, progress bars, or icons)
        - Responsive two-column layout

      hints:
        - level1: "Use CSS Grid for two-column about layout."
        - level2: "Display skills as a flex-wrap container of badges."
        - level3: |
            .skills-grid {
              display: flex;
              flex-wrap: wrap;
              gap: 1rem;
            }
            .skill-badge {
              padding: 0.5rem 1rem;
              background: var(--accent);
              border-radius: 4px;
            }

      pitfalls:
        - "Image not optimized for web (use WebP)"
        - "Skills list too long and overwhelming"
        - "Not using alt text for images"

      concepts:
        - CSS Grid
        - Image optimization
        - Visual hierarchy

      estimated_hours: 2-3

    - id: portfolio-03
      name: Projects Gallery
      description: |
        Showcase your projects with images and descriptions.

      acceptance_criteria:
        - Grid layout for project cards
        - Each card has image, title, description
        - Links to live demo and source code
        - Hover effects on cards
        - Filter by technology (optional)

      hints:
        - level1: "CSS Grid auto-fit creates responsive columns automatically."
        - level2: "Use aspect-ratio for consistent card image sizes."
        - level3: |
            .projects-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
              gap: 2rem;
            }
            .project-card img {
              aspect-ratio: 16/9;
              object-fit: cover;
            }

      pitfalls:
        - "Images stretching or distorting"
        - "Links not accessible (use meaningful text)"
        - "Cards different heights"

      concepts:
        - CSS Grid auto-fit
        - Card component pattern
        - Hover states

      estimated_hours: 3-4

    - id: portfolio-04
      name: Contact Form
      description: |
        Add a contact form for visitors to reach you.

      acceptance_criteria:
        - Form with name, email, message fields
        - Client-side validation
        - Submit to Formspree or similar service
        - Success/error feedback
        - Accessible form labels

      hints:
        - level1: "Use Formspree.io for free form handling without backend."
        - level2: "HTML5 validation attributes: required, type='email', minlength."
        - level3: |
            <form action="https://formspree.io/f/your-id" method="POST">
              <label for="name">Name</label>
              <input type="text" id="name" name="name" required>

              <label for="email">Email</label>
              <input type="email" id="email" name="email" required>

              <label for="message">Message</label>
              <textarea id="message" name="message" required></textarea>

              <button type="submit">Send</button>
            </form>

      pitfalls:
        - "Placeholders instead of labels (accessibility)"
        - "No validation feedback"
        - "Form not working without JavaScript"

      concepts:
        - HTML forms
        - Form validation
        - Form services

      estimated_hours: 2-3

    - id: portfolio-05
      name: Animations & Final Polish
      description: |
        Add animations and polish for a professional feel.

      acceptance_criteria:
        - Smooth scroll navigation
        - Subtle entrance animations
        - Dark/light mode toggle
        - Performance optimized (Lighthouse score > 90)
        - Meta tags for SEO

      hints:
        - level1: "CSS scroll-behavior: smooth for anchor links."
        - level2: "Use CSS @keyframes for entrance animations on scroll."
        - level3: |
            /* Smooth scroll */
            html { scroll-behavior: smooth; }

            /* Dark mode with CSS custom properties */
            :root {
              --bg: #ffffff;
              --text: #333333;
            }
            [data-theme="dark"] {
              --bg: #1a1a1a;
              --text: #f0f0f0;
            }

      pitfalls:
        - "Too many animations (distracting)"
        - "Animations causing layout shifts"
        - "prefers-reduced-motion not respected"

      concepts:
        - CSS animations
        - CSS custom properties
        - Performance optimization
        - Accessibility

      estimated_hours: 3-4

# -----------------------------------------------------------------------------

calculator:
  id: calculator
  name: Calculator
  description: |
    Build a functional calculator with a clean UI. Learn about UI state management,
    event handling, and handling edge cases in user input.

  difficulty: beginner
  estimated_hours: 8-12

  prerequisites:
    - HTML/CSS basics
    - JavaScript fundamentals

  languages:
    recommended: [JavaScript, TypeScript]
    also_possible: [Python, React, Vue]

  resources:
    tutorials:
      - name: "Build a Calculator - The Odin Project"
        url: "https://www.theodinproject.com/lessons/foundations-calculator"
        type: tutorial

  milestones:
    - id: calc-01
      name: UI Layout
      description: |
        Create the calculator interface with buttons and display.

      acceptance_criteria:
        - Display area for input and result
        - Number buttons (0-9)
        - Operator buttons (+, -, *, /)
        - Equals and clear buttons
        - Responsive grid layout

      hints:
        - level1: "Use CSS Grid for button layout - perfect for calculators."
        - level2: "Use data attributes to store button values."
        - level3: |
            .calculator {
              display: grid;
              grid-template-columns: repeat(4, 1fr);
              gap: 4px;
            }
            .display { grid-column: 1 / -1; }
            .btn-zero { grid-column: span 2; }

      pitfalls:
        - "Buttons too small for touch"
        - "Display overflow for long numbers"
        - "Not aligning numbers to the right"

      concepts:
        - CSS Grid
        - Button styling
        - Layout design

      estimated_hours: 2-3

    - id: calc-02
      name: Basic Operations
      description: |
        Implement basic arithmetic operations.

      acceptance_criteria:
        - Numbers append to display when clicked
        - Operators store current value and operation
        - Equals performs calculation
        - Clear resets calculator
        - Only one decimal point allowed

      hints:
        - level1: "Track: currentValue, previousValue, currentOperator."
        - level2: "Calculate when equals pressed or new operator selected."
        - level3: |
            function calculate(a, b, operator) {
              switch(operator) {
                case '+': return a + b;
                case '-': return a - b;
                case '*': return a * b;
                case '/': return b !== 0 ? a / b : 'Error';
              }
            }

      pitfalls:
        - "Division by zero"
        - "Multiple decimal points"
        - "Floating point precision (0.1 + 0.2)"

      concepts:
        - State management
        - Arithmetic operations
        - Edge case handling

      estimated_hours: 2-3

    - id: calc-03
      name: Chained Operations
      description: |
        Allow chaining multiple operations (e.g., 5 + 3 * 2).

      acceptance_criteria:
        - Pressing operator after operator changes operation
        - Result shown after each operator press
        - Can continue calculating without equals
        - Backspace/delete functionality

      hints:
        - level1: "When new operator pressed, first calculate previous if exists."
        - level2: "Track display mode: 'input' vs 'result' to know when to clear."
        - level3: |
            function handleOperator(op) {
              if (previousValue && currentOperator && displayMode === 'input') {
                currentValue = calculate(previousValue, parseFloat(display), currentOperator);
                updateDisplay(currentValue);
              }
              previousValue = parseFloat(display);
              currentOperator = op;
              displayMode = 'result';
            }

      pitfalls:
        - "Losing previous value when changing operators"
        - "Not updating display after intermediate calculation"
        - "Order of operations (this calculator is left-to-right)"

      concepts:
        - State transitions
        - Calculator logic
        - User experience

      estimated_hours: 2-3

    - id: calc-04
      name: Keyboard Support & Polish
      description: |
        Add keyboard input and polish the calculator.

      acceptance_criteria:
        - Number keys type numbers
        - Operator keys work (+, -, *, /)
        - Enter = equals, Escape = clear
        - Backspace deletes last digit
        - Visual feedback on button press

      hints:
        - level1: "Listen for keydown events, map key to button action."
        - level2: "Add visual feedback: briefly highlight button on keypress."
        - level3: |
            document.addEventListener('keydown', (e) => {
              if (e.key >= '0' && e.key <= '9') handleNumber(e.key);
              else if (['+', '-', '*', '/'].includes(e.key)) handleOperator(e.key);
              else if (e.key === 'Enter') handleEquals();
              else if (e.key === 'Escape') handleClear();
              else if (e.key === 'Backspace') handleBackspace();
            });

      pitfalls:
        - "Preventing default for some keys (like backspace navigating away)"
        - "Different key codes for numpad vs main keys"
        - "Focus management"

      concepts:
        - Keyboard events
        - Event key codes
        - Visual feedback

      estimated_hours: 2-3

# =============================================================================
# APPLICATION DEVELOPMENT - INTERMEDIATE
# =============================================================================

blog-platform:
  id: blog-platform
  name: Blog Platform
  description: |
    Build a full-featured blog platform with authentication, markdown support,
    and CRUD operations. Learn full-stack web development fundamentals.

  difficulty: intermediate
  estimated_hours: 25-35

  prerequisites:
    - HTML/CSS/JavaScript
    - Basic backend knowledge (Node.js or Python)
    - Database basics (SQL or MongoDB)

  languages:
    recommended: [JavaScript, Python, TypeScript]
    also_possible: [Go, Ruby, PHP]

  resources:
    tutorials:
      - name: "Build a Blog with Next.js"
        url: "https://nextjs.org/learn/basics/create-nextjs-app"
        type: tutorial
      - name: "Flask Mega-Tutorial"
        url: "https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world"
        type: tutorial

  milestones:
    - id: blog-01
      name: Project Setup & Database Schema
      description: |
        Set up the project structure and design the database.

      acceptance_criteria:
        - Project initialized with chosen framework
        - Database connection established
        - User table (id, email, password_hash, name)
        - Post table (id, title, content, author_id, created_at, updated_at)
        - Migration system in place

      hints:
        - level1: "Start with SQLite for development, switch to PostgreSQL for production."
        - level2: "Use an ORM (Prisma, SQLAlchemy, TypeORM) for database operations."
        - level3: |
            // Prisma schema example
            model User {
              id        Int      @id @default(autoincrement())
              email     String   @unique
              name      String
              password  String
              posts     Post[]
            }
            model Post {
              id        Int      @id @default(autoincrement())
              title     String
              content   String
              author    User     @relation(fields: [authorId], references: [id])
              authorId  Int
              createdAt DateTime @default(now())
            }

      pitfalls:
        - "Not indexing frequently queried columns"
        - "Storing passwords in plain text"
        - "Not using foreign key constraints"

      concepts:
        - Database design
        - ORM usage
        - Migrations

      estimated_hours: 3-4

    - id: blog-02
      name: User Authentication
      description: |
        Implement user registration and login with secure password handling.

      acceptance_criteria:
        - Registration with email/password
        - Password hashed with bcrypt
        - Login returns JWT or session
        - Protected routes require authentication
        - Logout functionality

      hints:
        - level1: "Use bcrypt with cost factor 10-12 for password hashing."
        - level2: "JWT: sign with secret, include user id and expiry."
        - level3: |
            // Express with JWT example
            app.post('/login', async (req, res) => {
              const user = await User.findByEmail(req.body.email);
              if (!user || !await bcrypt.compare(req.body.password, user.password)) {
                return res.status(401).json({ error: 'Invalid credentials' });
              }
              const token = jwt.sign({ userId: user.id }, SECRET, { expiresIn: '7d' });
              res.json({ token });
            });

      pitfalls:
        - "Storing JWT in localStorage (XSS vulnerable)"
        - "Not validating email format"
        - "Exposing whether email exists on failed login"

      concepts:
        - Password hashing
        - JWT authentication
        - HTTP-only cookies
        - CSRF protection

      estimated_hours: 5-6

    - id: blog-03
      name: Blog CRUD Operations
      description: |
        Implement create, read, update, delete for blog posts.

      acceptance_criteria:
        - Create post with title and content
        - View all posts (paginated)
        - View single post
        - Edit own posts only
        - Delete own posts only
        - Markdown support for content

      hints:
        - level1: "Use marked or markdown-it library for markdown rendering."
        - level2: "Pagination: OFFSET/LIMIT or cursor-based for large datasets."
        - level3: |
            // Pagination endpoint
            app.get('/posts', async (req, res) => {
              const page = parseInt(req.query.page) || 1;
              const limit = 10;
              const offset = (page - 1) * limit;

              const [posts, total] = await Promise.all([
                Post.findMany({ skip: offset, take: limit, orderBy: { createdAt: 'desc' } }),
                Post.count()
              ]);

              res.json({
                posts,
                pagination: { page, limit, total, pages: Math.ceil(total / limit) }
              });
            });

      pitfalls:
        - "XSS from rendering user markdown (sanitize HTML)"
        - "N+1 queries when loading posts with authors"
        - "Not checking ownership on edit/delete"

      concepts:
        - CRUD operations
        - Authorization
        - Markdown rendering
        - Pagination

      estimated_hours: 6-8

    - id: blog-04
      name: Frontend UI
      description: |
        Build the frontend interface for the blog.

      acceptance_criteria:
        - Homepage with post list
        - Post detail page
        - Login/register forms
        - Post editor with live preview
        - Responsive design

      hints:
        - level1: "Use a component library or build minimal components."
        - level2: "Split editor and preview into side-by-side panels."
        - level3: |
            // React markdown editor component
            function PostEditor({ value, onChange }) {
              return (
                <div className="editor-container">
                  <textarea
                    value={value}
                    onChange={(e) => onChange(e.target.value)}
                    className="editor"
                  />
                  <div
                    className="preview"
                    dangerouslySetInnerHTML={{ __html: marked(value) }}
                  />
                </div>
              );
            }

      pitfalls:
        - "Not handling loading states"
        - "No error boundaries"
        - "SEO issues with client-side rendering"

      concepts:
        - Component architecture
        - Form handling
        - State management

      estimated_hours: 6-8

    - id: blog-05
      name: Advanced Features
      description: |
        Add comments, tags, and search functionality.

      acceptance_criteria:
        - Comments on posts
        - Tags for posts
        - Filter posts by tag
        - Full-text search
        - RSS feed

      hints:
        - level1: "Comments: simple relation to post, nested replies optional."
        - level2: "Tags: many-to-many relation through join table."
        - level3: |
            // Full-text search with PostgreSQL
            const posts = await prisma.$queryRaw`
              SELECT * FROM posts
              WHERE to_tsvector('english', title || ' ' || content)
                    @@ plainto_tsquery('english', ${query})
              ORDER BY ts_rank(to_tsvector('english', title || ' ' || content),
                               plainto_tsquery('english', ${query})) DESC
            `;

      pitfalls:
        - "Deep comment nesting performance"
        - "Search query injection"
        - "RSS feed caching"

      concepts:
        - Full-text search
        - Many-to-many relations
        - RSS/XML generation

      estimated_hours: 5-8

# -----------------------------------------------------------------------------

chat-app:
  id: chat-app
  name: Real-time Chat
  description: |
    Build a real-time chat application using WebSockets.
    Learn about bi-directional communication, presence, and message persistence.

  difficulty: intermediate
  estimated_hours: 25-35

  prerequisites:
    - JavaScript/Node.js
    - Basic HTML/CSS
    - Understanding of HTTP

  languages:
    recommended: [JavaScript, TypeScript]
    also_possible: [Go, Python, Rust]

  resources:
    tutorials:
      - name: "Socket.io Chat Tutorial"
        url: "https://socket.io/get-started/chat"
        type: tutorial
      - name: "WebSocket API - MDN"
        url: "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API"
        type: documentation

  milestones:
    - id: chat-01
      name: WebSocket Server Setup
      description: |
        Set up WebSocket server and basic connection handling.

      acceptance_criteria:
        - Server accepts WebSocket connections
        - Clients can connect and disconnect
        - Server logs connection events
        - Basic error handling

      hints:
        - level1: "Use ws library (Node.js) or gorilla/websocket (Go)."
        - level2: "Track connected clients in a Map or Set."
        - level3: |
            const WebSocket = require('ws');
            const wss = new WebSocket.Server({ port: 8080 });
            const clients = new Set();

            wss.on('connection', (ws) => {
              clients.add(ws);
              console.log('Client connected', clients.size);

              ws.on('close', () => {
                clients.delete(ws);
                console.log('Client disconnected', clients.size);
              });
            });

      pitfalls:
        - "Not handling connection errors"
        - "Memory leaks from not cleaning up closed connections"
        - "Not implementing heartbeat/ping-pong"

      concepts:
        - WebSocket protocol
        - Connection lifecycle
        - Event-driven architecture

      estimated_hours: 2-3

    - id: chat-02
      name: Message Broadcasting
      description: |
        Implement sending and receiving messages.

      acceptance_criteria:
        - Client can send text messages
        - Server broadcasts to all connected clients
        - Messages include sender and timestamp
        - Message format is JSON

      hints:
        - level1: "Parse incoming messages as JSON, broadcast to all clients."
        - level2: "Don't send message back to sender (unless you want echo)."
        - level3: |
            ws.on('message', (data) => {
              const message = JSON.parse(data);
              const broadcast = JSON.stringify({
                type: 'message',
                user: message.user,
                text: message.text,
                timestamp: Date.now()
              });

              clients.forEach(client => {
                if (client !== ws && client.readyState === WebSocket.OPEN) {
                  client.send(broadcast);
                }
              });
            });

      pitfalls:
        - "Not checking readyState before sending"
        - "Invalid JSON crashing server"
        - "Missing message validation"

      concepts:
        - Broadcasting pattern
        - JSON message protocol
        - Error handling

      estimated_hours: 3-4

    - id: chat-03
      name: Chat Rooms
      description: |
        Implement multiple chat rooms/channels.

      acceptance_criteria:
        - Users can join/leave rooms
        - Messages scoped to room
        - List available rooms
        - Create new rooms
        - Show users in current room

      hints:
        - level1: "Use a Map: roomName -> Set of client connections."
        - level2: "Each message includes room name, only broadcast to room members."
        - level3: |
            const rooms = new Map();

            function joinRoom(ws, roomName) {
              if (!rooms.has(roomName)) {
                rooms.set(roomName, new Set());
              }
              rooms.get(roomName).add(ws);
              ws.currentRoom = roomName;
            }

            function broadcastToRoom(roomName, message, sender) {
              const room = rooms.get(roomName);
              if (!room) return;

              room.forEach(client => {
                if (client !== sender && client.readyState === WebSocket.OPEN) {
                  client.send(JSON.stringify(message));
                }
              });
            }

      pitfalls:
        - "Not removing user from room on disconnect"
        - "Room names not sanitized"
        - "Empty rooms accumulating"

      concepts:
        - Room-based messaging
        - Namespaces
        - User presence

      estimated_hours: 4-5

    - id: chat-04
      name: User Authentication & Persistence
      description: |
        Add user authentication and message history.

      acceptance_criteria:
        - Users authenticate before connecting
        - Messages stored in database
        - Load message history on join
        - User typing indicators
        - Online/offline status

      hints:
        - level1: "Send JWT token on WebSocket connect, verify before accepting."
        - level2: "Store last N messages per room, load on join."
        - level3: |
            // Typing indicator with debounce
            ws.on('message', (data) => {
              const msg = JSON.parse(data);
              if (msg.type === 'typing') {
                broadcastToRoom(ws.currentRoom, {
                  type: 'typing',
                  user: ws.user.name
                }, ws);

                // Auto-clear typing after 3 seconds
                clearTimeout(ws.typingTimeout);
                ws.typingTimeout = setTimeout(() => {
                  broadcastToRoom(ws.currentRoom, {
                    type: 'stopped_typing',
                    user: ws.user.name
                  }, ws);
                }, 3000);
              }
            });

      pitfalls:
        - "Loading too much history (pagination needed)"
        - "Typing indicator spam"
        - "Race conditions with presence"

      concepts:
        - WebSocket authentication
        - Message persistence
        - Presence system

      estimated_hours: 6-8

    - id: chat-05
      name: Frontend UI & Polish
      description: |
        Build the chat interface and add final features.

      acceptance_criteria:
        - Clean chat interface
        - Message input with send button
        - Auto-scroll to new messages
        - Notification sounds
        - Emoji support
        - File/image sharing (optional)

      hints:
        - level1: "CSS Flexbox: messages grow up, input fixed at bottom."
        - level2: "Use scrollIntoView() for auto-scroll, but not if user scrolled up."
        - level3: |
            function appendMessage(msg) {
              const wasAtBottom = isScrolledToBottom();

              const el = createMessageElement(msg);
              messagesContainer.appendChild(el);

              if (wasAtBottom) {
                el.scrollIntoView({ behavior: 'smooth' });
              }
            }

            function isScrolledToBottom() {
              const { scrollTop, scrollHeight, clientHeight } = messagesContainer;
              return scrollHeight - scrollTop <= clientHeight + 50;
            }

      pitfalls:
        - "Auto-scroll overriding user scroll position"
        - "XSS from rendering user content"
        - "Large file uploads crashing WebSocket"

      concepts:
        - Chat UI patterns
        - Scroll management
        - Rich media handling

      estimated_hours: 6-8

# -----------------------------------------------------------------------------

ecommerce-basic:
  id: ecommerce-basic
  name: E-commerce (Basic)
  description: |
    Build a basic e-commerce store with product catalog, shopping cart,
    and checkout flow. Learn about session management and payment integration.

  difficulty: intermediate
  estimated_hours: 35-50

  prerequisites:
    - Full-stack web development basics
    - Database design
    - Authentication concepts

  languages:
    recommended: [JavaScript, Python, TypeScript]
    also_possible: [Ruby, PHP, Go]

  resources:
    tutorials:
      - name: "Stripe Checkout Documentation"
        url: "https://stripe.com/docs/checkout/quickstart"
        type: documentation
      - name: "Build an E-commerce with React"
        url: "https://www.youtube.com/watch?v=4mOkFXyxfsU"
        type: video

  milestones:
    - id: ecom-01
      name: Product Catalog
      description: |
        Build the product listing and detail pages.

      acceptance_criteria:
        - Product model with name, description, price, images
        - Product listing page with grid
        - Product detail page
        - Category filtering
        - Search functionality

      hints:
        - level1: "Start with seed data, add admin panel later."
        - level2: "Use proper decimal type for prices, never floats."
        - level3: |
            // Product schema
            model Product {
              id          Int       @id @default(autoincrement())
              name        String
              description String
              price       Decimal   @db.Decimal(10, 2)
              images      String[]
              category    Category  @relation(...)
              inventory   Int       @default(0)
              createdAt   DateTime  @default(now())
            }

      pitfalls:
        - "Using floats for money (precision loss)"
        - "Not optimizing images"
        - "N+1 queries for categories"

      concepts:
        - Product data modeling
        - Image handling
        - Search implementation

      estimated_hours: 6-8

    - id: ecom-02
      name: Shopping Cart
      description: |
        Implement shopping cart functionality.

      acceptance_criteria:
        - Add products to cart
        - Update quantities
        - Remove items
        - Cart persists (localStorage or session)
        - Show cart total
        - Cart icon with item count

      hints:
        - level1: "Store cart in localStorage for guests, database for logged-in users."
        - level2: "Cart item: { productId, quantity }. Fetch product details on display."
        - level3: |
            // Cart context (React)
            const CartContext = createContext();

            function CartProvider({ children }) {
              const [items, setItems] = useState(() => {
                const saved = localStorage.getItem('cart');
                return saved ? JSON.parse(saved) : [];
              });

              useEffect(() => {
                localStorage.setItem('cart', JSON.stringify(items));
              }, [items]);

              const addItem = (productId, quantity = 1) => {
                setItems(prev => {
                  const existing = prev.find(i => i.productId === productId);
                  if (existing) {
                    return prev.map(i => i.productId === productId
                      ? { ...i, quantity: i.quantity + quantity }
                      : i
                    );
                  }
                  return [...prev, { productId, quantity }];
                });
              };

              return <CartContext.Provider value={{ items, addItem, ... }}>
                {children}
              </CartContext.Provider>;
            }

      pitfalls:
        - "Cart not syncing between tabs"
        - "Stale product prices in cart"
        - "Inventory not checked before add"

      concepts:
        - State management
        - localStorage
        - Cart patterns

      estimated_hours: 6-8

    - id: ecom-03
      name: User Accounts
      description: |
        Add user registration, login, and order history.

      acceptance_criteria:
        - User registration and login
        - User profile page
        - Order history
        - Shipping address management
        - Cart merging on login

      hints:
        - level1: "Merge guest cart with user cart on login."
        - level2: "Store multiple shipping addresses per user."
        - level3: |
            // Merge carts on login
            async function mergeCartsOnLogin(userId, guestCart) {
              const userCart = await Cart.findByUserId(userId);

              for (const guestItem of guestCart) {
                const existingItem = userCart.items.find(
                  i => i.productId === guestItem.productId
                );
                if (existingItem) {
                  existingItem.quantity += guestItem.quantity;
                } else {
                  userCart.items.push(guestItem);
                }
              }

              await userCart.save();
              return userCart;
            }

      pitfalls:
        - "Not clearing guest cart after merge"
        - "Password reset flow missing"
        - "Email verification skipped"

      concepts:
        - User accounts
        - Order management
        - Address book

      estimated_hours: 6-8

    - id: ecom-04
      name: Checkout Flow
      description: |
        Build the checkout process with payment.

      acceptance_criteria:
        - Multi-step checkout (cart -> shipping -> payment)
        - Shipping address form
        - Order summary
        - Stripe Checkout integration
        - Order confirmation email

      hints:
        - level1: "Use Stripe Checkout for easiest payment integration."
        - level2: "Create order in 'pending' state, confirm after payment webhook."
        - level3: |
            // Create Stripe Checkout session
            app.post('/create-checkout-session', async (req, res) => {
              const cart = await getCart(req.user.id);

              const session = await stripe.checkout.sessions.create({
                mode: 'payment',
                line_items: cart.items.map(item => ({
                  price_data: {
                    currency: 'usd',
                    product_data: { name: item.product.name },
                    unit_amount: Math.round(item.product.price * 100),
                  },
                  quantity: item.quantity,
                })),
                success_url: `${DOMAIN}/success?session_id={CHECKOUT_SESSION_ID}`,
                cancel_url: `${DOMAIN}/cart`,
              });

              res.json({ url: session.url });
            });

      pitfalls:
        - "Not using webhooks for payment confirmation"
        - "Inventory not reserved during checkout"
        - "Race conditions with concurrent checkouts"

      concepts:
        - Payment integration
        - Webhooks
        - Order state machine

      estimated_hours: 8-10

    - id: ecom-05
      name: Admin Panel & Inventory
      description: |
        Build admin functionality for managing products and orders.

      acceptance_criteria:
        - Admin dashboard
        - Add/edit/delete products
        - Image upload
        - Order management
        - Basic inventory tracking
        - Sales reports

      hints:
        - level1: "Use admin role in user model, middleware to protect routes."
        - level2: "Cloudinary or S3 for image hosting."
        - level3: |
            // Inventory management
            async function processOrder(order) {
              // Transaction to prevent overselling
              await prisma.$transaction(async (tx) => {
                for (const item of order.items) {
                  const product = await tx.product.update({
                    where: { id: item.productId },
                    data: { inventory: { decrement: item.quantity } },
                  });

                  if (product.inventory < 0) {
                    throw new Error(`Insufficient inventory for ${product.name}`);
                  }
                }

                await tx.order.update({
                  where: { id: order.id },
                  data: { status: 'confirmed' },
                });
              });
            }

      pitfalls:
        - "No transaction for inventory updates"
        - "Large image uploads timing out"
        - "Not validating admin access"

      concepts:
        - Admin interfaces
        - File uploads
        - Inventory management
        - Transactions

      estimated_hours: 8-12

# =============================================================================
# APPLICATION DEVELOPMENT - ADVANCED
# =============================================================================

social-network:
  id: social-network
  name: Social Network
  description: |
    Build a social network with user profiles, feeds, followers, and notifications.
    Learn about complex data relationships and real-time features at scale.

  difficulty: advanced
  estimated_hours: 60-80

  prerequisites:
    - Full-stack web development
    - Database design
    - Caching concepts
    - Real-time systems

  languages:
    recommended: [JavaScript, Python, Go]
    also_possible: [Ruby, Java, Elixir]

  resources:
    tutorials:
      - name: "Building a Social Network"
        url: "https://www.youtube.com/results?search_query=build+social+network+tutorial"
        type: video
      - name: "Feed Architecture"
        url: "https://www.youtube.com/watch?v=QmX2NPkJTKg"
        type: video

  milestones:
    - id: social-01
      name: User Profiles & Follow System
      description: |
        Build user profiles and the follow/follower relationship.

      acceptance_criteria:
        - User profile with bio, avatar, links
        - Follow/unfollow users
        - Follower and following lists
        - Follower/following counts
        - Profile editing

      hints:
        - level1: "Follow is a self-referential many-to-many relationship."
        - level2: "Store counts denormalized for performance."
        - level3: |
            // Follow relationship
            model Follow {
              id          Int      @id @default(autoincrement())
              followerId  Int
              followingId Int
              createdAt   DateTime @default(now())

              follower    User     @relation("follower", ...)
              following   User     @relation("following", ...)

              @@unique([followerId, followingId])
              @@index([followingId])
            }

            // Denormalized counts on User
            model User {
              followerCount  Int @default(0)
              followingCount Int @default(0)
            }

      pitfalls:
        - "Self-follow allowed"
        - "Count drift from denormalization"
        - "N+1 queries for follower lists"

      concepts:
        - Self-referential relations
        - Denormalization
        - Count caching

      estimated_hours: 8-10

    - id: social-02
      name: Posts & Feed (Fan-out on Write)
      description: |
        Implement posts and the home feed using fan-out on write.

      acceptance_criteria:
        - Create text/image posts
        - User's own post list
        - Home feed (posts from followed users)
        - Feed pagination (cursor-based)
        - Post timestamps

      hints:
        - level1: "Fan-out on write: when user posts, add to each follower's feed."
        - level2: "Use a Feed table: { userId, postId, createdAt }."
        - level3: |
            // Fan-out on write
            async function createPost(authorId, content) {
              const post = await Post.create({ authorId, content });

              // Get all followers
              const followers = await Follow.findMany({
                where: { followingId: authorId },
                select: { followerId: true }
              });

              // Fan-out to each follower's feed
              await FeedItem.createMany({
                data: followers.map(f => ({
                  userId: f.followerId,
                  postId: post.id,
                  createdAt: post.createdAt
                }))
              });

              return post;
            }

      pitfalls:
        - "Fan-out blocking post creation (use queue)"
        - "Celebrity problem (millions of followers)"
        - "Offset pagination performance"

      concepts:
        - Fan-out on write vs read
        - Feed generation
        - Cursor pagination

      estimated_hours: 10-12

    - id: social-03
      name: Likes, Comments & Interactions
      description: |
        Add social interactions to posts.

      acceptance_criteria:
        - Like/unlike posts
        - Comment on posts
        - Like counts (real-time update)
        - Comment threads
        - Share/repost

      hints:
        - level1: "Like: simple user-post relation. Comment: text + user + post."
        - level2: "Use optimistic UI updates for likes."
        - level3: |
            // Optimistic like with rollback
            async function likePost(postId) {
              // Optimistic update
              setLiked(true);
              setLikeCount(prev => prev + 1);

              try {
                await api.post(`/posts/${postId}/like`);
              } catch (error) {
                // Rollback on error
                setLiked(false);
                setLikeCount(prev => prev - 1);
              }
            }

      pitfalls:
        - "Double-like race condition"
        - "Comment ordering (newest vs oldest)"
        - "Deep nested replies complexity"

      concepts:
        - Social interactions
        - Optimistic updates
        - Comment systems

      estimated_hours: 8-10

    - id: social-04
      name: Notifications
      description: |
        Build a notification system for social activity.

      acceptance_criteria:
        - Notification for new follower
        - Notification for likes/comments
        - Notification badge count
        - Mark as read
        - Real-time notification delivery

      hints:
        - level1: "Notification table: { userId, type, data, read, createdAt }."
        - level2: "Use WebSocket or SSE for real-time delivery."
        - level3: |
            // Notification model
            model Notification {
              id        Int      @id
              userId    Int      // recipient
              type      String   // 'follow', 'like', 'comment'
              actorId   Int      // who triggered it
              targetId  Int?     // post id for likes/comments
              read      Boolean  @default(false)
              createdAt DateTime @default(now())

              @@index([userId, read, createdAt])
            }

            // Create notification on like
            async function createLikeNotification(postId, likerId) {
              const post = await Post.findUnique({ where: { id: postId } });
              if (post.authorId === likerId) return; // Don't notify self

              await Notification.create({
                data: {
                  userId: post.authorId,
                  type: 'like',
                  actorId: likerId,
                  targetId: postId
                }
              });

              // Real-time push
              notificationService.push(post.authorId, { type: 'like', ... });
            }

      pitfalls:
        - "Notification spam (batch similar notifications)"
        - "Notifying yourself"
        - "Notification count going negative"

      concepts:
        - Notification system
        - Real-time delivery
        - Batching

      estimated_hours: 8-10

    - id: social-05
      name: Search & Discovery
      description: |
        Add search and content discovery features.

      acceptance_criteria:
        - Search users by name/username
        - Search posts by content
        - Trending posts/hashtags
        - Suggested users to follow
        - Explore page

      hints:
        - level1: "Simple search with LIKE. Use Elasticsearch for scale."
        - level2: "Trending: count hashtags/posts in sliding window."
        - level3: |
            // Suggested users (collaborative filtering lite)
            async function getSuggestedUsers(userId) {
              // Users followed by people I follow, that I don't follow
              const suggestions = await prisma.$queryRaw`
                SELECT u.*, COUNT(*) as mutual
                FROM users u
                JOIN follows f1 ON f1.following_id = u.id
                JOIN follows f2 ON f2.follower_id = f1.follower_id
                WHERE f2.following_id = ${userId}
                  AND u.id != ${userId}
                  AND u.id NOT IN (
                    SELECT following_id FROM follows WHERE follower_id = ${userId}
                  )
                GROUP BY u.id
                ORDER BY mutual DESC
                LIMIT 10
              `;
              return suggestions;
            }

      pitfalls:
        - "Search too slow on large datasets"
        - "Trending manipulation (spam)"
        - "Recommendation bubbles"

      concepts:
        - Search implementation
        - Trending algorithms
        - Recommendation systems

      estimated_hours: 10-12

    - id: social-06
      name: Performance & Scaling
      description: |
        Optimize for performance and prepare for scale.

      acceptance_criteria:
        - Redis caching for feeds
        - Background job processing
        - CDN for media
        - Database indexing optimized
        - Load testing done

      hints:
        - level1: "Cache hot data: user profiles, feed, follower counts."
        - level2: "Use background jobs for fan-out, notifications, emails."
        - level3: |
            // Cached feed with Redis
            async function getFeed(userId, cursor) {
              const cacheKey = `feed:${userId}`;

              // Try cache first
              let feedIds = await redis.zrevrange(cacheKey, 0, 19);

              if (!feedIds.length) {
                // Cache miss - rebuild from DB
                const feed = await FeedItem.findMany({
                  where: { userId },
                  orderBy: { createdAt: 'desc' },
                  take: 100
                });

                // Populate cache
                await redis.zadd(
                  cacheKey,
                  ...feed.flatMap(f => [f.createdAt.getTime(), f.postId])
                );
                feedIds = feed.map(f => f.postId).slice(0, 20);
              }

              return Post.findMany({ where: { id: { in: feedIds } } });
            }

      pitfalls:
        - "Cache invalidation complexity"
        - "Celebrity user problem"
        - "Hot partition on popular content"

      concepts:
        - Caching strategies
        - Background jobs
        - Performance optimization

      estimated_hours: 12-15

# =============================================================================
# GAME DEVELOPMENT - BEGINNER
# =============================================================================

pong:
  id: pong
  name: Pong
  description: |
    Build the classic Pong game. Learn game loop fundamentals, collision detection,
    and basic game AI.

  difficulty: beginner
  estimated_hours: 8-12

  prerequisites:
    - Basic programming
    - HTML5 Canvas or similar graphics

  languages:
    recommended: [JavaScript, Python, C#]
    also_possible: [Rust, Go, Lua]

  resources:
    tutorials:
      - name: "Pong with JavaScript"
        url: "https://www.youtube.com/watch?v=nl0KXCa5pJk"
        type: video
      - name: "HTML5 Canvas Tutorial"
        url: "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial"
        type: documentation

  milestones:
    - id: pong-01
      name: Game Setup & Ball Movement
      description: |
        Set up the game canvas and implement ball movement.

      acceptance_criteria:
        - Canvas renders at 60fps
        - Ball appears on screen
        - Ball moves in a direction
        - Ball bounces off top and bottom walls
        - Ball resets when going off sides

      hints:
        - level1: "Use requestAnimationFrame for smooth 60fps game loop."
        - level2: "Ball velocity: { vx, vy }. Update position: x += vx, y += vy."
        - level3: |
            const ball = { x: 400, y: 300, vx: 5, vy: 3, radius: 10 };

            function update() {
              ball.x += ball.vx;
              ball.y += ball.vy;

              // Bounce off top/bottom
              if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
                ball.vy = -ball.vy;
              }

              // Reset if off sides
              if (ball.x < 0 || ball.x > canvas.width) {
                resetBall();
              }
            }

      pitfalls:
        - "Ball getting stuck in walls"
        - "Variable frame rate affecting speed"
        - "Not clearing canvas each frame"

      concepts:
        - Game loop
        - Velocity and position
        - Wall collision

      estimated_hours: 2-3

    - id: pong-02
      name: Paddles & Controls
      description: |
        Add player paddles with keyboard controls.

      acceptance_criteria:
        - Two paddles on left and right
        - Player 1 uses W/S keys
        - Player 2 uses Arrow keys
        - Paddles stay within screen bounds
        - Smooth paddle movement

      hints:
        - level1: "Track key states: keyDown sets flag, keyUp clears it."
        - level2: "Move paddles in update loop based on key states, not in event handler."
        - level3: |
            const keys = {};
            document.addEventListener('keydown', e => keys[e.key] = true);
            document.addEventListener('keyup', e => keys[e.key] = false);

            function updatePaddles() {
              if (keys['w'] && paddle1.y > 0) paddle1.y -= paddle1.speed;
              if (keys['s'] && paddle1.y < canvas.height - paddle1.height) paddle1.y += paddle1.speed;

              if (keys['ArrowUp'] && paddle2.y > 0) paddle2.y -= paddle2.speed;
              if (keys['ArrowDown'] && paddle2.y < canvas.height - paddle2.height) paddle2.y += paddle2.speed;
            }

      pitfalls:
        - "Paddle going off screen"
        - "Jerky movement from event-based updates"
        - "Key repeat delay issues"

      concepts:
        - Keyboard input
        - Input buffering
        - Bounds checking

      estimated_hours: 2-3

    - id: pong-03
      name: Paddle Collision & Scoring
      description: |
        Implement ball-paddle collision and scoring system.

      acceptance_criteria:
        - Ball bounces off paddles
        - Angle changes based on hit position
        - Score increments when ball passes paddle
        - Score displayed on screen
        - Game resets after score

      hints:
        - level1: "AABB collision: check if ball rectangle overlaps paddle rectangle."
        - level2: "Hit position affects angle: hit at edge = steeper angle."
        - level3: |
            function checkPaddleCollision(paddle) {
              if (ball.x - ball.radius < paddle.x + paddle.width &&
                  ball.x + ball.radius > paddle.x &&
                  ball.y > paddle.y &&
                  ball.y < paddle.y + paddle.height) {

                // Reverse horizontal direction
                ball.vx = -ball.vx;

                // Angle based on hit position
                const hitPos = (ball.y - paddle.y) / paddle.height; // 0 to 1
                const angle = (hitPos - 0.5) * Math.PI / 3; // -60 to +60 degrees
                const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                ball.vy = Math.sin(angle) * speed;
              }
            }

      pitfalls:
        - "Ball passing through paddle at high speed"
        - "Collision detected multiple times"
        - "Infinite speed increase"

      concepts:
        - AABB collision
        - Hit detection
        - Score system

      estimated_hours: 2-3

    - id: pong-04
      name: AI Opponent & Polish
      description: |
        Add single-player mode with AI and polish the game.

      acceptance_criteria:
        - AI controls one paddle
        - AI difficulty adjustable
        - Start/pause menu
        - Sound effects
        - Win condition (first to 10)

      hints:
        - level1: "Simple AI: move paddle toward ball Y position."
        - level2: "Add reaction delay and imperfection for difficulty levels."
        - level3: |
            function updateAI() {
              const targetY = ball.y - paddle2.height / 2;
              const diff = targetY - paddle2.y;

              // Imperfect AI - doesn't track perfectly
              const difficulty = 0.8; // 0-1, higher = harder
              const maxSpeed = paddle2.speed * difficulty;

              // Add some randomness
              if (Math.random() > 0.9) return; // Sometimes don't move

              if (Math.abs(diff) > 5) {
                paddle2.y += Math.sign(diff) * Math.min(Math.abs(diff), maxSpeed);
              }
            }

      pitfalls:
        - "Perfect AI is unbeatable"
        - "AI reacting to ball behind it"
        - "Sound playing too frequently"

      concepts:
        - Basic game AI
        - Difficulty scaling
        - Game states

      estimated_hours: 2-3

# -----------------------------------------------------------------------------

snake:
  id: snake
  name: Snake
  description: |
    Build the classic Snake game. Learn about grid-based movement, growing arrays,
    and collision detection with self.

  difficulty: beginner
  estimated_hours: 10-14

  prerequisites:
    - Basic programming
    - Array manipulation
    - HTML5 Canvas or similar

  languages:
    recommended: [JavaScript, Python, C#]
    also_possible: [Rust, Go, Lua]

  resources:
    tutorials:
      - name: "Snake with JavaScript"
        url: "https://www.youtube.com/watch?v=7Azlj0f9vas"
        type: video
      - name: "Python Snake with Pygame"
        url: "https://realpython.com/pygame-a-primer/"
        type: tutorial

  milestones:
    - id: snake-01
      name: Grid Setup & Snake Rendering
      description: |
        Set up the grid and render the snake.

      acceptance_criteria:
        - Game grid drawn on canvas
        - Snake represented as array of segments
        - Snake renders as connected blocks
        - Grid-based positioning
        - Clear visual distinction for head

      hints:
        - level1: "Snake is array of {x, y} coordinates. Head is index 0."
        - level2: "Grid cell size (e.g., 20px). Snake position in grid units."
        - level3: |
            const GRID_SIZE = 20;
            const GRID_WIDTH = 30;
            const GRID_HEIGHT = 20;

            let snake = [
              { x: 15, y: 10 }, // head
              { x: 14, y: 10 },
              { x: 13, y: 10 }
            ];

            function draw() {
              ctx.clearRect(0, 0, canvas.width, canvas.height);

              snake.forEach((segment, i) => {
                ctx.fillStyle = i === 0 ? 'darkgreen' : 'green';
                ctx.fillRect(
                  segment.x * GRID_SIZE,
                  segment.y * GRID_SIZE,
                  GRID_SIZE - 1,
                  GRID_SIZE - 1
                );
              });
            }

      pitfalls:
        - "Drawing snake in wrong order"
        - "Off-by-one in grid positioning"
        - "Not leaving gap between segments"

      concepts:
        - Grid-based games
        - Array representation
        - Canvas rendering

      estimated_hours: 2-3

    - id: snake-02
      name: Movement & Direction
      description: |
        Implement snake movement with keyboard controls.

      acceptance_criteria:
        - Snake moves automatically in current direction
        - Arrow keys change direction
        - Cannot reverse direction (no 180Â° turns)
        - Movement updates at regular interval
        - Smooth, grid-aligned movement

      hints:
        - level1: "Use setInterval for fixed movement timing, not requestAnimationFrame."
        - level2: "Queue direction changes, apply at next movement tick."
        - level3: |
            let direction = { x: 1, y: 0 };
            let nextDirection = { x: 1, y: 0 };

            document.addEventListener('keydown', e => {
              switch(e.key) {
                case 'ArrowUp':    if (direction.y !== 1) nextDirection = {x: 0, y: -1}; break;
                case 'ArrowDown':  if (direction.y !== -1) nextDirection = {x: 0, y: 1}; break;
                case 'ArrowLeft':  if (direction.x !== 1) nextDirection = {x: -1, y: 0}; break;
                case 'ArrowRight': if (direction.x !== -1) nextDirection = {x: 1, y: 0}; break;
              }
            });

            function moveSnake() {
              direction = nextDirection;
              const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
              snake.unshift(head);
              snake.pop();
            }

            setInterval(moveSnake, 150);

      pitfalls:
        - "Reversing and dying immediately"
        - "Multiple direction changes between ticks"
        - "Movement too fast or slow"

      concepts:
        - Timer-based updates
        - Direction queuing
        - Movement constraints

      estimated_hours: 2-3

    - id: snake-03
      name: Food & Growth
      description: |
        Add food spawning and snake growth.

      acceptance_criteria:
        - Food appears at random location
        - Food not spawned on snake
        - Eating food grows snake
        - New food spawns after eating
        - Score tracking

      hints:
        - level1: "To grow: don't remove tail when eating food."
        - level2: "Generate food position, check it's not on snake, regenerate if needed."
        - level3: |
            let food = spawnFood();
            let score = 0;

            function spawnFood() {
              let pos;
              do {
                pos = {
                  x: Math.floor(Math.random() * GRID_WIDTH),
                  y: Math.floor(Math.random() * GRID_HEIGHT)
                };
              } while (snake.some(s => s.x === pos.x && s.y === pos.y));
              return pos;
            }

            function moveSnake() {
              direction = nextDirection;
              const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
              snake.unshift(head);

              if (head.x === food.x && head.y === food.y) {
                score++;
                food = spawnFood();
                // Don't remove tail - snake grows
              } else {
                snake.pop();
              }
            }

      pitfalls:
        - "Food spawning on snake"
        - "Infinite loop if snake fills grid"
        - "Growth happening wrong direction"

      concepts:
        - Random positioning
        - Collision with objects
        - Array growth

      estimated_hours: 2-3

    - id: snake-04
      name: Collision & Game Over
      description: |
        Implement collision detection and game over.

      acceptance_criteria:
        - Collision with walls ends game
        - Collision with self ends game
        - Game over screen with score
        - Restart option
        - High score tracking

      hints:
        - level1: "Wall collision: head.x < 0 || head.x >= GRID_WIDTH."
        - level2: "Self collision: check if head matches any other segment."
        - level3: |
            function checkCollision() {
              const head = snake[0];

              // Wall collision
              if (head.x < 0 || head.x >= GRID_WIDTH ||
                  head.y < 0 || head.y >= GRID_HEIGHT) {
                return true;
              }

              // Self collision (skip head at index 0)
              for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                  return true;
                }
              }

              return false;
            }

            function gameOver() {
              clearInterval(gameLoop);
              const highScore = Math.max(score, localStorage.getItem('snakeHighScore') || 0);
              localStorage.setItem('snakeHighScore', highScore);
              // Show game over screen
            }

      pitfalls:
        - "Checking collision before movement"
        - "Self collision including head"
        - "High score not persisting"

      concepts:
        - Self-collision
        - Game states
        - Local storage

      estimated_hours: 2-3

    - id: snake-05
      name: Polish & Features
      description: |
        Add visual polish and additional features.

      acceptance_criteria:
        - Speed increases as snake grows
        - Sound effects
        - Pause functionality
        - Mobile touch controls
        - Different game modes (wrap-around walls)

      hints:
        - level1: "Decrease interval as score increases for speed."
        - level2: "Touch: swipe direction detection with touchstart/touchmove."
        - level3: |
            // Dynamic speed
            function getGameSpeed() {
              const baseSpeed = 150;
              const speedIncrease = Math.floor(score / 5) * 10;
              return Math.max(baseSpeed - speedIncrease, 50);
            }

            // Touch controls
            let touchStartX, touchStartY;

            canvas.addEventListener('touchstart', e => {
              touchStartX = e.touches[0].clientX;
              touchStartY = e.touches[0].clientY;
            });

            canvas.addEventListener('touchmove', e => {
              const dx = e.touches[0].clientX - touchStartX;
              const dy = e.touches[0].clientY - touchStartY;

              if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal swipe
                nextDirection = dx > 0 ? {x: 1, y: 0} : {x: -1, y: 0};
              } else {
                // Vertical swipe
                nextDirection = dy > 0 ? {x: 0, y: 1} : {x: 0, y: -1};
              }
            });

      pitfalls:
        - "Speed too aggressive"
        - "Touch events not preventing default"
        - "Pause not disabling input"

      concepts:
        - Dynamic difficulty
        - Touch input
        - Game variants

      estimated_hours: 2-3

# -----------------------------------------------------------------------------

tetris:
  id: tetris
  name: Tetris
  description: |
    Build the classic Tetris game. Learn about piece rotation, line clearing,
    and more complex game state management.

  difficulty: beginner
  estimated_hours: 15-20

  prerequisites:
    - Basic programming
    - 2D arrays
    - HTML5 Canvas or similar

  languages:
    recommended: [JavaScript, Python, C#]
    also_possible: [Rust, Go, C++]

  resources:
    tutorials:
      - name: "Tetris with JavaScript"
        url: "https://www.youtube.com/watch?v=rAUn1Lom6dw"
        type: video
      - name: "TDD Tetris Tutorial"
        url: "https://github.com/luontola/tdd-tetris-tutorial"
        type: interactive
      - name: "Coding Challenges Tetris"
        url: "https://codingchallenges.fyi/challenges/challenge-tetris/"
        type: tutorial

  milestones:
    - id: tetris-01
      name: Board & Tetrominoes
      description: |
        Create the game board and define tetromino shapes.

      acceptance_criteria:
        - 10x20 game board
        - 7 standard tetromino shapes (I, O, T, S, Z, J, L)
        - Each shape has distinct color
        - Shapes defined as 2D arrays
        - Board renders empty grid

      hints:
        - level1: "Board: 2D array of cell states (0=empty, 1-7=piece colors)."
        - level2: "Define pieces as 2D arrays, use rotation matrices or store all rotations."
        - level3: |
            const PIECES = {
              I: { shape: [[1,1,1,1]], color: 'cyan' },
              O: { shape: [[1,1],[1,1]], color: 'yellow' },
              T: { shape: [[0,1,0],[1,1,1]], color: 'purple' },
              S: { shape: [[0,1,1],[1,1,0]], color: 'green' },
              Z: { shape: [[1,1,0],[0,1,1]], color: 'red' },
              J: { shape: [[1,0,0],[1,1,1]], color: 'blue' },
              L: { shape: [[0,0,1],[1,1,1]], color: 'orange' }
            };

            // Board: 10 wide, 20 tall
            const board = Array(20).fill(null).map(() => Array(10).fill(0));

      pitfalls:
        - "Piece definition orientation inconsistent"
        - "Board dimensions swapped"
        - "Off-by-one in grid rendering"

      concepts:
        - 2D arrays
        - Piece representation
        - Grid rendering

      estimated_hours: 2-3

    - id: tetris-02
      name: Piece Falling & Controls
      description: |
        Implement falling pieces and player controls.

      acceptance_criteria:
        - Current piece falls automatically
        - Left/Right moves piece
        - Down accelerates fall
        - Space hard drops
        - Cannot move outside board

      hints:
        - level1: "Track current piece position separately from board state."
        - level2: "Validate move before applying: check bounds and collisions."
        - level3: |
            let currentPiece = { type: 'T', x: 3, y: 0 };

            function isValidPosition(piece, offsetX = 0, offsetY = 0) {
              const shape = PIECES[piece.type].shape;
              for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                  if (shape[row][col]) {
                    const newX = piece.x + col + offsetX;
                    const newY = piece.y + row + offsetY;

                    // Check bounds
                    if (newX < 0 || newX >= 10 || newY >= 20) return false;

                    // Check collision with placed pieces
                    if (newY >= 0 && board[newY][newX]) return false;
                  }
                }
              }
              return true;
            }

            function movePiece(dx, dy) {
              if (isValidPosition(currentPiece, dx, dy)) {
                currentPiece.x += dx;
                currentPiece.y += dy;
              }
            }

      pitfalls:
        - "Negative Y during spawn"
        - "Piece moving into placed blocks"
        - "Hard drop going through floor"

      concepts:
        - Position validation
        - Input handling
        - Collision detection

      estimated_hours: 3-4

    - id: tetris-03
      name: Piece Rotation
      description: |
        Implement piece rotation with wall kicks.

      acceptance_criteria:
        - Up arrow rotates piece clockwise
        - Rotation works for all pieces
        - Cannot rotate into walls or pieces
        - Wall kick: try offset positions if direct rotation fails
        - O piece doesn't rotate

      hints:
        - level1: "Transpose and reverse rows to rotate 90Â° clockwise."
        - level2: "If rotation fails, try offsets: (1,0), (-1,0), (0,-1)."
        - level3: |
            function rotateShape(shape) {
              const rows = shape.length;
              const cols = shape[0].length;
              const rotated = Array(cols).fill(null).map(() => Array(rows).fill(0));

              for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                  rotated[c][rows - 1 - r] = shape[r][c];
                }
              }
              return rotated;
            }

            function tryRotate() {
              const originalShape = PIECES[currentPiece.type].shape;
              const rotated = rotateShape(originalShape);
              PIECES[currentPiece.type].shape = rotated;

              // Try rotation at current position
              if (isValidPosition(currentPiece)) return true;

              // Try wall kicks
              const kicks = [[1, 0], [-1, 0], [0, -1], [1, -1], [-1, -1]];
              for (const [dx, dy] of kicks) {
                if (isValidPosition(currentPiece, dx, dy)) {
                  currentPiece.x += dx;
                  currentPiece.y += dy;
                  return true;
                }
              }

              // Revert if all fail
              PIECES[currentPiece.type].shape = originalShape;
              return false;
            }

      pitfalls:
        - "O piece rotation changing position"
        - "I piece wall kick needs special handling"
        - "Rotating into ceiling"

      concepts:
        - Matrix rotation
        - Wall kicks
        - SRS (Super Rotation System)

      estimated_hours: 3-4

    - id: tetris-04
      name: Line Clearing & Scoring
      description: |
        Implement line clearing and scoring system.

      acceptance_criteria:
        - Filled rows are detected
        - Filled rows are removed
        - Rows above fall down
        - Score based on lines cleared (1/2/3/4 = 100/300/500/800)
        - Level increases with lines
        - Speed increases with level

      hints:
        - level1: "Check each row: if all cells filled, remove and shift above down."
        - level2: "Track lines cleared, increase level every 10 lines."
        - level3: |
            function clearLines() {
              let linesCleared = 0;

              for (let row = board.length - 1; row >= 0; row--) {
                if (board[row].every(cell => cell !== 0)) {
                  board.splice(row, 1);
                  board.unshift(Array(10).fill(0));
                  linesCleared++;
                  row++; // Check same row again (new row fell here)
                }
              }

              if (linesCleared > 0) {
                const points = [0, 100, 300, 500, 800][linesCleared];
                score += points * level;
                totalLines += linesCleared;
                level = Math.floor(totalLines / 10) + 1;
              }
            }

      pitfalls:
        - "Iterating wrong direction when removing"
        - "Not re-checking row after splice"
        - "Tetris (4 lines) scoring wrong"

      concepts:
        - Row clearing
        - Score systems
        - Difficulty progression

      estimated_hours: 3-4

    - id: tetris-05
      name: Next Piece & Game Over
      description: |
        Add next piece preview and game over detection.

      acceptance_criteria:
        - Next piece preview shown
        - Random piece generation (7-bag system)
        - Game over when piece can't spawn
        - Game over screen
        - High score persistence

      hints:
        - level1: "Keep bag of all 7 pieces, shuffle when empty."
        - level2: "Game over: new piece spawns overlapping placed pieces."
        - level3: |
            let bag = [];
            let nextPiece = null;

            function getNextPiece() {
              if (bag.length === 0) {
                bag = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
                // Fisher-Yates shuffle
                for (let i = bag.length - 1; i > 0; i--) {
                  const j = Math.floor(Math.random() * (i + 1));
                  [bag[i], bag[j]] = [bag[j], bag[i]];
                }
              }
              return bag.pop();
            }

            function spawnPiece() {
              currentPiece = {
                type: nextPiece || getNextPiece(),
                x: 3,
                y: 0
              };
              nextPiece = getNextPiece();

              if (!isValidPosition(currentPiece)) {
                gameOver();
              }
            }

      pitfalls:
        - "Pure random causes droughts"
        - "Game over check before spawn"
        - "Next piece preview wrong position"

      concepts:
        - Randomness systems
        - Game state management
        - Preview displays

      estimated_hours: 3-4

# =============================================================================
# SECURITY - BEGINNER
# =============================================================================

hash-impl:
  id: hash-impl
  name: Hash Function (SHA-256)
  description: |
    Implement SHA-256 hash function from the NIST specification.
    Learn about cryptographic primitives and bitwise operations.

  difficulty: beginner
  estimated_hours: 10-15

  prerequisites:
    - Binary and hexadecimal representation
    - Bitwise operations
    - Basic understanding of cryptography

  languages:
    recommended: [Python, JavaScript, C]
    also_possible: [Rust, Go, Java]

  resources:
    tutorials:
      - name: "SHA-256 Step by Step"
        url: "https://blog.boot.dev/cryptography/how-sha-2-works-step-by-step-sha-256/"
        type: tutorial
      - name: "NIST SHA-256 Specification"
        url: "https://csrc.nist.gov/publications/detail/fips/180/4/final"
        type: specification

  milestones:
    - id: sha-01
      name: Message Preprocessing
      description: |
        Implement message padding and parsing.

      acceptance_criteria:
        - Convert message to binary
        - Append '1' bit
        - Pad with zeros to 448 mod 512
        - Append original length as 64-bit integer
        - Parse into 512-bit blocks

      hints:
        - level1: "Message length in bits must end at 64 bits from 512 boundary."
        - level2: "Padding: 1 + zeros + 64-bit length. Total = multiple of 512."
        - level3: |
            def preprocess(message):
                # Convert to bytes if string
                if isinstance(message, str):
                    message = message.encode()

                # Original length in bits
                original_bit_len = len(message) * 8

                # Append bit '1' (0x80 byte)
                message += b'\x80'

                # Pad with zeros until length â¡ 448 (mod 512)
                # In bytes: length â¡ 56 (mod 64)
                while (len(message) % 64) != 56:
                    message += b'\x00'

                # Append original length as 64-bit big-endian
                message += original_bit_len.to_bytes(8, 'big')

                # Parse into 512-bit (64-byte) blocks
                return [message[i:i+64] for i in range(0, len(message), 64)]

      pitfalls:
        - "Wrong bit/byte conversion"
        - "Endianness errors"
        - "Off-by-one in padding calculation"

      concepts:
        - Bit padding
        - Message blocks
        - Binary representation

      estimated_hours: 2-3

    - id: sha-02
      name: Message Schedule
      description: |
        Generate the message schedule from each 512-bit block.

      acceptance_criteria:
        - Parse 512-bit block into 16 words (32-bit each)
        - Extend to 64 words using SHA-256 schedule
        - Implement Ï0 and Ï1 functions
        - Words stored as 32-bit unsigned integers

      hints:
        - level1: "First 16 words: direct from message block (big-endian)."
        - level2: "Words 16-63: W[i] = Ï1(W[i-2]) + W[i-7] + Ï0(W[i-15]) + W[i-16]."
        - level3: |
            def rotr(x, n):
                return ((x >> n) | (x << (32 - n))) & 0xffffffff

            def sigma0(x):
                return rotr(x, 7) ^ rotr(x, 18) ^ (x >> 3)

            def sigma1(x):
                return rotr(x, 17) ^ rotr(x, 19) ^ (x >> 10)

            def message_schedule(block):
                # Parse 16 words from block (big-endian)
                W = [int.from_bytes(block[i*4:(i+1)*4], 'big') for i in range(16)]

                # Extend to 64 words
                for i in range(16, 64):
                    W.append((sigma1(W[i-2]) + W[i-7] + sigma0(W[i-15]) + W[i-16]) & 0xffffffff)

                return W

      pitfalls:
        - "Not masking to 32 bits"
        - "Right rotate vs right shift"
        - "Wrong Ï function parameters"

      concepts:
        - Rotate operations
        - XOR operations
        - Word expansion

      estimated_hours: 2-3

    - id: sha-03
      name: Compression Function
      description: |
        Implement the main compression function.

      acceptance_criteria:
        - Initialize working variables (a-h) from hash values
        - 64 rounds of compression
        - Implement Î£0, Î£1, Ch, Maj functions
        - Use correct K constants
        - Update hash values after compression

      hints:
        - level1: "Each round: T1 = h + Î£1(e) + Ch(e,f,g) + K[i] + W[i]."
        - level2: "Ch(x,y,z) = (x AND y) XOR (NOT x AND z). Maj(x,y,z) = (x AND y) XOR (x AND z) XOR (y AND z)."
        - level3: |
            # Initial hash values (first 32 bits of fractional parts of square roots of first 8 primes)
            H = [
                0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
                0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
            ]

            # K constants (first 32 bits of fractional parts of cube roots of first 64 primes)
            K = [0x428a2f98, 0x71374491, ...] # 64 values

            def compress(H, W):
                a, b, c, d, e, f, g, h = H

                for i in range(64):
                    S1 = rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25)
                    ch = (e & f) ^ (~e & g)
                    T1 = (h + S1 + ch + K[i] + W[i]) & 0xffffffff

                    S0 = rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22)
                    maj = (a & b) ^ (a & c) ^ (b & c)
                    T2 = (S0 + maj) & 0xffffffff

                    h, g, f, e, d, c, b, a = g, f, e, (d + T1) & 0xffffffff, c, b, a, (T1 + T2) & 0xffffffff

                return [(H[i] + v) & 0xffffffff for i, v in enumerate([a,b,c,d,e,f,g,h])]

      pitfalls:
        - "Mixing up Î£ and Ï functions"
        - "Wrong K constant values"
        - "Not masking intermediate results"

      concepts:
        - Compression function
        - Round functions
        - Hash state

      estimated_hours: 4-5

    - id: sha-04
      name: Final Hash Output
      description: |
        Produce the final 256-bit hash output.

      acceptance_criteria:
        - Process all message blocks
        - Concatenate final hash values
        - Output as 64-character hex string
        - Test against known vectors
        - Handle empty input correctly

      hints:
        - level1: "Process blocks sequentially, each updates hash state."
        - level2: "Final hash: concatenate all 8 hash values as big-endian."
        - level3: |
            def sha256(message):
                blocks = preprocess(message)
                H = initial_hash_values.copy()

                for block in blocks:
                    W = message_schedule(block)
                    H = compress(H, W)

                # Concatenate hash values (big-endian)
                return ''.join(h.to_bytes(4, 'big').hex() for h in H)

            # Test vectors
            assert sha256('') == 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'
            assert sha256('abc') == 'ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad'

      pitfalls:
        - "Wrong hash for empty string"
        - "Endianness in output"
        - "Not resetting state between calls"

      concepts:
        - Hash finalization
        - Test vectors
        - Hex encoding

      estimated_hours: 2-3

# =============================================================================
# CS FUNDAMENTALS - BEGINNER
# =============================================================================

linked-list:
  id: linked-list
  name: Linked List
  description: |
    Implement singly, doubly, and circular linked lists.
    Understand pointer manipulation and memory management.

  difficulty: beginner
  estimated_hours: 8-12

  prerequisites:
    - Basic programming
    - Understanding of pointers/references

  languages:
    recommended: [Python, JavaScript, C, Java]
    also_possible: [Rust, Go, C++]

  resources:
    tutorials:
      - name: "Linked List - GeeksforGeeks"
        url: "https://www.geeksforgeeks.org/linked-list-data-structure/"
        type: tutorial
      - name: "Visualgo - Linked List"
        url: "https://visualgo.net/en/list"
        type: interactive

  milestones:
    - id: ll-01
      name: Singly Linked List Basics
      description: |
        Implement a basic singly linked list with insert and traversal.

      acceptance_criteria:
        - Node class with value and next pointer
        - LinkedList class with head reference
        - Insert at beginning (prepend)
        - Insert at end (append)
        - Print/traverse list
        - Get length

      hints:
        - level1: "Node has two properties: value and next (reference to next node)."
        - level2: "Keep track of head. For append, traverse to end first."
        - level3: |
            class Node:
                def __init__(self, value):
                    self.value = value
                    self.next = None

            class LinkedList:
                def __init__(self):
                    self.head = None

                def prepend(self, value):
                    new_node = Node(value)
                    new_node.next = self.head
                    self.head = new_node

                def append(self, value):
                    new_node = Node(value)
                    if not self.head:
                        self.head = new_node
                        return
                    current = self.head
                    while current.next:
                        current = current.next
                    current.next = new_node

      pitfalls:
        - "Forgetting to handle empty list"
        - "Losing reference to head"
        - "Off-by-one in traversal"

      concepts:
        - Node structure
        - Head pointer
        - Traversal

      estimated_hours: 2-3

    - id: ll-02
      name: Search & Delete
      description: |
        Implement search and delete operations.

      acceptance_criteria:
        - Find node by value
        - Delete node by value
        - Delete at index
        - Handle not found cases
        - Handle single-element list

      hints:
        - level1: "To delete, keep track of previous node."
        - level2: "Special case: deleting head node."
        - level3: |
            def find(self, value):
                current = self.head
                while current:
                    if current.value == value:
                        return current
                    current = current.next
                return None

            def delete(self, value):
                if not self.head:
                    return False

                if self.head.value == value:
                    self.head = self.head.next
                    return True

                current = self.head
                while current.next:
                    if current.next.value == value:
                        current.next = current.next.next
                        return True
                    current = current.next
                return False

      pitfalls:
        - "Not handling delete at head"
        - "Memory leak (in manual memory languages)"
        - "Deleting wrong node"

      concepts:
        - Two-pointer technique
        - Edge cases
        - Memory management

      estimated_hours: 2-3

    - id: ll-03
      name: Doubly Linked List
      description: |
        Implement a doubly linked list with bidirectional traversal.

      acceptance_criteria:
        - Node has prev and next pointers
        - Maintain both head and tail
        - Insert at beginning and end O(1)
        - Delete from both ends O(1)
        - Traverse forward and backward

      hints:
        - level1: "Each node has three fields: value, prev, next."
        - level2: "Keep tail pointer for O(1) append."
        - level3: |
            class DoublyNode:
                def __init__(self, value):
                    self.value = value
                    self.prev = None
                    self.next = None

            class DoublyLinkedList:
                def __init__(self):
                    self.head = None
                    self.tail = None

                def append(self, value):
                    new_node = DoublyNode(value)
                    if not self.tail:
                        self.head = self.tail = new_node
                    else:
                        new_node.prev = self.tail
                        self.tail.next = new_node
                        self.tail = new_node

                def prepend(self, value):
                    new_node = DoublyNode(value)
                    if not self.head:
                        self.head = self.tail = new_node
                    else:
                        new_node.next = self.head
                        self.head.prev = new_node
                        self.head = new_node

      pitfalls:
        - "Not updating both prev and next"
        - "Forgetting to update tail"
        - "Inconsistent head/tail on single element"

      concepts:
        - Bidirectional links
        - Head and tail pointers
        - Constant time operations

      estimated_hours: 2-3

    - id: ll-04
      name: Circular & Advanced Operations
      description: |
        Implement circular linked list and advanced operations.

      acceptance_criteria:
        - Circular linked list (last points to first)
        - Reverse a linked list
        - Detect cycle (Floyd's algorithm)
        - Find middle element
        - Merge two sorted lists

      hints:
        - level1: "Circular: tail.next = head instead of null."
        - level2: "Reverse: three pointers - prev, current, next."
        - level3: |
            def reverse(self):
                prev = None
                current = self.head
                while current:
                    next_node = current.next
                    current.next = prev
                    prev = current
                    current = next_node
                self.head = prev

            def has_cycle(self):
                slow = fast = self.head
                while fast and fast.next:
                    slow = slow.next
                    fast = fast.next.next
                    if slow == fast:
                        return True
                return False

            def find_middle(self):
                slow = fast = self.head
                while fast and fast.next:
                    slow = slow.next
                    fast = fast.next.next
                return slow

      pitfalls:
        - "Infinite loop in circular list traversal"
        - "Reverse losing nodes"
        - "Cycle detection on empty list"

      concepts:
        - Circular structures
        - In-place reversal
        - Floyd's cycle detection
        - Two-pointer technique

      estimated_hours: 2-3

# =============================================================================
# SOFTWARE ENGINEERING - BEGINNER
# =============================================================================

unit-testing-basics:
  id: unit-testing-basics
  name: Unit Testing Fundamentals
  description: |
    Learn to write effective unit tests using pytest or Jest.
    Understand test structure, assertions, and test-driven development basics.

  difficulty: beginner
  estimated_hours: 8-12

  prerequisites:
    - Basic programming
    - Functions and modules

  languages:
    recommended: [Python, JavaScript]
    also_possible: [Java, Go, Rust]

  resources:
    tutorials:
      - name: "pytest Documentation"
        url: "https://docs.pytest.org/"
        type: documentation
      - name: "Jest Documentation"
        url: "https://jestjs.io/docs/getting-started"
        type: documentation
      - name: "Real Python - Testing"
        url: "https://realpython.com/python-testing/"
        type: tutorial

  milestones:
    - id: test-01
      name: First Tests & Assertions
      description: |
        Write your first unit tests with basic assertions.

      acceptance_criteria:
        - Test file created and discovered
        - Test functions with descriptive names
        - Use assert for equality
        - Use assert for truthiness
        - Test passes and fails correctly

      hints:
        - level1: "Test file: test_*.py (pytest) or *.test.js (Jest)."
        - level2: "Function name should describe what's being tested and expected outcome."
        - level3: |
            # pytest example
            def test_addition_returns_sum():
                result = add(2, 3)
                assert result == 5

            def test_addition_with_negative_numbers():
                assert add(-1, 1) == 0
                assert add(-1, -1) == -2

            def test_divide_by_zero_raises_error():
                import pytest
                with pytest.raises(ZeroDivisionError):
                    divide(1, 0)

      pitfalls:
        - "Testing implementation not behavior"
        - "Tests not independent"
        - "Unclear test names"

      concepts:
        - Test discovery
        - Assertions
        - Test naming

      estimated_hours: 2-3

    - id: test-02
      name: Test Organization & Fixtures
      description: |
        Organize tests with setup/teardown and fixtures.

      acceptance_criteria:
        - Group related tests in classes/describe blocks
        - Setup code runs before each test
        - Teardown code runs after each test
        - Fixtures provide reusable test data
        - Tests remain independent

      hints:
        - level1: "Fixtures create fresh test data for each test."
        - level2: "Use scope to control fixture lifetime (function, module, session)."
        - level3: |
            # pytest fixtures
            import pytest

            @pytest.fixture
            def sample_user():
                return User(name="Test", email="test@example.com")

            @pytest.fixture
            def database():
                db = create_test_database()
                yield db  # Test runs here
                db.cleanup()  # Teardown

            def test_user_creation(sample_user):
                assert sample_user.name == "Test"

            def test_user_save(sample_user, database):
                database.save(sample_user)
                assert database.get_user(sample_user.email) is not None

      pitfalls:
        - "Fixtures modifying shared state"
        - "Tests depending on other tests"
        - "Expensive fixtures not scoped properly"

      concepts:
        - Test fixtures
        - Setup/teardown
        - Test isolation

      estimated_hours: 2-3

    - id: test-03
      name: Testing Edge Cases & Errors
      description: |
        Test edge cases, error conditions, and boundary values.

      acceptance_criteria:
        - Test empty/null inputs
        - Test boundary values
        - Test error conditions
        - Test exception messages
        - Parametrized tests for multiple inputs

      hints:
        - level1: "Think: What are the boundaries? What invalid inputs are possible?"
        - level2: "Parametrize to test same logic with different inputs."
        - level3: |
            import pytest

            # Parametrized tests
            @pytest.mark.parametrize("input,expected", [
                ("", 0),
                ("a", 1),
                ("hello", 5),
                ("  spaces  ", 10),
            ])
            def test_string_length(input, expected):
                assert len(input) == expected

            # Edge cases
            def test_empty_list_max_raises():
                with pytest.raises(ValueError, match="empty sequence"):
                    max([])

            # Boundary values
            @pytest.mark.parametrize("age,expected", [
                (17, False),  # Just below boundary
                (18, True),   # At boundary
                (19, True),   # Just above boundary
            ])
            def test_is_adult(age, expected):
                assert is_adult(age) == expected

      pitfalls:
        - "Only testing happy path"
        - "Not testing boundaries"
        - "Catching too broad exceptions"

      concepts:
        - Edge cases
        - Boundary testing
        - Parametrization

      estimated_hours: 2-3

    - id: test-04
      name: Mocking & Test Doubles
      description: |
        Use mocks to isolate code from dependencies.

      acceptance_criteria:
        - Mock external API calls
        - Mock file system operations
        - Verify mock was called correctly
        - Mock return values
        - Understand when to mock vs not

      hints:
        - level1: "Mock external dependencies, not the code you're testing."
        - level2: "Use patch as decorator or context manager."
        - level3: |
            from unittest.mock import Mock, patch

            def test_fetch_user_data():
                # Create mock
                mock_api = Mock()
                mock_api.get_user.return_value = {"name": "Test", "id": 1}

                result = UserService(mock_api).get_user_name(1)

                assert result == "Test"
                mock_api.get_user.assert_called_once_with(1)

            @patch('mymodule.requests.get')
            def test_api_call(mock_get):
                mock_get.return_value.json.return_value = {"data": "test"}

                result = fetch_data("http://api.example.com")

                assert result == {"data": "test"}
                mock_get.assert_called_with("http://api.example.com")

      pitfalls:
        - "Mocking too much (tests don't test anything)"
        - "Mocking wrong level"
        - "Not verifying mock calls"

      concepts:
        - Test doubles
        - Mocking
        - Dependency injection

      estimated_hours: 2-3

# =============================================================================
# DISTRIBUTED & CLOUD - INTERMEDIATE
# =============================================================================

rate-limiter:
  id: rate-limiter
  name: Rate Limiter
  description: |
    Build a rate limiter using the token bucket algorithm.
    Learn about request throttling and protecting services from abuse.

  difficulty: intermediate
  estimated_hours: 10-15

  prerequisites:
    - Basic web server knowledge
    - Concurrency basics
    - Time handling

  languages:
    recommended: [Python, Go, JavaScript]
    also_possible: [Java, Rust]

  resources:
    tutorials:
      - name: "Token Bucket Algorithm"
        url: "https://en.wikipedia.org/wiki/Token_bucket"
        type: documentation
      - name: "Rate Limiting Strategies"
        url: "https://blog.bytebytego.com/p/rate-limiting-fundamentals"
        type: article

  milestones:
    - id: rl-01
      name: Token Bucket Implementation
      description: |
        Implement the core token bucket algorithm.

      acceptance_criteria:
        - Bucket has configurable capacity
        - Tokens added at configurable rate
        - Consume tokens for requests
        - Return allow/deny decision
        - Thread-safe implementation

      hints:
        - level1: "Track tokens and last refill time."
        - level2: "Refill tokens on each request based on elapsed time."
        - level3: |
            import time
            import threading

            class TokenBucket:
                def __init__(self, capacity, refill_rate):
                    self.capacity = capacity
                    self.tokens = capacity
                    self.refill_rate = refill_rate  # tokens per second
                    self.last_refill = time.time()
                    self.lock = threading.Lock()

                def _refill(self):
                    now = time.time()
                    elapsed = now - self.last_refill
                    tokens_to_add = elapsed * self.refill_rate
                    self.tokens = min(self.capacity, self.tokens + tokens_to_add)
                    self.last_refill = now

                def consume(self, tokens=1):
                    with self.lock:
                        self._refill()
                        if self.tokens >= tokens:
                            self.tokens -= tokens
                            return True
                        return False

      pitfalls:
        - "Race conditions without locking"
        - "Integer overflow in token calculation"
        - "Clock drift issues"

      concepts:
        - Token bucket algorithm
        - Thread safety
        - Rate calculations

      estimated_hours: 3-4

    - id: rl-02
      name: Per-Client Rate Limiting
      description: |
        Track rate limits per client (IP or API key).

      acceptance_criteria:
        - Each client has own bucket
        - Identify clients by IP or key
        - Clean up old buckets
        - Memory-efficient storage
        - Configurable per-client limits

      hints:
        - level1: "Use dict/map: client_id -> TokenBucket."
        - level2: "Expire buckets not used for N minutes to save memory."
        - level3: |
            class RateLimiter:
                def __init__(self, capacity, refill_rate, cleanup_interval=60):
                    self.capacity = capacity
                    self.refill_rate = refill_rate
                    self.buckets = {}
                    self.lock = threading.Lock()

                def is_allowed(self, client_id):
                    with self.lock:
                        if client_id not in self.buckets:
                            self.buckets[client_id] = TokenBucket(
                                self.capacity, self.refill_rate
                            )
                        return self.buckets[client_id].consume()

                def cleanup_old_buckets(self, max_age=300):
                    now = time.time()
                    with self.lock:
                        expired = [
                            cid for cid, bucket in self.buckets.items()
                            if now - bucket.last_refill > max_age
                        ]
                        for cid in expired:
                            del self.buckets[cid]

      pitfalls:
        - "Memory leak from never cleaning buckets"
        - "Lock contention under load"
        - "Client spoofing bypassing limits"

      concepts:
        - Per-client tracking
        - Memory management
        - Background cleanup

      estimated_hours: 2-3

    - id: rl-03
      name: HTTP Middleware Integration
      description: |
        Integrate rate limiter as HTTP middleware.

      acceptance_criteria:
        - Middleware intercepts requests
        - Returns 429 Too Many Requests when limited
        - Includes Retry-After header
        - X-RateLimit headers show limit/remaining
        - Works with Express/Flask/etc

      hints:
        - level1: "Middleware checks rate limiter, proceeds or returns 429."
        - level2: "Calculate Retry-After from time until next token."
        - level3: |
            # Flask middleware example
            from flask import Flask, request, jsonify

            app = Flask(__name__)
            limiter = RateLimiter(capacity=10, refill_rate=1)

            @app.before_request
            def rate_limit():
                client_ip = request.remote_addr
                if not limiter.is_allowed(client_ip):
                    response = jsonify({"error": "Too many requests"})
                    response.status_code = 429
                    response.headers['Retry-After'] = str(limiter.get_retry_after(client_ip))
                    response.headers['X-RateLimit-Limit'] = str(limiter.capacity)
                    response.headers['X-RateLimit-Remaining'] = '0'
                    return response

                # Set headers for successful requests too
                @after_this_request
                def add_headers(response):
                    bucket = limiter.buckets.get(client_ip)
                    if bucket:
                        response.headers['X-RateLimit-Remaining'] = str(int(bucket.tokens))
                    return response

      pitfalls:
        - "Not returning proper status code"
        - "Missing Retry-After header"
        - "Rate limit headers only on 429"

      concepts:
        - HTTP middleware
        - Rate limit headers
        - 429 response

      estimated_hours: 2-3

    - id: rl-04
      name: Distributed Rate Limiting
      description: |
        Scale rate limiter across multiple server instances.

      acceptance_criteria:
        - Rate limit shared across instances
        - Redis-backed storage
        - Atomic operations
        - Handles Redis failures gracefully
        - Consistent under high concurrency

      hints:
        - level1: "Store bucket state in Redis instead of memory."
        - level2: "Use Redis transactions (MULTI/EXEC) or Lua scripts."
        - level3: |
            # Redis Lua script for atomic token bucket
            SCRIPT = """
            local key = KEYS[1]
            local capacity = tonumber(ARGV[1])
            local refill_rate = tonumber(ARGV[2])
            local now = tonumber(ARGV[3])
            local requested = tonumber(ARGV[4])

            local bucket = redis.call('HMGET', key, 'tokens', 'last_refill')
            local tokens = tonumber(bucket[1]) or capacity
            local last_refill = tonumber(bucket[2]) or now

            -- Refill tokens
            local elapsed = now - last_refill
            tokens = math.min(capacity, tokens + elapsed * refill_rate)

            -- Try to consume
            local allowed = 0
            if tokens >= requested then
                tokens = tokens - requested
                allowed = 1
            end

            -- Save state
            redis.call('HMSET', key, 'tokens', tokens, 'last_refill', now)
            redis.call('EXPIRE', key, 3600)

            return {allowed, tokens}
            """

      pitfalls:
        - "Non-atomic read-modify-write"
        - "Redis connection failures"
        - "Clock sync between servers"

      concepts:
        - Distributed state
        - Redis Lua scripts
        - Atomic operations

      estimated_hours: 3-4

load-balancer-basic:
  id: load-balancer-basic
  name: Load Balancer (Basic)
  description: |
    Build a basic application load balancer with round-robin distribution.
    Learn about reverse proxying and server health management.

  difficulty: intermediate
  estimated_hours: 15-20

  prerequisites:
    - HTTP protocol
    - TCP networking
    - Concurrency basics

  languages:
    recommended: [Go, Python, JavaScript]
    also_possible: [Rust, Java]

  resources:
    tutorials:
      - name: "Build Your Own Load Balancer"
        url: "https://codingchallenges.fyi/challenges/challenge-load-balancer/"
        type: tutorial
      - name: "Load Balancer in Go"
        url: "https://kasvith.me/posts/lets-create-a-simple-lb-go/"
        type: tutorial

  milestones:
    - id: lb-01
      name: HTTP Proxy Foundation
      description: |
        Build basic HTTP reverse proxy functionality.

      acceptance_criteria:
        - Accept incoming HTTP requests
        - Forward to single backend server
        - Return backend response to client
        - Handle connection errors
        - Log requests

      hints:
        - level1: "Read request from client, write to backend, read response, write to client."
        - level2: "Use HTTP library to handle request/response parsing."
        - level3: |
            # Python example using requests
            from flask import Flask, request, Response
            import requests

            app = Flask(__name__)
            BACKEND = "http://localhost:8001"

            @app.route('/', defaults={'path': ''}, methods=['GET', 'POST', 'PUT', 'DELETE'])
            @app.route('/<path:path>', methods=['GET', 'POST', 'PUT', 'DELETE'])
            def proxy(path):
                url = f"{BACKEND}/{path}"

                # Forward request
                resp = requests.request(
                    method=request.method,
                    url=url,
                    headers={k: v for k, v in request.headers if k != 'Host'},
                    data=request.get_data(),
                    allow_redirects=False
                )

                # Return response
                return Response(
                    resp.content,
                    status=resp.status_code,
                    headers=dict(resp.headers)
                )

      pitfalls:
        - "Not forwarding all headers"
        - "Not handling request body"
        - "Connection timeouts"

      concepts:
        - Reverse proxy
        - HTTP forwarding
        - Request/response handling

      estimated_hours: 3-4

    - id: lb-02
      name: Round Robin Distribution
      description: |
        Distribute requests across multiple backends.

      acceptance_criteria:
        - Configure list of backend servers
        - Round-robin selection algorithm
        - Even distribution across backends
        - Thread-safe counter
        - Skip unavailable backends

      hints:
        - level1: "Keep counter, increment mod number of backends."
        - level2: "Use atomic operations for thread safety."
        - level3: |
            import threading

            class RoundRobinBalancer:
                def __init__(self, backends):
                    self.backends = backends
                    self.current = 0
                    self.lock = threading.Lock()

                def get_next(self):
                    with self.lock:
                        backend = self.backends[self.current]
                        self.current = (self.current + 1) % len(self.backends)
                        return backend

            # Usage
            backends = [
                "http://localhost:8001",
                "http://localhost:8002",
                "http://localhost:8003"
            ]
            balancer = RoundRobinBalancer(backends)

            @app.route('/<path:path>')
            def proxy(path):
                backend = balancer.get_next()
                # Forward to backend...

      pitfalls:
        - "Race condition in counter"
        - "Modulo with zero backends"
        - "Uneven distribution after backend changes"

      concepts:
        - Round robin algorithm
        - Atomic operations
        - Backend pool

      estimated_hours: 2-3

    - id: lb-03
      name: Health Checks
      description: |
        Implement active health checking of backends.

      acceptance_criteria:
        - Periodic health check requests
        - Mark unhealthy backends
        - Skip unhealthy backends in routing
        - Recover backends when healthy
        - Configurable check interval and threshold

      hints:
        - level1: "Background thread pings each backend periodically."
        - level2: "Track consecutive failures, mark unhealthy after threshold."
        - level3: |
            class HealthChecker:
                def __init__(self, backends, check_interval=5, threshold=3):
                    self.backends = backends
                    self.healthy = {b: True for b in backends}
                    self.failures = {b: 0 for b in backends}
                    self.check_interval = check_interval
                    self.threshold = threshold

                def check_backend(self, backend):
                    try:
                        resp = requests.get(f"{backend}/health", timeout=2)
                        if resp.status_code == 200:
                            self.failures[backend] = 0
                            self.healthy[backend] = True
                            return
                    except:
                        pass

                    self.failures[backend] += 1
                    if self.failures[backend] >= self.threshold:
                        self.healthy[backend] = False

                def run(self):
                    while True:
                        for backend in self.backends:
                            self.check_backend(backend)
                        time.sleep(self.check_interval)

            # In balancer
            def get_next(self):
                healthy_backends = [b for b in self.backends if health_checker.healthy[b]]
                if not healthy_backends:
                    raise NoHealthyBackendsError()
                # Round robin over healthy only

      pitfalls:
        - "Health checks overwhelming backends"
        - "No healthy backends available"
        - "Thundering herd on recovery"

      concepts:
        - Health checking
        - Failure detection
        - Graceful degradation

      estimated_hours: 3-4

    - id: lb-04
      name: Connection Pooling & Timeouts
      description: |
        Optimize with connection pooling and proper timeouts.

      acceptance_criteria:
        - Connection pool per backend
        - Configurable pool size
        - Request timeout handling
        - Connect timeout handling
        - Retry on timeout (optional)

      hints:
        - level1: "Reuse connections instead of creating new for each request."
        - level2: "Python requests uses connection pooling with Session."
        - level3: |
            from requests.adapters import HTTPAdapter
            from requests import Session

            class LoadBalancer:
                def __init__(self, backends):
                    self.backends = backends
                    self.sessions = {}

                    for backend in backends:
                        session = Session()
                        adapter = HTTPAdapter(
                            pool_connections=10,
                            pool_maxsize=10,
                            max_retries=0
                        )
                        session.mount('http://', adapter)
                        self.sessions[backend] = session

                def forward(self, backend, request):
                    return self.sessions[backend].request(
                        method=request.method,
                        url=f"{backend}{request.path}",
                        headers=dict(request.headers),
                        data=request.get_data(),
                        timeout=(3, 10)  # (connect, read) timeout
                    )

      pitfalls:
        - "Connection leak"
        - "Pool exhaustion"
        - "No timeout causing hanging"

      concepts:
        - Connection pooling
        - Timeout handling
        - Resource management

      estimated_hours: 3-4

    - id: lb-05
      name: Additional Algorithms
      description: |
        Implement additional load balancing algorithms.

      acceptance_criteria:
        - Weighted round robin
        - Least connections
        - IP hash (sticky sessions)
        - Random selection
        - Algorithm configurable at runtime

      hints:
        - level1: "Least connections: track active requests per backend."
        - level2: "IP hash: hash(client_ip) % len(backends) for consistency."
        - level3: |
            class LeastConnectionsBalancer:
                def __init__(self, backends):
                    self.backends = backends
                    self.connections = {b: 0 for b in backends}
                    self.lock = threading.Lock()

                def get_next(self):
                    with self.lock:
                        healthy = [b for b in self.backends if health_checker.healthy[b]]
                        return min(healthy, key=lambda b: self.connections[b])

                def increment(self, backend):
                    with self.lock:
                        self.connections[backend] += 1

                def decrement(self, backend):
                    with self.lock:
                        self.connections[backend] -= 1

            class IPHashBalancer:
                def __init__(self, backends):
                    self.backends = backends

                def get_next(self, client_ip):
                    healthy = [b for b in self.backends if health_checker.healthy[b]]
                    index = hash(client_ip) % len(healthy)
                    return healthy[index]

      pitfalls:
        - "Least connections not updating on response"
        - "IP hash inconsistent after backend changes"
        - "Weighted round robin integer overflow"

      concepts:
        - Load balancing algorithms
        - Session affinity
        - Algorithm tradeoffs

      estimated_hours: 4-5

# =============================================================================
# SYSTEMS & LOW-LEVEL - BEGINNER
# =============================================================================

cat-clone:
  id: cat-clone
  name: Cat Clone
  description: |
    Build a clone of the Unix cat command. Learn about file I/O,
    command-line arguments, and basic systems programming.

  difficulty: beginner
  estimated_hours: 4-6

  prerequisites:
    - Basic programming
    - Command-line usage
    - File system concepts

  languages:
    recommended: [C, Rust, Go]
    also_possible: [Python, JavaScript]

  milestones:
    - id: cat-01
      name: Read and Print File
      description: Read a single file and print its contents to stdout.

      acceptance_criteria:
        - Accept filename as command-line argument
        - Read file contents in chunks
        - Print to stdout
        - Handle file not found error

      hints:
        - level1: "Use argc/argv to get filename, open file, read contents."
        - level2: "Read in chunks (buffer) rather than entire file at once."
        - level3: "Use fread/fwrite in C, or read() system call."

      pitfalls:
        - "Reading entire file into memory (fails on large files)"
        - "Not handling binary files correctly"
        - "Not closing file handles"

      concepts:
        - File I/O
        - Command-line arguments
        - Error handling

      estimated_hours: 2-3

# -----------------------------------------------------------------------------

wc-clone:
  id: wc-clone
  name: Wc Clone
  description: |
    Build a clone of the Unix wc (word count) command.
    Count lines, words, and bytes in files.

  difficulty: beginner
  estimated_hours: 4-6

  prerequisites:
    - Basic programming
    - String processing

  languages:
    recommended: [C, Rust, Go, Python]

  milestones:
    - id: wc-01
      name: Count Lines, Words, Bytes
      description: Count lines, words, and bytes in a file.

      acceptance_criteria:
        - Count newline characters (lines)
        - Count words (whitespace-separated)
        - Count bytes
        - Output format matches wc

      hints:
        - level1: "Lines = count of newlines. Bytes = file size."
        - level2: "Word: track 'in word' state, increment on transition."
        - level3: "Use state machine for accurate word counting."

      pitfalls:
        - "Different definitions of 'word'"
        - "UTF-8 multi-byte characters"
        - "Files without trailing newline"

      concepts:
        - State machines
        - Character classification
        - File statistics

      estimated_hours: 2-3

# =============================================================================
# AI & MACHINE LEARNING - BEGINNER
# =============================================================================

linear-regression:
  id: linear-regression
  name: Linear Regression
  description: |
    Implement linear regression with gradient descent from scratch.
    Understand the fundamentals of machine learning optimization.

  difficulty: beginner
  estimated_hours: 8-12

  prerequisites:
    - Basic Python/NumPy
    - High school math (derivatives)

  languages:
    recommended: [Python]
    also_possible: [JavaScript, Julia]

  milestones:
    - id: lr-01
      name: Simple Linear Regression
      description: Implement single-variable linear regression.

      acceptance_criteria:
        - Model y = mx + b
        - Fit using closed-form solution
        - Calculate predictions
        - Calculate R2 score

      hints:
        - level1: "Closed-form: m = cov(x,y)/var(x), b = mean(y) - m*mean(x)"
        - level2: "Use numpy for vectorized operations."
        - level3: "R2 = 1 - SS_res/SS_tot"

      pitfalls:
        - "Division by zero with constant X"
        - "Data not being proper arrays"

      concepts:
        - Linear relationship
        - Least squares
        - Model evaluation

      estimated_hours: 2-3

    - id: lr-02
      name: Gradient Descent
      description: Implement gradient descent optimization.

      acceptance_criteria:
        - Cost function (MSE)
        - Gradient calculation
        - Iterative parameter update
        - Convergence detection

      hints:
        - level1: "Cost = (1/n) * sum((y_pred - y)^2)"
        - level2: "Update: param = param - learning_rate * gradient"
        - level3: "Gradient of MSE: d/dm = -2/n * sum(x*(y-y_pred))"

      pitfalls:
        - "Learning rate too high (divergence)"
        - "Not normalizing features"

      concepts:
        - Gradient descent
        - Learning rate
        - Cost function

      estimated_hours: 2-3

# -----------------------------------------------------------------------------

knn:
  id: knn
  name: KNN Classifier
  description: |
    Implement K-Nearest Neighbors classification algorithm.
    Learn about distance metrics and non-parametric models.

  difficulty: beginner
  estimated_hours: 6-10

  prerequisites:
    - Basic Python/NumPy
    - Distance formulas

  languages:
    recommended: [Python]

  milestones:
    - id: knn-01
      name: Distance and Classification
      description: Implement distance calculation and KNN classification.

      acceptance_criteria:
        - Euclidean distance implementation
        - Find k nearest neighbors
        - Majority voting
        - Calculate accuracy

      hints:
        - level1: "Euclidean: sqrt(sum((a-b)^2))"
        - level2: "Use Counter for majority voting"
        - level3: "Normalize features for better results"

      pitfalls:
        - "K larger than dataset"
        - "Feature scaling differences"

      concepts:
        - Distance metrics
        - Classification
        - Hyperparameter tuning

      estimated_hours: 3-4

# =============================================================================
# COMPILERS - BEGINNER
# =============================================================================

json-parser:
  id: json-parser
  name: JSON Parser
  description: |
    Build a JSON parser using recursive descent parsing.
    Learn about tokenization and AST construction.

  difficulty: beginner
  estimated_hours: 8-12

  prerequisites:
    - Basic programming
    - Understanding of JSON format

  languages:
    recommended: [Python, JavaScript, C]
    also_possible: [Rust, Go]

  milestones:
    - id: json-01
      name: Tokenizer
      description: Build a lexer that converts JSON string into tokens.

      acceptance_criteria:
        - Tokenize strings, numbers, booleans, null
        - Tokenize punctuation
        - Skip whitespace
        - Handle escape sequences

      hints:
        - level1: "Read char by char, emit tokens based on current char."
        - level2: "Handle escape sequences in strings."
        - level3: "Use enum for token types."

      pitfalls:
        - "Escape sequences in strings"
        - "Negative numbers"
        - "Scientific notation"

      concepts:
        - Lexical analysis
        - Token types
        - State machine

      estimated_hours: 2-3

    - id: json-02
      name: Parser
      description: Parse tokens into native data structures.

      acceptance_criteria:
        - Parse objects and arrays
        - Handle nested structures
        - Return native data types
        - Handle syntax errors

      hints:
        - level1: "Recursive descent: parse_value calls parse_object/parse_array"
        - level2: "Object: {key: value, ...}. Array: [value, ...]"
        - level3: "Use recursive functions for each grammar rule"

      pitfalls:
        - "Trailing comma handling"
        - "Deep nesting stack overflow"

      concepts:
        - Recursive descent
        - Grammar rules
        - AST construction

      estimated_hours: 3-4

# =============================================================================
# DATA & STORAGE - BEGINNER
# =============================================================================

json-db:
  id: json-db
  name: JSON File Database
  description: |
    Build a simple file-based database using JSON for storage.
    Learn about data persistence and basic database operations.

  difficulty: beginner
  estimated_hours: 8-12

  prerequisites:
    - JSON handling
    - File I/O

  languages:
    recommended: [Python, JavaScript, Go]

  milestones:
    - id: jsondb-01
      name: Basic CRUD
      description: Implement Create, Read, Update, Delete operations.

      acceptance_criteria:
        - Create with auto-generated ID
        - Read by ID
        - Update existing record
        - Delete record
        - List all records

      hints:
        - level1: "Store records in dict with ID as key"
        - level2: "Auto-generate ID: track and increment last_id"
        - level3: "Save to file after each operation"

      pitfalls:
        - "Concurrent writes"
        - "Data loss on crash"
        - "ID collision"

      concepts:
        - CRUD operations
        - Data persistence
        - File-based storage

      estimated_hours: 3-4

# =============================================================================
# GAME DEVELOPMENT - INTERMEDIATE
# =============================================================================

platformer:
  id: platformer
  name: Platformer
  description: |
    Build a 2D platformer game with gravity, jumping, and collision.
    Learn about physics simulation and level design.

  difficulty: intermediate
  estimated_hours: 20-30

  prerequisites:
    - Basic game loop concepts
    - 2D graphics basics

  languages:
    recommended: [JavaScript, Python, C#]
    also_possible: [Rust, Go, Lua]

  milestones:
    - id: plat-01
      name: Player Physics
      description: Implement player movement with gravity and jumping.

      acceptance_criteria:
        - Gravity pulls player down
        - Left/right movement
        - Jump with velocity
        - Variable jump height (hold to jump higher)
        - Coyote time (jump briefly after leaving platform)

      hints:
        - level1: "Velocity-based movement: position += velocity * dt"
        - level2: "Gravity: velocity.y += GRAVITY * dt each frame"
        - level3: "Variable jump: cut velocity when button released"

      pitfalls:
        - "Floaty jumps (gravity too low)"
        - "Frame-rate dependent physics"
        - "Getting stuck in platforms"

      concepts:
        - Physics simulation
        - Jump mechanics
        - Game feel

      estimated_hours: 5-7

    - id: plat-02
      name: Collision Detection
      description: Implement tile-based collision.

      acceptance_criteria:
        - Detect collision with platforms
        - Stand on platforms
        - Collide with walls
        - Handle slopes (optional)

      hints:
        - level1: "AABB collision: check overlap of bounding boxes"
        - level2: "Separate X and Y collision resolution"
        - level3: "Check only tiles near player for efficiency"

      pitfalls:
        - "Tunneling through thin platforms"
        - "Corner cases (literal corners)"
        - "One-way platforms"

      concepts:
        - AABB collision
        - Collision resolution
        - Tile maps

      estimated_hours: 5-7

# =============================================================================
# DISTRIBUTED - ADVANCED
# =============================================================================

distributed-cache:
  id: distributed-cache
  name: Distributed Cache
  description: |
    Build a distributed cache with consistent hashing.
    Learn about data distribution and cache coherence.

  difficulty: advanced
  estimated_hours: 30-40

  prerequisites:
    - Networking basics
    - Hash tables
    - Distributed systems concepts

  languages:
    recommended: [Go, Rust, Java]
    also_possible: [Python]

  milestones:
    - id: dcache-01
      name: Consistent Hashing
      description: Implement consistent hashing for key distribution.

      acceptance_criteria:
        - Hash ring implementation
        - Add/remove nodes with minimal redistribution
        - Virtual nodes for better distribution
        - Key lookup O(log n)

      hints:
        - level1: "Map nodes and keys to points on a ring (0 to 2^32)"
        - level2: "Key belongs to first node clockwise from its position"
        - level3: "Virtual nodes: each physical node has multiple positions"

      pitfalls:
        - "Poor distribution without virtual nodes"
        - "All keys moving when node added"
        - "Hash function collisions"

      concepts:
        - Consistent hashing
        - Virtual nodes
        - Key distribution

      estimated_hours: 6-8

    - id: dcache-02
      name: Cache Operations
      description: Implement get/set operations across distributed nodes.

      acceptance_criteria:
        - GET routes to correct node
        - SET with TTL support
        - DELETE operation
        - LRU eviction when full

      hints:
        - level1: "Hash key to find responsible node, forward request"
        - level2: "Each node maintains local LRU cache"
        - level3: "Use TCP/gRPC for inter-node communication"

      pitfalls:
        - "Network partitions"
        - "Stale data after node changes"
        - "Hot keys overloading single node"

      concepts:
        - Cache operations
        - LRU eviction
        - Request routing

      estimated_hours: 8-10
