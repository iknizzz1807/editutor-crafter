id: anticheat-kernel-driver
name: Vanguard Anti-Cheat Driver
description: >-
  Linux kernel module for game process protection using system callbacks,
  memory integrity scanning, and kernel-userspace communication via netlink
  or IOCTL.
difficulty: expert
estimated_hours: 70
essence: >-
  Kernel-mode security instrumentation using system-wide callbacks and memory
  protection mechanisms to monitor process memory integrity and prevent
  unauthorized code injection or hooking.
why_important: >-
  Anti-cheat systems are the ultimate cat-and-mouse game in security. Building
  one teaches you kernel-space programming, hardware-level protection
  mechanisms, and the deepest internals of operating systems.
learning_outcomes:
  - Implement a Linux kernel module with proper initialization and cleanup
  - Design kernel-userspace communication via netlink sockets or misc devices
  - Build process monitoring using task_struct traversal and notifier chains
  - Implement memory integrity checks using cryptographic hashing of code sections
  - Detect inline hooks and IAT modifications in target processes
  - Handle kernel debugging with QEMU+GDB or native debugging
  - Understand Linux security modules (LSM) and when to use them
skills:
  - Kernel Programming
  - Security Research
  - Linux Internals
  - C Programming
  - Debugging
tags:
  - security
  - kernel
  - anti-cheat
  - low-level
  - linux
architecture_doc: architecture-docs/anticheat-kernel-driver/index.md
languages:
  recommended:
    - C
  also_possible:
    - Rust
resources:
  - name: Linux Kernel Module Programming Guide
    url: https://sysprog21.github.io/lkmpg/
    type: tutorial
  - name: Linux Driver Development
    url: https://www.kernel.org/doc/html/latest/driver-api/
    type: documentation
  - name: Rootkit Arsenal
    url: https://www.amazon.com/Rootkit-Arsenal-Escape-Evasion-Corners/dp/144962636X
    type: book
prerequisites:
  - type: skill
    name: C programming (advanced)
  - type: skill
    name: Linux command line and build tools
  - type: skill
    name: Basic operating system concepts
milestones:
  - id: anticheat-kernel-driver-m1
    name: Kernel Module Entry & Communication
    description: >-
      Set up the kernel module with proper lifecycle and establish
      kernel-userspace communication channel.
    acceptance_criteria:
      - "Kernel module loads successfully with insmod and unloads cleanly with rmmod"
      - "Module registers a misc device or netlink socket for userspace communication"
      - "Userspace application can send and receive messages via the communication channel"
      - "Module handles multiple concurrent userspace connections safely"
      - "Proper reference counting prevents use-after-free on unload"
      - "Module logs to kernel ring buffer (dmesg) for debugging"
    pitfalls:
      - "Memory leaks in kernel memory (kmalloc without kfree) waste non-reclaimable memory"
      - "Improper cleanup leaves dangling references causing crash on later access"
      - "Race conditions in IOCTL handlers if shared state isn't protected"
      - "Blocking operations in communication handlers can hang the system"
    concepts:
      - Kernel module init/exit lifecycle
      - Misc device registration for IOCTL
      - Netlink sockets for bidirectional communication
      - Reference counting for object lifetime
    skills:
      - Kernel module development
      - Character device implementation
      - Kernel-userspace IPC
      - Memory management in kernel space
    deliverables:
      - Kernel module with module_init/module_exit
      - Misc device with file_operations for open/read/write/release/ioctl
      - Alternative: Netlink socket family for message passing
      - Simple userspace test client for communication verification
    estimated_hours: 15

  - id: anticheat-kernel-driver-m2
    name: Process Monitoring
    description: >-
      Monitor process lifecycle events and protect target process from
      unauthorized access.
    acceptance_criteria:
      - "Register notifier callback for process execution (execve) events"
      - "Identify target process by name, PID, or path"
      - "Track target process creation and termination"
      - "Monitor for foreign thread creation in target process address space"
      - "Optionally restrict process handle access using LSM hooks or ptrace_scope"
    pitfalls:
      - "Notifier callbacks run in atomic context—cannot sleep or call blocking functions"
      - "Recursive callbacks can cause stack overflow—track re-entry"
      - "Over-aggressive blocking can crash legitimate applications"
      - "Task struct pointers become invalid after task exits—use proper locking"
    concepts:
      - Process notifier chains for lifecycle events
      - task_struct traversal for process information
      - Thread group vs individual threads
      - LSM (Linux Security Modules) for access control
    skills:
      - Kernel notifier chains
      - Process structure navigation
      - Concurrency in kernel context
      - Security hook integration
    deliverables:
      - Execve notifier tracking process creation
      - Target process identification and tracking
      - Thread creation detection via clone/fork events
      - Process exit cleanup to avoid dangling references
    estimated_hours: 18

  - id: anticheat-kernel-driver-m3
    name: Memory Integrity Scanning
    description: >-
      Scan target process memory for unauthorized modifications and code hooks.
    acceptance_criteria:
      - "Access target process memory via /proc/pid/mem or get_user_pages"
      - "Compute cryptographic hash (SHA-256 or SipHash) of code sections"
      - "Compare against known-good hashes to detect modifications"
      - "Detect inline hooks (JMP instructions at function entry points)"
      - "Report violations to userspace service via communication channel"
      - "Handle process exiting during scan gracefully"
    pitfalls:
      - "Accessing memory of exiting process causes use-after-free—pin pages or check state"
      - "Scanning impacts game performance—throttle scans and avoid hot paths"
      - "False positives from legitimate code changes (JIT, ASLR relocations)"
      - "Race between scan and modification—consider pausing threads or using breakpoints"
    concepts:
      - Process memory access via mm_struct and page tables
      - Code integrity verification via hashing
      - Inline hook detection (unexpected JMP/CALL at entry)
      - Kernel-workers for background scanning
    skills:
      - Process memory access
      - Cryptographic hashing in kernel
      - Background work scheduling
      - Safe concurrent access patterns
    deliverables:
      - Memory scanner worker using kernel workqueue
      - Code section hasher comparing against baseline
      - Inline hook detector checking for JMP opcodes
      - Violation reporter sending alerts to userspace
    estimated_hours: 20

  - id: anticheat-kernel-driver-m4
    name: User-Mode Management Service
    description: >-
      Build the userspace service that configures the driver and handles
      integrity reports.
    acceptance_criteria:
      - "Service connects to kernel module via misc device or netlink"
      - "Service sends configuration (target process, scan intervals, hash baselines)"
      - "Service receives and logs integrity violation reports"
      - "Service implements policy decisions (log, warn, terminate)"
      - "Service handles driver load/unload gracefully with reconnection"
    pitfalls:
      - "Service crash leaves driver in undefined state—implement heartbeat"
      - "Privilege escalation if service runs as root—minimize permissions"
      - "Communication protocol versioning for forward compatibility"
    concepts:
      - Daemon process for background service
      - Event-driven communication with kernel
      - Policy engine for response decisions
      - Graceful degradation on failures
    skills:
      - Unix daemon development
      - Netlink socket programming
      - Event loop design
      - Privilege management
    deliverables:
      - User-mode daemon with event loop
      - Configuration file parser for driver settings
      - Violation handler with logging and policy enforcement
      - CLI tool for status and configuration
    estimated_hours: 12

  - id: anticheat-kernel-driver-m5
    name: Testing & Debugging Infrastructure
    description: >-
      Set up safe testing environment and debugging tools for kernel
      development.
    acceptance_criteria:
      - "QEMU or VM setup for safe kernel module testing"
      - "Kernel debug symbols enabled for meaningful stack traces"
      - "GDB or kgdb setup for kernel debugging"
      - "Test suite with simulated attacks (code injection, hooking)"
      - "Module works across kernel version changes (document version requirements)"
    pitfalls:
      - "Testing on host machine risks full system crash—always use VM first"
      - "Missing debug symbols make crashes impossible to diagnose"
      - "Kernel version API changes break module—track version requirements"
    concepts:
      - Virtualization for safe kernel testing
      - Kernel debugging with GDB/kgdb
      - Symbol resolution and stack traces
      - Regression testing for kernel modules
    skills:
      - QEMU/KVM setup
      - Kernel debugging
      - Test automation
      - Version compatibility management
    deliverables:
      - QEMU launch script with debug kernel
      - GDB init script for kernel debugging
      - Test cases for each detection mechanism
      - Documentation of kernel version requirements
    estimated_hours: 5