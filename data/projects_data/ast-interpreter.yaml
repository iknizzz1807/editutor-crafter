id: ast-interpreter
name: AST Tree-Walking Interpreter
description: Tree-walking interpreter that evaluates AST nodes directly, implementing variable binding, control flow, and heap-allocated closures with proper environment persistence.
difficulty: intermediate
estimated_hours: 16
essence: Recursive traversal of abstract syntax trees to evaluate expressions, manage variable bindings in nested scopes, and execute control flow by interpreting nodes directly without compilation to machine code.
why_important: Building an AST interpreter teaches the foundational principles behind every interpreted language (Python, Ruby, JavaScript), providing essential knowledge for language design, compiler construction, and understanding how code execution actually works under the hood.
learning_outcomes:
- Implement tree-walking evaluation for expressions and statements
- Build environment chains for lexical scope management
- Implement control flow with if/else, while, for, break, and continue
- Create heap-allocated closures that survive after their defining scope exits
- Handle runtime errors with meaningful messages and source locations
skills:
- Tree-Walking Interpretation
- Environment Chaining
- Closure Implementation
- Control Flow
- Runtime Error Handling
tags:
- interpreter
- tree-walking
- ast
- closures
- intermediate
architecture_doc: architecture-docs/ast-interpreter/index.md
languages:
  recommended:
  - Python
  - JavaScript
  - Rust
  also_possible:
  - Go
  - Java
resources:
- name: Crafting Interpreters
  url: https://craftinginterpreters.com/
  type: book
- name: Writing an Interpreter in Go
  url: https://interpreterbook.com/
  type: book
- name: Python ceval.c
  url: https://github.com/python/cpython/blob/main/Python/ceval.c
  type: code
prerequisites:
- type: skill
  name: Tree data structures and traversal
- type: skill
  name: Recursion
- type: skill
  name: Basic parsing concepts
milestones:
- id: ast-interpreter-m1
  name: Expression Evaluation
  description: Evaluate arithmetic and comparison expressions with runtime type checking.
  acceptance_criteria:
  - Literal nodes evaluate to their corresponding runtime values (numbers, strings, booleans, nil)
  - Binary operators (+, -, *, /, <, >, ==, !=) produce correct results for valid operand types
  - Unary minus negates numeric values and logical-not inverts boolean truthiness
  - Parenthesized expressions are evaluated first, correctly overriding default operator precedence
  - Runtime type errors are raised with clear messages when operators are applied to incompatible types
  pitfalls:
  - 'Type errors at runtime: always validate operand types before operations'
  - 'Division by zero: decide if this is an error or returns Infinity/NaN'
  - Short-circuit evaluation for AND and OR must NOT evaluate the right operand when result is already determined
  concepts:
  - Tree-walking visits each AST node and computes a runtime value
  - Evaluation rules define how each node type produces a value
  - Operator semantics include type checking and result computation
  skills:
  - Recursive AST traversal
  - Operator precedence handling
  - Type coercion and checking
  - Runtime error handling
  deliverables:
  - Literal value evaluation that returns numbers, strings, and booleans as runtime values
  - Binary operator evaluation with runtime type checking for arithmetic, comparison, and equality
  - Unary operator evaluation supporting numeric negation and logical-not operations
  - Short-circuit evaluation for logical AND and OR that skips the right operand when result is determined
  - Runtime error reporting with source location for type mismatches
  estimated_hours: 4
- id: ast-interpreter-m2
  name: Variables and Environment
  description: Implement variable binding and lookup with environment chaining.
  acceptance_criteria:
  - Environment stores name-to-value mappings and supports get, set, and define operations
  - Variable declaration with var or let creates a new binding in the current scope's environment
  - Variable assignment updates the binding in the nearest enclosing scope where the name is defined
  - Nested scopes look up variables by walking the parent environment chain until the name is found
  - Accessing an undefined variable raises a clear runtime error with the variable name and source location
  pitfalls:
  - 'Scope restoration: after a block exits, the environment must revert to the parent'
  - 'Shadowing: a new binding in a nested scope should NOT mutate the outer scope''s binding'
  - 'Assignment vs declaration: assignment looks up existing binding; declaration always creates new'
  concepts:
  - Environments are hash maps mapping names to values
  - Environment chaining enables lexical scope lookups
  - Variable binding creates entries; assignment modifies existing entries
  skills:
  - Hash map implementation for environments
  - Scope chain management
  - Variable resolution and lookup
  - Handling undefined variables
  deliverables:
  - Environment class that maps variable names to their current runtime values
  - Nested scopes with a parent environment chain enabling lexical scope variable lookup
  - Variable declaration that binds a name to an initial value in the current environment
  - Variable assignment that finds and updates the binding in the correct scope
  - Undefined variable error handling that raises a clear runtime error with the variable name
  estimated_hours: 4
- id: ast-interpreter-m3
  name: Control Flow
  description: Implement if/else, loops, break, and continue.
  acceptance_criteria:
  - If/else statements correctly evaluate the condition and execute only the matching branch
  - While loops repeat the body as long as the condition evaluates to a truthy value
  - For loops execute the initializer once, check the condition each iteration, and run the increment
  - Break statement exits the nearest enclosing loop immediately
  - Continue statement skips to the next iteration of the nearest enclosing loop
  - Break and continue outside a loop are detected as runtime errors
  pitfalls:
  - 'Infinite loops: consider adding an iteration limit or timeout for safety'
  - 'Break outside loop: track loop depth and validate break/continue are inside a loop'
  - 'Truthiness rules: define clearly what values are truthy vs falsy (typically: nil and false are falsy)'
  concepts:
  - Control flow changes the sequential execution order
  - Loops repeat code based on a condition
  - Break and continue are control flow statements, not expressions
  skills:
  - Conditional branch evaluation
  - Loop iteration and termination
  - Break and continue statement handling
  - Boolean expression evaluation
  deliverables:
  - If/else statement execution that evaluates the condition and runs the appropriate branch
  - While loop execution with support for break and continue control flow statements
  - For loop desugaring or direct execution with initializer, condition, and increment
  - Return statement execution with value propagation back to the enclosing function call
  - Loop depth tracking for validating break and continue placement
  estimated_hours: 4
- id: ast-interpreter-m4
  name: Functions and Closures
  description: Implement function definitions, calls, and heap-allocated closures.
  acceptance_criteria:
  - Function declarations create a callable value stored in the current environment by name
  - Function calls bind each argument to the corresponding parameter in a new local environment
  - Return statements unwind execution and deliver the return value to the call site
  - Closures correctly capture and access variables from the enclosing scope even after it exits
  - Heap-allocated environments ensure closures survive after their defining function returns
  - Recursion works correctly—a function can call itself by name
  pitfalls:
  - 'Closure capture: the closure must capture the ENVIRONMENT at definition time, not call time'
  - 'Return from nested function: return must exit the current function, not just the inner block'
  - 'Argument count mismatch: decide how to handle too few or too many arguments (error vs default)'
  - 'Environment on stack: if environments are stack-allocated, closures will reference garbage after the defining function returns—MUST use heap allocation'
  concepts:
  - Functions are first-class values that can be stored, passed, and returned
  - Closures capture their lexical environment at definition time
  - Heap-allocated environments persist beyond their defining scope
  skills:
  - Function closure implementation
  - Call stack management
  - Parameter binding and argument passing
  - Return value propagation
  - Heap allocation for closures
  deliverables:
  - Function declaration that stores the function name, parameters, and body in the environment
  - Function call execution that binds arguments to parameters and evaluates the body in a new scope
  - Heap-allocated closure capture that preserves the enclosing environment at function definition time
  - Recursion support allowing a function to call itself by name within its own body
  - Return value propagation that delivers the result back to the call site
  estimated_hours: 4
domain: compilers
