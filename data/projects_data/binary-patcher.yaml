id: binary-patcher
name: Binary Instrumentation Tool
description: >-
  ELF binary patching with instruction-level modification, trampoline-based
  function hooking, code injection, and runtime patching via ptrace.
difficulty: advanced
estimated_hours: "35-50"
essence: >-
  Runtime and static manipulation of executable code through instruction-level
  patching with variable-length encoding awareness, trampoline-based control
  flow redirection with RIP-relative fixups, code cave utilization or segment
  extension for code injection, and ptrace-based live process patching with
  ASLR-aware address resolution.
why_important: >-
  Building this develops low-level systems programming expertise essential for
  security research, debugging tools, performance profilers, and dynamic
  analysis frameworks—foundational skills used in reverse engineering,
  vulnerability research, and production debugging tools like gdb and strace.
learning_outcomes:
  - Parse ELF file structures including section headers, program headers, symbol tables, and string tables
  - Implement instruction-level patching with variable-length encoding awareness and boundary detection
  - Design trampoline mechanisms that preserve register state, fix RIP-relative addressing, and redirect execution
  - Locate code caves or extend segments for injecting new code into existing binaries
  - Use ptrace to attach to running processes, resolve ASLR-randomized addresses, and patch code at runtime
  - Handle x86-64 calling conventions, stack alignment, and ABI requirements for cross-function hooking
  - Debug memory corruption and segmentation faults in binary manipulation code
skills:
  - ELF Binary Format
  - x86-64 Instruction Encoding
  - Instruction Boundary Detection
  - Process Memory Layout (ASLR)
  - ptrace System Calls
  - Trampoline Techniques
  - RIP-Relative Address Fixup
  - Code Cave Detection
tags:
  - advanced
  - binary-patching
  - elf
  - reverse-engineering
  - security
  - x86-64
architecture_doc: architecture-docs/binary-patcher/index.md
languages:
  recommended:
    - C
    - Rust
  also_possible:
    - C++
resources:
  - name: ELF Specification
    url: https://refspecs.linuxfoundation.org/elf/elf.pdf
    type: specification
  - name: Intel x86-64 Instruction Reference
    url: https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html
    type: reference
  - name: ptrace Man Page
    url: https://man7.org/linux/man-pages/man2/ptrace.2.html
    type: documentation
  - name: tmpout ELF resources
    url: https://tmpout.sh/
    type: reference
prerequisites:
  - type: project
    name: elf-parser
  - type: project
    name: disassembler
  - type: skill
    name: x86-64 assembly reading/writing
  - type: skill
    name: ELF binary format structure
milestones:
  - id: binary-patcher-m1
    name: Instruction-Level Patching with Boundary Detection
    description: >-
      Parse ELF binaries, detect instruction boundaries in .text section,
      and patch individual instructions at specified offsets while maintaining
      binary integrity.
    acceptance_criteria:
      - "Load ELF file and parse section headers to locate .text section with executable code"
      - "Implement instruction length decoder for x86-64 variable-length instructions (1-15 bytes)"
      - "Detect instruction boundaries at and around the patch target offset"
      - "Replace instruction at given offset with new instruction of same or smaller size, padding with NOP (0x90) if smaller"
      - "If replacement instruction is LARGER than original, detect and relocate partially-overwritten subsequent instructions"
      - "Maintain ELF structural integrity after patching: section sizes, header offsets, and checksums remain valid"
      - "Produce patched binary that executes correctly with modified behavior (verified by running and comparing output)"
      - "Support patching by symbol name (look up function address in .symtab/.dynsym) in addition to raw offset"
    pitfalls:
      - "x86-64 has variable-length instructions (1-15 bytes); you CANNOT patch at arbitrary byte offsets, only at instruction boundaries"
      - "Overwriting an instruction with a longer replacement corrupts the next instruction; must handle overflow"
      - "NOP padding (0x90) is safe for x86-64 but multi-byte NOPs (0x0F 0x1F...) are preferred for performance"
      - "Modifying .text section size is dangerous; prefer same-size or smaller replacements"
      - "Stripped binaries have no .symtab; must fall back to .dynsym or raw offsets"
      - "ELF checksum fields (e_shstrndx, sh_size) must be updated if section boundaries change"
    concepts:
      - x86-64 variable-length instruction encoding
      - Instruction boundary detection (length disassembly)
      - NOP padding for instruction size mismatches
      - ELF section and symbol resolution
    skills:
      - ELF binary parsing and section navigation
      - x86-64 instruction length decoding
      - Binary file writing with structural integrity
      - Symbol table lookup
    deliverables:
      - ELF loader parsing headers, sections, and symbol tables
      - x86-64 instruction length decoder for boundary detection
      - Instruction patcher replacing code at offsets with size-aware padding
      - Symbol-to-offset resolver for named patching targets
      - Binary writer producing valid patched ELF
      - Test suite with before/after execution verification
    estimated_hours: "8-12"

  - id: binary-patcher-m2
    name: Function Hooking with Trampolines
    description: >-
      Implement trampoline-based function interception that preserves
      register state, fixes RIP-relative instructions, and supports
      both near and far jumps.
    acceptance_criteria:
      - "Detect function entry points from ELF symbol table (.symtab or .dynsym)"
      - "Determine minimum number of instruction bytes to overwrite for a JMP (5 bytes for near E9, 14 bytes for far JMP via register)"
      - "Copy and relocate the overwritten prologue instructions to the trampoline"
      - "Fix all RIP-relative operands in relocated instructions (adjust displacement for new address)"
      - "Trampoline structure: save all registers (pushaq equivalent) → call hook function → restore registers → execute relocated prologue → jump back to original function body"
      - "Hook function receives original function arguments per System V AMD64 ABI (rdi, rsi, rdx, rcx, r8, r9)"
      - "Handle near JMP (E9, ±2GB range) and fall back to far JMP (movabs + jmp reg) for distant trampolines"
      - "Demonstrate working hook that logs function calls with arguments then continues to original function"
      - "Hooked binary executes correctly (same output as unhooked) except for added hook side effects"
    pitfalls:
      - "Near JMP (E9) has ±2GB range on x86-64; if trampoline is further, must use 14-byte indirect jump (movabs rax, addr; jmp rax)"
      - "MUST save and restore ALL registers including flags (pushfq) in trampoline; any corruption causes unpredictable crashes"
      - "Relocated prologue instructions with RIP-relative addressing (very common in x86-64) need displacement recalculation"
      - "Stack must remain 16-byte aligned before calling hook function (System V ABI requirement)"
      - "Short functions (less than 5 bytes) cannot be hooked with standard trampoline technique"
      - "Indirect jumps through data (jmp [rip+offset]) need both the instruction AND the pointed-to data relocated"
    concepts:
      - Trampoline-based function hooking
      - RIP-relative addressing fixups
      - Near vs far jump encoding on x86-64
      - Calling convention preservation (System V AMD64 ABI)
    skills:
      - x86-64 assembly code generation
      - Register preservation and stack alignment
      - RIP-relative displacement recalculation
      - Function prologue analysis
    deliverables:
      - Function entry point detection from symbol table
      - Trampoline code generator with register save/restore and flag preservation
      - Prologue instruction relocation with RIP-relative fixup
      - Near and far JMP insertion at function entry
      - Hook function interface receiving original arguments
      - End-to-end demo: hooked binary logging function calls
    estimated_hours: "8-14"

  - id: binary-patcher-m3
    name: Code Injection via Code Caves & Segment Extension
    description: >-
      Inject new executable code into ELF binaries by finding code caves
      or extending existing segments, with proper header updates.
    acceptance_criteria:
      - "Scan ELF for code caves: unused padding between sections within existing LOAD segments (typically between .text and next section)"
      - "Report code cave locations with available size for each candidate"
      - "For small injections (< cave size): write hook code into code cave, update no headers"
      - "For larger injections: extend last PT_LOAD segment by increasing p_filesz and p_memsz, append code at end of file"
      - "Update section headers if adding a new section (.inject) to describe the injected code region"
      - "Set proper permissions on injected region (PF_R | PF_X for executable code)"
      - "Injected code can reference symbols from original binary by resolving addresses from symbol table"
      - "Support injecting pre-compiled position-independent code (PIC) object files"
      - "Patched binary with injected code loads and executes correctly (verified by readelf and execution)"
    pitfalls:
      - "Code caves are often small (0-4096 bytes); may not be enough for complex hooks"
      - "Extending a segment changes file layout; all subsequent section offsets must be updated"
      - "Adding a new PT_LOAD segment may require expanding the program header table, which shifts EVERYTHING"
      - "Injected code MUST be position-independent (compiled with -fPIC -fno-plt) or relocated to its actual load address"
      - "Some loaders reject ELFs with overlapping segments or non-page-aligned segment boundaries"
      - "File-backed segments must be aligned to page size (typically 4096 bytes) for mmap()"
    concepts:
      - Code cave detection and utilization
      - ELF segment extension for code injection
      - Position-independent code requirements
      - ELF header consistency after modification
    skills:
      - ELF program header and section header manipulation
      - Code cave scanning and size analysis
      - Segment boundary and alignment management
      - PIC compilation and injection
    deliverables:
      - Code cave scanner finding unused space in existing LOAD segments
      - Code cave injector writing PIC code into available padding
      - Segment extender appending code by growing last PT_LOAD segment
      - Header updater maintaining ELF consistency after injection
      - Symbol resolver enabling injected code to call original binary functions
      - Validation: readelf shows valid structure; binary executes correctly
    estimated_hours: "8-12"

  - id: binary-patcher-m4
    name: Runtime Patching via ptrace with ASLR
    description: >-
      Patch running processes using ptrace with ASLR-aware address resolution,
      memory protection handling, and multi-thread awareness.
    acceptance_criteria:
      - "Attach to running process using PTRACE_ATTACH; handle permission errors (must be same user or root)"
      - "Parse /proc/pid/maps to determine ASLR-randomized base addresses of all loaded segments"
      - "Resolve symbol addresses by adding ASLR slide (actual base - ELF base) to symbol table offsets"
      - "Read process memory using PTRACE_PEEKDATA (word-at-a-time) or process_vm_readv (bulk)"
      - "Write modified code using PTRACE_POKEDATA (word-at-a-time) or process_vm_writev (bulk)"
      - "Handle read-only code pages: inject mprotect() syscall into target process to make pages writable, then patch, then restore permissions"
      - "Inject trampoline into running process's code at ASLR-resolved function entry points"
      - "If target is multi-threaded, stop ALL threads before patching (enumerate via /proc/pid/task/)"
      - "Flush instruction cache after code modification (on x86-64 this is typically automatic, but verify)"
      - "Detach cleanly using PTRACE_DETACH leaving process running with hooks active and all threads resumed"
      - "Demonstrate: attach to running process, install function hook, observe hook logging, detach"
    pitfalls:
      - "ASLR randomizes base address on every execution; MUST read /proc/pid/maps to find actual addresses"
      - "PTRACE_PEEKDATA and PTRACE_POKEDATA operate on word-sized (8 byte) units; must read-modify-write for smaller patches"
      - "Code pages are typically mapped read-execute (no write); must change protection via injected mprotect syscall"
      - "Injecting a syscall requires: save registers → write syscall instructions → single-step → restore registers and original code"
      - "Process is STOPPED during ptrace operations; minimize attach duration to reduce disruption"
      - "Multi-threaded targets: patching while other threads execute the same code causes crashes; stop ALL threads first"
      - "On x86-64, instruction cache coherency is maintained by hardware; on ARM, explicit cache flush (cacheflush syscall) is required"
    concepts:
      - ASLR and /proc/pid/maps for address resolution
      - ptrace word-at-a-time memory access
      - Memory protection manipulation via injected syscall
      - Multi-thread synchronization during patching
    skills:
      - ptrace API for process control and memory access
      - ASLR-aware address calculation from /proc/pid/maps
      - Syscall injection technique for mprotect
      - Thread enumeration and synchronization
    deliverables:
      - Process attachment with permission handling
      - ASLR resolver parsing /proc/pid/maps and computing address slides
      - Memory read/write using ptrace PEEK/POKE or process_vm_readv/writev
      - Memory protection handler injecting mprotect syscall into target
      - Runtime trampoline injection at ASLR-resolved addresses
      - Multi-thread stopper enumerating and stopping all target threads
      - Clean detach protocol resuming all threads with hooks active
    estimated_hours: "10-14"