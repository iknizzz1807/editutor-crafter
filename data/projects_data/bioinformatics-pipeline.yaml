id: bioinformatics-pipeline
name: Bioinformatics Pipeline
description: >
  Build computational biology tools for DNA/RNA sequence analysis,
  including sequence alignment, genome assembly fundamentals, and
  protein structure prediction basics.

difficulty: advanced
estimated_hours: 50-70
domain: specialized

essence: >
  String algorithms optimized for biological sequences, dynamic programming
  for optimal alignment, statistical models for sequence similarity scoring,
  and understanding the biological constraints that shape algorithm design
  in genomics and proteomics.

why_important: >
  Computational biology is a high-impact field driving drug discovery,
  personalized medicine, and biotechnology. Bioinformatics engineers earn
  $120K-250K+ at biotech companies, research institutions, and pharma.

learning_outcomes:
  - Implement exact string matching algorithms (KMP, Boyer-Moore)
  - Build pairwise sequence alignment with dynamic programming (Needleman-Wunsch, Smith-Waterman)
  - Implement BLAST-style heuristic alignment for database search
  - Build multiple sequence alignment algorithms
  - Parse standard bioinformatics file formats (FASTA, FASTQ, VCF)
  - Implement k-mer counting and analysis
  - Build basic hidden Markov models for sequence analysis
  - Understand scoring matrices (BLOSUM, PAM)

skills:
  - Sequence Alignment
  - Dynamic Programming
  - String Algorithms
  - Bioinformatics File Formats
  - Statistical Scoring
  - HMM Implementation
  - K-mer Analysis
  - Biological Domain Knowledge

tags:
  - advanced
  - alignment
  - bioinformatics
  - biology
  - computational-biology
  - genomics
  - sequences
  - string-algorithms

languages:
  recommended:
    - Python
    - C++
    - Rust
  also_possible:
    - Java
    - Go

resources:
  - name: "Bioinformatics Algorithms (Compeau & Pevzner)"
    url: https://www.bioinformaticsalgorithms.org/
    type: book
  - name: "Biological Sequence Analysis (Durbin et al.)"
    url: https://www.cambridge.org/core/books/biological-sequence-analysis/
    type: book
  - name: "Rosalind Problems"
    url: http://rosalind.info/problems/locations/
    type: practice
  - name: "NCBI BLAST Documentation"
    url: https://www.ncbi.nlm.nih.gov/books/NBK62345/
    type: documentation

prerequisites:
  - type: skill
    name: Dynamic programming fundamentals
  - type: skill
    name: String algorithms and pattern matching
  - type: skill
    name: Basic statistics and probability
  - type: skill
    name: Understanding of DNA/RNA/protein basics

milestones:
  - id: bioinformatics-pipeline-m1
    name: Sequence File I/O & Basic Operations
    description: >
      Implement parsers for standard bioinformatics file formats and
      basic sequence manipulation operations.
    acceptance_criteria:
      - FASTA parser correctly handles multi-sequence files with varying line lengths
      - FASTQ parser correctly parses sequences with quality scores
      - Handles edge cases: empty files, very long single-line sequences, whitespace variations
      - Reverse complement function correctly transforms DNA sequences
      - GC content calculation for DNA sequences
      - Translation function converts DNA codons to amino acids using standard genetic code
      - File streaming support for files too large to fit in memory
    pitfalls:
      - FASTQ quality scores use ASCII encoding; offset varies (Phred+33 vs Phred+64)
      - DNA sequences may contain ambiguous bases (N, R, Y, etc.) beyond ACGT
      - Case sensitivity in sequence data; some tools use lowercase for soft-masked regions
      - Line wrapping in FASTA is arbitrary; don't assume fixed line length
      - Quality scores can contain special characters that confuse naive parsers
    concepts:
      - FASTA and FASTQ file formats
      - DNA/RNA representation and complement
      - Quality score encoding
      - Genetic code and translation
    skills:
      - Bioinformatics file parsing
      - Sequence manipulation
      - Streaming I/O for large files
      - Edge case handling
    deliverables:
      - FASTA/FASTQ parser with streaming support
      - Reverse complement function
      - GC content calculator
      - DNA to protein translation
      - Unit tests with real sample data
    estimated_hours: "8-10"

  - id: bioinformatics-pipeline-m2
    name: Pairwise Sequence Alignment
    description: >
      Implement optimal pairwise alignment algorithms using dynamic
      programming for global and local alignment.
    acceptance_criteria:
      - Needleman-Wunsch algorithm for global alignment with configurable scoring (match, mismatch, gap)
      - Smith-Waterman algorithm for local alignment
      - Affine gap penalty support: gap opening cost separate from gap extension cost
      - Backtracking to reconstruct the optimal alignment
      - Alignment visualization showing matches, mismatches, and gaps
      - Performance optimized using banded alignment when approximate match location is known
      - Handles sequences up to 10,000 bases in reasonable time (< 10 seconds)
    pitfalls:
      - O(n*m) space for full DP matrix; use linear-space variant (Hirschberg) for long sequences
      - Affine gap scoring requires three DP matrices (match, insert, delete), not one
      - Backtracking ties (multiple optimal paths) must be handled consistently
      - Integer overflow with large sequences and high scores; use appropriate types
      - Banded alignment can miss optimal alignment if band is too narrow
    concepts:
      - Dynamic programming for alignment
      - Global vs local alignment
      - Affine gap penalties
      - Space-time trade-offs in DP
    skills:
      - DP algorithm implementation
      - Affine gap handling
      - Alignment visualization
      - Performance optimization
    deliverables:
      - Needleman-Wunsch global aligner
      - Smith-Waterman local aligner
      - Affine gap penalty support
      - Alignment visualization output
      - Banded alignment optimization
    estimated_hours: "12-14"

  - id: bioinformatics-pipeline-m3
    name: Heuristic Database Search
    description: >
      Implement BLAST-style heuristic alignment for searching
      sequence databases efficiently.
    acceptance_criteria:
      - K-mer indexing builds lookup table of short word positions
      - Seed-and-extend: find matching k-mers, then extend alignments
      - Word hit list is generated quickly (O(n) scan of query vs index lookup)
      - Ungapped extension identifies high-scoring segment pairs (HSPs)
      - Gapped extension refines HSPs into final alignments
      - E-value calculation estimates statistical significance of matches
      - Database search completes in < 1 second for 1MB database, 1000bp query
    pitfalls:
      - K-mer size trade-off: small k gives many seeds (slow), large k misses matches
      - E-value calculation requires accurate statistical parameters; use published values
      - Low-complexity regions (e.g., AAAAA) cause spurious hits; filtering is needed
      - Memory usage for index scales with database size; external memory may be needed
      - Extension step dominates runtime; early termination for low-scoring extensions
    concepts:
      - Seed-and-extend paradigm
      - K-mer indexing and lookup
      - Statistical significance (E-value)
      - Heuristic vs optimal alignment
    skills:
      - Index data structure design
      - Heuristic algorithm implementation
      - Statistical calculation
      - Performance optimization
    deliverables:
      - K-mer index builder
      - Seed-and-extend search algorithm
      - HSP identification and scoring
      - E-value calculation
      - Database search tool
    estimated_hours: "12-14"

  - id: bioinformatics-pipeline-m4
    name: K-mer Analysis & Multiple Alignment
    description: >
      Implement k-mer counting and analysis, plus progressive
      multiple sequence alignment.
    acceptance_criteria:
      - K-mer counter efficiently counts all k-mers in a sequence (k up to 31)
      - Uses efficient data structure (hash table or suffix array) for counting
      - Handles large sequences (whole bacterial genome) with memory efficiency
      - K-mer frequency spectrum analysis identifies unique vs repeated sequences
      - Progressive multiple alignment using pairwise alignments and guide tree
      - Simple guide tree construction using pairwise distance matrix
      - Alignment includes position conservation scoring
    pitfalls:
      - K-mer counting with naive hash table uses excessive memory; use counting Bloom filter or minimizers
      - Canonical k-mers (lexicographically smaller of forward/reverse complement) reduce space by half
      - Progressive alignment order affects result; guide tree quality matters
      - Gap placement in multiple alignment is complex; simple approaches may produce poor alignments
      - Reversing complement k-mers for palindromic sequences
    concepts:
      - K-mer spectrum analysis
      - Memory-efficient counting
      - Progressive alignment strategy
      - Guide tree construction
    skills:
      - Efficient k-mer counting
      - Frequency analysis
      - Multiple alignment algorithms
      - Distance-based clustering
    deliverables:
      - Memory-efficient k-mer counter
      - K-mer frequency spectrum analyzer
      - Progressive multiple aligner
      - Guide tree builder
      - Conservation scoring
    estimated_hours: "10-12"

  - id: bioinformatics-pipeline-m5
    name: Hidden Markov Models for Sequences
    description: >
      Implement HMM-based sequence analysis for profile matching
      and gene finding applications.
    acceptance_criteria:
      - Generic HMM implementation with forward-backward algorithm
      - Viterbi algorithm finds most likely state path (annotation)
      - Baum-Welch algorithm for parameter estimation (training)
      - Profile HMM for protein family modeling
      - CpG island detector using simple HMM
      - Log-probability space used to avoid numerical underflow
      - Model training converges on test data
    pitfalls:
      - Probability underflow in forward-backward; use log-space or scaling
      - Baum-Welch can converge to local optima; multiple random restarts help
      - Viterbi path vs posterior decoding: different for uncertain annotations
      - Profile HMM architecture must handle insertions and deletions
      - Training data quality limits model quality; garbage in, garbage out
    concepts:
      - Hidden Markov Model fundamentals
      - Forward-backward algorithm
      - Viterbi decoding
      - Baum-Welch training
    skills:
      - HMM implementation
      - Dynamic programming for HMMs
      - Log-space numerical methods
      - Profile modeling
    deliverables:
      - Generic HMM class with forward-backward
      - Viterbi decoder
      - Baum-Welch training
      - Profile HMM for sequence families
      - CpG island detector application
    estimated_hours: "10-12"
