id: btree-impl
name: B-tree Implementation
description: Implement a disk-oriented B-tree with insert, search, delete, and range scan operations. Nodes are serialized to fixed-size pages on disk with a buffer pool for caching. Supports configurable minimum degree and duplicate key policy.
difficulty: intermediate
estimated_hours: 20-35
essence: Multi-way search tree with variable-key nodes and minimum degree constraints, maintaining balance through algorithmic splitting during insertion and key redistribution or merging during deletion to guarantee logarithmic height. Nodes map to fixed-size disk pages to minimize I/O operations for database index workloads.
why_important: B-trees are the foundation of database indexes and file systems (PostgreSQL, MySQL, SQLite, NTFS, APFS). Building one teaches you how to design data structures that bridge the performance gap between fast RAM and slow disk storage, and how databases achieve O(log n) lookups on billions of rows.
learning_outcomes:
- Implement multi-way tree nodes with variable key counts and child pointers
- Design disk-page-oriented node layout with serialization and deserialization
- Build search algorithms that traverse multi-level tree structures
- Implement node splitting logic to maintain B-tree balance during insertions
- Handle complex deletion cases with key borrowing, merging, and root shrinking
- Implement range scans using in-order traversal or leaf-level iteration
- Handle duplicate keys with a defined policy (reject, allow, or append to overflow)
- Debug tree invariants and validate B-tree properties after every operation
- Optimize memory layout for cache efficiency and disk block alignment
skills:
- Self-balancing Trees
- Disk I/O Optimization
- Page-oriented Data Structures
- Tree Invariant Verification
- Memory Layout Design
- Algorithm Complexity Analysis
- Serialization and Deserialization
tags:
- balanced-tree
- c
- data-structures
- databases
- disk-based
- implementation
- intermediate
- python
- range-queries
- rust
architecture_doc: architecture-docs/btree-impl/index.md
languages:
  recommended:
  - C
  - Rust
  - Python
  also_possible:
  - Go
  - Java
resources:
- name: B-tree Wikipedia
  url: https://en.wikipedia.org/wiki/B-tree
  type: article
- name: B-tree Visualization
  url: https://www.cs.usfca.edu/~galles/visualization/BTree.html
  type: tool
- name: CMU Database Systems - Tree Indexes
  url: https://15445.courses.cs.cmu.edu/
  type: course
- name: 'Introduction to Algorithms (CLRS) - Chapter 18: B-Trees'
  url: https://mitpress.mit.edu/9780262046305/introduction-to-algorithms/
  type: book
prerequisites:
- type: skill
  name: Binary search trees and tree traversal
- type: skill
  name: Algorithm complexity (Big-O notation)
- type: skill
  name: Basic file I/O (read, write, seek)
milestones:
- id: btree-impl-m1
  name: Node Structure & Page Serialization
  description: Define the B-tree node structure with configurable minimum degree t, and implement serialization/deserialization of nodes to fixed-size disk pages. Define the duplicate key policy.
  estimated_hours: 4-6
  concepts:
  - B-tree properties (minimum degree t, key count bounds)
  - Fixed-size page layout for disk storage
  - Node serialization to binary format
  - Duplicate key handling policy
  skills:
  - Struct design and memory layout
  - Binary serialization/deserialization
  - File I/O (read, write, seek)
  - Page-oriented data structure design
  acceptance_criteria:
  - Each node holds at most 2t-1 keys and at least t-1 keys (except root which may have 1 to 2t-1 keys)
  - Each internal node has exactly (number_of_keys + 1) child pointers
  - Keys within every node are maintained in sorted ascending order
  - Leaf indicator flag correctly differentiates leaf nodes from internal nodes
  - Nodes are serialized to a fixed-size page (e.g., 4096 bytes) with a defined binary layout containing header (leaf flag, key count), keys array, values array, and child page IDs
  - Nodes are deserialized from disk pages back to in-memory structures with byte-perfect round-trip fidelity
  - Duplicate key policy is configurable — at minimum, support REJECT_DUPLICATE mode that returns an error on duplicate insert
  - 'Page file has a header page (page 0) storing metadata: root page ID, minimum degree t, page count, and free page list head'
  pitfalls:
  - Off-by-one in maximum key capacity (2t-1, not 2t) is the most common bug
  - Fixed-size pages waste space for small t values; choose page size and t so that max node size fits exactly in one page
  - Child pointers on disk are page IDs (integers), not memory pointers; confusing them causes segfaults or corruption
  - Forgetting to persist the file header after metadata changes (e.g., new root page ID) corrupts the tree on restart
  - Not tracking free/reusable pages leads to unbounded file growth after deletions
  deliverables:
  - Node structure with sorted keys array, values array, child page ID array, and leaf flag
  - Configurable minimum degree t with derived max/min key capacity
  - Binary serialization of node to fixed-size page bytes
  - Binary deserialization of page bytes back to node structure
  - File header page storing root page ID, tree metadata, and free page list
  - Simple page allocator returning new page IDs and tracking free pages
- id: btree-impl-m2
  name: Search & Range Scan
  description: Implement point search and range scan operations, reading nodes from disk pages. Verify O(log_t n) page reads for point lookups.
  estimated_hours: 3-5
  concepts:
  - Binary search within sorted node keys
  - Recursive tree descent
  - Range scan via in-order traversal
  - Page read counting for I/O cost analysis
  skills:
  - Binary search implementation
  - Recursive tree traversal
  - In-order traversal for range queries
  - I/O operation counting
  acceptance_criteria:
  - Point search uses binary search within each node's key array to find the target key or the correct child pointer in O(log t) comparisons per node
  - Search descends at most O(log_t n) levels, reading one page per level from disk
  - Search returns the associated value when the key exists, or a definitive not-found indicator when absent
  - Range scan returns all keys in [low, high] in sorted order by performing in-order traversal bounded by the range endpoints
  - Range scan reads only the pages necessary to cover the range, not the entire tree
  - Page read counter confirms point search reads at most ceil(log_t(n)) + 1 pages for a tree with n keys
  pitfalls:
  - Binary search boundary conditions — use lower_bound semantics to find the first key >= target
  - Range scan must handle the case where low and high span multiple subtrees at the same level
  - Forgetting to check leaf status before attempting to descend to children causes null pointer access
  - Range scan on an empty tree must return empty result, not error
  deliverables:
  - Point search function with binary search within nodes and recursive descent
  - Range scan function returning all key-value pairs in [low, high] sorted order
  - Page read counter tracking disk I/O operations per query
  - Test suite verifying correctness on trees with 1, t, 2t, and 10000+ keys
- id: btree-impl-m3
  name: Insert with Proactive Split
  description: Implement insertion with proactive node splitting during descent. Handle root splits that increase tree height. Persist all modified pages to disk.
  estimated_hours: 5-8
  concepts:
  - Proactive (preemptive) node splitting during descent
  - Median key promotion to parent
  - Root split creating new root node
  - Write-back of modified pages to disk
  skills:
  - Dynamic page allocation for new nodes
  - Array element shifting for sorted insertion
  - Parent-child page ID updates
  - Root pointer reassignment in file header
  acceptance_criteria:
  - Insertion into a non-full leaf places the key in sorted position without structural changes
  - Full nodes (2t-1 keys) are split proactively during descent, BEFORE reaching the insertion leaf
  - Split promotes the median key to the parent and creates a new sibling node with the upper t-1 keys
  - Splitting the root creates a new root page with one key and two children, increasing tree height by one; file header is updated with new root page ID
  - After every insertion, all modified pages (split nodes, parent, new root) are written back to disk
  - Duplicate key insertion is handled according to the configured policy (reject with error in REJECT_DUPLICATE mode)
  - Sorted order invariant holds across all nodes after every insertion (verified by invariant checker)
  - Inserting n=10000 random keys produces a valid B-tree verifiable by full invariant check
  pitfalls:
  - Split must move t-1 keys to the new node and promote 1 median key; moving t keys is a common off-by-one
  - After splitting a child, the parent's child array must be shifted right to insert the new child pointer at the correct position
  - Proactive split means the root is split before descending, not after insertion fails — bottom-up splitting is more complex and error-prone
  - Forgetting to update the file header when root splits causes the old root to be used on restart, corrupting the tree
  - 'Disk writes must be ordered: new child page written before parent page, otherwise crash between writes orphans the new page'
  deliverables:
  - Sorted insertion into non-full leaf node
  - Proactive node split during descent, including median promotion and sibling creation
  - Root split handler creating new root and updating file header
  - Modified page write-back to disk after every structural change
  - Invariant checker verifying sorted order, key count bounds, and child count after each insert
- id: btree-impl-m4
  name: Delete with Borrowing, Merging & Root Shrinking
  description: 'Implement deletion handling all cases: leaf deletion, internal node deletion (predecessor/successor swap), sibling borrowing (rotation), node merging, and root shrinking.'
  estimated_hours: 6-10
  concepts:
  - Deletion from leaf vs internal node
  - In-order predecessor/successor replacement
  - Sibling borrowing (key rotation through parent)
  - Node merging with parent separator key
  - Root shrinking when root becomes empty
  - Preemptive rebalancing during descent
  skills:
  - Conditional rebalancing strategy selection
  - Sibling node access and key redistribution
  - Recursive deletion with structural propagation
  - Edge case handling for tree height reduction
  acceptance_criteria:
  - Deleting a key from a leaf with more than t-1 keys removes it without restructuring
  - Deleting a key from an internal node replaces it with its in-order predecessor (or successor) and recursively deletes the predecessor from its leaf
  - When a node underflows (fewer than t-1 keys after deletion), borrowing rotates a key from an adjacent sibling through the parent if the sibling has more than t-1 keys
  - When borrowing is not possible (both siblings have exactly t-1 keys), merging combines the underflowing node, a sibling, and their shared parent separator key into one node
  - When the root has zero keys and one child after a merge, the child becomes the new root and tree height decreases by one; file header is updated
  - Preemptive rebalancing during descent ensures every visited node (except root) has at least t keys before descending, so deletion never requires backtracking
  - 'All invariants hold after every deletion: sorted keys, key count bounds, correct child counts, all leaves at same depth'
  - Delete of non-existent key returns not-found without modifying the tree
  - 'Stress test: insert 10000 keys, delete all 10000 in random order, verify tree is empty and file header reflects empty state'
  pitfalls:
  - Merge vs borrow decision depends on sibling key count, not the underflowing node — checking the wrong node selects the wrong strategy
  - When merging, the parent's separator key must be included in the merged node; forgetting it loses a key silently
  - Root shrinking must handle the case where the tree becomes completely empty (root is a leaf with zero keys)
  - Preemptive rebalancing during descent is the CLRS approach; without it, you need complex bottom-up fix-up which is harder to implement correctly
  - After merging, the parent loses one key and one child pointer; parent array shifting must be correct or subsequent operations corrupt the tree
  - Deleting from an internal node where both children have exactly t-1 keys requires merging before swapping — this is the hardest case
  deliverables:
  - Leaf deletion removing key and shifting remaining keys
  - Internal node deletion with predecessor/successor swap and recursive leaf deletion
  - Sibling borrowing (left and right rotation) through parent separator key
  - Node merging combining sibling, separator key, and underflowing node
  - Root shrinking when root becomes empty, updating file header
  - Preemptive rebalancing during descent ensuring every visited non-root node has >= t keys
  - Full invariant verification suite (sorted order, key count bounds, uniform leaf depth, child count consistency)
  - Stress test inserting and deleting 10K+ keys in random order
domain: data-storage
