id: build-allocator
name: "Build Your Own Memory Allocator"
description: "malloc/free/realloc implementation with boundary tags, segregated free lists, and thread safety"
difficulty: expert
estimated_hours: "40-60"
essence: >
  Heap memory expansion through sbrk/mmap system calls, free block management
  with boundary tags (header + footer) enabling O(1) bidirectional coalescing,
  segregated free lists with size-class bucketing for efficient allocation,
  and per-thread arenas for lock-free fast-path allocation under concurrent access.
why_important: >
  Building a memory allocator exposes you to fundamental OS-level concepts that
  underpin all high-level programming, teaching you how systems balance performance,
  fragmentation, and concurrency trade-offs that affect every production application.
learning_outcomes:
  - Implement heap expansion using sbrk and mmap system calls
  - Design block headers and footers (boundary tags) for O(1) coalescing
  - Build segregated free lists with size-class bucketing
  - Implement realloc with in-place growth optimization
  - Debug memory corruption (double-free, buffer overflow) with canaries
  - Implement thread-safe allocation with per-thread arenas
  - Measure fragmentation, throughput, and utilization metrics
  - Test via LD_PRELOAD replacing libc malloc in real programs
skills:
  - Systems Programming
  - Memory Management
  - Data Structure Design (free lists, bitmaps)
  - Concurrency Control
  - Performance Optimization
  - Low-Level Debugging
  - Heap Fragmentation Analysis
  - System Calls (sbrk, mmap, munmap)
tags:
  - build-from-scratch
  - c
  - expert
  - fragmentation
  - free-list
  - malloc
  - memory-management
  - rust
  - systems
  - zig
architecture_doc: architecture-docs/build-allocator/index.md
languages:
  recommended:
    - C
    - Zig
  also_possible:
    - Rust
resources:
  - type: article
    name: "Implementing malloc (IIT slides)"
    url: "https://moss.cs.iit.edu/cs351/slides/slides-malloc.pdf"
  - type: article
    name: "Writing a Memory Allocator"
    url: "http://dmitrysoshnikov.com/compilers/writing-a-memory-allocator/"
  - type: book
    name: "CSAPP Chapter 9 - Dynamic Memory Allocation"
    url: "https://csapp.cs.cmu.edu/"
  - type: article
    name: "A look at how malloc works on the Mac (jemalloc concepts)"
    url: "https://www.cocoawithlove.com/2010/05/look-at-how-malloc-works-on-mac.html"
prerequisites:
  - type: skill
    name: "C programming (pointers, casting, sizeof)"
  - type: skill
    name: "Memory layout (stack, heap, data, text segments)"
  - type: skill
    name: "Data structures (linked lists)"
  - type: skill
    name: "System calls (sbrk, mmap basics)"
milestones:
  - id: build-allocator-m1
    name: "Basic Allocator with sbrk and Boundary Tags"
    description: >
      Implement a simple heap allocator using sbrk with block headers AND footers
      (boundary tags) for proper alignment and future coalescing support.
    acceptance_criteria:
      - "Allocator extends heap via sbrk() when free memory is insufficient; handles sbrk failure (-1) gracefully by returning NULL"
      - "Block header stores: size (including header+footer overhead), allocated/free flag; block footer duplicates size and flag for backward traversal"
      - "malloc returns memory aligned to at least 16 bytes (alignof(max_align_t) on x86-64); verified by checking (uintptr_t)ptr % 16 == 0"
      - "Minimum allocation size accounts for header + footer + alignment padding; requests smaller than minimum are rounded up"
      - "free() marks the block as free by clearing the allocated flag in both header and footer"
      - "First-fit allocation scans from heap start and returns the first free block large enough to satisfy the request"
      - "sbrk is called to extend the heap only when no existing free block is large enough"
      - "Allocator handles the zero-size edge case: malloc(0) returns NULL or a minimal unique pointer (implementation-defined)"
    pitfalls:
      - "Alignment to 16 bytes, not 8; SSE instructions and C standard require 16-byte alignment on x86-64 for max_align_t"
      - "Forgetting footer means backward coalescing is impossible later; build it in from the start"
      - "sbrk is not thread-safe; in M1 this is acceptable but must be addressed in M4"
      - "Header/footer overhead: each block costs 2×sizeof(size_t) + padding; very small allocations have high overhead ratio"
      - "Not handling sbrk failure; in production, sbrk can fail if address space is exhausted"
    concepts:
      - Heap management with sbrk
      - Boundary tags (header + footer)
      - Memory alignment requirements
      - First-fit allocation
    skills:
      - Pointer arithmetic
      - System call interfaces
      - Memory layout design
    deliverables:
      - sbrk wrapper for heap extension
      - Block structure with header and footer (boundary tags)
      - 16-byte aligned malloc returning usable pointer after header
      - free marking block as available (header + footer update)
      - First-fit free block scanner
      - Heap initialization on first malloc call
    estimated_hours: "8-12"

  - id: build-allocator-m2
    name: "Free List, Splitting, and Coalescing"
    description: >
      Implement an explicit free list with block splitting and bidirectional
      coalescing using boundary tags.
    acceptance_criteria:
      - "Explicit free list links free blocks using next/prev pointers embedded in the free block's payload area (no extra memory cost)"
      - "Block splitting: when a free block is significantly larger than the request (remaining ≥ minimum block size), split it into an allocated portion and a new free remainder"
      - "Immediate coalescing on free(): check the adjacent block AFTER (using header + size arithmetic) and the adjacent block BEFORE (using previous block's footer) and merge all contiguous free blocks into one"
      - "Boundary tags enable O(1) backward coalescing: the footer of the previous block is at (current_header - sizeof(footer)), giving its size and free status"
      - "First-fit, best-fit, and next-fit strategies are implemented and selectable; next-fit starts scanning from the last allocation point (roving pointer)"
      - "Fragmentation metric: utilization = sum(payload_sizes) / total_heap_size; measured after a sequence of malloc/free operations"
      - "A test harness runs a sequence of mixed malloc/free calls and verifies: no overlapping allocations, all freed memory is reclaimable, coalescing reduces fragmentation"
    pitfalls:
      - "Corrupting free list pointers during coalescing; when merging blocks, the combined block must be correctly inserted into the free list and the absorbed block removed"
      - "Splitting a block too small to hold header+footer+min_payload creates an unusable fragment; enforce minimum block size"
      - "Next-fit can degenerate to worst-fit if the roving pointer always lands on large blocks"
      - "Not coalescing on every free causes fragmentation to grow unboundedly over time"
    concepts:
      - Explicit free lists
      - Block splitting and minimum size
      - Bidirectional coalescing with boundary tags
      - Allocation strategies (first-fit, best-fit, next-fit)
    skills:
      - Linked list in unsafe memory
      - Coalescing algorithms
      - Fragmentation analysis
    deliverables:
      - Explicit free list with embedded next/prev pointers
      - Block splitting when remainder ≥ minimum block size
      - Immediate coalescing on free (forward + backward using boundary tags)
      - First-fit, best-fit, and next-fit allocation strategies
      - Fragmentation/utilization metric calculator
      - Test harness with malloc/free sequences
    estimated_hours: "10-15"

  - id: build-allocator-m3
    name: "Segregated Free Lists and realloc"
    description: >
      Implement size-class segregated free lists for faster allocation
      and realloc with in-place growth.
    acceptance_criteria:
      - "Multiple segregated free lists maintained, one per size class; size classes defined (e.g., 16, 32, 48, 64, 96, 128, 256, 512, 1024, 2048, 4096, ∞)"
      - "Allocation for a given size selects the appropriate size class list and returns a block in O(1) if one is available"
      - "If the exact size class list is empty, search the next larger class; split if necessary"
      - "Freed blocks are inserted into the correct size class list based on their total block size"
      - "realloc(ptr, new_size) is implemented: if the current block has enough space (or can coalesce with the next free block to grow), resize in-place; otherwise malloc + memcpy + free"
      - "realloc(NULL, size) behaves as malloc(size); realloc(ptr, 0) behaves as free(ptr) and returns NULL"
      - "Internal fragmentation measured: wasted bytes within allocated blocks due to size class rounding; compared to non-segregated allocator"
    pitfalls:
      - "Power-of-two size classes (16, 32, 64, 128) cause up to 50% internal fragmentation (e.g., 33-byte request gets 64-byte block); finer granularity for small sizes reduces waste"
      - "Moving a freed block between size class lists during coalescing: the merged block may belong in a different (larger) size class"
      - "realloc in-place growth by coalescing with the next block must update the free list to remove the absorbed block"
      - "Cache-unfriendly access when scanning multiple segregated lists; keep hot size classes in fast-access array positions"
    concepts:
      - Size-class segregation
      - Segregated fits
      - realloc optimization
      - Internal vs external fragmentation
    skills:
      - Cache-aware data structure design
      - Size class bucketing
      - In-place reallocation
    deliverables:
      - Segregated free list array indexed by size class
      - Size class selection function mapping request size to class index
      - Fast O(1) allocation from matching size class
      - Block migration between size classes on coalescing
      - realloc with in-place growth optimization
      - Internal fragmentation metric
    estimated_hours: "10-15"

  - id: build-allocator-m4
    name: "Thread Safety, mmap, and Debugging"
    description: >
      Add thread-safe allocation with per-thread arenas, mmap for large
      allocations, and basic memory debugging support.
    acceptance_criteria:
      - "Large allocations above a threshold (e.g., 128KB) use mmap() instead of sbrk; free uses munmap() to immediately return memory to the OS"
      - "Per-thread arenas: each thread gets its own heap arena (free lists, sbrk region) accessed via thread-local storage (TLS); no lock required for same-thread allocation"
      - "Cross-thread free (freeing memory allocated by a different thread) is handled safely: either lock the target arena or use a lock-free return queue"
      - "Multi-threaded stress test: N threads each performing M random malloc/free operations concurrently with no crashes, corruption, or leaks"
      - "Basic double-free detection: freed blocks are poisoned with a magic value; free() checks for the poison pattern before marking as free"
      - "Basic buffer overflow detection: a canary value is placed after the user payload; free() checks canary integrity and reports corruption"
      - "LD_PRELOAD test: compile allocator as a shared library; use LD_PRELOAD=./libmymalloc.so to replace libc malloc and run a real program (e.g., ls, grep) successfully"
      - "Allocator performance benchmark: measure throughput (allocs/sec) and compare single-threaded vs multi-threaded, and against libc malloc"
    pitfalls:
      - "sbrk is process-global and not thread-safe; per-thread arenas must either serialize sbrk access or use mmap for arena creation"
      - "Lock contention on a global allocator destroys multi-threaded throughput; per-thread arenas are essential"
      - "Cross-thread free is the hardest part: thread A frees memory from thread B's arena; without proper synchronization this corrupts B's free list"
      - "mmap for large allocations must be aligned to page boundaries; munmap must free the exact mapped region"
      - "Canary checking on free adds overhead; make it compile-time optional (debug mode)"
      - "LD_PRELOAD requires implementing calloc (malloc + memset) and potentially memalign/posix_memalign"
    concepts:
      - Per-thread arenas and TLS
      - mmap for large allocations
      - Cross-thread memory management
      - Memory debugging canaries
    skills:
      - Thread-local storage
      - mmap/munmap system calls
      - Lock-free or low-contention design
      - Memory debugging techniques
      - Shared library compilation (LD_PRELOAD)
    deliverables:
      - mmap fallback for large allocations (≥128KB)
      - Per-thread arena with TLS-based fast path
      - Cross-thread free handling (lock or return queue)
      - Double-free detection via poison pattern
      - Buffer overflow detection via canary values
      - LD_PRELOAD shared library build and test
      - Performance benchmark comparing against libc malloc
    estimated_hours: "12-18"