id: build-browser
name: Build Your Own Browser Engine
description: 'Toy browser engine that parses HTML/CSS, performs layout, and renders to a canvas. Loads from local files (no networking).


  **Notes:** This project loads HTML and CSS from local files, not from the network. Text layout assumes left-to-right (LTR) only. Only a subset of CSS properties are supported (display, margin, padding, border, width, height, background-color, color, font-size).

  '
difficulty: expert
estimated_hours: 80-150
essence: 'Multi-stage rendering pipeline transforming markup text into pixels through tokenization and parsing (HTML/CSS to DOM/stylesheet), style resolution via selector matching and cascade, box model layout computation with recursive reflow, and rasterization to a 2D canvas through painting primitives.

  '
why_important: 'Building a browser engine demystifies the entire web stack by forcing you to implement the same parsing, layout, and rendering algorithms that power modern browsers, giving you deep insight into performance optimization and computer graphics fundamentals.

  '
learning_outcomes:
- Implement recursive descent parsers for HTML and CSS syntax
- Design tree data structures for DOM representation and traversal
- Build CSS selector matching and specificity-based cascade resolution
- Construct a style/render tree merging DOM with computed styles
- Implement the CSS box model with block and inline flow layout
- Calculate layout trees with recursive reflow and constraint solving
- Render visual output using 2D graphics primitives and painting algorithms
- Debug complex state machines in tokenization and parsing phases
skills:
- Parser Implementation
- DOM Tree Manipulation
- CSS Selector Matching
- CSS Box Model
- Layout Algorithms
- Rendering Pipelines
- Computer Graphics
- Memory Management
tags:
- build-from-scratch
- c++
- css-engine
- expert
- go
- html-parser
- layout
- rendering
- rust
- web
architecture_doc: architecture-docs/build-browser/index.md
languages:
  recommended:
  - Rust
  - C++
  - Go
  also_possible:
  - Python
  - TypeScript
resources:
- type: book
  name: Web Browser Engineering
  url: https://browser.engineering/
- type: tutorial
  name: Let's build a browser engine
  url: https://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html
- type: specification
  name: CSS 2.1 Visual Formatting Model
  url: https://www.w3.org/TR/CSS21/visuren.html
prerequisites:
- type: skill
  name: HTML/CSS fundamentals
- type: skill
  name: Tree data structures
- type: skill
  name: Basic 2D graphics programming
milestones:
- id: build-browser-m1
  name: HTML Parser and DOM Tree
  description: 'Parse a subset of HTML into a DOM tree with correct parent-child relationships, attribute parsing, and basic error recovery.

    '
  acceptance_criteria:
  - Tokenizer correctly identifies start tags, end tags, self-closing tags, text content, and comments from raw HTML input
  - Attribute parsing extracts name-value pairs from tags, handling double-quoted, single-quoted, and unquoted attribute values
  - DOM tree is built with correct parent-child and sibling relationships reflecting the HTML nesting structure
  - Void elements (br, hr, img, input, meta, link) are handled without expecting a matching end tag
  - DOCTYPE declaration (<!DOCTYPE html>) is recognized and skipped without crashing
  - Basic error recovery handles missing closing tags by implicitly closing elements at the end of their parent's scope
  - Text nodes are created for text content between tags, with whitespace preserved as-is (normalization happens later)
  - DOM nodes are printable for debugging (tree dump showing tag names, attributes, and hierarchy)
  pitfalls:
  - Malformed HTML is the norm on the web; the parser must not crash on missing closing tags, mismatched nesting, or unexpected tokens
  - Entity decoding (&amp; &lt; &gt; &quot;) should be handled at minimum for these common entities
  - Attributes with no value (e.g., <input disabled>) are boolean attributes and should be stored with empty string value
  - Self-closing syntax (<br/> vs <br>) should both be accepted
  - Comments (<!-- ... -->) must be recognized and skipped without being added to the DOM
  concepts:
  - DOM tree structure
  - HTML tokenization
  - Tree construction algorithm
  - Error recovery in parsers
  skills:
  - String manipulation and parsing
  - Recursive data structure construction
  - Error recovery strategies
  - Tree traversal and manipulation
  deliverables:
  - HTML tokenizer producing start tag, end tag, self-closing, text, and comment tokens
  - Attribute parser extracting name-value pairs from tag tokens
  - DOM tree builder constructing element and text nodes with correct hierarchy
  - Void element handling and basic error recovery for malformed HTML
  - DOM tree debug dump utility
  estimated_hours: 12-20
- id: build-browser-m2
  name: CSS Parser and Stylesheet
  description: 'Parse a subset of CSS into a structured stylesheet representation with selector parsing and specificity calculation.

    '
  acceptance_criteria:
  - Selector parser handles tag selectors (div), class selectors (.foo), ID selectors (#bar), universal selector (*), and descendant combinator (space)
  - Property parser extracts property name and value pairs, handling values with units (px, em, %), colors (#hex, named colors), and shorthand properties (margin, padding with 1-4 values)
  - Specificity is correctly calculated as (inline_count, id_count, class_count, tag_count) for any parsed selector
  - Multiple rules in a stylesheet are parsed and stored in declaration order for cascade resolution
  - Inline styles from the 'style' attribute on HTML elements are parsed with specificity (1,0,0,0)
  - Comments (/* ... */) in CSS are correctly skipped during parsing
  pitfalls:
  - Selector combinators beyond descendant (child >, sibling +, general ~) are complex; scope to descendant only initially and document the limitation
  - 'Shorthand properties (margin: 10px 20px) expand to individual properties (margin-top, margin-right, etc.); this expansion must happen during parsing'
  - 'Color parsing must handle both hex (#ff0000, #f00) and common named colors (red, blue, black, white)'
  - CSS comments can appear between any tokens; the parser must skip them robustly
  - '!important declarations should be tracked (even if only to give them highest priority in cascade)'
  concepts:
  - CSS syntax and rule structure
  - Selector specificity calculation
  - CSS cascade algorithm
  - Property value parsing
  skills:
  - Tokenization and lexical analysis
  - Specificity calculation
  - Data structure design for stylesheets
  - Value parsing with units and types
  deliverables:
  - CSS tokenizer and rule parser
  - Selector parser supporting tag, class, ID, universal, and descendant combinators
  - Specificity calculator
  - Property value parser handling units, colors, and shorthands
  - Stylesheet storage structure mapping selectors to declaration blocks
  estimated_hours: 12-20
- id: build-browser-m3
  name: Style Resolution and Render Tree
  description: 'Match CSS selectors to DOM nodes, apply the cascade to compute final styles for each element, and build a render tree excluding non-visual elements.

    '
  acceptance_criteria:
  - Selector matching correctly determines which CSS rules apply to each DOM element by testing the selector against the element and its ancestors (for descendant combinator)
  - 'Cascade resolution applies rules in correct order: user-agent defaults, then author stylesheet rules ordered by specificity, then inline styles; later rules of equal specificity win'
  - 'Property inheritance is implemented: inheritable properties (color, font-size) are inherited from parent if not explicitly set on the element'
  - 'Default values from a minimal user-agent stylesheet are applied (e.g., display: block for div/p/h1-h6, display:inline for span/a/em/strong)'
  - 'Render tree excludes non-visual elements: elements with display:none, and non-rendering elements (<head>, <script>, <style>, <meta>, <link>) are not included'
  - Each render tree node stores its computed style (resolved property values) and a reference to its DOM node
  - Computed styles are accessible for debugging (dump styled tree showing element + computed properties)
  pitfalls:
  - Selector matching for descendant combinators requires walking up the DOM ancestor chain; this can be expensive for deep trees
  - Inheritance must distinguish between inherited and non-inherited properties; margin, padding, border are NOT inherited
  - The 'initial' value for each property must be defined; without a user-agent stylesheet, nothing has sensible defaults
  - 'display: none removes the element AND all its descendants from the render tree; display:inline on a block''s child changes layout behavior'
  - Multiple selectors may match the same element; all matching rules must be collected, sorted by specificity, and merged
  concepts:
  - CSS selector matching algorithm
  - Cascade and specificity resolution
  - Property inheritance
  - Render tree vs DOM tree
  skills:
  - Selector matching implementation
  - Cascade resolution algorithm
  - Tree transformation (DOM â†’ render tree)
  - Default style application
  deliverables:
  - Selector matching engine testing CSS selectors against DOM elements
  - Cascade resolver merging matching rules by specificity order
  - Property inheritance propagating inheritable values from parent to child
  - Render tree builder excluding display: none and non-visual elements
  - Minimal user-agent stylesheet providing default display values
  estimated_hours: 15-25
- id: build-browser-m4
  name: Layout
  description: 'Calculate box positions and sizes using the CSS box model with block and inline flow layout.

    '
  acceptance_criteria:
  - Box model correctly computes total element dimensions as content + padding + border + margin on all four sides
  - Block layout stacks child block-level elements vertically; each child's y-position is the previous sibling's y + height + collapsed margin
  - 'Vertical margin collapsing between adjacent block siblings is implemented: the gap between them is max(bottom_margin, top_margin), not the sum'
  - Inline layout flows text and inline elements horizontally left-to-right, wrapping to a new line when content exceeds the container's content width
  - 'Width resolves correctly: explicit px width is used directly; ''auto'' width for block elements expands to fill parent content width minus margins; percentage width resolves against parent content width'
  - 'Height resolves correctly: explicit px height is used; ''auto'' height for block elements is the sum of child heights (content-driven)'
  - Layout tree assigns each render tree node a position (x, y) and dimensions (width, height) in a global coordinate space
  - 'Auto margins (margin-left: auto, margin-right:auto) center a block element horizontally within its parent'
  pitfalls:
  - Margin collapsing is one of the most confusing CSS behaviors; only vertical margins between adjacent block siblings collapse (not horizontal, not inline, not parent-child without border/padding separation)
  - 'Percentage width resolution requires a chain: each element resolves against its parent''s content width, which must already be computed (top-down width pass)'
  - '''auto'' height requires knowing children''s total height (bottom-up height pass); layout is typically a two-pass algorithm: top-down for width, bottom-up for height'
  - Inline elements with different font sizes affect line height calculation; use the tallest inline's line-height for the line box
  - Text wrapping requires knowing the width of each word; for simplicity, assume monospace font or use a font metrics library
  concepts:
  - CSS box model (content, padding, border, margin)
  - Block formatting context
  - Inline formatting context with line boxes
  - Margin collapsing rules
  - Two-pass layout algorithm
  skills:
  - Geometric computation and positioning
  - Recursive layout algorithms
  - Constraint solving for dimensions
  - Text measurement and line breaking
  deliverables:
  - Box model dimension calculator for content + padding + border + margin
  - Block layout algorithm stacking children vertically with margin collapsing
  - Inline layout algorithm with horizontal flow and line wrapping
  - Width/height resolution handling px, auto, and percentage values
  - Layout tree assigning (x, y, width, height) to each render tree node
  estimated_hours: 20-35
- id: build-browser-m5
  name: Rendering
  description: 'Paint the layout tree to a canvas or image by generating draw commands and executing them in the correct order.

    '
  acceptance_criteria:
  - Background colors are painted as filled rectangles at the correct position and size for each box
  - Borders are rendered with the correct width and color on all four sides (top, right, bottom, left may differ)
  - Text is rendered at the correct position within its content box using the computed font-size and color
  - 'Elements are painted in tree order (pre-order traversal): parent background first, then children, ensuring correct visual layering'
  - The final output is displayed in a window (using SDL, winit, or similar) or saved as an image file (PNG) for automated testing
  - A reference HTML/CSS test page renders correctly with backgrounds, borders, text, nested elements, and inline/block layout
  pitfalls:
  - 'Painting order matters: backgrounds must be painted before borders, borders before content, parent before children'
  - Text rendering requires a font rasterizer or library (SDL_ttf, rusttype, etc.); implementing glyph rasterization from scratch is out of scope
  - Sub-pixel rendering and anti-aliasing depend on the graphics library; accept library defaults
  - 'Clipping: content that overflows its box (without overflow:hidden) should still be visible in a simple implementation; overflow handling is complex'
  - Font fallback (when the specified font isn't available) should use a default system font rather than crashing
  concepts:
  - Paint/display list generation
  - Painting order and tree traversal
  - 2D graphics primitives
  - Text rendering with fonts
  skills:
  - 2D graphics programming
  - Display list generation and execution
  - Font and text rendering integration
  - Image output for testing
  deliverables:
  - Paint list generator traversing layout tree and emitting draw commands (fill_rect, draw_border, draw_text)
  - Paint executor rendering draw commands to a canvas or window
  - Text rendering using a font library at computed font-size and color
  - Visual output to window or PNG image file
  - Reference test page demonstrating correct rendering of blocks, inline text, backgrounds, and borders
  estimated_hours: 20-40
domain: specialized
