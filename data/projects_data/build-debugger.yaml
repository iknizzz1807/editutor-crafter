id: build-debugger
name: Build Your Own Debugger
description: GDB-like debugger for Linux x86-64 ELF binaries with source-level debugging
difficulty: expert
estimated_hours: "60-100"
essence: >
  Process introspection through ptrace system calls for execution control, software
  breakpoint injection via INT3 instruction patching with step-over-breakpoint logic,
  and parsing DWARF debug metadata to map machine addresses and register states back
  to source-level symbols, lines, and type information.
why_important: >
  Debuggers reveal how operating systems expose process internals and how compilers
  encode source-to-binary mappings, providing deep insight into systems programming,
  binary formats, and the runtime behavior of compiled code.
learning_outcomes:
  - Implement process control using ptrace to pause, resume, and single-step program execution
  - Design software breakpoints by injecting INT3 instructions and implementing step-over-breakpoint logic
  - Parse DWARF debug information to map machine addresses to source code locations
  - Read and modify process memory and CPU registers through ptrace APIs
  - Handle signal-based debugging events and distinguish between breakpoint hits and program signals
  - Implement source-level stepping (step-over, step-into, step-out) using debug line information
  - Build variable inspection using DWARF location and type metadata
  - Navigate ELF sections and DWARF compilation units to resolve symbols
skills:
  - ptrace System Calls
  - Signal Handling
  - DWARF Parsing
  - Binary Instruction Patching
  - Memory Introspection
  - Process Control
  - Symbol Resolution
  - ELF Format
tags:
  - breakpoints
  - build-from-scratch
  - c
  - c++
  - expert
  - inspection
  - ptrace
  - rust
  - stepping
  - tool
architecture_doc: architecture-docs/build-debugger/index.md
languages:
  recommended:
    - C
    - Rust
    - C++
  also_possible:
    - Go
resources:
  - type: article
    name: "Writing a Linux Debugger"
    url: "https://blog.tartanllama.xyz/writing-a-linux-debugger-setup/"
  - type: book
    name: "The Linux Programming Interface - Ch 26"
    url: "https://man7.org/tlpi/"
  - type: specification
    name: "DWARF Debugging Standard"
    url: "https://dwarfstd.org/"
prerequisites:
  - type: skill
    name: Unix processes and signals
  - type: skill
    name: x86-64 assembly basics
  - type: skill
    name: ELF binary format
  - type: skill
    name: C or systems programming language
milestones:
  - id: build-debugger-m1
    name: Process Control
    description: >
      Fork a child process, attach with ptrace using the TRACEME pattern,
      and implement continue, single-step, and signal handling.
    acceptance_criteria:
      - "Debugger forks a child process; the child calls PTRACE_TRACEME and then exec's the target program, stopping on the first instruction before main"
      - "The parent (debugger) calls waitpid to catch the initial SIGTRAP from the child's exec, confirming attachment"
      - "PTRACE_CONT resumes the tracee; the debugger blocks on waitpid until the next signal, breakpoint, or exit"
      - "PTRACE_SINGLESTEP advances exactly one machine instruction and returns control to the debugger via SIGTRAP"
      - "waitpid status is inspected using WIFEXITED, WIFSTOPPED, WIFSIGNALED, and WSTOPSIG macros to determine the stop reason"
      - "Signals delivered to the tracee (other than debugger-injected SIGTRAP) are forwarded to the tracee via PTRACE_CONT's signal parameter, not swallowed"
      - "The debugger handles tracee exit and reports the exit code or termination signal"
      - "A simple REPL command loop accepts 'continue', 'step', and 'quit' commands from the user"
    pitfalls:
      - "PTRACE_TRACEME must be called in the child BEFORE exec; calling it after is too late"
      - "Swallowing all signals instead of forwarding them causes the tracee to behave differently under debugging (e.g., SIGALRM timers break)"
      - "On modern Linux, /proc/sys/kernel/yama/ptrace_scope may restrict ptrace; must run as root or set ptrace_scope=0"
      - "Zombie processes result if the debugger doesn't waitpid on the child after it exits"
      - "Race condition: the child may exec before the parent is ready to waitpid; PTRACE_TRACEME ensures the child stops at exec"
    concepts:
      - ptrace TRACEME/CONT/SINGLESTEP
      - Process lifecycle (fork, exec, wait)
      - Unix signals and waitpid status inspection
    skills:
      - System call debugging with ptrace
      - Process state management
      - Signal interception and forwarding
      - Parent-child process coordination
    deliverables:
      - Fork-traceme-exec launcher that creates and attaches to the target process
      - PTRACE_CONT continue command resuming the tracee until next stop event
      - PTRACE_SINGLESTEP single-step command advancing exactly one instruction
      - waitpid-based event loop determining stop reason (breakpoint, signal, exit)
      - Signal forwarding passing non-debug signals to the tracee
      - Interactive REPL accepting debugger commands
    estimated_hours: "8-12"

  - id: build-debugger-m2
    name: Software Breakpoints
    description: >
      Implement software breakpoints using INT3 (0xCC) instruction patching,
      including the critical step-over-breakpoint algorithm for resumption.
    acceptance_criteria:
      - "Setting a breakpoint at a given address reads the original byte using PTRACE_PEEKDATA, saves it, and writes 0xCC (INT3) at that address using PTRACE_POKEDATA"
      - "Breakpoint hit is detected via SIGTRAP from waitpid; on x86-64 the RIP register is one byte past the INT3 and must be decremented by 1 to point back to the breakpoint address"
      - "Step-over-breakpoint algorithm is implemented: (1) disable breakpoint by restoring original byte, (2) set RIP back to breakpoint address, (3) single-step one instruction, (4) re-enable breakpoint by writing 0xCC again"
      - "Multiple breakpoints can be set simultaneously at different addresses and each fires independently"
      - "Breakpoints can be enabled, disabled, and removed individually without affecting other breakpoints"
      - "Breakpoint at an address that is hit in a loop fires correctly on every iteration (step-over-breakpoint re-inserts the INT3)"
      - "Breakpoints set at invalid addresses (unmapped memory) produce a clear error message"
      - "NOTE: The RIP-1 adjustment is x86-64 specific. On ARM (AArch64), the PC points to the BRK instruction itself and no adjustment is needed."
    pitfalls:
      - "Forgetting the step-over-breakpoint sequence causes the debugger to either re-trigger the breakpoint infinitely or skip the original instruction"
      - "On x86-64, INT3 is a 1-byte instruction (0xCC); the CPU advances RIP past it, so RIP must be decremented by 1 to re-execute the original instruction"
      - "PTRACE_PEEKDATA and PTRACE_POKEDATA operate on word-sized (8 bytes on x86-64) units; must mask and preserve surrounding bytes when patching a single byte"
      - "Setting a breakpoint in the middle of a multi-byte instruction corrupts the instruction; breakpoints should be set at instruction boundaries"
      - "Thread safety: in multi-threaded programs, another thread may hit the breakpoint during the step-over window when the original byte is temporarily restored"
    concepts:
      - Software breakpoints via INT3 injection
      - Step-over-breakpoint algorithm
      - Instruction pointer manipulation
      - x86-64 vs ARM breakpoint differences
    skills:
      - Binary instruction manipulation
      - Memory patching with ptrace
      - Instruction pointer control
      - Trap instruction handling
    deliverables:
      - Breakpoint set/enable/disable/remove commands using INT3 byte patching
      - Original instruction byte preservation and restoration
      - Step-over-breakpoint algorithm (restore → set RIP → single-step → re-insert)
      - Breakpoint address to RIP mapping with x86-64 RIP-1 adjustment
      - Multiple simultaneous breakpoint support with per-breakpoint enable/disable state
      - Hit count tracking per breakpoint
    estimated_hours: "10-15"

  - id: build-debugger-m3
    name: DWARF Debug Information and Source Mapping
    description: >
      Parse ELF section headers to locate DWARF debug sections and implement
      address-to-line and name-to-address mappings. A DWARF parsing library
      (libdw, gimli) may be used.
    acceptance_criteria:
      - "ELF section headers are parsed to locate .debug_info, .debug_line, .debug_abbrev, .debug_str, and .symtab sections"
      - "DWARF compilation unit headers are parsed from .debug_info to identify the boundaries and DWARF version of each compilation unit"
      - "DWARF Debug Information Entries (DIEs) are decoded with correct handling of abbreviation tables, tag types, and attribute forms including references to .debug_str"
      - "Address-to-line mapping converts a program counter value to the corresponding source file path and line number using .debug_line line number program"
      - "Name-to-address mapping resolves a function name (DW_TAG_subprogram with DW_AT_name) to its entry point address (DW_AT_low_pc) for setting breakpoints by name"
      - "Source-level breakpoint: user can specify break filename:line\" and the debugger resolves it to a machine address using .debug_line data and sets a breakpoint\""
      - "When stopped at a breakpoint, the debugger displays the current source file, line number, and surrounding lines of source code"
    pitfalls:
      - "DWARF versions 2, 3, 4, and 5 have different header formats and attribute encodings; scope to DWARF 4 (most common with gcc -g) initially"
      - "Inlined functions have DW_TAG_inlined_subroutine entries and may not have contiguous address ranges; defer inline handling or note limitation"
      - "Optimized code (-O2) may have non-monotonic address-to-line mappings; multiple addresses can map to the same line and vice versa"
      - ".debug_line is a bytecode program that must be interpreted (state machine), not a simple table; this is non-trivial to implement from scratch"
      - "Using a DWARF library (libdw on Linux, gimli in Rust) is strongly recommended for the initial implementation; understanding the format matters more than reimplementing it"
      - ".debug_str offsets are byte offsets into a string table; off-by-one errors here produce garbage symbol names"
    concepts:
      - ELF binary format and section headers
      - DWARF debug information structure
      - Line number program (.debug_line state machine)
      - Compilation units and DIE tree hierarchy
    skills:
      - Binary format parsing (ELF sections)
      - Debug metadata interpretation
      - Source-to-machine code mapping
      - Symbol resolution from DWARF entries
    deliverables:
      - ELF section header parser locating DWARF debug sections
      - DWARF compilation unit and DIE parser (or library integration)
      - Address-to-source-line mapping using .debug_line data
      - Function-name-to-address mapping from DW_TAG_subprogram entries
      - Source-level breakpoint setting by filename: line specification
      - Source code display showing current file and line when stopped
    estimated_hours: "15-22"

  - id: build-debugger-m4
    name: Source-Level Stepping
    description: >
      Implement step-over (next line), step-into (enter function call),
      and step-out (finish current function) using debug line information.
    acceptance_criteria:
      - "Step-over advances execution to the next source line in the current function, stepping over function calls (not entering them)"
      - "Step-into advances to the next source line, entering function calls when the current line contains a call instruction"
      - "Step-out continues execution until the current function returns, stopping at the caller's next line"
      - "All stepping commands correctly handle breakpoints encountered during stepping (do not skip or double-trigger)"
      - "Step-over is implemented by: setting a temporary breakpoint at the next line's address in the current function and continuing, OR by single-stepping until the line number changes while staying in the current function's address range"
      - "Step-out is implemented by: reading the return address from the stack frame (via frame pointer or DWARF CFI), setting a temporary breakpoint there, and continuing"
      - "Stack backtrace (backtrace/bt command) displays the call chain showing function name, source file, and line number for each frame using frame pointer chain or DWARF Call Frame Information (CFI)"
    pitfalls:
      - "Step-over must not enter function calls; this requires knowing the address range of the current function (DW_AT_low_pc to DW_AT_high_pc) and detecting when RIP leaves that range"
      - "Optimized code may have no frame pointer (compiled with -fomit-frame-pointer); stack unwinding then requires DWARF .debug_frame or .eh_frame CFI data"
      - "Stepping through inlined functions is confusing because the source line changes but the address range stays within the inlined copy; defer or document this limitation"
      - "Temporary breakpoints used for stepping must be cleaned up after they fire to avoid interfering with subsequent execution"
      - "Step-out relies on finding the return address; on x86-64, this is typically at [RBP+8] with frame pointers enabled"
    concepts:
      - Source-level stepping algorithms
      - Function address ranges in DWARF
      - Stack unwinding and frame pointers
      - DWARF Call Frame Information (CFI)
    skills:
      - Instruction-to-line mapping for stepping
      - Stack frame traversal
      - Temporary breakpoint management
      - Call chain reconstruction
    deliverables:
      - Step-over (next) command advancing to the next source line without entering function calls
      - Step-into command advancing to the next source line including entering called functions
      - Step-out (finish) command running until the current function returns
      - Stack backtrace command displaying the call chain with function names and source locations
      - Temporary breakpoint infrastructure for stepping implementation
    estimated_hours: "12-18"

  - id: build-debugger-m5
    name: Variable Inspection
    description: >
      Read and display variable values by resolving DWARF location and type
      information. Scope to simple types and stack variables.
    acceptance_criteria:
      - "Variable location is resolved from DWARF location attributes: DW_OP_fbreg (stack offset from frame base), DW_OP_reg* (register), DW_OP_addr (global address)"
      - "Frame base is resolved from the current function's DW_AT_frame_base attribute (typically DW_OP_reg6 for RBP on x86-64)"
      - "Register values are read using PTRACE_GETREGS and memory values using PTRACE_PEEKDATA"
      - "Basic types (int, long, float, double, char, bool, pointer) are correctly formatted based on DWARF type information (DW_TAG_base_type with encoding and size)"
      - "Pointer types display the pointed-to address and can be dereferenced to show the value at that address"
      - "Struct/class members are accessible by name; each field is displayed with its type and value using DW_TAG_member offset information"
      - "Array elements are accessible by index using element stride from the array type's element type size"
      - "Variables that are optimized out (DW_AT_location absent or DW_OP_GNU_uninit) display a clear 'optimized out' message instead of garbage"
    pitfalls:
      - "DWARF location expressions are a stack-based bytecode VM (DW_OP_*); full implementation is very complex. Scope to DW_OP_fbreg, DW_OP_reg*, DW_OP_addr, and DW_OP_plus_uconst initially"
      - "Variables optimized into registers may only be valid for part of a function's execution (location lists); the current PC must be checked against the location list ranges"
      - "Type alignment and padding in structs means field offsets from DWARF must be used, not computed from type sizes"
      - "PTRACE_PEEKDATA reads word-sized (8 bytes) chunks; reading a single char requires masking"
      - "Float/double interpretation requires reading bytes and reinterpreting as IEEE 754; be careful with endianness"
      - "Scoping: the correct variable instance depends on the current function and lexical block scope (DW_TAG_lexical_block)"
    concepts:
      - DWARF location expressions
      - Type metadata interpretation
      - Register and memory reading via ptrace
      - Variable scoping in DWARF
    skills:
      - Memory address calculation from DWARF locations
      - Register value extraction via PTRACE_GETREGS
      - Type-aware data interpretation
      - Stack frame and scope traversal
    deliverables:
      - Variable location resolver handling DW_OP_fbreg, DW_OP_reg*, and DW_OP_addr
      - Memory and register reader fetching raw bytes for variable values
      - Type-aware value formatter for basic types, pointers, structs, and arrays
      - Optimized-out variable detection with user-friendly message
      - Print/inspect command displaying variable name, type, and current value
    estimated_hours: "15-22"