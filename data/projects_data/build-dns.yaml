id: build-dns
name: Build Your Own DNS Server
description: Recursive DNS resolver with authoritative zone serving and caching
difficulty: expert
estimated_hours: 45-70
essence: 'Binary protocol parsing of variable-length message formats with pointer compression, recursive query resolution traversing a hierarchical tree of distributed authoritative nameservers from root to leaf, and cache management with TTL-based expiration to minimize latency in domain-to-IP translation.

  '
why_important: 'Building a DNS server teaches foundational internet infrastructure and low-level network programming that underpins every web service, with skills directly applicable to building distributed systems, protocol implementations, and performance-critical networking applications.

  '
learning_outcomes:
- Implement binary protocol parsing and serialization for DNS message formats per RFC 1035
- Design recursive resolution algorithms that traverse the DNS hierarchy from root servers
- Build efficient caching mechanisms with TTL expiration and negative caching
- Handle UDP and TCP transport protocols with proper truncation handling and fallback
- Implement state management for concurrent query handling across multiple clients
- Debug network protocols using packet capture tools like Wireshark and dig
- Handle CNAME chains and circular delegation detection during recursive resolution
- Understand zone file formats and authoritative name server data structures
skills:
- Binary Protocol Parsing
- Recursive Algorithms
- Network Socket Programming
- Caching Strategies
- UDP/TCP Protocols
- Concurrent Request Handling
- Memory-Efficient Data Structures
- DNS Infrastructure
tags:
- build-from-scratch
- c
- expert
- go
- networking
- records
- recursion
- resolver
- rust
- zone-files
architecture_doc: architecture-docs/build-dns/index.md
languages:
  recommended:
  - Go
  - Rust
  - C
  also_possible:
  - Python
  - JavaScript
resources:
- type: specification
  name: RFC 1035 - DNS
  url: https://tools.ietf.org/html/rfc1035
- type: specification
  name: RFC 6891 - EDNS(0)
  url: https://tools.ietf.org/html/rfc6891
- type: tool
  name: CodeCrafters DNS
  url: https://app.codecrafters.io/courses/dns-server/overview
- type: article
  name: How DNS Works
  url: https://howdns.works/
prerequisites:
- type: skill
  name: UDP/TCP networking
- type: skill
  name: DNS protocol basics
- type: skill
  name: Binary data manipulation
- type: skill
  name: Concurrency fundamentals
milestones:
- id: build-dns-m1
  name: DNS Message Parsing and UDP Server
  description: 'Parse and construct DNS messages per RFC 1035 wire format, including name compression. Stand up a UDP server that receives queries and sends responses.

    '
  acceptance_criteria:
  - Header parser correctly extracts 16-bit ID, QR flag, opcode, AA, TC, RD, RA, rcode, and all four section counts from the 12-byte header
  - Question section parser decodes domain names with label-length encoding (labels up to 63 bytes, total name up to 253 characters) and extracts QTYPE and QCLASS
  - Answer/authority/additional section parser reads resource records with name, type, class, TTL, RDLENGTH, and type-specific RDATA for at least A, AAAA, NS, CNAME, MX, SOA, and TXT record types
  - Name decompression correctly handles DNS pointer labels (top 2 bits = 11, 0xC0 prefix) including pointers that point to other pointers, with loop detection to prevent infinite pointer chains
  - Message serializer encodes DNS responses into correct wire-format bytes with name compression to reduce response size
  - UDP server listens on port 53 (or configurable port), receives query packets, and sends response packets back to the querying client address
  - Responses to unknown queries return RCODE=NXDOMAIN with correct header flags
  pitfalls:
  - Compression pointers can form infinite loops; must track visited offsets and abort with SERVFAIL after detecting a cycle
  - DNS uses network byte order (big-endian); all multi-byte fields must be converted
  - Domain names are terminated by a zero-length label (null byte), not by \0 in the C string sense
  - Name compression during serialization requires tracking already-written names and their offsets
  - UDP recv buffer must be at least 512 bytes (RFC 1035 minimum); larger with EDNS(0)
  concepts:
  - DNS wire format (RFC 1035 Section 4)
  - Name compression with pointer labels
  - UDP datagram server architecture
  skills:
  - Binary data manipulation and bit-level operations
  - Network protocol implementation
  - UDP socket programming
  - Memory-safe parsing with bounds checking
  deliverables:
  - DNS header parser reading 12-byte header with all flags and section counts
  - Question and resource record parser supporting A, AAAA, NS, CNAME, MX, SOA, TXT types
  - Name compression decoder with pointer loop detection
  - DNS message serializer with name compression encoding
  - UDP server accepting queries and sending responses on configurable port
  estimated_hours: 12-18
- id: build-dns-m2
  name: Authoritative Zone Server
  description: 'Load zone data from files and respond authoritatively to queries for domains within the zone, including proper NXDOMAIN, NODATA, and delegation responses.

    '
  acceptance_criteria:
  - Zone file parser reads a simplified BIND-format zone file and loads SOA, NS, A, AAAA, CNAME, MX, and TXT records into an in-memory data structure
  - Query matching returns the correct record set for a given domain name and record type from the zone, with case-insensitive name comparison
  - A and AAAA records are returned in the answer section with AA (authoritative answer) flag set when the queried name and type match a zone record
  - 'CNAME records are followed: if the queried name has a CNAME, the CNAME record is included in the answer section and resolution continues for the canonical name'
  - NXDOMAIN response is returned with RCODE=3 and the SOA record in the authority section when the queried name does not exist in the zone
  - NODATA response is returned with RCODE=0, empty answer section, and SOA in authority section when the name exists but the queried type has no records
  - NS records for delegated subdomains are returned in the authority section as referrals, with glue A/AAAA records in the additional section
  pitfalls:
  - DNS names are case-insensitive per RFC 1035; comparison must normalize case
  - CNAME records must not coexist with other record types for the same name (except DNSSEC); this invariant should be enforced during zone loading
  - Wildcard matching (*.example.com) requires specific matching rules per RFC 4592; scope it explicitly or defer
  - Distinguishing NXDOMAIN from NODATA requires checking whether the name exists at all vs. just lacking the requested type
  - Glue records are only needed for NS names that are within the delegated zone; out-of-zone NS names require separate resolution
  concepts:
  - Zone file format and loading
  - Authoritative vs non-authoritative responses
  - NXDOMAIN vs NODATA distinction
  - DNS delegation and glue records
  skills:
  - Zone file parsing
  - DNS record management and lookup
  - Case-insensitive string matching
  - Authoritative response construction
  deliverables:
  - Zone file parser loading records from simplified BIND format
  - Query matching engine with case-insensitive lookup returning correct record sets
  - CNAME following within the zone for authoritative responses
  - NXDOMAIN and NODATA response generation with SOA in authority section
  - Delegation response with NS records and glue A/AAAA records in additional section
  estimated_hours: 10-15
- id: build-dns-m3
  name: Recursive Resolver
  description: 'Implement iterative resolution starting from root servers, following NS referrals and CNAME chains to resolve any domain name.

    '
  acceptance_criteria:
  - Iterative resolution starts at root servers and follows NS referrals down the DNS hierarchy until reaching the authoritative server for the queried domain
  - Root hints bootstrap the resolver with hardcoded IP addresses of the 13 DNS root servers (a.root-servers.net through m.root-servers.net)
  - Glue records (A records in the additional section of referral responses) are used to resolve NS names without circular dependencies
  - When no glue record is provided for a referred NS name, a separate recursive resolution is performed to resolve the NS name's IP address
  - 'CNAME chains are followed transparently: if the authoritative answer is a CNAME, the resolver continues resolution for the canonical name, up to a configurable maximum chain length (e.g., 8)'
  - Maximum recursion depth (e.g., 16 referrals) is enforced to prevent infinite loops from circular delegations
  - Truncated responses (TC bit set) trigger a retry of the same query over TCP using the standard DNS TCP framing (2-byte length prefix + message)
  - SERVFAIL is returned to the client when resolution fails due to timeout, unreachable nameservers, or exceeded recursion limits
  pitfalls:
  - Infinite referral loops between two nameservers will hang the resolver without a recursion depth limit
  - Missing glue records require resolving the NS name first, which can itself require recursion â€” track resolution chain to detect cycles
  - CNAME chains can span multiple zones; each step may require a full recursive resolution
  - Some nameservers only respond over TCP; TC bit handling and TCP fallback are essential for correctness
  - Timeout handling is critical; a single unresponsive nameserver should not block the entire resolution chain; try alternate NS records
  - Referral responses may include NS records for a less-specific zone than expected; the resolver must verify that the referral moves closer to the target name
  concepts:
  - Iterative DNS resolution algorithm
  - NS referral following
  - DNS hierarchy traversal
  - TCP fallback for truncated responses
  - CNAME chain resolution
  skills:
  - Multi-step query orchestration
  - Root server interaction
  - TCP DNS framing implementation
  - Referral chain traversal and cycle detection
  deliverables:
  - Root hints file/configuration with IP addresses of root nameservers
  - Iterative query engine following NS referrals from root to authoritative server
  - CNAME chain following with configurable maximum chain length
  - TCP fallback for truncated UDP responses with 2-byte length-prefixed framing
  - Recursion depth limiting and timeout-based failover to alternate nameservers
  - SERVFAIL response generation for unresolvable queries
  estimated_hours: 14-20
- id: build-dns-m4
  name: Caching, Concurrency, and Security
  description: 'Implement a TTL-based cache with negative caching, concurrent query handling, and basic cache poisoning prevention.

    '
  acceptance_criteria:
  - Cached records are returned immediately for subsequent queries; TTL is decremented based on elapsed time since caching and records are evicted when TTL reaches zero
  - Negative caching stores NXDOMAIN responses using the minimum of the SOA minimum TTL and the SOA record's own TTL, per RFC 2308
  - NODATA responses are cached separately from NXDOMAIN, keyed by (name, type) to avoid returning stale negative results for newly added record types
  - 'Cache poisoning is prevented by bailiwick checking: response records are only cached if the record''s owner name is within or equal to the zone of the queried nameserver (e.g., a query to ns1.example.com should not cache records for evil.com)'
  - Transaction ID is randomized for each outgoing query to prevent blind spoofing attacks
  - Source port is randomized for each outgoing query socket to increase entropy against cache poisoning
  - UDP server handles concurrent queries from multiple clients without blocking; a slow recursive resolution for one client does not delay responses to other clients
  - Cache has a configurable maximum size; when full, least-recently-used or lowest-TTL entries are evicted
  pitfalls:
  - TTL underflow (negative TTL) must be handled; expired records must be treated as absent, not served with TTL=0
  - Cache poisoning is the most critical DNS security vulnerability; bailiwick checking and randomized transaction IDs are minimum defenses
  - Memory exhaustion from unbounded cache growth under attack; maximum cache size and eviction policy are required
  - Concurrent access to the cache data structure requires proper synchronization (mutex, RWLock, or lock-free design)
  - Negative cache entries must be invalidated when the zone's SOA serial changes, though this is an advanced optimization
  - Serving stale cache entries during resolution of the same name (cache stampede) can be avoided with query deduplication
  concepts:
  - TTL-based cache with time-decrementing expiration
  - Negative caching per RFC 2308
  - Bailiwick checking for cache poisoning prevention
  - Concurrent query processing
  skills:
  - Cache invalidation strategies
  - Concurrent data structure design
  - Memory management and eviction policies
  - Security-conscious protocol implementation
  deliverables:
  - TTL-based record cache with time-decrementing expiration and automatic eviction
  - Negative caching for NXDOMAIN and NODATA responses with SOA-derived TTL
  - Bailiwick checking rejecting out-of-zone response records
  - Randomized transaction ID and source port for outgoing queries
  - Concurrent query handler using async I/O or thread pool for parallel resolution
  - Cache size limiting with LRU or TTL-based eviction policy
  estimated_hours: 12-18
domain: specialized
