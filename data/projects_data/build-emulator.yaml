id: build-emulator
name: Build Your Own Emulator
description: 'Emulator for a retro platform. Primary target: CHIP-8 (beginner-friendly). Advanced targets: Game Boy (SM83 CPU) or NES (6502 CPU).


  **Notes:** Target platform selection: CHIP-8 is recommended as the primary target (35 instructions, simple graphics, completable in 20-30 hours). Game Boy or NES are advanced targets requiring 80-120+ hours. Milestones are written generically but time estimates assume CHIP-8 as primary, with notes for advanced targets.

  '
difficulty: expert
estimated_hours: 60-120
essence: 'Cycle-accurate simulation of legacy CPU architectures through instruction-level interpretation, memory-mapped I/O handling, interrupt-driven peripheral communication, and precise timing synchronization between processor, graphics, and audio subsystems.

  '
why_important: 'Building an emulator teaches low-level systems programming and computer architecture fundamentals that are directly applicable to embedded systems, kernel development, compiler optimization, and performance-critical software engineering.

  '
learning_outcomes:
- Implement fetch-decode-execute cycles for 8-bit CPU instruction sets
- Design memory management with address space partitioning and memory-mapped I/O
- Implement interrupt handling (IRQ, NMI, V-Blank) for CPU-peripheral communication
- Build scanline-based or frame-based graphics rendering that syncs with CPU timing
- Debug timing-sensitive code using test ROMs and cycle-accurate execution models
- Handle input mapping from host devices to emulated platform input registers
- Optimize interpreter loops and instruction dispatch for performance
- Reverse-engineer hardware behavior from specifications and test ROMs
skills:
- CPU Architecture
- Instruction Set Simulation
- Memory Mapping
- Interrupt Handling
- Cycle-Accurate Timing
- Binary Data Manipulation
- Hardware Emulation
- Low-Level Debugging
tags:
- build-from-scratch
- c
- c++
- cpu
- expert
- game-dev
- instructions
- io
- memory-mapping
- rust
architecture_doc: architecture-docs/build-emulator/index.md
languages:
  recommended:
  - C
  - Rust
  - C++
  also_possible:
  - Go
  - TypeScript
resources:
- type: guide
  name: Writing a CHIP-8 Emulator
  url: https://tobiasvl.github.io/blog/write-a-chip-8-emulator/
- type: documentation
  name: Pan Docs (Game Boy)
  url: https://gbdev.io/pandocs/
- type: reference
  name: NesDev Wiki
  url: https://www.nesdev.org/wiki/Nesdev_Wiki
- type: test
  name: CHIP-8 Test Suite
  url: https://github.com/Timendus/chip8-test-suite
- type: test
  name: Blargg's Game Boy Test ROMs
  url: https://github.com/retrio/gb-test-roms
prerequisites:
- type: skill
  name: Binary/hex arithmetic
- type: skill
  name: Assembly basics (any ISA)
- type: skill
  name: Basic graphics programming (framebuffer/SDL/similar)
milestones:
- id: build-emulator-m1
  name: CPU Core and Memory
  description: 'Implement the CPU register file, memory address space, ROM loading, and the fetch-decode-execute loop for all instructions in the target ISA.

    '
  acceptance_criteria:
  - 'All CPU registers are implemented with correct bit widths matching the target architecture (CHIP-8: sixteen 8-bit V registers, 16-bit I register, 16-bit PC, 8-bit SP, 8-bit delay/sound timers; GB: 8-bit A/B/C/D/E/H/L, 16-bit SP/PC, flags register)'
  - 'Memory address space covers the full range with correct regions (CHIP-8: 4KB with ROM at 0x200; GB: 64KB with ROM/RAM/IO regions; NES: 64KB with mirroring)'
  - ROM loader reads the binary ROM file and places it at the correct starting address; for GB/NES, the ROM header is parsed to determine mapper type and memory configuration
  - Fetch-decode-execute cycle reads the opcode at PC, decodes it, executes the correct handler, and advances PC appropriately
  - All documented opcodes are implemented and produce correct register and memory side effects, validated against at least one community test ROM
  - CPU flags (where applicable) are updated correctly after each arithmetic and logic instruction
  - Stack operations (push/pop/call/return) correctly manage the stack pointer and return addresses
  - Undefined/illegal opcodes are trapped and reported rather than silently ignored
  pitfalls:
  - Endianness varies by platform (CHIP-8 is big-endian, GB is little-endian); opcode decoding must use the correct byte order
  - Flag edge cases in half-carry (GB) or decimal mode (6502) are common sources of subtle bugs that only manifest in specific games
  - CHIP-8 has two common instruction variants (COSMAC VIP vs SUPER-CHIP) for shift and store/load instructions; document which variant is implemented
  - 'For GB/NES: undocumented/illegal opcodes exist and some games use them; initially these can be trapped but may need implementation later'
  - Test ROMs are essential for validation; do not skip this step as manual testing misses subtle instruction bugs
  concepts:
  - CPU architecture and register files
  - Instruction set encoding and decoding
  - Memory address space layout
  - ROM format and loading
  skills:
  - Binary arithmetic and bitwise operations
  - Register manipulation and state management
  - Opcode decoding and dispatch (switch/table)
  - Low-level debugging with hex dumps and test ROMs
  deliverables:
  - Register file implementation with all registers for the target CPU
  - Memory address space with correct region mapping and access control
  - ROM loader placing binary at correct address with header parsing (if applicable)
  - Fetch-decode-execute loop with complete instruction set implementation
  - Test ROM validation passing at least one community CPU test suite
  estimated_hours: 15-30
- id: build-emulator-m2
  name: Interrupts and Timers
  description: 'Implement the interrupt system and hardware timers that drive CPU-peripheral communication. This is required before graphics and input can function correctly.

    '
  acceptance_criteria:
  - 'Interrupt controller correctly prioritizes and dispatches interrupts to the CPU when interrupts are enabled (CHIP-8: delay/sound timer decrement at 60Hz; GB: V-Blank, LCD STAT, Timer, Serial, Joypad; NES: NMI for V-Blank, IRQ for mapper/APU)'
  - Interrupt handling pushes the current PC onto the stack, disables further interrupts (if applicable), and jumps to the correct interrupt vector address
  - Interrupt enable/disable instructions (e.g., EI/DI on GB, CLI/SEI on 6502) correctly toggle the interrupt master flag
  - Hardware timers count down or up at the correct rate relative to the CPU clock and trigger interrupts on overflow/expiry
  - 'For CHIP-8: delay timer and sound timer decrement at 60Hz regardless of instruction execution speed'
  - 'For GB/NES: V-Blank interrupt fires at the correct point in the frame cycle (after the last visible scanline)'
  - Timer accuracy is validated by running a timer-specific test ROM (if available for target platform)
  pitfalls:
  - 'Interrupt timing is critical: interrupts should be checked between instructions, not mid-instruction (for instruction-level accuracy)'
  - On GB, the EI instruction enables interrupts after the NEXT instruction, not immediately; this one-instruction delay is commonly missed
  - On NES, NMI is edge-triggered (fires once per V-Blank), not level-triggered; missing this causes double-fire bugs
  - CHIP-8 timers must decrement independently of CPU speed; tying timer decrement to instruction count causes variable-speed timer behavior
  - Interrupt priority ordering must be correct; wrong priority causes the wrong handler to execute when multiple interrupts are pending
  concepts:
  - Hardware interrupts (IRQ, NMI)
  - Interrupt vectors and handler dispatch
  - Timer hardware and clock dividers
  - Interrupt priority and masking
  skills:
  - Interrupt controller implementation
  - Timer-driven event scheduling
  - CPU state save/restore on interrupt
  - Clock synchronization between subsystems
  deliverables:
  - Interrupt controller with priority-based dispatch
  - Hardware timer implementation decrementing at correct clock-relative rate
  - Interrupt enable/disable flag management
  - Interrupt vector jump with PC push and state save
  - Timer test ROM validation (if available)
  estimated_hours: 8-15
- id: build-emulator-m3
  name: Graphics Rendering
  description: 'Implement the display system. For CHIP-8: XOR sprite drawing on a 64x32 monochrome display. For GB/NES: tile/sprite-based PPU with scanline rendering.

    '
  acceptance_criteria:
  - 'Screen rendering produces correct visual output at the target platform''s native resolution (CHIP-8: 64x32 pixels; GB: 160x144; NES: 256x240)'
  - 'For CHIP-8: sprites are drawn via XOR onto the framebuffer and the VF collision flag is set correctly when any pixel is turned off'
  - 'For GB/NES: background tiles are rendered using the tile map and tile data with correct scrolling offsets applied'
  - 'For GB/NES: sprites are rendered with correct positioning, priority (behind/in-front of background), horizontal/vertical flipping, and palette selection'
  - 'For GB/NES: rendering timing matches scanline progression so V-Blank interrupt fires at the correct point'
  - Framebuffer is displayed in a host window at an appropriate scale using SDL, winit, or similar library at the target refresh rate (~60Hz)
  - 'Screen clear operation (CHIP-8: 00E0) correctly resets the framebuffer'
  pitfalls:
  - 'For CHIP-8: sprite wrapping at screen edges varies by implementation; document the chosen behavior (wrap vs clip)'
  - 'For GB/NES: mid-frame register changes (writing to scroll registers or palette during rendering) cause visual effects that simple frame-based rendering misses; this is acceptable as a known limitation for initial implementation'
  - 'For GB/NES: sprite limit per scanline (GB: 10, NES: 8) must be enforced; exceeding it causes sprite flickering as on real hardware'
  - 'For GB/NES: sprite priority rules are complex (lower X position = higher priority on GB; lower OAM index on NES); incorrect implementation causes rendering glitches'
  - Host display scaling must use nearest-neighbor interpolation to preserve pixel-art crispness
  concepts:
  - Framebuffer and pixel manipulation
  - XOR sprite rendering (CHIP-8)
  - Tile and sprite-based rendering (GB/NES)
  - Scanline timing and V-Blank
  skills:
  - Framebuffer management and pixel rendering
  - SDL or similar graphics library integration
  - Sprite rendering with priority and layering
  - Scanline-based rendering loops
  deliverables:
  - Framebuffer at target platform's native resolution and color depth
  - Sprite and background rendering engine appropriate to target platform
  - Host window display with scaled framebuffer output at ~60Hz
  - V-Blank timing integration with interrupt system from M2
  estimated_hours: 15-30
- id: build-emulator-m4
  name: Input and Timing Synchronization
  description: 'Map host input devices to the emulated platform''s input system and synchronize overall emulation speed to real-time.

    '
  acceptance_criteria:
  - 'Host keyboard (or gamepad) events are mapped to the target platform''s input format (CHIP-8: 16-key hex keypad; GB: 8 buttons via joypad register; NES: 8 buttons via shift register)'
  - Input state is correctly readable by the emulated program via the platform's input mechanism (memory-mapped register read, shift register strobe)
  - 'Emulation speed is synchronized to real time: the emulator runs at approximately the correct speed (e.g., ~60 FPS) using frame timing, not running as fast as possible'
  - Speed limiting uses a combination of timing (sleep until next frame) and frame counting; processing delay within a frame is accounted for
  - Pause and resume functionality allows halting and continuing emulation
  - 'For CHIP-8: the Fx0A (wait for key press) instruction correctly blocks execution until a key is pressed and released'
  - 'For GB/NES: cycle-accurate timing ensures CPU instructions consume the correct number of machine cycles, and the PPU/timer step in lockstep with the CPU at the correct ratio'
  pitfalls:
  - Running the emulator as fast as possible without frame limiting makes games unplayable and timers inaccurate
  - Sleeping for the exact frame duration ignores processing time within the frame; measure elapsed time and sleep only the remainder
  - 'For GB/NES: the relationship between CPU cycles and PPU dots must be maintained (GB: 1 CPU cycle = 4 PPU dots; NES: 1 CPU cycle = 3 PPU dots); drifting this ratio causes graphical and timing glitches'
  - Input polling must happen at the right frequency; polling too rarely causes missed short key presses; polling too frequently wastes CPU
  - CHIP-8 key-wait instruction must wait for key RELEASE, not just key press (per original COSMAC VIP behavior)
  concepts:
  - Input device emulation and mapping
  - Real-time synchronization and frame limiting
  - Cycle-ratio synchronization between subsystems
  - Host event loop integration
  skills:
  - Input polling and event handling
  - Frame rate limiting and timing
  - Cycle-accurate subsystem synchronization
  - Host platform event loop integration
  deliverables:
  - Input mapping from host keyboard/gamepad to emulated platform buttons
  - Frame timing synchronization limiting emulation to real-time speed
  - Cycle-accurate subsystem stepping (CPU, PPU, timers in lockstep)
  - Pause/resume and basic emulator controls
  estimated_hours: 10-20
- id: build-emulator-m5
  name: Audio and Polish (Advanced)
  description: 'Implement audio output and overall polish. For CHIP-8: simple beep tone when sound timer > 0. For GB/NES: multi-channel audio synthesis.

    '
  acceptance_criteria:
  - 'For CHIP-8: a tone is played when the sound timer is non-zero and stops when it reaches zero'
  - 'For GB: the four audio channels (two square waves, one programmable wave, one noise) produce correct output based on their register configuration'
  - 'For NES: the five audio channels (two pulse, triangle, noise, DMC) produce correct output'
  - Audio samples are generated at the correct rate and fed to the host audio system (e.g., SDL audio callback) without buffer underruns or overruns
  - Audio timing is synchronized with CPU execution so that audio register writes take effect at the correct time
  - The emulator successfully runs at least 3 well-known ROMs for the target platform with correct behavior (graphics, input, timing, audio)
  pitfalls:
  - 'Audio buffer size tradeoff: too small causes underruns and clicks; too large causes noticeable latency'
  - Audio sample generation must happen at a consistent rate regardless of frame rate variation
  - 'For GB/NES: audio channel mixing must prevent clipping; normalize or clamp the combined output'
  - Audio is often the last system implemented but timing bugs in earlier subsystems manifest as audio glitches; validate CPU and timer accuracy first
  - Some games rely on precise audio timing for gameplay synchronization; audio-visual sync issues indicate underlying timing bugs
  concepts:
  - Audio synthesis and waveform generation
  - Audio buffer management and sample rates
  - Host audio API integration
  - Multi-channel audio mixing
  skills:
  - Digital audio fundamentals
  - Audio callback/buffer programming
  - Waveform synthesis
  - Audio-visual synchronization
  deliverables:
  - Audio output producing sound at correct pitch and timing
  - Host audio integration via SDL or platform audio API
  - Audio channel mixing and output normalization
  - End-to-end validation with multiple commercial/community ROMs
  estimated_hours: 12-25
domain: specialized
