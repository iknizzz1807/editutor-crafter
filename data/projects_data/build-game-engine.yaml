id: build-game-engine
name: Build Your Own Game Engine
description: Full 2D game engine with rendering, ECS, physics, asset management, and scene system.
difficulty: expert
estimated_hours: 120-250
essence: 'Real-time rendering pipeline with batched GPU command submission, Entity-Component-System architecture with deferred command buffers, fixed-timestep physics simulation with AABB/circle collision detection and manifold-based impulse resolution, and a resource management pipeline with reference-counted asset caching.

  '
why_important: 'Building a game engine exposes you to systems programming fundamentals that underpin modern game development—from graphics pipeline management and cache-friendly data layouts to deterministic physics simulation and asset lifecycle management. These skills apply to AAA game development, simulation systems, and any performance-critical interactive application.

  '
learning_outcomes:
- Implement window creation and OpenGL rendering pipeline with shader compilation
- Design batched sprite rendering minimizing draw calls
- Build an ECS with sparse-set storage and deferred command buffers
- Implement resource manager with reference-counted caching
- Build AABB and circle collision detection with manifold generation
- Implement impulse-based collision response with positional correction
- Develop fixed-timestep physics with accumulator pattern
- Create scene serialization and transition system
- Design input abstraction layer mapping OS events to engine actions
- Profile and optimize frame timing for 60+ FPS
skills:
- Graphics API Integration
- Memory Layout Optimization
- Entity-Component-System
- Physics Simulation
- Asset Pipeline Design
- Collision Detection & Response
- Performance Profiling
- Systems Programming
tags:
- build-from-scratch
- c++
- ecs
- expert
- framework
- game-dev
- game-loop
- physics
- rendering
- rust
architecture_doc: architecture-docs/build-game-engine/index.md
languages:
  recommended:
  - C++
  - Rust
  also_possible:
  - C
  - Zig
resources:
- type: book
  name: Game Engine Architecture
  url: https://www.gameenginebook.com/
- type: video
  name: Handmade Hero
  url: https://handmadehero.org/
- type: tutorial
  name: Learn OpenGL
  url: https://learnopengl.com/
- type: book
  name: Game Programming Patterns
  url: https://gameprogrammingpatterns.com/
prerequisites:
- type: skill
  name: OpenGL or Vulkan basics
- type: skill
  name: Linear algebra (matrices, vectors)
- type: skill
  name: C++ or Rust proficiency
- type: skill
  name: Understanding of ECS pattern
- type: project
  name: 'Recommended: Complete ECS Architecture project first'
milestones:
- id: build-game-engine-m1
  name: Window, Input & Core Loop
  description: 'Create the engine foundation: window, input abstraction, core game loop with fixed-timestep update and variable-rate rendering.

    '
  acceptance_criteria:
  - Window created with configurable resolution and title using SDL2 or GLFW
  - OS input events (keyboard, mouse) are captured and mapped to an engine input abstraction layer
  - Input system provides is_key_pressed(), is_key_just_pressed(), mouse_position() API
  - Core loop implements fixed-timestep update with accumulator (e.g., 60 Hz physics tick)
  - Render phase runs at monitor refresh rate, decoupled from update rate
  - Delta time is computed and passed to update functions
  - 'Frame timing is measurable: FPS counter available'
  - Clean shutdown releases all OS resources
  pitfalls:
  - Variable timestep physics causes non-deterministic behavior
  - Input polling in wrong phase (before/after update) causes one-frame latency
  - 'Accumulator spiral of death: if update takes too long, accumulator grows unbounded'
  - Forgetting to cap accumulator to prevent hundreds of physics steps per frame
  concepts:
  - Fixed timestep with accumulator
  - Input abstraction
  - Game loop architecture
  skills:
  - Window management and OS event handling
  - Fixed-timestep game loop design
  - Input system abstraction
  deliverables:
  - Window creation with configurable resolution
  - Input abstraction layer mapping OS events to engine queries
  - Fixed-timestep game loop with accumulator
  - Frame timing and FPS measurement
  estimated_hours: 10-15
- id: build-game-engine-m2
  name: Rendering & Resource Management
  description: 'Implement OpenGL rendering pipeline with batched sprite drawing, shader compilation, texture loading, and a resource manager with reference-counted caching.

    '
  acceptance_criteria:
  - OpenGL context initialized; screen clears to solid color each frame
  - Shader system compiles vertex + fragment shaders, reports errors with line numbers
  - Texture loader reads PNG/JPG from disk, uploads to GPU, returns a handle
  - 'Resource manager caches loaded assets: duplicate load requests return same handle'
  - Reference counting tracks asset usage; assets freed when reference count reaches zero
  - 'Batched sprite renderer: multiple sprites sharing a texture are drawn in a single draw call'
  - Sprites support position, rotation, scale, and tint color
  - Rendering 10,000 sprites at 60 FPS (measurable benchmark)
  - Resource handles are invalidated on unload; using a stale handle produces an error, not a crash
  pitfalls:
  - OpenGL state leaks from not unbinding buffers/shaders between draws
  - Shader compilation errors silently ignored—always check glGetShaderiv
  - One draw call per sprite destroys performance (must batch)
  - Resource reference count off-by-one causes premature free or leak
  - Texture upload with wrong format/alignment causes garbled rendering
  concepts:
  - GPU rendering pipeline
  - Sprite batching
  - Resource lifecycle management
  - Reference counting
  skills:
  - OpenGL/Vulkan API usage
  - GLSL shader programming
  - Sprite batching and draw call optimization
  - Reference-counted resource management
  deliverables:
  - OpenGL context and render pipeline setup
  - Shader compilation and linking system
  - Texture loader with GPU upload
  - Resource manager with caching and reference counting
  - Batched sprite renderer
  - Benchmark: 10K sprites at 60 FPS
  estimated_hours: 20-35
- id: build-game-engine-m3
  name: Entity Component System
  description: 'Implement ECS with entity ID management, sparse-set component storage, system scheduling, and command buffers for safe structural changes during iteration.

    '
  acceptance_criteria:
  - Entity creation returns generational ID; destruction recycles index with incremented generation
  - Component storage uses sparse-set with contiguous dense arrays for cache-friendly iteration
  - add_component, remove_component, get_component, has_component all operate in O(1) amortized time
  - Systems registered with World execute in defined order each tick
  - Component queries iterate only entities possessing all required component types
  - Command buffer defers entity create/destroy and component add/remove until after system execution
  - Entity destruction cleans up all associated components
  - 'Integration test: TransformSystem + SpriteSystem correctly update and render 1000 entities'
  pitfalls:
  - Modifying components during iteration without command buffer corrupts sparse set
  - Memory fragmentation from frequent entity create/destroy without pooling
  - System ordering dependencies not declared—render system runs before transform update
  - Component storage not integrated with rendering—ECS and renderer are disconnected
  concepts:
  - Entity-Component-System architecture
  - Sparse-set storage
  - Command buffer pattern
  - System scheduling
  skills:
  - Data-oriented design
  - Generational ID management
  - Command buffer implementation
  - Cache-friendly data structures
  deliverables:
  - Generational entity ID manager with free list recycling
  - Sparse-set component storage with type-safe access
  - System scheduler with ordered execution
  - Command buffer for deferred structural changes
  - Integration with renderer: SpriteComponent + TransformComponent renders entities
  estimated_hours: 20-30
- id: build-game-engine-m4
  name: Physics & Collision
  description: 'Implement 2D rigid body physics with AABB and circle collision detection, manifold generation, and impulse-based response.

    '
  acceptance_criteria:
  - Rigid bodies have mass, velocity, acceleration, and restitution properties
  - Gravity and forces applied via semi-implicit Euler integration at fixed timestep
  - AABB-vs-AABB collision detection correctly identifies overlapping pairs
  - Circle-vs-circle collision detection correctly identifies overlapping pairs
  - AABB-vs-circle collision detection correctly identifies overlapping pairs
  - 'Collision manifold generated for each collision pair: contact normal, penetration depth, contact point(s)'
  - Impulse-based response separates overlapping bodies and adjusts velocities based on manifold and restitution
  - Positional correction prevents objects from sinking into each other over time
  - Spatial partitioning (uniform grid or quadtree) reduces broad-phase from O(n²) to O(n log n) or better
  - 'Physics timestep is fixed and deterministic: same inputs produce same outputs regardless of frame rate'
  - Objects stack stably (e.g., boxes on a floor don't jitter or explode)
  pitfalls:
  - Variable timestep in physics causes non-deterministic and unstable behavior
  - 'Tunneling: fast objects pass through thin walls—need CCD or velocity capping'
  - Impulse without positional correction causes slow sinking
  - Missing manifold makes impulse direction arbitrary—objects bounce in wrong directions
  - Collision jitter from insufficient solver iterations or incorrect restitution handling
  concepts:
  - Rigid body dynamics
  - Collision manifold generation
  - Impulse-based resolution
  - Spatial partitioning
  skills:
  - Numerical integration (semi-implicit Euler)
  - Manifold generation algorithms
  - Vector math for impulse computation
  - Spatial data structures
  deliverables:
  - Rigid body component with mass, velocity, restitution
  - AABB, circle, and AABB-circle collision detection
  - Collision manifold generator (normal, depth, contact points)
  - Impulse-based collision response with positional correction
  - Spatial partitioning for broad-phase
  - Fixed-timestep integration
  estimated_hours: 25-40
- id: build-game-engine-m5
  name: Scene System & Serialization
  description: 'Implement scene management with save/load, scene transitions, hierarchical transforms, and a demonstration game using all engine systems.

    '
  acceptance_criteria:
  - Scene serialization writes all entities and their components to a JSON or binary file
  - Scene deserialization recreates the exact entity/component state from a saved file
  - Scene transitions unload current scene resources and load new scene without memory leaks
  - 'Hierarchical transform: child entities inherit parent transform (position, rotation, scale propagation)'
  - Resource manager correctly frees assets no longer referenced after scene unload
  - 'A playable demo game (e.g., simple platformer or shooter) uses all engine systems: rendering, ECS, physics, input, scenes'
  - Demo runs at 60 FPS with no memory leaks (verified by memory profiler or leak sanitizer)
  - 'Engine API is documented: creating entities, adding components, registering systems, loading scenes'
  pitfalls:
  - 'Serialization version incompatibility: adding a new component field breaks old save files'
  - Scene transition corrupting global state (e.g., input system, physics world not reset)
  - Hierarchical transform cycles causing infinite recursion
  - Memory leaks from resources loaded but never freed during scene transitions
  - Demo game exposing integration bugs between subsystems
  concepts:
  - Scene serialization
  - Hierarchical transforms
  - Resource lifecycle
  - Engine integration
  skills:
  - Serialization and deserialization
  - Transform hierarchy propagation
  - Memory leak detection
  - Full-system integration
  deliverables:
  - Scene save/load system (JSON or binary format)
  - Scene transition with resource cleanup
  - Hierarchical transform component with parent-child propagation
  - Playable demo game exercising all engine subsystems
  - Engine API documentation
  estimated_hours: 20-30
domain: game-dev
