id: build-interpreter
name: Build Your Own Interpreter (Lox)
description: 'Complete interpreter implementation following Crafting Interpreters: scanner, parser, tree-walking evaluator, closures, classes, and inheritance with optional compile-time variable resolution.'
difficulty: expert
estimated_hours: 55
essence: Recursive descent parsing, abstract syntax tree traversal, lexical scanning with finite automata, and environment-based variable binding with lexical scoping rules, optionally enhanced with compile-time resolution for performance.
why_important: Building an interpreter from scratch demystifies how programming languages work internally and teaches foundational compiler theory that applies to debuggers, static analyzers, transpilers, and any tool that processes code.
learning_outcomes:
- Build a scanner that tokenizes source code with error recovery
- Implement recursive descent parsing for expressions and statements
- Design AST node types with visitor pattern support
- Implement tree-walking interpretation with environments
- Build closures with proper lexical scope capture
- Implement classes, instances, methods, and inheritance
skills:
- Lexical Analysis
- Recursive Descent Parsing
- AST Design
- Tree-Walking Interpretation
- Closure Implementation
- Object-Oriented Runtime
tags:
- interpreter
- lox
- crafting-interpreters
- expert
- complete-implementation
architecture_doc: architecture-docs/build-interpreter/index.md
languages:
  recommended:
  - Java
  - C
  - Rust
  also_possible:
  - Python
  - Go
  - JavaScript
resources:
- name: Crafting Interpreters
  url: https://craftinginterpreters.com/
  type: book
- name: Lox Language Spec
  url: https://github.com/munificent/craftinginterpreters/blob/master/note/answers/appendix-ii.md
  type: documentation
- name: Crafting Interpreters Source
  url: https://github.com/munificent/craftinginterpreters
  type: code
prerequisites:
- type: skill
  name: Programming fundamentals
- type: skill
  name: Tree data structures
- type: skill
  name: Recursion
milestones:
- id: build-interpreter-m1
  name: Scanner (Lexer)
  description: Build a scanner that converts Lox source code into tokens.
  acceptance_criteria:
  - Scanner recognizes all language tokens including keywords (var, fun, if, else, while, for, return, class, etc.)
  - String literals with double quotes and number literals with optional decimal points are correctly tokenized
  - Line numbers are tracked and reported accurately for each token to support meaningful error messages
  - Whitespace and comments (single-line // and optionally block /* */) are consumed and ignored between tokens
  - Lexical errors such as unterminated strings or unrecognized characters are reported with their source location
  pitfalls:
  - 'Confusing = and ==: single = is assignment, == is equality'
  - 'Not handling unterminated strings: report error at the opening quote'
  - 'Newlines inside strings: decide if allowed or error'
  concepts:
  - Lexical analysis converts characters to tokens
  - Token representation includes type, lexeme, literal value, and location
  - Error recovery continues scanning after errors
  skills:
  - Finite state machines
  - Character-by-character processing
  - Token stream generation
  - Lexer error reporting
  deliverables:
  - Character stream to token stream converter that reads source code and emits a sequence of typed tokens
  - Token type definitions for keywords, identifiers, string literals, number literals, and operators
  - Line and column tracking that records the source position of each token for error reporting
  - String and number literal scanner that handles quoted strings with escape sequences and decimal numbers
  estimated_hours: 3
- id: build-interpreter-m2
  name: Representing Code (AST)
  description: Define the abstract syntax tree classes for Lox with visitor pattern.
  acceptance_criteria:
  - Expression node classes cover binary, unary, grouping, literal, variable, assign, call, and logical expressions
  - Statement node classes cover print, expression-statement, variable declaration, block, if, while, function, return, and class
  - Visitor pattern implementation enables type-safe traversal without modifying node classes
  - Pretty-printer using the visitor pattern outputs readable S-expression format for debugging
  pitfalls:
  - 'Visitor pattern boilerplate: consider code generation to reduce manual work'
  - 'Mutable vs immutable AST nodes: immutable is safer but may complicate optimization passes'
  - 'Parent/child references: avoid circular references that complicate memory management'
  concepts:
  - AST nodes represent program structure as a tree
  - Visitor pattern separates operations from node types
  - Expression vs statement: expressions produce values, statements don't
  skills:
  - Design patterns (Visitor)
  - Type-safe tree structures
  - Code generation from specifications
  - Metaprogramming
  deliverables:
  - Expression AST node classes for all expression types
  - Statement AST node classes for all statement types
  - Visitor pattern implementation enabling type-safe dispatch
  - Pretty printer that formats AST as S-expressions for debugging
  estimated_hours: 3
- id: build-interpreter-m3
  name: Parsing Expressions
  description: Build a recursive descent parser for expressions with correct precedence.
  acceptance_criteria:
  - 'Arithmetic expressions are parsed with correct precedence: * and / bind tighter than + and -'
  - Parenthesized sub-expressions override default precedence and are correctly nested in the AST
  - Comparison (<, >, <=, >=) and equality (==, !=) operators are parsed at their correct precedence levels
  - Syntax errors report the unexpected token, its line number, and a description of what was expected
  pitfalls:
  - Left recursion in grammar causes infinite loop—rewrite grammar to eliminate
  - 'Forgetting closing paren: report error at opening paren location'
  - 'Error recovery: synchronize to statement boundaries after errors'
  concepts:
  - Recursive descent uses one function per grammar rule
  - Operator precedence determines grouping order
  - Error recovery continues parsing after errors
  skills:
  - Recursive algorithms
  - Grammar-based parsing
  - Parse error recovery
  - Operator precedence handling
  deliverables:
  - Recursive descent expression parser with one function per precedence level
  - Operator precedence handling that correctly nests binary operations
  - Grouping expression parsing for parenthesized sub-expressions
  - Unary and binary expression node construction
  estimated_hours: 4
- id: build-interpreter-m4
  name: Evaluating Expressions
  description: Build a tree-walking interpreter to evaluate expressions.
  acceptance_criteria:
  - Arithmetic operations (+, -, *, /) evaluate correctly on numeric operands and return numeric results
  - Unary minus negates a number and unary ! inverts a boolean truthiness value
  - 'Truthiness rules are implemented: nil and false are falsy, all other values are truthy'
  - String concatenation with the + operator joins two string operands
  - Runtime errors are raised when operators are applied to incompatible types
  pitfalls:
  - 'Division by zero: decide if error or Infinity/NaN'
  - 'String + non-string: error or coerce?'
  - 'Java null vs Lox nil: ensure Lox nil is a proper value, not null'
  concepts:
  - Tree-walking visits each node and computes a value
  - Runtime type checking validates operand types
  - Dynamic typing defers type errors to runtime
  skills:
  - Tree traversal algorithms
  - Runtime type checking
  - Dynamic dispatch
  - Arithmetic expression evaluation
  deliverables:
  - Tree-walking evaluator that recursively visits each AST node
  - Runtime value representation supporting numbers, strings, booleans, nil, and callables
  - Runtime type checking for each operation
  - Operator semantics for arithmetic, comparison, equality, and string operations
  estimated_hours: 3
- id: build-interpreter-m5
  name: Statements and State
  description: Add statements, variables, and assignment.
  acceptance_criteria:
  - Print statement evaluates its expression and writes the string representation to stdout
  - Variable declarations with var create a new binding initialized to the expression value or nil
  - Assignment expressions update the value of an existing variable binding in the nearest enclosing scope
  - Expression statements evaluate their expression for side effects and discard the result
  - Environment stores variable bindings and supports nested scopes with parent-chain lookup
  pitfalls:
  - 'Using undeclared variable: error or implicitly declare?'
  - 'Assignment to non-variable: expressions can''t be assigned to'
  - 'Scoping issues: ensure blocks create new scopes'
  concepts:
  - Statements are executed for their side effects
  - Environments map names to values with scope chains
  - Assignment modifies existing bindings
  skills:
  - Symbol tables
  - Variable scoping
  - Environment management
  - State mutation
  deliverables:
  - Print statement that evaluates and outputs its expression
  - Variable declaration that binds a name to a value
  - Environment data structure with nested scope support
  - Block statement that creates a new nested scope
  estimated_hours: 3
- id: build-interpreter-m6
  name: Control Flow
  description: Add if, while, for, and logical operators.
  acceptance_criteria:
  - If/else executes the then-branch when condition is truthy and else-branch (if present) otherwise
  - While loops repeat the body until the condition evaluates to falsy
  - For loops are desugared to a block containing initializer, while loop, and increment
  - 'Logical and/or short-circuit: return left operand if it determines the result'
  pitfalls:
  - 'Dangling else: associate else with nearest if'
  - 'Forgetting short-circuit: logical operators must NOT always evaluate both operands'
  - 'Infinite loops: consider adding a maximum iteration limit for safety'
  concepts:
  - Conditional execution selects between branches
  - Loops repeat code based on conditions
  - Short-circuit evaluation skips unnecessary work
  skills:
  - Control flow implementation
  - Boolean logic optimization
  - Loop transformation
  - AST desugaring
  deliverables:
  - If/else statement execution with branch selection
  - While loop execution with condition checking
  - For loop desugaring to equivalent while loop
  - Logical operators with short-circuit evaluation
  estimated_hours: 3
- id: build-interpreter-m7
  name: Functions
  description: Add function declarations and calls.
  acceptance_criteria:
  - The fun keyword declares a named function and stores it as a callable value
  - Parameters are bound to argument values positionally and accessible as local variables
  - Return statement exits the function immediately and delivers the return value
  - Functions are first-class values that can be stored, passed, and returned
  - Recursive calls work correctly with each invocation getting its own environment
  pitfalls:
  - 'Stack overflow from infinite recursion: add recursion depth limit'
  - 'Not restoring environment after call: ensure caller''s environment is restored'
  - 'Return outside function: detect and report as error'
  concepts:
  - First-class functions can be used as values
  - Call frames isolate function invocations
  - Return unwinds the call stack
  skills:
  - Call stack management
  - Function activation records
  - Return value propagation
  - Recursion handling
  deliverables:
  - Function declaration that creates a callable object
  - Function call that binds arguments and evaluates the body
  - Return statement that exits and delivers a value
  - Local variable scoping within function bodies
  estimated_hours: 4
- id: build-interpreter-m8
  name: Closures
  description: Implement lexical scoping and closures with optional compile-time resolution.
  acceptance_criteria:
  - Functions capture the enclosing environment at definition time
  - Nested functions access and modify variables from enclosing scopes
  - Closures persist and remain usable after the enclosing function has returned
  - Variable resolution at compile time (optional) determines scope depth for performance
  pitfalls:
  - 'Capturing variable vs capturing value: closures must capture the variable, not a copy'
  - 'Variable resolution with shadowing: ensure correct variable is referenced'
  - 'This in closures: document how ''this'' behaves in nested functions'
  concepts:
  - Lexical scoping resolves variables by source code structure
  - Closures capture their defining environment
  - Compile-time resolution (optional) improves performance
  skills:
  - Closure implementation
  - Lexical scope resolution
  - Environment capture
  - Variable lifetime management
  deliverables:
  - Closure implementation that captures the defining environment
  - Free variable resolution from enclosing scopes
  - Closure as a first-class value
  - Optional: compile-time variable resolution for performance
  estimated_hours: 6
- id: build-interpreter-m9
  name: Classes
  description: Add class declarations, instances, and methods.
  acceptance_criteria:
  - The class keyword declares a named class and stores it as a callable class object
  - Calling ClassName() creates a new instance and invokes init() if defined
  - Properties are accessed and assigned using dot notation (instance.field)
  - Methods defined in the class body are callable on instances with 'this' bound to the receiver
  - The init() initializer is automatically called on instance creation
  pitfalls:
  - 'This outside method: accessing ''this'' outside a method is an error'
  - 'Returning from init(): init() should return ''this'' implicitly, not an explicit value'
  - 'Method vs function: methods have implicit ''this'', functions don''t'
  concepts:
  - Classes are templates for objects
  - Instances hold per-object state
  - Methods are functions with implicit 'this' binding
  skills:
  - Object-oriented runtime implementation
  - Instance method dispatch
  - Constructor patterns
  - Runtime object representation
  deliverables:
  - Class declaration that creates a class object
  - Instance creation by calling the class
  - Property get/set using dot notation
  - Method definition with implicit 'this' binding
  estimated_hours: 5
- id: build-interpreter-m10
  name: Inheritance
  description: Add class inheritance and super calls.
  acceptance_criteria:
  - Syntax 'class Derived < Base' creates a subclass that inherits all methods from the superclass
  - Methods defined on the superclass are callable on subclass instances without redefinition
  - super.method() inside a subclass method calls the superclass version, not the override
  - Method resolution looks up the class hierarchy from instance class to superclasses in order
  pitfalls:
  - 'Super outside class: using ''super'' outside a class method is an error'
  - 'Inheriting from non-class: only classes can be superclasses'
  - 'Diamond inheritance: Lox doesn''t support multiple inheritance—document this limitation'
  concepts:
  - Single inheritance allows one superclass per class
  - Super calls bypass the current class's override
  - Method resolution order follows the inheritance chain
  skills:
  - Inheritance mechanism implementation
  - Method lookup chains
  - Super method resolution
  - Class hierarchy management
  deliverables:
  - Superclass specification using < syntax
  - Method inheritance from base class
  - Super keyword for calling superclass methods
  - Initializer chaining with super.init()
  estimated_hours: 4
domain: compilers
