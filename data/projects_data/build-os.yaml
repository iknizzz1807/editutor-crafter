id: build-os
name: "Build Your Own OS"
description: "x86 operating system kernel with interrupts, memory management, and preemptive scheduling"
difficulty: expert
estimated_hours: "120-200"
essence: >
  Bootstrap from firmware to protected mode via GDT configuration, hardware
  interrupt handling through IDT and PIC/APIC, physical and virtual memory
  management with page tables and heap allocation, and preemptive process
  scheduling with context switching and user-mode transitions via TSS.
why_important: >
  Building an OS kernel demystifies the abstraction layer between hardware and
  applications, teaching foundational systems concepts that underlie every modern
  computing platform — from interrupt handling to memory isolation to process scheduling.
learning_outcomes:
  - Implement a bootloader transitioning from real mode to 32-bit protected mode
  - Configure GDT with proper segment descriptors for kernel and user mode
  - Set up IDT and interrupt service routines for CPU exceptions and hardware IRQs
  - Build physical memory allocators (bitmap or buddy)
  - Implement virtual memory with page tables and demand paging
  - Create process control blocks and preemptive context switching
  - Set up TSS for ring 3 → ring 0 transitions
  - Implement system call interface via software interrupts
  - Debug with QEMU, serial port logging, and GDB stubs
skills:
  - x86 Assembly
  - Hardware Interrupts (PIC, APIC)
  - GDT/IDT/TSS Configuration
  - Page Table Management
  - Context Switching
  - Kernel Programming (freestanding)
  - Low-Level Debugging
  - Linker Script Design
tags:
  - bootloader
  - build-from-scratch
  - c
  - expert
  - interrupts
  - kernel
  - rust
  - scheduling
  - systems
  - zig
architecture_doc: architecture-docs/build-os/index.md
languages:
  recommended:
    - C
    - Rust
    - Zig
  also_possible: []
resources:
  - type: book
    name: "Operating Systems: Three Easy Pieces"
    url: "https://pages.cs.wisc.edu/~remzi/OSTEP/"
  - type: tutorial
    name: "Writing an OS in Rust (phil-opp)"
    url: "https://os.phil-opp.com/"
  - type: reference
    name: "OSDev Wiki"
    url: "https://wiki.osdev.org/"
  - type: reference
    name: "Intel Software Developer Manuals"
    url: "https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html"
prerequisites:
  - type: skill
    name: "x86 assembly language (AT&T or NASM syntax)"
  - type: skill
    name: "C programming (freestanding, no stdlib)"
  - type: skill
    name: "Computer architecture (registers, stack, memory bus)"
  - type: skill
    name: "Binary and hexadecimal arithmetic"
milestones:
  - id: build-os-m1
    name: "Bootloader, GDT, and Kernel Entry"
    description: >
      Boot from BIOS, configure the GDT for protected mode, load the kernel
      into memory, and transfer control to kernel C code.
    acceptance_criteria:
      - "Bootloader fits in 512 bytes (MBR) or uses a two-stage approach (stage1 in MBR loads stage2 from disk)"
      - "Bootloader reads kernel binary from disk using BIOS INT 13h and loads it to a known physical address (e.g., 0x100000)"
      - "GDT is configured with at least 5 entries: null descriptor, kernel code (ring 0, base=0, limit=4GB, executable+readable), kernel data (ring 0, base=0, limit=4GB, writable), user code (ring 3), user data (ring 3)"
      - "Protected mode is entered by setting CR0.PE bit after loading GDTR; a far jump to the kernel code segment flushes the pipeline"
      - "Segment registers (DS, ES, FS, GS, SS) are loaded with the kernel data segment selector after the far jump"
      - "Kernel entry point (in C) zeroes the BSS section (from __bss_start to __bss_end as defined in linker script) and calls main()"
      - "VGA text mode driver writes characters with foreground/background color attributes to 0xB8000"
      - "Serial port (COM1, 0x3F8) is initialized for debug output; kprintf-like function outputs to both VGA and serial"
      - "Kernel boots successfully in QEMU and displays a welcome message on screen and serial console"
    pitfalls:
      - "GDT misconfiguration is the #1 cause of triple-faults; verify base=0, limit=0xFFFFF, granularity=4KB, and correct access bytes for each segment"
      - "Forgetting the far jump after setting CR0.PE leaves the CPU in an inconsistent state with real-mode CS"
      - "Not disabling interrupts (cli) before loading GDT and entering protected mode; stale IVT entries cause immediate faults"
      - "Linker script must place kernel at the correct virtual/physical address; mismatch causes garbage execution"
      - "BSS is not guaranteed to be zero on bare metal; zeroing it is the kernel's responsibility (no CRT0)"
      - "A20 line must be enabled for addresses above 1MB; on some hardware it's disabled by default"
    concepts:
      - x86 boot process (BIOS → MBR → kernel)
      - Global Descriptor Table and segmentation
      - Real mode → protected mode transition
      - Freestanding C environment
    skills:
      - x86 assembly for boot code
      - GDT configuration
      - Linker script design
      - Serial port I/O
      - VGA text mode
    deliverables:
      - Bootloader (stage1 + optional stage2) loading kernel from disk
      - GDT with null, kernel code, kernel data, user code, user data descriptors
      - Protected mode transition with far jump and segment register reload
      - BSS zeroing and C entry point
      - VGA text mode driver with color support
      - Serial port debug output driver
      - Linker script placing kernel sections at correct addresses
    estimated_hours: "20-30"

  - id: build-os-m2
    name: "Interrupts, Exceptions, and Keyboard"
    description: >
      Set up the IDT, PIC, interrupt handlers for CPU exceptions and
      hardware IRQs, and a PS/2 keyboard driver.
    acceptance_criteria:
      - "IDT contains 256 entries; entries 0-31 handle CPU exceptions (divide error, page fault, GPF, etc.) with descriptive error messages"
      - "Interrupt handlers save all general-purpose registers on entry and restore them before iret; error code is popped for exceptions that push one"
      - "PIC (8259) is remapped so IRQ0-7 map to vectors 32-39 and IRQ8-15 map to vectors 40-47, avoiding conflicts with CPU exception vectors 0-31"
      - "EOI (End of Interrupt) is sent to the correct PIC (master or slave) at the end of each IRQ handler"
      - "Timer interrupt (IRQ0, PIT channel 0) fires at a configurable frequency (e.g., 100Hz); a global tick counter is incremented on each interrupt"
      - "Keyboard interrupt (IRQ1) reads PS/2 scancode from port 0x60 and converts to ASCII using a scancode-to-ASCII table; characters are placed in a keyboard buffer"
      - "Double fault (exception 8) handler catches cascading faults and halts with a diagnostic message instead of triple-faulting"
      - "Interrupts are enabled (sti) after IDT and PIC setup is complete"
    pitfalls:
      - "Forgetting to send EOI causes the PIC to stop delivering interrupts; the system appears to hang"
      - "PIC remapping: the default mapping overlaps CPU exceptions (IRQ0=vector 8=double fault); this must be remapped BEFORE enabling interrupts"
      - "Not saving/restoring all registers in interrupt handlers causes mysterious register corruption in interrupted code"
      - "Exceptions 8 (double fault), 10-14 push an error code; others don't; the handler must account for this or the stack frame is misaligned"
      - "PS/2 keyboard sends make AND break codes; ignoring break codes causes repeated character issues"
    concepts:
      - Interrupt Descriptor Table
      - Programmable Interrupt Controller (8259 PIC)
      - CPU exception handling
      - Hardware device drivers
    skills:
      - IDT configuration
      - PIC programming (ICW1-ICW4)
      - Interrupt service routine development
      - PS/2 keyboard protocol
    deliverables:
      - IDT with 256 entries and proper gate types
      - CPU exception handlers (0-31) with error messages
      - PIC remapping and EOI handling
      - PIT timer at configurable frequency with tick counter
      - PS/2 keyboard driver with scancode-to-ASCII conversion
      - Keyboard input buffer
    estimated_hours: "15-25"

  - id: build-os-m3
    name: "Physical and Virtual Memory Management"
    description: >
      Implement physical frame allocator, page tables for virtual memory,
      and a kernel heap allocator.
    acceptance_criteria:
      - "Physical memory map is obtained from multiboot info or E820 memory map; regions are classified as usable, reserved, or ACPI"
      - "Physical frame allocator (bitmap or free-list) allocates and frees individual 4KB page frames; double-free and allocating reserved frames are prevented"
      - "Page directory and page tables are set up for identity-mapping the first N MB (covering kernel + VGA + MMIO) and higher-half mapping the kernel (e.g., kernel at 0xC0000000 virtual)"
      - "Paging is enabled by loading CR3 with the page directory physical address and setting CR0.PG bit"
      - "TLB is flushed (invlpg or full CR3 reload) after modifying page table entries"
      - "Page fault handler (exception 14) reads CR2 for faulting address and prints diagnostic info (address, error code: present/write/user)"
      - "Kernel heap allocator (kmalloc/kfree) provides dynamic memory allocation from a dedicated virtual address range; uses the page allocator for backing frames"
      - "Identity map is kept for low memory so VGA (0xB8000) and MMIO regions remain accessible at their physical addresses"
    pitfalls:
      - "Enabling paging without identity-mapping the currently executing code causes an immediate page fault on the next instruction"
      - "Not flushing the TLB after page table changes causes stale translations; invlpg flushes a single page, CR3 reload flushes all"
      - "Page directory/table entries have specific flag bits (present, writable, user-accessible, write-through, cache-disable); wrong flags cause faults or security holes"
      - "Physical frame allocator must not allocate frames used by the kernel binary, page tables, or multiboot data"
      - "Higher-half kernel mapping requires the linker script to use virtual addresses while the boot code uses physical addresses until paging is on"
    concepts:
      - Physical memory allocation
      - x86 paging (two-level: PD + PT on 32-bit)
      - Higher-half kernel mapping
      - TLB management
    skills:
      - Page table implementation
      - Physical frame allocator
      - CR3/CR0 register manipulation
      - Kernel heap design
    deliverables:
      - Memory map parser (E820 or multiboot)
      - Physical frame allocator (bitmap-based)
      - Page directory and page table setup
      - Identity mapping + higher-half kernel mapping
      - Paging enablement (CR0.PG + CR3)
      - Page fault handler reading CR2
      - Kernel heap allocator (kmalloc/kfree)
    estimated_hours: "30-45"

  - id: build-os-m4
    name: "Processes and Preemptive Scheduling"
    description: >
      Implement process control blocks, context switching, preemptive round-robin
      scheduling, TSS for ring transitions, and a basic system call interface.
    acceptance_criteria:
      - "Process control block (PCB) stores: PID, register state (EIP, ESP, EBP, general regs, EFLAGS), page directory pointer, process state (ready/running/blocked), and kernel stack pointer"
      - "Context switch saves current process registers to its PCB and loads the next process's registers; implemented in assembly for correctness"
      - "TSS (Task State Segment) is configured with the kernel stack pointer (SS0: ESP0) so the CPU knows which stack to use when transitioning from ring 3 to ring 0 on interrupt/syscall"
      - "Timer interrupt (IRQ0) triggers the scheduler; scheduler selects the next ready process in round-robin order and performs a context switch"
      - "At least 3 kernel-mode processes run concurrently, each printing to a different screen region, demonstrating preemptive multitasking"
      - "User-mode processes: at least one process runs in ring 3 with its own page directory; accessing kernel memory from user mode triggers a page fault (user-bit not set)"
      - "System call interface via INT 0x80: user-mode process triggers a software interrupt; kernel reads syscall number from EAX and arguments from EBX/ECX/EDX; at minimum implement sys_write and sys_exit"
      - "TSS ESP0 is updated on every context switch to point to the current process's kernel stack top"
    pitfalls:
      - "Context switch must save ALL registers including EFLAGS; missing a register causes subtle corruption that manifests much later"
      - "TSS is required for ring 3 → ring 0 transitions; without it, the CPU doesn't know what kernel stack to use and triple-faults"
      - "Stack corruption during context switch: each process needs its own kernel stack; reusing the same stack corrupts saved state"
      - "Preemptive scheduling requires re-enabling interrupts after the context switch or the system freezes"
      - "Not disabling interrupts during critical sections of the context switch causes nested interrupts and stack overflow"
      - "User-mode processes need their own page directory with kernel pages mapped but marked supervisor-only"
    concepts:
      - Process control blocks
      - Context switching (register save/restore)
      - Preemptive scheduling with timer interrupts
      - Task State Segment for privilege transitions
      - System call interface
    skills:
      - Context switch assembly
      - TSS configuration
      - Scheduler design
      - Ring 0/Ring 3 transitions
      - System call dispatch
    deliverables:
      - Process control block structure
      - Context switch routine (assembly)
      - TSS setup and per-process ESP0 update
      - Round-robin scheduler triggered by timer interrupt
      - Kernel-mode multi-process demo
      - User-mode process with ring 3 segments
      - System call handler (INT 0x80) with sys_write and sys_exit
    estimated_hours: "35-55"