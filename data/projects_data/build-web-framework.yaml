id: build-web-framework
name: Build Your Own Web Framework
description: Express/Django-like HTTP framework with routing, middleware pipeline, body parsing, and template engine
difficulty: expert
estimated_hours: 45-75
essence: 'HTTP server abstraction with trie-based path-to-handler routing, chain-of-responsibility middleware pipeline for request/response transformation, body parsing as middleware, and string-based template rendering with variable interpolation and inheritance.

  '
why_important: 'Building a web framework reveals the abstractions underlying all modern web development, teaching you how Express, Django, and Flask actually work under the hood and enabling you to architect scalable web applications with deep understanding of the request processing pipeline.

  '
learning_outcomes:
- Implement URL routing with parameterized path extraction using trie or regex-based matching
- Design middleware pipeline using chain-of-responsibility pattern for request/response transformation
- Build body parsing middleware for JSON, form-urlencoded, and multipart data
- Implement response helper methods for status codes, headers, and content-type negotiation
- Create template engine with variable interpolation, loops, conditionals, and template inheritance
- Design plugin architecture for extensibility and third-party middleware integration
- Handle error propagation through middleware stack with dedicated error handler middleware
- Implement route grouping, prefixing, and nested routing with correct middleware scoping
skills:
- HTTP Protocol Design
- Middleware Architecture
- URL Pattern Matching (Trie/Regex)
- Request/Response Handling
- Template Engines
- Chain of Responsibility
- Parser Implementation
- Plugin Systems
tags:
- api
- build-from-scratch
- expert
- framework
- go
- javascript/node.js
- middleware
- python
- routing
- templating
- web
architecture_doc: architecture-docs/build-web-framework/index.md
languages:
  recommended:
  - JavaScript/Node.js
  - Python
  - Go
  also_possible:
  - Ruby
  - Rust
resources:
- type: repository
  name: Express.js source
  url: https://github.com/expressjs/express
- type: article
  name: Build Express from Scratch
  url: https://www.freecodecamp.org/news/express-explained-with-examples-installation-routing-middleware-and-more/
prerequisites:
- type: skill
  name: HTTP server basics (raw TCP or built-in HTTP module)
- type: skill
  name: Request/response handling
- type: skill
  name: Basic routing concepts
- type: skill
  name: Regular expressions or trie data structures
milestones:
- id: build-web-framework-m1
  name: Routing Engine
  description: 'Implement a URL routing engine that maps HTTP method + URL pattern pairs to handler functions, supporting parameterized paths, static-segment priority, route groups, and proper 404/405 responses.

    '
  acceptance_criteria:
  - Route registration associates HTTP methods (GET, POST, PUT, DELETE, PATCH) with URL patterns and handler functions
  - 'URL parameters like /users/: id extract named values accessible as a key-value map (e.g., {id: "42"}) from matching path segments'
  - Route matching uses a trie (radix tree) or compiled regex per route; linear scan of raw string patterns is not acceptable for more than 100 routes
  - 'Static path segments take priority over parameterized segments: /users/admin matches before /users/:id'
  - Unmatched paths return 404 Not Found; paths matching a route but with wrong HTTP method return 405 Method Not Allowed with an Allow header listing valid methods
  - Route groups share a common prefix so /api/users and /api/posts share the /api prefix, and groups can be nested
  - 'Trailing slashes are normalized: /users/ and /users match the same route (or redirect, configurable)'
  - Wildcard/catch-all routes like /files/*path capture the remaining path as a single parameter
  pitfalls:
  - Linear scan route matching becomes O(n) per request; trie-based matching is O(path length) and should be the target
  - 'Route ordering ambiguity between /users/: id and /users/admin leads to bugs if static segments don''t take priority'
  - URL-encoded characters (%20, %2F) in path segments must be decoded before matching
  - Trailing slash inconsistency causes subtle 404s; must have an explicit normalization policy
  - Forgetting to return 405 (instead of 404) when the path matches but method doesn't violates HTTP semantics
  concepts:
  - Trie/radix tree for URL matching
  - HTTP method dispatching
  - URL parameter extraction
  - Route precedence rules
  skills:
  - Trie or regex-based pattern matching
  - HTTP method semantics
  - URL encoding/decoding
  - RESTful API route design
  deliverables:
  - Route registration API mapping method + pattern to handler
  - Trie-based or compiled-regex route matcher with O(path-length) lookup
  - URL parameter extraction returning key-value map
  - Route group/prefix support with nesting
  - 404 and 405 response generation with Allow header
  - Wildcard/catch-all route support
  estimated_hours: 8-12
- id: build-web-framework-m2
  name: Middleware Pipeline
  description: 'Implement a middleware pipeline where middleware functions execute in registration order, transforming request/response objects. Support global middleware, route-scoped middleware, and a dedicated error-handling middleware signature.

    '
  acceptance_criteria:
  - Middleware executes in registration order before the request reaches the matched route handler
  - Calling next() passes control to the next middleware; NOT calling next() short-circuits the pipeline (e.g., for auth rejection)
  - 'Async middleware is supported: if a middleware or next() returns a Promise, rejected promises propagate as errors to the error handler'
  - 'Error-handling middleware has a distinct signature (e.g., 4-argument: err, req, res, next) and is invoked when any middleware throws or calls next(err)'
  - Route-scoped middleware runs only for specific routes or route groups, not globally
  - A built-in logging middleware logs HTTP method, URL path, response status code, and response duration in milliseconds
  - Calling next() more than once from a single middleware is detected and throws an error or is silently ignored (configurable)
  pitfalls:
  - Calling next() multiple times causes downstream handlers to execute twice, corrupting response state
  - Forgetting to await async middleware before calling next() causes handlers to execute out of order
  - Error middleware must be registered separately; mixing it with normal middleware based on argument count is fragile
  - 'Middleware ordering is critical: auth middleware must run before route handlers, but after body parsing'
  - Not catching synchronous exceptions thrown in handlers leaves the request hanging
  concepts:
  - Chain of responsibility pattern
  - Middleware pipeline
  - Error propagation through the chain
  - Async control flow
  skills:
  - Function composition and higher-order functions
  - Async/await and Promise error handling
  - Error boundary implementation
  - Request/response transformation
  deliverables:
  - Middleware chain executing in registration order with next() control
  - Error-handling middleware with dedicated signature for error propagation
  - Route-scoped middleware attachment to specific routes or groups
  - Built-in logging middleware as reference implementation
  - Async middleware support with proper Promise rejection handling
  estimated_hours: 10-15
- id: build-web-framework-m3
  name: Request/Response Enhancement & Body Parsing
  description: 'Add convenience methods to request/response objects and implement body parsing as middleware that plugs into the M2 pipeline. This ensures all downstream middleware and route handlers can access parsed body data.

    '
  acceptance_criteria:
  - JSON body parsing middleware reads the request body stream, parses JSON, and attaches the parsed object to 'req.body'; invalid JSON returns 400 Bad Request
  - URL-encoded form body parsing middleware decodes application/x-www-form-urlencoded data into key-value pairs on 'req.body'
  - Body parsing middleware enforces a configurable maximum body size (default 1MB); bodies exceeding the limit return 413 Payload Too Large
  - 'Response helpers: ''res.json(obj)'' sets Content-Type to application/json and serializes; ''res.send(text)'' sends text; ''res.redirect(url)'' sends 302; ''res.status(code)'' chains'
  - Query parameters are parsed from the URL query string and accessible as 'req.query' key-value map
  - Cookie reading parses the Cookie header into 'req.cookies' map; 'res.cookie(name, value, options)' sets Set-Cookie header with path, httpOnly, secure, maxAge, and sameSite options
  - Content-Type header is checked before body parsing; mismatched Content-Type skips the parser gracefully
  pitfalls:
  - Reading the request body stream twice (once in body parser, once in handler) yields empty data the second time; body must be parsed once and cached
  - Not enforcing body size limits enables denial-of-service via large payloads
  - Cookie values must be URI-encoded/decoded; special characters in cookie values cause parse failures
  - Multipart form data (file uploads) is significantly more complex than JSON/form parsing; scope it as optional or a separate middleware
  - Content-Type may include charset (e.g., application/json; charset=utf-8); parsing must handle this
  concepts:
  - Stream-based body reading
  - Content-Type negotiation
  - Cookie protocol (RFC 6265)
  - Request decoration pattern
  skills:
  - Stream processing for request bodies
  - JSON and form data parsing
  - HTTP header manipulation
  - Cookie management and security
  - Content negotiation
  deliverables:
  - JSON body parsing middleware with size limit and error handling
  - Form-urlencoded body parsing middleware
  - Response helper methods (json, send, redirect, status)
  - Query parameter parsing as req.query
  - Cookie read/write support with security options
  - Static file serving middleware for a configured directory
  estimated_hours: 10-14
- id: build-web-framework-m4
  name: Template Engine
  description: 'Implement a template engine that compiles template strings into render functions, supporting variable interpolation with auto-escaping, control flow directives, and template inheritance (base/child layouts).

    '
  acceptance_criteria:
  - Template variables like {{ name }} are replaced with corresponding context values; undefined variables render as empty string
  - All variable output is HTML-escaped by default (< > & " ' are encoded); a raw/safe filter like {{{ html }}} or {{ html | safe }} bypasses escaping
  - 'For-each loops iterate over arrays: "{% for item in items %}...{% endfor %} renders the block for each element"'
  - 'If/else conditionals: "{% if condition %}...{% else %}...{% endif %} include/exclude template sections based on truthiness"'
  - 'Template inheritance: child templates declare {% extends "base.html" %} and override {% block content %}...{% endblock %} sections defined in the parent'
  - Templates are compiled to JavaScript/Python functions on first use and cached; subsequent renders use the cached function without re-parsing
  - Template syntax errors report the template file name, line number, and description of the error
  - 'Integration with the framework: ''res.render(''template.html'', {data})'' looks up the template, renders it, and sends the HTML response with correct Content-Type'
  pitfalls:
  - Not auto-escaping variable output by default creates XSS vulnerabilities; escaping must be the default, not opt-in
  - 'Template injection: if user input is used as a template string (not a context variable), arbitrary code execution is possible; templates must come from trusted sources only'
  - Compiling templates on every request (not caching) causes orders-of-magnitude performance degradation
  - Template inheritance with multiple levels (grandchild extends child extends base) requires careful block resolution ordering
  - Large templates compiled to string concatenation are slow; compilation to function calls or buffer appends is significantly faster
  concepts:
  - Template compilation to render functions
  - HTML auto-escaping for XSS prevention
  - Template inheritance and block resolution
  - Template caching
  skills:
  - Lexing and parsing template syntax
  - Code generation from template AST
  - HTML sanitization and escaping
  - Template caching strategies
  deliverables:
  - Variable interpolation with HTML auto-escaping by default and raw bypass
  - Control flow directives: for-each loops and if/else conditionals
  - Template inheritance with extends and block override
  - Template compilation and caching for performance
  - Framework integration via res.render() helper
  - Error reporting with template name and line number
  estimated_hours: 14-22
domain: app-dev
