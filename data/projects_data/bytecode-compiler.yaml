id: bytecode-compiler
name: Bytecode Compiler
description: >-
  AST to bytecode compilation with scope analysis, instruction selection,
  jump target resolution, and constant pool organization for stack-based
  virtual machines.
difficulty: advanced
estimated_hours: 32
essence: >-
  AST traversal with instruction selection and emission, stack depth management
  for operand tracking, jump target resolution for control flow, and constant
  pool organization to generate compact executable bytecode for stack-based
  architectures.
why_important: >-
  Bytecode compilation bridges high-level language semantics and machine
  execution, teaching fundamental compiler backend techniques used in Python,
  Java, and WebAssembly while developing skills in code generation and
  low-level optimization applicable to any systems programming role.
learning_outcomes:
  - Compile expressions to stack-based bytecode with constant pool management
  - Implement scope analysis to distinguish local, global, and upvalue variables
  - Generate control flow bytecode with forward jump patching
  - Compile functions with call frames and return handling
  - Build a bytecode disassembler for debugging
skills:
  - Bytecode Generation
  - Scope Analysis
  - Jump Patching
  - Constant Pool Management
  - Code Emission
tags:
  - compiler
  - bytecode
  - code-generation
  - advanced
  - stack-machine
architecture_doc: architecture-docs/bytecode-compiler/index.md
languages:
  recommended:
    - C
    - Rust
    - Go
  also_possible:
    - Python
    - Java
resources:
  - name: Crafting Interpreters - Chapters 14-24
    url: https://craftinginterpreters.com/
    type: book
  - name: Python Compiler
    url: https://devguide.python.org/internals/compiler/
    type: documentation
  - name: Lua Compiler
    url: https://www.lua.org/source/5.4/lcode.c.html
    type: code
prerequisites:
  - type: skill
    name: AST representation and traversal
  - type: skill
    name: Understanding of stack machines
  - type: skill
    name: Basic compiler concepts
milestones:
  - id: bytecode-compiler-m1
    name: Expression Compilation
    description: >-
      Compile arithmetic and boolean expressions to stack-based bytecode.
    acceptance_criteria:
      - "Literal values are stored in constant pool and loaded via LOAD_CONST instruction"
      - "Binary operations emit left operand code, right operand code, then operator instruction"
      - "Unary negation compiles to operand code followed by NEGATE instruction"
      - "Compiled bytecode for expressions evaluates to same result as source expression"
      - "Constant pool deduplicates identical literals to reduce bytecode size"
    pitfalls:
      - "Wrong operand order for non-commutative ops: SUB/DIV need left operand pushed first"
      - "Constant pool indexing: use consistent indexing scheme (0-based)"
      - "Forgetting to handle all operators: ensure every operator has corresponding bytecode"
    concepts:
      - Tree traversal visits AST nodes in evaluation order
      - Stack-based code generation pushes operands, then applies operators
      - Constant pool stores literals once, referenced by index
    skills:
      - Recursive tree traversal
      - Stack machine programming
      - Bytecode instruction encoding
      - Expression evaluation
    deliverables:
      - Literal emission generating LOAD_CONST instructions for numeric and string constants
      - Binary operation compilation emitting opcodes for arithmetic and comparison operators
      - Unary operation compilation emitting opcodes for negation and logical not
      - Constant pool storing literal values referenced by bytecode load instructions
      - Bytecode chunk structure holding instructions and constant pool
    estimated_hours: 6

  - id: bytecode-compiler-m2
    name: Variables and Scope Analysis
    description: >-
      Compile variable declarations, assignments, and references with scope
      analysis.
    acceptance_criteria:
      - "Scope analysis pass determines whether each variable is local, global, or upvalue"
      - "Local variables use GET_LOCAL and SET_LOCAL with stack slot index"
      - "Global variables use GET_GLOBAL and SET_GLOBAL with name constant index"
      - "Upvalue variables use GET_UPVALUE and SET_UPVALUE for closures"
      - "Inner scope variables shadow outer scope variables with correct slot allocation"
      - "Scope exit frees local variable slots for reuse"
    pitfalls:
      - "Scope lifetime management: local slots must be freed when scope exits"
      - "Variable shadowing bugs: shadowed variable should use a new slot, not the parent's"
      - "Uninitialized variables: decide if reading uninitialized locals is an error or returns nil"
      - "Scope analysis order: must resolve variable categories BEFORE code emission"
    concepts:
      - Scope analysis categorizes variables by storage mechanism
      - Local variables are stack-indexed; globals are name-lookup based
      - Upvalues capture variables from enclosing functions
    skills:
      - Symbol table implementation
      - Lexical scoping analysis
      - Variable lifetime management
      - Stack slot allocation
    deliverables:
      - Scope analysis pass determining local/global/upvalue category for each variable
      - Variable declaration compiling to stack slot allocation for locals
      - Variable assignment compiling to SET_LOCAL, SET_GLOBAL, or SET_UPVALUE based on scope analysis
      - Variable read compiling to GET_LOCAL, GET_GLOBAL, or GET_UPVALUE based on scope analysis
      - Scope management tracking variable visibility and stack depth per block
    estimated_hours: 8

  - id: bytecode-compiler-m3
    name: Control Flow
    description: >-
      Compile if statements, while loops, and logical operators with jump
      patching.
    acceptance_criteria:
      - "Conditional jump pops stack top and branches if value is falsy to target offset"
      - "If-else compiles to: condition, JUMP_IF_FALSE to else-block, then-block, JUMP to end, else-block, end"
      - "While loop compiles to: condition, JUMP_IF_FALSE to end, body, JUMP back to condition, end"
      - "Forward jump targets are patched with correct offset after compilation of skipped block"
      - "Logical AND/OR compile to short-circuit evaluation with conditional jumps"
    pitfalls:
      - "Jump offset calculation: decide if offsets are absolute or relative; document clearly"
      - "Forgetting to pop condition in conditional jump causes stack leak"
      - "Break/continue in nested loops: each loop needs its own break/continue jump targets"
    concepts:
      - Jump patching resolves forward references after target offset is known
      - Backpatching records placeholder jumps and fills them in later
      - Short-circuit evaluation skips unnecessary operand evaluation
    skills:
      - Control flow graph construction
      - Jump instruction generation
      - Conditional branching
      - Forward reference resolution
    deliverables:
      - Conditional jump instructions branching based on stack top boolean value
      - If-else compilation emitting conditional jump over then-branch to else-branch
      - While loop compilation emitting backward jump to loop condition check
      - Jump target patching resolving forward jump offsets after target is known
      - Short-circuit AND/OR compilation using conditional jumps
    estimated_hours: 10

  - id: bytecode-compiler-m4
    name: Functions
    description: >-
      Compile function definitions and calls with proper frame management.
    acceptance_criteria:
      - "Function body compiles to separate bytecode chunk with its own constant pool"
      - "CALL instruction creates new call frame with argument count and function reference"
      - "RETURN instruction pops frame and pushes return value onto caller's stack"
      - "Arguments are pushed onto stack in order before CALL instruction"
      - "Closure creation captures upvalues from enclosing scope"
      - "Function declarations store closure in a variable or constant pool"
    pitfalls:
      - "Frame pointer management: each function needs its own local variable base"
      - "Argument count validation: CALL includes arity for runtime checking"
      - "Stack cleanup on return: caller must clean up arguments after call returns"
      - "Upvalue capture: closures must capture variables BEFORE the function returns"
    concepts:
      - Call frames isolate function invocations
      - Parameter binding maps arguments to local slots
      - Return addresses are stored in call frames, not hardcoded
    skills:
      - Calling convention design
      - Stack frame management
      - Function invocation protocols
      - Return value handling
      - Closure compilation
    deliverables:
      - Function compilation generating separate bytecode chunk for function body
      - CALL instruction pushing frame and transferring control to function bytecode
      - RETURN instruction popping frame and resuming caller execution context
      - Argument passing pushing arguments onto stack before call instruction
      - Closure compilation capturing upvalues from enclosing scope
    estimated_hours: 8