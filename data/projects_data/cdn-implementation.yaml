id: cdn-implementation
name: CDN Implementation
description: Content delivery network with edge caching, multi-node distribution, cache invalidation propagation, origin shielding, and request collapsing.
difficulty: expert
estimated_hours: 55
essence: Geographically distributed HTTP reverse proxy implementing cache coherence across edge nodes, request deduplication through collapsed forwarding, multi-tier cache hierarchy with TTL-based expiration, and invalidation propagation across distributed edge nodes routed via geo-aware DNS.
why_important: Building this teaches core techniques behind how internet-scale services (Netflix, Cloudflare, Akamai) deliver content globally with minimal latency, developing critical skills in distributed systems, HTTP caching standards, cache coherence protocols, and performance optimization essential for backend and infrastructure engineering.
learning_outcomes:
- Implement edge caching with TTL expiration and Cache-Control header parsing per RFC 9111
- Design cache key generation including URL, query parameters, and Vary header dimensions
- Build cache invalidation with purge (URL-specific), surrogate key (tag-based), and soft purge mechanisms
- Implement origin shielding with request collapsing to reduce origin load during cache miss storms
- Design multi-edge-node architecture with geo-aware routing and health-based failover
- Implement conditional requests using ETags and Last-Modified for efficient revalidation
- Build cache coherence protocols for invalidation propagation across distributed edge nodes
- Handle content compression (gzip/Brotli) and HTTP range requests for large file delivery
skills:
- HTTP Caching Protocols (RFC 9111)
- Distributed Systems
- Cache Invalidation Strategies
- Request Collapsing
- Origin Shielding
- Geo-Aware Routing
- Reverse Proxy Architecture
- Content Compression
tags:
- caching
- cdn
- distributed
- edge
- expert
- networking
- origin
- performance
architecture_doc: architecture-docs/cdn-implementation/index.md
languages:
  recommended:
  - Go
  - Rust
  also_possible:
  - C
  - C++
resources:
- name: RFC 9111 HTTP Caching
  url: https://httpwg.org/specs/rfc9111.html
  type: documentation
- name: Varnish Cache Documentation
  url: https://varnish-cache.readthedocs.io/
  type: documentation
- name: NGINX Content Caching Guide
  url: https://docs.nginx.com/nginx/admin-guide/content-cache/content-caching/
  type: documentation
- name: Cloudflare CDN Architecture
  url: https://developers.cloudflare.com/reference-architecture/architectures/cdn/
  type: documentation
- name: CDN Origin Shield Guide
  url: https://www.cdnplanet.com/guides/origin-shield
  type: article
prerequisites:
- type: project
  id: http-server-basic
  name: HTTP Server (Basic)
- type: project
  id: distributed-cache
  name: Distributed Cache
- type: skill
  name: HTTP protocol fundamentals
milestones:
- id: cdn-implementation-m1
  name: Single-Node Edge Cache
  description: Implement a single HTTP reverse proxy with cache storage, TTL management, Cache-Control header parsing, and conditional request handling per RFC 9111.
  acceptance_criteria:
  - Reverse proxy forwards cache misses to a configurable origin server and caches the response
  - Cache key is constructed from the request URL path, query string, and all headers listed in the response Vary header
  - TTL is determined by priority order - s-maxage > max-age > Expires header > configurable default TTL
  - Cache-Control no-store and no-cache directives are respected (no-store = never cache; no-cache = always revalidate)
  - Vary header with value '*' prevents caching of that response entirely
  - Conditional requests with If-None-Match (ETag) and If-Modified-Since return 304 Not Modified when content is unchanged
  - LRU or LFU eviction removes least valuable entries when configurable cache capacity is exceeded
  - Accept-Encoding variants are cached separately so compressed and uncompressed responses are served correctly
  - Stale-while-revalidate directive serves stale content while asynchronously refreshing from origin
  - 'Cache hit/miss status is included in a response header (X-Cache: HIT or MISS)'
  pitfalls:
  - Vary '*' means never cache - failing to handle this case serves wrong content to different clients
  - s-maxage takes priority over max-age for shared caches (CDN) but max-age is for private caches (browser) - using the wrong one serves stale content
  - ETag has weak ('W/') and strong forms - weak allows semantic equivalence, strong requires byte-for-byte match
  - Cache key must include ALL Vary dimensions - missing one causes cache poisoning where User A sees User B's content
  - 'Never cache responses with Vary: Cookie unless you understand the full implications - this can leak session data between users'
  - Negative responses (404, 410) should be cached briefly to prevent origin storms from repeated requests for missing resources
  concepts:
  - HTTP cache validation with ETag and Last-Modified per RFC 9111
  - Cache key construction from URL, query, and Vary header dimensions
  - TTL hierarchy (s-maxage, max-age, Expires)
  - Conditional requests (If-None-Match, If-Modified-Since)
  - Stale-while-revalidate for serving stale during background refresh
  - Cache poisoning risks from incomplete Vary handling
  skills:
  - HTTP caching standards
  - Cache-Control parsing
  - Vary header handling
  - Conditional requests
  deliverables:
  - HTTP reverse proxy forwarding requests to origin and caching responses
  - Cache key generator combining URL, query, and Vary header values
  - TTL manager computing expiration from Cache-Control directive hierarchy
  - Conditional request handler returning 304 for unchanged resources
  - LRU/LFU eviction when cache capacity is exceeded
  - Accept-Encoding variant caching for compressed/uncompressed responses
  estimated_hours: 14
- id: cdn-implementation-m2
  name: Edge Node Distribution & Routing
  description: Implement multi-edge-node architecture with geo-aware client routing, health checking, and failover.
  acceptance_criteria:
  - Multiple edge nodes register with a control plane reporting their geographic location and health status
  - Client requests are routed to the nearest healthy edge node via GeoDNS or Anycast simulation based on client IP geolocation
  - Health check probes run every 10 seconds; unhealthy nodes are removed from routing within 30 seconds
  - Edge node failover redirects traffic to the next-nearest healthy edge within the health check interval
  - Control plane API allows adding, removing, and inspecting registered edge nodes
  - Edge nodes pull configuration (origin server, cache settings, invalidation rules) from the control plane
  - Consistent hashing is NOT used for client routing (that's GeoDNS/Anycast); it is used internally for cache key distribution when nodes form a cache cluster
  pitfalls:
  - GeoIP databases have significant inaccuracy, especially for mobile carriers and VPN users - use it as a hint, not a guarantee
  - Anycast BGP routing is the production approach but complex to simulate; GeoDNS is a reasonable alternative for this project
  - Cache inconsistency across edges is expected and acceptable - CDNs provide eventual consistency, not strong consistency
  - Thundering herd on edge failover - all traffic from a failed edge hits the next edge simultaneously; rate limit origin fetches
  - Consistent hashing minimizes cache rebalancing when nodes join/leave but is for intra-cluster content distribution, not client routing
  concepts:
  - GeoDNS and Anycast BGP for geo-aware client routing
  - Health checking and service discovery for edge nodes
  - Consistent hashing for cache key distribution within a cluster
  - Control plane / data plane separation
  - Eventual consistency model for distributed caches
  skills:
  - Geo-routing
  - Health checking
  - Service discovery
  - Consistent hashing
  deliverables:
  - Control plane for edge node registration, health tracking, and configuration distribution
  - GeoDNS resolver directing clients to nearest healthy edge based on IP geolocation
  - Health check system probing edge nodes and removing unhealthy ones from rotation
  - Failover logic redirecting traffic to next-nearest edge on node failure
  - Edge node configuration sync pulling settings from control plane
  estimated_hours: 12
- id: cdn-implementation-m3
  name: Cache Invalidation & Propagation
  description: Implement purge, surrogate key invalidation, soft purge, and invalidation propagation across all edge nodes.
  acceptance_criteria:
  - Purge API removes a specific URL from cache on all edge nodes; next request for that URL fetches fresh from origin
  - Surrogate key (tag) purge invalidates all resources tagged with a specified key across all edge nodes in a single operation
  - Soft purge marks content as stale (rather than deleting) so it can be served while asynchronously revalidating from origin
  - Invalidation commands propagate to all registered edge nodes within a configurable time window (default 5 seconds)
  - Invalidation propagation is confirmed - control plane tracks acknowledgment from each edge node
  - Ban list pattern-matching invalidation removes all URLs matching a regex pattern; ban list entries have a TTL to prevent unbounded growth
  pitfalls:
  - Propagation delay means clients may briefly receive stale content from edges that haven't processed the invalidation yet - this is expected behavior
  - Soft purge (stale-while-revalidate) is almost always better than hard purge for user experience - hard purge causes cache miss latency spikes
  - Ban lists grow unboundedly without TTL - old ban entries that can no longer match any cached content must be garbage collected
  - Surrogate keys must be set by the origin in a response header (e.g., Surrogate-Key) - the CDN cannot invent them
  - Invalidation is not instant and not atomic across edges - design for eventual consistency, not immediate global purge
  concepts:
  - Surrogate-Key header for grouping related cache entries
  - Purge (exact URL) vs ban (pattern match) vs tag (surrogate key) invalidation
  - Soft purge with stale-while-revalidate for graceful degradation
  - Ban list management with TTL and garbage collection
  - Invalidation propagation protocol across distributed edge nodes
  skills:
  - Invalidation strategies
  - Propagation protocols
  - Surrogate keys
  - Distributed coordination
  deliverables:
  - Purge by URL API removing specific cached resource from all edge nodes
  - Surrogate key purge API invalidating all resources tagged with a given key
  - Soft purge marking content stale for background revalidation
  - Ban list invalidation with regex pattern matching and TTL-based cleanup
  - Invalidation propagation system distributing commands to all edge nodes with acknowledgment tracking
  estimated_hours: 12
- id: cdn-implementation-m4
  name: Origin Shield & Request Collapsing
  description: Implement origin shielding as a mid-tier cache and request collapsing to prevent cache miss storms from overwhelming the origin.
  acceptance_criteria:
  - Origin shield node sits between edge nodes and the origin server, caching responses to reduce origin load
  - Edge cache misses are forwarded to the shield node first; only shield misses reach the origin
  - Concurrent requests for the same uncached resource from multiple edge nodes are collapsed into a single origin fetch at the shield
  - Request collapsing timeout is configurable (default 5 seconds) and shorter than the client-facing request timeout
  - Negative responses (404) are cached at the shield for a configurable short TTL (default 10 seconds) to prevent origin storms for missing resources
  - Stale-while-revalidate at the shield serves cached content while a single background request refreshes from origin
  - Shield node health is monitored; when the shield is unhealthy, edges bypass it and fetch directly from origin
  pitfalls:
  - Shield adds latency (extra hop) but dramatically reduces origin load - the tradeoff is almost always worth it for popular content
  - Request collapsing timeout must be shorter than client timeout; otherwise clients time out while waiting for the collapsed request
  - Negative caching (caching 404s briefly) prevents origin storms when many edges simultaneously request a non-existent resource
  - Shield bypass on shield failure must be automatic - a failing shield should not take down the entire CDN
  - Collapsed requests share the same response, including errors - if the single origin fetch fails, all waiting edges get the failure
  concepts:
  - Origin shield as a secondary cache tier between edges and origin
  - Request coalescing to collapse concurrent identical requests
  - Thundering herd prevention through collapsing and negative caching
  - Negative response caching with short TTLs
  - Health-based routing to bypass failed shield nodes
  skills:
  - Origin protection
  - Request collapsing
  - Thundering herd prevention
  - Multi-tier caching
  deliverables:
  - Origin shield node caching responses between edge nodes and origin
  - Request collapsing deduplicating concurrent identical origin fetches
  - Negative response caching for 404s with configurable short TTL
  - Shield health monitoring with automatic bypass on failure
  - Stale-while-revalidate at shield layer for background origin refresh
  estimated_hours: 10
- id: cdn-implementation-m5
  name: Analytics, Compression & Range Requests
  description: Build cache analytics, content compression at the edge, and HTTP range request support for large file delivery.
  acceptance_criteria:
  - Cache hit ratio is tracked in real-time per edge node and globally, broken down by content type
  - Text-based content (HTML, CSS, JS, JSON) is automatically compressed with gzip and/or Brotli at the edge if the client supports it via Accept-Encoding
  - Compression is not applied to already-compressed content types (images, video, archives) or responses smaller than 1KB
  - HTTP Range requests (Range header) are supported, returning 206 Partial Content for large files
  - Range request caching stores the full response and serves partial content from cache without re-fetching from origin
  - Bandwidth savings from compression and cache hits are tracked and reported
  - Performance dashboard displays hit ratio, bandwidth savings, latency percentiles, and top-requested URLs
  pitfalls:
  - Compression at the edge consumes CPU - balance compression level against latency; level 4-6 for gzip is typically optimal
  - Range request cache fragmentation occurs when only partial ranges are cached - always cache the full response and serve ranges from it
  - Brotli offers better compression ratios than gzip but is slower to compress - pre-compress static assets, compress dynamic content with gzip
  - Cache analytics must not be on the hot path - use sampling or async aggregation to avoid adding latency to every request
  - Content-Length header must be accurate for range requests; chunked transfer encoding and range requests are incompatible
  concepts:
  - Cache analytics with hit/miss ratio tracking
  - Content-Encoding negotiation (gzip, br) via Accept-Encoding
  - HTTP Range requests and 206 Partial Content responses
  - Compression CPU-latency tradeoff optimization
  - Async metrics aggregation to avoid hot-path overhead
  skills:
  - Cache analytics
  - Content compression
  - HTTP range requests
  - Performance monitoring
  deliverables:
  - Cache hit ratio tracker per edge node and globally by content type
  - Content compression middleware supporting gzip and Brotli with configurable levels
  - HTTP range request handler serving 206 Partial Content from cached full responses
  - Performance dashboard with hit ratio, bandwidth savings, and latency percentiles
  - Bandwidth savings calculator tracking compression and cache efficiency
  estimated_hours: 7
domain: specialized
