id: coroutine-runtime-engine
name: Coroutine Runtime Engine
description: >
  Build an M:N user-space scheduler and coroutine runtime similar to Go's
  goroutines, implementing work-stealing, preemptive scheduling, and
  efficient context switching.

difficulty: expert
estimated_hours: 80-100
domain: systems

essence: >
  User-space threads (coroutines/fibers) scheduled onto kernel threads with
  work-stealing algorithms, stackful coroutine implementation, preemptive
  scheduling via timer or compiler cooperation, and efficient context
  switching without kernel involvement.

why_important: >
  Understanding coroutine runtimes is essential for building high-concurrency
  systems. This knowledge is valued at $200K-400K+ at companies building
  async runtimes, game engines, and high-performance servers.

learning_outcomes:
  - Implement stackful coroutines with custom stacks
  - Build an M:N work-stealing scheduler
  - Implement efficient context switching
  - Handle preemptive scheduling without kernel support
  - Implement async I/O integration with event loop
  - Build synchronization primitives for coroutines
  - Handle stack growth and overflow detection
  - Profile and optimize scheduler performance

skills:
  - Coroutine Implementation
  - Work-Stealing Scheduler
  - Context Switching
  - Stack Management
  - Preemptive Scheduling
  - Async I/O Integration
  - Concurrency Primitives
  - Performance Optimization

tags:
  - concurrency
  - coroutines
  - expert
  - fibers
  - green-threads
  - runtime
  - scheduler
  - systems

languages:
  recommended:
    - Rust
    - C++
    - C
  also_possible:
    - Zig

resources:
  - name: "Go Scheduler Design"
    url: https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw
    type: documentation
  - name: "Work Stealing Paper"
    url: https://dl.acm.org/doi/10.1145/324133.324234
    type: paper
  - name: "Boost.Context"
    url: https://www.boost.org/doc/libs/release/libs/context/
    type: reference
  - name: "Tokio Runtime Architecture"
    url: https://tokio.rs/tokio/tutorial
    type: documentation

prerequisites:
  - type: skill
    name: Systems programming (memory management, pointers)
  - type: skill
    name: Understanding of OS threading and scheduling
  - type: skill
    name: Assembly or inline assembly for context switch
  - type: project
    id: build-event-loop
    name: Build Event Loop

milestones:
  - id: cre-m1
    name: Stackful Coroutines
    description: >
      Implement stackful coroutines with separate execution stacks and
      context switching between them.
    acceptance_criteria:
      - Each coroutine has its own stack (fixed or growable)
      - Context switch saves/restores all necessary registers
      - Coroutines can yield control voluntarily
      - Coroutines can return values on completion
      - Stack overflow detection implemented
      - Works on x86-64 (assembly or ucontext)
      - Basic benchmark shows context switch overhead
    pitfalls:
      - Callee-saved registers must be preserved
      - Stack alignment requirements (16-byte on x86-64)
      - Floating point/SIMD register saving is expensive
      - ucontext is deprecated on some systems
      - Debugging corrupted stacks is difficult
    concepts:
      - Stackful coroutines
      - Context switching
      - Stack management
      - CPU registers
    skills:
      - Assembly programming
      - Stack manipulation
      - Context save/restore
      - Low-level debugging
    deliverables:
      - Coroutine structure
      - Context switch implementation
      - Stack allocator
      - Basic yield/resume API
    estimated_hours: "16-20"

  - id: cre-m2
    name: Work-Stealing Scheduler
    description: >
      Implement an M:N scheduler with work-stealing for load balancing
      across kernel threads.
    acceptance_criteria:
      - Global queue for new coroutines
      - Per-thread local queues for cache locality
      - Work-stealing when local queue empty
      - Configurable number of worker threads
      - Random stealing to reduce contention
      - No deadlock under any scheduling pattern
      - Scaling efficiency > 70% up to CPU core count
    pitfalls:
      - Work-stealing can cause cache pollution
      - Global queue becomes contention point
      - Queue empty races during stealing
      - Thread termination with pending work
      - NUMA awareness missing hurts performance
    concepts:
      - M:N scheduling
      - Work stealing
      - Load balancing
      - Scalability
    skills:
      - Scheduler design
      - Lock-free queues
      - Thread management
      - Performance tuning
    deliverables:
      - Work-stealing queue
      - Thread pool
      - Stealing algorithm
      - Scaling benchmark
    estimated_hours: "16-20"

  - id: cre-m3
    name: Preemptive Scheduling
    description: >
      Implement preemptive scheduling to prevent runaway coroutines from
      starving other work.
    acceptance_criteria:
      - Coroutines can be preempted after time slice
      - Preemption implemented via timer or compiler cooperation
      - No need for coroutine cooperation (cooperative preemption)
      - Preemption points inserted at safe locations
      - Preemption overhead is minimal (< 1% of execution time)
      - Fair scheduling across all runnable coroutines
    pitfalls:
      - Preemption at wrong point corrupts state
      - Timer-based preemption requires signal handling
      - Compiler-assisted preemption requires instrumentation
      - Preemption during locks causes deadlock risk
      - Preemption overhead adds latency
    concepts:
      - Preemptive scheduling
      - Time slicing
      - Fairness
      - Safe points
    skills:
      - Timer handling
      - Signal safety
      - Compiler integration
      - Safety analysis
    deliverables:
      - Preemption mechanism
      - Timer integration
      - Safe point detection
      - Fairness benchmark
    estimated_hours: "14-18"

  - id: cre-m4
    name: Async I/O Integration
    description: >
      Integrate the coroutine scheduler with async I/O for efficient
      network and file operations without blocking kernel threads.
    acceptance_criteria:
      - Coroutines can await I/O without blocking threads
      - Integration with epoll/kqueue/io_uring
      - Socket operations (accept, read, write) are async
      - File operations (read, write) are async
      - Timer/coroutine sleep is efficient
      - I/O multiplexing scales to thousands of connections
      - Benchmarks show competitive throughput with epoll directly
    pitfalls:
      - Blocking I/O in coroutine blocks entire thread
      - File I/O is often blocking; need thread pool
      - Cancellation of pending I/O is complex
      - Error handling across async boundaries
      - Integration with TLS/SSL adds complexity
    concepts:
      - Async I/O
      - Event notification
      - Non-blocking operations
      - I/O multiplexing
    skills:
      - epoll/kqueue/io_uring
      - Non-blocking I/O
      - Event integration
      - Network programming
    deliverables:
      - I/O event loop
      - Async socket operations
      - Async file operations
      - Timer integration
    estimated_hours: "16-20"

  - id: cre-m5
    name: Synchronization Primitives & Polish
    description: >
      Implement coroutine-aware synchronization primitives and optimize
      the runtime for production use.
    acceptance_criteria:
      - Coroutine mutex (async-aware)
      - Coroutine condition variable
      - Semaphore and channel primitives
      - Deadlock detection or prevention
      - Runtime statistics (coroutine count, queue depth)
      - Graceful shutdown with coroutine drain
      - Performance within 2x of Go/Tokio on benchmarks
    pitfalls:
      - Regular mutex in coroutine defeats scheduling
      - Deadlock with coroutine primitives is easy
      - Priority inversion possible
      - Statistics collection adds overhead
      - Shutdown races with pending I/O
    concepts:
      - Async synchronization
      - Deadlock prevention
      - Runtime monitoring
      - Production readiness
    skills:
      - Synchronization design
      - Debugging tools
      - Performance optimization
      - Production engineering
    deliverables:
      - Coroutine mutex
      - Condition variable
      - Channel implementation
      - Runtime statistics
      - Performance comparison
    estimated_hours: "14-18"
