id: custom-jit-backend
name: Custom JIT Backend
description: >
  Build a JIT compiler backend using Cranelift or LLVM to compile a custom
  DSL or language to native machine code at runtime.

difficulty: expert
estimated_hours: 70-90
domain: compilers

essence: >
  Intermediate representation design, code generation via Cranelift or LLVM
  APIs, optimization passes, calling conventions, runtime linking, and
  memory management for executable code.

why_important: >
  JIT compilation powers JavaScript engines (V8, SpiderMonkey), JVMs, and
  database query engines. Compiler engineers earn $180K-350K+ at browser
  vendors, language companies, and database firms.

learning_outcomes:
  - Design intermediate representation (IR)
  - Use Cranelift or LLVM for code generation
  - Implement function compilation and linking
  - Handle calling conventions and ABI
  - Implement basic optimizations
  - Manage executable memory
  - Build runtime type system
  - Debug JIT-compiled code

skills:
  - JIT Compilation
  - IR Design
  - Code Generation
  - Optimization
  - Calling Conventions
  - Memory Management
  - Runtime Systems
  - Debugging JIT Code

tags:
  - compilers
  - cranelift
  - expert
  - jit
  - llvm
  - runtime
  - wasm

languages:
  recommended:
    - Rust
    - C++
  also_possible:
    - C

resources:
  - name: "Cranelift Documentation"
    url: https://cranelift.readthedocs.io/
    type: documentation
  - name: "LLVM Tutorial"
    url: https://llvm.org/docs/tutorial/
    type: tutorial
  - name: "Crafting Interpreters (JIT Chapter)"
    url: https://craftinginterpreters.com/
    type: book
  - name: "MIR JIT Compiler"
    url: https://github.com/vnmakarov/mir
    type: reference

prerequisites:
  - type: project
    id: build-jit
    name: Build JIT (simple)
  - type: skill
    name: Understanding of compiler IR
  - type: skill
    name: Assembly/machine code basics
  - type: skill
    name: Rust or C++ proficiency

milestones:
  - id: cjb-m1
    name: IR Design & Frontend
    description: >
      Design an intermediate representation and build a frontend that
      translates your source language to IR.
    acceptance_criteria:
      - IR design documented with types and operations
      - Parser produces AST from source
      - AST lowered to IR correctly
      - Type checking before IR generation
      - Support for functions, basic control flow, arithmetic
      - IR can be printed for debugging
    pitfalls:
      - IR too high-level misses optimization opportunities
      - IR too low-level is hard to generate
      - Type system must be consistent
      - SSA form is complex but enables optimizations
      - Debugging IR generation requires good visualization
    concepts:
      - IR design
      - SSA form
      - Type checking
      - Lowering
    skills:
      - IR design
      - Parser integration
      - Type system
      - Debugging output
    deliverables:
      - IR definition
      - AST to IR lowering
      - Type checker
      - IR printer
    estimated_hours: "14-16"

  - id: cjb-m2
    name: Cranelift/LLVM Integration
    description: >
      Integrate Cranelift or LLVM to compile IR to machine code.
    acceptance_criteria:
      - Cranelift or LLVM integrated as dependency
      - IR translated to Cranelift/LLVM IR
      - Function compilation produces machine code
      - Machine code is executable
      - Basic functions compile and run correctly
      - Error handling for unsupported constructs
    pitfalls:
      - Cranelift IR differs from custom IR
      - LLVM API is complex and verbose
      - Type mapping between IRs
      - Calling convention setup
      - Symbol resolution for external functions
    concepts:
      - Codegen API
      - IR translation
      - Machine code emission
      - Integration patterns
    skills:
      - API usage
      - IR translation
      - Error handling
      - Build configuration
    deliverables:
      - Codegen integration
      - IR translator
      - Compilation function
      - Test programs
    estimated_hours: "14-18"

  - id: cjb-m3
    name: Runtime & Memory Management
    description: >
      Implement runtime support including memory management for JIT'd
      code and runtime type information.
    acceptance_criteria:
      - Executable memory allocation (mmap with PROT_EXEC)
      - Function pointer storage and calling
      - Runtime type information for JIT'd types
      - Garbage collection or manual memory management
      - Exception handling (optional)
      - Memory safety: no leaks in normal operation
    pitfalls:
      - W^X (write xor execute) violations
      - Memory fragmentation from many small functions
      - GC must know about JIT'd code roots
      - Exception handling is platform-specific
      - Thread safety for concurrent JIT
    concepts:
      - Executable memory
      - Runtime types
      - Memory management
      - Exception handling
    skills:
      - Memory allocation
      - Runtime design
      - GC integration
      - Platform specifics
    deliverables:
      - Executable memory allocator
      - Function registry
      - Runtime type support
      - Memory management
    estimated_hours: "14-16"

  - id: cjb-m4
    name: Optimization & Performance
    description: >
      Implement optimizations and tune the JIT for performance.
    acceptance_criteria:
      - At least 3 optimization passes enabled
      - Constant folding/propagation
      - Dead code elimination
      - Inlining for small functions
      - Benchmark shows 2x+ speedup vs interpreter
      - Compilation time reasonable (< 100ms for typical function)
    pitfalls:
      - Optimizations can increase code size
      - Compilation time vs runtime tradeoff
      - Some optimizations require SSA
      - Inlining decisions affect performance
      - Register allocation quality matters
    concepts:
      - Optimization passes
      - Inlining
      - Register allocation
      - Performance tuning
    skills:
      - Optimization selection
      - Performance analysis
      - Tradeoff decisions
      - Benchmarking
    deliverables:
      - Optimization pipeline
      - Inlining heuristic
      - Performance benchmarks
      - Tuning documentation
    estimated_hours: "12-16"

  - id: cjb-m5
    name: Debugging & Production Features
    description: >
      Add debugging support and production features for the JIT compiler.
    acceptance_criteria:
      - Source location mapping (IR to source)
      - Stack unwinding for JIT'd frames
      - GDB integration or custom debugger
      - Hot code recompilation (optional)
      - JIT statistics (compile time, code size)
      - Graceful handling of compilation failures
      - Documentation for JIT API
    pitfalls:
      - Debug info format is complex (DWARF)
      - Stack unwinding through JIT'd code is hard
      - Recompilation must handle running code
      - Statistics add overhead
      - Production JIT needs extensive testing
    concepts:
      - Debug information
      - Stack unwinding
      - Hot recompilation
      - Production readiness
    skills:
      - Debug info generation
      - Unwinding implementation
      - Statistics
      - Documentation
    deliverables:
      - Debug info support
      - Stack unwinding
      - JIT statistics
      - API documentation
    estimated_hours: "12-16"
