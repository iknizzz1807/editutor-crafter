id: ecs-arch
name: ECS Architecture
description: Entity-Component-System framework with sparse-set storage, system scheduling, command buffers, and archetype-based optimization.
difficulty: advanced
estimated_hours: 25-40
essence: 'Sparse-set component storage with cache-friendly contiguous arrays, generation-counted entity IDs for safe handle invalidation, system scheduling with deferred command buffers for safe structural changes, and archetype-based entity grouping for optimal iteration locality.

  '
why_important: 'ECS is the dominant architecture in modern game engines and high-performance simulations. Building one teaches data-oriented design principles, cache-aware programming, and safe concurrent data access patterns that apply to any performance-critical system.

  '
learning_outcomes:
- Implement generation-counted entity IDs with recycling via free lists
- Design sparse-set component storage with O(1) add/remove/lookup
- Build a system scheduler that iterates only matching entities
- Implement entity command buffers for deferred structural changes
- Design query interfaces filtering entities by component presence
- Implement archetype-based storage for cache-optimal iteration
- Measure and compare performance using benchmarks with 100K+ entities
- Debug performance bottlenecks using cache miss analysis
skills:
- Data-Oriented Design
- Cache Optimization
- Memory Layout Patterns
- System Architecture
- Performance Profiling
- Sparse Data Structures
- Type System Design
- Command Buffer Patterns
tags:
- advanced
- c++
- components
- entities
- game-dev
- rust
- systems
- performance
architecture_doc: architecture-docs/ecs-arch/index.md
languages:
  recommended:
  - C++
  - Rust
  - C
  also_possible:
  - C#
  - Go
resources:
- name: ECS FAQ
  url: https://github.com/SanderMertens/ecs-faq
  type: article
- name: Overwatch GDC Talk
  url: https://www.youtube.com/watch?v=W3aieHjyNvw
  type: video
- name: 'EnTT: Gaming meets modern C++'
  url: https://github.com/skypjack/entt
  type: reference
prerequisites:
- type: skill
  name: Systems programming (C++, Rust, or C)
- type: skill
  name: Data structures (arrays, hash maps, linked lists)
- type: skill
  name: Understanding of CPU cache hierarchy
milestones:
- id: ecs-arch-m1
  name: Entity Manager & World Container
  description: 'Create entity ID management with generation counters and a World container that will own all ECS state.

    '
  acceptance_criteria:
  - Entity IDs are packed as (index, generation) pairs in a single integer (e.g., 20-bit index + 12-bit generation)
  - create_entity() returns a new valid entity ID; successive calls never return the same ID while it's alive
  - destroy_entity() marks the entity as dead and adds the index to a free list for recycling
  - Recycled IDs increment the generation counter so stale handles are detectable
  - is_alive(entity) returns false for destroyed entities and for stale generation handles
  - Creating and destroying 1 million entities completes in under 100ms (benchmark test)
  - World struct/class is the top-level container owning the entity manager (and later, component storage and systems)
  pitfalls:
  - Not incrementing generation on recycle allows stale references to resolve to new entities
  - Free list implemented as vector of indices causes O(n) scan; use a stack or linked-list-in-array
  - Generation counter overflow wrapping to 0 causes false 'alive' on very long-running systems
  - Index space exhaustion when max entities exceeded—need clear error or growth strategy
  concepts:
  - Generation-counted entity IDs
  - Free list recycling
  - Handle invalidation
  skills:
  - Bit packing and manipulation
  - Free list / pool allocator design
  - Handle validation patterns
  deliverables:
  - Entity ID type with packed (index, generation) representation
  - Entity creation returning unique ID from free list or new allocation
  - Entity destruction adding index to free list and incrementing generation
  - is_alive() validation checking generation match
  - World container struct owning entity manager state
  - Benchmark: create/destroy 1M entities with timing output
  estimated_hours: 3-5
- id: ecs-arch-m2
  name: Sparse-Set Component Storage
  description: 'Implement cache-friendly component storage using sparse sets with O(1) add, remove, and lookup. Handle entity destruction cleanup.

    '
  acceptance_criteria:
  - Components are stored in a dense (contiguous) array for cache-friendly iteration
  - Sparse array maps entity index to dense array index for O(1) lookup
  - add_component(entity, component) stores the component and updates sparse/dense mappings
  - remove_component(entity) uses swap-and-pop on the dense array to maintain contiguity
  - get_component(entity) returns a reference/pointer to the component in O(1) time
  - has_component(entity) returns true/false in O(1) time
  - Entity destruction removes all components associated with that entity across all storage arrays
  - 'Type-safe access: requesting a component of the wrong type produces a compile-time or runtime error'
  - Iterating over all components of a type touches only contiguous memory (verifiable by cache miss profiling or by inspecting memory layout)
  pitfalls:
  - Swap-and-pop changes the index of the swapped element—must update its sparse entry
  - 'Sparse array growth: entity index 999999 requires sparse array of size 1M if using flat array'
  - Using a sentinel value (e.g., -1) for 'no component' in sparse array—must be consistent
  - Forgetting to clean up components on entity destruction causes dangling data
  - Type erasure losing type information—need per-type storage arrays
  concepts:
  - Sparse sets
  - Dense (contiguous) storage
  - Swap-and-pop removal
  - Data-oriented design
  skills:
  - Cache-aware data structure design
  - Sparse set implementation
  - Type-safe generic containers
  - Memory layout analysis
  deliverables:
  - Sparse set implementation with sparse array and dense array
  - add_component, remove_component, get_component, has_component API
  - Per-component-type storage registry
  - Entity destruction cleanup across all component stores
  - Type-safe access interface
  estimated_hours: 5-7
- id: ecs-arch-m3
  name: Systems, Queries & Command Buffers
  description: 'Create system execution framework with component queries and entity command buffers for safe deferred structural changes.

    '
  acceptance_criteria:
  - Systems are registered with the World and execute in a defined order each tick
  - Each system declares its required component types; iteration only visits entities possessing all required components
  - 'Query API: query<A, B>() returns an iterator over all entities with both component A and B'
  - 'Command buffer: structural changes (create entity, destroy entity, add/remove component) are queued during system execution and applied after all systems complete'
  - Applying command buffer does not invalidate any currently-held references (because systems have finished)
  - System execution receives delta time for time-based updates
  - Attempting to modify component storage directly during iteration produces an error or is prevented by API design
  - 'Integration test: a MovementSystem updates Position using Velocity for all entities with both components; entities without Velocity are not visited'
  pitfalls:
  - Modifying component storage during iteration corrupts sparse set indices
  - Command buffer not flushed between frames causes stale commands
  - System ordering dependencies not declared—physics runs before movement
  - Query result caching becomes stale after structural changes
  - Forgetting to clear command buffer after applying causes duplicate operations
  concepts:
  - System scheduling
  - Component queries
  - Deferred structural changes (command buffers)
  skills:
  - Command buffer pattern implementation
  - Iterator design for filtered entity sets
  - System dependency ordering
  - API safety design
  deliverables:
  - System registration and ordered execution in World
  - Component query API returning iterator over matching entities
  - Entity command buffer queuing create/destroy/add/remove operations
  - Command buffer flush applying all deferred operations after systems execute
  - Delta time propagation to systems
  - Integration test: MovementSystem processing Position + Velocity entities
  estimated_hours: 6-8
- id: ecs-arch-m4
  name: Archetype-Based Storage
  description: 'Implement archetype-based entity grouping where entities with the same component set are stored together in contiguous tables for maximum cache efficiency during iteration.

    '
  acceptance_criteria:
  - Archetype is identified by a sorted set of component type IDs (e.g., bitmask or sorted vector)
  - Entities with the same component set are stored in the same archetype table with components in parallel arrays
  - Adding or removing a component moves the entity from its current archetype to the target archetype
  - 'Archetype graph: edges connect archetypes that differ by one component, enabling O(1) transition lookup'
  - Queries match against archetype component sets (not individual entities), iterating only over matching archetype tables
  - Iteration over a matching archetype table is purely sequential memory access (no indirection through sparse array)
  - 'Benchmark: iterating 100K entities with 2 components is at least 2x faster with archetypes vs sparse-set queries (measured)'
  pitfalls:
  - 'Archetype explosion: too many unique component combinations creates many small tables (monitor archetype count)'
  - Entity move between archetypes requires copying all component data—expensive if done frequently
  - 'Archetype graph edge caching: forgetting to cache causes repeated hash lookups'
  - Chunk-based allocation within arcetype tables needed to avoid massive reallocation on growth
  - 'Command buffer interactions: structural changes must correctly move entities between archetypes'
  concepts:
  - Archetype tables
  - Archetype graph
  - Component set identity
  - Data locality optimization
  skills:
  - Graph-based archetype transitions
  - Bitmask or sorted-set component identification
  - Memory pool allocation
  - Performance benchmarking and comparison
  deliverables:
  - Archetype identification by component set (bitmask or sorted type list)
  - Archetype table storing components in parallel contiguous arrays
  - Entity migration between archetypes on component add/remove
  - Archetype graph with cached edges for O(1) transitions
  - Query system matching archetype tables instead of individual entities
  - Benchmark: 100K entity iteration comparing sparse-set vs archetype performance
  estimated_hours: 7-10
domain: game-dev
