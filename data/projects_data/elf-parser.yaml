id: elf-parser
name: ELF Binary Parser
description: Parse ELF headers, sections, segments, and symbol tables
difficulty: intermediate
estimated_hours: 12-18
essence: 'Low-level binary format parsing of the ELF (Executable and Linkable Format), interpreting multi-byte structures with endianness and word-size awareness, traversing section and program header tables, and resolving symbol names through string table indirection to understand how executables are structured on disk and loaded into memory.

  '
why_important: 'Building this demystifies the executable format underlying every Linux program and provides foundational knowledge for systems programming, reverse engineering, debugging, and understanding how compilers, linkers, and loaders work together.

  '
learning_outcomes:
- Parse binary file headers with multi-byte integer fields respecting endianness and word size
- Implement section header table traversal to locate code, data, and metadata sections
- Extract and decode symbol table entries to map function and variable names to addresses
- Decode program headers to understand segment loading and memory mapping
- Parse dynamic section entries to extract shared library dependencies
- Handle both 32-bit and 64-bit ELF variants with different struct sizes
- Build a command-line tool displaying structured binary data in human-readable format
- Debug binary parsing using hexdump and readelf for verification
skills:
- Binary Format Parsing
- Structure Packing and Alignment
- File I/O and Byte Manipulation
- Symbol Table Processing
- Dynamic Linking Concepts
- Systems Programming
- Endianness Handling
tags:
- binary-format
- elf
- systems-programming
- parsing
- low-level
- intermediate
architecture_doc: architecture-docs/elf-parser/index.md
languages:
  recommended:
  - C
  - Rust
  also_possible:
  - Go
  - Python
resources:
- name: ELF Specification
  url: https://refspecs.linuxfoundation.org/elf/elf.pdf
  type: reference
- name: 'In-depth: ELF - The Extensible & Linkable Format'
  url: https://www.cavestory.org/guides/csguide/download/elf_format.pdf
  type: article
- name: readelf man page
  url: https://man7.org/linux/man-pages/man1/readelf.1.html
  type: reference
prerequisites:
- type: skill
  name: C or Rust basics
- type: project
  name: hexdump
milestones:
- id: elf-parser-m1
  name: ELF Header Parsing
  description: Parse and display the ELF file header.
  estimated_hours: 3-4
  concepts:
  - Binary file parsing
  - ELF identification bytes
  - Header structure layout
  skills:
  - Binary file I/O
  - Struct memory layout and padding
  - Parsing fixed-size binary structures
  - Validating magic numbers
  acceptance_criteria:
  - Read and validate ELF magic bytes (0x7f 'E' 'L' 'F') at file offset 0; reject non-ELF files with clear error
  - Parse e_ident array to determine class (32/64-bit), data encoding (little/big endian), and OS/ABI
  - Parse all ELF header fields using the correct struct size for the detected class (Elf32_Ehdr or Elf64_Ehdr)
  - Display parsed header matching 'readelf -h' output format (type, machine, version, entry point, phoff, shoff, flags, sizes)
  - Read all multi-byte fields using the endianness declared in e_ident[EI_DATA]
  - Verify against 'readelf -h' output for at least 3 different binaries (shared library, executable, relocatable object)
  pitfalls:
  - Endianness of multi-byte fields must match the ELF file's declared endianness, not the host machine's
  - 32-bit and 64-bit ELF headers have different struct sizes and field widths (e.g., e_entry is 4 bytes vs 8 bytes)
  - e_shstrndx can be SHN_UNDEF (0) if there are no sections; handle gracefully
  - Do not assume host byte order matches file byte order; always convert explicitly
  deliverables:
  - ELF magic byte validation rejecting non-ELF files
  - ELF header field parser handling both Elf32 and Elf64 layouts
  - Endianness-aware multi-byte integer reading
  - Formatted header display matching readelf -h conventions
- id: elf-parser-m2
  name: Section Header Table
  description: Parse the section header table and display section information.
  estimated_hours: 3-4
  concepts:
  - Section headers
  - String table indirection
  - Section types and flags
  skills:
  - Array traversal with computed offsets
  - String table dereferencing
  - Interpreting section type and flag enumerations
  acceptance_criteria:
  - Read section header table using e_shoff, e_shentsize, and e_shnum from the ELF header
  - Handle the extended section numbering case where e_shnum == 0 (actual count in sh_size of section 0)
  - Resolve section names by reading the section header string table identified by e_shstrndx
  - Display section table matching 'readelf -S' output (index, name, type, address, offset, size, flags, link, info, align)
  - 'Identify key sections by type: SHT_PROGBITS, SHT_SYMTAB, SHT_STRTAB, SHT_RELA, SHT_DYNAMIC, SHT_NOTE'
  - Verify output against 'readelf -S' for at least 2 different binaries
  pitfalls:
  - Section 0 is always SHN_UNDEF (null section); do not skip it, as it may carry extended metadata
  - String table is just a blob of null-terminated strings; index is a byte offset into this blob, not a string index
  - sh_link and sh_info have section-type-dependent meanings; do not interpret them uniformly
  deliverables:
  - Section header table parser iterating all section entries
  - Section name resolution from .shstrtab
  - Section type and flag interpretation with human-readable labels
  - Formatted section table display matching readelf -S
- id: elf-parser-m3
  name: Symbol Tables
  description: Parse .symtab and .dynsym sections to extract symbol information.
  estimated_hours: 3-4
  concepts:
  - Symbol tables
  - String table lookup
  - Symbol types and bindings
  skills:
  - Array indexing and offset calculations
  - String table dereferencing
  - Symbol visibility and binding interpretation
  acceptance_criteria:
  - Locate .symtab and .dynsym sections by type (SHT_SYMTAB, SHT_DYNSYM)
  - Parse each symbol entry extracting name index, info (type + binding), other (visibility), shndx, value, and size
  - Resolve symbol names from the corresponding string table (.strtab for .symtab, .dynstr for .dynsym) using sh_link
  - Handle STT_SECTION symbols by displaying the corresponding section name instead of empty string
  - Display output matching 'readelf -s' format (index, value, size, type, binding, visibility, ndx, name)
  - Verify against 'readelf -s' for at least 2 binaries (one with .symtab, one stripped with only .dynsym)
  pitfalls:
  - .symtab may be absent in stripped binaries; handle gracefully and fall back to .dynsym
  - Symbol name index 0 means the symbol has no name (STN_UNDEF); display empty string
  - sh_link of the symbol table section points to the associated string table; do not hardcode section names
  - The info field packs type (low 4 bits) and binding (high 4 bits) using ELF32_ST_TYPE/ELF32_ST_BIND macros
  deliverables:
  - Symbol table parser for both .symtab and .dynsym
  - String table resolution using sh_link for correct string table association
  - Symbol type, binding, and visibility decoding
  - Formatted symbol table display matching readelf -s
- id: elf-parser-m4
  name: Program Headers and Dynamic Section
  description: Parse program headers and the .dynamic section for shared library dependencies.
  estimated_hours: 3-4
  concepts:
  - Program headers and segments
  - Dynamic linking
  - Shared library dependencies
  skills:
  - Understanding memory segments vs file sections
  - Parsing null-terminated strings from binary data
  - Dynamic linker metadata extraction
  acceptance_criteria:
  - Parse program header table using e_phoff, e_phentsize, and e_phnum from the ELF header
  - Display segment information matching 'readelf -l' output (type, offset, vaddr, paddr, filesz, memsz, flags, align)
  - Show section-to-segment mapping (which sections fall within each segment's address range)
  - Locate the PT_DYNAMIC segment and parse .dynamic section entries
  - Extract DT_NEEDED entries and resolve library names from the dynamic string table
  - Extract PT_INTERP segment content to show the dynamic linker path
  - Verify against 'readelf -l' and 'readelf -d' output
  pitfalls:
  - Program headers describe runtime memory layout; sections describe link-time structureâ€”they can overlap
  - DT_NEEDED d_val is a string table offset into .dynstr, not a direct pointer
  - PT_INTERP contains a null-terminated string (the dynamic linker path); read it from the file offset, not a virtual address
  - Statically linked binaries have no PT_DYNAMIC or PT_INTERP; handle gracefully
  - Do not attempt to display readelf -a output; limit scope to headers, sections, symbols, segments, and dynamic entries
  deliverables:
  - Program header table parser with segment type and flag decoding
  - Section-to-segment mapping display
  - Dynamic section parser extracting DT_NEEDED and other key entries
  - Dynamic linker path extraction from PT_INTERP
  - Library dependency listing from DT_NEEDED entries
domain: specialized
