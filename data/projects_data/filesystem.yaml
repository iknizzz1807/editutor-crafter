id: filesystem
name: "Filesystem Implementation"
description: "Inode-based filesystem with block allocation, directories, FUSE integration, and write-ahead journaling"
difficulty: advanced
estimated_hours: "65-85"
essence: >
  Block-level storage abstraction layered with inode-based metadata structures
  for file organization, directory tree traversal through linked entries, and
  crash consistency achieved through write-ahead journaling that serializes
  filesystem operations to a sequential log before applying changes to primary
  data structures.
why_important: >
  Building a filesystem teaches you how operating systems manage persistent storage
  at the lowest level — skills directly applicable to database internals, storage
  systems engineering, and understanding performance bottlenecks in any I/O-intensive
  application.
learning_outcomes:
  - Design and implement on-disk layout with superblock, bitmaps, inode table, and data blocks
  - Implement inode-based file metadata with direct and indirect block pointers
  - Build directory tree operations with path resolution and entry management
  - Implement file read, write, truncate, and sparse file handling
  - Integrate with FUSE to mount the filesystem as a real mount point
  - Implement write-ahead journaling for crash consistency and recovery
  - Build mkfs formatter initializing filesystem structures on a raw image
skills:
  - Block I/O
  - Inode structures
  - Directory entries
  - Write-ahead journaling
  - FUSE interface
  - Crash recovery
  - On-disk layout design
tags:
  - advanced
  - directories
  - inodes
  - journaling
  - vfs
  - fuse
architecture_doc: architecture-docs/filesystem/index.md
languages:
  recommended:
    - C
    - Rust
    - Go
  also_possible: []
resources:
  - name: "Writing a FUSE Filesystem Tutorial"
    url: "https://www.cs.nmsu.edu/~pfeiffer/fuse-tutorial/"
    type: tutorial
  - name: "Operating Systems: Three Easy Pieces (OSTEP)"
    url: "https://pages.cs.wisc.edu/~remzi/OSTEP/"
    type: book
  - name: "OSTEP - File System Implementation"
    url: "https://pages.cs.wisc.edu/~remzi/OSTEP/file-implementation.pdf"
    type: book
  - name: "OSTEP - Crash Consistency and Journaling"
    url: "https://pages.cs.wisc.edu/~remzi/OSTEP/file-journaling.pdf"
    type: book
  - name: "libfuse API Documentation"
    url: "https://libfuse.github.io/doxygen/"
    type: documentation
prerequisites:
  - type: skill
    name: "File I/O (read, write, seek)"
  - type: skill
    name: "Data structures (linked lists, trees, bitmaps)"
  - type: skill
    name: "C or Rust programming"
milestones:
  - id: filesystem-m1
    name: "Block Layer and mkfs"
    description: >
      Implement raw block device abstraction, on-disk layout design,
      free block bitmap, and mkfs formatter to initialize a fresh filesystem.
    acceptance_criteria:
      - "Block device abstraction provides read_block(block_num) and write_block(block_num, data) over a fixed 4KB block size backed by a disk image file"
      - "On-disk layout is defined: superblock (block 0), block bitmap, inode bitmap, inode table, journal region, data blocks — all positions derived from superblock metadata"
      - "Superblock stores magic number, filesystem version, total blocks, total inodes, block size, free block/inode counts, and journal region location"
      - "Block bitmap tracks free/used status for all data blocks; allocation returns the first free block and marks it used; deallocation clears the bit"
      - "Inode bitmap tracks free/used status for all inodes independently from blocks"
      - "mkfs tool initializes a raw file: writes superblock, zeroes bitmaps, initializes inode table, creates root directory (inode 0 or 1) with . and .. entries"
      - "After mkfs, the filesystem image can be read back and all metadata is consistent"
    pitfalls:
      - "Not initializing the superblock magic number; mounting without validation risks interpreting garbage as filesystem metadata"
      - "Bitmap corruption from not flushing writes; a crash between allocation and data write leaves orphaned blocks"
      - "Off-by-one in bitmap indexing; block 0 is the superblock, data blocks start at a different offset"
      - "Writing beyond the disk image size without validation; check total_blocks boundary"
    concepts:
      - Block-level I/O and sector alignment
      - On-disk layout design
      - Bitmap-based allocation
      - Filesystem formatting (mkfs)
    skills:
      - Block I/O abstraction
      - Bitmap manipulation
      - On-disk serialization
    deliverables:
      - Block device abstraction with read/write operations on a file-backed image
      - Superblock structure and serialization
      - Block bitmap allocator and deallocator
      - Inode bitmap allocator and deallocator
      - mkfs tool creating a formatted filesystem image with root directory
    estimated_hours: "10-14"

  - id: filesystem-m2
    name: "Inode Management"
    description: >
      Implement inode structure for file metadata with direct and indirect
      block pointers for variable-size files.
    acceptance_criteria:
      - "Inode structure contains: file type (regular, directory), size, permissions (mode), link count, timestamps (atime, mtime, ctime), direct block pointers (e.g., 12), single-indirect pointer, and double-indirect pointer"
      - "Direct block pointers address the first N blocks of a file (e.g., first 12 × 4KB = 48KB)"
      - "Single-indirect pointer references a block containing an array of block pointers, extending file capacity (e.g., +4MB)"
      - "Double-indirect pointer references a block of single-indirect pointers, further extending capacity (e.g., +4GB)"
      - "Inode allocation from the inode bitmap returns a free inode number; deallocation frees all associated data blocks AND indirect blocks"
      - "Inode read/write serializes inode structure to/from the inode table region on disk"
      - "Null/zero block pointers in the inode indicate unallocated blocks (holes for sparse files)"
      - "Timestamps are updated on inode modification (mtime, ctime) and access (atime)"
    pitfalls:
      - "Leaking indirect blocks when freeing an inode; must traverse and free single-indirect and double-indirect blocks recursively"
      - "Off-by-one in block offset calculations when transitioning from direct to indirect pointers"
      - "Not distinguishing between zero block pointer (hole/unallocated) and block 0 (superblock); block 0 should never be a data block"
      - "Forgetting to update link count and timestamps on inode operations"
    concepts:
      - Inode metadata structure
      - Direct and indirect block addressing
      - Sparse file representation with null pointers
      - Reference counting (link count)
    skills:
      - Inode structure design and serialization
      - Multi-level pointer traversal
      - Block offset calculation
    deliverables:
      - Inode structure with all metadata fields
      - Direct block pointer access for small files
      - Single-indirect and double-indirect pointer traversal for large files
      - Inode allocation and full deallocation (including indirect blocks)
      - Inode serialization to/from disk
    estimated_hours: "10-14"

  - id: filesystem-m3
    name: "Directory Operations"
    description: >
      Implement directory entries, path resolution, and directory management.
    acceptance_criteria:
      - "Directory is a special file whose data blocks contain an array of directory entries; each entry has inode number, entry length, name length, and name"
      - "add_entry(dir_inode, name, target_inode) appends a new entry to the directory; fails if name already exists"
      - "remove_entry(dir_inode, name) removes the entry and decrements the target inode's link count; if link count reaches 0 and no open file descriptors, inode is freed"
      - "Path resolution traverses '/' separated components from root (or cwd): \"for path 'a/b/c', look up 'a' in root, then 'b' in a's inode, then 'c' in b's inode\""
      - "'.' entry always points to the directory's own inode; '..' entry points to parent directory's inode (root's '..' points to itself)"
      - "mkdir creates a new directory inode with '.' and '..' entries; parent's link count is incremented (because '..' in child points to parent)"
      - "rmdir removes a directory only if it's empty (contains only '.' and '..')"
      - "Hard link creation (link) adds a new directory entry pointing to an existing inode and increments link count"
    pitfalls:
      - "Not validating name uniqueness before adding an entry; duplicate names cause ambiguous lookups"
      - "Forgetting to increment parent link count on mkdir (for child's '..' entry) and decrement on rmdir"
      - "Not handling the root directory's '..' correctly (it must point to itself)"
      - "Race conditions in concurrent directory modifications; for FUSE, multiple threads may modify simultaneously"
      - "Maximum filename length must be enforced; long names can overflow entry structures"
    concepts:
      - Directory entry format
      - Path traversal algorithm
      - Hard links and link counting
      - Directory consistency
    skills:
      - Directory entry management
      - Path parsing and traversal
      - Link count tracking
    deliverables:
      - Directory entry structure and serialization
      - add_entry and remove_entry operations
      - Path-to-inode resolution function
      - mkdir and rmdir with link count management
      - Hard link (link) operation
    estimated_hours: "10-14"

  - id: filesystem-m4
    name: "File Read/Write Operations"
    description: >
      Implement file creation, reading, writing, truncation, and sparse file support.
    acceptance_criteria:
      - "create_file(parent_dir_inode, name, mode) allocates a new inode, adds a directory entry, and returns the inode number"
      - "read(inode, offset, length) reads data from the file's blocks via inode pointers; reading unallocated blocks (holes) returns zero bytes"
      - "write(inode, offset, data) writes data to allocated blocks; allocates new blocks as needed for growth; updates inode size if writing past current end"
      - "truncate(inode, new_size) either extends the file (zero-filling conceptually via holes) or shrinks it (freeing blocks beyond new_size and updating pointers)"
      - "Sparse file support: writing at a high offset without writing intermediate positions does not allocate blocks for the gap; those blocks read as zeros"
      - "Append operation writes data at the current end of file and extends inode size"
      - "File metadata (size, mtime, ctime) is updated correctly on every write and truncate operation"
      - "Unit tests verify round-trip: write data, read it back, compare byte-for-byte"
    pitfalls:
      - "Not zero-filling partial blocks when writing doesn't align to block boundaries"
      - "Forgetting to free indirect pointer blocks when truncating below their range"
      - "Memory leaks from caching block data without eviction"
      - "Off-by-one in calculating which block index corresponds to a given file offset"
    concepts:
      - File offset to block mapping
      - Sparse file representation
      - Block allocation on write
      - Truncation and deallocation
    skills:
      - File I/O implementation
      - Block-level data management
      - Offset arithmetic
    deliverables:
      - create_file operation allocating inode and adding directory entry
      - read operation mapping file offset to blocks and returning data
      - write operation allocating blocks and writing data
      - truncate operation shrinking or extending files
      - Sparse file handling with zero-filled reads for holes
      - Unit test suite for file operations
    estimated_hours: "10-14"

  - id: filesystem-m5
    name: "FUSE Integration"
    description: >
      Mount the filesystem via FUSE for real-world testing with standard
      Unix tools (ls, cat, cp, etc.).
    acceptance_criteria:
      - "Filesystem mounts via FUSE appearing as a regular mount point accessible by the OS"
      - "FUSE callbacks implemented: getattr, readdir, lookup, create, open, read, write, release, mkdir, rmdir, unlink, rename, truncate, chmod, utimens"
      - "Standard tools work: \"'ls -la' lists directory contents with correct sizes/permissions; 'cat' reads files; 'cp' copies files into the mount; 'echo > file' writes\""
      - "Concurrent access from multiple processes does not corrupt filesystem state (proper locking around shared structures)"
      - "Unmount flushes all pending data to the disk image and cleans up resources"
      - "rename operation moves entries between directories atomically"
    pitfalls:
      - "Not implementing getattr correctly causes ls and every other tool to fail (it's called on every path operation)"
      - "Deadlocks in FUSE callbacks when holding locks and calling back into the filesystem"
      - "FUSE passes paths, not inodes, to most callbacks; each callback must resolve the path, which is expensive without caching"
      - "Forgetting to implement 'create' vs 'mknod'; FUSE calls create for O_CREAT opens"
      - "Not flushing dirty data on unmount loses recently written data"
    concepts:
      - FUSE callback interface
      - VFS abstraction layer
      - User-space vs kernel-space filesystem
    skills:
      - FUSE API integration
      - System test with real tools
      - Concurrent access handling
    deliverables:
      - FUSE operation callback registration
      - All required callbacks (getattr, readdir, create, read, write, mkdir, rmdir, unlink, rename, truncate, etc.)
      - Locking strategy for thread-safe access
      - Mount/unmount lifecycle with flush-on-unmount
      - Integration test running standard Unix commands against mounted filesystem
    estimated_hours: "10-14"

  - id: filesystem-m6
    name: "Write-Ahead Journaling and Crash Recovery"
    description: >
      Implement a write-ahead journal for crash consistency. Metadata operations
      are journaled so the filesystem can recover from crashes without corruption.
    acceptance_criteria:
      - "Journal region occupies a fixed set of blocks on disk (configured in superblock); journal entries are written sequentially with wrap-around"
      - "Each filesystem operation (create, write metadata, mkdir, unlink, etc.) is wrapped in a transaction: begin → journal writes → commit → apply to data structures → end"
      - "Transaction commit writes a commit record to the journal; without a commit record, the transaction is considered incomplete on recovery"
      - "Recovery (fsck/replay): on mount, scan the journal for committed transactions and replay their operations; discard uncommitted transactions"
      - "Metadata journaling mode: only metadata changes (inode updates, bitmap changes, directory entries) are journaled; data blocks are written directly"
      - "Crash simulation test: kill the filesystem process mid-operation, remount, verify recovery produces a consistent filesystem with no orphaned inodes or leaked blocks"
      - "Journal checkpoint: \"after all committed transactions are applied, the journal is marked as clean so it doesn't replay stale entries\""
    pitfalls:
      - "Not writing the commit record atomically (or at least ensuring it's fully flushed); a partial commit record looks uncommitted on recovery"
      - "Replaying a transaction that was already applied (idempotency): operations must be safe to apply multiple times"
      - "Journal wrap-around overwriting uncommitted transactions; must checkpoint before the journal fills"
      - "Data journaling (journaling data blocks too) doubles write amplification; metadata-only journaling is the practical default"
      - "Not fsyncing the journal before writing to the main data structures; reorder by the OS can defeat the write-ahead guarantee"
    concepts:
      - Write-ahead logging (WAL)
      - Transaction begin/commit/abort
      - Crash recovery and replay
      - Journaling modes (metadata-only vs full)
    skills:
      - Transaction design
      - Crash recovery implementation
      - Atomic write guarantees
      - Idempotent operation design
    deliverables:
      - Journal region with sequential log entries and wrap-around
      - Transaction API (begin, journal_write, commit, end)
      - Journal replay on mount for crash recovery
      - Checkpoint operation marking journal as clean after replay
      - Crash simulation test verifying filesystem consistency after interrupted operations
    estimated_hours: "12-16"