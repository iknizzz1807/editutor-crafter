id: formal-verification-tool
name: Formal Verification Tool
description: >
  Build a formal verification tool using SMT (Satisfiability Modulo Theories)
  solvers to prove program correctness. Implement specification languages,
  verification conditions, and counterexample generation.

difficulty: expert
estimated_hours: 60-80
domain: software-engineering

essence: >
  Mathematical proof of program correctness through specification languages
  (pre/post conditions, invariants), verification condition generation via
  weakest preconditions, and SMT solver integration for automated proof.

why_important: >
  Formal verification is critical for safety-critical systems (aviation, medical,
  automotive). Understanding SMT-based verification is valuable at $200K-400K+
  at companies like AWS (Amazon's Automated Reasoning), Galois, and Bedrock.

learning_outcomes:
  - Implement specification language (pre/post conditions)
  - Build verification condition generator using weakest preconditions
  - Integrate SMT solver (Z3) for constraint solving
  - Implement invariant inference for loops
  - Build counterexample generation for failed proofs
  - Handle basic data types (integers, arrays, records)
  - Implement procedure modular verification
  - Build interactive proof assistance

skills:
  - Formal Verification
  - SMT Solvers
  - Weakest Preconditions
  - Specification Languages
  - Invariant Inference
  - Counterexample Generation
  - Modular Verification
  - Z3 Integration

tags:
  - expert
  - formal-verification
  - smt
  - z3
  - correctness
  - proof
  - safety-critical

languages:
  recommended:
    - Python
    - Rust
  also_possible:
    - OCaml
    - C++

resources:
  - name: "Program Proofs (K. Rustan M. Leino)"
    url: https://program-proofs.com/
    type: book
  - name: "Z3 Tutorial"
    url: https://microsoft.github.io/z3tutorial/
    type: tutorial
  - name: "Dafny Language"
    url: https://dafny.org/
    type: documentation
  - name: "Software Foundations"
    url: https://softwarefoundations.cis.upenn.edu/
    type: book

prerequisites:
  - type: skill
    name: Mathematical logic (propositional, first-order)
  - type: skill
    name: Understanding of program semantics
  - type: project
    name: type-checker or equivalent PL experience
  - type: skill
    name: Python or Rust proficiency

milestones:
  - id: formal-verify-m1
    name: Specification Language
    description: >
      Design and implement a specification language for expressing
      preconditions, postconditions, and invariants.
    acceptance_criteria:
      - Function specifications with requires/ensures clauses
      - Loop invariants attached to while loops
      - Assertions within code
      - Basic types: int, bool, arrays
      - Specification expressions: arithmetic, comparisons, logical ops
      - Parsing specifications embedded in source comments
    pitfalls:
      - Specification language too limited
      - Parsing specifications is tricky
      - Type system mismatch with implementation
      - Unclear specification scope
    concepts:
      - Contract specifications
      - Preconditions
      - Postconditions
      - Invariants
    skills:
      - Language design
      - Specification parsing
      - Type handling
      - Syntax extension
    deliverables:
      - Specification syntax
      - Parser for specs
      - Type system
      - AST with specs
    estimated_hours: "10-14"

  - id: formal-verify-m2
    name: Weakest Precondition Calculator
    description: >
      Implement weakest precondition calculation for generating
      verification conditions from programs and specifications.
    acceptance_criteria:
      - WP for assignments: wp(x := e, Q) = Q[x := e]
      - WP for sequences: wp(S1; S2, Q) = wp(S1, wp(S2, Q))
      - WP for conditionals: wp(if b then S1 else S2, Q) = ...
      - WP for loops with given invariant
      - VC generation: precondition implies WP(postcondition)
      - Handles basic control flow
    pitfalls:
      - Substitution is tricky (variable capture)
      - Loop handling requires invariant
      - Array updates need careful modeling
      - Expressions in WP must be pure
    concepts:
      - Weakest precondition
      - Verification conditions
      - Substitution
      - Loop handling
    skills:
      - WP calculation
      - Substitution
      - VC generation
      - Control flow
    deliverables:
      - WP calculator
      - Substitution engine
      - VC generator
      - Control flow handling
    estimated_hours: "14-18"

  - id: formal-verify-m3
    name: SMT Solver Integration
    description: >
      Integrate Z3 SMT solver for checking verification conditions.
    acceptance_criteria:
      - VCs translated to Z3 assertions
      - Integer arithmetic with overflow handling
      - Array theory for array operations
      - Solver reports sat (valid) or unsat (invalid)
      - Model extraction for counterexamples
      - Timeout handling for long-running proofs
    pitfalls:
      - Z3 syntax differences
      - Integer overflow not modeled by default
      - Quantifier instantiation issues
      - Timeout vs actual unsat
    concepts:
      - SMT theories
      - Solver integration
      - Model interpretation
      - Timeout handling
    skills:
      - Z3 API
      - Theory selection
      - Model parsing
      - Error handling
    deliverables:
      - Z3 integration
      - Theory setup
      - Model extraction
      - Timeout handling
    estimated_hours: "12-16"

  - id: formal-verify-m4
    name: Invariant Inference & Counterexamples
    description: >
      Implement basic invariant inference for loops and
      counterexample generation for failed proofs.
    acceptance_criteria:
      - Template-based invariant inference (linear invariants)
      - Houdini-style candidate pruning
      - Counterexample shows violating execution path
      - Counterexample includes variable values
      - User-friendly counterexample display
      - Works for simple loop patterns
    pitfalls:
      - Invariant inference is undecidable in general
      - Templates too restrictive miss invariants
      - Counterexample can be spurious
      - Complex loops need manual invariants
    concepts:
      - Invariant inference
      - Template matching
      - Counterexample generation
      - Proof debugging
    skills:
      - Inference algorithms
      - Template design
      - Model interpretation
      - Error reporting
    deliverables:
      - Invariant inference
      - Template system
      - Counterexample generator
      - Display formatting
    estimated_hours: "12-16"

  - id: formal-verify-m5
    name: Modular Verification
    description: >
      Implement procedure-modular verification where functions
      are verified against their specifications independently.
    acceptance_criteria:
      - Function calls use specification, not body
      - Callers verify against callee precondition
      - Callers assume callee postcondition
      - Separate verification of each procedure
      - Dependency order for verification
      - Recursive procedure handling
    pitfalls:
      - Circular dependencies
      - Incorrect specification usage
      - Recursive procedures need termination metric
      - Specification strengthening/weakening
    concepts:
      - Modular verification
      - Procedure contracts
      - Dependency analysis
      - Termination
    skills:
      - Modular design
      - Contract checking
      - Dependency handling
      - Recursion support
    deliverables:
      - Modular verifier
      - Contract checking
      - Dependency analysis
      - Recursion handling
    estimated_hours: "10-14"
