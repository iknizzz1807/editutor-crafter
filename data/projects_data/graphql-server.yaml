id: graphql-server
name: GraphQL Server
description: >-
  Build a schema-first GraphQL server with resolvers, DataLoader for N+1
  prevention, authentication, query complexity limiting, and real-time
  subscriptions over WebSocket.
difficulty: intermediate
estimated_hours: "35-45"
essence: >-
  Schema-first type system with resolver functions for field-level data
  fetching, request-scoped batching and caching through DataLoader to
  collapse redundant database queries, query complexity analysis to prevent
  abuse, and persistent WebSocket connections enabling server-initiated
  push of real-time data updates to subscribed clients.
why_important: >-
  Building this teaches you efficient API architecture patterns that prevent
  common performance pitfalls (N+1 queries), enforce security boundaries
  (query complexity limiting), and gives you hands-on experience with
  real-time bidirectional protocols used in production systems.
learning_outcomes:
  - Design type-safe GraphQL schemas with object types, interfaces, enums, and input types
  - Implement resolver functions with proper context passing and error handling
  - Eliminate N+1 query problems using DataLoader batching and per-request caching
  - Build authentication and authorization within the GraphQL context
  - Implement query depth and complexity limiting to prevent abuse
  - Design cursor-based pagination following the Relay connection specification
  - Build real-time subscriptions over WebSocket with pub/sub event routing
  - Handle subscription lifecycle including authentication and resource cleanup
skills:
  - GraphQL Schema Design (SDL)
  - Resolver Implementation Patterns
  - DataLoader Batching & Caching
  - Real-time Subscriptions
  - Authentication in GraphQL
  - Query Complexity Analysis
  - Cursor-Based Pagination
  - Error Handling
tags:
  - api
  - dataloaders
  - intermediate
  - resolvers
  - schema
  - service
  - subscriptions
architecture_doc: architecture-docs/graphql-server/index.md
languages:
  recommended:
    - Python
    - Go
    - TypeScript
  also_possible:
    - Rust
    - Java
resources:
  - name: GraphQL Official Documentation
    url: https://graphql.org/learn/
    type: documentation
  - name: How to GraphQL Full Tutorial
    url: https://www.howtographql.com/
    type: tutorial
  - name: Solving N+1 with DataLoader
    url: https://www.graphql-js.org/docs/n1-dataloader/
    type: article
  - name: Relay Connection Specification
    url: https://relay.dev/graphql/connections.htm
    type: documentation
  - name: graphql-ws Protocol
    url: https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md
    type: documentation
prerequisites:
  - type: skill
    name: REST API basics
  - type: skill
    name: Database queries (SQL)
  - type: skill
    name: Basic authentication concepts
milestones:
  - id: graphql-server-m1
    name: Schema, Resolvers & Authentication
    description: >-
      Define the GraphQL schema for a domain (e.g., blog or task manager),
      implement resolvers with database fetching, and add authentication
      via context.
    acceptance_criteria:
      - "Schema defines at least 3 object types with relationships (e.g., User, Post, Comment with author/post foreign key relationships)"
      - "Query type includes at least: single entity by ID, and list query with cursor-based pagination following Relay connection spec (edges, nodes, pageInfo with hasNextPage/endCursor)"
      - "Mutation type includes at least: create, update, and delete operations with input types for arguments"
      - "Custom scalar types (e.g., DateTime) are implemented with serialize, parseValue, and parseLiteral methods"
      - "Enum types are used for fixed-value fields (e.g., PostStatus: DRAFT, PUBLISHED)"
      - "Schema is validated at startup; invalid definitions cause a startup error with a descriptive message"
      - "Resolver functions receive (parent, args, context, info) and fetch data from the database"
      - "Context object is constructed per-request containing database connection and authenticated user (or null)"
      - "Authentication: mutations and protected queries check context.user; unauthenticated access returns an UNAUTHENTICATED error"
      - "Authorization: mutations verify the current user owns the resource being modified; unauthorized access returns a FORBIDDEN error"
      - "Resolver errors return structured GraphQL errors with appropriate error codes (UNAUTHENTICATED, FORBIDDEN, NOT_FOUND, BAD_USER_INPUT)"
    pitfalls:
      - "Making too many fields nullable leads to complex null handling on the client; prefer non-null with explicit error handling"
      - "Forgetting to define input types for mutation arguments; using object types as inputs is a schema error"
      - "Not planning for schema evolution; avoid removing fields, use @deprecated instead"
      - "Exposing entire database models through resolvers leaks sensitive fields (password_hash, internal IDs)"
      - "Not validating mutation arguments in resolvers; always validate before persisting"
      - "Blocking the event loop with synchronous database calls; use async resolvers"
    concepts:
      - Schema Definition Language (SDL) and type system
      - Resolver function signature and execution
      - Context object for per-request dependencies
      - Relay connection specification for pagination
      - Authentication and authorization in GraphQL
    skills:
      - GraphQL SDL schema design
      - Resolver implementation
      - Context-based authentication
      - Cursor-based pagination
      - Error handling with GraphQL error codes
    deliverables:
      - GraphQL schema with object types, input types, enums, and custom scalars
      - Query resolvers with cursor-based pagination
      - Mutation resolvers with input validation and authorization
      - Per-request context setup with auth user and database connection
      - Structured error responses with appropriate error codes
    estimated_hours: "12-15"

  - id: graphql-server-m2
    name: DataLoader & N+1 Prevention
    description: >-
      Implement DataLoader for batched data fetching to eliminate N+1
      queries, with per-request scoping and cache management.
    acceptance_criteria:
      - "DataLoader instances are created per-request in the context; they are NOT shared across requests"
      - "Batch function loads multiple records in a single database query (e.g., SELECT * FROM users WHERE id IN (...))"
      - "Batch function returns results in the same order as the input keys; missing keys return null/error at the corresponding index"
      - "For a query fetching 10 posts with authors, database query count is reduced from 11 (1 + N) to 2 (1 for posts, 1 batched for authors)"
      - "Query count reduction is verified by logging or counting database queries per request in tests"
      - "DataLoader cache is scoped to the request; data loaded in one request does not leak to another"
      - "Nested resolvers (e.g., Post → Author → Posts) use DataLoader throughout, preventing N+1 at every nesting level"
    pitfalls:
      - "Sharing DataLoader instances across requests causes stale data and cross-user data leaks—this is a security vulnerability"
      - "Creating new DataLoader instances inside individual resolvers defeats batching; they must be in the request context"
      - "Batch function must return results in the exact order of input keys; out-of-order results cause data corruption"
      - "Not handling batch errors per-key means one missing record fails the entire batch"
      - "Caching mutable data in DataLoader without invalidation returns stale data within the same request after a mutation"
    concepts:
      - DataLoader batching window and request coalescing
      - Per-request instance scoping
      - Batch function contract (ordered results, per-key errors)
      - Cache key strategy
      - N+1 query detection and measurement
    skills:
      - DataLoader implementation and integration
      - Batched database queries
      - Per-request caching
      - Query performance measurement
    deliverables:
      - DataLoader factory creating per-request instances in context
      - Batch functions for each entity type using IN-clause queries
      - Integration of DataLoader into all nested resolvers
      - Test demonstrating query count reduction from N+1 to 2
      - Per-key error handling in batch functions
    estimated_hours: "8-10"

  - id: graphql-server-m3
    name: Query Complexity & Security
    description: >-
      Implement query depth limiting, complexity analysis, and security
      hardening to prevent abusive queries.
    acceptance_criteria:
      - "Query depth is limited to a configurable maximum (e.g., 10 levels); queries exceeding the limit are rejected before execution with a descriptive error"
      - "Query complexity is calculated by assigning cost to each field (default 1, list fields multiplied by expected count); queries exceeding a configurable budget are rejected"
      - "Introspection is disabled in production to prevent schema leakage (configurable per environment)"
      - "Field-level authorization prevents accessing sensitive fields (e.g., user.email) by unauthorized roles"
      - "Query complexity cost and remaining budget are returned in the response extensions for client visibility"
    pitfalls:
      - "Not limiting query depth allows attackers to craft deeply nested queries that cause exponential resolver execution"
      - "Static complexity analysis underestimates list fields; multiply field cost by the requested limit/first argument"
      - "Disabling introspection in development breaks tooling like GraphiQL; only disable in production"
      - "Field-level auth in resolvers is tedious; consider schema directives or middleware for consistent enforcement"
    concepts:
      - Query depth analysis via AST traversal
      - Complexity cost calculation with multipliers
      - Schema introspection control
      - Field-level authorization
      - Response extensions for metadata
    skills:
      - Query complexity analysis
      - AST-based query validation
      - Security hardening
      - Schema directive implementation
    deliverables:
      - Query depth limiter rejecting over-nested queries
      - Complexity calculator with per-field cost and list multipliers
      - Introspection toggle based on environment configuration
      - Field-level authorization middleware
      - Complexity budget reporting in response extensions
    estimated_hours: "6-8"

  - id: graphql-server-m4
    name: Real-Time Subscriptions
    description: >-
      Implement GraphQL subscriptions over WebSocket with pub/sub event
      routing, authentication, filtering, and lifecycle management.
    acceptance_criteria:
      - "WebSocket transport uses the graphql-transport-ws protocol (graphql-ws library) for subscription connections"
      - "Client establishes WebSocket connection with connection_init message including auth token; unauthenticated connections are rejected"
      - "Subscription resolvers return an async iterator/generator yielding events from a pub/sub system"
      - "Events are published to named topics when mutations occur (e.g., postCreated, commentAdded)"
      - "Subscription filtering ensures clients receive only events matching their subscription arguments (e.g., subscribe to comments on a specific post)"
      - "Client disconnection triggers cleanup: subscription iterators are closed, pub/sub listeners are removed, no resource leaks"
      - "Connection keep-alive pings are sent at a configurable interval to detect dead WebSocket connections"
    pitfalls:
      - "Not authenticating subscription connections allows unauthenticated users to receive real-time data"
      - "Not cleaning up subscription iterators and pub/sub listeners on disconnect causes memory leaks"
      - "Sending entire entity objects in subscription payloads when clients only need a few fields wastes bandwidth; let the subscription resolver be re-executed with the event payload"
      - "Not filtering events per-user permissions allows subscription to bypass authorization"
      - "Using the deprecated subscriptions-transport-ws protocol (legacy) instead of graphql-transport-ws"
    concepts:
      - graphql-transport-ws protocol lifecycle
      - Pub/Sub pattern for event distribution
      - Async iterator/generator for subscription resolvers
      - Topic-based event routing with filtering
      - Connection initialization and authentication
    skills:
      - WebSocket transport configuration
      - Pub/Sub implementation
      - Async iterator patterns
      - Subscription filtering
      - Connection lifecycle management
    deliverables:
      - WebSocket transport setup using graphql-transport-ws protocol
      - Pub/Sub system for publishing and subscribing to named topics
      - Subscription resolvers yielding filtered events
      - Authentication during connection_init
      - Connection lifecycle handling with cleanup on disconnect
      - Keep-alive ping mechanism
    estimated_hours: "8-12"