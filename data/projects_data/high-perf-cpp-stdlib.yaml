id: high-perf-cpp-stdlib
name: High-Performance C++ Standard Library
description: >
  Build custom optimized containers and utilities that outperform the standard
  library for specific HFT and low-latency workloads. Implement FlatHashMap,
  SSO String, SmallVector, and memory-efficient data structures.

difficulty: advanced
estimated_hours: 60-80
domain: performance-engineering

essence: >
  Cache-friendly data structures with custom memory layouts, small buffer
  optimizations, branch reduction techniques, and SIMD-aware algorithms.
  Understanding when and why to deviate from std:: containers.

why_important: >
  HFT firms and low-latency systems pay $300K-800K+ for engineers who can
  squeeze every nanosecond. Standard library containers are general-purpose;
  custom containers can be 2-10x faster for specific workloads.

learning_outcomes:
  - Implement FlatHashMap with open addressing and Robin Hood hashing
  - Build Small String Optimization (SSO) string class
  - Create SmallVector with small buffer optimization
  - Implement custom allocators for arena/pool patterns
  - Understand cache-friendly memory layouts
  - Benchmark and prove performance improvements
  - Handle exception safety in high-performance code
  - Profile and optimize memory access patterns

skills:
  - Container Design
  - Memory Layout Optimization
  - SSO Implementation
  - Hash Table Internals
  - Custom Allocators
  - Cache-Aware Design
  - SIMD-Friendly Layouts
  - Micro-benchmarking

tags:
  - advanced
  - c++
  - containers
  - data-structures
  - hft
  - low-latency
  - memory-optimization
  - performance

languages:
  recommended:
    - C++
  also_possible: []

resources:
  - name: "CppCon: High Performance C++ Containers"
    url: https://www.youtube.com/watch?v=vElZcX5LcHU
    type: video
  - name: "Folly Documentation (Facebook's Library)"
    url: https://github.com/facebook/folly
    type: reference
  - name: "Abseil Container Design"
    url: https://abseil.io/about/design/swisstables
    type: documentation
  - name: "Eastl (EA Standard Template Library)"
    url: https://github.com/electronicarts/EASTL
    type: reference

prerequisites:
  - type: skill
    name: Advanced C++ (templates, move semantics, RAII)
  - type: skill
    name: Understanding of cache hierarchy and memory layout
  - type: skill
    name: Proficiency with profiling tools (perf, VTune)
  - type: project
    name: data structures implementation experience

milestones:
  - id: hpcpp-m1
    name: SmallVector with SBO
    description: >
      Implement a vector class with small buffer optimization that avoids
      heap allocation for small numbers of elements.
    acceptance_criteria:
      - SmallVector stores N elements inline (configurable)
      - Heap allocation only when exceeding inline capacity
      - Move operations are noexcept and O(1)
      - Iterator invalidation rules documented and correct
      - Benchmark shows 3-10x speedup for small vectors vs std::vector
      - Memory footprint matches expectations (inline + pointer overhead)
      - Supports emplace_back with perfect forwarding
    pitfalls:
      - Inline capacity affects sizeof(SmallVector) - balance carefully
      - Move from inline to heap must be exception-safe
      - Iterator invalidation differs from std::vector during grow
      - Alignment requirements for inline storage
      - Debug vs release performance differs significantly
    concepts:
      - Small Buffer Optimization (SBO)
      - Inline storage
      - Exception safety during grow
      - Iterator stability
    skills:
      - SBO implementation
      - Exception-safe code
      - Memory layout design
      - Benchmark methodology
    deliverables:
      - SmallVector implementation
      - Unit tests covering edge cases
      - Benchmark vs std::vector
      - Memory footprint analysis
    estimated_hours: "10-14"

  - id: hpcpp-m2
    name: SSO String Class
    description: >
      Implement a string class with Small String Optimization that stores
      short strings inline without heap allocation.
    acceptance_criteria:
      - SSO capacity of at least 22 bytes (typical for 64-bit)
      - Zero heap allocations for strings fitting in SSO capacity
      - Copy-on-write NOT used (COW is deprecated/problematic)
      - All string operations (append, substr, etc.) work correctly
      - Benchmark shows significant improvement for short strings
      - Compatible with std::string_view for string operations
      - Proper handling of null terminator in SSO mode
    pitfalls:
      - SSO capacity affects sizeof(String) - larger = more cache misses
      - Switching between SSO and heap must be exception-safe
      - Short string optimization complicates move semantics
      - String view lifetime issues
      - Different ABIs for std::string cause interoperability issues
    concepts:
      - Small String Optimization
      - String representation
      - Memory locality for short strings
      - ABI compatibility
    skills:
      - SSO implementation
      - String manipulation
      - Exception safety
      - ABI considerations
    deliverables:
      - SSO String implementation
      - Comprehensive string tests
      - Benchmark vs std::string
      - Size analysis (sizeof)
    estimated_hours: "10-14"

  - id: hpcpp-m3
    name: FlatHashMap with Open Addressing
    description: >
      Implement a hash map using open addressing with Robin Hood hashing
      for superior cache performance compared to std::unordered_map.
    acceptance_criteria:
      - Open addressing with linear/quadratic probing
      - Robin Hood hashing reduces probe lengths
      - Load factor configurable (default 0.7-0.8)
      - Supports heterogeneous lookup (string_view for string keys)
      - Benchmark shows 2-5x improvement over std::unordered_map
      - Tombstone handling for erase operations
      - Iterator stability requirements documented
    pitfalls:
      - High load factor degrades performance dramatically
      - Erase with tombstones wastes memory; need rehash
      - Hash quality critical for distribution
      - Key type requirements differ from std::unordered_map
      - Reference/iterator invalidation more aggressive
    concepts:
      - Open addressing
      - Robin Hood hashing
      - Probe sequences
      - Load factor
    skills:
      - Hash table implementation
      - Probing strategies
      - Memory-efficient design
      - Performance tuning
    deliverables:
      - FlatHashMap implementation
      - Hash function adapters
      - Benchmark vs std::unordered_map
      - Probe length analysis
    estimated_hours: "14-16"

  - id: hpcpp-m4
    name: Custom Allocators
    description: >
      Implement arena and pool allocators for predictable memory behavior
      and cache-friendly allocation patterns.
    acceptance_criteria:
      - Arena allocator for bulk allocation/deallocation
      - Pool allocator for fixed-size objects
      - Monotonic allocator for append-only patterns
      - Aligned allocation support (cache line, page)
      - Zero fragmentation for appropriate use cases
      - Thread-local allocator option
      - Memory statistics tracking
    pitfalls:
      - Arena deallocators don't free individual objects
      - Pool allocator requires knowing object size at compile time
      - Thread-local allocators increase memory usage
      - Mixing allocators causes undefined behavior
      - Lifetime management more complex
    concepts:
      - Arena allocation
      - Pool allocation
      - Memory alignment
      - Fragmentation avoidance
    skills:
      - Allocator design
      - Memory patterns
      - Alignment handling
      - Statistics tracking
    deliverables:
      - Arena allocator
      - Pool allocator
      - Aligned allocation helpers
      - Usage documentation
    estimated_hours: "12-14"

  - id: hpcpp-m5
    name: SIMD-Friendly Containers & Benchmarking
    description: >
      Design containers with SIMD-friendly memory layouts and create
      comprehensive benchmarks proving performance improvements.
    acceptance_criteria:
      - Container layouts support SIMD vectorization
      - Aligned memory access for SIMD loads
      - Structure-of-Arrays (SoA) vs Array-of-Structures (AoS) options
      - Benchmark harness with statistical analysis
      - Comparisons against std:: equivalents with graphs
      - Memory access pattern documentation
      - Cache miss analysis with perf counters
    pitfalls:
      - SIMD layouts increase code complexity
      - SoA better for SIMD but worse for object-oriented code
      - Benchmarks sensitive to compiler flags and CPU
      - False sharing in multi-threaded benchmarks
      - Results may not generalize to all workloads
    concepts:
      - SIMD-friendly layout
      - Structure of Arrays
      - Benchmark methodology
      - Cache analysis
    skills:
      - SIMD-aware design
      - Benchmark creation
      - Performance analysis
      - Documentation
    deliverables:
      - SIMD-friendly container variant
      - Benchmark harness
      - Performance report with graphs
      - Cache analysis results
    estimated_hours: "12-16"
