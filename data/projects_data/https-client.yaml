id: https-client
name: HTTPS Client
description: >-
  Low-level TLS 1.3 client implementation performing handshake, certificate
  verification, and encrypted HTTP communication over raw TCP sockets.
difficulty: advanced
estimated_hours: "30-50"
essence: >-
  Low-level implementation of TLS 1.3 record framing, stateful cryptographic
  handshake protocol with transcript hashing, ECDHE-based key agreement,
  multi-stage HKDF key derivation, X.509 certificate chain verification, and
  AEAD-authenticated symmetric encryption over raw TCP sockets without relying
  on existing TLS libraries.
why_important: >-
  Building a TLS client from the ground up teaches the cryptographic primitives
  and security protocols that secure virtually all internet communication,
  providing deep understanding of public-key infrastructure, cipher suites, and
  attack surface mitigation essential for backend, security, and systems
  engineering roles.
learning_outcomes:
  - Implement TLS 1.3 record layer protocol with proper framing, content type routing, and fragment reassembly
  - Construct ClientHello messages with cipher suite negotiation, supported_versions, key_share, and SNI extensions
  - Perform elliptic curve Diffie-Hellman ephemeral (ECDHE) key exchange using X25519 for perfect forward secrecy
  - Implement the TLS 1.3 multi-stage key schedule (Early Secret → Handshake Secret → Master Secret) via HKDF-Extract and HKDF-Expand-Label
  - Validate X.509 certificate chains including signature verification, hostname matching, and trust anchor resolution
  - Implement AEAD cipher modes (AES-128-GCM) for authenticated encryption of application data
  - Handle TLS alerts, handshake state machine transitions, and EncryptedExtensions processing
  - Maintain running transcript hash of all handshake messages for key derivation and Finished verification
skills:
  - Cryptographic Protocols
  - Public Key Infrastructure
  - Elliptic Curve Cryptography
  - X.509 Certificate Validation
  - Symmetric Encryption (AEAD)
  - HKDF Key Derivation
  - Binary Protocol Parsing
  - Network Security
  - TLS 1.3 State Machine
tags:
  - advanced
  - certificates
  - go
  - python
  - rust
  - security
  - tls-1.3
  - tool
  - verification
architecture_doc: architecture-docs/https-client/index.md
languages:
  recommended:
    - Python
    - Go
    - Rust
  also_possible:
    - C
    - Java
resources:
  - name: TLS 1.3 RFC 8446
    url: https://datatracker.ietf.org/doc/html/rfc8446
    type: specification
  - name: Illustrated TLS 1.3
    url: https://tls13.xargs.org/
    type: tutorial
  - name: X.509 Certificate RFC 5280
    url: https://datatracker.ietf.org/doc/html/rfc5280
    type: specification
prerequisites:
  - type: skill
    name: TCP socket programming
  - type: skill
    name: Cryptography basics (symmetric/asymmetric, hashing)
  - type: skill
    name: X.509 certificate structure awareness
  - type: skill
    name: Binary data manipulation (struct packing, endianness)
milestones:
  - id: https-client-m1
    name: TCP Socket & TLS Record Layer
    description: >-
      Establish TCP connection and implement the TLS record layer protocol
      for framing, routing, and fragment reassembly.
    acceptance_criteria:
      - "TCP connect to remote host on port 443 with configurable timeout"
      - "Parse TLS record 5-byte header extracting content_type (1 byte), legacy_record_version (2 bytes), and length (2 bytes) in network byte order"
      - "Enforce maximum record size of 16384 bytes (2^14) per RFC 8446 Section 5.1; reject oversized records"
      - "Route records by content_type to correct handler (handshake=22, alert=21, change_cipher_spec=20, application_data=23)"
      - "Reassemble fragmented handshake messages split across multiple TLS records into complete messages"
      - "Handle partial TCP reads by buffering until complete record is available"
      - "Implement record writing with proper header construction and payload framing"
    pitfalls:
      - "All multi-byte fields in TLS are big-endian (network byte order); x86 is little-endian"
      - "TCP recv() may return partial data; must loop until expected bytes are received"
      - "In TLS 1.3, legacy_record_version is always 0x0303 (TLS 1.2) for middlebox compatibility, NOT 0x0304"
      - "A single handshake message may span multiple records, AND multiple handshake messages may be in one record"
      - "Record content type changes meaning after handshake completes (all post-handshake is application_data with inner content type)"
    concepts:
      - TLS record protocol framing
      - Network byte order and binary parsing
      - TCP stream reassembly
      - Protocol multiplexing by content type
    skills:
      - TCP socket programming with timeouts
      - Binary protocol implementation
      - Buffer management for stream reassembly
      - Network I/O error handling
    deliverables:
      - TCP connection manager with configurable connect/read timeouts
      - TLS record parser extracting header fields and payload
      - Record writer constructing properly framed TLS records
      - Fragment reassembly buffer for handshake messages
      - Content type router dispatching records to appropriate handler
    estimated_hours: "3-5"

  - id: https-client-m2
    name: ClientHello & ServerHello
    description: >-
      Construct and send ClientHello with TLS 1.3 extensions, parse
      ServerHello response including version negotiation.
    acceptance_criteria:
      - "Generate 32 cryptographically secure random bytes for ClientHello.random field"
      - "Set legacy_version to 0x0303 (TLS 1.2) and negotiate actual version via supported_versions extension listing 0x0304 (TLS 1.3)"
      - "Include legacy_session_id as non-empty random bytes for middlebox compatibility (NOT for session resumption)"
      - "Cipher suite list includes TLS_AES_128_GCM_SHA256 (0x1301) as minimum required suite"
      - "SNI extension (type 0x0000) includes target hostname for correct certificate selection"
      - "key_share extension includes client's ephemeral X25519 public key"
      - "supported_groups extension lists x25519 (0x001d) and optionally secp256r1"
      - "signature_algorithms extension lists rsa_pss_rsae_sha256 and ecdsa_secp256r1_sha256"
      - "Parse ServerHello extracting server_random, selected cipher suite, and selected key_share"
      - "Verify ServerHello supported_versions extension contains 0x0304 confirming TLS 1.3 negotiation"
      - "Detect HelloRetryRequest (server_random equals SHA-256 of 'HelloRetryRequest' string) and handle appropriately"
      - "Initialize transcript hash with hash of ClientHello and ServerHello messages"
    pitfalls:
      - "Extension ordering does not matter per spec, but some buggy servers are sensitive to it"
      - "Length fields are nested (extensions_length contains multiple extension structs each with their own length)"
      - "legacy_session_id in TLS 1.3 is NOT used for session resumption; it's purely for middlebox compatibility"
      - "If ServerHello doesn't include supported_versions extension with 0x0304, you're getting TLS 1.2 (different protocol)"
      - "Transcript hash must include the complete handshake message (type + length + body), not just the body"
    concepts:
      - TLS 1.3 version negotiation via supported_versions extension
      - ClientHello/ServerHello message structure
      - Extension encoding and parsing
      - Middlebox compatibility measures
      - Transcript hash initialization
    skills:
      - Protocol message construction with nested length fields
      - Cryptographic random number generation
      - Extension encoding and parsing
      - TLS version negotiation
    deliverables:
      - ClientHello builder with all required TLS 1.3 extensions
      - ServerHello parser extracting selected cipher suite and key_share
      - supported_versions validation confirming TLS 1.3 negotiation
      - Transcript hash initializer accumulating handshake messages
      - HelloRetryRequest detection and handling
    estimated_hours: "5-7"

  - id: https-client-m3
    name: Key Exchange & Key Schedule
    description: >-
      Perform ECDHE key exchange using X25519, then derive handshake traffic
      keys using TLS 1.3's multi-stage HKDF key schedule.
    acceptance_criteria:
      - "Generate ephemeral X25519 key pair (32-byte private key, 32-byte public key)"
      - "Compute ECDH shared secret from client private key and server's key_share public key"
      - "Validate shared secret is not all-zeros (indicates invalid peer public key)"
      - "Derive Early Secret from HKDF-Extract(salt=0, ikm=0) per RFC 8446 Section 7.1"
      - "Derive Handshake Secret from HKDF-Extract(salt=Derive-Secret(Early Secret, \"derived\", \"\"), ikm=shared_secret)"
      - "Derive client_handshake_traffic_secret and server_handshake_traffic_secret using transcript hash at ServerHello"
      - "Expand traffic secrets into encryption keys and IVs using HKDF-Expand-Label with key_length and iv_length from cipher suite"
      - "Decrypt server's EncryptedExtensions, Certificate, CertificateVerify, and Finished messages using server_handshake_traffic_secret"
      - "Process EncryptedExtensions message (may contain ALPN, server_name acknowledgment)"
    pitfalls:
      - "TLS 1.3 has NO 'pre-master secret'; it uses a staged hierarchy (Early → Handshake → Master Secret)"
      - "HKDF-Expand-Label format is specific to TLS 1.3 and includes a 'tls13 ' prefix in the label"
      - "Transcript hash must be updated with each handshake message IN ORDER before deriving next secret"
      - "X25519 private keys must be clamped (specific bits set/cleared) per RFC 7748"
      - "After ServerHello, all subsequent handshake messages are encrypted; must decrypt before parsing"
      - "Wrong transcript hash at any stage produces wrong keys and decryption silently produces garbage"
    concepts:
      - ECDHE key exchange with X25519
      - TLS 1.3 key schedule (Early → Handshake → Master)
      - HKDF-Extract and HKDF-Expand-Label
      - Transcript hash dependency chain
      - Encrypted handshake messages
    skills:
      - Elliptic curve Diffie-Hellman computation
      - HKDF key derivation function
      - Transcript hash management
      - AEAD decryption of handshake records
    deliverables:
      - X25519 key pair generation and shared secret computation
      - Multi-stage key schedule implementation (Early → Handshake → Master Secret)
      - HKDF-Expand-Label implementing TLS 1.3 specific label format
      - Handshake traffic key derivation for both client and server directions
      - Encrypted handshake message decryption and parsing
      - EncryptedExtensions message processing
    estimated_hours: "7-10"

  - id: https-client-m4
    name: Certificate Chain Verification
    description: >-
      Parse X.509 certificates from the server's Certificate message and
      verify the chain of trust, hostname, and validity.
    acceptance_criteria:
      - "Parse Certificate handshake message extracting ordered list of DER-encoded X.509 certificates"
      - "Parse each X.509 certificate extracting subject, issuer, validity dates, public key, and extensions"
      - "Build certificate chain from server (leaf) certificate to a trusted root CA in the system trust store"
      - "Verify each certificate's signature using the issuer's public key (RSA-PSS or ECDSA)"
      - "Reject certificates with notBefore in the future or notAfter in the past"
      - "Verify leaf certificate's Subject Alternative Name (SAN) extension matches the target hostname"
      - "Check Basic Constraints extension: CA certificates must have cA=TRUE, leaf must not"
      - "Verify CertificateVerify message signature over transcript hash using server's public key"
      - "Reject self-signed certificates not in the trust store"
      - "Handle certificate chain with intermediate CAs (not just leaf → root)"
    pitfalls:
      - "Hostname matching must check SAN extension, NOT Common Name (CN) per RFC 6125"
      - "Wildcard certificates (*.example.com) match only one level of subdomain"
      - "Certificate chain may be sent out of order by server; must sort by issuer/subject relationship"
      - "CertificateVerify in TLS 1.3 signs a specific context string + transcript hash, not just the hash"
      - "System trust store location varies by OS (/etc/ssl/certs on Linux, Keychain on macOS)"
      - "ASN.1/DER parsing is complex; consider using a library for this specific part"
      - "Missing intermediate certificates cause verification failure even if root is trusted"
    concepts:
      - X.509 certificate structure and extensions
      - Certificate chain of trust model
      - Digital signature verification (RSA-PSS, ECDSA)
      - Subject Alternative Name hostname matching
      - CertificateVerify message in TLS 1.3
    skills:
      - X.509 certificate parsing (DER/ASN.1)
      - PKI chain building and validation
      - Digital signature verification
      - Hostname verification per RFC 6125
    deliverables:
      - X.509 certificate parser extracting key fields from DER encoding
      - Certificate chain builder linking leaf to trusted root CA
      - Signature verification for each link in the certificate chain
      - Hostname verification against SAN extension with wildcard support
      - Validity date checking rejecting expired or not-yet-valid certificates
      - CertificateVerify signature validation over TLS 1.3 transcript
    estimated_hours: "7-10"

  - id: https-client-m5
    name: Handshake Completion & Encrypted Communication
    description: >-
      Verify Finished messages, derive application traffic keys, and
      exchange encrypted HTTP request/response data.
    acceptance_criteria:
      - "Verify server's Finished message by computing HMAC over transcript hash with server_handshake_traffic_secret"
      - "Send client's Finished message computed with client_handshake_traffic_secret"
      - "Derive Master Secret from HKDF-Extract(salt=Derive-Secret(Handshake Secret, \"derived\", \"\"), ikm=0)"
      - "Derive client_application_traffic_secret_0 and server_application_traffic_secret_0 from Master Secret"
      - "Switch to application traffic keys for all subsequent record encryption/decryption"
      - "Encrypt application data using AES-128-GCM with nonce = XOR(IV, sequence_number) per RFC 8446 Section 5.3"
      - "Sequence number increments per-record per-direction starting from 0; nonce reuse causes catastrophic failure"
      - "Send encrypted HTTP/1.1 GET request and decrypt the response successfully"
      - "Handle TLS alerts (at minimum: close_notify for graceful shutdown, unexpected_message, bad_record_mac)"
      - "Send close_notify alert before closing TCP connection for graceful TLS termination"
      - "Verify response decryption produces valid HTTP response with expected headers and body"
    pitfalls:
      - "Nonce reuse with AES-GCM is CATASTROPHIC; it reveals the authentication key and allows forgery"
      - "Sequence numbers are 64-bit and MUST NOT wrap; close connection before overflow (practically impossible but must handle)"
      - "TLS 1.3 application data records have an inner content type byte after the plaintext that must be parsed"
      - "After decryption, strip trailing zero padding bytes BEFORE the inner content type byte"
      - "Application traffic keys are different from handshake traffic keys; using wrong keys produces garbage"
      - "HTTP response may span multiple TLS records; must reassemble at application layer"
      - "close_notify is a warning-level alert, not fatal; both sides should send it"
    concepts:
      - Finished message verification
      - Application traffic key derivation
      - AEAD nonce construction from IV and sequence number
      - TLS 1.3 inner content type
      - Graceful TLS termination
    skills:
      - AEAD encryption/decryption (AES-128-GCM)
      - Nonce management and sequence numbers
      - Alert protocol handling
      - HTTP over encrypted channel
    deliverables:
      - Finished message computation and verification for both client and server
      - Master Secret and application traffic key derivation
      - AES-128-GCM encryption with proper nonce construction
      - HTTP request encryption and response decryption
      - Alert handling for close_notify and error conditions
      - End-to-end test: connect to a real HTTPS server and retrieve a page
    estimated_hours: "7-10"