id: integration-testing
name: Integration Testing Suite
description: Comprehensive integration testing framework with containerized dependencies, API testing, service mocking, contract testing, and deterministic test isolation.
difficulty: advanced
estimated_hours: 18-28
essence: Coordinating multi-component interactions across network boundaries, data persistence layers, and external service contracts while maintaining test isolation through container lifecycle management, deterministic clock control, dynamic port allocation, and readiness probing despite asynchronous operations and stateful dependencies.
why_important: Most production failures occur at component boundaries rather than within units. Mastering test isolation, container readiness, database setup, service mocking, and clock control enables you to catch regression bugs early, eliminate flaky tests, and deploy with confidence.
learning_outcomes:
- Configure isolated test databases with schema migrations, fixture management, and readiness probes
- Implement end-to-end API tests validating request/response contracts with real HTTP clients on dynamic ports
- Design test doubles and mocking strategies for external service dependencies with contract fidelity
- Build test harnesses that manage setup, teardown, and cleanup of stateful resources with deterministic ordering
- Debug failures in asynchronous workflows using clock mocking and deterministic time control
- Implement test data builders and factories for complex domain objects
- Apply test isolation techniques including dynamic port allocation and network namespacing to prevent interference
- Validate cross-cutting concerns like authentication, authorization, and error handling across layers
skills:
- Test Isolation
- Database Testing
- HTTP Client Testing
- Service Mocking
- Test Fixtures
- Asynchronous Testing
- Test Data Management
- Contract Validation
- Container Readiness Probing
- Clock Mocking
tags:
- advanced
- assertions
- cleanup
- containers
- fixtures
- java
- javascript
- python
- testing
architecture_doc: architecture-docs/integration-testing/index.md
languages:
  recommended:
  - Python
  - JavaScript
  - Java
  also_possible:
  - Go
  - Ruby
resources:
- name: Testcontainers
  url: https://www.testcontainers.org/
  type: documentation
- name: Martin Fowler - Integration Testing
  url: https://martinfowler.com/bliki/IntegrationTest.html
  type: article
- name: Testcontainers Getting Started Guides
  url: https://testcontainers.com/guides/
  type: tutorial
- name: Pact Contract Testing
  url: https://docs.pact.io/
  type: documentation
prerequisites:
- type: skill
  name: Unit testing
- type: skill
  name: Docker basics
- type: skill
  name: Database knowledge (SQL)
- type: skill
  name: HTTP fundamentals
milestones:
- id: integration-testing-m1
  name: Test Database Setup with Readiness Probing
  description: Set up isolated database containers for testing with readiness probes, schema migrations, fixture management, and inter-test cleanup.
  acceptance_criteria:
  - Test database is started in a Docker container with randomized port mapping to avoid port conflicts in parallel CI runs
  - Readiness probe polls the database container (e.g., pg_isready, mysqladmin ping) and blocks test execution until the database accepts connections, with a configurable timeout (default 30s)
  - Schema migrations run automatically before the test suite executes, creating all required tables and indexes
  - Each test starts with a clean database state achieved via transaction rollback (preferred) or table truncation; no data leaks between tests
  - 'Test ordering independence is verified: running the test suite in randomized order produces the same pass/fail results'
  - Database container is torn down and removed after the test suite completes, freeing all resources including volumes
  pitfalls:
  - 'Not waiting for container readiness: the container port is open but the database process is still initializing—always use application-level readiness checks, not just TCP port checks'
  - Port conflicts in CI when multiple test suites run in parallel on the same host—always use dynamic port mapping (docker -P or Testcontainers' random port)
  - Transaction rollback cleanup doesn't work for DDL statements in some databases (e.g., MySQL auto-commits DDL)—know your database's transaction semantics
  - Data leaking between tests via sequences or auto-increment IDs that don't reset on truncation—use RESTART IDENTITY with TRUNCATE
  concepts:
  - Container readiness probing
  - Test isolation via transaction rollback
  - Dynamic port allocation
  - Database fixtures and factories
  skills:
  - Docker container management
  - Database schema migrations
  - Test data isolation strategies
  - Fixture and factory patterns
  deliverables:
  - Database container launcher with dynamic port mapping and application-level readiness probe
  - Schema migration runner executing before test suite start
  - Test data seeding utilities with factory pattern for deterministic fixture generation
  - Inter-test cleanup mechanism using transaction rollback or TRUNCATE with verification
  estimated_hours: 3-5
- id: integration-testing-m2
  name: API Integration Tests
  description: Test API endpoints with real HTTP requests against a running test server on a dynamic port, including authentication flows and error handling.
  acceptance_criteria:
  - Test server starts on a randomly assigned port to avoid conflicts; the port is communicated to test HTTP clients programmatically
  - Real HTTP requests are made to the running server using a configured HTTP client; responses include full status code, headers, and body
  - Response assertions verify status codes, JSON body structure, header values, and response times (< configurable threshold)
  - 'Complete authentication flow is tested: registration -> login -> token issuance -> protected endpoint access -> token expiry rejection'
  - 'Error cases are tested: invalid input returns 400, unauthorized returns 401, not found returns 404, and server errors return 500 with safe error messages'
  - Tests are independent and runnable in any order; no test depends on side effects of another test
  pitfalls:
  - 'Test order dependencies: test B relies on data created by test A—use per-test setup/teardown to ensure independence'
  - Shared mutable state (e.g., global user count) across tests causes non-deterministic failures
  - Slow tests from unnecessary database seeding—seed only the data each test needs, not a global fixture
  - Token expiry tests require clock control—without clock mocking, you either wait real seconds or skip the test
  concepts:
  - API testing with real HTTP
  - Test server lifecycle
  - Authentication testing
  - Clock mocking for time-sensitive tests
  skills:
  - HTTP client configuration
  - JWT token generation for tests
  - Request/response validation
  - Clock/time mocking
  deliverables:
  - Test server launcher with dynamic port binding and programmatic port discovery
  - HTTP test client with request builder, response assertions, and configurable timeouts
  - Authentication test helpers for user creation, login, and token management
  - Error case test suite verifying proper HTTP error responses for all expected failure modes
  estimated_hours: 4-5
- id: integration-testing-m3
  name: External Service Mocking with Contract Fidelity
  description: Mock external APIs while testing real internal integration, with contract verification to ensure mocks match real API schemas.
  acceptance_criteria:
  - Mock HTTP server intercepts outbound calls to external APIs and returns predefined responses based on URL, method, and header matching
  - Request verification confirms external APIs were called with correct URL, method, headers, and body content
  - 'Error simulation: mock returns configurable HTTP error codes (500, 503, timeout) to test error handling and retry paths'
  - 'Retry logic test: mock fails the first N requests then succeeds, verifying the application retries with correct backoff'
  - 'Network isolation is enforced: an unmatched outbound HTTP call raises an error rather than hitting a real external API'
  - Mock response schemas are validated against the real API's OpenAPI/Swagger spec (or a recorded contract) to prevent mock drift
  pitfalls:
  - Missing mock for an API endpoint causes a real HTTP call to production—always enforce network isolation (block all unmocked outbound calls)
  - 'Mock drift: the mock returns a response format the real API no longer uses—contract tests or schema validation catch this'
  - 'Mock setup order: registering mocks after the test starts can miss early requests—setup all mocks before any application code runs'
  - Mocking at the wrong layer (e.g., mocking the HTTP client instead of the network) can mask real serialization/deserialization bugs
  concepts:
  - HTTP request interception
  - Service virtualization
  - Contract fidelity verification
  - Network isolation in tests
  skills:
  - Mock server configuration
  - Network stub libraries (WireMock, responses, nock)
  - Contract testing patterns
  - Error response simulation
  deliverables:
  - Mock HTTP server with URL/method/header matching and configurable response stubs
  - Request verification assertions confirming call parameters for each mocked endpoint
  - Network isolation enforcer blocking unmocked outbound HTTP calls during tests
  - Contract fidelity validator checking mock responses against OpenAPI/recorded API schemas
  estimated_hours: 4-5
- id: integration-testing-m4
  name: Multi-Service Test Infrastructure
  description: Use Testcontainers to orchestrate multiple service dependencies (database, cache, message broker) with proper lifecycle management and CI integration.
  acceptance_criteria:
  - Tests use Testcontainers (or equivalent) for PostgreSQL, Redis, and at least one message broker (RabbitMQ or Kafka)
  - Each container has an application-level readiness probe that blocks test execution until the service is accepting commands
  - Containers use dynamic port mapping; no hardcoded ports in test configuration
  - Container configurations are reusable across test modules via a shared test fixture library
  - CI pipeline runs containerized tests without manual Docker setup; Docker socket access or DinD is configured
  - Total test suite startup time (all containers ready) is measured and reported; target < 60 seconds
  pitfalls:
  - 'Slow container startup: pulling images on every CI run—use pre-cached images or a local registry mirror'
  - Port conflicts in CI from hardcoded ports—always use Testcontainers' automatic port mapping
  - 'Docker socket permissions: CI runner may not have access to /var/run/docker.sock—document required permissions'
  - Container cleanup failure on test abort leaves orphaned containers consuming resources—use Testcontainers' Ryuk sidecar for automatic cleanup
  concepts:
  - Testcontainers lifecycle management
  - Multi-service test orchestration
  - CI/CD container integration
  - Readiness probing
  skills:
  - Testcontainers API
  - Docker networking
  - CI integration
  - Performance measurement
  deliverables:
  - Testcontainers configuration for PostgreSQL, Redis, and a message broker with readiness probes
  - Reusable test fixture library with shared container configurations and data seeding utilities
  - CI pipeline configuration running containerized tests with Docker access
  - Startup time benchmark measuring container provisioning and readiness overhead
  estimated_hours: 4-6
- id: integration-testing-m5
  name: Contract Testing & End-to-End Flows
  description: Implement consumer-driven contract tests between services and end-to-end test flows with flaky test detection and reporting.
  acceptance_criteria:
  - Consumer-driven contracts (using Pact or similar) define expected API interactions from the consumer perspective
  - Provider verification replays consumer contracts against the real provider API and reports compatibility
  - End-to-end tests cover at least one full user flow (signup -> action -> verification) spanning multiple services
  - Flaky test detection identifies tests that produce inconsistent results across N runs (configurable, default 5) and flags them
  - Test report is generated with pass/fail counts, execution time per test, failure details, and flaky test annotations
  - Clock mocking utility is available for testing time-sensitive operations (token expiry, cache TTL, scheduled tasks) deterministically
  pitfalls:
  - 'Brittle E2E tests: testing UI details or exact response bodies that change frequently—test behavior and contracts, not implementation details'
  - 'Contract versioning: provider changes break consumer contracts—use semantic versioning and can-i-deploy checks'
  - 'Test environment drift: E2E test environment diverges from production configuration—use infrastructure-as-code to keep them aligned'
  - 'Clock mocking that leaks into other tests: always restore the real clock in teardown'
  concepts:
  - Consumer-driven contract testing
  - E2E testing strategy
  - Flaky test detection and quarantine
  - Deterministic clock control
  skills:
  - Pact or contract testing framework
  - E2E test design
  - Test reporting and analysis
  - Clock mocking techniques
  deliverables:
  - Consumer contract definitions using Pact (or equivalent) for at least two service interactions
  - Provider verification runner replaying contracts against real provider with compatibility report
  - E2E test suite covering a critical user flow with retry and timeout handling
  - Flaky test detector that runs tests N times and reports inconsistent results
  - Clock mocking utility for deterministic time-sensitive test scenarios
  estimated_hours: 5-7
domain: software-engineering
