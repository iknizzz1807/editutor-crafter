id: interrupt-driven-system
name: Interrupt-Driven System
description: >
  Build an interrupt-driven embedded system for real-time control applications.
  Implement interrupt handlers, debouncing, state machines, and real-time
  response to external events.

difficulty: intermediate
estimated_hours: 30-45
domain: systems

essence: >
  Event-driven execution through hardware interrupt handling, priority-based
  interrupt nesting, efficient ISR design, deferred processing for non-critical
  work, and deterministic response time to external events.

why_important: >
  Interrupt-driven design is fundamental to embedded systems. Understanding
  real-time event handling is valuable at $120K-200K+ for firmware engineers.

learning_outcomes:
  - Implement hardware interrupt handlers
  - Build interrupt priority management
  - Implement input debouncing algorithms
  - Build finite state machines for control
  - Handle timer interrupts for scheduling
  - Implement deferred processing (main loop)
  - Build watchdog timer for reliability
  - Measure and optimize interrupt latency

skills:
  - Interrupt Handling
  - Priority Management
  - Input Debouncing
  - State Machines
  - Timer Interrupts
  - Deferred Processing
  - Watchdog Timers
  - Latency Measurement

tags:
  - intermediate
  - embedded
  - interrupts
  - real-time
  - firmware
  - microcontroller

languages:
  recommended:
    - C
    - Rust
  also_possible: []

resources:
  - name: "Embedded Systems - Introduction"
    url: https://users.ece.utexas.edu/~valvano/
    type: course
  - name: "Making Embedded Systems"
    url: https://www.oreilly.com/library/view/making-embedded-systems/9781449308885/
    type: book
  - name: "ARM Cortex-M Programming"
    url: https://developer.arm.com/documentation/
    type: documentation
  - name: "AVR Libc"
    url: https://www.nongnu.org/avr-libc/
    type: documentation

prerequisites:
  - type: skill
    name: C programming
  - type: skill
    name: Basic electronics understanding
  - type: skill
    name: Microcontroller basics
  - type: skill
    name: Understanding of registers and memory-mapped I/O

milestones:
  - id: interrupt-m1
    name: Basic Interrupt Handling
    description: >
      Implement basic interrupt handlers for external
      and timer interrupts.
    acceptance_criteria:
      - GPIO interrupt on pin change
      - Timer interrupt at configurable interval
      - ISR registration and vector table
      - Interrupt enable/disable control
      - Global interrupt management
      - Basic ISR timing measurement
    pitfalls:
      - Forgetting to clear interrupt flag
      - ISR too long blocks other interrupts
      - Race conditions with main code
      - Stack usage in ISR
    concepts:
      - Interrupt vectors
      - ISR structure
      - Flag clearing
      - Global enable/disable
    skills:
      - ISR implementation
      - Vector setup
      - Flag management
      - Timing measurement
    deliverables:
      - GPIO ISR
      - Timer ISR
      - Interrupt API
      - Timing measurement
    estimated_hours: "8-10"

  - id: interrupt-m2
    name: Interrupt Priority & Nesting
    description: >
      Implement interrupt priority management and nested
      interrupt handling.
    acceptance_criteria:
      - Configurable priority levels (at least 4)
      - Higher priority interrupts preempt lower
      - Priority configuration per interrupt source
      - Priority inversion prevention
      - Critical section implementation
      - Priority inheritance (optional)
    pitfalls:
      - Priority inversion
      - Unbounded nesting
      - Starvation of low priority
      - Critical section length
    concepts:
      - Priority levels
      - Nesting
      - Preemption
      - Critical sections
    skills:
      - Priority implementation
      - Nesting handling
      - Critical sections
      - Priority management
    deliverables:
      - Priority system
      - Nesting support
      - Critical section API
      - Priority configuration
    estimated_hours: "6-8"

  - id: interrupt-m3
    name: Input Debouncing & Edge Detection
    description: >
      Implement robust input handling with debouncing
      and edge detection.
    acceptance_criteria:
      - Software debouncing with configurable delay
      - Hardware debouncing (if available)
      - Rising/falling edge detection
      - Both-edge detection
      - Debounce without blocking
      - Works for buttons and switches
    pitfalls:
      - Debounce time too short or long
      - Blocking delay in debounce
      - Multiple triggers from noise
      - Mechanical switch variability
    concepts:
      - Debouncing
      - Edge detection
      - Input filtering
      - Non-blocking design
    skills:
      - Debounce algorithm
      - Edge detection
      - Timer integration
      - Noise filtering
    deliverables:
      - Debounce function
      - Edge detector
      - Button handler
      - Configuration API
    estimated_hours: "6-8"

  - id: interrupt-m4
    name: State Machine for Control
    description: >
      Implement finite state machine for event-driven
      control logic.
    acceptance_criteria:
      - State machine with defined states and transitions
      - Event-driven state changes
      - Entry/exit actions per state
      - Hierarchical states (optional)
      - State machine visualization (optional)
      - Example: traffic light, motor controller
    pitfalls:
      - State explosion
      - Missing transitions
      - Non-deterministic behavior
      - Action timing
    concepts:
      - State machines
      - Transitions
      - Actions
      - Event handling
    skills:
      - FSM design
      - Transition logic
      - Action implementation
      - Testing
    deliverables:
      - State machine framework
      - Example application
      - Transition table
      - Testing harness
    estimated_hours: "6-8"

  - id: interrupt-m5
    name: Deferred Processing & Watchdog
    description: >
      Implement deferred processing pattern and watchdog
      timer for system reliability.
    acceptance_criteria:
      - Main loop processes deferred work from ISRs
      - Queue of pending tasks from interrupts
      - Watchdog timer initialization
      - Watchdog kick in main loop
      - Watchdog timeout handling (reset)
      - System hangs detected and recovered
    pitfalls:
      - Deferred queue overflow
      - Watchdog kick too early or late
      - Missing watchdog initialization
      - Infinite loops bypassing watchdog
    concepts:
      - Deferred processing
      - Main loop pattern
      - Watchdog timers
      - System reliability
    skills:
      - Queue implementation
      - Main loop design
      - Watchdog setup
      - Recovery handling
    deliverables:
      - Deferred task queue
      - Main loop framework
      - Watchdog driver
      - Recovery logic
    estimated_hours: "6-8"
