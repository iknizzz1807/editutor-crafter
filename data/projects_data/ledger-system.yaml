id: ledger-system
name: Double-entry Ledger System
description: Accounting system with immutable journal entries, double-entry enforcement, cryptographic tamper-evidence, period locking, and financial reporting.
difficulty: advanced
estimated_hours: 55
essence: Append-only transaction recording with atomic debit-credit pairs that maintain the fundamental accounting equation (Assets = Liabilities + Equity) across account hierarchies, using cryptographic hash chaining for tamper-evidence and supporting efficient balance reconstruction through materialized running totals over immutable journal entries.
why_important: Financial systems require absolute correctness - building this teaches immutability patterns, data integrity constraints, cryptographic audit trails, and the accounting domain model that apply broadly to distributed ledgers, blockchain applications, and any system where verifiable state transitions and regulatory compliance matter.
learning_outcomes:
- Implement the double-entry accounting model enforcing debits equal credits on every journal entry
- Design an immutable append-only journal with cryptographic hash chaining for tamper detection
- Build efficient balance calculation using materialized running totals with point-in-time queries
- Implement period locking to prevent retroactive modification of closed accounting periods
- Generate standard financial reports (trial balance, income statement, balance sheet) from ledger data
- Handle multi-currency transactions with exchange rate tracking at transaction and reporting dates
skills:
- Double-entry accounting
- Transaction integrity
- Cryptographic hash chaining
- Balance calculation
- Immutable audit logging
- Financial reporting
- Period locking
- Multi-currency handling
tags:
- advanced
- audit-trail
- databases
- double-entry
- immutable
- reconciliation
- storage
- cryptography
architecture_doc: architecture-docs/ledger-system/index.md
languages:
  recommended:
  - Go
  - Rust
  - Java
  also_possible:
  - Python
resources:
- name: Martin Fowler's Accounting Patterns
  url: https://martinfowler.com/eaaDev/AccountingNarrative.html
  type: article
- name: Double-Entry Accounting for Engineers
  url: https://anvil.works/blog/double-entry-accounting-for-engineers
  type: tutorial
- name: Accounting for Developers Part I
  url: https://www.moderntreasury.com/journal/accounting-for-developers-part-i
  type: article
- name: SQL Server Ledger - Immutable Audit Trails
  url: https://dzone.com/articles/sql-server-ledger-tamper-evident-audit-trails
  type: article
- name: Designing Real-Time Ledger Systems
  url: https://finlego.com/tpost/c2pjjza3k1-designing-a-real-time-ledger-system-with
  type: tutorial
prerequisites:
- type: skill
  name: Relational database design and SQL
- type: skill
  name: Database transactions and isolation levels
- type: skill
  name: REST API design
- type: skill
  name: Basic cryptographic hashing
milestones:
- id: ledger-system-m1
  name: Chart of Accounts & Entry Model
  description: Design the core ledger data model with account types, hierarchy, journal entry structure, and multi-currency support.
  acceptance_criteria:
  - Five account types are supported with correct normal balances - asset (debit-normal), liability (credit-normal), equity (credit-normal), revenue (credit-normal), expense (debit-normal)
  - Accounts have a hierarchical structure with parent-child relationships for chart of accounts nesting (e.g., Assets > Current Assets > Cash)
  - Journal entries contain a header (entry ID, date, description, status) and multiple line items each referencing an account with a debit or credit amount
  - Every journal entry enforces that the sum of all debit amounts equals the sum of all credit amounts; unbalanced entries are rejected before persistence
  - All monetary amounts are stored as fixed-point integers (e.g., cents) or decimal types with explicit precision - never as floating-point
  - Multi-currency accounts store amounts in their native currency with the exchange rate at transaction date recorded on the journal entry
  - Account codes follow a configurable numbering scheme (e.g., 1000-1999 for assets, 2000-2999 for liabilities)
  pitfalls:
  - Using floating-point for monetary amounts causes rounding errors that accumulate and make reconciliation impossible
  - Not validating that debit/credit lines reference account types consistent with the operation (e.g., debiting a revenue account reduces revenue)
  - Allowing deletion of accounts that have posted entries breaks referential integrity and audit trail
  - Multi-currency without storing the exchange rate at transaction time makes historical reporting unreliable
  - Account hierarchy depth must be bounded to prevent infinite recursion in balance aggregation
  concepts:
  - Double-entry principle - every debit must have an equal and opposite credit
  - Account type normal balances (debit-normal vs credit-normal)
  - Chart of accounts hierarchy with parent-child nesting
  - Immutable journal entry design with posting date and reference
  - Fixed-point integer arithmetic for monetary precision
  skills:
  - Schema design
  - Account type modeling
  - Multi-currency
  - Data integrity constraints
  deliverables:
  - Account table with ID, code, name, type, currency, parent reference, and active status
  - Journal entry header table with entry ID, date, description, posting status, and created timestamp
  - Journal entry line items table linking entries to accounts with debit or credit amounts
  - Normal balance rules engine enforcing correct debit/credit behavior per account type
  - Multi-currency amount storage with exchange rate at transaction date
  - Account hierarchy supporting parent-child relationships
  estimated_hours: 10
- id: ledger-system-m2
  name: Transaction Recording & Immutability
  description: Record journal entries atomically with double-entry validation, idempotency, and strict immutability for posted entries.
  acceptance_criteria:
  - Journal entries are created atomically within a database transaction - either all line items are posted or none are on failure
  - Balance validation rejects any entry where the sum of debits does not equal the sum of credits, returning a clear error
  - Each journal entry receives a unique auto-generated ID and sequential entry number for audit reference
  - Idempotency key prevents duplicate entries from retried API requests; the same key returns the original entry
  - Posted journal entries cannot be modified (UPDATE) or deleted (DELETE) at the database level; corrections are made via reversal entries only
  - Entry reversal creates a new journal entry with all debits and credits swapped, referencing the original entry ID
  - Concurrent journal entry posting is handled correctly under database transaction isolation (serializable or snapshot isolation)
  - Transaction metadata fields store arbitrary key-value pairs (invoice number, memo, external reference)
  pitfalls:
  - Not wrapping all line items in a single database transaction causes partial posts where some debits are recorded without their corresponding credits
  - Missing idempotency on the write path causes duplicate entries when clients retry after network timeouts
  - Allowing posted entries to be modified breaks the audit trail and makes reconciliation impossible
  - Reversal entries must exactly mirror the original - any discrepancy creates an imbalance
  - Under READ COMMITTED isolation, concurrent entries can interleave and cause incorrect running balance updates; use SERIALIZABLE or explicit locking
  concepts:
  - Atomic transaction boundaries for all-or-nothing posting
  - Database isolation levels and their impact on concurrent entry recording
  - Idempotency keys for duplicate prevention
  - Reversal entry pattern (never modify, always reverse and re-post)
  - Immutability at the database level (triggers or policies preventing UPDATE/DELETE)
  skills:
  - Transaction atomicity
  - Idempotency
  - Immutability enforcement
  - Concurrency control
  deliverables:
  - Journal entry creation API posting all line items atomically within a database transaction
  - Debit-equals-credit validation rejecting unbalanced entries
  - Idempotency key system preventing duplicate entries from retried requests
  - Database-level immutability enforcement preventing UPDATE and DELETE on posted entries
  - Entry reversal API creating offsetting entries to correct posted transactions
  - Concurrent posting test suite verifying correctness under parallel entry creation
  estimated_hours: 10
- id: ledger-system-m3
  name: Balance Calculation & Running Totals
  description: Implement efficient balance calculation using materialized running totals with point-in-time query support.
  acceptance_criteria:
  - Current account balance is computed as the sum of all posted debits minus credits (for debit-normal accounts) or credits minus debits (for credit-normal accounts)
  - Running balance table maintains a materialized balance per account, updated atomically when new entries are posted
  - Point-in-time balance query returns the correct account balance as of a specified date by considering only entries posted on or before that date
  - Trial balance report lists all accounts with their debit and credit column totals; the difference between total debits and total credits is zero
  - Balance queries respond in under 100ms for a ledger with 1 million+ journal entries
  - Hierarchical balance aggregation computes parent account balances by summing all descendant account balances
  - Running balance cache is invalidated and updated atomically with each new journal entry post to prevent stale reads
  pitfalls:
  - Recalculating balances by scanning all entries on every query causes O(n) performance degradation as the ledger grows
  - Not respecting account type sign conventions (debit-normal vs credit-normal) produces incorrect balance signs
  - Missing indexes on posting date and account ID columns causes slow point-in-time queries
  - Running balance updates must be atomic with entry posting; updating them asynchronously creates temporary inconsistency windows
  - Trial balance not summing to zero indicates a bug in the entry validation logic - treat this as a critical system integrity failure
  concepts:
  - Materialized running balance tables for O(1) current balance queries
  - Point-in-time balance using date-filtered entry aggregation
  - Account type sign conventions (debit-normal: debits increase, credits decrease)
  - Trial balance as a fundamental integrity check
  - Hierarchical balance aggregation across account trees
  skills:
  - Running balance maintenance
  - Point-in-time queries
  - Query optimization
  - Aggregation
  deliverables:
  - Current balance calculator using materialized running totals per account
  - Point-in-time balance query computing balance as of a specified date
  - Running balance table updated atomically with each posted journal entry
  - Trial balance report verifying total debits equal total credits system-wide
  - Hierarchical balance aggregation summing descendant account balances
  - Performance benchmark verifying sub-100ms balance queries at 1M+ entries
  estimated_hours: 10
- id: ledger-system-m4
  name: Audit Trail & Cryptographic Integrity
  description: Implement immutable audit logging with cryptographic hash chaining for tamper-evidence and compliance.
  acceptance_criteria:
  - Every posted journal entry includes a SHA-256 hash computed over the entry data concatenated with the previous entry's hash, forming a chain
  - Tampering with any historical entry is detectable by re-computing the hash chain and finding the first mismatch
  - Hash chain verification API validates the entire chain or a date range and reports any integrity violations
  - All system actions (entry creation, reversal, account changes, user logins) are logged with timestamp, actor identity, action type, and before/after values
  - Audit log entries are append-only and cannot be modified or deleted at the database level
  - User action audit distinguishes between the person who entered the transaction and the person who authorized/approved it
  - Audit reports can be generated for any date range showing all entries, reversals, and system actions
  pitfalls:
  - Hash chain must include the previous hash, not just the current entry data - without chaining, individual entries can be replaced without detection
  - Storing audit logs in mutable database tables defeats the purpose - enforce append-only constraints at the database level
  - Not recording who authorized vs who entered transactions fails dual-control audit requirements
  - Hash chain recomputation is O(n) on the full chain - support partial verification over date ranges for efficiency
  - Audit log storage grows indefinitely - implement archival to cold storage while preserving the hash chain integrity
  concepts:
  - Cryptographic hash chaining (each entry hashes over previous entry's hash + current data)
  - Append-only storage guarantees for regulatory compliance
  - Tamper detection via hash chain verification
  - Dual-control audit (enterer vs authorizer separation)
  - Event sourcing for complete state change audit trail
  skills:
  - Cryptographic hashing
  - Hash chain design
  - Immutability enforcement
  - Audit logging
  deliverables:
  - SHA-256 hash chain linking each journal entry to its predecessor
  - Hash chain verification API detecting tampering in any historical entry
  - Append-only audit log recording all system actions with timestamps and actors
  - Entry authorization tracking distinguishing enterer from authorizer
  - Audit report generator producing compliance reports for specified date ranges
  - Tamper detection alerting when hash chain verification fails
  estimated_hours: 10
- id: ledger-system-m5
  name: Period Locking & Financial Reports
  description: Implement accounting period management with locking, closing entries, and standard financial report generation.
  acceptance_criteria:
  - Accounting periods (monthly, quarterly, yearly) can be opened and closed via API; closed periods reject all new journal entry posts with a clear error
  - Period closing process generates closing entries that transfer revenue and expense balances to retained earnings, zeroing the income/expense accounts
  - Balance sheet report displays assets, liabilities, and equity at a specified date; assets equal liabilities plus equity (the accounting equation)
  - Income statement report shows revenue minus expenses for a specified period, producing net income
  - Trial balance report is generated pre-close and post-close to verify integrity at each step
  - Reports are exportable in PDF and CSV formats with proper formatting and headers
  - Multi-currency reporting converts foreign currency balances at the period-end closing exchange rate with translation adjustments
  - Period locking is enforced at the database level - not just application logic - to prevent bypass via direct SQL
  pitfalls:
  - Not enforcing period locking allows retroactive entry posting that changes historical financial reports - this is an audit failure
  - Calculating income statement without proper period date filtering includes entries from outside the reporting period
  - Closing entries must zero out ALL revenue and expense accounts; missing accounts create carried-forward balances that corrupt future periods
  - Multi-currency translation uses closing rate for balance sheet items but average rate for income statement items - mixing these up produces incorrect reports
  - Generating reports without first validating the trial balance may produce reports that don't balance - always verify integrity first
  concepts:
  - Accounting period lifecycle (open -> posting -> closing -> closed)
  - Closing entries transferring temporary account balances to retained earnings
  - Balance sheet: assets = liabilities + equity at a point in time
  - Income statement: revenue - expenses over a period
  - Multi-currency translation (closing rate for balance sheet, average rate for income statement)
  - Period locking enforcement at database level
  skills:
  - Period management
  - Closing entries
  - Report generation
  - Multi-currency translation
  deliverables:
  - Period management API for opening, closing, and querying accounting periods
  - Period locking enforcement preventing journal entries into closed periods at database level
  - Closing entries generator transferring income/expense balances to retained earnings
  - Balance sheet generator displaying assets, liabilities, and equity at a point in time
  - Income statement generator computing revenue minus expenses for a period
  - Multi-currency translation converting foreign balances at period-end exchange rates
  - Report export module outputting PDF and CSV formats
  estimated_hours: 15
domain: specialized
