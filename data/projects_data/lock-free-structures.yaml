id: lock-free-structures
name: Lock-free Data Structures
description: >-
  Lock-free stack, queue, and hash map using CAS operations with safe memory
  reclamation via hazard pointers.
difficulty: advanced
estimated_hours: 55
essence: >-
  Thread-safe data structure design using atomic compare-and-swap operations
  without traditional mutex locks, requiring deep understanding of memory
  ordering semantics, the ABA problem, and safe memory reclamation via hazard
  pointers or epoch-based reclamation to prevent use-after-free in concurrent
  environments.
why_important: >-
  Lock-free programming is essential for building high-performance systems
  that avoid contention bottlenecks. Mastering atomic operations, memory
  ordering, ABA prevention, and safe memory reclamation provides deep
  understanding of CPU-level concurrency primitives used in production
  databases, operating systems, and real-time applications.
learning_outcomes:
  - Implement compare-and-swap loops with correct memory ordering for different synchronization needs
  - Demonstrate the ABA problem and implement prevention via tagged pointers or hazard pointers
  - Build a lock-free Treiber stack with CAS-based push and pop operations
  - Implement the Michael-Scott lock-free FIFO queue with helping mechanism
  - Design safe memory reclamation using hazard pointers to prevent use-after-free
  - Build a lock-free hash map with atomic insert, lookup, and delete operations
  - Verify linearizability of lock-free structures under concurrent stress testing
skills:
  - Atomic operations (CAS, FAA)
  - Memory ordering (relaxed, acquire, release, seq_cst)
  - ABA problem and prevention
  - Hazard pointers
  - Lock-free algorithms
  - Linearizability verification
tags:
  - aba-problem
  - advanced
  - atomic
  - cas
  - concurrency
  - lock-free
  - memory-reclamation
architecture_doc: architecture-docs/lock-free-structures/index.md
languages:
  recommended:
    - C
    - C++
    - Rust
  also_possible:
    - Java
resources:
  - name: C++ Atomic Operations Reference
    url: https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange
    type: documentation
  - name: Michael-Scott Queue Paper
    url: https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf
    type: paper
  - name: Hazard Pointers Paper (Michael 2004)
    url: https://www.cs.otago.ac.nz/cosc440/readings/hazard-pointers.pdf
    type: paper
  - name: Lock-Free Programming in Java
    url: https://www.baeldung.com/lock-free-programming
    type: tutorial
  - name: Compare-and-Swap Tutorial
    url: https://jenkov.com/tutorials/java-concurrency/compare-and-swap.html
    type: tutorial
  - name: Split-Ordered Lists Paper (Shalev & Shavit 2006)
    url: https://www.cs.ucf.edu/~dcm/Teaching/COT4810-Spring2011/Literature/SplitOrderedLists.pdf
    type: paper
prerequisites:
  - type: skill
    name: Concurrency basics (threads, mutexes, race conditions)
  - type: skill
    name: CPU memory model and cache coherence concepts
  - type: skill
    name: C/C++ or Rust systems programming
milestones:
  - id: lock-free-structures-m1
    name: Atomic Operations & Memory Ordering
    description: >-
      Understand and implement atomic primitives with correct memory ordering
      semantics. Demonstrate the ABA problem.
    acceptance_criteria:
      - "Compare-and-swap wrapper atomically updates a variable only if it equals the expected value; returns success/failure and the observed value on failure"
      - "Memory ordering is correctly applied - relaxed for counters, acquire on loads, release on stores, seq_cst only where required for total ordering"
      - "ABA problem is demonstrated with a concrete test case showing a CAS incorrectly succeeding because the value was changed and changed back"
      - "Atomic counter incremented by N threads (each incrementing M times) produces exactly N*M as the final value with zero lost updates"
      - "Fetch-and-add operation atomically increments a counter and returns the previous value"
      - "A test demonstrates that relaxed ordering can produce counter-intuitive results that acquire/release prevents"
    pitfalls:
      - "Assuming sequential consistency everywhere is safe but wastes performance; using relaxed everywhere is fast but produces incorrect results"
      - "Spinning indefinitely in CAS loops without backoff wastes CPU and can cause livelock under contention"
      - "Mixing atomic and non-atomic operations on the same shared variable is undefined behavior in C/C++"
      - "The ABA problem is not theoretical - it causes real crashes in naive lock-free stacks and queues"
      - "Platform-specific differences in memory models (x86 TSO vs ARM weak ordering) mean code that works on x86 may break on ARM"
    concepts:
      - Compare-and-swap (CAS) loop patterns and retry logic
      - Memory ordering constraints (relaxed, acquire, release, acquire-release, sequentially consistent)
      - CPU cache coherence (MESI protocol) and visibility guarantees
      - ABA problem definition and consequences
      - Happens-before relationships in concurrent execution
    skills:
      - Atomic operations
      - Memory ordering
      - CAS loops
    deliverables:
      - Atomic load, store, and CAS wrappers with configurable memory ordering
      - Fetch-and-add operation for atomic counter increment
      - ABA problem demonstration test case with annotated explanation
      - Memory ordering test showing relaxed vs acquire/release behavioral difference
      - Concurrent counter stress test verifying no lost updates
    estimated_hours: 10

  - id: lock-free-structures-m2
    name: Lock-free Treiber Stack
    description: >-
      Implement the Treiber stack using CAS-based push and pop with
      tagged pointers for ABA prevention.
    acceptance_criteria:
      - "Push atomically prepends a new node to the stack top using CAS on the top pointer with no mutex locks"
      - "Pop atomically removes and returns the top node using CAS with ABA prevention via tagged pointers (version counter)"
      - "Tagged pointer combines a pointer with a monotonically increasing counter; CAS compares both pointer and counter to detect ABA"
      - "Concurrent push and pop from 16+ threads produces no lost elements, no duplicated elements, and no crashes over 1M operations"
      - "Empty stack pop returns a sentinel/error value without blocking or crashing"
      - "Stack is linearizable - each operation appears to take effect atomically at a single point in time"
      - "NOTE: Memory reclamation of popped nodes is deferred to Milestone 4 (Hazard Pointers); nodes may leak in this milestone"
    pitfalls:
      - "Tagged pointers require double-width CAS (128-bit on 64-bit platforms via cmpxchg16b) - verify hardware support"
      - "Reusing popped nodes immediately (without safe reclamation) causes use-after-free; explicitly leak nodes until M4"
      - "Not handling the empty stack case in pop leads to null pointer dereference"
      - "Memory leaks from nodes lost during failed CAS operations if retry logic doesn't clean up"
      - "Without the version counter (naive CAS on pointer alone), ABA causes stack corruption"
    concepts:
      - Top-of-stack pointer updates using single-word CAS
      - ABA problem in stack pop and tagged pointer prevention
      - Linearization points in push (successful CAS) and pop (successful CAS)
      - Double-width CAS for tagged pointer atomicity
      - Deferred memory reclamation awareness
    skills:
      - Treiber stack algorithm
      - CAS-based push/pop
      - Tagged pointer ABA prevention
    deliverables:
      - Node struct with data payload and atomic next pointer
      - Lock-free push using CAS on top pointer
      - Lock-free pop using CAS with tagged pointer ABA prevention
      - ABA demonstration showing naive pop corruption and tagged pointer fix
      - Concurrent stress test with 16+ threads verifying no data loss over 1M ops
      - Empty stack handling returning error/sentinel on pop
    estimated_hours: 10

  - id: lock-free-structures-m3
    name: Michael-Scott Lock-free Queue
    description: >-
      Implement the Michael-Scott FIFO queue with sentinel node, two-pointer
      design, and helping mechanism.
    acceptance_criteria:
      - "Queue uses separate head (for dequeue) and tail (for enqueue) pointers with a dummy sentinel node separating them"
      - "Enqueue atomically appends a new node at the tail using a two-step CAS (link node, advance tail)"
      - "Dequeue atomically removes and returns the node after head using CAS, advancing head past the sentinel"
      - "Helping mechanism ensures any thread that observes a lagging tail pointer advances it before proceeding"
      - "FIFO ordering is strictly preserved - elements dequeue in exactly the order they were enqueued"
      - "Empty queue dequeue returns a not-found indicator without blocking"
      - "Concurrent enqueue and dequeue from 16+ threads over 1M operations preserves FIFO order with no lost or duplicated elements"
      - "NOTE: Memory reclamation of dequeued nodes is deferred to Milestone 4; nodes may leak"
    pitfalls:
      - "Not advancing the tail pointer when it lags behind the actual tail causes all subsequent enqueues to fail"
      - "The helping step (advancing a lagging tail) is essential for lock-freedom - without it, a stalled enqueuer blocks all others"
      - "Premature node reclamation while another thread is reading the node's next pointer causes use-after-free"
      - "Forgetting to handle the case where head equals tail (empty queue or single element) causes dequeue bugs"
      - "Incorrect linearization when multiple threads simultaneously help the same lagging tail"
    concepts:
      - Two-pointer design separating enqueue (tail) from dequeue (head)
      - Sentinel dummy node simplifying empty queue handling
      - Helping mechanism ensuring lock-free progress guarantee
      - Two-step enqueue (link then swing tail)
      - Linearization points for enqueue and dequeue
    skills:
      - Michael-Scott queue algorithm
      - Two-pointer queue design
      - Helping mechanism
      - Lock-freedom proof
    deliverables:
      - Queue struct with atomic head and tail pointers initialized to sentinel node
      - Lock-free enqueue with two-step CAS (link new node, advance tail)
      - Lock-free dequeue with CAS on head, returning data from the node after head
      - Tail-advance helping mechanism for threads observing lagging tail
      - FIFO order verification test under concurrent load
      - Linearizability argument documenting operation atomicity points
    estimated_hours: 10

  - id: lock-free-structures-m4
    name: Hazard Pointers & Memory Reclamation
    description: >-
      Implement the hazard pointer memory reclamation scheme and integrate
      it with the lock-free stack and queue to eliminate memory leaks.
    acceptance_criteria:
      - "Each thread has a fixed number of hazard pointer slots (typically 1-2 per data structure operation)"
      - "Before accessing a node obtained from a CAS, the thread publishes the node's address in its hazard pointer slot"
      - "Retired (removed from data structure) nodes are added to a per-thread retirement list"
      - "When the retirement list exceeds a threshold (e.g., 2 * num_threads * hazard_slots), a scan-and-reclaim pass frees nodes not in any thread's hazard set"
      - "Memory reclamation is verified by running the stack and queue stress tests with reclamation enabled and checking that total allocated memory remains bounded"
      - "Hazard pointer is set BEFORE loading the node pointer and validated AFTER - the classic \"set-then-validate\" protocol prevents the race"
      - "Thread exit cleanup releases all hazard slots and reclaims all remaining retired nodes"
      - "Integration with Treiber stack and Michael-Scott queue replaces the deferred-leak approach from M2/M3"
    pitfalls:
      - "Setting the hazard pointer AFTER loading the node pointer is a race condition - the node can be freed between load and protect"
      - "Forgetting to clear the hazard pointer after finishing node access prevents reclamation of that node permanently (memory leak)"
      - "Unbounded retirement list growth without periodic reclamation scan causes effective memory leak"
      - "Incorrect memory ordering when publishing hazard pointers (must use at least release/acquire) can miss protections"
      - "The scan-and-reclaim phase must be efficient; scanning all threads' hazard pointers on every retirement is too expensive"
    concepts:
      - Per-thread hazard pointer slots protecting currently accessed nodes
      - Retirement list for deferred deletion of unprotected nodes
      - Threshold-based reclamation to amortize scan cost
      - Set-then-validate protocol for safe hazard pointer usage
      - Memory fence requirements when publishing hazard pointers
    skills:
      - Hazard pointer protocol
      - Safe memory reclamation
      - Deferred freeing
      - Integration with lock-free structures
    deliverables:
      - Hazard pointer registry with per-thread slots and global visibility
      - Protect (publish) and release (clear) operations for hazard pointer slots
      - Per-thread retirement list collecting removed nodes
      - Threshold-triggered scan-and-reclaim routine freeing unprotected retired nodes
      - Integration adapter adding hazard pointer protection to Treiber stack pop
      - Integration adapter adding hazard pointer protection to Michael-Scott queue dequeue
      - Memory boundedness test verifying no unbounded growth under sustained load
    estimated_hours: 12

  - id: lock-free-structures-m5
    name: Lock-free Hash Map
    description: >-
      Implement a concurrent hash map with lock-free insert, lookup, and
      delete operations using split-ordered lists.
    acceptance_criteria:
      - "Lock-free hash map supports concurrent insert, lookup, and delete without any mutex locks"
      - "Split-ordered list maintains a single sorted linked list with sentinel nodes at bucket boundaries"
      - "Bucket array is resized incrementally (doubling) without blocking concurrent readers or writers"
      - "Reverse-bit ordering of hash keys preserves list order during bucket splits"
      - "Concurrent operations from 16+ threads produce correct results - no lost inserts, no phantom reads, no double-deletes"
      - "Hazard pointers from M4 are used for safe memory reclamation of deleted nodes"
      - "Throughput benchmark compares lock-free hash map against a mutex-based hash map under varying contention levels"
      - "Load factor monitoring triggers resize when average chain length exceeds a configurable threshold"
    pitfalls:
      - "Not initializing parent buckets before accessing child buckets during incremental resize causes lookups to miss existing entries"
      - "Incorrect reverse-bit calculation places entries in wrong positions, corrupting the sorted list invariant"
      - "Missing sentinel node initialization during bucket split leaves dangling bucket pointers"
      - "Memory reclamation of nodes that appear in multiple logical buckets (via the shared list) requires careful hazard pointer integration"
      - "Contention hotspots on popular buckets with skewed hash distribution degrade to near-sequential performance"
    concepts:
      - Split-ordered list maintaining logical hash order in a physical sorted linked list
      - Recursive bucket splitting for incremental lock-free resizing
      - Sentinel nodes marking bucket boundaries in the underlying list
      - Reverse-bit ordering preserving list structure during splits
      - Lock-free insertion into sorted list with CAS
    skills:
      - Concurrent hash map design
      - Split-ordered lists
      - Lock-free resizing
      - Hazard pointer integration
    deliverables:
      - Split-ordered list with sentinel nodes at bucket boundaries
      - Lock-free insert adding key-value pairs at correct position in sorted list
      - Lock-free lookup traversing from bucket sentinel to find matching key
      - Lock-free delete marking and physically removing entries with hazard pointer protection
      - Incremental resize doubling bucket array without blocking concurrent operations
      - Load factor monitor triggering resize when threshold is exceeded
      - Throughput benchmark comparing against mutex-based hash map
    estimated_hours: 13