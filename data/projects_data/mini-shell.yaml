id: mini-shell
name: Mini Shell
description: Unix shell with pipelines, I/O redirection, job control, and signal handling
difficulty: advanced
estimated_hours: 35-55
essence: 'Process lifecycle orchestration through fork/exec/wait, file descriptor manipulation for I/O redirection and pipes, shell expansion (variables, globs, tilde), signal-based asynchronous event handling, and process group management for terminal foreground/background control.

  '
why_important: 'Building a shell demystifies how operating systems manage processes and reveals the coordination between kernel syscalls, terminal drivers, and user-space programs. This project develops foundational systems programming skills essential for backend engineering, DevOps tooling, and understanding how production applications interact with the OS.

  '
learning_outcomes:
- Implement process creation and lifecycle management using fork, exec, and wait system calls
- Design parsers for command-line syntax including pipelines, I/O redirection, and shell expansions
- Understand WHY certain commands (cd, export) must be built-ins (they modify caller process state)
- Implement environment variable expansion, tilde expansion, and pathname globbing
- Build signal handlers for SIGINT, SIGTSTP, and SIGCHLD with proper signal masking
- Implement process group management and terminal control using setpgid and tcsetpgrp
- Handle asynchronous job state transitions between foreground, background, stopped, and terminated
- Debug race conditions and signal delivery timing issues in concurrent process coordination
- Manage file descriptor plumbing for pipes and redirections across multiple processes
skills:
- Process management
- Signal handling
- Job control
- System calls (fork/exec/wait)
- File descriptors and pipes
- Terminal control
- Shell expansion (variables, globs)
- Race condition debugging
tags:
- advanced
- c
- job-control
- pipes
- redirection
- rust
- scheduling
- systems
architecture_doc: architecture-docs/mini-shell/index.md
languages:
  recommended:
  - C
  - Rust
  also_possible:
  - Go
  - Zig
resources:
- type: article
  name: Writing Your Own Shell
  url: https://brennan.io/2015/01/16/write-a-shell-in-c/
- type: book
  name: Advanced Programming in Unix Environment - Ch 9 (Process Relationships)
  url: https://www.apuebook.com/
- type: documentation
  name: GNU Implementing a Shell
  url: https://www.gnu.org/software/libc/manual/html_node/Implementing-a-Shell.html
- type: documentation
  name: POSIX Shell Command Language
  url: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html
prerequisites:
- type: skill
  name: C programming or Rust
- type: skill
  name: Unix process model (fork, exec, wait)
- type: skill
  name: File descriptors
- type: skill
  name: Basic signal handling
milestones:
- id: mini-shell-m1
  name: Command Parsing and Execution
  description: 'Parse command lines into tokens, execute external commands via fork/exec, and implement essential built-in commands.

    '
  acceptance_criteria:
  - Tokenizer splits input on whitespace boundaries; single-quoted strings preserve literal content; double-quoted strings allow variable expansion but preserve spaces
  - External commands are located via PATH search and executed in a forked child process using execvp or equivalent
  - Built-in 'cd' changes the shell's working directory via chdir() and updates PWD; cd with no args goes to $HOME. Student must explain WHY cd cannot be external (chdir only affects calling process)
  - Built-in 'exit' terminates the shell with optional numeric exit code; student must explain why this must be built-in
  - Built-in 'export' sets environment variables inherited by child processes; student must explain why this must be built-in (setenv/putenv only affects calling process)
  - Built-in 'pwd' prints current working directory
  - Shell stores child exit status and makes it available as $?
  - Empty input and whitespace-only input are handled gracefully without errors or crashes
  pitfalls:
  - Forgetting to null-terminate the argv array passed to exec (exec expects NULL sentinel)
  - Not handling the case where execvp fails (e.g., command not found); child must _exit() to avoid fork bomb
  - Memory leaks in the tokenizer from not freeing allocated token arrays
  - Treating echo as necessarily built-in; it's typically external (/bin/echo) though many shells optimize it as built-in
  concepts:
  - Lexical analysis and tokenization
  - fork/exec pattern
  - Built-in vs external command distinction
  - Environment variable inheritance
  skills:
  - Process management with fork/exec/waitpid
  - Command-line parsing
  - Memory management
  - Error handling
  deliverables:
  - REPL loop displaying prompt and reading input
  - Tokenizer handling whitespace, single quotes, and double quotes
  - PATH-searching external command executor using fork + execvp
  - Built-in command dispatcher for cd, exit, export, pwd
  - Exit status tracking ($? variable)
  estimated_hours: 5-8
- id: mini-shell-m2
  name: Shell Expansions
  description: 'Implement environment variable expansion, tilde expansion, and pathname globbing before command execution.

    '
  acceptance_criteria:
  - Environment variable expansion replaces $VAR and ${VAR} with their values; undefined variables expand to empty string
  - Special variables $? (last exit status), $$ (shell PID), and $0 (shell name) are expanded correctly
  - Tilde expansion replaces leading ~ with $HOME and ~user with that user's home directory from /etc/passwd
  - Globbing expands *, ?, and [...] patterns against filenames in the current directory; unexpanded globs pass through literally
  - 'Expansion order follows POSIX: tilde → variable → field splitting → pathname (glob) → quote removal'
  - Expansions inside single quotes are suppressed; expansions inside double quotes expand variables but suppress globbing and field splitting
  pitfalls:
  - Expanding variables before tokenization can change token boundaries; expansion must happen after initial parsing but before exec
  - Glob expansion can produce zero matches; POSIX says the pattern passes through literally, but bash has nullglob option
  - Recursive glob expansion or expanding in the wrong directory breaks pathname matching
  - Not handling the case where $VAR contains spaces and is unquoted (field splitting must re-tokenize)
  concepts:
  - Shell expansion pipeline (POSIX order)
  - Variable scope and environment
  - Pathname pattern matching
  skills:
  - String processing and substitution
  - Pattern matching (fnmatch or equivalent)
  - POSIX compliance
  deliverables:
  - Variable expander substituting $VAR, ${VAR}, $?, $$
  - Tilde expander replacing ~ and ~user
  - Glob expander using opendir/readdir + fnmatch or equivalent
  - Quote removal pass stripping quotes after all expansions
  - Integration into the parsing pipeline before command execution
  estimated_hours: 5-7
- id: mini-shell-m3
  name: Pipes and I/O Redirection
  description: 'Implement pipelines and file-based I/O redirection.

    '
  acceptance_criteria:
  - Input redirection '<' reads command stdin from specified file; file-not-found produces an error message
  - Output redirection '>' writes command stdout to file, creating or truncating it; '>>' appends without truncation
  - Stderr redirection '2>' writes command stderr to specified file separately from stdout
  - Combined redirection '2>&1' redirects stderr to wherever stdout currently points
  - Pipeline 'cmd1 | cmd2 | cmd3' chains stdout→stdin across multiple commands; all pipeline processes run concurrently
  - All pipe file descriptors are properly closed in both parent and child processes after dup2; no fd leaks causing pipe hangs
  - Pipeline exit status is the exit code of the last command in the chain (POSIX behavior)
  - Redirections and pipes can be combined (e.g., cmd1 < in.txt | cmd2 > out.txt)
  pitfalls:
  - Fd leaks from not closing both ends of every pipe in the parent process cause children to hang waiting for EOF
  - Wrong order of dup2 calls when combining redirections (e.g., 2>&1 > file vs > file 2>&1 have different semantics)
  - Not closing the original fd after dup2 wastes file descriptors
  - Creating all pipes before forking any children risks fd table exhaustion for long pipelines; create pipes incrementally
  concepts:
  - File descriptors and dup2
  - Unix pipe semantics
  - File descriptor inheritance across fork
  skills:
  - Inter-process communication
  - File descriptor manipulation
  - Pipeline construction
  - Resource cleanup
  deliverables:
  - Pipe creation and fd plumbing for multi-stage pipelines
  - Input redirection (< file)
  - Output redirection (> file, >> file)
  - Stderr redirection (2> file, 2>&1)
  - Combined pipeline + redirection support
  estimated_hours: 6-9
- id: mini-shell-m4
  name: Signal Handling and Process Groups
  description: 'Set up signal infrastructure, process groups, and terminal control required for job control.

    '
  acceptance_criteria:
  - Shell process ignores SIGINT and SIGTSTP so it is not killed/stopped by Ctrl+C/Ctrl+Z
  - Each pipeline is placed in its own process group using setpgid() called in BOTH parent and child (to avoid race condition)
  - Foreground process group is given terminal control via tcsetpgrp() before the shell waits for it
  - Shell reclaims terminal control via tcsetpgrp(STDIN_FILENO, shell_pgid) after foreground job completes or stops
  - SIGCHLD handler reaps terminated background processes using waitpid(-1, ..., WNOHANG) in a loop and records their exit status
  - Signal masks are set with sigprocmask to block SIGCHLD during critical sections (job table updates) preventing race conditions
  - Child processes reset signal dispositions to SIG_DFL after fork and before exec so they respond normally to signals
  pitfalls:
  - Race between parent's setpgid() and child's exec(); BOTH parent and child must call setpgid() to guarantee the group is set before either proceeds
  - SIGCHLD handler must only call async-signal-safe functions (write, waitpid, etc.); printf, malloc are NOT safe
  - Interrupted system calls (EINTR) from signal delivery; read() and waitpid() must be retried on EINTR
  - Not blocking SIGCHLD while modifying the job table can corrupt shared data structures
  - Forgetting to call tcsetpgrp() means Ctrl+C/Ctrl+Z go to the shell instead of the foreground job
  concepts:
  - Process groups and sessions
  - Terminal controlling process
  - Signal masking and async-signal safety
  - tcsetpgrp/tcgetpgrp
  skills:
  - Signal handler implementation
  - Process group management
  - Terminal session control
  - Race condition prevention
  deliverables:
  - Shell signal setup (ignore SIGINT, SIGTSTP, SIGTTOU)
  - Process group creation for each pipeline
  - Terminal control transfer via tcsetpgrp()
  - SIGCHLD handler with async-signal-safe waitpid loop
  - Signal mask management during job table updates
  - Child signal disposition reset before exec
  estimated_hours: 7-10
- id: mini-shell-m5
  name: Job Control
  description: 'Implement background execution, job table, and fg/bg/jobs built-ins.

    '
  acceptance_criteria:
  - Trailing '&' launches a pipeline in the background; shell prints '[job_number] PID' and immediately shows next prompt
  - Job table tracks each job's job number, process group ID, command string, and state (running, stopped, done)
  - jobs built-in lists all jobs with format '[N] Running/Stopped command'
  - '"fg %N brings job N to foreground": sends SIGCONT if stopped, calls tcsetpgrp to give it terminal, waits for completion or stop'
  - '''bg %N'' sends SIGCONT to stopped job N allowing it to continue running in background'
  - Ctrl+Z sends SIGTSTP to the foreground process group, stopping it; shell updates job state to 'Stopped' and prints notification
  - Ctrl+C sends SIGINT to the foreground process group only; shell itself is unaffected
  - Completed background jobs are reported to the user at the next prompt display (e.g., '[1] Done ls')
  pitfalls:
  - Zombie processes from background jobs that complete without being waited on; SIGCHLD handler must reap them
  - Race condition between SIGCHLD delivery and job table lookup; use sigprocmask to block SIGCHLD during table updates
  - 'Orphaned process groups: if the shell exits with running background jobs, they receive SIGHUP'
  - Not waiting for ALL processes in a pipeline's process group; wait for the entire group, not just the last PID
  concepts:
  - Background execution
  - Job table management
  - SIGCONT for job resumption
  - Foreground/background switching
  skills:
  - Job control implementation
  - Process group lifecycle
  - Built-in command implementation
  - State machine for job transitions
  deliverables:
  - Background execution with '&' operator
  - Job table data structure
  - jobs, fg, bg built-in commands
  - Ctrl+Z stop handling with job state update
  - Ctrl+C interrupt forwarding to foreground group
  - Background job completion notification
  estimated_hours: 8-12
domain: systems
