id: multiplayer-game-server
name: Multiplayer Game Server
description: Real-time authoritative game server with client-side prediction and lag compensation
difficulty: advanced
estimated_hours: "70-100"
essence: >
  Real-time state synchronization across unreliable network connections with
  authoritative server validation, client-side prediction for input responsiveness,
  and retroactive lag compensation to ensure fair gameplay under varying latency conditions.
why_important: >
  Game servers push real-time systems to their limits with strict latency requirements,
  making this excellent practice for performance-critical networking code, state
  management, and concurrent systems design.
learning_outcomes:
  - Implement authoritative server architecture with server-side input validation
  - Design UDP-based custom protocol with packet serialization and reliability layers
  - Build client-side prediction and server reconciliation for responsive controls
  - Handle lag compensation for fair hit detection across latency variance
  - Design tick-based game loops with deterministic fixed-timestep simulation
  - Implement delta compression and priority-based state synchronization
  - Handle jitter buffering for smooth entity interpolation
  - Manage client connections, timeouts, and reconnection
skills:
  - Network Protocol Design
  - Client-Side Prediction
  - Server Reconciliation
  - Lag Compensation
  - Fixed-Timestep Game Loops
  - Delta Compression
  - State Synchronization
  - UDP Socket Programming
  - Jitter Buffering
tags:
  - advanced
  - game-dev
  - interpolation
  - lobbies
  - networking
  - performance
  - real-time
  - service
  - state-sync
  - tick-rate
architecture_doc: architecture-docs/multiplayer-game-server/index.md
languages:
  recommended:
    - Go
    - Rust
    - C++
  also_possible: []
resources:
  - name: "Fast-Paced Multiplayer Series"
    url: "https://www.gabrielgambetta.com/client-server-game-architecture.html"
    type: tutorial
  - name: "Valve Lag Compensation Guide"
    url: "https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization"
    type: article
  - name: "Gaffer On Games Networked Physics"
    url: "https://www.gafferongames.com/categories/networked-physics/"
    type: tutorial
  - name: "Source Multiplayer Networking"
    url: "https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking"
    type: documentation
  - name: "GDC Vault - I Shot You First (Halo Reach)"
    url: "https://www.gdcvault.com/play/1014345/I-Shot-You-First-Networking"
    type: video
prerequisites:
  - type: skill
    name: UDP/TCP socket programming
  - type: skill
    name: Game loop architecture
  - type: skill
    name: Binary serialization
  - type: skill
    name: Concurrency basics
milestones:
  - id: multiplayer-game-server-m1
    name: Game Loop and Network Transport
    description: >
      Implement a fixed-timestep server game loop and a UDP-based network
      transport layer with client connection management and packet serialization.
    acceptance_criteria:
      - "Server game loop runs at a fixed tick rate (e.g., 60 ticks/second) with consistent timing between ticks using an accumulator pattern"
      - "Game state (positions, velocities, health) is updated deterministically each tick based on player inputs"
      - "Tick timing remains consistent under varying CPU load; processing time is subtracted from sleep duration, with spiral-of-death protection (max accumulated ticks per frame)"
      - "UDP socket is created and listens on a configurable port for client packets"
      - "Custom packet format is defined with a header containing packet type, sequence number, and client ID"
      - "Client connection is established via a connect/handshake packet exchange; server assigns a unique client ID"
      - "Client disconnection is detected via timeout (no packets received within N seconds) and the client is removed from the game"
      - "Input packets from clients are received, deserialized, and queued for processing in the next tick"
      - "State snapshot packets are serialized and sent to each connected client after each tick"
    pitfalls:
      - "Variable delta time causes non-deterministic simulation; always use fixed timestep with accumulator"
      - "Sleeping for the exact tick duration ignores processing time; measure elapsed time and sleep only the remainder"
      - "Unbounded accumulator causes spiral of death when the server falls behind; cap maximum accumulated ticks per frame (e.g., 3-5)"
      - "UDP packets can arrive out of order, be duplicated, or be lost; sequence numbers are needed to detect these conditions"
      - "MTU limits UDP payload to ~1200-1400 bytes for safe internet transmission; packets exceeding MTU will be fragmented or dropped"
      - "Client timeout detection must use monotonic clock, not wall clock, to avoid issues with system time changes"
    concepts:
      - Fixed timestep with accumulator pattern
      - UDP socket programming and datagram handling
      - Custom binary packet protocol design
      - Connection management over connectionless UDP
    skills:
      - Game loop architecture
      - UDP socket programming
      - Binary serialization/deserialization
      - Connection state management
    deliverables:
      - Fixed-timestep game loop with configurable tick rate and spiral-of-death protection
      - UDP socket transport with send/receive on configurable port
      - Packet format definition with header (type, sequence, client ID) and serialization
      - Client connection/disconnection management with timeout detection
      - Input packet receiving and state snapshot broadcasting
    estimated_hours: "18-25"

  - id: multiplayer-game-server-m2
    name: Client-Side Prediction and Server Reconciliation
    description: >
      Implement client-side prediction for responsive controls with server
      reconciliation to correct mispredictions smoothly.
    acceptance_criteria:
      - "Client-side prediction applies local player inputs immediately without waiting for server confirmation, providing zero-latency response to player actions"
      - "Each input is tagged with a monotonically increasing sequence number and stored in an input history buffer"
      - "Server processes inputs and includes the last-processed input sequence number in its state update to each client"
      - "On receiving a server state update, the client compares the authoritative state against the predicted state at that sequence number"
      - "If a discrepancy is detected (beyond a configurable epsilon threshold for floating-point comparison), the client resets to the server state and replays all unacknowledged inputs to produce a corrected predicted state"
      - "Visual correction uses interpolation (smoothing) over 100-200ms to avoid jarring teleportation when reconciliation adjusts position"
      - "Server validates all client inputs before applying them (e.g., movement speed cannot exceed maximum, actions must be legal in current game state)"
    pitfalls:
      - "Not storing enough input history causes the client to discard inputs that haven't been acknowledged yet, leading to rubber-banding"
      - "Exact floating-point comparison for state discrepancy fails due to precision differences between client and server; use epsilon threshold"
      - "Overcorrecting (instantly snapping to server state) causes visible jitter; smooth interpolation over a short duration is essential"
      - "Server must validate inputs to prevent cheating; a client sending impossibly fast movement should be rejected or clamped"
      - "Input replay during reconciliation must be deterministic; any randomness in game logic breaks reconciliation"
    concepts:
      - Client-side prediction with input buffering
      - Server reconciliation and state correction
      - Input sequence numbering and acknowledgment
      - Authoritative server model
    skills:
      - Client-server state synchronization
      - Input replay and deterministic simulation
      - Visual smoothing and interpolation
      - Server-side input validation
    deliverables:
      - Client-side prediction engine applying local inputs immediately
      - Input history buffer with sequence numbering
      - Server-side input processing with last-acknowledged sequence in state updates
      - Reconciliation logic replaying unacknowledged inputs on server state divergence
      - Visual smoothing correction avoiding snap/teleport artifacts
      - Server input validation rejecting illegal or impossible actions
    estimated_hours: "15-20"

  - id: multiplayer-game-server-m3
    name: Entity Interpolation, Jitter Buffering, and Lag Compensation
    description: >
      Implement smooth rendering of remote entities via interpolation with
      jitter buffering, and server-side lag compensation for fair hit detection.
    acceptance_criteria:
      - "Remote entities (other players) are rendered using interpolation between two buffered server state snapshots, displaying them at a position in the recent past (e.g., 100ms behind real-time)"
      - "Jitter buffer stores incoming server snapshots and delays rendering by a configurable amount (e.g., 2-3 server ticks) to smooth out inconsistent packet arrival times"
      - "Interpolation handles missing snapshots gracefully (extrapolation for short gaps, freezing for long gaps) without crashing or producing impossible positions"
      - "Server-side lag compensation rewinds game state to the client's estimated render time when processing combat/hit-detection actions"
      - "Client round-trip time (RTT) is measured via periodic ping/pong packets or timestamp comparison, and used to estimate the client's view time for lag compensation"
      - "Maximum rewind window is capped (e.g., 200ms) to prevent extreme advantage from high-latency clients (shooting around corners)"
      - "State rewind buffer stores the last N ticks of game state history for retroactive hit detection"
      - "Entity interpolation handles spawn/despawn boundaries correctly (new entities appear, departing entities are removed without interpolation artifacts)"
    pitfalls:
      - "Without jitter buffering, packet arrival time variation causes entities to stutter even with interpolation"
      - "Unlimited rewind window allows high-latency players to shoot around corners that low-latency players have already moved behind; cap the maximum"
      - "State history buffer memory grows linearly with tick rate × rewind window × entity count; must be bounded"
      - "Interpolation between entity spawn/despawn causes phantom entities briefly appearing at origin (0,0); handle spawn/despawn as special cases"
      - "Extrapolation (predicting beyond last known state) can produce physically impossible positions; cap extrapolation duration"
      - "Lag compensation must only apply to the shooting client's perspective, not modify the global game state retroactively"
    concepts:
      - Entity interpolation and render delay
      - Jitter buffering for network variance
      - Server-side state rewinding
      - Round-trip time estimation
      - Maximum rewind window limits
    skills:
      - Time-based state management
      - Hit detection algorithms
      - Memory-efficient circular buffers
      - Network latency measurement
    deliverables:
      - Entity interpolation renderer displaying remote entities between buffered snapshots
      - Jitter buffer delaying rendering by configurable tick count to absorb arrival variance
      - RTT measurement via ping/pong protocol
      - Server-side state rewind buffer storing tick history
      - Lag-compensated hit detection validating shots against rewound game state
      - Maximum rewind cap preventing excessive time travel
    estimated_hours: "18-25"

  - id: multiplayer-game-server-m4
    name: Bandwidth Optimization and Delta Compression
    description: >
      Optimize network bandwidth using delta compression, priority-based
      update scheduling, and interest management.
    acceptance_criteria:
      - "Delta compression transmits only changed fields since the last acknowledged baseline snapshot, reducing bandwidth by at least 50% compared to full snapshots on a test scene with 20+ entities"
      - "Baseline snapshot is tracked per client; full state is sent on initial connection and after packet loss invalidates the baseline"
      - "Priority-based update scheduling sends nearby/important entities at higher frequency than distant ones, distributing bandwidth budget fairly"
      - "Bandwidth limiter caps outgoing packet rate and size per client to a configurable maximum bitrate (e.g., 64 Kbps per client)"
      - "Reliable delivery mechanism ensures critical game events (player death, score change, game over) are delivered even over unreliable UDP transport (e.g., ack-based retransmission for event channel)"
      - "Packet loss is detected via sequence number gaps and handled gracefully (request full snapshot re-sync after excessive consecutive losses)"
    pitfalls:
      - "Delta compression without a reliable baseline causes progressive desync; must re-send full snapshot when baseline is lost due to packet loss"
      - "Priority calculation per entity per client is O(n*m); use spatial partitioning (grid or quadtree) to efficiently determine nearby entities"
      - "Sending full state every tick overwhelms bandwidth for games with many entities; delta + priority is essential"
      - "Reliable event delivery over UDP requires implementing acknowledgment and retransmission; using TCP for a side channel is simpler but adds connection management complexity"
      - "Bandwidth measurement should account for UDP/IP header overhead (~28 bytes per packet) in addition to payload size"
    concepts:
      - Delta compression with acknowledged baselines
      - Priority-based update scheduling
      - Area-of-interest management
      - Reliable delivery over unreliable transport
      - Bandwidth budgeting
    skills:
      - Network bandwidth optimization
      - Binary delta encoding
      - Spatial partitioning for interest management
      - Reliable message delivery design
    deliverables:
      - Delta compression encoder transmitting only changed fields since last acknowledged baseline
      - Baseline tracking per client with full re-sync on loss
      - Priority-based entity update scheduler with spatial awareness
      - Bandwidth limiter capping outgoing bitrate per client
      - Reliable event channel for critical game events with ack-based retransmission
      - Packet loss detection and recovery via sequence gaps and re-sync
    estimated_hours: "18-25"