id: nanite-like-virtualized-geometry
name: Virtualized Geometry System
description: >
  Build a virtualized geometry system like Unreal Engine 5's Nanite.
  Implement LOD streaming, cluster-based culling, and GPU-driven rendering
  for billions of polygons at real-time frame rates.

difficulty: expert
estimated_hours: 90-120
domain: game-dev

essence: >
  Virtualized geometry through mesh clusterization, hierarchical LOD streaming
  based on screen-space error, visibility-driven loading, and GPU-driven rendering
  that processes only visible clusters at appropriate detail levels.

why_important: >
  Nanite-style rendering is the cutting edge of real-time graphics. Understanding
  GPU-driven pipelines, virtualized assets, and LOD systems is valuable for
  senior graphics engineers at $200K-400K+ at AAA game studios.

learning_outcomes:
  - Implement mesh clusterization for hierarchical LOD
  - Build screen-space error metric for LOD selection
  - Implement virtualized geometry streaming
  - Build GPU-driven culling (occlusion, frustum)
  - Implement cluster-based rendering without CPU draw calls
  - Handle texture and geometry streaming coordination
  - Build persistent data structures for large scenes
  - Implement virtual shadow maps for consistent quality

skills:
  - Mesh Clusterization
  - LOD Streaming
  - GPU-Driven Rendering
  - Virtualized Assets
  - Screen-Space Error
  - Occlusion Culling
  - GPU Culling
  - Virtual Shadows

tags:
  - expert
  - graphics
  - nanite
  - lod-streaming
  - gpu-driven
  - virtualized-geometry
  - game-engine

languages:
  recommended:
    - C++
    - Rust
  also_possible: []

resources:
  - name: "Unreal Engine 5 Nanite Technical Details"
    url: https://docs.unrealengine.com/5.0/en-US/RenderingAndGraphics/Nanite/
    type: documentation
  - name: "GPU-Driven Rendering Pipelines"
    url: https://advances.realtimerendering.com/s2021/
    type: presentation
  - name: "Mesh Shaders in DirectX 12"
    url: https://developer.nvidia.com/blog/introduction-turing-mesh-shaders/
    type: article
  - name: "Virtual Geometry Images"
    url: https://hhoppe.com/vgi.pdf
    type: paper

prerequisites:
  - type: project
    name: vulkan-gpu-engine or equivalent graphics experience
  - type: skill
    name: Advanced GPU programming
  - type: skill
    name: Understanding of LOD and culling
  - type: skill
    name: Compute shader experience

milestones:
  - id: nanite-m1
    name: Mesh Clusterization
    description: >
      Implement mesh clusterization that divides meshes into
      clusters for hierarchical LOD generation.
    acceptance_criteria:
      - Mesh divided into clusters of ~128 triangles
      - Clusters store position bounds, error metric
      - Hierarchical clustering combines clusters into parent groups
      - LOD levels generated by simplifying clusters
      - Error metric predicts screen-space deviation
      - Cluster data stored in GPU-friendly format
    pitfalls:
      - Cluster size affects culling granularity
      - Error metric must be conservative
      - Simplification quality affects visual popping
      - Memory overhead from multiple LOD levels
    concepts:
      - Mesh clustering
      - Error metrics
      - LOD generation
      - GPU data format
    skills:
      - Clustering algorithm
      - Mesh simplification
      - Error computation
      - Data layout
    deliverables:
      - Cluster generator
      - LOD hierarchy
      - Error metric
      - GPU format
    estimated_hours: "18-24"

  - id: nanite-m2
    name: Screen-Space Error & LOD Selection
    description: >
      Implement screen-space error metric and GPU-driven LOD
      selection for each cluster.
    acceptance_criteria:
      - Screen-space error computed from view parameters
      - LOD selection picks highest detail within error threshold
      - Selection runs on GPU via compute shader
      - Per-cluster selection avoids uniform LOD
      - Dithered transitions between LOD levels
      - Temporal coherence to avoid flickering
    pitfalls:
      - Error threshold affects quality/performance balance
      - LOD popping without dithering
      - Selection instability causes temporal noise
      - Conservative error prevents popping but wastes detail
    concepts:
      - Screen-space error
      - GPU selection
      - LOD transition
      - Temporal coherence
    skills:
      - Error calculation
      - Compute shader
      - Dithering
      - Temporal stability
    deliverables:
      - Error calculation
      - GPU LOD selector
      - Dithered transition
      - Temporal handling
    estimated_hours: "16-20"

  - id: nanite-m3
    name: Virtualized Streaming
    description: >
      Implement streaming system that loads/unloads geometry
      based on visibility and memory budget.
    acceptance_criteria:
      - Cluster pages stream in/out based on visibility
      - Priority queue for streaming based on screen importance
      - Async loading doesn't block rendering
      - Memory budget enforced with LRU eviction
      - Partial loading for very close geometry
      - Streaming metrics show bandwidth and residency
    pitfalls:
      - Pop-in when streaming too slow
      - Thrashing from memory pressure
      - Async safety with rendering
      - Priority inversion in queue
    concepts:
      - Virtualized streaming
      - Priority scheduling
      - Async loading
      - Memory management
    skills:
      - Streaming system
      - Priority queue
      - Async safety
      - Memory budgeting
    deliverables:
      - Streaming manager
      - Priority scheduler
      - Async loader
      - Memory tracker
    estimated_hours: "18-24"

  - id: nanite-m4
    name: GPU-Driven Culling
    description: >
      Implement hierarchical culling on GPU including
      frustum, occlusion, and backface culling.
    acceptance_criteria:
      - Frustum culling in compute shader
      - Hierarchical Z-buffer occlusion culling
      - Cluster-level backface and small primitive culling
      - Indirect draw generation on GPU
      - Zero CPU draw calls for geometry
      - Culling statistics for debugging
    pitfalls:
      - Occlusion culling accuracy vs speed tradeoff
      - False negatives cause visible popping
      - Indirect dispatch size computation
      - Synchronization between culling and drawing
    concepts:
      - GPU culling
      - Hi-Z occlusion
      - Indirect rendering
      - Draw call elimination
    skills:
      - Compute culling
      - Hi-Z buffer
      - Indirect dispatch
      - GPU synchronization
    deliverables:
      - Frustum culling
      - Occlusion culling
      - Indirect draw
      - Culling stats
    estimated_hours: "18-24"

  - id: nanite-m5
    name: Cluster Rendering & Shadows
    description: >
      Implement cluster rendering pipeline with virtual
      shadow maps for consistent quality.
    acceptance_criteria:
      - Cluster rasterization via mesh shaders or compute
      - Material evaluation per cluster
      - Virtual shadow maps for precise shadows
      - Shadow LOD consistent with geometry LOD
      - Transparent and masked material support
      - Performance scales with visible complexity, not scene size
    pitfalls:
      - Mesh shader availability on older GPUs
      - Shadow aliasing from insufficient resolution
      - Material complexity affects performance
      - Transparency sorting issues
    concepts:
      - Mesh shaders
      - Virtual shadows
      - Material system
      - Transparency
    skills:
      - Mesh shader rendering
      - Shadow mapping
      - Material integration
      - Performance tuning
    deliverables:
      - Cluster rasterizer
      - Virtual shadows
      - Material support
      - Performance validation
    estimated_hours: "16-22"
