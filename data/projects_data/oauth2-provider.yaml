id: oauth2-provider
name: OAuth2/OIDC Provider
description: >-
  Identity provider implementing OAuth 2.0 Authorization Code Flow with PKCE,
  OpenID Connect ID Tokens, JWT access tokens, token lifecycle management,
  and OIDC Discovery.
difficulty: expert
estimated_hours: "60-90"
essence: >-
  Multi-party cryptographic authorization framework implementing RFC 6749
  Authorization Code Flow with RFC 7636 PKCE challenge-response, OpenID
  Connect ID Token issuance via asymmetric JWT signatures, OIDC Discovery
  and JWKS key publication, and distributed token lifecycle management across
  authorization, token, introspection, revocation, and UserInfo endpoints.
why_important: >-
  Identity providers are foundational infrastructure for modern authentication
  systems, and building one teaches protocol-level security design,
  cryptographic operations, and the architectural patterns used by Auth0,
  Okta, and enterprise SSO systems that handle billions of authentication
  requests.
learning_outcomes:
  - Implement PKCE authorization code flow with SHA-256 code_challenge/code_verifier validation
  - Design JWT access tokens and OIDC ID Tokens with asymmetric signing (RS256/ES256)
  - Build secure refresh token rotation with token family tracking to detect replay attacks
  - Implement OIDC Discovery (/.well-known/openid-configuration) and JWKS endpoint for key distribution
  - Implement RFC 7662 token introspection and RFC 7009 token revocation endpoints
  - Design client registration with secret hashing, redirect URI validation, and grant type restrictions
  - Build consent management flows with granular scope approval and persistence
  - Debug OAuth2 security vulnerabilities including authorization code interception, CSRF, and token replay
skills:
  - OAuth2 Protocol Design (RFC 6749)
  - PKCE Security Extension (RFC 7636)
  - JWT Cryptographic Signing (RFC 7519)
  - OpenID Connect Core
  - OIDC Discovery & JWKS
  - Token Lifecycle Management
  - Authorization Code Flow
  - Consent Flow Design
  - API Security Patterns
tags:
  - authentication
  - authorization-code
  - expert
  - identity
  - jwt
  - oauth2
  - oidc
  - pkce
  - scopes
  - security
  - tokens
architecture_doc: architecture-docs/oauth2-provider/index.md
languages:
  recommended:
    - Go
    - Python
    - Java
  also_possible:
    - Rust
    - TypeScript
resources:
  - name: OAuth 2.0 RFC 6749
    url: https://datatracker.ietf.org/doc/html/rfc6749
    type: specification
  - name: PKCE RFC 7636
    url: https://datatracker.ietf.org/doc/html/rfc7636
    type: specification
  - name: OpenID Connect Core 1.0
    url: https://openid.net/specs/openid-connect-core-1_0.html
    type: specification
  - name: OpenID Connect Discovery 1.0
    url: https://openid.net/specs/openid-connect-discovery-1_0.html
    type: specification
  - name: JWT RFC 7519
    url: https://datatracker.ietf.org/doc/html/rfc7519
    type: specification
  - name: OAuth 2.0 Simplified
    url: https://www.oauth.com/oauth2-servers/
    type: tutorial
prerequisites:
  - type: project
    id: http-server-basic
    name: HTTP Server (Basic)
  - type: skill
    name: Cryptography basics (hashing, asymmetric signing)
  - type: skill
    name: HTTP request/response handling and routing
  - type: skill
    name: JSON parsing and generation
milestones:
  - id: oauth2-provider-m1
    name: Client Registration & Authorization Endpoint with PKCE
    description: >-
      Implement OAuth2 client registration, the authorization endpoint with
      mandatory PKCE support, consent flow, and authorization code issuance.
    acceptance_criteria:
      - "Register OAuth clients with generated client_id, bcrypt-hashed client_secret, configured redirect_uris, allowed grant_types, and allowed scopes"
      - "Authorization endpoint validates required parameters: response_type=code, client_id, redirect_uri, scope, state, code_challenge, code_challenge_method"
      - "Redirect URI validation performs EXACT string match against registered URIs (no partial/substring matching)"
      - "State parameter is required and echoed back in redirect to prevent CSRF attacks"
      - "PKCE code_challenge and code_challenge_method=S256 are MANDATORY for all clients (public and confidential)"
      - "Store code_challenge associated with the authorization code for later verification at token endpoint"
      - "Authorization consent page displays client name, requested scopes with descriptions, and allow/deny buttons"
      - "On consent approval, generate authorization code as cryptographically random string (min 128 bits entropy)"
      - "Authorization code is bound to: client_id, redirect_uri, code_challenge, user_id, granted scopes, and timestamp"
      - "Authorization code expires after maximum 10 minutes (configurable, ≤600 seconds) per RFC 6749 Section 4.1.2"
      - "Authorization code is single-use: second attempt to exchange same code revokes any tokens already issued from it"
      - "Redirect user to redirect_uri with code and state parameters on approval, or error on denial"
    pitfalls:
      - "Authorization codes MUST be single-use; if reused, revoke ALL tokens issued from that code (theft detection)"
      - "redirect_uri matching must be EXACT string comparison including scheme, host, port, and path"
      - "PKCE code_challenge_method must be S256 (SHA-256); plain method should be rejected for security"
      - "State parameter must be cryptographically random and verified by the client; provider must pass it through unchanged"
      - "Never include error details in redirects to unregistered redirect_uris (open redirect vulnerability)"
      - "Client secrets must be hashed (bcrypt/argon2), never stored in plaintext"
    concepts:
      - OAuth2 authorization code grant flow
      - PKCE code_challenge generation and storage (SHA-256 of code_verifier)
      - CSRF protection via state parameter
      - Authorization code binding and single-use enforcement
      - Redirect URI exact matching
    skills:
      - OAuth2 authorization flow implementation
      - PKCE challenge-response protocol
      - Cryptographic random generation
      - Secure credential storage (bcrypt)
    deliverables:
      - Client registration API creating OAuth client records with hashed secrets and redirect URIs
      - Authorization endpoint validating parameters, PKCE challenge, and redirecting to consent
      - Consent page displaying client info, requested scopes, and capturing user decision
      - Authorization code generator creating short-lived, single-use, bound codes
      - Redirect handler appending code and state to redirect_uri on approval
    estimated_hours: "14-18"

  - id: oauth2-provider-m2
    name: Token Endpoint, JWT Access Tokens & ID Tokens
    description: >-
      Implement the token endpoint exchanging authorization codes for JWT
      access tokens, OIDC ID Tokens, and rotating refresh tokens with PKCE
      verification.
    acceptance_criteria:
      - "Token endpoint accepts POST with grant_type=authorization_code, code, redirect_uri, client_id, and code_verifier"
      - "Verify code_verifier by computing SHA-256 hash and comparing against stored code_challenge (base64url encoded)"
      - "Authenticate confidential clients via client_secret_post or client_secret_basic"
      - "Validate authorization code is not expired, not already used, bound to correct client_id and redirect_uri"
      - "Issue JWT access token signed with RS256 or ES256 containing claims: iss, sub, aud, exp, iat, jti, scope"
      - "Access token exp set to short-lived duration (configurable, default 15 minutes)"
      - "Issue OIDC ID Token (JWT) containing claims: iss, sub, aud, exp, iat, nonce (if provided), auth_time, at_hash"
      - "at_hash claim in ID Token computed as left half of SHA-256 hash of access token, base64url encoded"
      - "Issue refresh token as opaque cryptographically random string (min 256 bits entropy)"
      - "Store refresh token hashed in database with associated user_id, client_id, scope, and token_family_id"
      - "Refresh token rotation: on grant_type=refresh_token, issue new refresh token AND new access token, invalidate old refresh token"
      - "Token family tracking: if a previously-invalidated refresh token is reused, revoke ALL tokens in the family (theft detection)"
      - "Client credentials grant (grant_type=client_credentials) issues access token directly without user context"
      - "Token response includes access_token, token_type=\"Bearer\", expires_in, refresh_token, id_token, and scope"
    pitfalls:
      - "JWT payload is base64url encoded NOT encrypted; never include sensitive data (passwords, secrets) in claims"
      - "PKCE verification: code_verifier is the raw value; code_challenge = BASE64URL(SHA256(code_verifier))"
      - "Refresh token rotation requires atomic invalidate-old + issue-new to prevent race conditions"
      - "Token family tracking is essential: without it, stolen refresh tokens can be used indefinitely"
      - "Access token should be short-lived (15 min); refresh token longer (hours/days) with rotation"
      - "Use constant-time comparison for all secret/token validation to prevent timing attacks"
      - "ID Token must NOT be used for API authorization; that's what the access token is for"
    concepts:
      - JWT structure (header.payload.signature) with asymmetric signing
      - PKCE code_verifier verification at token endpoint
      - Refresh token rotation and token family tracking
      - OIDC ID Token claims and at_hash computation
      - Token binding to prevent cross-client token use
    skills:
      - JWT creation and asymmetric signing (RS256/ES256)
      - PKCE verification
      - Refresh token rotation implementation
      - Secure token storage (hashed)
    deliverables:
      - Token endpoint handling authorization_code, refresh_token, and client_credentials grants
      - PKCE code_verifier verification against stored code_challenge
      - JWT access token generator with configurable claims and signing key
      - OIDC ID Token generator with at_hash and required claims
      - Refresh token rotation with token family tracking and theft detection
      - Client authentication (client_secret_basic and client_secret_post)
    estimated_hours: "14-18"

  - id: oauth2-provider-m3
    name: Token Introspection, Revocation & JWKS
    description: >-
      Implement RFC 7662 token introspection, RFC 7009 token revocation,
      OIDC Discovery endpoint, and JWKS key publication.
    acceptance_criteria:
      - "Token introspection endpoint (POST /introspect) returns {\"active\": true/false} with token metadata per RFC 7662"
      - "Introspection response for active tokens includes: active, scope, client_id, sub, exp, iat, token_type, jti"
      - "Introspection endpoint requires client authentication (confidential clients only)"
      - "Token revocation endpoint (POST /revoke) accepts token and optional token_type_hint per RFC 7009"
      - "Revocation of refresh token also revokes all associated access tokens in the token family"
      - "Revocation endpoint returns 200 OK even for invalid/already-revoked tokens (no information leakage)"
      - "Revoked JWTs are tracked by jti claim in a revocation list until their original exp time passes"
      - "OIDC Discovery endpoint (GET /.well-known/openid-configuration) returns JSON with all endpoint URLs, supported scopes, grant types, and signing algorithms"
      - "JWKS endpoint (GET /jwks) returns the public key(s) used for JWT signing in JWK Set format"
      - "JWKS includes key id (kid), algorithm (alg), key type (kty), and public key parameters"
      - "Resource servers can validate access tokens locally by fetching JWKS and verifying JWT signature + claims"
    pitfalls:
      - "Introspection endpoint MUST require authentication; unauthenticated introspection leaks token validity"
      - "Revoked JWTs continue to be valid until exp if only checked locally; introspection or revocation list needed"
      - "jti-based revocation list grows unbounded; must expire entries when token's exp passes (use TTL in cache)"
      - "JWKS endpoint must be publicly accessible (no auth) so resource servers can fetch signing keys"
      - "Key rotation: JWKS should support multiple keys (old and new) during rotation period; kid in JWT header selects key"
      - "Refresh token family revocation on reuse is critical; without it, stolen tokens provide indefinite access"
    concepts:
      - Token introspection response format (RFC 7662)
      - Token revocation semantics (RFC 7009)
      - JWT revocation tracking via jti claim
      - OIDC Discovery metadata document
      - JWK Set format for public key distribution
    skills:
      - Token lifecycle management
      - Revocation list implementation with TTL
      - OIDC Discovery document construction
      - JWK/JWKS key serialization
    deliverables:
      - Token introspection endpoint returning active status and metadata per RFC 7662
      - Token revocation endpoint invalidating tokens per RFC 7009
      - JWT revocation list tracking jti claims with TTL-based cleanup
      - OIDC Discovery endpoint at /.well-known/openid-configuration
      - JWKS endpoint publishing signing public keys in JWK Set format
      - Local JWT validation library using JWKS for signature verification
    estimated_hours: "14-18"

  - id: oauth2-provider-m4
    name: UserInfo Endpoint & Consent Management
    description: >-
      Implement OIDC UserInfo endpoint returning scope-filtered claims and
      persistent consent management for authorized applications.
    acceptance_criteria:
      - "UserInfo endpoint (GET /userinfo) authenticates caller via Bearer access token in Authorization header"
      - "UserInfo returns claims based on GRANTED scopes: openid→sub, profile→name/family_name/picture, email→email/email_verified"
      - "UserInfo returns ONLY claims for scopes that were actually granted, not all scopes that were requested"
      - "UserInfo response format is JSON (application/json) with standard OIDC claim names"
      - "Previously granted consent decisions are persisted (user_id + client_id + scopes) to skip re-prompting"
      - "Users can view all authorized applications and their granted scopes via a management interface"
      - "Users can revoke consent for a specific client, which revokes all tokens for that client-user pair"
      - "Revoking consent causes future authorization requests from that client to re-prompt for approval"
      - "Consent re-prompting occurs if client requests additional scopes beyond what was previously granted"
    pitfalls:
      - "UserInfo MUST use the access token for authentication, NOT the ID Token"
      - "Return only claims for GRANTED scopes, not REQUESTED scopes (user may have denied some)"
      - "Consent screen must clearly explain what data will be shared in plain language"
      - "Consent revocation must also revoke all outstanding tokens for that client-user pair"
      - "Standard OIDC claim names must be used exactly (e.g., 'family_name' not 'lastName')"
      - "Bearer token in Authorization header must use constant-time comparison"
    concepts:
      - OIDC standard claims and scope-to-claim mapping
      - Bearer token authentication for protected resources
      - Consent persistence and incremental authorization
      - Consent revocation and its cascading effects on tokens
    skills:
      - OIDC UserInfo endpoint implementation
      - Scope-based claim filtering
      - Consent lifecycle management
      - User-facing authorization management UI
    deliverables:
      - UserInfo endpoint returning scope-filtered user claims via Bearer token auth
      - Scope-to-claims mapping (openid, profile, email, address, phone)
      - Consent persistence store saving user grant decisions per client
      - Consent management interface showing authorized apps and allowing revocation
      - Incremental consent handling for additional scope requests
      - Consent revocation cascading to token invalidation
    estimated_hours: "12-16"