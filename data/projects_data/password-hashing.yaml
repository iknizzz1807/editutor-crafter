id: password-hashing
name: Password Hashing
description: >-
  Implement secure password hashing with salting, key stretching (PBKDF2),
  and modern password hashing algorithms (bcrypt, Argon2id), including
  peppering, timing-safe comparison, and hash migration strategies.
difficulty: beginner
estimated_hours: "6-10"
essence: >-
  Salted key derivation with iterative computational hardening to transform
  passwords into cryptographically strong hash digests while defending
  against rainbow tables, GPU-accelerated brute force, and timing side-
  channel attacks, using algorithms with deliberately tunable cost
  parameters (CPU-hard, memory-hard, or both).
why_important: >-
  Password hashing is the most critical security primitive in authentication
  systems. Understanding salting, key stretching, and memory-hard functions
  is essential for any developer building production systems that handle
  user credentials.
learning_outcomes:
  - Implement salt generation and demonstrate why unsalted hashes are vulnerable to rainbow tables
  - Understand why fast hash functions (SHA-256) are unsuitable for password storage
  - Build PBKDF2-HMAC-SHA256 key stretching with configurable iteration count
  - Implement timing-safe comparison to prevent side-channel attacks
  - Integrate bcrypt with proper cost factor selection and understand its 72-byte input limit
  - Integrate Argon2id with memory, time, and parallelism parameter tuning
  - Implement hash format versioning and migration for algorithm upgrades
  - Apply peppering as defense-in-depth against database-only breaches
skills:
  - Cryptographic Hashing
  - Salt Generation (CSPRNG)
  - Key Derivation Functions
  - Timing Attack Prevention
  - bcrypt/Argon2 Integration
  - Password Security Design
  - Cost Factor Tuning
  - Hash Migration Strategies
tags:
  - bcrypt
  - argon2
  - beginner-friendly
  - go
  - javascript
  - key-derivation
  - python
  - salt
  - security
architecture_doc: architecture-docs/password-hashing/index.md
languages:
  recommended:
    - Python
    - Go
    - JavaScript
  also_possible:
    - Java
    - C#
resources:
  - name: OWASP Password Storage Cheat Sheet""
    url: https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html
    type: documentation
  - name: Argon2 vs Bcrypt vs Scrypt vs PBKDF2 - Complete Guide""
    url: https://guptadeepak.com/the-complete-guide-to-password-hashing-argon2-vs-bcrypt-vs-scrypt-vs-pbkdf2-2026/
    type: article
  - name: CrackStation - Salted Password Hashing""
    url: https://crackstation.net/hashing-security.htm
    type: tutorial
prerequisites:
  - type: skill
    name: Basic programming
  - type: skill
    name: Understanding of hash functions (one-way, deterministic)
milestones:
  - id: password-hashing-m1
    name: "Salted Hashing and Why Fast Hashes Fail"
    description: >-
      Implement salted password hashing with SHA-256 to understand the
      mechanics of salting, then demonstrate why a fast hash function is
      insufficient for password storage.
    acceptance_criteria:
      - >-
        Generate a cryptographically random salt of at least 16 bytes
        using the platform CSPRNG (os.urandom, crypto/rand, etc.).
      - >-
        Hash the password concatenated with the salt using SHA-256,
        producing a deterministic output for the same password+salt pair.
      - >-
        Store the salt alongside the hash in a single encoded string
        (e.g., '$sha256$<salt_hex>$<hash_hex>') so both are available
        for verification.
      - >-
        Verification function extracts the salt from the stored string,
        recomputes the hash, and compares it to the stored hash.
      - >-
        Demonstrate: the same password with two different salts produces
        two different hashes (proving rainbow table resistance).
      - >-
        Demonstrate: SHA-256 can compute >1 million hashes per second
        on commodity hardware, making brute-force feasible for short
        passwords. Document this measurement as motivation for key
        stretching.
      - >-
        Use constant-time comparison (hmac.compare_digest or equivalent)
        for hash verification to prevent timing attacks.
    pitfalls:
      - >-
        Using predictable or sequential salts (timestamps, user IDs)
        defeats the purpose. Always use CSPRNG output.
      - >-
        Not storing the salt: without the salt, the hash cannot be
        verified later. Always encode salt + hash together.
      - >-
        Using string comparison (==) instead of constant-time comparison
        leaks hash value information through response timing differences.
      - >-
        This milestone's SHA-256 approach is INTENTIONALLY INSECURE for
        passwords — it exists to teach WHY key stretching is needed.
        Never use plain SHA-256 for password storage in production.
    concepts:
      - Salting and rainbow table defense
      - CSPRNG for salt generation
      - Why fast hashes are bad for passwords
      - Constant-time comparison
    skills:
      - Cryptographic random number generation
      - Hash function usage
      - Secure comparison operations
      - Salt storage encoding
    deliverables:
      - CSPRNG-based salt generation function
      - Salted SHA-256 hash computation
      - Combined salt+hash storage format
      - Constant-time verification function
      - Benchmark demonstrating SHA-256 speed (motivating key stretching)
    estimated_hours: "1.5-2.5"

  - id: password-hashing-m2
    name: "Key Stretching with PBKDF2"
    description: >-
      Implement PBKDF2-HMAC-SHA256 with configurable iteration count to
      make brute-force attacks computationally expensive. Understand the
      difference between PBKDF2's linear cost and bcrypt/Argon2's cost models.
    acceptance_criteria:
      - >-
        PBKDF2-HMAC-SHA256 is implemented (or called via library) with
        a configurable iteration count, defaulting to at least 600,000
        per OWASP 2023 recommendations.
      - >-
        Output derived key length is configurable (default 32 bytes).
      - >-
        Iteration count and salt are stored alongside the derived key
        in a self-describing format (e.g., '$pbkdf2-sha256$<iterations>$<salt>$<hash>').
      - >-
        Verification recomputes the derived key with stored parameters
        and compares using constant-time comparison.
      - >-
        Benchmark: PBKDF2 with 600,000 iterations takes 200ms-1s per
        hash on the development machine, demonstrating brute-force
        resistance. Document the measurement.
      - >-
        Demonstrate: PBKDF2 cost is linear in iteration count (doubling
        iterations roughly doubles time), unlike bcrypt's logarithmic
        cost factor.
    pitfalls:
      - >-
        Too few iterations: 100,000 was reasonable in 2015 but is
        insufficient today. OWASP 2023 recommends 600,000 for
        PBKDF2-HMAC-SHA256. Always check current recommendations.
      - >-
        Not storing the iteration count: if iterations aren't stored
        with the hash, you can't verify old hashes after changing the
        default, and you can't migrate to higher counts.
      - >-
        PBKDF2 is CPU-hard only (not memory-hard), making it vulnerable
        to GPU/ASIC attacks. This is why bcrypt and Argon2 exist.
      - >-
        Confusing PBKDF2 iterations (flat count, e.g., 600,000) with
        bcrypt cost (logarithmic, e.g., cost 12 = 2^12 = 4096 iterations).
        They are fundamentally different parameters.
    concepts:
      - Key stretching and computational hardening
      - PBKDF2 and HMAC-based key derivation
      - Linear vs. logarithmic vs. memory-hard cost models
      - Timing attacks and constant-time comparison
    skills:
      - PBKDF2 implementation/integration
      - Cost parameter selection
      - Constant-time comparison
      - Hash format design with versioning
    deliverables:
      - PBKDF2-HMAC-SHA256 with configurable iterations (≥600,000)
      - Self-describing storage format including algorithm, iterations, salt, hash
      - Constant-time verification function
      - Benchmark measuring hash time vs. iteration count
    estimated_hours: "1.5-2.5"

  - id: password-hashing-m3
    name: "Modern Password Hashing: bcrypt and Argon2id"
    description: >-
      Integrate bcrypt and Argon2id using established libraries, with
      proper cost factor tuning, peppering for defense-in-depth, and
      a migration strategy for upgrading legacy hashes.
    acceptance_criteria:
      - >-
        bcrypt integration: hash passwords with a configurable cost factor
        (default 12, producing ~250ms hash time on modern hardware).
      - >-
        bcrypt output format ($2b$<cost>$<salt+hash>) is correctly parsed
        during verification.
      - >-
        bcrypt's 72-byte input limit is documented and handled: passwords
        longer than 72 bytes are pre-hashed with SHA-256 (or truncation
        is explicitly documented as a security limitation).
      - >-
        Argon2id integration: hash passwords with configurable time cost
        (default 3 iterations), memory cost (default 64 MB), and
        parallelism (default 1), targeting ~250ms hash time.
      - >-
        Peppering: apply an HMAC with a server-side secret key before
        or after hashing, so database theft alone is insufficient to
        crack passwords. Pepper is stored separately from the database
        (e.g., environment variable, HSM).
      - >-
        Hash migration: when a user logs in with a legacy hash format
        (e.g., PBKDF2 from M2), verify against the old format, then
        re-hash with the current algorithm (Argon2id) and store the
        upgraded hash.
      - >-
        Cost factor tuning utility: a script/function that benchmarks
        the hash algorithm on current hardware and recommends a cost
        factor targeting a configured time budget (e.g., 250ms).
    pitfalls:
      - >-
        Never implement bcrypt or Argon2 from scratch in production.
        Use audited libraries (bcrypt, argon2-cffi, golang.org/x/crypto).
        This milestone is about integration and parameter selection.
      - >-
        bcrypt's 72-byte limit: passwords longer than 72 bytes are
        silently truncated by most bcrypt implementations. Two passwords
        that share the first 72 bytes will hash identically. Pre-hash
        with SHA-256 to avoid this.
      - >-
        Argon2 memory parameter: 64 MB per hash means 100 concurrent
        logins require 6.4 GB of RAM. Size memory cost relative to
        expected concurrent authentication load.
      - >-
        Pepper rotation: if the pepper changes, all existing hashes
        become unverifiable. Implement pepper versioning (store pepper
        ID with hash) to support rotation.
      - >-
        Migration timing: re-hashing only happens at login time, so
        inactive accounts retain legacy hashes. Plan for bulk migration
        or accept the long tail.
    concepts:
      - bcrypt (Blowfish-based, logarithmic cost, 72-byte limit)
      - Argon2id (memory-hard, multi-dimensional cost parameters)
      - Peppering (server-side secret, defense-in-depth)
      - Algorithm agility and hash migration
      - Cost factor tuning for target latency
    skills:
      - Library integration for cryptographic primitives
      - Cost parameter selection and tuning
      - Pepper management and rotation
      - Hash format migration strategies
    deliverables:
      - bcrypt integration with cost factor tuning and 72-byte limit handling
      - Argon2id integration with time, memory, and parallelism parameters
      - Peppering layer using HMAC with server-side secret
      - Hash migration function upgrading legacy formats on login
      - Cost factor tuning utility for target hash time
    estimated_hours: "2-3"