id: platformer
name: Platformer
description: 2D side-scrolling platformer with gravity, jumping, tile-based collision, enemies, and camera scrolling.
difficulty: intermediate
estimated_hours: 25-40
essence: 'Frame-rate independent physics simulation with semi-implicit Euler integration, axis-aligned bounding box collision detection resolved on separate axes, tile-based spatial partitioning for efficient level interaction, and state machine-driven character animation.

  '
why_important: 'Building this teaches fundamental game physics algorithms and real-time simulation techniques that apply to any interactive application requiring smooth movement and collision handling, from games to robotics simulations. It also covers game-feel polish (coyote time, input buffering, animation states) that separates functional code from a good player experience.

  '
learning_outcomes:
- Implement gravity and velocity-based movement with delta time scaling
- Design variable-height jump mechanics using coyote time and input buffering
- Build AABB collision detection with separate-axis resolution
- Create tile-based levels with efficient collision queries
- Implement collision response with separation vectors and surface detection
- Design state machines for character animation transitions
- Implement a camera system that follows the player with smoothing
- Debug floating-point precision issues in physics calculations
- Optimize collision detection using grid-based broad-phase culling
skills:
- 2D Physics Simulation
- AABB Collision Detection
- Tile-based Level Design
- State Machine Architecture
- Delta Time Integration
- Camera Systems
- Input Buffering
- Animation Systems
tags:
- c#
- collision
- framework
- game-dev
- intermediate
- javascript
- python
- sprites
- tiles
architecture_doc: architecture-docs/platformer/index.md
languages:
  recommended:
  - JavaScript
  - Python
  - C#
  also_possible:
  - C++
  - Lua
resources:
- name: 2D Platformer Physics
  url: https://jobtalle.com/2d_platformer_physics.html
  type: tutorial
- name: 2D Collision Detection - MDN Web Docs
  url: https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection
  type: documentation
- name: Game Programming Patterns
  url: https://gameprogrammingpatterns.com/
  type: book
- name: Celeste & TowerFall Movement Mechanics
  url: https://maddymakesgames.com/articles/celeste_and_towerfall_physics/index.html
  type: article
prerequisites:
- type: skill
  name: Basic game loop implementation
- type: skill
  name: 2D graphics rendering (sprites, rectangles)
- type: skill
  name: Basic physics concepts (velocity, acceleration)
milestones:
- id: platformer-m1
  name: Tile Map & Static World
  description: 'Build the tile-based level system first, providing the world geometry that all subsequent physics and collision work depends on. Render a tile map from data and display a static level.

    '
  acceptance_criteria:
  - Tile map is loaded from a data file or embedded array defining solid and empty tiles
  - Tile map renders visually with distinct tiles for solid ground, platforms, and empty space
  - World-to-tile coordinate conversion correctly maps pixel positions to tile grid indices
  - Tile-to-world conversion correctly maps grid indices back to pixel positions
  - Tile size is configurable (e.g., 16x16 or 32x32 pixels)
  - At least one test level is defined with floor, walls, and elevated platforms
  pitfalls:
  - Off-by-one in tile index calculation causing collision with wrong tiles
  - Mixing up row/column ordering (y=row, x=column) in the tile array
  - Tile rendering offset misaligned with collision grid
  - Hardcoding tile positions instead of loading from data
  concepts:
  - Tile maps and tile sets
  - Coordinate system conversion
  - Level data representation
  skills:
  - 2D array-based level representation
  - Coordinate system conversion (world ↔ tile)
  - Tile rendering and sprite mapping
  - Data-driven level design
  deliverables:
  - Tile map data structure representing level geometry as 2D grid
  - Tile renderer drawing the level to screen
  - World-to-tile and tile-to-world coordinate conversion functions
  - At least one complete test level with varied geometry
  estimated_hours: 3-4
- id: platformer-m2
  name: Player Movement, Gravity & Tile Collision
  description: 'Place a player entity in the tile world, implement gravity and horizontal movement, and resolve collisions against solid tiles using separate-axis AABB resolution.

    '
  acceptance_criteria:
  - Player entity has position, velocity, and AABB dimensions
  - Horizontal movement responds to left/right input with acceleration and deceleration
  - Gravity applies downward acceleration each physics frame, scaled by delta time
  - Terminal velocity caps maximum falling speed
  - 'AABB collision detection checks player against nearby solid tiles (broad phase: only check tiles overlapping player AABB)'
  - X-axis and Y-axis collisions are resolved separately to prevent corner sticking
  - Player cannot pass through solid tiles in any direction (floor, walls, ceiling)
  - '''Grounded'' flag is set when player''s bottom edge rests on a solid tile'
  - Physics uses fixed timestep with accumulator for deterministic behavior
  pitfalls:
  - Resolving X and Y simultaneously causes corner-clipping and tunneling
  - Not checking 'grounded' state properly—player slides along walls as if grounded
  - High velocity causing tunneling through thin (1-tile) walls
  - Floating-point drift causing player to slowly sink into floor
  - Variable timestep causing different physics on different frame rates
  concepts:
  - AABB collision detection and resolution
  - Separate-axis collision resolution
  - Semi-implicit Euler integration
  - Fixed timestep with accumulator
  skills:
  - Implementing gravity simulation with delta time
  - AABB overlap testing
  - Collision separation vector computation
  - Broad-phase culling using tile grid
  - Fixed timestep game loop
  deliverables:
  - Player entity with position, velocity, acceleration, and AABB
  - Gravity and horizontal movement with delta-time scaling
  - AABB collision detection against solid tiles
  - Separate X/Y axis collision resolution
  - Grounded state detection
  - Terminal velocity cap
  estimated_hours: 5-7
- id: platformer-m3
  name: Jumping & Game Feel
  description: 'Implement variable-height jumping, coyote time, jump buffering, and one-way platforms. Focus on making movement feel responsive.

    '
  acceptance_criteria:
  - Jump is only allowed when grounded flag is true (or within coyote time window)
  - 'Variable jump height: releasing jump button early reduces upward velocity (gravity multiplier on release)'
  - 'Coyote time: jump is permitted within a configurable window (e.g., 80-150ms) after walking off an edge'
  - 'Jump buffer: jump input registered within a configurable window (e.g., 80-150ms) before landing is executed on land'
  - 'One-way platforms: player passes through from below but lands on top; dropping through is triggered by down+jump'
  - Jump apex feels controlled—separate gravity multiplier for rising vs falling
  - All timing parameters (coyote time, buffer window, gravity multipliers) are configurable constants
  pitfalls:
  - Double jump without intending—grounded flag not cleared on jump frame
  - Jump feels floaty because fall gravity equals rise gravity (use higher fall multiplier)
  - Coyote time too generous allows mid-air jumps that look like flight
  - One-way platform check interferes with normal upward collision resolution
  - Jump buffer consumed multiple times if not cleared after use
  concepts:
  - Variable-height jump mechanics
  - Coyote time and input buffering
  - One-way platform collision
  - Game feel tuning
  skills:
  - Implementing responsive jump controls
  - Timer-based grace period systems
  - Input buffering design
  - Physics parameter tuning for feel
  deliverables:
  - Jump initiation with upward velocity impulse
  - Variable jump height via early-release gravity multiplier
  - Coyote time grace window with configurable duration
  - Jump buffer with configurable window
  - One-way platform support with drop-through input
  - Configurable physics constants for tuning
  estimated_hours: 3-5
- id: platformer-m4
  name: Animation State Machine & Camera
  description: 'Implement character animation states (idle, run, jump, fall) driven by a state machine, and a camera system that follows the player.

    '
  acceptance_criteria:
  - 'Character animation state machine with at least: Idle, Run, Jump, Fall states'
  - State transitions triggered by velocity and grounded status (not input directly)
  - Sprite flips horizontally based on movement direction
  - Animation frames play at correct speed independent of frame rate
  - Camera follows player with configurable smoothing (lerp or deadzone)
  - Camera is clamped to level bounds—does not show area outside the tile map
  - 'Camera lookahead: optionally shifts in the direction of player movement'
  pitfalls:
  - Animation state driven by input instead of physics state causes desync (e.g., 'run' animation while sliding on wall)
  - Camera snapping instead of smoothing causes jarring movement
  - Camera not clamped to level bounds shows void beyond the map
  - Frame-rate dependent animation speed—animations play faster at higher FPS
  concepts:
  - State machines for animation
  - Sprite animation systems
  - Camera following algorithms
  skills:
  - State machine design and transition logic
  - Sprite sheet animation with frame timing
  - Camera smoothing (lerp, deadzone)
  - Coordinate system management (world vs screen)
  deliverables:
  - Animation state machine with Idle, Run, Jump, Fall states
  - Sprite rendering with directional flipping
  - Frame-rate independent animation playback
  - Camera follow system with smoothing
  - Camera bounds clamping to level extents
  estimated_hours: 4-5
- id: platformer-m5
  name: Enemies, Hazards & Game Loop
  description: 'Add enemies with patrol AI, stomp-to-defeat mechanics, hazards, and a death/respawn system with checkpoints.

    '
  acceptance_criteria:
  - Enemies patrol between defined waypoints with direction reversal at endpoints
  - Player-enemy collision from the side or below kills the player
  - Player landing on top of an enemy (stomp) defeats the enemy and gives a small bounce
  - 'Stomp detection: player''s bottom edge contacts enemy''s top edge while player is falling (vy > 0)'
  - Player death triggers respawn at last activated checkpoint with brief invincibility
  - Invincibility frames after respawn prevent immediate re-death (visual flicker feedback)
  - At least one hazard type (spikes, pits) that kills on contact
  - Checkpoint activation is visually indicated (flag, color change)
  - 'Game can be completed: reaching the end of the level triggers a win condition'
  pitfalls:
  - Stomp detection window too narrow—stomps register as side hits
  - Enemy stuck at patrol bounds due to collision with walls not handled
  - Death during invincibility frames—timer not checked before damage
  - Enemies falling through one-way platforms or getting stuck in geometry
  - Respawn position not validated—player spawns inside a wall
  concepts:
  - AI patrol behavior
  - Directional collision response
  - Health/death/respawn systems
  - Invincibility frames
  skills:
  - Simple AI pattern implementation
  - Collision direction detection
  - Checkpoint and respawn system design
  - Game state management (alive, dead, invincible)
  deliverables:
  - Enemy entity with patrol AI between waypoints
  - Stomp-to-defeat mechanic with collision direction detection
  - Player death and respawn at checkpoint system
  - Invincibility frames with visual feedback
  - Hazard tiles (spikes/pits) causing instant death
  - Win condition on reaching level end
  estimated_hours: 5-7
domain: game-dev
