id: process-spawner
name: Process Spawner
description: fork/exec process lifecycle management with IPC and worker pools
difficulty: intermediate
estimated_hours: 12-18
essence: 'Process lifecycle management through fork/exec system calls, pipe-based inter-process communication with proper file descriptor management, and coordinating worker process pools with SIGCHLD-driven death detection, process group management, and graceful shutdown.

  '
why_important: 'Building this teaches low-level operating system primitives that underpin every server, shell, and container runtime, giving you deep understanding of how Node.js subprocess, Python''s subprocess module, and Docker spawn and manage processes.

  '
learning_outcomes:
- Implement fork/exec to spawn child processes with argument and environment passing
- Design pipe-based communication channels with proper file descriptor management
- Handle process termination with wait/waitpid including signal-caused death
- Build a worker pool with SIGCHLD-driven death detection and automatic respawning
- Manage process groups for coordinated signal delivery
- Debug race conditions between fork, exec, and signal delivery
skills:
- Process Management
- System Calls (fork, exec, wait, pipe, dup2)
- Inter-Process Communication
- File Descriptors
- Signal Handling (SIGCHLD)
- Process Groups
- Unix Programming
- Resource Management
tags:
- c
- exec
- fork
- go
- intermediate
- lifecycle
- rust
- systems
architecture_doc: architecture-docs/process-spawner/index.md
languages:
  recommended:
  - C
  - Rust
  - Go
  also_possible:
  - Python
resources:
- name: fork(2) man page
  url: https://man7.org/linux/man-pages/man2/fork.2.html
  type: documentation
- name: Advanced Programming in Unix
  url: https://www.apuebook.com/
  type: book
prerequisites:
- type: skill
  name: C programming (pointers, arrays, structs)
- type: skill
  name: Unix basics (shell, file system, permissions)
- type: skill
  name: System calls (open, read, write, close)
milestones:
- id: process-spawner-m1
  name: Fork/Exec with Arguments
  description: 'Spawn a child process to run an external command with arguments and environment variables. Collect the exit status and handle errors.

    '
  acceptance_criteria:
  - Create child process using fork(); parent receives child PID, child receives 0
  - Execute external command in child using execvp() with a NULL-terminated argument array; command and arguments are configurable
  - Parent waits for child completion using waitpid() and extracts exit status using WIFEXITED/WEXITSTATUS macros
  - Detect signal-caused child termination using WIFSIGNALED/WTERMSIG and report which signal killed the child
  - Child uses _exit() (not exit()) on exec failure to avoid running parent's atexit handlers or flushing parent's stdio buffers
  - Handle fork() failure (returns -1) with informative error message including errno
  - Handle exec() failure in child (e.g., command not found) by reporting error and calling _exit(127)
  - Support passing custom environment variables to the child via execve() or execvpe()
  pitfalls:
  - Using exit() instead of _exit() in the child after a failed exec runs the parent's atexit handlers and flushes shared stdio buffers, causing duplicate output or file corruption
  - Forgetting to check the return value of fork() â€” it returns -1 on failure (e.g., process limit reached)
  - 'Not handling the case where exec fails: the child continues running the parent''s code instead of the intended command'
  - WEXITSTATUS only has meaning when WIFEXITED is true; checking it without the guard returns garbage
  concepts:
  - fork() creates a copy of the calling process
  - exec() family replaces the process image
  - waitpid() and status macros
  - _exit() vs exit() in forked children
  skills:
  - Process lifecycle management with fork/exec/wait
  - System call error handling with errno
  - Child process argument and environment passing
  - Exit status interpretation
  deliverables:
  - fork() call with proper parent/child path branching
  - execvp()/execve() with argument array and optional environment
  - Exit status collection with WIFEXITED and WIFSIGNALED checks
  - Error handling for fork failure, exec failure, and signal termination
  estimated_hours: 2-4
- id: process-spawner-m2
  name: Pipe-Based IPC
  description: 'Set up pipes for bidirectional parent-child communication, redirecting child stdin/stdout/stderr to pipe endpoints.

    '
  acceptance_criteria:
  - Create pipe file descriptor pairs using pipe() BEFORE forking the child process
  - Redirect child stdin to read end of input pipe using dup2(); redirect child stdout to write end of output pipe using dup2()
  - Capture child stderr separately via a third pipe, or merge it with stdout via dup2(stderr_fd, stdout_fd) in the child
  - Close ALL unused pipe ends in BOTH parent and child immediately after dup2(); failure to close unused ends causes EOF detection to fail
  - Parent writes data to child's stdin pipe and reads output from child's stdout pipe
  - 'Handle pipe buffer full condition: if parent writes more than pipe capacity (typically 64KB on Linux) without the child reading, the write blocks; demonstrate awareness via non-blocking mode or select/poll'
  - Read from child stdout pipe until EOF (read returns 0) indicating child has closed its end
  pitfalls:
  - 'Pipe deadlock: if parent writes to child''s stdin while child''s stdout buffer is full, both processes block indefinitely; must use non-blocking I/O or poll both pipes simultaneously'
  - Forgetting to close the write end of the output pipe in the parent causes the parent's read to never see EOF
  - Forgetting to close the read end of the input pipe in the child causes the child to hang waiting for more input
  - dup2() must be called before exec(); after exec() the file descriptor table is inherited but cannot be rearranged
  - Pipe file descriptors might coincidentally equal 0, 1, or 2, which makes dup2 a no-op; handle this edge case
  concepts:
  - pipe() system call and file descriptor pairs
  - dup2() for file descriptor redirection
  - Pipe buffer capacity and blocking behavior
  - EOF detection via closed write end
  skills:
  - Inter-process communication via pipes
  - File descriptor manipulation with dup2
  - Handling blocking I/O and pipe capacity
  - Proper resource cleanup in both processes
  deliverables:
  - Pipe creation before fork for stdin, stdout, and stderr redirection
  - dup2-based redirection in child process
  - Proper close of all unused pipe ends in parent and child
  - Parent write-to-stdin and read-from-stdout demonstration
  - Deadlock-aware I/O using non-blocking mode or select/poll on both pipes
  estimated_hours: 3-5
- id: process-spawner-m3
  name: Worker Process Pool
  description: 'Manage a pool of worker processes with SIGCHLD-driven death detection, process group management, and graceful shutdown.

    '
  acceptance_criteria:
  - Spawn a configurable number (N) of worker processes at startup, each connected to the manager via pipes
  - All worker processes are placed in a dedicated process group using setpgid() so they can be signaled as a group
  - Install a SIGCHLD handler (using sigaction with SA_NOCLDSTOP) that asynchronously detects worker death; handler sets a flag or writes to a self-pipe to notify the main loop
  - Main loop detects worker death via SIGCHLD notification and calls waitpid(WNOHANG) in a loop to reap ALL dead children (multiple children may die between SIGCHLD deliveries)
  - Dead workers are automatically respawned to maintain the configured pool size
  - Work distribution sends tasks to idle workers via their stdin pipes and collects results from their stdout pipes
  - 'Graceful shutdown on SIGTERM: stop sending new tasks, send SIGTERM to the worker process group (kill(-pgid, SIGTERM)), wait for all workers to exit with a timeout, then SIGKILL any stragglers'
  - 'No zombie processes remain after pool operation: all exited children are reaped via waitpid'
  pitfalls:
  - 'SIGCHLD is not queued: if two children die simultaneously, only one SIGCHLD may be delivered; must call waitpid in a loop with WNOHANG until it returns 0 or -1'
  - 'Signal handler race: if SIGCHLD arrives between checking the worker table and calling waitpid, the handler may interfere; use the self-pipe trick or sigprocmask to manage this'
  - Not using process groups means graceful shutdown must iterate over all PIDs and signal each one individually, which is racy if a PID has been reused
  - setpgid() must be called in both parent AND child to avoid a race where the child runs before the parent sets its group
  - Worker stdin pipe must be closed when no more work is available so the worker sees EOF and exits cleanly
  concepts:
  - Process groups (setpgid, kill with negative PID)
  - SIGCHLD handler and asynchronous reaping
  - Self-pipe trick for signal-to-main-loop notification
  - Zombie process prevention
  skills:
  - Signal-driven process management (SIGCHLD)
  - Process group creation and signal delivery
  - Asynchronous event notification (self-pipe)
  - Worker lifecycle management (spawn, monitor, reap, respawn)
  - Graceful shutdown sequencing
  deliverables:
  - Worker pool spawner creating N processes in a dedicated process group
  - SIGCHLD handler with self-pipe notification to main loop
  - Reaping loop using waitpid(WNOHANG) to collect all dead children
  - Automatic worker respawning to maintain pool size
  - Task distribution via pipes to idle workers
  - Graceful shutdown: SIGTERM to process group, timeout, SIGKILL fallback
  estimated_hours: 5-7
domain: systems
