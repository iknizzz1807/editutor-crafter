id: profiler-tool
name: Profiler Tool
description: >
  Build a sampling profiler that measures CPU usage, memory allocation,
  and function timing for performance analysis of applications.

difficulty: intermediate
estimated_hours: 20-30
domain: performance-engineering

essence: >
  Statistical sampling of program execution to identify hot paths,
  memory allocation tracking for leak detection, call graph construction
  for understanding program behavior, and flame graph visualization
  for intuitive performance analysis.

why_important: >
  Profiling is essential for performance optimization. Understanding
  how profilers work enables you to build custom profiling tools and
  interpret profiling data correctly. Valuable at $130K-220K+ for
  performance engineers and systems developers.

learning_outcomes:
  - Implement sampling-based CPU profiling
  - Track memory allocations and detect leaks
  - Build call graph from stack samples
  - Generate flame graph visualization data
  - Handle profiling overhead minimization
  - Support async/await profiling patterns
  - Profile multi-threaded applications
  - Export profiles in standard formats (pprof)

skills:
  - Statistical Sampling
  - Stack Unwinding
  - Memory Tracking
  - Call Graph Analysis
  - Flame Graphs
  - Signal Handling
  - Multi-threading
  - Data Visualization

tags:
  - intermediate
  - debugging
  - flame-graph
  - memory
  - performance
  - profiling
  - sampling

languages:
  recommended:
    - Rust
    - C++
    - Go
  also_possible:
    - Python
    - C

resources:
  - name: "Systems Performance (Brendan Gregg)"
    url: https://www.brendangregg.com/sysperfbook.html
    type: book
  - name: "Flame Graphs"
    url: https://www.brendangregg.com/flamegraphs.html
    type: article
  - name: "pprof Format"
    url: https://github.com/google/pprof/blob/main/proto/README.md
    type: documentation
  - name: "perf_event_open"
    url: https://man7.org/linux/man-pages/man2/perf_event_open.2.html
    type: documentation

prerequisites:
  - type: skill
    name: Understanding of stack frames and calling conventions
  - type: skill
    name: Signal handling in Unix/Linux
  - type: skill
    name: Basic statistics (sampling, confidence)
  - type: skill
    name: Multi-threading concepts

milestones:
  - id: profiler-m1
    name: Sampling-Based CPU Profiler
    description: >
      Implement a statistical sampler that periodically captures
      stack traces to identify CPU hot spots.
    acceptance_criteria:
      - Timer-based sampling at configurable frequency (e.g., 99Hz)
      - Stack unwinding captures full call stack
      - Samples aggregated by function/call path
      - Overhead under 5% at 100Hz sampling
      - Works with multi-threaded applications
      - Handles dynamically loaded code (shared libraries)
    pitfalls:
      - Sampling frequency affects accuracy vs overhead
      - Prime frequency (99Hz) avoids lock-step with application
      - Stack unwinding fails without frame pointers
      - Signal safety in signal handler
      - Thread races during sample collection
    concepts:
      - Statistical sampling
      - Stack unwinding
      - Signal handling
      - Sampling bias
    skills:
      - Timer signals
      - Stack walking
      - Thread handling
      - Overhead management
    deliverables:
      - Sampling profiler core
      - Stack unwinder
      - Sample aggregation
      - Multi-thread support
      - Overhead measurement
    estimated_hours: "8-10"

  - id: profiler-m2
    name: Call Graph & Flame Graph Generation
    description: >
      Build call graph from samples and generate flame graph
      visualization data.
    acceptance_criteria:
      - Call graph constructed from stack samples
      - Each node shows function name and sample count
      - Edges show caller-callee relationships
      - Flame graph data in standard format (folded stacks)
      - SVG or JSON output for visualization
      - Supports filtering by function name
      - Differential flame graphs (compare two profiles)
    pitfalls:
      - Recursive functions inflate counts
      - Inlined functions may not appear
      - Generic functions need monomorphization info
      - Large call graphs hard to visualize
      - Time ordering lost in aggregation
    concepts:
      - Call graph construction
      - Stack folding
      - Flame graph visualization
      - Differential analysis
    skills:
      - Graph algorithms
      - Data aggregation
      - Visualization formats
      - Comparative analysis
    deliverables:
      - Call graph builder
      - Flame graph generator
      - Stack folder
      - SVG/JSON output
      - Differential support
    estimated_hours: "6-8"

  - id: profiler-m3
    name: Memory Allocation Tracking
    description: >
      Track memory allocations to identify allocation hot spots
      and potential memory leaks.
    acceptance_criteria:
      - Hook malloc/free or use LD_PRELOAD interceptor
      - Track allocation size, site (call stack), and timestamp
      - Detect memory leaks (allocated but not freed)
      - Report allocation hot spots by call site
      - Temporal analysis: allocations over time
      - Memory usage high-water mark
      - Low overhead (< 10%) for allocation-heavy code
    pitfalls:
      - Interceptor overhead significant for alloc-heavy code
      - Boehm effect: profiler changes allocation behavior
      - Tracking every allocation uses lots of memory
      - False positives from long-lived caches
      - Free tracking may miss due to optimization
    concepts:
      - Allocation interception
      - Leak detection
      - Call site attribution
      - Memory profiling
    skills:
      - Library interposition
      - Allocation tracking
      - Leak analysis
      - Overhead minimization
    deliverables:
      - Allocation interceptor
      - Leak detector
      - Hot spot reporter
      - Temporal analysis
      - Memory high-water tracking
    estimated_hours: "6-8"

  - id: profiler-m4
    name: Async/Aware Profiling
    description: >
      Extend profiler to handle async/await patterns where
      logical call stacks span multiple physical stacks.
    acceptance_criteria:
      - Async task identification (Future, coroutine, goroutine)
      - Logical call stack reconstruction across await points
      - Time attribution includes both CPU and await time
      - Works with at least one async runtime (Tokio, async-std, goroutines)
      - Visualizes await time separately from CPU time
      - Handles task spawning and completion
    pitfalls:
      - Async runtimes vary in implementation
      - Task identity tracking across migrations
      - Await time includes I/O wait and scheduling delay
      - Logical stack may be deeper than physical
      - Wake-up attribution loses original spawn context
    concepts:
      - Async execution model
      - Logical vs physical stack
      - Task identity
      - Time attribution
    skills:
      - Async runtime integration
      - Task tracking
      - Stack reconstruction
      - Time categorization
    deliverables:
      - Async task tracker
      - Logical stack builder
      - CPU vs await time split
      - Runtime integration
      - Async-aware output
    estimated_hours: "6-8"

  - id: profiler-m5
    name: Profile Export & Integration
    description: >
      Export profiles in standard formats and integrate with
      visualization tools.
    acceptance_criteria:
      - Export in pprof protobuf format
      - Export in collapsed stack format (for flamegraph.pl)
      - Import and merge multiple profile files
      - Symbol resolution for stripped binaries
      - Source code line attribution with debug info
      - HTTP endpoint for continuous profiling (optional)
      - Command-line interface for profiling
    pitfalls:
      - pprof format has multiple versions
      - Symbol resolution needs debug symbols
      - Source lines may be inlined away
      - Continuous profiling uses storage
      - HTTP endpoint security considerations
    concepts:
      - Profile formats
      - Symbol resolution
      - Debug information
      - Continuous profiling
    skills:
      - Format implementation
      - Binary analysis
      - Tool integration
      - CLI design
    deliverables:
      - pprof exporter
      - Collapsed stack exporter
      - Profile merger
      - Symbol resolver
      - CLI tool
    estimated_hours: "4-6"
