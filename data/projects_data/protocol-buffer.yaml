id: protocol-buffer
name: Protocol Buffer Codec
description: Binary serialization format implementation compatible with Protocol Buffers wire format
difficulty: advanced
estimated_hours: "25-35"
essence: >
  Variable-length integer encoding (varints) combined with a tag-based
  wire format where each field is encoded as (field_number << 3 | wire_type)
  followed by payload data, enabling compact binary serialization with
  schema-driven encoding/decoding and forward/backward compatibility.
why_important: >
  Building this teaches the engineering tradeoffs in binary protocol
  design—balancing compactness, parsing speed, and schema evolution—skills
  directly applicable to distributed systems, storage engines, and network
  protocol implementation.
learning_outcomes:
  - Implement unsigned and signed varint encoding with continuation bits
  - Understand the difference between sign-extended varints (int32) and ZigZag encoding (sint32)
  - Design and implement a tag-length-value wire format
  - Build a schema parser for a simplified .proto subset
  - Handle backward and forward compatibility through unknown field preservation
  - Implement packed repeated field encoding
  - Debug binary protocols using hex dumps
skills:
  - Binary Serialization
  - Varint Encoding
  - Wire Protocol Design
  - Schema-Driven Architecture
  - Bit Manipulation
  - Protocol Evolution
  - Parsing Techniques
tags:
  - advanced
  - binary
  - go
  - protocols
  - python
  - rust
  - schema
  - serialization
  - wire-format
architecture_doc: architecture-docs/protocol-buffer/index.md
languages:
  recommended:
    - Python
    - Go
    - Rust
  also_possible:
    - C
    - Java
resources:
  - name: Protocol Buffers Encoding
    url: "https://protobuf.dev/programming-guides/encoding/"
    type: reference
  - name: Varint Encoding
    url: "https://developers.google.com/protocol-buffers/docs/encoding#varints"
    type: tutorial
  - name: Proto3 Language Guide
    url: "https://protobuf.dev/programming-guides/proto3/"
    type: reference
prerequisites:
  - type: skill
    name: Binary encoding and bitwise operations
  - type: skill
    name: Schema concepts (types, fields)
  - type: skill
    name: Data structures (maps, lists, trees)
milestones:
  - id: protocol-buffer-m1
    name: Varint Encoding
    description: Implement variable-length integer encoding for both unsigned and signed integers.
    estimated_hours: "4-5"
    concepts:
      - Variable-length encoding (base-128)
      - ZigZag encoding for sint32/sint64
      - Sign-extended varints for int32/int64
    skills:
      - Binary data manipulation
      - Bitwise operations (shifts, masks, continuation bits)
      - Multi-byte sequence encoding/decoding
    acceptance_criteria:
      - "Encode unsigned integers (uint32/uint64) as base-128 varints with 7 data bits per byte and MSB as continuation bit"
      - "Decode unsigned varints from a byte stream returning the value AND the number of bytes consumed"
      - "Implement ZigZag encoding for sint32/sint64: (n << 1) ^ (n >> 31) for 32-bit, (n << 1) ^ (n >> 63) for 64-bit"
      - "Implement ZigZag decoding: (n >>> 1) ^ -(n & 1)"
      - "Implement sign-extended varint encoding for int32/int64: negative int32 values are sign-extended to 64-bit and encoded as 10-byte varints (this is the protobuf int32 behavior, NOT ZigZag)"
      - "Handle the full 64-bit range: values up to 2^64-1 for unsigned, -2^63 to 2^63-1 for signed"
      - "Reject varints longer than 10 bytes as malformed (10 bytes is the maximum for 64-bit values)"
      - "Verify: encode then decode round-trips correctly for edge values: 0, 1, 127, 128, 16383, 16384, -1 (ZigZag=1, int32=10 bytes), INT32_MIN, INT64_MAX, UINT64_MAX"
    pitfalls:
      - "CRITICAL: int32 and sint32 use DIFFERENT encodings for negative numbers. int32(-1) = 10 bytes (sign-extended), sint32(-1) = 1 byte (ZigZag maps -1 to 1). Confusing these is the #1 protobuf encoding bug."
      - "Varint decoding must check for overflow; a malicious input could have more than 10 continuation bytes"
      - "Python's arbitrary-precision integers can mask overflow bugs that would appear in C/Go/Rust"
      - "Forgetting the unsigned right shift (>>>) in ZigZag decode causes sign extension bugs in languages with signed shift"
    deliverables:
      - Unsigned varint encoder and decoder
      - ZigZag encoder and decoder for sint32/sint64
      - Sign-extended varint encoder for int32/int64
      - Comprehensive test suite covering edge values

  - id: protocol-buffer-m2
    name: Wire Format Encoding
    description: Implement the wire type system and field key encoding.
    estimated_hours: "5-6"
    concepts:
      - Wire types (VARINT=0, I64=1, LEN=2, I32=5)
      - Field key encoding (field_number << 3 | wire_type)
      - Tag-length-value structure
    skills:
      - Binary protocol implementation
      - Little-endian byte ordering
      - Length-delimited field framing
      - Unknown field skipping
    acceptance_criteria:
      - "Encode field keys as varints: (field_number << 3) | wire_type"
      - "Decode field keys extracting field_number (key >> 3) and wire_type (key & 0x07)"
      - "Wire type 0 (VARINT): encode/decode int32, int64, uint32, uint64, sint32, sint64, bool, enum values"
      - "Wire type 1 (I64): encode/decode fixed64, sfixed64, double as 8 bytes in little-endian order"
      - "Wire type 2 (LEN): encode/decode strings, bytes, embedded messages, and packed repeated fields as varint-length-prefixed byte sequences"
      - "Wire type 5 (I32): encode/decode fixed32, sfixed32, float as 4 bytes in little-endian order"
      - "Skip deprecated wire types 3 (SGROUP) and 4 (EGROUP) without error when encountered during decoding"
      - "Validate field numbers are in range 1 to 2^29-1 and not in reserved range 19000-19999"
      - "Implement a raw wire-format decoder that reads a protobuf binary and dumps all fields as (field_number, wire_type, raw_value) without a schema"
      - "Verify: encode a message with the reference protobuf library (e.g., protoc + Python protobuf), decode with your implementation, and compare field values"
    pitfalls:
      - "Fixed-size fields (I32, I64) are little-endian, matching x86 native order but differing from network byte order"
      - "Unknown fields (unrecognized field numbers) must be SKIPPED based on wire type, not rejected; this enables forward compatibility"
      - "Wire type 2 (LEN) is overloaded for strings, bytes, sub-messages, and packed repeated fields; the schema determines interpretation"
      - "Boolean true encodes as varint 1, false as varint 0; but decoders should treat any non-zero varint as true"
    deliverables:
      - Field key encoder and decoder
      - Wire type 0 (VARINT) encoder/decoder
      - Wire type 1 (I64) and type 5 (I32) encoder/decoder in little-endian
      - Wire type 2 (LEN) length-prefixed encoder/decoder
      - Unknown field skipper based on wire type
      - Raw wire-format dumper (schema-less decoder)

  - id: protocol-buffer-m3
    name: Schema Parser
    description: Parse a simplified .proto file subset to drive schema-aware encoding/decoding.
    estimated_hours: "5-6"
    concepts:
      - Schema languages
      - Recursive descent parsing
      - Type system mapping
    skills:
      - Lexer/parser implementation
      - AST construction
      - Schema validation
    acceptance_criteria:
      - "Parse a simplified .proto3 subset supporting: syntax declaration, message definitions, field declarations (type name = number;)"
      - "Support scalar types: int32, int64, uint32, uint64, sint32, sint64, fixed32, fixed64, sfixed32, sfixed64, float, double, bool, string, bytes"
      - "Support 'repeated' field modifier for array-type fields"
      - "Support nested message definitions (message inside message)"
      - "Support enum definitions with named integer constants"
      - "Validate field numbers are unique within each message and in valid range (1 to 536870911, excluding 19000-19999)"
      - "Build an in-memory schema representation mapping message names to field definitions (number, type, name, modifier)"
      - "Map each field type to its wire type (e.g., int32 -> VARINT, string -> LEN, float -> I32)"
      - "Report parse errors with line numbers: unknown types, duplicate field numbers, syntax errors"
    pitfalls:
      - "Field numbers must be unique within a message; detect and report duplicates"
      - "Nested message types need qualified name resolution (e.g., Outer.Inner)"
      - "The 'repeated' keyword changes serialization behavior (packed encoding for scalars in proto3)"
      - "Do not attempt to parse the full .proto3 grammar (oneof, map, service, options, etc.); explicitly scope to the subset above"
    deliverables:
      - Lexer tokenizing .proto file
      - Message and field definition parser
      - Enum definition parser
      - Schema validation (unique field numbers, valid types)
      - In-memory schema representation with field-to-wire-type mapping

  - id: protocol-buffer-m4
    name: Schema-Aware Serialization and Deserialization
    description: Serialize and deserialize structured data according to the parsed schema.
    estimated_hours: "6-8"
    concepts:
      - Schema-driven encoding
      - Packed repeated fields
      - Nested message encoding
      - Forward/backward compatibility
    skills:
      - Schema-driven serialization
      - Recursive encoding for nested messages
      - Packed encoding for repeated scalars
    acceptance_criteria:
      - "Serialize a language-native data structure (dict/struct/map) to protobuf binary bytes using the parsed schema for field number and wire type lookup"
      - "Deserialize protobuf binary bytes back into a language-native data structure using the schema for field name and type resolution"
      - "Encode repeated scalar fields using packed encoding (wire type 2 containing concatenated varints/fixed values), matching proto3 default behavior"
      - "Encode nested messages as length-delimited (wire type 2) with recursive serialization"
      - "Handle missing optional fields by simply not encoding them (proto3 default behavior)"
      - "Handle unknown fields during deserialization by preserving them as raw bytes (for re-serialization)"
      - "Handle default values: in proto3, fields with default values (0, false, empty string) are not encoded; decoder must return defaults for missing fields"
      - "Round-trip test: create a message with the reference protobuf library, decode with your implementation, re-encode with your implementation, decode with reference library; all field values must match"
      - "Compatibility test: add a new field to the schema; verify that old encoded messages (without the new field) decode successfully with default values"
    pitfalls:
      - "Field order in the wire format is arbitrary and may not match field number order; do not assume ordering"
      - "Unknown fields must be preserved and re-serialized for forward compatibility; discarding them breaks proxies and middleware"
      - "Empty repeated fields produce no bytes in the wire format (not even a zero-length LEN)"
      - "Packed repeated encoding is a single LEN field containing all elements; non-packed encoding repeats the field key for each element. Proto3 defaults to packed for scalar types"
      - "Nested message encoding requires computing the serialized size before writing the length prefix; this may require a two-pass approach or buffering"
    deliverables:
      - Schema-aware serializer encoding all supported field types
      - Schema-aware deserializer with field name resolution
      - Packed repeated field encoding and decoding
      - Nested message recursive encoding/decoding
      - Unknown field preservation
      - Default value handling for proto3 semantics
      - Round-trip compatibility test suite