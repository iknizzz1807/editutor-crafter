id: rest-api-design
name: Production REST API
description: >-
  Build a production-grade REST API with authentication, input validation,
  rate limiting, proper error handling, and API versioning.
difficulty: intermediate
estimated_hours: "25-35"
essence: >-
  Request routing and middleware composition with stateless authentication
  tokens, combining HTTP protocol semantics, concurrent connection handling,
  and algorithmic rate limiting to process client requests through validation,
  authorization, and serialization layers before persisting state changes.
why_important: >-
  Production REST APIs are the backbone of modern web and mobile applications,
  making this essential infrastructure that every backend developer must master.
  This project teaches industry-standard patterns for secure, scalable API
  design that directly applies to real-world backend engineering roles.
learning_outcomes:
  - Implement CRUD operations with correct HTTP verb semantics, idempotency guarantees, and status codes
  - Design resource-based URL structures following REST architectural constraints
  - Build JWT-based authentication with token generation, validation, and refresh mechanisms
  - Implement role-based access control with middleware authorization layers
  - Validate and sanitize input data using schema validation libraries
  - Handle errors consistently with structured error responses and proper status codes
  - Apply rate limiting algorithms to prevent API abuse and ensure fair resource usage
  - Structure API responses with consistent data serialization, pagination, and versioning
skills:
  - RESTful Architecture
  - HTTP Protocol
  - JWT Authentication
  - Input Validation
  - Rate Limiting
  - Error Handling
  - API Security
  - Middleware Patterns
  - API Versioning
tags:
  - api
  - crud
  - endpoints
  - go
  - intermediate
  - node.js
  - python
  - validation
  - versioning
architecture_doc: architecture-docs/rest-api-design/index.md
languages:
  recommended:
    - Go
    - Python
    - Node.js
  also_possible:
    - Rust
    - Java
resources:
  - name: REST API Design Best Practices
    url: https://restfulapi.net/
    type: tutorial
  - name: OpenAPI Specification
    url: https://swagger.io/specification/
    type: documentation
  - name: "RFC 9110: HTTP Semantics"
    url: https://www.rfc-editor.org/rfc/rfc9110
    type: documentation
prerequisites:
  - type: skill
    name: HTTP basics
  - type: skill
    name: JSON
  - type: skill
    name: Database basics
milestones:
  - id: rest-api-design-m1
    name: CRUD Operations & HTTP Semantics
    description: >-
      Implement Create, Read, Update, Delete operations with correct HTTP
      methods, status codes, and content negotiation.
    acceptance_criteria:
      - "POST /resources creates a new resource, returns 201 Created with a Location header pointing to the new resource URI"
      - "GET /resources returns a paginated list with Link headers or next/prev cursors; default page size is configurable"
      - "GET /resources/: id returns the single resource with 200 OK, or 404 Not Found with a structured error body"
      - "PUT /resources/: id replaces the entire resource representation idempotently and returns 200 OK with the new state"
      - "PATCH /resources/: id applies a partial update to specified fields only and returns 200 OK with the updated state"
      - "DELETE /resources/: id removes the resource and returns 204 No Content with an empty body"
      - "All responses include correct Content-Type header (application/json) and a consistent JSON envelope structure"
      - "Concurrent updates are detected using an ETag or version field; conflicting writes return 409 Conflict"
    pitfalls:
      - "Using POST for updates or GET for mutations violates HTTP method semantics and breaks cacheability"
      - "Returning 200 for resource creation instead of 201 with Location header"
      - "Treating PUT and PATCH identically; PUT must replace the full resource, PATCH applies partial changes"
      - "Not handling concurrent updates with optimistic locking (ETag/If-Match) leading to lost updates"
      - "Missing or incorrect Content-Type headers causing client deserialization failures"
    concepts:
      - REST principles and uniform interface constraint
      - HTTP methods and idempotency guarantees
      - Status codes (2xx, 4xx, 5xx) and their semantics
      - Resource modeling and URI design
      - Optimistic concurrency control with ETags
    skills:
      - HTTP API Design
      - Resource Modeling
      - Database Operations
      - JSON Serialization
      - Concurrency Control
    deliverables:
      - Resource endpoints following RESTful URL naming conventions
      - HTTP method mapping with correct idempotency semantics for PUT vs PATCH
      - Consistent JSON response envelope with data, error, and metadata fields
      - ETag-based optimistic locking for update operations
    estimated_hours: "5-7"

  - id: rest-api-design-m2
    name: Input Validation & Error Handling
    description: >-
      Validate all input data, sanitize against injection attacks, and return
      structured, consistent error responses.
    acceptance_criteria:
      - "Request body fields are validated against a defined JSON schema; invalid requests return 400 Bad Request"
      - "Query parameters are validated for type, range, and allowed values; out-of-range values return 400"
      - "Path parameters are validated for correct format; non-existent resources return 404 Not Found"
      - "Validation error responses include a structured body listing each field-level failure with field name, expected constraint, and actual value"
      - "All string inputs are sanitized against SQL injection and NoSQL injection before use in queries"
      - "Error responses follow a consistent schema across all endpoints: {error: {code, message, details[]}}"
      - "Internal errors return 500 with a generic message; no stack traces or internal details are leaked to the client"
    pitfalls:
      - "Only validating types but not business rules (e.g., end_date must be after start_date)"
      - "Exposing internal error details, stack traces, or database error messages to the client"
      - "Not validating query and path parameters, only request bodies"
      - "SQL/NoSQL injection through unvalidated or unsanitized string inputs used in queries"
      - "Confusing input sanitization for a REST API (injection prevention) with XSS sanitization (a client-rendering concern)"
    concepts:
      - JSON Schema validation
      - Structured error response design
      - Input sanitization vs output encoding
      - SQL and NoSQL injection prevention
      - Defense in depth
    skills:
      - Input Validation
      - Security Best Practices
      - Error Response Design
      - Data Sanitization
    deliverables:
      - Request body validation middleware using JSON Schema definitions
      - Query and path parameter validation with type coercion and range checks
      - Consistent error response format applied across all endpoints
      - Input sanitization layer preventing injection attacks at the query construction level
    estimated_hours: "4-6"

  - id: rest-api-design-m3
    name: Authentication & Authorization
    description: >-
      Implement JWT authentication with token lifecycle management and
      role-based access control.
    acceptance_criteria:
      - "POST /auth/register creates a new user with a securely hashed password (bcrypt cost >= 10 or argon2id)"
      - "POST /auth/login validates credentials and returns a signed JWT access token with a configurable short expiration (e.g., 15 minutes)"
      - "POST /auth/refresh accepts a valid refresh token and returns a new access token; refresh tokens have longer expiration"
      - "Protected endpoints return 401 Unauthorized when the request lacks a valid, non-expired JWT"
      - "Role-based access control restricts endpoints by user role; unauthorized role access returns 403 Forbidden"
      - "JWT secret is loaded from environment variables or a secrets manager, never hardcoded in source"
      - "Tokens issued before a password change are invalidated (e.g., via a per-user token version or issued-at check)"
    pitfalls:
      - "Storing JWT secrets in source code or version control"
      - "Setting token expiration too long (hours/days) for access tokens, negating the benefit of short-lived tokens"
      - "Not invalidating existing tokens when a user changes their password"
      - "RBAC bypass through Insecure Direct Object Reference (IDOR); always verify resource ownership, not just role"
      - "Using symmetric HS256 when asymmetric RS256 is more appropriate for distributed verification"
    concepts:
      - JWT structure (header, payload, signature)
      - Password hashing with bcrypt/argon2id
      - Role-based access control (RBAC)
      - Token refresh rotation
      - Stateless vs stateful token invalidation
    skills:
      - Authentication Systems
      - Security Token Management
      - Password Security
      - Access Control Implementation
    deliverables:
      - JWT-based authentication with access and refresh token generation and validation
      - User registration with secure password hashing
      - Role-based access control middleware restricting endpoints by user role
      - Token invalidation mechanism tied to password changes
    estimated_hours: "6-8"

  - id: rest-api-design-m4
    name: Rate Limiting & API Hardening
    description: >-
      Protect the API from abuse with rate limiting and add production
      hardening features including health checks and versioning.
    acceptance_criteria:
      - "Per-user rate limits are enforced based on authenticated identity; unauthenticated requests are limited by IP"
      - "Rate limiting uses a sliding window or token bucket algorithm; the choice is documented with trade-off rationale"
      - "All responses include X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset headers"
      - "Requests exceeding the rate limit return 429 Too Many Requests with a Retry-After header"
      - "Rate limiter gracefully degrades if the backing store (e.g., Redis) is unavailable, defaulting to allow or a local fallback"
      - "GET /health returns 200 OK with database connectivity status for liveness/readiness probes"
      - "API versioning is implemented via URL prefix (e.g., /v1/) or Accept header; version routing is tested"
    pitfalls:
      - "Rate limiting only by IP is trivially bypassed with proxies; combine with authenticated identity"
      - "Not handling Redis/backing store failures; a crash in the rate limiter should not crash the API"
      - "Clock skew between distributed instances causes inconsistent rate limit enforcement"
      - "Forgetting the Retry-After header on 429 responses, leaving clients guessing when to retry"
      - "Not versioning the API from day one, making breaking changes impossible to manage later"
    concepts:
      - Sliding window vs token bucket vs fixed window algorithms
      - Distributed rate limiting with Redis
      - API versioning strategies
      - Health check endpoints for orchestrators
    skills:
      - Rate Limiting Implementation
      - Distributed Caching
      - API Protection
      - API Versioning
      - Operational Readiness
    deliverables:
      - Rate limit middleware with configurable algorithm and per-route thresholds
      - Standard rate limit response headers on all API responses
      - 429 response with Retry-After header and structured error body
      - Health check endpoint reporting service and dependency status
      - API versioning mechanism with at least one versioned route
    estimated_hours: "6-8"