id: rpc-basic
name: RPC Framework (Basic)
description: Build a basic RPC framework with message framing, JSON serialization, TCP client-server communication, method dispatching, and transparent remote method invocation.
difficulty: beginner
estimated_hours: 12-18
essence: Length-prefixed message framing over TCP streams, JSON-based request/response serialization with unique correlation IDs, server-side method registry and dispatch, and client-side proxy abstraction for transparent remote procedure calls with proper error categorization.
why_important: Building an RPC framework teaches foundational distributed systems concepts used in microservices, gRPC, and modern APIs, while developing crucial skills in network programming, protocol design, and the critical distinction between transport and application errors.
learning_outcomes:
- Design a length-prefixed message framing protocol for TCP streams
- Implement JSON-based request/response serialization with correlation IDs
- Build a TCP server with concurrent client handling and method dispatch
- Distinguish between transport errors (network) and application errors (remote exceptions)
- Create client-side proxy objects for transparent remote method invocation
- Handle connection lifecycle including timeouts and reconnection
- Implement basic service introspection for method discovery
- Debug message framing bugs caused by TCP stream buffering
skills:
- TCP/IP Networking
- Message Framing (length-prefixing)
- JSON Serialization
- Client-Server Architecture
- Protocol Design
- Socket Programming
- Error Categorization
- Method Dispatching
tags:
- beginner-friendly
- go
- java
- marshalling
- networking
- protocols
- python
- serialization
- stubs
architecture_doc: architecture-docs/rpc-basic/index.md
languages:
  recommended:
  - Python
  - Go
  - Java
  also_possible:
  - JavaScript
  - Rust
resources:
- name: gRPC Concepts
  url: https://grpc.io/docs/what-is-grpc/core-concepts/
  type: documentation
- name: JSON-RPC 2.0 Specification
  url: https://www.jsonrpc.org/specification
  type: specification
- name: Beej's Guide to Network Programming""
  url: https://beej.us/guide/bgnet/
  type: tutorial
prerequisites:
- type: skill
  name: TCP sockets basics
- type: skill
  name: JSON serialization/deserialization
- type: skill
  name: Basic concurrency (threads or async)
milestones:
- id: rpc-basic-m1
  name: Message Framing and Protocol
  description: Define the wire protocol with length-prefixed message framing and JSON-based request/response format. TCP is a byte stream, not a message stream — without framing, messages will merge or split unpredictably in the receive buffer.
  acceptance_criteria:
  - Messages are framed with a 4-byte big-endian length prefix followed by the JSON payload bytes
  - 'Request format contains fields: jsonrpc (version string), method (string), params (array or object), and id (unique integer or string)'
  - 'Response format contains fields: jsonrpc (version string), result (any) OR error (object with code and message), and id (matching request id)'
  - Framing correctly handles messages up to 1MB; messages exceeding max size are rejected with an error
  - A standalone encode/decode module can round-trip serialize and deserialize 1000 random messages without data loss
  - 'Partial TCP reads are handled correctly: the receiver accumulates bytes until the full length-prefixed message is available'
  pitfalls:
  - 'Not handling partial TCP reads: recv() may return fewer bytes than the length prefix indicates, requiring a read loop'
  - 'Endianness mismatch: always use network byte order (big-endian) for the length prefix'
  - 'Not validating the length prefix: a malicious or buggy client sending length=2GB will exhaust memory'
  - 'Using newline delimiters instead of length-prefixing: JSON payloads can contain newlines, breaking the framing'
  concepts:
  - TCP stream vs message semantics
  - Length-prefixed framing
  - JSON-RPC 2.0 message format
  - Network byte order
  skills:
  - Binary data packing/unpacking
  - TCP stream buffering
  - JSON serialization
  - Protocol specification design
  deliverables:
  - Message framing module with encode (length-prefix + payload) and decode (read length, read payload) functions
  - Request and Response data classes/structs matching JSON-RPC 2.0 format
  - Validation function rejecting malformed messages (missing fields, oversized payloads)
  - Unit tests proving correct round-trip serialization of various parameter types
  estimated_hours: 3-4
- id: rpc-basic-m2
  name: Server with Method Registry and Dispatch
  description: Build a TCP server that accepts concurrent client connections, reads framed messages, dispatches method calls to registered handlers, and returns framed responses. The server must distinguish between transport-level errors and application-level errors.
  acceptance_criteria:
  - Server listens on a configurable TCP port and accepts multiple concurrent client connections (thread-per-connection or async)
  - Callable handler functions are registered by name in a method registry at server startup
  - Incoming requests are dispatched to the matching handler; unknown methods return a JSON-RPC error with code -32601 (Method not found)
  - Parameter type/count mismatches return a JSON-RPC error with code -32602 (Invalid params)
  - Unhandled exceptions in handlers are caught and returned as JSON-RPC error with code -32603 (Internal error) without crashing the server
  - Server handles at least 10 concurrent clients sending requests simultaneously without deadlock or data corruption
  - A special introspection method 'rpc.listMethods' returns a list of all registered method names
  pitfalls:
  - 'Single-threaded server blocks all clients while processing one request: always handle clients concurrently'
  - 'Letting handler exceptions crash the server: every handler invocation must be wrapped in try/except'
  - 'Not closing client connections on framing errors: a malformed message should close that connection, not corrupt state'
  - 'Shared mutable state in handlers without synchronization: the method registry is read-only after startup, but handler state may not be'
  concepts:
  - Method registry and dynamic dispatch
  - Concurrent connection handling
  - JSON-RPC error codes
  - Transport vs application error separation
  skills:
  - TCP server implementation
  - Thread/goroutine/async connection handling
  - Dynamic method dispatch by name
  - Error classification and propagation
  deliverables:
  - TCP server with concurrent connection handling
  - Method registry (map of name → callable) with registration API
  - Request dispatcher that parses messages, looks up methods, invokes handlers, and returns responses
  - Error response generation with proper JSON-RPC error codes
  - Introspection endpoint listing available methods
  estimated_hours: 4-5
- id: rpc-basic-m3
  name: Client with Proxy and Error Handling
  description: Build an RPC client that connects to the server, sends framed requests, correlates responses by ID, and provides a proxy object for transparent method invocation. The client must distinguish transport errors from remote application errors.
  acceptance_criteria:
  - Client connects to server via TCP and performs framed message exchange
  - Each outgoing request is assigned a monotonically increasing unique ID for correlation
  - Client provides a proxy object where calling proxy.method_name(args) transparently sends an RPC request and returns the result
  - Transport errors (connection refused, socket closed, timeout) raise a distinct TransportError exception type
  - Remote application errors (method not found, invalid params, handler exception) raise a distinct RemoteError exception type containing the error code and message
  - Configurable per-call timeout (default 30s) raises TimeoutError if no response is received within the deadline
  - Client can be used in a context manager / with-statement for automatic connection cleanup
  pitfalls:
  - 'Not correlating responses by ID: if the server sends responses out of order (future pipelining), mismatched results will occur'
  - 'Conflating transport and application errors: retrying a ''method not found'' error is pointless, but retrying a connection timeout is valid'
  - 'Not implementing connection cleanup: leaked TCP connections exhaust file descriptors'
  - 'Infinite timeout by default: a missing timeout means a hung server hangs the client forever'
  concepts:
  - Client-side proxy / stub pattern
  - Request-response correlation by ID
  - Transport vs application error distinction
  - Connection lifecycle management
  skills:
  - Dynamic proxy / __getattr__ / reflection
  - TCP client socket programming
  - Timeout implementation with socket options or select()
  - Exception hierarchy design
  deliverables:
  - TCP client with connect, send, receive, and close operations
  - Proxy object translating method calls to RPC requests
  - Response correlation matching responses to pending requests by ID
  - Typed exception hierarchy (TransportError, RemoteError, TimeoutError)
  - Configurable timeout per call
  estimated_hours: 4-5
- id: rpc-basic-m4
  name: Integration Testing and Edge Cases
  description: 'Write comprehensive integration tests proving the RPC framework handles real-world scenarios: concurrent calls, large payloads, server crashes, and malformed messages.'
  acceptance_criteria:
  - 'Integration test: 10 concurrent clients each make 100 calls; all 1000 responses are correctly correlated and returned'
  - 'Integration test: calling a method that throws an exception returns RemoteError on the client without crashing the server'
  - 'Integration test: sending a payload larger than the max message size is rejected gracefully'
  - 'Integration test: server shutdown while client is waiting returns TransportError on the client'
  - 'Integration test: client timeout fires correctly when server handler sleeps longer than the deadline'
  - 'Integration test: rpc.listMethods returns all registered method names'
  pitfalls:
  - 'Flaky tests from port conflicts: use dynamic port assignment (port 0) in tests'
  - 'Not waiting for server startup before connecting clients: add a readiness check'
  - 'Test isolation: each test should start a fresh server to avoid state leakage'
  concepts:
  - Integration testing patterns
  - Fault injection
  - Test isolation
  skills:
  - Test framework usage
  - Concurrent test orchestration
  - Port management in tests
  - Fault injection techniques
  deliverables:
  - Integration test suite covering happy path, error paths, and edge cases
  - Concurrent client stress test
  - Fault injection tests (server crash, timeout, malformed message)
  - CI-compatible test runner configuration
  estimated_hours: 2-3
domain: distributed
