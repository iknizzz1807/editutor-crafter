id: secret-management
name: Secret Management Vault
description: Secure storage for API keys, credentials, and certificates with envelope encryption, Shamir's secret sharing, identity-based authentication, dynamic credentials, and audit logging.
difficulty: expert
estimated_hours: 55-75
essence: Cryptographic key hierarchy management using envelope encryption with a master key protected by Shamir's secret sharing for distributed unsealing, identity-based authentication mapping external identities to internal policies, path-based access control enforcement, ephemeral credential generation with lease lifecycle management, and tamper-evident audit logging for all secret operations.
why_important: Building a secret management system teaches you production-grade cryptography, distributed systems security patterns, identity mapping, and credential lifecycle management—critical skills for any infrastructure or security engineering role.
learning_outcomes:
- Implement envelope encryption with a key hierarchy (unseal key → master key → data encryption keys)
- Design Shamir's secret sharing for distributed unseal key splitting with threshold reconstruction
- Build identity-based authentication mapping external identities (tokens, certificates) to vault policies
- Implement path-based access control lists with wildcard matching and policy evaluation
- Build dynamic credential generation for databases with TTL-based lease lifecycle management
- Create tamper-evident audit logging for all secret read/write/delete operations
- Implement sealed/unsealed state machine rejecting all operations when sealed
- Develop high-availability replication using an existing consensus library
- Debug and secure against timing attacks, key exposure, and unauthorized access
- Integrate cryptographic libraries safely while avoiding common implementation pitfalls
skills:
- Envelope Encryption
- Shamir Secret Sharing
- Identity-Based Authentication
- Path-Based Access Control
- Dynamic Credential Generation
- Lease Lifecycle Management
- Audit Logging
- Cryptographic Key Management
- Sealed/Unsealed State Machine
tags:
- authentication
- encryption
- encryption-at-rest
- expert
- infrastructure
- rotation
- secrets
- security
- vault
- identity
architecture_doc: architecture-docs/secret-management/index.md
languages:
  recommended:
  - Go
  - Rust
  - Python
  also_possible:
  - Java
resources:
- name: HashiCorp Vault Architecture
  url: https://developer.hashicorp.com/vault/docs/internals/architecture
  type: documentation
- name: Envelope Encryption Guide
  url: https://docs.cloud.google.com/kms/docs/envelope-encryption
  type: documentation
- name: Shamir's Secret Sharing""
  url: https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing
  type: reference
- name: HashiCorp Vault Seal/Unseal
  url: https://developer.hashicorp.com/vault/docs/concepts/seal
  type: documentation
- name: Database Dynamic Secrets
  url: https://developer.hashicorp.com/vault/tutorials/db-credentials/database-secrets
  type: tutorial
prerequisites:
- type: project
  id: http-server-basic
  name: HTTP Server (Basic)
- type: skill
  name: Symmetric encryption (AES-GCM)
- type: skill
  name: HTTP API design
- type: skill
  name: Database operations (SQL)
milestones:
- id: secret-management-m1
  name: Encrypted Storage & Seal/Unseal Mechanism
  description: Implement envelope encryption with a three-layer key hierarchy (unseal key → master key → data encryption keys) and Shamir's secret sharing for distributed unsealing.
  acceptance_criteria:
  - 'Implement three-layer key hierarchy: unseal key decrypts encrypted master key; master key encrypts/decrypts data encryption keys (DEKs); DEKs encrypt individual secrets'
  - Generate master key as cryptographically random 256-bit key at vault initialization
  - Encrypt master key with unseal key and store the encrypted master key on disk
  - Implement Shamir's secret sharing to split unseal key into N shares with threshold T (configurable, e.g., 5 shares, threshold 3)
  - Display unseal key shares ONCE during initialization; they are never stored by the vault
  - Unseal operation accepts individual key shares; vault transitions to unsealed state when T shares are collected
  - 'Implement sealed/unsealed state machine: when sealed, ALL API operations (except unseal and status) return HTTP 503'
  - Encrypt all secret values at rest using AES-256-GCM with per-secret DEKs
  - DEKs are encrypted by master key and stored alongside the encrypted secret
  - 'Support secret versioning: store up to N previous versions (configurable) with creation timestamps'
  - 'Key rotation: generate new master key, re-encrypt all DEKs with new master key without re-encrypting secrets themselves'
  - Seal operation clears master key from memory and transitions back to sealed state
  - Zero sensitive key material from memory after use (explicit memset/zeroize, not just deallocation)
  pitfalls:
  - Shamir splits the UNSEAL KEY, not the master key directly; master key is encrypted by unseal key and stored on disk
  - Never store all Shamir shares together; distribute to different operators/locations
  - Clear unseal key shares from memory immediately after reconstruction
  - AES-GCM nonces must be unique per encryption; use random 96-bit nonces or deterministic counter
  - Key rotation re-encrypts DEKs (fast) not secrets (slow); this is the envelope encryption advantage
  - Memory can be swapped to disk; consider mlock() to prevent sensitive pages from being swapped
  - PBKDF2 is legacy; prefer Argon2id for any password-derived keys (600k+ iterations for PBKDF2 if used)
  concepts:
  - Envelope encryption (three-layer key hierarchy)
  - Shamir's secret sharing threshold scheme
  - Sealed/unsealed state machine
  - AES-GCM authenticated encryption
  - Key rotation without re-encrypting data
  - Secure memory handling and zeroing
  skills:
  - Envelope encryption implementation
  - Shamir secret sharing (polynomial interpolation over finite fields)
  - State machine design
  - Cryptographic key lifecycle management
  deliverables:
  - Three-layer key hierarchy (unseal key → master key → DEKs)
  - Shamir's secret sharing splitting unseal key into N shares with threshold T
  - Unseal API accepting individual shares and reconstructing unseal key at threshold
  - Sealed/unsealed state machine rejecting operations when sealed
  - AES-256-GCM encryption for all secrets at rest
  - Secret versioning with configurable version retention
  - Master key rotation re-encrypting all DEKs
  - Seal API clearing master key from memory
  estimated_hours: 14-18
- id: secret-management-m2
  name: Identity, Authentication & Access Policies
  description: Implement identity-based authentication mapping external identities to vault tokens with attached policies, and path-based ACLs for secret access control.
  acceptance_criteria:
  - 'Implement token authentication: vault issues opaque tokens with attached policy references and TTL'
  - Implement at least one external auth method that maps an external identity to a vault token (e.g., userpass, TLS certificate, or app-role)
  - 'AppRole auth method: role_id (can be embedded in code) + secret_id (delivered securely) → vault token'
  - Define path-based ACL policies specifying capabilities (create, read, update, delete, list) on secret paths
  - 'Policy paths support glob wildcards: ''secret/data/myapp/*'' matches all secrets under that prefix'
  - 'Policy evaluation: request is allowed only if at least one attached policy grants the required capability on the path'
  - 'Default-deny: if no policy grants the capability, the request is denied'
  - Tokens have configurable TTL and max-TTL; expired tokens are rejected
  - Token renewal extends TTL up to max-TTL; renewal beyond max-TTL is denied
  - Root token (created at initialization) has unrestricted access; should be revoked after initial setup
  - All authentication and authorization decisions are logged with identity, path, capability, and outcome
  pitfalls:
  - role_id can be embedded in deployment configs; secret_id must be delivered through a secure channel (one-time use)
  - Token lookup table grows unbounded; implement periodic cleanup of expired tokens
  - 'Glob patterns: ensure ''*'' matches path segments correctly (not crossing ''/'' boundaries unless intended)'
  - Use constant-time comparison for all token and secret validation to prevent timing attacks
  - Root token should be used only for initial setup then revoked; operating with root token is a security anti-pattern
  - TLS certificate auth must verify full chain, not just that any certificate was presented
  concepts:
  - Identity-based authentication (external identity → internal token)
  - Path-based access control lists with glob matching
  - Token lifecycle (creation, renewal, expiration, revocation)
  - AppRole two-factor authentication pattern
  - Default-deny policy evaluation
  skills:
  - Authentication method implementation
  - Path-based ACL design
  - Token lifecycle management
  - Policy evaluation engine
  deliverables:
  - Token authentication with creation, validation, renewal, and revocation
  - AppRole auth method mapping role_id + secret_id to vault token
  - Path-based ACL policy definition with glob wildcards and capability specification
  - Policy evaluation engine checking token's attached policies against request path and capability
  - Token TTL enforcement with renewal up to max-TTL
  - Authentication and authorization audit logging
  estimated_hours: 12-16
- id: secret-management-m3
  name: Dynamic Secrets & Lease Management
  description: Generate short-lived credentials on-demand for databases with TTL-based lease lifecycle including creation, renewal, and revocation.
  acceptance_criteria:
  - 'Dynamic secret backend for at least one database (e.g., PostgreSQL): creates unique database user with specific privileges on each request'
  - Generated credentials have a configurable TTL (default 1 hour) and max-TTL (default 24 hours)
  - Each credential issuance creates a lease with a unique lease_id returned to the client
  - Lease renewal API extends credential TTL up to max-TTL; renewal beyond max-TTL is denied
  - Lease revocation API immediately drops the database user/role and invalidates the credential
  - 'Automatic lease expiry: background reaper process revokes credentials when TTL expires'
  - Lease reaper handles revocation failures with exponential backoff retry and alerting
  - 'Credential template system: configure SQL statements for user creation, privilege grant, and revocation per role'
  - Connection to backend database uses a long-lived privileged connection (not per-request)
  - Maximum concurrent leases per role is configurable to prevent resource exhaustion
  - All credential generation, renewal, and revocation events are audit logged
  pitfalls:
  - Lease reaper must handle database connection failures gracefully; orphaned DB users are a security risk
  - Max-TTL must be enforced even for renewals; infinite renewal defeats the purpose of dynamic secrets
  - Don't create a new DB connection for every credential request; use connection pooling for the backend
  - Database user creation SQL must be parameterized to prevent SQL injection in usernames
  - Revocation failure must trigger alerts; silent failure leaves orphaned privileged accounts
  - Concurrent lease limit prevents a single misconfigured application from exhausting DB connections
  concepts:
  - Lease-based credential lifecycle (creation → renewal → revocation/expiry)
  - Dynamic credential generation and cleanup
  - Background lease reaping with failure handling
  - Connection pooling for backend systems
  skills:
  - Database user/role management via SQL
  - TTL and lease lifecycle implementation
  - Background task scheduling with retry logic
  - Connection pool management
  deliverables:
  - Dynamic secret backend generating unique database credentials per request
  - Lease manager tracking all active leases with lease_id, TTL, and max-TTL
  - Lease renewal API extending credential TTL within max-TTL bounds
  - Lease revocation API immediately dropping database user and invalidating credential
  - Background lease reaper revoking expired credentials with retry on failure
  - Credential template system for configurable user creation and revocation SQL
  - Audit logging for all credential lifecycle events
  estimated_hours: 12-16
- id: secret-management-m4
  name: Audit Logging & High Availability
  description: Implement comprehensive tamper-evident audit logging for all vault operations and high-availability with leader election.
  acceptance_criteria:
  - 'Log every vault operation: secret read, write, delete, list, auth, lease create/renew/revoke, policy change, seal/unseal'
  - 'Audit log entries include: timestamp, request_id, client_token_accessor (not the token itself), path, operation, response_status, remote_addr'
  - Audit logs are append-only; storage backend prevents modification or deletion of existing entries
  - Audit log entries include HMAC of sensitive fields (path, accessor) using a vault-managed key for verification without exposing raw values
  - 'At least one audit backend must be enabled for the vault to process requests (fail-safe: if audit write fails, reject the operation)'
  - Support file-based audit backend with log rotation and configurable retention period
  - 'High availability: multiple vault instances with leader election via existing Raft library (e.g., hashicorp/raft, etcd/raft)'
  - Only the leader handles write operations; standby nodes forward writes to leader
  - Standby nodes serve read operations from replicated storage
  - Automatic leader election on leader failure with configurable election timeout
  - All vault instances share the same encrypted storage backend (replicated via Raft log)
  - 'Auto-unseal option: integrate with external KMS (or simulated KMS) to unseal without Shamir shares'
  pitfalls:
  - NEVER log raw tokens or secret values in audit logs; use HMAC'd values or accessors
  - Fail-open audit (continue if audit write fails) is a compliance violation; fail-closed is safer
  - Implementing Raft from scratch is a separate expert project; use an existing library
  - Only ONE node should be active writer (leader) to prevent split-brain and data corruption
  - Auto-unseal trades Shamir's security model for operational convenience; document the tradeoff
  - Audit log volume can be enormous; implement rotation and archival without losing integrity chain
  concepts:
  - Tamper-evident audit logging with HMAC integrity
  - Fail-closed audit enforcement
  - Raft consensus for leader election and log replication
  - Auto-unseal with external KMS
  - Split-brain prevention
  skills:
  - Append-only audit log implementation
  - HMAC-based field integrity
  - Raft library integration for HA
  - Leader election and write forwarding
  deliverables:
  - Comprehensive audit logger recording all vault operations with required fields
  - HMAC integrity protection for sensitive audit log fields
  - Fail-closed audit enforcement rejecting operations if audit write fails
  - File-based audit backend with log rotation
  - HA cluster using Raft library for leader election and storage replication
  - Write forwarding from standby to leader node
  - Auto-unseal integration with external KMS
  estimated_hours: 14-18
domain: security
