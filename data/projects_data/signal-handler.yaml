id: signal-handler
name: Signal Handler
description: 'POSIX signal handling: sigaction, signal masks, self-pipe trick, async-signal safety'
difficulty: intermediate
estimated_hours: 10-14
essence: 'Asynchronous interrupt handling with async-signal-safe constraints, signal masking for atomic critical sections, volatile sig_atomic_t for handler-to-main communication, and integration of OS-level signals into event loops using the self-pipe trick.

  '
why_important: 'Building this teaches systems programming fundamentals essential for reliable servers, daemons, and CLI tools, addressing real-world challenges like graceful shutdown, preventing race conditions in multi-signal scenarios, and correctly handling interrupts without corrupting program state.

  '
learning_outcomes:
- Implement signal handlers using sigaction with strict async-signal-safe constraints
- Use volatile sig_atomic_t for safe communication between handler and main code
- Design critical sections protected by signal masks using sigprocmask
- Build the self-pipe trick to integrate signals into select/poll event loops
- Handle EINTR for interrupted system calls both via SA_RESTART and manual retry
- Implement graceful shutdown sequences with SIGTERM and SIGINT
- Debug race conditions arising from signal delivery during system calls
skills:
- Signal masking (sigprocmask)
- Async-signal safety
- Self-pipe pattern
- Event loop integration
- Graceful shutdown
- Race condition handling
- POSIX signal API (sigaction)
- volatile sig_atomic_t
tags:
- async-signal-safe
- c
- intermediate
- masks
- rust
- sigint
- sigterm
- systems
architecture_doc: architecture-docs/signal-handler/index.md
languages:
  recommended:
  - C
  - Rust
  also_possible:
  - Go
  - Python
resources:
- name: signal(7) man page
  url: https://man7.org/linux/man-pages/man7/signal.7.html
  type: documentation
- name: Signal Safety (signal-safety(7))
  url: https://man7.org/linux/man-pages/man7/signal-safety.7.html
  type: documentation
- name: The Self-Pipe Trick""
  url: https://cr.yp.to/docs/selfpipe.html
  type: article
prerequisites:
- type: skill
  name: C programming (functions, pointers, structs)
- type: skill
  name: Unix basics (processes, file descriptors)
- type: skill
  name: Process concepts (fork, exec, wait)
milestones:
- id: signal-handler-m1
  name: Signal Handlers with Async-Signal Safety
  description: 'Install signal handlers for SIGINT, SIGTERM, and SIGHUP using sigaction(). Strictly enforce async-signal-safe constraints inside handlers. Use volatile sig_atomic_t for handler-to-main communication.

    '
  acceptance_criteria:
  - Install handlers for SIGINT (Ctrl+C), SIGTERM (kill), and SIGHUP (terminal hangup) using sigaction(), NOT the deprecated signal() function
  - Signal handlers use ONLY async-signal-safe functions (write(), _exit(), sig_atomic_t assignment); explicitly do NOT call printf(), malloc(), free(), or any non-safe function inside the handler
  - Handler sets a volatile sig_atomic_t flag variable; main loop checks the flag and performs the actual work (logging, cleanup) outside the handler context
  - Set SA_RESTART flag on sigaction so that interrupted blocking system calls (read, write, accept) restart automatically instead of failing with EINTR
  - 'Additionally, handle EINTR manually for system calls that SA_RESTART does not cover (e.g., select, poll, epoll_wait on some systems): if a call returns -1 with errno==EINTR, retry the call'
  - 'Demonstrate correct behavior: send SIGINT via Ctrl+C during a blocking read(); the program prints a message (from main loop, not handler) and exits gracefully'
  - Original signal dispositions are saved during handler installation and restored during cleanup
  pitfalls:
  - Calling printf() inside a signal handler deadlocks if the main code is also inside printf (both acquire the same stdio lock)
  - Calling malloc() inside a signal handler corrupts the heap if the handler interrupts malloc in the main code
  - Forgetting volatile on sig_atomic_t allows the compiler to optimize away the flag check in the main loop (flag read is cached in a register)
  - 'SA_RESTART doesn''t cover all system calls: select(), poll(), and sleep() are typically NOT restarted; must handle EINTR for these'
  - 'Using signal() instead of sigaction() gives unreliable semantics: on some systems the handler is reset to SIG_DFL after the first delivery'
  concepts:
  - sigaction() vs signal()
  - Async-signal-safe function list (signal-safety(7))
  - volatile sig_atomic_t for flag-based communication
  - SA_RESTART and EINTR handling
  skills:
  - Signal handler installation with sigaction
  - Async-signal-safe programming discipline
  - volatile sig_atomic_t usage
  - EINTR retry logic
  deliverables:
  - sigaction-based handler installation for SIGINT, SIGTERM, SIGHUP
  - Async-signal-safe handler bodies (only write() and flag assignment)
  - volatile sig_atomic_t flag checked in main loop
  - SA_RESTART configuration with manual EINTR retry for uncovered calls
  - Signal disposition save and restore
  - Demo program showing graceful Ctrl+C handling
  estimated_hours: 3-4
- id: signal-handler-m2
  name: Signal Masking & Critical Sections
  description: 'Use sigprocmask() to block signals during critical code sections, inspect pending signals, and understand signal delivery ordering.

    '
  acceptance_criteria:
  - Block specific signals during critical sections using sigprocmask(SIG_BLOCK, &mask, &oldmask) and restore with sigprocmask(SIG_SETMASK, &oldmask, NULL)
  - Demonstrate that signals delivered during a blocked period become pending and are delivered immediately when the mask is removed
  - Inspect pending signals using sigpending() and display which signals are queued
  - Demonstrate that multiple instances of the same signal pending are coalesced into one delivery (standard signals are not queued)
  - 'Nested critical sections save and restore masks correctly: blocking SIGINT inside a section that already blocks SIGTERM preserves the SIGTERM block on exit'
  - sigprocmask is used (not pthread_sigmask) since this milestone focuses on single-threaded programs; note the distinction for multi-threaded use
  pitfalls:
  - Forgetting to restore the old mask after a critical section leaves signals permanently blocked, causing the program to ignore subsequent signals
  - 'Standard signals coalesce: if SIGINT is delivered 5 times while blocked, only one SIGINT is delivered when unblocked; this surprises students expecting a queue'
  - Using SIG_UNBLOCK instead of SIG_SETMASK to restore can accidentally unblock signals that were blocked by an outer critical section
  - Blocking SIGKILL or SIGSTOP is silently ignored by the kernel; students must understand these signals cannot be caught or blocked
  concepts:
  - Signal sets and sigprocmask
  - Signal pending vs delivered states
  - Signal coalescing for standard signals
  - Nested critical section mask management
  skills:
  - Signal set manipulation (sigemptyset, sigaddset, sigfillset)
  - Critical section protection with signal masks
  - Pending signal inspection with sigpending
  - Correct mask save/restore with SIG_SETMASK
  deliverables:
  - Critical section guard using sigprocmask SIG_BLOCK and SIG_SETMASK restore
  - Pending signal inspection using sigpending()
  - Demonstration of signal coalescing behavior
  - Nested mask management preserving outer block sets
  estimated_hours: 2-3
- id: signal-handler-m3
  name: Self-Pipe Trick & Event Loop Integration
  description: 'Implement the self-pipe trick to safely integrate signal handling into a select/poll-based event loop, allowing signals to be processed synchronously in the main loop context.

    '
  acceptance_criteria:
  - Create a pipe with both ends set to non-blocking mode (O_NONBLOCK via fcntl) and set FD_CLOEXEC on both ends
  - Signal handler writes a single byte (the signal number) to the pipe write end; handle EAGAIN gracefully (pipe full means signal is already pending in the pipe)
  - Main event loop monitors the pipe read end alongside other I/O file descriptors using select() or poll()
  - When the pipe becomes readable, the main loop reads all available bytes (draining the pipe) and dispatches the appropriate signal handling logic in the main context (where printf, malloc, etc. are safe)
  - 'Demonstrate multiplexed I/O: event loop simultaneously monitors the signal pipe AND a network socket (or stdin), handling whichever becomes ready first'
  - Multiple signals of different types (e.g., SIGINT and SIGHUP arriving nearly simultaneously) are both delivered via the pipe and both handled in the main loop
  - Mention signalfd() (Linux-specific) and sigwait() as alternative approaches with their trade-offs
  pitfalls:
  - Pipe write end must be non-blocking; a blocking write in a signal handler can deadlock the entire process if the pipe buffer is full
  - 'Not draining the pipe fully on read: if multiple signal bytes accumulate, reading only one byte per loop iteration delays handling'
  - 'Signal coalescing still applies: if SIGINT is delivered twice before the pipe is read, two bytes are written, but the underlying signal was only delivered once; the pipe provides more information than the signal itself'
  - Setting FD_CLOEXEC prevents the pipe from leaking to child processes spawned via fork/exec
  - select() returns EINTR when a signal arrives during the call (even with SA_RESTART, select is often not restarted); must handle this
  concepts:
  - Self-pipe trick pattern
  - Non-blocking pipe I/O
  - Event loop integration with I/O multiplexing
  - Synchronous signal processing in main context
  - signalfd() and sigwait() alternatives
  skills:
  - Non-blocking I/O with pipes
  - select()/poll() event loop
  - Signal-safe IPC via pipe
  - Multiplexed I/O handling
  deliverables:
  - Non-blocking pipe pair with FD_CLOEXEC for signal notification
  - Signal handler writing signal number byte to pipe (with EAGAIN handling)
  - Event loop monitoring signal pipe + other FDs with select/poll
  - Pipe drain logic reading all available bytes per wakeup
  - Demo: multiplexed handling of signals and stdin/socket I/O
  - Documentation of signalfd/sigwait alternatives with trade-offs
  estimated_hours: 3-5
domain: systems
