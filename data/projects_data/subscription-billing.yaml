id: subscription-billing
name: Subscription Billing
description: >-
  Recurring payment lifecycle management with plan pricing, proration,
  usage metering, invoicing, tax calculation, and dunning for failed payments.
difficulty: expert
estimated_hours: 65
essence: >-
  Recurring payment lifecycle management with prorated billing calculations,
  idempotent transaction processing, high-throughput usage metering, invoice
  generation with tax computation, and dunning workflows that retry failed
  charges with escalating customer notifications to minimize involuntary churn.
why_important: >-
  Building this teaches production payment processing patterns used by major
  SaaS platforms, including handling money reliably at scale, implementing
  complex business logic for pricing changes, generating legally compliant
  invoices, and designing fault-tolerant systems where financial accuracy
  is non-negotiable.
learning_outcomes:
  - Implement idempotent webhook handlers with deduplication and retry logic for payment events
  - Design prorated billing calculations for mid-cycle plan upgrades and downgrades with credit handling
  - Build high-throughput usage metering with event batching, aggregation, and time-series storage
  - Implement subscription state machines handling trials, renewals, cancellations, and dunning workflows
  - Build invoice generation systems with line-item calculations, tax handling, and PDF rendering
  - Implement dunning management with configurable retry schedules and customer notification escalation
  - Design flexible pricing engines supporting tiered, per-seat, usage-based, and hybrid billing models
  - Handle tax calculation for different jurisdictions with tax rate lookups and exemption handling
skills:
  - Payment Gateway Integration
  - Idempotency Patterns
  - Webhook Processing
  - Prorated Billing Calculations
  - Usage Metering & Aggregation
  - State Machine Design
  - Invoice Generation
  - Dunning Management
  - Tax Calculation
  - Time-Series Data Storage
tags:
  - billing
  - expert
  - fintech
  - invoices
  - metering
  - payments
  - recurring
  - saas
  - subscriptions
  - dunning
  - tax
architecture_doc: architecture-docs/subscription-billing/index.md
languages:
  recommended:
    - Python
    - Go
    - Java
  also_possible: []
resources:
  - name: Stripe Billing Documentation
    url: https://docs.stripe.com/billing
    type: documentation
  - name: Designing Robust APIs with Idempotency
    url: https://stripe.com/blog/idempotency
    type: article
  - name: Building Usage-Based Billing Systems
    url: https://www.getlago.com/blog/usage-based-billing-system
    type: article
  - name: Payment Webhook Reliability Guide
    url: https://medium.com/@sohail_saifii/handling-payment-webhooks-reliably-idempotency-retries-validation-69b762720bf5
    type: tutorial
  - name: PCI Compliance Guide
    url: https://stripe.com/guides/pci-compliance
    type: documentation
  - name: Lago Open Source Billing
    url: https://github.com/getlago/lago
    type: tool
prerequisites:
  - type: project
    id: payment-gateway
  - type: skill
    name: Database transactions and modeling
milestones:
  - id: subscription-billing-m1
    name: Plans & Pricing Engine
    description: >-
      Implement flexible pricing plans with tiers, features, currencies,
      and trial periods.
    acceptance_criteria:
      - "Plans are defined with a unique ID, name, billing interval (monthly/yearly), currency, and base price in smallest currency unit (cents)"
      - "Multiple pricing models are supported - flat-rate, per-seat, tiered (each tier charged separately), and volume (single rate based on total)"
      - "Plan versioning ensures existing subscribers retain their original plan terms when a plan is updated; old plan versions are archived, not deleted"
      - "Trial periods are configurable per plan with a duration in days and automatic conversion to paid at expiry"
      - "Feature entitlement matrix maps each plan to a set of feature flags that control access"
      - "Plans support multiple currencies with amounts stored as integers in the smallest unit of each currency"
      - "Creating a plan with the same ID as an archived plan returns an error; plan IDs are globally unique"
    pitfalls:
      - "Tiered vs Volume pricing is a common source of bugs - tiered charges each bracket separately while volume applies a single rate to all units based on total quantity"
      - "Currency precision must always use smallest unit (cents, pence) as integers - never use floating-point for money"
      - "Deleting a plan breaks existing subscriptions - always archive and keep the plan definition immutable for active subscribers"
      - "Feature access must check plan entitlements, not subscription status alone - an active subscription on a basic plan should not access premium features"
      - "Zero-amount plans (free tier) must still create proper subscription records for consistent lifecycle management"
    concepts:
      - Recurring billing models (flat-rate, per-seat, tiered, volume-based)
      - Feature entitlements and access control lists
      - Multi-currency handling with smallest-unit integer storage
      - Plan versioning and grandfathering existing customers
      - Trial period lifecycle and conversion triggers
    skills:
      - Pricing model design
      - Feature flags
      - Multi-currency
      - Plan versioning
    deliverables:
      - Plan definition schema with ID, name, interval, currency, price, and feature list
      - Pricing tier configuration supporting flat-rate, per-unit, tiered, and volume models
      - Feature entitlement matrix mapping plan tiers to accessible feature flags
      - Plan management API for creating, updating (as new version), and archiving plans
      - Trial period configuration with duration and auto-conversion flag
    estimated_hours: 10

  - id: subscription-billing-m2
    name: Subscription Lifecycle
    description: >-
      Implement subscription creation, activation, renewal, cancellation,
      pause/resume with a strict state machine.
    acceptance_criteria:
      - "Subscription creation associates a customer, plan version, payment method, and billing anchor date; status starts as 'trialing' (if trial) or 'active'"
      - "Subscription state machine enforces valid transitions - trialing->active, active->past_due, active->cancelled, past_due->active, past_due->unpaid, paused->active"
      - "Trial expiration triggers automatic transition to 'active' and schedules the first charge"
      - "Cancellation supports both 'immediate' (terminates now) and 'at_period_end' (terminates at cycle boundary) modes, recording cancellation reason"
      - "Pause freezes billing and access; resume reactivates with prorated billing adjustment from the resume date"
      - "Billing anchor date ensures consistent billing on the same day each month; month overflow is handled (Jan 31 -> Feb 28, not Mar 3)"
      - "Renewal processing generates a charge at each billing cycle boundary and transitions to 'past_due' on payment failure"
      - "Each subscription has a unique idempotency key for creation to prevent duplicate subscriptions from retried requests"
    pitfalls:
      - "Billing anchor date must handle month-length variations correctly (Jan 31 + 1 month = Feb 28)"
      - "'past_due' means payment retry is still in progress; 'unpaid' means all retries exhausted - these are distinct states with different customer experiences"
      - "Cancel at period end is the most user-friendly option since the customer already paid for the period"
      - "Reactivation after cancellation must check whether the original plan version is still available"
      - "Concurrent subscription creation for the same customer+plan must be prevented via unique constraint or distributed lock"
    concepts:
      - Subscription state machine transitions and valid state flows
      - Billing cycle calculation and anniversary date handling
      - Month overflow handling in date arithmetic
      - Cancellation timing (immediate vs end-of-period)
      - Idempotent subscription creation
    skills:
      - State machines
      - Billing cycles
      - Date arithmetic
      - Idempotency
    deliverables:
      - Subscription creation service with customer, plan, payment method, and anchor date
      - State machine enforcing valid transitions with rejection of invalid state changes
      - Trial expiration handler that transitions to active and triggers first charge
      - Cancellation handler supporting immediate and end-of-period modes
      - Pause and resume handlers with billing adjustment
      - Renewal scheduler that triggers charge at each billing cycle boundary
    estimated_hours: 10

  - id: subscription-billing-m3
    name: Invoicing & Tax Calculation
    description: >-
      Implement invoice generation with line items, tax calculation,
      and PDF rendering for each billing event.
    acceptance_criteria:
      - "Each billing cycle generates an invoice with line items showing description, quantity, unit price, and total for each charge"
      - "Tax is calculated per line item based on the customer's jurisdiction, with tax rate looked up from a configurable tax rate table"
      - "Tax-exempt customers are flagged and their invoices show zero tax with an exemption reason"
      - "Invoice total equals the sum of all line items plus applicable taxes minus any credits applied"
      - "Invoices are numbered sequentially with no gaps for compliance (e.g., INV-2024-00001)"
      - "Invoice PDF is rendered with business details, customer details, line items, tax breakdown, and total"
      - "Invoices are immutable after finalization; corrections require a credit note referencing the original invoice"
      - "Prorated charges from plan changes appear as separate line items on the next invoice"
    pitfalls:
      - "Invoice numbers must be sequential and gap-free in many jurisdictions - using database auto-increment with transaction rollbacks can create gaps"
      - "Tax rates vary by jurisdiction, product type, and customer type - hardcoding rates is a compliance time bomb"
      - "Rounding taxes per line item vs on the invoice total gives different results - choose one method and be consistent"
      - "Credit notes must reference the original invoice for audit trail compliance"
      - "Invoice finalization must be atomic - a partially generated invoice is worse than no invoice"
    concepts:
      - Invoice line item structure with amount, description, and tax
      - Tax rate lookup by jurisdiction and product category
      - Sequential invoice numbering for legal compliance
      - Credit note pattern for invoice corrections
      - PDF generation from structured invoice data
    skills:
      - Invoice generation
      - Tax calculation
      - PDF rendering
      - Financial compliance
    deliverables:
      - Invoice generation engine creating line-item invoices at each billing cycle
      - Tax calculation module with configurable rates per jurisdiction and product type
      - Tax exemption handling for flagged customers
      - Credit application service deducting customer credits from invoice totals
      - Sequential invoice numbering with gap-free guarantee
      - PDF invoice renderer with business, customer, line item, and tax details
      - Credit note generator for correcting finalized invoices
    estimated_hours: 12

  - id: subscription-billing-m4
    name: Proration & Plan Changes
    description: >-
      Implement upgrade/downgrade with prorated charges and credits,
      generating correct invoice line items.
    acceptance_criteria:
      - "Upgrade calculates a prorated charge for the remaining days in the current cycle at the new plan's rate minus credit for unused time on the old plan"
      - "Downgrade calculates a credit for unused time on the higher-tier plan, applied to the customer's balance for the next invoice"
      - "Proration formula uses (days_remaining / total_days_in_period) * plan_price, with amounts rounded to the nearest cent using banker's rounding"
      - "Immediate plan change takes effect now and generates a prorated invoice line item; end-of-cycle change is scheduled and takes effect at next renewal"
      - "Quantity changes (e.g., adding seats) are prorated the same way as plan changes"
      - "Credits are tracked in a customer credit balance and automatically applied to the next invoice before charging the payment method"
      - "All proration line items appear on the next invoice with clear descriptions (e.g., 'Unused time on Pro plan: -$15.00')"
    pitfalls:
      - "Proration direction matters - upgrade charges extra, downgrade credits; getting this backwards is a revenue-critical bug"
      - "Small rounding errors accumulate over thousands of customers - use banker's rounding (round half to even) consistently"
      - "Credits must be applied automatically on the next invoice; forgotten credits lead to customer complaints and churn"
      - "Quantity changes (adding/removing seats) are proration events too, not just plan tier changes"
      - "Multiple plan changes within a single billing period must each be prorated correctly relative to their effective date"
    concepts:
      - Proration formulas for time-based and quantity-based changes
      - Credit balance management and application order (credits before payment method)
      - Invoice line items for prorated upgrades and downgrades
      - Immediate vs scheduled plan change execution
      - "Banker's rounding for financial calculations"
    skills:
      - Proration calculation
      - Credit management
      - Mid-cycle billing changes
      - Financial rounding
    deliverables:
      - Proration calculation engine computing partial charges for mid-cycle changes
      - Upgrade handler charging prorated difference for remaining period
      - Downgrade handler crediting unused time to customer balance
      - Credit balance ledger tracking credits and their application to invoices
      - Quantity change proration for seat-based plan modifications
      - Scheduled plan change system for end-of-cycle transitions
    estimated_hours: 10

  - id: subscription-billing-m5
    name: Dunning Management
    description: >-
      Implement failed payment retry logic with exponential backoff,
      customer notifications, and grace period enforcement.
    acceptance_criteria:
      - "Failed initial charge transitions subscription to 'past_due' and schedules the first retry"
      - "Retry schedule is configurable (e.g., retry at 1, 3, 5, 7 days after failure) with a maximum of N attempts"
      - "Each retry attempt is logged with the failure reason (declined, insufficient funds, expired card, etc.)"
      - "Customer is notified via email/webhook at each stage - payment failed, retry scheduled, final warning, subscription cancelled"
      - "After all retries are exhausted, subscription transitions to 'unpaid' and optionally to 'cancelled' based on configuration"
      - "Grace period allows customer access during 'past_due' status for a configurable number of days"
      - "Customer can update their payment method while in 'past_due' status, triggering an immediate retry"
      - "Smart retry logic avoids retrying at times known to have low success rates (e.g., weekends for business cards)"
    pitfalls:
      - "Retrying too aggressively increases card network decline rates and can get your merchant account flagged"
      - "Not distinguishing between soft declines (insufficient funds - retry later) and hard declines (card stolen - stop retrying) wastes retry attempts"
      - "Customer notifications must be clear and actionable with a direct link to update payment method"
      - "Grace period access without payment creates revenue leakage if the period is too long"
      - "Payment method update during dunning must trigger immediate retry, not wait for the next scheduled retry"
    concepts:
      - Dunning workflow with configurable retry schedule
      - Soft vs hard decline classification from payment provider response codes
      - Customer notification escalation (email, in-app, SMS)
      - Grace period policy for continued access during payment failure
      - Smart retry timing based on decline reason and historical success patterns
    skills:
      - Dunning workflows
      - Retry scheduling
      - Customer notification
      - Payment failure classification
    deliverables:
      - Dunning state machine managing retry schedule from first failure to resolution
      - Configurable retry schedule with per-attempt delay and maximum attempt count
      - Decline reason classifier distinguishing soft (retriable) from hard (terminal) declines
      - Customer notification system sending emails at each dunning stage
      - Payment method update handler triggering immediate retry on update
      - Grace period enforcer controlling access during past_due status
    estimated_hours: 10

  - id: subscription-billing-m6
    name: Usage-Based Billing
    description: >-
      Implement metered billing with idempotent usage event ingestion,
      time-series aggregation, and overage charge calculation.
    acceptance_criteria:
      - "Usage events are ingested via API with a client-provided idempotency key; duplicate events with the same key are silently deduplicated"
      - "Events include subscription ID, metric name, quantity, and server-assigned timestamp (client timestamps are ignored)"
      - "Usage is aggregated per subscription per billing period with correct period boundary alignment"
      - "Aggregation supports sum, count, max, and last-value modes configurable per metric"
      - "Charges are calculated based on usage tiers with correct bracket application"
      - "Overage beyond plan allowance is charged at the configured per-unit overage rate"
      - "Usage summary appears as line items on the period-end invoice"
      - "Usage approaching plan limits triggers an alert at 80% and 100% thresholds"
    pitfalls:
      - "Same event reported twice must not be double-counted - idempotency keys are mandatory for correctness"
      - "Always use server timestamps for billing purposes - client clocks cannot be trusted"
      - "Aggregation type matters enormously - sum vs max gives very different bills for the same usage pattern"
      - "Usage limits should alert before hitting the limit (80% threshold), not after - customers hate surprise overages"
      - "Period boundary alignment must match the subscription's billing anchor date, not calendar month boundaries"
    concepts:
      - Event-based metering with deduplication via idempotency keys
      - Time-series aggregation (sum, count, max, last-value)
      - Usage reporting windows aligned to billing period boundaries
      - Tiered usage pricing with bracket calculation
      - Threshold-based alerting for usage limits
    skills:
      - Usage metering
      - Time-series aggregation
      - Idempotent event ingestion
      - Threshold alerting
    deliverables:
      - Usage event ingestion API with idempotency key deduplication
      - Server-side timestamp assignment for all usage events
      - Usage aggregation engine with configurable aggregation modes per metric
      - Tiered usage charge calculator applying bracket rates
      - Overage charge calculator for usage beyond plan allowance
      - Usage threshold alerting at configurable percentage limits
      - Invoice line item generation from aggregated usage data
    estimated_hours: 13