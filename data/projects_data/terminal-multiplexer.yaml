id: terminal-multiplexer
name: Terminal Multiplexer
description: tmux-like terminal manager with session persistence
difficulty: advanced
estimated_hours: 40-55
essence: 'Pseudo-terminal (PTY) lifecycle management, VT100/ANSI escape sequence parsing through state machines, multiplexed I/O between PTY pairs, tiled window layout management, and a client-server architecture with Unix domain socket communication for session persistence across terminal disconnects.

  '
why_important: 'Building a terminal multiplexer exposes you to low-level Unix process control, PTY device programming, stateful parsing, and client-server IPC—critical skills for systems programming and understanding how tmux/screen work internally.

  '
learning_outcomes:
- Implement PTY creation using posix_openpt, grantpt, unlockpt
- Design a state machine parser for VT100/ANSI escape sequences
- Build async I/O multiplexing using poll/epoll for multiple PTY pairs
- Implement window splitting and layout management
- Handle SIGWINCH and propagate terminal dimensions
- Implement client-server architecture for session detach/attach
- Manage bidirectional data flow between PTY master/slave pairs
skills:
- PTY/TTY Programming
- ANSI Escape Sequence Parsing
- Process Session Management
- Asynchronous I/O Multiplexing
- Signal Handling
- Unix Domain Sockets
- State Machine Design
- Client-Server Architecture
tags:
- advanced
- c
- go
- panes
- pty
- rust
- sessions
- terminal
- tmux
architecture_doc: architecture-docs/terminal-multiplexer/index.md
languages:
  recommended:
  - C
  - Rust
  - Go
  also_possible:
  - Python
resources:
- name: PTY Programming
  url: https://www.man7.org/linux/man-pages/man7/pty.7.html
  type: reference
- name: ANSI Escape Codes
  url: https://en.wikipedia.org/wiki/ANSI_escape_code
  type: reference
- name: Building a Terminal Emulator
  url: https://www.uninformativ.de/blog/postings/2018-02-24/0/POSTING-en.html
  type: tutorial
- name: Paul Williams' VT500 State Machine
  url: https://vt100.net/emu/dec_ansi_parser
  type: reference
prerequisites:
- type: skill
  name: Unix processes (fork, exec, signals)
- type: skill
  name: Terminal basics (raw mode, termios)
- type: skill
  name: File descriptors and I/O multiplexing
milestones:
- id: terminal-multiplexer-m1
  name: PTY Management and Shell Spawning
  description: Create PTY pairs, fork child processes, and run shells connected to slave PTY devices.
  estimated_hours: 6-8
  concepts:
  - Pseudo-terminals (master/slave pairs)
  - Process groups and session leaders
  - Controlling terminals
  skills:
  - System call programming (posix_openpt, grantpt, unlockpt, fork, setsid)
  - File descriptor management across fork
  - Signal handling (SIGCHLD)
  - Terminal attribute configuration (termios)
  acceptance_criteria:
  - Open PTY master/slave pair using posix_openpt + grantpt + unlockpt (or openpty helper)
  - 'Fork child process; in child: call setsid() to create new session, open slave PTY to make it the controlling terminal, close master fd, dup2 slave to stdin/stdout/stderr, exec shell'
  - 'In parent: close slave fd, read from master to get shell output, write to master to send input'
  - Set the parent terminal to raw mode (disable echo, canonical mode, signal generation) using tcgetattr/tcsetattr
  - Forward keyboard input from parent stdin to PTY master; forward PTY master output to parent stdout
  - Handle SIGCHLD to detect child shell exit and clean up PTY file descriptors
  - Set initial terminal size on slave PTY using TIOCSWINSZ ioctl before exec'ing the shell
  - 'On exit (normal or crash): restore the original terminal attributes using the saved termios struct'
  - Verify by running an interactive shell (bash/zsh) and confirming basic commands work (ls, cat, vim)
  pitfalls:
  - Must call setsid() in child before opening slave PTY, otherwise it won't become the controlling terminal
  - Forgetting to close the master fd in the child and slave fd in the parent leaks file descriptors
  - SIGCHLD must be handled or waited on to avoid zombie processes
  - If the program crashes without restoring terminal attributes, the terminal is left in raw mode (unusable); install signal handlers for SIGTERM/SIGSEGV that restore termios
  deliverables:
  - PTY pair allocation and child process spawning
  - Raw mode terminal configuration with save/restore
  - Bidirectional I/O forwarding between parent stdin/stdout and PTY master
  - SIGCHLD handling for child cleanup
  - Terminal attribute restoration on exit
- id: terminal-multiplexer-m2
  name: Terminal Emulation (VT100 Subset)
  description: Parse ANSI escape sequences and maintain a virtual screen buffer.
  estimated_hours: 8-10
  concepts:
  - VT100/ANSI escape sequence state machine
  - CSI (Control Sequence Introducer) parsing
  - Virtual screen buffer (cells with attributes)
  skills:
  - State machine implementation
  - Escape sequence parsing
  - Screen buffer management
  - UTF-8 decoding
  acceptance_criteria:
  - 'Implement a state machine parser based on Paul Williams'' VT500 parser model with states: Ground, Escape, CSI Entry, CSI Param, CSI Intermediate, CSI Dispatch, OSC String'
  - 'Handle cursor movement sequences: CUU (up), CUD (down), CUF (forward), CUB (back), CUP (absolute position), HVP'
  - 'Handle erase sequences: ED (erase display), EL (erase line) with mode parameters (0=to-end, 1=to-start, 2=all)'
  - 'Handle SGR (Select Graphic Rendition) for: reset, bold, dim, underline, blink, reverse, 8-color foreground/background, 256-color, and 24-bit RGB color'
  - Handle cursor save/restore (DECSC/DECRC or CSI s/u)
  - Handle scroll region setting (DECSTBM) and scrolling within regions
  - Handle alternate screen buffer (DECSET 1049 / DECRST 1049) for applications like vim and less
  - Maintain a virtual screen buffer as a 2D array of cells; each cell stores a character (Unicode codepoint), foreground color, background color, and text attributes
  - Maintain a scrollback buffer of at least 1000 lines above the visible screen
  - Handle basic UTF-8 multi-byte character sequences (2-4 bytes)
  - 'Explicitly OUT OF SCOPE: Sixel graphics, mouse tracking, OSC clipboard, DCS sequences'
  - Verify by running vim, htop, and less in the terminal and confirming correct display
  pitfalls:
  - Many escape sequences have optional parameters with defaults; e.g., CSI H with no params means row 1, col 1
  - UTF-8 characters can span multiple bytes; a partial sequence at the end of a read() must be buffered
  - Some sequences are terminal-specific (xterm, vt100, vt220); focus on the most common subset
  - Wide characters (CJK) occupy 2 columns but 1 cell; proper handling requires wcwidth()
  deliverables:
  - VT500-based escape sequence state machine
  - CSI dispatch handler for cursor, erase, and SGR sequences
  - Virtual screen buffer with per-cell character and attribute storage
  - Scrollback buffer with configurable size
  - Alternate screen buffer support
  - UTF-8 multi-byte character handling
- id: terminal-multiplexer-m3
  name: Pane Splitting and Layout Management
  description: Support multiple panes with independent PTY sessions in a tiled layout.
  estimated_hours: 8-10
  concepts:
  - Binary tree layout (split containers)
  - PTY size management per pane
  - I/O multiplexing across multiple PTYs
  skills:
  - Layout algorithms (binary space partitioning)
  - I/O multiplexing (poll/epoll)
  - Terminal coordinate calculation
  - Input routing
  acceptance_criteria:
  - Implement vertical and horizontal splits creating new panes, each with its own PTY session and shell process
  - Represent layout as a binary tree where leaves are panes and internal nodes are split containers (vertical or horizontal)
  - Use poll/epoll to multiplex I/O across all PTY master file descriptors simultaneously
  - Route keyboard input to the focused pane only; all other panes continue to receive output
  - When a pane is resized (due to split or terminal resize), update its PTY dimensions via TIOCSWINSZ
  - 'Handle SIGWINCH on the parent terminal: recalculate all pane dimensions and propagate new sizes to all PTY slaves'
  - Enforce minimum pane dimensions (4 columns × 2 rows); reject splits that would create panes below minimum
  - Draw single-line box-drawing character borders between panes
  - 'Known limitation: scrollback reflow on resize is not required; existing content may display incorrectly after resize. Document this.'
  - Support at least 4 simultaneous panes without performance degradation
  pitfalls:
  - Resizing a pane requires updating the PTY size AND re-rendering the screen buffer content; without scrollback reflow, long lines will wrap incorrectly
  - Border characters reduce the usable area; account for 1-character borders in layout calculations
  - Focus tracking must handle pane close (focus moves to sibling) and nested splits
  - I/O multiplexing must handle EAGAIN/EWOULDBLOCK on non-blocking reads
  deliverables:
  - Binary tree layout data structure for pane organization
  - Vertical and horizontal split operations
  - I/O multiplexing across all PTY file descriptors
  - SIGWINCH handler with cascading size propagation
  - Border rendering between panes
  - Input focus routing
- id: terminal-multiplexer-m4
  name: Key Bindings, Status Bar, and UI
  description: Add prefix-key command mode, key bindings, and status bar display.
  estimated_hours: 6-8
  concepts:
  - Prefix key / command mode
  - Key binding dispatch
  - Status bar rendering
  - Screen compositing
  skills:
  - Terminal mode configuration
  - Event-driven command parsing
  - Efficient screen rendering
  - Double-buffered output
  acceptance_criteria:
  - Implement a configurable prefix key (default Ctrl-b) that switches to command mode
  - 'In command mode, handle key bindings: ''"'' (horizontal split), ''%'' (vertical split), arrow keys (navigate panes), ''x'' (close pane), ''z'' (zoom/unzoom pane), ''d'' (detach)'
  - 'Render a status bar on the bottom line showing: session name, pane index, active pane title, and clock'
  - Composite all pane screen buffers plus borders plus status bar to the real terminal using efficient cursor movement (avoid full-screen redraws when only one pane changed)
  - 'Implement double-buffered rendering: compute the new frame in memory, then diff against previous frame and emit only changed characters to minimize flicker'
  - 'Restore terminal to normal mode on exit: reset raw mode, show cursor, clear alternate screen buffer'
  - Handle Ctrl-C in command mode without killing the multiplexer (intercept and ignore or send to pane)
  pitfalls:
  - Raw mode disables Ctrl-C, Ctrl-Z, Ctrl-D interpretation; must handle them explicitly
  - Full-screen redraws on every keystroke cause visible flicker; differential rendering is essential
  - Status bar consumes one row from the bottom, reducing available pane space
  - Prefix key must be passthrough-able (pressing prefix twice sends the prefix character to the active pane)
  deliverables:
  - Prefix key handler with command mode state machine
  - Key binding registry for pane management commands
  - Status bar renderer
  - Double-buffered differential screen rendering
  - Terminal state restoration on exit
- id: terminal-multiplexer-m5
  name: Session Persistence (Detach/Attach)
  description: Implement client-server architecture for session detach and reattach.
  estimated_hours: 8-10
  concepts:
  - Client-server architecture
  - Unix domain sockets
  - Session persistence
  - Daemon process
  skills:
  - Unix domain socket programming
  - Process daemonization
  - Protocol design for client-server communication
  - Session state management
  acceptance_criteria:
  - When first launched, fork a server (daemon) process that owns all PTY sessions and a client process that connects to it
  - Server listens on a Unix domain socket (e.g., /tmp/mux-<uid>/session-<name>.sock)
  - Client connects to server socket; server streams rendered screen content to client; client forwards keyboard input to server
  - '''d'' key in command mode (or closing the terminal) detaches the client; server continues running with all PTY sessions alive'
  - Running the multiplexer again with the same session name reattaches to the existing server; screen content is immediately re-rendered
  - List existing sessions with a '--list' command showing session name, creation time, and attached/detached status
  - Server exits when all panes are closed (all child shells have exited)
  - Handle multiple clients attaching to the same session simultaneously (all see the same content, all can type)
  - Clean up socket file when server exits; handle stale socket files from crashed servers
  pitfalls:
  - The server must NOT be a child of the client terminal; use double-fork or setsid to fully daemonize
  - When the client detaches, the server must continue handling PTY I/O; it must not block on the (now disconnected) client socket
  - The client-server protocol must handle screen size negotiation (client may have different terminal size than previous client)
  - Stale Unix domain socket files from crashed servers must be detected and cleaned up
  - File permissions on the socket must restrict access to the owning user (0700 on directory)
  deliverables:
  - Server daemon process owning PTY sessions
  - Unix domain socket listener for client connections
  - Client-server protocol for screen streaming and input forwarding
  - Detach command disconnecting client while server persists
  - Reattach command reconnecting to existing session
  - Session listing command
  - Socket cleanup and stale session handling
domain: specialized
