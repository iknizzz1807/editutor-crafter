id: tetris
name: Tetris
description: "Grid-based puzzle game implementing rotation, line clearing, and modern Tetris Guideline mechanics."
difficulty: beginner-intermediate
estimated_hours: "18-25"
essence: >
  Grid-based collision detection, matrix transformations for piece rotation
  with SRS (Super Rotation System) wall-kick lookup tables, 7-bag random
  piece generation for fairness, and real-time game state management covering
  falling pieces, lock delay, line clearing, scoring, and level progression.
why_important: >
  Tetris introduces fundamental game development patterns including
  fixed-timestep game loops, collision detection in constrained grids,
  state machines for game progression, and implementing behavior from a
  formal specification (Tetris Guideline)—all of which translate directly
  to more complex game systems and real-time applications.
learning_outcomes:
  - Implement grid-based collision detection for moving game pieces
  - Design rotation using SRS wall-kick lookup tables with per-piece offset data
  - Build a fixed-timestep game loop with frame-independent updates
  - Implement 7-bag randomization for fair piece distribution
  - Manage complex game state across spawning, falling, locking, clearing, and game-over
  - Implement efficient line-clearing algorithms with 2D array manipulation
  - Create DAS/ARR input handling for responsive repeated key movement
  - Debug timing-dependent behavior in real-time systems
  - Optimize render cycles to separate game logic from visual updates
skills:
  - Grid-based Collision Detection
  - Lookup-Table-Based Rotation (SRS)
  - Game Loop Architecture
  - State Machine Design
  - 2D Array Manipulation
  - Input Handling (DAS/ARR)
  - Frame-Independent Timing
  - Real-time Rendering
tags:
  - beginner-friendly
  - c#
  - collision
  - game-dev
  - game-loop
  - input-handling
  - javascript
  - python
  - sprites
architecture_doc: architecture-docs/tetris/index.md
languages:
  recommended:
    - JavaScript
    - Python
    - "C#"
  also_possible:
    - Rust
    - Go
    - C++
resources:
  - name: Tetris Guideline (Wiki)
    url: https://tetris.wiki/Tetris_Guideline
    type: specification
  - name: Tetris with JavaScript
    url: https://www.youtube.com/watch?v=rAUn1Lom6dw
    type: video
  - name: Coding Challenges Tetris
    url: https://codingchallenges.fyi/challenges/challenge-tetris/
    type: tutorial
  - name: SRS Wall Kick Data
    url: https://tetris.wiki/Super_Rotation_System
    type: specification
prerequisites:
  - type: skill
    name: Basic programming
  - type: skill
    name: 2D arrays
  - type: skill
    name: HTML5 Canvas or similar rendering target
milestones:
  - id: tetris-m1
    name: Board & Tetrominoes
    description: >
      Create the 10x20 game board data structure, define all seven standard
      tetromino shapes with their four rotation states, and render the
      empty grid to screen.
    acceptance_criteria:
      - "10-column by 20-row visible game board is initialized with all cells empty (plus 2-4 hidden rows above for spawning)"
      - "All 7 standard tetromino shapes (I, O, T, S, Z, J, L) are defined"
      - "Each piece stores all 4 rotation states as explicit 2D arrays (not computed at runtime)"
      - "Each shape has a distinct color matching Tetris Guideline color assignments"
      - "Board renders the empty grid with visible cell boundaries at a consistent cell size"
      - "Coordinate system is documented: origin position, x-right, y-down convention"
    pitfalls:
      - "Piece rotation states defined inconsistently across shapes (e.g., different pivot assumptions)"
      - "Board dimensions swapped (columns vs rows, width vs height)"
      - "Off-by-one in grid rendering causing misalignment between logical and visual grid"
      - "Forgetting hidden spawn rows above the visible 20-row playfield"
    concepts:
      - 2D arrays
      - Piece representation with rotation states
      - Grid rendering
    skills:
      - Grid-based rendering
      - Data structure design for game states
      - Coordinate system management
      - Shape representation in code
    deliverables:
      - Game board grid data structure: 10-column by 20+buffer-row playing field
      - "Tetromino shape definitions for all 7 piece types with 4 rotation states each"
      - "Color mapping table assigning Guideline-accurate colors to each tetromino type"
      - "Rendered empty grid displayed on screen with cell boundaries"
    estimated_hours: "2-3"

  - id: tetris-m2
    name: "Piece Spawning, Falling & Controls"
    description: >
      Implement 7-bag random piece generation, piece spawning at the top
      center, gravity-based falling, and player movement controls including
      soft drop, hard drop, and DAS/ARR key repeat.
    acceptance_criteria:
      - "7-bag randomization: all 7 pieces appear exactly once per bag before the next bag begins"
      - "Pieces spawn centered horizontally in the hidden rows above the visible playfield"
      - "Current piece falls automatically at a rate determined by the current level"
      - "Left/right arrow keys move piece one cell horizontally with DAS (Delayed Auto Shift) after initial delay"
      - "ARR (Auto Repeat Rate) controls the speed of continued movement when key is held"
      - "Down arrow accelerates fall speed (soft drop) and awards 1 point per cell dropped"
      - "Space bar performs hard drop: piece instantly moves to lowest valid position, locks, awards 2 points per cell"
      - "No piece can move outside board boundaries or into occupied cells (collision check before every move)"
      - "Next-piece preview displays at least the next piece in the queue"
    pitfalls:
      - "Naive random() instead of 7-bag produces unfair streaks (e.g., no I-piece for 30+ pieces)"
      - "Piece spawning at y=0 instead of hidden rows causes immediate visible pop-in"
      - "Hard drop not checking every intermediate row—piece teleports through occupied cells"
      - "DAS not implemented causes unresponsive repeated movement on key hold"
      - "Soft drop points not awarded or double-counted"
    concepts:
      - 7-bag randomization
      - Position validation
      - Input handling with DAS/ARR
      - Collision detection
    skills:
      - Game loop implementation
      - Keyboard input processing with repeat handling
      - Boundary collision detection
      - Timer-based movement
      - Randomization algorithm implementation
    deliverables:
      - "7-bag piece generator producing fair pseudo-random piece sequences"
      - "Piece spawning logic placing new tetrominoes at top center in hidden rows"
      - "Gravity timer that drops the current piece at level-dependent intervals"
      - "Left/right movement with DAS delay and ARR repeat rate"
      - "Soft drop (accelerated fall) and hard drop (instant placement) controls"
      - "Next-piece preview UI element"
    estimated_hours: "3-5"

  - id: tetris-m3
    name: Piece Rotation (SRS)
    description: >
      Implement piece rotation using the Super Rotation System (SRS) with
      proper wall-kick offset tables. The I-piece and O-piece require
      special handling.
    acceptance_criteria:
      - "Up arrow (or Z/X keys) rotates the current piece clockwise by one state"
      - "Rotation cycles through 4 states: 0→R→2→L→0"
      - "If basic rotation collides, up to 4 additional wall-kick offset positions are tested from the SRS table"
      - "J, L, S, T, Z pieces share one SRS offset table; the I-piece uses a separate, distinct offset table"
      - "O-piece does not rotate and remains in its single orientation"
      - "Wall kicks correctly handle rotation near left wall, right wall, and floor"
      - "T-spin detection is implemented: recognize when a T-piece locks after a rotation into a T-slot (optional but recommended)"
      - "All rotation tests pass for each piece type in each rotation direction from each starting state"
    pitfalls:
      - "Using a single wall-kick table for all pieces—I-piece has fundamentally different offsets"
      - "O-piece rotation causing position drift even though it should be identity"
      - "Rotating into the ceiling or into occupied cells above the visible area"
      - "Confusing clockwise vs counterclockwise rotation direction in offset table lookup"
      - "Not testing all 5 kick positions (basic + 4 offsets) before rejecting rotation"
    concepts:
      - SRS (Super Rotation System)
      - Wall-kick offset lookup tables
      - Rotation state transitions
    skills:
      - Implementing behavior from a formal specification
      - Complex collision handling with multiple fallback positions
      - Lookup table design and indexing
      - Exhaustive edge case testing
    deliverables:
      - "Rotation state machine cycling through 4 orientations per piece type"
      - "SRS offset table for J/L/S/T/Z pieces (5 tests per rotation transition)"
      - "Separate SRS offset table for the I-piece (5 tests per rotation transition)"
      - Wall-kick test logic: attempt basic rotation, then each offset in order, accept first valid position
      - "Comprehensive test suite verifying rotation in all states for all piece types"
    estimated_hours: "3-5"

  - id: tetris-m4
    name: "Lock Delay, Line Clearing & Scoring"
    description: >
      Implement lock delay before piece placement, line clearing with
      gravity, and a scoring system with level progression.
    acceptance_criteria:
      - "Lock delay: piece does not lock instantly on ground contact; a timer (e.g., 500ms) allows last-second moves/rotations"
      - "Lock delay resets on successful move or rotation (up to a maximum reset count, e.g., 15)"
      - "Filled rows are detected immediately after a piece locks into place"
      - "Filled rows are removed and all rows above shift down to fill gaps"
      - "Scoring follows a defined table: Single=100×level, Double=300×level, Triple=500×level, Tetris=800×level"
      - "Level increases every 10 lines cleared"
      - "Gravity speed increases with each level (e.g., from 1 cell/second at level 1 to 20 cells/second at level 15)"
      - "Line clear animation or visual feedback is displayed before rows collapse"
      - "Score, level, and lines-cleared counters are displayed in the UI"
    pitfalls:
      - "No lock delay makes high-speed levels unplayable—pieces lock on contact"
      - "Infinite lock delay resets allow indefinite stalling (must cap reset count)"
      - "Iterating rows top-to-bottom when clearing causes skipped rows—iterate bottom-to-top or rebuild array"
      - "Forgetting level multiplier in scoring (flat 100/300/500/800 ignores level)"
      - "Speed curve too aggressive—game becomes impossible before level 10"
      - "Not re-checking rows after gravity collapse (edge case: cascading clears)"
    concepts:
      - Lock delay mechanics
      - Row clearing and gravity
      - Scoring systems with level multiplier
      - Difficulty progression curves
    skills:
      - Array manipulation and row shifting
      - Timer management with reset logic
      - Game balance and progression tuning
      - Scoring algorithm implementation
      - UI state display
    deliverables:
      - "Lock delay timer with configurable duration and max reset count"
      - "Full line detection scanning each row for completely filled cells"
      - "Line removal logic clearing filled rows and shifting rows above downward"
      - Scoring system: points = base_score × current_level
      - "Level progression system increasing level every 10 lines"
      - "Gravity speed table mapping level to fall interval"
      - "UI displaying score, level, and lines cleared"
    estimated_hours: "3-5"

  - id: tetris-m5
    name: "Game Over, Restart & Polish"
    description: >
      Implement game-over detection, game state machine (menu, playing,
      paused, game-over), and final polish including hold piece.
    acceptance_criteria:
      - "Game over triggers when a newly spawned piece immediately collides with occupied cells"
      - "Game over screen displays final score, level, and lines cleared"
      - "Game state machine manages transitions: Menu → Playing → Paused → Game Over → Menu"
      - "Pause functionality freezes game state and hides the board (to prevent pausing to think)"
      - "Hold piece: player can swap current piece with held piece once per drop"
      - "Restart option resets all state (board, score, level, bag) without reloading"
      - "Ghost piece shows where the current piece would land if hard-dropped"
      - "Frame rate is stable at 60 FPS with game logic decoupled from render rate"
    pitfalls:
      - "Game over not checked at spawn—game continues with overlapping pieces"
      - "Hold piece allowing infinite swaps per drop (must limit to once per lock)"
      - "Ghost piece not updating after rotation or horizontal movement"
      - "Pause state not properly freezing timers—lock delay and gravity continue"
      - "State machine transitions allowing invalid paths (e.g., Paused → Menu skipping cleanup)"
    concepts:
      - Game state machines
      - Ghost piece projection
      - Hold piece mechanics
      - Game loop architecture
    skills:
      - State machine design and implementation
      - Game loop timing and decoupling
      - UI state management
      - Feature integration and polish
    deliverables:
      - "Game-over detection at piece spawn"
      - Game state machine: Menu, Playing, Paused, Game Over
      - "Hold piece functionality with once-per-drop restriction"
      - "Ghost piece rendering showing hard-drop landing position"
      - "Game over screen with final statistics"
      - "Restart functionality with full state reset"
    estimated_hours: "3-5"