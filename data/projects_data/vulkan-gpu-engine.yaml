id: vulkan-gpu-engine
name: Vulkan GPU Engine
description: >
  Build a high-performance graphics engine using the Vulkan API.
  Implement render passes, pipelines, descriptors, and compute shaders
  for modern GPU programming without abstraction overhead.

difficulty: expert
estimated_hours: 80-100
domain: game-dev

essence: >
  Explicit GPU control through Vulkan's low-level API: manual memory management,
  pipeline state objects, descriptor sets for resource binding, render passes
  for framebuffer configuration, and synchronization primitives for GPU scheduling.

why_important: >
  Vulkan is the modern graphics API for AAA games and professional applications.
  Understanding low-level GPU programming is valuable for graphics engineers at
  $150K-300K+ at game studios, GPU companies, and visualization companies.

learning_outcomes:
  - Set up Vulkan instance, device, and swapchain
  - Implement graphics pipeline with shaders
  - Manage GPU memory and buffers manually
  - Build descriptor sets for uniform and texture binding
  - Implement render passes and framebuffers
  - Handle synchronization with fences and semaphores
  - Implement compute shaders for GPU compute
  - Optimize rendering with command buffer batching

skills:
  - Vulkan API
  - GPU Programming
  - Memory Management
  - Pipeline Configuration
  - Descriptor Sets
  - Render Passes
  - GPU Synchronization
  - Compute Shaders

tags:
  - expert
  - vulkan
  - graphics
  - gpu-programming
  - game-engine
  - rendering

languages:
  recommended:
    - C++
    - Rust
  also_possible:
    - C

resources:
  - name: "Vulkan Tutorial"
    url: https://vulkan-tutorial.com/
    type: tutorial
  - name: "Vulkan Specification"
    url: https://www.khronos.org/registry/vulkan/
    type: documentation
  - name: "GPU Gems"
    url: https://developer.nvidia.com/gpugems/GPUGems/gpugems_pref01.html
    type: book
  - name: "Sascha Willems Vulkan Examples"
    url: https://github.com/SaschaWillems/Vulkan
    type: code

prerequisites:
  - type: skill
    name: C++ or Rust proficiency
  - type: skill
    name: Understanding of 3D graphics concepts
  - type: skill
    name: Linear algebra for transformations
  - type: project
    name: software-3d or equivalent graphics experience

milestones:
  - id: vulkan-m1
    name: Instance, Device & Swapchain
    description: >
      Set up the foundational Vulkan objects: instance, physical device,
      logical device, and swapchain for presentation.
    acceptance_criteria:
      - Vulkan instance created with required extensions
      - Physical device selected with queue family support
      - Logical device created with graphics and present queues
      - Swapchain created with proper format and extent
      - Image views created for each swapchain image
      - Validation layers enabled in debug builds
    pitfalls:
      - Missing extensions cause creation failure
      - Not all devices support present queue
      - Swapchain extent must match window size
      - Forgetting to enable validation in debug
    concepts:
      - Vulkan instance
      - Device selection
      - Queue families
      - Swapchain creation
    skills:
      - Vulkan setup
      - Device management
      - Extension handling
      - Debug configuration
    deliverables:
      - Vulkan instance
      - Device and queues
      - Swapchain
      - Image views
    estimated_hours: "14-18"

  - id: vulkan-m2
    name: Graphics Pipeline & Shaders
    description: >
      Create graphics pipeline with vertex and fragment shaders,
      including pipeline layout and render pass configuration.
    acceptance_criteria:
      - Vertex shader transforms vertices to clip space
      - Fragment shader outputs color per pixel
      - Pipeline layout defines descriptor set layouts
      - Render pass describes attachment usage
      - Pipeline combines shaders, layout, and render pass
      - Triangle renders correctly to screen
    pitfalls:
      - Shader compilation errors often silent
      - Mismatched descriptor layout causes crash
      - Render pass compatibility with pipeline
      - Vertex format mismatch with shader
    concepts:
      - Shader modules
      - Pipeline layout
      - Render passes
      - Pipeline state
    skills:
      - Shader compilation
      - Pipeline creation
      - Render pass setup
      - State configuration
    deliverables:
      - Vertex/fragment shaders
      - Pipeline layout
      - Render pass
      - Graphics pipeline
    estimated_hours: "16-20"

  - id: vulkan-m3
    name: Buffers & Memory Management
    description: >
      Implement GPU buffer creation and memory allocation for
      vertex and index data.
    acceptance_criteria:
      - Vertex buffer created with appropriate size and usage
      - Index buffer for efficient rendering
      - Device memory allocated and bound to buffers
      - Staging buffer for host-visible memory
      - Memory copy from host to device-local memory
      - Buffer correctly bound in command buffer
    pitfalls:
      - Device-local memory faster but not host-visible
      - Memory type selection is device-dependent
      - Buffer alignment requirements
      - Not unmapping mapped memory
    concepts:
      - Buffer creation
      - Memory allocation
      - Staging buffers
      - Memory types
    skills:
      - Buffer management
      - Memory allocation
      - Staging pattern
      - Copy operations
    deliverables:
      - Vertex buffer
      - Index buffer
      - Staging buffer
      - Memory allocation
    estimated_hours: "14-18"

  - id: vulkan-m4
    name: Descriptors & Uniforms
    description: >
      Implement descriptor sets for binding uniform buffers
      and textures to shaders.
    acceptance_criteria:
      - Descriptor set layout defines binding points
      - Descriptor pool allocates descriptor sets
      - Uniform buffer for transformation matrices
      - Texture sampler for image sampling
      - Descriptor sets updated with resources
      - Descriptor sets bound before draw calls
    pitfalls:
      - Descriptor pool size must match usage
      - Binding mismatch between layout and shader
      - Not updating descriptors after allocation
      - Texture format support varies by device
    concepts:
      - Descriptor layouts
      - Descriptor pools
      - Uniform buffers
      - Texture sampling
    skills:
      - Descriptor management
      - Uniform binding
      - Texture handling
      - Resource binding
    deliverables:
      - Descriptor set layout
      - Descriptor pool
      - Uniform buffer
      - Texture support
    estimated_hours: "14-18"

  - id: vulkan-m5
    name: Synchronization & Rendering Loop
    description: >
      Implement proper GPU synchronization and the main
      rendering loop with command buffers.
    acceptance_criteria:
      - Semaphores synchronize between frames
      - Fences synchronize CPU with GPU
      - Command buffer recorded with draw commands
      - Double or triple buffering for smooth rendering
      - Swapchain image acquisition and presentation
      - Proper cleanup of synchronization objects
    pitfalls:
      - Using same command buffer while GPU executing
      - Not waiting for fence before reusing resources
      - Swapchain suboptimal or outdated handling
      - Semaphore ordering mistakes
    concepts:
      - GPU synchronization
      - Semaphores
      - Fences
      - Command buffers
    skills:
      - Synchronization
      - Command recording
      - Double buffering
      - Present handling
    deliverables:
      - Semaphore management
      - Fence handling
      - Command buffer recording
      - Render loop
    estimated_hours: "14-18"

  - id: vulkan-m6
    name: Compute Shaders
    description: >
      Implement compute shaders for GPU compute operations
      beyond traditional graphics.
    acceptance_criteria:
      - Compute pipeline created with compute shader
      - Compute queue separate from graphics queue (optional)
      - Storage buffers for compute input/output
      - Work group dispatch with proper dimensions
      - Memory barriers between compute and graphics
      - Example: particle simulation or image processing
    pitfalls:
      - Compute shader work group size limits
      - Memory barriers required for data visibility
      - Not all devices support compute queue
      - Shared memory size limits
    concepts:
      - Compute pipelines
      - Storage buffers
      - Work groups
      - Memory barriers
    skills:
      - Compute shaders
      - GPU compute
      - Barrier handling
      - GPGPU patterns
    deliverables:
      - Compute pipeline
      - Storage buffers
      - Compute dispatch
      - Example application
    estimated_hours: "10-14"
