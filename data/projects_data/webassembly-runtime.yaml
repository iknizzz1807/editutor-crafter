id: webassembly-runtime
name: WebAssembly Runtime
description: >
  Build a WebAssembly runtime from scratch, implementing binary parsing,
  validation, interpretation, and JIT compilation to native code.

difficulty: expert
estimated_hours: 80-100
domain: specialized

essence: >
  Binary format parsing and validation per the W3C specification, stack-based
  virtual machine execution, control flow handling (blocks, loops, branches),
  memory and table management, and JIT compilation with optimization passes
  for near-native execution speed.

why_important: >
  WebAssembly is transforming web development, edge computing, and serverless
  platforms. Runtime engineers are in demand at $180K-350K+ at browser vendors,
  CDN companies, and platforms building WASM-based infrastructure.

learning_outcomes:
  - Parse WebAssembly binary format (modules, sections, instructions)
  - Implement module validation per specification
  - Build stack-based WASM interpreter
  - Implement control flow (block, loop, br, br_if, br_table)
  - Handle memory operations and bounds checking
  - Implement function calls and indirect calls
  - Build basic JIT compilation pipeline
  - Implement WASI (WebAssembly System Interface) basics

skills:
  - Binary Format Parsing
  - Virtual Machine Design
  - Interpreter Implementation
  - JIT Compilation
  - Control Flow Handling
  - Memory Management
  - Type Validation
  - WASI Implementation

tags:
  - compilation
  - expert
  - interpreter
  - jit
  - runtime
  - virtual-machine
  - wasm
  - webassembly

languages:
  recommended:
    - Rust
    - C++
    - Go
  also_possible:
    - C
    - Zig

resources:
  - name: "WebAssembly Specification"
    url: https://webassembly.github.io/spec/
    type: documentation
  - name: "Wasmtime Runtime"
    url: https://github.com/bytecodealliance/wasmtime
    type: reference
  - name: "WebAssembly from Scratch"
    url: https://depth-first.com/articles/2020/05/19/webassembly-from-scratch/
    type: tutorial
  - name: "WASI Specification"
    url: https://wasi.dev/
    type: documentation

prerequisites:
  - type: project
    id: bytecode-vm
    name: Bytecode VM
  - type: skill
    name: Binary format parsing experience
  - type: skill
    name: Understanding of stack machines
  - type: skill
    name: Systems programming

milestones:
  - id: webassembly-runtime-m1
    name: Binary Parsing & Validation
    description: >
      Implement WebAssembly binary format parsing and module validation
      according to the specification.
    acceptance_criteria:
      - Parses all standard sections: type, import, function, table, memory, global, export, start, element, code, data
      - Handles LEB128 integer encoding correctly
      - Validates type signatures for functions
      - Validates instruction sequences (type checking)
      - Detects malformed modules and reports specific errors
      - Parses real WASM modules compiled from C/Rust
      - Memory-efficient parsing without unnecessary allocations
    pitfalls:
      - LEB128 encoding has multiple valid representations; must handle all
      - Section ordering matters for validation
      - Import resolution happens after parsing; track unresolved imports
      - Instruction validation requires type stack simulation
      - Some instructions have immediate arguments; parsing order matters
    concepts:
      - WebAssembly binary format
      - LEB128 encoding
      - Module structure and sections
      - Static validation rules
    skills:
      - Binary parsing
      - LEB128 handling
      - Module validation
      - Error reporting
    deliverables:
      - WASM binary parser
      - Module structure representation
      - Validation pass implementation
      - Test suite with valid and invalid modules
      - Parser benchmark
    estimated_hours: "16-18"

  - id: webassembly-runtime-m2
    name: Stack Machine Interpreter
    description: >
      Build a stack-based interpreter for WebAssembly instructions
      with proper control flow handling.
    acceptance_criteria:
      - Executes numeric operations: i32/i64/f32/f64 arithmetic, comparisons
      - Stack operations: local.get/set/tee, global.get/set
      - Memory operations: load/store with bounds checking
      - Control flow: block, loop, br, br_if, br_table
      - Function calls: call, call_indirect with table lookup
      - Handles all core instruction opcodes
      - Correct stack polymorphism at unreachable code
      - Executes compiled modules and produces correct results
    pitfalls:
      - Stack values are typed; implicit conversions are errors
      - br_table jump table can be large; efficient implementation needed
      - call_indirect requires type check at runtime
      - Memory bounds checking on every access impacts performance
      - Unreachable code has different typing rules (stack polymorphism)
    concepts:
      - Stack machine execution
      - Control flow in stack machines
      - Memory addressing and bounds
      - Indirect calls and tables
    skills:
      - Interpreter implementation
      - Control flow handling
      - Memory safety
      - Table management
    deliverables:
      - Instruction interpreter
      - Control flow handling (blocks, branches)
      - Memory operations with bounds checking
      - Function call implementation
      - Test suite with execution verification
    estimated_hours: "18-20"

  - id: webassembly-runtime-m3
    name: Memory & Table Management
    description: >
      Implement WebAssembly linear memory and table management
      with grow operations and import/export handling.
    acceptance_criteria:
      - Linear memory allocation with configurable limits (min/max pages)
      - Memory.grow implementation with proper return values
      - Memory copy/fill instructions (memory.copy, memory.fill)
      - Table management for function references
      - Table.grow for dynamic function registration
      - Import handling for memory and tables from host
      - Export resolution for host access to WASM memory
      - Multiple memory support (multi-memory proposal)
    pitfalls:
      - Memory.grow can fail; must return -1 on failure
      - Page size is fixed at 64KB
      - Table elements are function references; type safety required
      - Import vs defined memory/table have different initialization
      - Memory initialization from data sections happens at instantiation
    concepts:
      - Linear memory model
      - Memory growth and limits
      - Function tables
      - Import/export system
    skills:
      - Memory management
      - Table implementation
      - Import resolution
      - Multi-memory handling
    deliverables:
      - Linear memory implementation
      - Memory.grow and bounds handling
      - Table management
      - Import/export system
      - Data/element section initialization
    estimated_hours: "14-16"

  - id: webassembly-runtime-m4
    name: JIT Compilation
    description: >
      Implement just-in-time compilation from WebAssembly to
      native machine code with basic optimizations.
    acceptance_criteria:
      - Translates WASM instructions to native code (x86-64 or ARM64)
      - Register allocation for native code generation
      - Basic optimizations: constant folding, dead code elimination
      - Control flow translation: blocks, loops, branches
      - Inline caching for indirect calls
      - JIT-compiled code runs faster than interpreter (2x+ improvement)
      - Supports lazy compilation (compile on first call)
      - Handles code patching for lazy compilation
    pitfalls:
      - Register allocation is NP-complete; use simple algorithm initially
      - Branch target resolution requires forward references
      - Inline caching invalidation when table is modified
      - Code patching requires memory to be writable then executable
      - Stack overflow handling in JIT code requires coordination
    concepts:
      - Code generation
      - Register allocation
      - Basic optimizations
      - Inline caching
    skills:
      - Code generation
      - Register allocation
      - Optimization passes
      - Runtime patching
    deliverables:
      - WASM to native code translator
      - Register allocator
      - Basic optimization passes
      - Inline cache for indirect calls
      - Performance comparison: interpreter vs JIT
    estimated_hours: "20-24"

  - id: webassembly-runtime-m5
    name: WASI & Host Integration
    description: >
      Implement WASI (WebAssembly System Interface) for file I/O,
      networking, and system calls, plus host function integration.
    acceptance_criteria:
      - WASI fd_write for console output
      - WASI fd_read for console input
      - WASI path_open for file access
      - WASI args_get for command-line arguments
      - WASI environ_get for environment variables
      - Host function registration and calling convention
      - Host-to-WASM and WASM-to-host value conversion
      - Sandboxed file system access with preopened directories
    pitfalls:
      - WASI capabilities must be explicitly granted (capability-based security)
      - File descriptor management differs from POSIX
      - Host functions can trap; error handling required
      - String passing requires memory coordination
      - Async operations in WASI require special handling
    concepts:
      - WASI system interface
      - Host function integration
      - Capability-based security
      - Cross-language calling conventions
    skills:
      - WASI implementation
      - Host binding generation
      - Memory sharing protocols
      - Security sandboxing
    deliverables:
      - Core WASI functions implementation
      - Host function registration system
      - Value conversion layer
      - Sandboxed file system
      - Demo: run compiled C program with I/O
    estimated_hours: "14-16"
