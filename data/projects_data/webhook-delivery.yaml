id: webhook-delivery
name: Webhook Delivery System
description: Reliable webhook dispatch with HMAC signing, exponential backoff retries, circuit breaker protection, and event replay capability.
difficulty: advanced
estimated_hours: 40
essence: Asynchronous message delivery orchestration across unreliable networks with guaranteed at-least-once semantics, implementing idempotent processing through event ID tracking, cryptographic payload verification via HMAC-SHA256, and fault tolerance through exponential backoff retry strategies with circuit breaker state machines to prevent cascading failures when downstream endpoints become unresponsive.
why_important: 'Building this teaches critical production engineering skills for distributed systems: implementing fault-tolerant message delivery, protecting downstream services from cascading failures, handling head-of-line blocking in ordered queues, and securing inter-service communication - capabilities essential for backend infrastructure at scale.'
learning_outcomes:
- Implement HMAC-SHA256 signature generation with timestamp inclusion for replay attack prevention
- Design retry logic with exponential backoff, jitter, and dead letter queues for guaranteed delivery
- Build circuit breaker pattern with closed, open, and half-open states to protect failing endpoints
- Implement rate limiting respecting downstream Retry-After headers to prevent overwhelming receivers
- Design idempotent event processing using event IDs to handle at-least-once delivery guarantees
- Build persistent event log with replay capability for debugging and recovery scenarios
- Implement async queue-based processing with worker pools and head-of-line blocking mitigation
- Prevent SSRF attacks through URL validation blocking private/internal IP ranges
skills:
- Message Queue Architecture
- Exponential Backoff Strategies
- Circuit Breaker Pattern
- HMAC Cryptographic Signing
- Idempotent Delivery Design
- Fault Tolerance Engineering
- SSRF Prevention
- Rate Limiting & Throttling
tags:
- advanced
- async
- cryptography
- delivery
- events
- fault-tolerance
- reliability
- retry
- signing
- webhooks
architecture_doc: architecture-docs/webhook-delivery/index.md
languages:
  recommended:
  - Python
  - Go
  - Rust
  also_possible: []
resources:
- name: RabbitMQ Tutorials
  url: https://www.rabbitmq.com/tutorials
  type: documentation
- name: Circuit Breaker Pattern
  url: https://martinfowler.com/bliki/CircuitBreaker.html
  type: article
- name: HMAC Webhook Verification
  url: https://hookdeck.com/webhooks/guides/how-to-implement-sha256-webhook-signature-verification
  type: tutorial
- name: AWS Retry with Backoff
  url: https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/retry-backoff.html
  type: documentation
- name: Standard Webhooks Specification
  url: https://www.standardwebhooks.com/
  type: documentation
prerequisites:
- type: skill
  name: Message queue / pub-sub basics
- type: project
  id: http-server-basic
  name: HTTP Server (Basic)
milestones:
- id: webhook-delivery-m1
  name: Webhook Registration & Security
  description: Implement webhook endpoint registration with HMAC signing, SSRF prevention, and endpoint ownership verification.
  acceptance_criteria:
  - Endpoint registration accepts a callback URL and list of subscribed event types; a cryptographically random signing secret (256-bit minimum) is generated and returned once
  - 'Registered URLs are validated against an SSRF blocklist rejecting private IP ranges (10.x, 172.16-31.x, 192.168.x, 127.x, 169.254.x, : :1, fc00::/7) and non-HTTPS schemes'
  - Endpoint ownership is verified by sending a challenge request with a random token; only endpoints that echo back the token within 10 seconds are activated
  - Unverified endpoints cannot receive any webhook deliveries; delivery queue rejects events for unverified endpoints
  - HMAC-SHA256 signature is computed over 'timestamp.payload' and included in the X-Webhook-Signature header along with the timestamp
  - Secret rotation creates a new secret while keeping the old secret valid for a configurable overlap window (default 24 hours); both secrets are accepted for verification during the window
  - Webhook payload includes a unique event ID, event type, timestamp, and the event data body
  pitfalls:
  - HTTPS only - never deliver webhooks over plain HTTP; this leaks signatures and payload data in transit
  - SSRF via webhook registration is a real attack vector - always resolve the URL and check the resolved IP against blocklists, not just the hostname
  - DNS rebinding can bypass hostname-based SSRF checks - resolve the IP at registration time AND at delivery time
  - Signing secret rotation requires accepting both old and new secrets during the overlap window; cutting over instantly breaks in-flight deliveries
  - Timestamp in the signature prevents replay attacks but requires the receiver to validate the timestamp is within tolerance (e.g., 5 minutes)
  concepts:
  - HMAC-SHA256 signature generation over timestamp-prefixed payload
  - SSRF prevention via IP blocklist and DNS resolution validation
  - Endpoint ownership verification via challenge-response
  - Secret rotation with overlapping validity periods
  - Timestamp-based replay attack prevention
  skills:
  - HMAC signatures
  - SSRF prevention
  - Endpoint validation
  - Secret management
  deliverables:
  - Endpoint registration API with URL validation, event type subscription, and secret generation
  - SSRF prevention module blocking private/internal IP ranges at registration and delivery time
  - Challenge-response ownership verification with timeout enforcement
  - HMAC-SHA256 signature generator computing over timestamp-prefixed payload
  - Secret rotation mechanism with configurable overlap window accepting both old and new secrets
  estimated_hours: 9
- id: webhook-delivery-m2
  name: Delivery Queue & Retry Logic
  description: Implement reliable delivery with exponential backoff, response-aware retry decisions, dead letter queue, and head-of-line blocking mitigation.
  acceptance_criteria:
  - Events are queued for delivery with per-endpoint parallelism (configurable concurrency limit per endpoint, default 5)
  - Delivery attempts POST the signed payload to the registered URL with a 10-second connection timeout and 30-second read timeout
  - Successful delivery (2xx response) marks the event as delivered and records the response code and latency
  - 5xx responses and network timeouts trigger retry with exponential backoff (base 2s, factor 2, jitter Â±25%, max delay 1 hour, max 8 attempts)
  - 4xx responses (except 429) are treated as permanent failures - no retry, event moves directly to dead letter queue
  - HTTP 429 responses honor the Retry-After header for the next retry delay
  - Events that exhaust all retry attempts are moved to a dead letter queue with full attempt history
  - Head-of-line blocking is mitigated by allowing events to be delivered out of order when earlier events are in retry; per-endpoint event ordering is NOT guaranteed
  - Each delivery attempt is recorded with HTTP status code, response time, error message, and attempt number
  pitfalls:
  - Jitter is essential to prevent thundering herd when many webhooks fail simultaneously and retry at the same time
  - 4xx errors (except 429) indicate a client-side problem that retrying won't fix - retrying wastes resources and delays other deliveries
  - Dead letter queue must have monitoring and alerting - events there are lost revenue or broken integrations if nobody notices
  - 'Strict per-endpoint ordering creates head-of-line blocking - if event #1 is retrying for hours, events #2-#100 are stuck. Use unordered delivery with event timestamps for receiver-side ordering'
  - Delivery timeout must be shorter than queue visibility timeout to prevent duplicate delivery from queue reprocessing
  concepts:
  - Exponential backoff with full jitter for retry scheduling
  - HTTP status code classification for retry decisions (retriable vs terminal)
  - Dead letter queue pattern for undeliverable messages
  - Head-of-line blocking and mitigation via unordered per-endpoint delivery
  - Queue visibility timeout and delivery timeout coordination
  skills:
  - Retry strategies
  - Exponential backoff with jitter
  - Dead letter queues
  - Head-of-line blocking mitigation
  deliverables:
  - Delivery queue with per-endpoint concurrency control (configurable parallelism limit)
  - HTTP delivery client with configurable connection and read timeouts
  - Retry scheduler with exponential backoff, jitter, and response-aware retry decisions
  - Dead letter queue for permanently failed deliveries with full attempt history
  - Delivery attempt logger recording status code, latency, error, and attempt number
  estimated_hours: 10
- id: webhook-delivery-m3
  name: Circuit Breaker & Rate Limiting
  description: Implement per-endpoint circuit breaker to protect failing endpoints and rate limiting to prevent overwhelming receivers.
  acceptance_criteria:
  - Circuit breaker per endpoint transitions from closed to open after N consecutive failures (configurable, default 10)
  - Open circuit stops all delivery attempts and alerts the webhook owner via notification
  - After a configurable timeout (default 60 seconds), circuit transitions to half-open allowing 1 test delivery
  - Successful test delivery in half-open state closes the circuit; failure reopens it with an increased timeout (2x previous, max 1 hour)
  - Rate limiting caps delivery rate per endpoint (configurable, default 100/minute) using token bucket algorithm
  - When receiver returns HTTP 429 with Retry-After header, the rate limiter respects the specified delay
  - Events queued during open circuit or rate limiting are buffered, not dropped; they are delivered when the circuit closes or rate limit clears
  - Endpoint health dashboard shows current circuit state, success rate, average latency, and rate limit status per endpoint
  pitfalls:
  - Half-open state should only allow a single test request (or very few), not full traffic - premature full load on a recovering endpoint causes immediate re-failure
  - Circuit breaker timeout should increase on repeated failures (exponential backoff on the circuit itself) to avoid hammering unstable endpoints
  - Rate limiting must respect Retry-After headers from the receiver - ignoring them risks getting IP-blocked
  - Always alert when a circuit opens - the endpoint owner needs to know their integration is broken
  - Events buffered during open circuit can create a burst when the circuit closes - apply rate limiting to the burst
  concepts:
  - Circuit breaker state transitions (closed -> open -> half-open -> closed)
  - Token bucket rate limiting algorithm
  - HTTP 429 and Retry-After header semantics
  - Endpoint health probe with limited traffic during half-open
  - Back-pressure handling during circuit open state
  skills:
  - Circuit breaker pattern
  - Rate limiting
  - Health monitoring
  - Back-pressure
  deliverables:
  - Per-endpoint circuit breaker with configurable failure threshold and timeout
  - Token bucket rate limiter with configurable rate per endpoint
  - Retry-After header parser and rate limit adjustment
  - Circuit state transition logic with exponential timeout increase on repeated failures
  - Endpoint health tracking with success rate, latency, and circuit state
  - Owner notification on circuit open events
  estimated_hours: 10
- id: webhook-delivery-m4
  name: Event Log, Replay & Observability
  description: Implement event logging for debugging, replay capability for recovery, and delivery observability metrics.
  acceptance_criteria:
  - Every event is stored with full payload, all delivery attempts (status, latency, error), and final disposition (delivered, failed, dead-lettered)
  - Manual replay of a specific event re-queues it for delivery with the original event ID (for receiver deduplication) but a new delivery attempt ID
  - Bulk replay supports re-delivering all events in a time range or matching an event type filter, respecting per-endpoint rate limits
  - Event log has configurable retention (default 30 days) with automatic archival of older events to cold storage
  - 'Delivery metrics are tracked in real-time: delivery success rate, p50/p95/p99 latency, retry rate, dead letter rate, per endpoint'
  - Debugging view for a specific event shows the complete delivery timeline with request/response headers and bodies for each attempt
  - Replay warns the user that payload data may be stale if the event is older than a configurable threshold (default 24 hours)
  pitfalls:
  - Event log grows unboundedly without retention policies - implement TTL-based cleanup and cold storage archival
  - Replay must reuse the original event ID so receivers can deduplicate, but use a new delivery attempt ID for tracking
  - Bulk replay can overwhelm endpoints - always respect rate limits and circuit breaker state during replay
  - Stale payload on replay can cause incorrect state at the receiver - warn users and consider allowing payload override
  - Storing full request/response bodies for debugging consumes significant storage - consider compression and selective retention
  concepts:
  - Event sourcing for complete delivery audit trail
  - Event ID vs delivery attempt ID distinction for deduplication
  - Log retention policies with TTL and cold storage archival
  - Real-time metrics aggregation for delivery observability
  - Replay rate limiting to prevent endpoint overload
  skills:
  - Event sourcing
  - Log retention
  - Event replay
  - Observability metrics
  deliverables:
  - Persistent event log with payload, attempt history, and final disposition
  - Single-event replay API re-queuing with original event ID and new attempt ID
  - Bulk replay API with time range and event type filters, rate-limited
  - Retention and archival job moving events older than TTL to cold storage
  - Delivery metrics dashboard showing success rate, latency percentiles, and error rates per endpoint
  - Event debugging view with full request/response timeline for each delivery attempt
  estimated_hours: 11
domain: specialized
